// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20221001

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/insights/v1api20221001/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/insights/v1api20221001/storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /monitor/resource-manager/Microsoft.Insights/stable/2022-10-01/autoscale_API.json
// - ARM URI: /subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Insights/autoscalesettings/{autoscaleSettingName}
type AutoscaleSetting struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              AutoscaleSetting_Spec   `json:"spec,omitempty"`
	Status            Autoscalesetting_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &AutoscaleSetting{}

// GetConditions returns the conditions of the resource
func (setting *AutoscaleSetting) GetConditions() conditions.Conditions {
	return setting.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (setting *AutoscaleSetting) SetConditions(conditions conditions.Conditions) {
	setting.Status.Conditions = conditions
}

var _ conversion.Convertible = &AutoscaleSetting{}

// ConvertFrom populates our AutoscaleSetting from the provided hub AutoscaleSetting
func (setting *AutoscaleSetting) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.AutoscaleSetting)
	if !ok {
		return fmt.Errorf("expected insights/v1api20221001/storage/AutoscaleSetting but received %T instead", hub)
	}

	return setting.AssignProperties_From_AutoscaleSetting(source)
}

// ConvertTo populates the provided hub AutoscaleSetting from our AutoscaleSetting
func (setting *AutoscaleSetting) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.AutoscaleSetting)
	if !ok {
		return fmt.Errorf("expected insights/v1api20221001/storage/AutoscaleSetting but received %T instead", hub)
	}

	return setting.AssignProperties_To_AutoscaleSetting(destination)
}

// +kubebuilder:webhook:path=/mutate-insights-azure-com-v1api20221001-autoscalesetting,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=insights.azure.com,resources=autoscalesettings,verbs=create;update,versions=v1api20221001,name=default.v1api20221001.autoscalesettings.insights.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &AutoscaleSetting{}

// Default applies defaults to the AutoscaleSetting resource
func (setting *AutoscaleSetting) Default() {
	setting.defaultImpl()
	var temp any = setting
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (setting *AutoscaleSetting) defaultAzureName() {
	if setting.Spec.AzureName == "" {
		setting.Spec.AzureName = setting.Name
	}
}

// defaultImpl applies the code generated defaults to the AutoscaleSetting resource
func (setting *AutoscaleSetting) defaultImpl() { setting.defaultAzureName() }

var _ configmaps.Exporter = &AutoscaleSetting{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (setting *AutoscaleSetting) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if setting.Spec.OperatorSpec == nil {
		return nil
	}
	return setting.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &AutoscaleSetting{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (setting *AutoscaleSetting) SecretDestinationExpressions() []*core.DestinationExpression {
	if setting.Spec.OperatorSpec == nil {
		return nil
	}
	return setting.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &AutoscaleSetting{}

// InitializeSpec initializes the spec for this resource from the given status
func (setting *AutoscaleSetting) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*Autoscalesetting_STATUS); ok {
		return setting.Spec.Initialize_From_Autoscalesetting_STATUS(s)
	}

	return fmt.Errorf("expected Status of type Autoscalesetting_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &AutoscaleSetting{}

// AzureName returns the Azure name of the resource
func (setting *AutoscaleSetting) AzureName() string {
	return setting.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2022-10-01"
func (setting AutoscaleSetting) GetAPIVersion() string {
	return "2022-10-01"
}

// GetResourceScope returns the scope of the resource
func (setting *AutoscaleSetting) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (setting *AutoscaleSetting) GetSpec() genruntime.ConvertibleSpec {
	return &setting.Spec
}

// GetStatus returns the status of this resource
func (setting *AutoscaleSetting) GetStatus() genruntime.ConvertibleStatus {
	return &setting.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (setting *AutoscaleSetting) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Insights/autoscalesettings"
func (setting *AutoscaleSetting) GetType() string {
	return "Microsoft.Insights/autoscalesettings"
}

// NewEmptyStatus returns a new empty (blank) status
func (setting *AutoscaleSetting) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &Autoscalesetting_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (setting *AutoscaleSetting) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(setting.Spec)
	return setting.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (setting *AutoscaleSetting) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*Autoscalesetting_STATUS); ok {
		setting.Status = *st
		return nil
	}

	// Convert status to required version
	var st Autoscalesetting_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	setting.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-insights-azure-com-v1api20221001-autoscalesetting,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=insights.azure.com,resources=autoscalesettings,verbs=create;update,versions=v1api20221001,name=validate.v1api20221001.autoscalesettings.insights.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &AutoscaleSetting{}

// ValidateCreate validates the creation of the resource
func (setting *AutoscaleSetting) ValidateCreate() (admission.Warnings, error) {
	validations := setting.createValidations()
	var temp any = setting
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	return genruntime.ValidateCreate(validations)
}

// ValidateDelete validates the deletion of the resource
func (setting *AutoscaleSetting) ValidateDelete() (admission.Warnings, error) {
	validations := setting.deleteValidations()
	var temp any = setting
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	return genruntime.ValidateDelete(validations)
}

// ValidateUpdate validates an update of the resource
func (setting *AutoscaleSetting) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	validations := setting.updateValidations()
	var temp any = setting
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	return genruntime.ValidateUpdate(old, validations)
}

// createValidations validates the creation of the resource
func (setting *AutoscaleSetting) createValidations() []func() (admission.Warnings, error) {
	return []func() (admission.Warnings, error){setting.validateResourceReferences, setting.validateOwnerReference, setting.validateSecretDestinations, setting.validateConfigMapDestinations}
}

// deleteValidations validates the deletion of the resource
func (setting *AutoscaleSetting) deleteValidations() []func() (admission.Warnings, error) {
	return nil
}

// updateValidations validates the update of the resource
func (setting *AutoscaleSetting) updateValidations() []func(old runtime.Object) (admission.Warnings, error) {
	return []func(old runtime.Object) (admission.Warnings, error){
		func(old runtime.Object) (admission.Warnings, error) {
			return setting.validateResourceReferences()
		},
		setting.validateWriteOnceProperties,
		func(old runtime.Object) (admission.Warnings, error) {
			return setting.validateOwnerReference()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return setting.validateSecretDestinations()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return setting.validateConfigMapDestinations()
		},
	}
}

// validateConfigMapDestinations validates there are no colliding genruntime.ConfigMapDestinations
func (setting *AutoscaleSetting) validateConfigMapDestinations() (admission.Warnings, error) {
	if setting.Spec.OperatorSpec == nil {
		return nil, nil
	}
	return configmaps.ValidateDestinations(setting, nil, setting.Spec.OperatorSpec.ConfigMapExpressions)
}

// validateOwnerReference validates the owner field
func (setting *AutoscaleSetting) validateOwnerReference() (admission.Warnings, error) {
	return genruntime.ValidateOwner(setting)
}

// validateResourceReferences validates all resource references
func (setting *AutoscaleSetting) validateResourceReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindResourceReferences(&setting.Spec)
	if err != nil {
		return nil, err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateSecretDestinations validates there are no colliding genruntime.SecretDestination's
func (setting *AutoscaleSetting) validateSecretDestinations() (admission.Warnings, error) {
	if setting.Spec.OperatorSpec == nil {
		return nil, nil
	}
	return secrets.ValidateDestinations(setting, nil, setting.Spec.OperatorSpec.SecretExpressions)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (setting *AutoscaleSetting) validateWriteOnceProperties(old runtime.Object) (admission.Warnings, error) {
	oldObj, ok := old.(*AutoscaleSetting)
	if !ok {
		return nil, nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, setting)
}

// AssignProperties_From_AutoscaleSetting populates our AutoscaleSetting from the provided source AutoscaleSetting
func (setting *AutoscaleSetting) AssignProperties_From_AutoscaleSetting(source *storage.AutoscaleSetting) error {

	// ObjectMeta
	setting.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec AutoscaleSetting_Spec
	err := spec.AssignProperties_From_AutoscaleSetting_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_AutoscaleSetting_Spec() to populate field Spec")
	}
	setting.Spec = spec

	// Status
	var status Autoscalesetting_STATUS
	err = status.AssignProperties_From_Autoscalesetting_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_Autoscalesetting_STATUS() to populate field Status")
	}
	setting.Status = status

	// No error
	return nil
}

// AssignProperties_To_AutoscaleSetting populates the provided destination AutoscaleSetting from our AutoscaleSetting
func (setting *AutoscaleSetting) AssignProperties_To_AutoscaleSetting(destination *storage.AutoscaleSetting) error {

	// ObjectMeta
	destination.ObjectMeta = *setting.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.AutoscaleSetting_Spec
	err := setting.Spec.AssignProperties_To_AutoscaleSetting_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_AutoscaleSetting_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.Autoscalesetting_STATUS
	err = setting.Status.AssignProperties_To_Autoscalesetting_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_Autoscalesetting_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (setting *AutoscaleSetting) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: setting.Spec.OriginalVersion(),
		Kind:    "AutoscaleSetting",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /monitor/resource-manager/Microsoft.Insights/stable/2022-10-01/autoscale_API.json
// - ARM URI: /subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Insights/autoscalesettings/{autoscaleSettingName}
type AutoscaleSettingList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []AutoscaleSetting `json:"items"`
}

// +kubebuilder:validation:Enum={"2022-10-01"}
type APIVersion string

const APIVersion_Value = APIVersion("2022-10-01")

type AutoscaleSetting_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// Enabled: the enabled flag. Specifies whether automatic scaling is enabled for the resource. The default value is 'false'.
	Enabled *bool `json:"enabled,omitempty"`

	// +kubebuilder:validation:Required
	// Location: Resource location
	Location *string `json:"location,omitempty"`

	// Name: the name of the autoscale setting.
	Name *string `json:"name,omitempty"`

	// Notifications: the collection of notifications.
	Notifications []AutoscaleNotification `json:"notifications,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *AutoscaleSettingOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// PredictiveAutoscalePolicy: the predictive autoscale policy mode.
	PredictiveAutoscalePolicy *PredictiveAutoscalePolicy `json:"predictiveAutoscalePolicy,omitempty"`

	// +kubebuilder:validation:Required
	// +kubebuilder:validation:MaxItems=20
	// Profiles: the collection of automatic scaling profiles that specify different scaling parameters for different time
	// periods. A maximum of 20 profiles can be specified.
	Profiles []AutoscaleProfile `json:"profiles,omitempty"`

	// Tags: Gets or sets a list of key value pairs that describe the resource. These tags can be used in viewing and grouping
	// this resource (across resource groups). A maximum of 15 tags can be provided for a resource. Each tag must have a key no
	// greater in length than 128 characters and a value no greater in length than 256 characters.
	Tags map[string]string `json:"tags,omitempty"`

	// TargetResourceLocation: the location of the resource that the autoscale setting should be added to.
	TargetResourceLocation *string `json:"targetResourceLocation,omitempty"`

	// TargetResourceUriReference: the resource identifier of the resource that the autoscale setting should be added to.
	TargetResourceUriReference *genruntime.ResourceReference `armReference:"TargetResourceUri" json:"targetResourceUriReference,omitempty"`
}

var _ genruntime.ARMTransformer = &AutoscaleSetting_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (setting *AutoscaleSetting_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if setting == nil {
		return nil, nil
	}
	result := &arm.AutoscaleSetting_Spec{}

	// Set property "Location":
	if setting.Location != nil {
		location := *setting.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if setting.Enabled != nil ||
		setting.Name != nil ||
		setting.Notifications != nil ||
		setting.PredictiveAutoscalePolicy != nil ||
		setting.Profiles != nil ||
		setting.TargetResourceLocation != nil ||
		setting.TargetResourceUriReference != nil {
		result.Properties = &arm.AutoscaleSettingProperties{}
	}
	if setting.Enabled != nil {
		enabled := *setting.Enabled
		result.Properties.Enabled = &enabled
	}
	if setting.Name != nil {
		name := *setting.Name
		result.Properties.Name = &name
	}
	for _, item := range setting.Notifications {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.Notifications = append(result.Properties.Notifications, *item_ARM.(*arm.AutoscaleNotification))
	}
	if setting.PredictiveAutoscalePolicy != nil {
		predictiveAutoscalePolicy_ARM, err := (*setting.PredictiveAutoscalePolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		predictiveAutoscalePolicy := *predictiveAutoscalePolicy_ARM.(*arm.PredictiveAutoscalePolicy)
		result.Properties.PredictiveAutoscalePolicy = &predictiveAutoscalePolicy
	}
	for _, item := range setting.Profiles {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.Profiles = append(result.Properties.Profiles, *item_ARM.(*arm.AutoscaleProfile))
	}
	if setting.TargetResourceLocation != nil {
		targetResourceLocation := *setting.TargetResourceLocation
		result.Properties.TargetResourceLocation = &targetResourceLocation
	}
	if setting.TargetResourceUriReference != nil {
		targetResourceUriARMID, err := resolved.ResolvedReferences.Lookup(*setting.TargetResourceUriReference)
		if err != nil {
			return nil, err
		}
		targetResourceUri := targetResourceUriARMID
		result.Properties.TargetResourceUri = &targetResourceUri
	}

	// Set property "Tags":
	if setting.Tags != nil {
		result.Tags = make(map[string]string, len(setting.Tags))
		for key, value := range setting.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (setting *AutoscaleSetting_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AutoscaleSetting_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (setting *AutoscaleSetting_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AutoscaleSetting_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AutoscaleSetting_Spec, got %T", armInput)
	}

	// Set property "AzureName":
	setting.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "Enabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Enabled != nil {
			enabled := *typedInput.Properties.Enabled
			setting.Enabled = &enabled
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		setting.Location = &location
	}

	// Set property "Name":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Name != nil {
			name := *typedInput.Properties.Name
			setting.Name = &name
		}
	}

	// Set property "Notifications":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Notifications {
			var item1 AutoscaleNotification
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			setting.Notifications = append(setting.Notifications, item1)
		}
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	setting.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "PredictiveAutoscalePolicy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PredictiveAutoscalePolicy != nil {
			var predictiveAutoscalePolicy1 PredictiveAutoscalePolicy
			err := predictiveAutoscalePolicy1.PopulateFromARM(owner, *typedInput.Properties.PredictiveAutoscalePolicy)
			if err != nil {
				return err
			}
			predictiveAutoscalePolicy := predictiveAutoscalePolicy1
			setting.PredictiveAutoscalePolicy = &predictiveAutoscalePolicy
		}
	}

	// Set property "Profiles":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Profiles {
			var item1 AutoscaleProfile
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			setting.Profiles = append(setting.Profiles, item1)
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		setting.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			setting.Tags[key] = value
		}
	}

	// Set property "TargetResourceLocation":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TargetResourceLocation != nil {
			targetResourceLocation := *typedInput.Properties.TargetResourceLocation
			setting.TargetResourceLocation = &targetResourceLocation
		}
	}

	// no assignment for property "TargetResourceUriReference"

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &AutoscaleSetting_Spec{}

// ConvertSpecFrom populates our AutoscaleSetting_Spec from the provided source
func (setting *AutoscaleSetting_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.AutoscaleSetting_Spec)
	if ok {
		// Populate our instance from source
		return setting.AssignProperties_From_AutoscaleSetting_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.AutoscaleSetting_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = setting.AssignProperties_From_AutoscaleSetting_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our AutoscaleSetting_Spec
func (setting *AutoscaleSetting_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.AutoscaleSetting_Spec)
	if ok {
		// Populate destination from our instance
		return setting.AssignProperties_To_AutoscaleSetting_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.AutoscaleSetting_Spec{}
	err := setting.AssignProperties_To_AutoscaleSetting_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_AutoscaleSetting_Spec populates our AutoscaleSetting_Spec from the provided source AutoscaleSetting_Spec
func (setting *AutoscaleSetting_Spec) AssignProperties_From_AutoscaleSetting_Spec(source *storage.AutoscaleSetting_Spec) error {

	// AzureName
	setting.AzureName = source.AzureName

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		setting.Enabled = &enabled
	} else {
		setting.Enabled = nil
	}

	// Location
	setting.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	setting.Name = genruntime.ClonePointerToString(source.Name)

	// Notifications
	if source.Notifications != nil {
		notificationList := make([]AutoscaleNotification, len(source.Notifications))
		for notificationIndex, notificationItem := range source.Notifications {
			// Shadow the loop variable to avoid aliasing
			notificationItem := notificationItem
			var notification AutoscaleNotification
			err := notification.AssignProperties_From_AutoscaleNotification(&notificationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_AutoscaleNotification() to populate field Notifications")
			}
			notificationList[notificationIndex] = notification
		}
		setting.Notifications = notificationList
	} else {
		setting.Notifications = nil
	}

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec AutoscaleSettingOperatorSpec
		err := operatorSpec.AssignProperties_From_AutoscaleSettingOperatorSpec(source.OperatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AutoscaleSettingOperatorSpec() to populate field OperatorSpec")
		}
		setting.OperatorSpec = &operatorSpec
	} else {
		setting.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		setting.Owner = &owner
	} else {
		setting.Owner = nil
	}

	// PredictiveAutoscalePolicy
	if source.PredictiveAutoscalePolicy != nil {
		var predictiveAutoscalePolicy PredictiveAutoscalePolicy
		err := predictiveAutoscalePolicy.AssignProperties_From_PredictiveAutoscalePolicy(source.PredictiveAutoscalePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PredictiveAutoscalePolicy() to populate field PredictiveAutoscalePolicy")
		}
		setting.PredictiveAutoscalePolicy = &predictiveAutoscalePolicy
	} else {
		setting.PredictiveAutoscalePolicy = nil
	}

	// Profiles
	if source.Profiles != nil {
		profileList := make([]AutoscaleProfile, len(source.Profiles))
		for profileIndex, profileItem := range source.Profiles {
			// Shadow the loop variable to avoid aliasing
			profileItem := profileItem
			var profile AutoscaleProfile
			err := profile.AssignProperties_From_AutoscaleProfile(&profileItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_AutoscaleProfile() to populate field Profiles")
			}
			profileList[profileIndex] = profile
		}
		setting.Profiles = profileList
	} else {
		setting.Profiles = nil
	}

	// Tags
	setting.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TargetResourceLocation
	setting.TargetResourceLocation = genruntime.ClonePointerToString(source.TargetResourceLocation)

	// TargetResourceUriReference
	if source.TargetResourceUriReference != nil {
		targetResourceUriReference := source.TargetResourceUriReference.Copy()
		setting.TargetResourceUriReference = &targetResourceUriReference
	} else {
		setting.TargetResourceUriReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AutoscaleSetting_Spec populates the provided destination AutoscaleSetting_Spec from our AutoscaleSetting_Spec
func (setting *AutoscaleSetting_Spec) AssignProperties_To_AutoscaleSetting_Spec(destination *storage.AutoscaleSetting_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = setting.AzureName

	// Enabled
	if setting.Enabled != nil {
		enabled := *setting.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(setting.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(setting.Name)

	// Notifications
	if setting.Notifications != nil {
		notificationList := make([]storage.AutoscaleNotification, len(setting.Notifications))
		for notificationIndex, notificationItem := range setting.Notifications {
			// Shadow the loop variable to avoid aliasing
			notificationItem := notificationItem
			var notification storage.AutoscaleNotification
			err := notificationItem.AssignProperties_To_AutoscaleNotification(&notification)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_AutoscaleNotification() to populate field Notifications")
			}
			notificationList[notificationIndex] = notification
		}
		destination.Notifications = notificationList
	} else {
		destination.Notifications = nil
	}

	// OperatorSpec
	if setting.OperatorSpec != nil {
		var operatorSpec storage.AutoscaleSettingOperatorSpec
		err := setting.OperatorSpec.AssignProperties_To_AutoscaleSettingOperatorSpec(&operatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AutoscaleSettingOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = setting.OriginalVersion()

	// Owner
	if setting.Owner != nil {
		owner := setting.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// PredictiveAutoscalePolicy
	if setting.PredictiveAutoscalePolicy != nil {
		var predictiveAutoscalePolicy storage.PredictiveAutoscalePolicy
		err := setting.PredictiveAutoscalePolicy.AssignProperties_To_PredictiveAutoscalePolicy(&predictiveAutoscalePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PredictiveAutoscalePolicy() to populate field PredictiveAutoscalePolicy")
		}
		destination.PredictiveAutoscalePolicy = &predictiveAutoscalePolicy
	} else {
		destination.PredictiveAutoscalePolicy = nil
	}

	// Profiles
	if setting.Profiles != nil {
		profileList := make([]storage.AutoscaleProfile, len(setting.Profiles))
		for profileIndex, profileItem := range setting.Profiles {
			// Shadow the loop variable to avoid aliasing
			profileItem := profileItem
			var profile storage.AutoscaleProfile
			err := profileItem.AssignProperties_To_AutoscaleProfile(&profile)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_AutoscaleProfile() to populate field Profiles")
			}
			profileList[profileIndex] = profile
		}
		destination.Profiles = profileList
	} else {
		destination.Profiles = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(setting.Tags)

	// TargetResourceLocation
	destination.TargetResourceLocation = genruntime.ClonePointerToString(setting.TargetResourceLocation)

	// TargetResourceUriReference
	if setting.TargetResourceUriReference != nil {
		targetResourceUriReference := setting.TargetResourceUriReference.Copy()
		destination.TargetResourceUriReference = &targetResourceUriReference
	} else {
		destination.TargetResourceUriReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Autoscalesetting_STATUS populates our AutoscaleSetting_Spec from the provided source Autoscalesetting_STATUS
func (setting *AutoscaleSetting_Spec) Initialize_From_Autoscalesetting_STATUS(source *Autoscalesetting_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		setting.Enabled = &enabled
	} else {
		setting.Enabled = nil
	}

	// Location
	setting.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	setting.Name = genruntime.ClonePointerToString(source.PropertiesName)

	// Notifications
	if source.Notifications != nil {
		notificationList := make([]AutoscaleNotification, len(source.Notifications))
		for notificationIndex, notificationItem := range source.Notifications {
			// Shadow the loop variable to avoid aliasing
			notificationItem := notificationItem
			var notification AutoscaleNotification
			err := notification.Initialize_From_AutoscaleNotification_STATUS(&notificationItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_AutoscaleNotification_STATUS() to populate field Notifications")
			}
			notificationList[notificationIndex] = notification
		}
		setting.Notifications = notificationList
	} else {
		setting.Notifications = nil
	}

	// PredictiveAutoscalePolicy
	if source.PredictiveAutoscalePolicy != nil {
		var predictiveAutoscalePolicy PredictiveAutoscalePolicy
		err := predictiveAutoscalePolicy.Initialize_From_PredictiveAutoscalePolicy_STATUS(source.PredictiveAutoscalePolicy)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_PredictiveAutoscalePolicy_STATUS() to populate field PredictiveAutoscalePolicy")
		}
		setting.PredictiveAutoscalePolicy = &predictiveAutoscalePolicy
	} else {
		setting.PredictiveAutoscalePolicy = nil
	}

	// Profiles
	if source.Profiles != nil {
		profileList := make([]AutoscaleProfile, len(source.Profiles))
		for profileIndex, profileItem := range source.Profiles {
			// Shadow the loop variable to avoid aliasing
			profileItem := profileItem
			var profile AutoscaleProfile
			err := profile.Initialize_From_AutoscaleProfile_STATUS(&profileItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_AutoscaleProfile_STATUS() to populate field Profiles")
			}
			profileList[profileIndex] = profile
		}
		setting.Profiles = profileList
	} else {
		setting.Profiles = nil
	}

	// Tags
	setting.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TargetResourceLocation
	setting.TargetResourceLocation = genruntime.ClonePointerToString(source.TargetResourceLocation)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (setting *AutoscaleSetting_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (setting *AutoscaleSetting_Spec) SetAzureName(azureName string) { setting.AzureName = azureName }

type Autoscalesetting_STATUS struct {
	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// Enabled: the enabled flag. Specifies whether automatic scaling is enabled for the resource. The default value is 'false'.
	Enabled *bool `json:"enabled,omitempty"`

	// Id: Azure resource Id
	Id *string `json:"id,omitempty"`

	// Location: Resource location
	Location *string `json:"location,omitempty"`

	// Name: Azure resource name
	Name *string `json:"name,omitempty"`

	// Notifications: the collection of notifications.
	Notifications []AutoscaleNotification_STATUS `json:"notifications,omitempty"`

	// PredictiveAutoscalePolicy: the predictive autoscale policy mode.
	PredictiveAutoscalePolicy *PredictiveAutoscalePolicy_STATUS `json:"predictiveAutoscalePolicy,omitempty"`

	// Profiles: the collection of automatic scaling profiles that specify different scaling parameters for different time
	// periods. A maximum of 20 profiles can be specified.
	Profiles []AutoscaleProfile_STATUS `json:"profiles,omitempty"`

	// PropertiesName: the name of the autoscale setting.
	PropertiesName *string `json:"properties_name,omitempty"`

	// SystemData: The system metadata related to the response.
	SystemData *SystemData_STATUS `json:"systemData,omitempty"`

	// Tags: Gets or sets a list of key value pairs that describe the resource. These tags can be used in viewing and grouping
	// this resource (across resource groups). A maximum of 15 tags can be provided for a resource. Each tag must have a key no
	// greater in length than 128 characters and a value no greater in length than 256 characters.
	Tags map[string]string `json:"tags,omitempty"`

	// TargetResourceLocation: the location of the resource that the autoscale setting should be added to.
	TargetResourceLocation *string `json:"targetResourceLocation,omitempty"`

	// TargetResourceUri: the resource identifier of the resource that the autoscale setting should be added to.
	TargetResourceUri *string `json:"targetResourceUri,omitempty"`

	// Type: Azure resource type
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &Autoscalesetting_STATUS{}

// ConvertStatusFrom populates our Autoscalesetting_STATUS from the provided source
func (autoscalesetting *Autoscalesetting_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.Autoscalesetting_STATUS)
	if ok {
		// Populate our instance from source
		return autoscalesetting.AssignProperties_From_Autoscalesetting_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.Autoscalesetting_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = autoscalesetting.AssignProperties_From_Autoscalesetting_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our Autoscalesetting_STATUS
func (autoscalesetting *Autoscalesetting_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.Autoscalesetting_STATUS)
	if ok {
		// Populate destination from our instance
		return autoscalesetting.AssignProperties_To_Autoscalesetting_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.Autoscalesetting_STATUS{}
	err := autoscalesetting.AssignProperties_To_Autoscalesetting_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &Autoscalesetting_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (autoscalesetting *Autoscalesetting_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Autoscalesetting_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (autoscalesetting *Autoscalesetting_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Autoscalesetting_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Autoscalesetting_STATUS, got %T", armInput)
	}

	// no assignment for property "Conditions"

	// Set property "Enabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Enabled != nil {
			enabled := *typedInput.Properties.Enabled
			autoscalesetting.Enabled = &enabled
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		autoscalesetting.Id = &id
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		autoscalesetting.Location = &location
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		autoscalesetting.Name = &name
	}

	// Set property "Notifications":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Notifications {
			var item1 AutoscaleNotification_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			autoscalesetting.Notifications = append(autoscalesetting.Notifications, item1)
		}
	}

	// Set property "PredictiveAutoscalePolicy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PredictiveAutoscalePolicy != nil {
			var predictiveAutoscalePolicy1 PredictiveAutoscalePolicy_STATUS
			err := predictiveAutoscalePolicy1.PopulateFromARM(owner, *typedInput.Properties.PredictiveAutoscalePolicy)
			if err != nil {
				return err
			}
			predictiveAutoscalePolicy := predictiveAutoscalePolicy1
			autoscalesetting.PredictiveAutoscalePolicy = &predictiveAutoscalePolicy
		}
	}

	// Set property "Profiles":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Profiles {
			var item1 AutoscaleProfile_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			autoscalesetting.Profiles = append(autoscalesetting.Profiles, item1)
		}
	}

	// Set property "PropertiesName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Name != nil {
			propertiesName := *typedInput.Properties.Name
			autoscalesetting.PropertiesName = &propertiesName
		}
	}

	// Set property "SystemData":
	if typedInput.SystemData != nil {
		var systemData1 SystemData_STATUS
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		autoscalesetting.SystemData = &systemData
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		autoscalesetting.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			autoscalesetting.Tags[key] = value
		}
	}

	// Set property "TargetResourceLocation":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TargetResourceLocation != nil {
			targetResourceLocation := *typedInput.Properties.TargetResourceLocation
			autoscalesetting.TargetResourceLocation = &targetResourceLocation
		}
	}

	// Set property "TargetResourceUri":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TargetResourceUri != nil {
			targetResourceUri := *typedInput.Properties.TargetResourceUri
			autoscalesetting.TargetResourceUri = &targetResourceUri
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		autoscalesetting.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_Autoscalesetting_STATUS populates our Autoscalesetting_STATUS from the provided source Autoscalesetting_STATUS
func (autoscalesetting *Autoscalesetting_STATUS) AssignProperties_From_Autoscalesetting_STATUS(source *storage.Autoscalesetting_STATUS) error {

	// Conditions
	autoscalesetting.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		autoscalesetting.Enabled = &enabled
	} else {
		autoscalesetting.Enabled = nil
	}

	// Id
	autoscalesetting.Id = genruntime.ClonePointerToString(source.Id)

	// Location
	autoscalesetting.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	autoscalesetting.Name = genruntime.ClonePointerToString(source.Name)

	// Notifications
	if source.Notifications != nil {
		notificationList := make([]AutoscaleNotification_STATUS, len(source.Notifications))
		for notificationIndex, notificationItem := range source.Notifications {
			// Shadow the loop variable to avoid aliasing
			notificationItem := notificationItem
			var notification AutoscaleNotification_STATUS
			err := notification.AssignProperties_From_AutoscaleNotification_STATUS(&notificationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_AutoscaleNotification_STATUS() to populate field Notifications")
			}
			notificationList[notificationIndex] = notification
		}
		autoscalesetting.Notifications = notificationList
	} else {
		autoscalesetting.Notifications = nil
	}

	// PredictiveAutoscalePolicy
	if source.PredictiveAutoscalePolicy != nil {
		var predictiveAutoscalePolicy PredictiveAutoscalePolicy_STATUS
		err := predictiveAutoscalePolicy.AssignProperties_From_PredictiveAutoscalePolicy_STATUS(source.PredictiveAutoscalePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PredictiveAutoscalePolicy_STATUS() to populate field PredictiveAutoscalePolicy")
		}
		autoscalesetting.PredictiveAutoscalePolicy = &predictiveAutoscalePolicy
	} else {
		autoscalesetting.PredictiveAutoscalePolicy = nil
	}

	// Profiles
	if source.Profiles != nil {
		profileList := make([]AutoscaleProfile_STATUS, len(source.Profiles))
		for profileIndex, profileItem := range source.Profiles {
			// Shadow the loop variable to avoid aliasing
			profileItem := profileItem
			var profile AutoscaleProfile_STATUS
			err := profile.AssignProperties_From_AutoscaleProfile_STATUS(&profileItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_AutoscaleProfile_STATUS() to populate field Profiles")
			}
			profileList[profileIndex] = profile
		}
		autoscalesetting.Profiles = profileList
	} else {
		autoscalesetting.Profiles = nil
	}

	// PropertiesName
	autoscalesetting.PropertiesName = genruntime.ClonePointerToString(source.PropertiesName)

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		autoscalesetting.SystemData = &systemDatum
	} else {
		autoscalesetting.SystemData = nil
	}

	// Tags
	autoscalesetting.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TargetResourceLocation
	autoscalesetting.TargetResourceLocation = genruntime.ClonePointerToString(source.TargetResourceLocation)

	// TargetResourceUri
	autoscalesetting.TargetResourceUri = genruntime.ClonePointerToString(source.TargetResourceUri)

	// Type
	autoscalesetting.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_Autoscalesetting_STATUS populates the provided destination Autoscalesetting_STATUS from our Autoscalesetting_STATUS
func (autoscalesetting *Autoscalesetting_STATUS) AssignProperties_To_Autoscalesetting_STATUS(destination *storage.Autoscalesetting_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(autoscalesetting.Conditions)

	// Enabled
	if autoscalesetting.Enabled != nil {
		enabled := *autoscalesetting.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(autoscalesetting.Id)

	// Location
	destination.Location = genruntime.ClonePointerToString(autoscalesetting.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(autoscalesetting.Name)

	// Notifications
	if autoscalesetting.Notifications != nil {
		notificationList := make([]storage.AutoscaleNotification_STATUS, len(autoscalesetting.Notifications))
		for notificationIndex, notificationItem := range autoscalesetting.Notifications {
			// Shadow the loop variable to avoid aliasing
			notificationItem := notificationItem
			var notification storage.AutoscaleNotification_STATUS
			err := notificationItem.AssignProperties_To_AutoscaleNotification_STATUS(&notification)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_AutoscaleNotification_STATUS() to populate field Notifications")
			}
			notificationList[notificationIndex] = notification
		}
		destination.Notifications = notificationList
	} else {
		destination.Notifications = nil
	}

	// PredictiveAutoscalePolicy
	if autoscalesetting.PredictiveAutoscalePolicy != nil {
		var predictiveAutoscalePolicy storage.PredictiveAutoscalePolicy_STATUS
		err := autoscalesetting.PredictiveAutoscalePolicy.AssignProperties_To_PredictiveAutoscalePolicy_STATUS(&predictiveAutoscalePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PredictiveAutoscalePolicy_STATUS() to populate field PredictiveAutoscalePolicy")
		}
		destination.PredictiveAutoscalePolicy = &predictiveAutoscalePolicy
	} else {
		destination.PredictiveAutoscalePolicy = nil
	}

	// Profiles
	if autoscalesetting.Profiles != nil {
		profileList := make([]storage.AutoscaleProfile_STATUS, len(autoscalesetting.Profiles))
		for profileIndex, profileItem := range autoscalesetting.Profiles {
			// Shadow the loop variable to avoid aliasing
			profileItem := profileItem
			var profile storage.AutoscaleProfile_STATUS
			err := profileItem.AssignProperties_To_AutoscaleProfile_STATUS(&profile)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_AutoscaleProfile_STATUS() to populate field Profiles")
			}
			profileList[profileIndex] = profile
		}
		destination.Profiles = profileList
	} else {
		destination.Profiles = nil
	}

	// PropertiesName
	destination.PropertiesName = genruntime.ClonePointerToString(autoscalesetting.PropertiesName)

	// SystemData
	if autoscalesetting.SystemData != nil {
		var systemDatum storage.SystemData_STATUS
		err := autoscalesetting.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(autoscalesetting.Tags)

	// TargetResourceLocation
	destination.TargetResourceLocation = genruntime.ClonePointerToString(autoscalesetting.TargetResourceLocation)

	// TargetResourceUri
	destination.TargetResourceUri = genruntime.ClonePointerToString(autoscalesetting.TargetResourceUri)

	// Type
	destination.Type = genruntime.ClonePointerToString(autoscalesetting.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Autoscale notification.
type AutoscaleNotification struct {
	// Email: the email notification.
	Email *EmailNotification `json:"email,omitempty"`

	// +kubebuilder:validation:Required
	// Operation: the operation associated with the notification and its value must be "scale"
	Operation *AutoscaleNotification_Operation `json:"operation,omitempty"`

	// Webhooks: the collection of webhook notifications.
	Webhooks []WebhookNotification `json:"webhooks,omitempty"`
}

var _ genruntime.ARMTransformer = &AutoscaleNotification{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (notification *AutoscaleNotification) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if notification == nil {
		return nil, nil
	}
	result := &arm.AutoscaleNotification{}

	// Set property "Email":
	if notification.Email != nil {
		email_ARM, err := (*notification.Email).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		email := *email_ARM.(*arm.EmailNotification)
		result.Email = &email
	}

	// Set property "Operation":
	if notification.Operation != nil {
		var temp string
		temp = string(*notification.Operation)
		operation := arm.AutoscaleNotification_Operation(temp)
		result.Operation = &operation
	}

	// Set property "Webhooks":
	for _, item := range notification.Webhooks {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Webhooks = append(result.Webhooks, *item_ARM.(*arm.WebhookNotification))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (notification *AutoscaleNotification) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AutoscaleNotification{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (notification *AutoscaleNotification) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AutoscaleNotification)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AutoscaleNotification, got %T", armInput)
	}

	// Set property "Email":
	if typedInput.Email != nil {
		var email1 EmailNotification
		err := email1.PopulateFromARM(owner, *typedInput.Email)
		if err != nil {
			return err
		}
		email := email1
		notification.Email = &email
	}

	// Set property "Operation":
	if typedInput.Operation != nil {
		var temp string
		temp = string(*typedInput.Operation)
		operation := AutoscaleNotification_Operation(temp)
		notification.Operation = &operation
	}

	// Set property "Webhooks":
	for _, item := range typedInput.Webhooks {
		var item1 WebhookNotification
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		notification.Webhooks = append(notification.Webhooks, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_AutoscaleNotification populates our AutoscaleNotification from the provided source AutoscaleNotification
func (notification *AutoscaleNotification) AssignProperties_From_AutoscaleNotification(source *storage.AutoscaleNotification) error {

	// Email
	if source.Email != nil {
		var email EmailNotification
		err := email.AssignProperties_From_EmailNotification(source.Email)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_EmailNotification() to populate field Email")
		}
		notification.Email = &email
	} else {
		notification.Email = nil
	}

	// Operation
	if source.Operation != nil {
		operation := *source.Operation
		operationTemp := genruntime.ToEnum(operation, autoscaleNotification_Operation_Values)
		notification.Operation = &operationTemp
	} else {
		notification.Operation = nil
	}

	// Webhooks
	if source.Webhooks != nil {
		webhookList := make([]WebhookNotification, len(source.Webhooks))
		for webhookIndex, webhookItem := range source.Webhooks {
			// Shadow the loop variable to avoid aliasing
			webhookItem := webhookItem
			var webhook WebhookNotification
			err := webhook.AssignProperties_From_WebhookNotification(&webhookItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_WebhookNotification() to populate field Webhooks")
			}
			webhookList[webhookIndex] = webhook
		}
		notification.Webhooks = webhookList
	} else {
		notification.Webhooks = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AutoscaleNotification populates the provided destination AutoscaleNotification from our AutoscaleNotification
func (notification *AutoscaleNotification) AssignProperties_To_AutoscaleNotification(destination *storage.AutoscaleNotification) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Email
	if notification.Email != nil {
		var email storage.EmailNotification
		err := notification.Email.AssignProperties_To_EmailNotification(&email)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_EmailNotification() to populate field Email")
		}
		destination.Email = &email
	} else {
		destination.Email = nil
	}

	// Operation
	if notification.Operation != nil {
		operation := string(*notification.Operation)
		destination.Operation = &operation
	} else {
		destination.Operation = nil
	}

	// Webhooks
	if notification.Webhooks != nil {
		webhookList := make([]storage.WebhookNotification, len(notification.Webhooks))
		for webhookIndex, webhookItem := range notification.Webhooks {
			// Shadow the loop variable to avoid aliasing
			webhookItem := webhookItem
			var webhook storage.WebhookNotification
			err := webhookItem.AssignProperties_To_WebhookNotification(&webhook)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_WebhookNotification() to populate field Webhooks")
			}
			webhookList[webhookIndex] = webhook
		}
		destination.Webhooks = webhookList
	} else {
		destination.Webhooks = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AutoscaleNotification_STATUS populates our AutoscaleNotification from the provided source AutoscaleNotification_STATUS
func (notification *AutoscaleNotification) Initialize_From_AutoscaleNotification_STATUS(source *AutoscaleNotification_STATUS) error {

	// Email
	if source.Email != nil {
		var email EmailNotification
		err := email.Initialize_From_EmailNotification_STATUS(source.Email)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_EmailNotification_STATUS() to populate field Email")
		}
		notification.Email = &email
	} else {
		notification.Email = nil
	}

	// Operation
	if source.Operation != nil {
		operation := genruntime.ToEnum(string(*source.Operation), autoscaleNotification_Operation_Values)
		notification.Operation = &operation
	} else {
		notification.Operation = nil
	}

	// Webhooks
	if source.Webhooks != nil {
		webhookList := make([]WebhookNotification, len(source.Webhooks))
		for webhookIndex, webhookItem := range source.Webhooks {
			// Shadow the loop variable to avoid aliasing
			webhookItem := webhookItem
			var webhook WebhookNotification
			err := webhook.Initialize_From_WebhookNotification_STATUS(&webhookItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_WebhookNotification_STATUS() to populate field Webhooks")
			}
			webhookList[webhookIndex] = webhook
		}
		notification.Webhooks = webhookList
	} else {
		notification.Webhooks = nil
	}

	// No error
	return nil
}

// Autoscale notification.
type AutoscaleNotification_STATUS struct {
	// Email: the email notification.
	Email *EmailNotification_STATUS `json:"email,omitempty"`

	// Operation: the operation associated with the notification and its value must be "scale"
	Operation *AutoscaleNotification_Operation_STATUS `json:"operation,omitempty"`

	// Webhooks: the collection of webhook notifications.
	Webhooks []WebhookNotification_STATUS `json:"webhooks,omitempty"`
}

var _ genruntime.FromARMConverter = &AutoscaleNotification_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (notification *AutoscaleNotification_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AutoscaleNotification_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (notification *AutoscaleNotification_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AutoscaleNotification_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AutoscaleNotification_STATUS, got %T", armInput)
	}

	// Set property "Email":
	if typedInput.Email != nil {
		var email1 EmailNotification_STATUS
		err := email1.PopulateFromARM(owner, *typedInput.Email)
		if err != nil {
			return err
		}
		email := email1
		notification.Email = &email
	}

	// Set property "Operation":
	if typedInput.Operation != nil {
		var temp string
		temp = string(*typedInput.Operation)
		operation := AutoscaleNotification_Operation_STATUS(temp)
		notification.Operation = &operation
	}

	// Set property "Webhooks":
	for _, item := range typedInput.Webhooks {
		var item1 WebhookNotification_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		notification.Webhooks = append(notification.Webhooks, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_AutoscaleNotification_STATUS populates our AutoscaleNotification_STATUS from the provided source AutoscaleNotification_STATUS
func (notification *AutoscaleNotification_STATUS) AssignProperties_From_AutoscaleNotification_STATUS(source *storage.AutoscaleNotification_STATUS) error {

	// Email
	if source.Email != nil {
		var email EmailNotification_STATUS
		err := email.AssignProperties_From_EmailNotification_STATUS(source.Email)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_EmailNotification_STATUS() to populate field Email")
		}
		notification.Email = &email
	} else {
		notification.Email = nil
	}

	// Operation
	if source.Operation != nil {
		operation := *source.Operation
		operationTemp := genruntime.ToEnum(operation, autoscaleNotification_Operation_STATUS_Values)
		notification.Operation = &operationTemp
	} else {
		notification.Operation = nil
	}

	// Webhooks
	if source.Webhooks != nil {
		webhookList := make([]WebhookNotification_STATUS, len(source.Webhooks))
		for webhookIndex, webhookItem := range source.Webhooks {
			// Shadow the loop variable to avoid aliasing
			webhookItem := webhookItem
			var webhook WebhookNotification_STATUS
			err := webhook.AssignProperties_From_WebhookNotification_STATUS(&webhookItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_WebhookNotification_STATUS() to populate field Webhooks")
			}
			webhookList[webhookIndex] = webhook
		}
		notification.Webhooks = webhookList
	} else {
		notification.Webhooks = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AutoscaleNotification_STATUS populates the provided destination AutoscaleNotification_STATUS from our AutoscaleNotification_STATUS
func (notification *AutoscaleNotification_STATUS) AssignProperties_To_AutoscaleNotification_STATUS(destination *storage.AutoscaleNotification_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Email
	if notification.Email != nil {
		var email storage.EmailNotification_STATUS
		err := notification.Email.AssignProperties_To_EmailNotification_STATUS(&email)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_EmailNotification_STATUS() to populate field Email")
		}
		destination.Email = &email
	} else {
		destination.Email = nil
	}

	// Operation
	if notification.Operation != nil {
		operation := string(*notification.Operation)
		destination.Operation = &operation
	} else {
		destination.Operation = nil
	}

	// Webhooks
	if notification.Webhooks != nil {
		webhookList := make([]storage.WebhookNotification_STATUS, len(notification.Webhooks))
		for webhookIndex, webhookItem := range notification.Webhooks {
			// Shadow the loop variable to avoid aliasing
			webhookItem := webhookItem
			var webhook storage.WebhookNotification_STATUS
			err := webhookItem.AssignProperties_To_WebhookNotification_STATUS(&webhook)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_WebhookNotification_STATUS() to populate field Webhooks")
			}
			webhookList[webhookIndex] = webhook
		}
		destination.Webhooks = webhookList
	} else {
		destination.Webhooks = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Autoscale profile.
type AutoscaleProfile struct {
	// +kubebuilder:validation:Required
	// Capacity: the number of instances that can be used during this profile.
	Capacity *ScaleCapacity `json:"capacity,omitempty"`

	// FixedDate: the specific date-time for the profile. This element is not used if the Recurrence element is used.
	FixedDate *TimeWindow `json:"fixedDate,omitempty"`

	// +kubebuilder:validation:Required
	// Name: the name of the profile.
	Name *string `json:"name,omitempty"`

	// Recurrence: the repeating times at which this profile begins. This element is not used if the FixedDate element is used.
	Recurrence *Recurrence `json:"recurrence,omitempty"`

	// +kubebuilder:validation:Required
	// Rules: the collection of rules that provide the triggers and parameters for the scaling action. A maximum of 10 rules
	// can be specified.
	Rules []ScaleRule `json:"rules,omitempty"`
}

var _ genruntime.ARMTransformer = &AutoscaleProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *AutoscaleProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.AutoscaleProfile{}

	// Set property "Capacity":
	if profile.Capacity != nil {
		capacity_ARM, err := (*profile.Capacity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		capacity := *capacity_ARM.(*arm.ScaleCapacity)
		result.Capacity = &capacity
	}

	// Set property "FixedDate":
	if profile.FixedDate != nil {
		fixedDate_ARM, err := (*profile.FixedDate).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		fixedDate := *fixedDate_ARM.(*arm.TimeWindow)
		result.FixedDate = &fixedDate
	}

	// Set property "Name":
	if profile.Name != nil {
		name := *profile.Name
		result.Name = &name
	}

	// Set property "Recurrence":
	if profile.Recurrence != nil {
		recurrence_ARM, err := (*profile.Recurrence).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		recurrence := *recurrence_ARM.(*arm.Recurrence)
		result.Recurrence = &recurrence
	}

	// Set property "Rules":
	for _, item := range profile.Rules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Rules = append(result.Rules, *item_ARM.(*arm.ScaleRule))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *AutoscaleProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AutoscaleProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *AutoscaleProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AutoscaleProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AutoscaleProfile, got %T", armInput)
	}

	// Set property "Capacity":
	if typedInput.Capacity != nil {
		var capacity1 ScaleCapacity
		err := capacity1.PopulateFromARM(owner, *typedInput.Capacity)
		if err != nil {
			return err
		}
		capacity := capacity1
		profile.Capacity = &capacity
	}

	// Set property "FixedDate":
	if typedInput.FixedDate != nil {
		var fixedDate1 TimeWindow
		err := fixedDate1.PopulateFromARM(owner, *typedInput.FixedDate)
		if err != nil {
			return err
		}
		fixedDate := fixedDate1
		profile.FixedDate = &fixedDate
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		profile.Name = &name
	}

	// Set property "Recurrence":
	if typedInput.Recurrence != nil {
		var recurrence1 Recurrence
		err := recurrence1.PopulateFromARM(owner, *typedInput.Recurrence)
		if err != nil {
			return err
		}
		recurrence := recurrence1
		profile.Recurrence = &recurrence
	}

	// Set property "Rules":
	for _, item := range typedInput.Rules {
		var item1 ScaleRule
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.Rules = append(profile.Rules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_AutoscaleProfile populates our AutoscaleProfile from the provided source AutoscaleProfile
func (profile *AutoscaleProfile) AssignProperties_From_AutoscaleProfile(source *storage.AutoscaleProfile) error {

	// Capacity
	if source.Capacity != nil {
		var capacity ScaleCapacity
		err := capacity.AssignProperties_From_ScaleCapacity(source.Capacity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ScaleCapacity() to populate field Capacity")
		}
		profile.Capacity = &capacity
	} else {
		profile.Capacity = nil
	}

	// FixedDate
	if source.FixedDate != nil {
		var fixedDate TimeWindow
		err := fixedDate.AssignProperties_From_TimeWindow(source.FixedDate)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_TimeWindow() to populate field FixedDate")
		}
		profile.FixedDate = &fixedDate
	} else {
		profile.FixedDate = nil
	}

	// Name
	profile.Name = genruntime.ClonePointerToString(source.Name)

	// Recurrence
	if source.Recurrence != nil {
		var recurrence Recurrence
		err := recurrence.AssignProperties_From_Recurrence(source.Recurrence)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Recurrence() to populate field Recurrence")
		}
		profile.Recurrence = &recurrence
	} else {
		profile.Recurrence = nil
	}

	// Rules
	if source.Rules != nil {
		ruleList := make([]ScaleRule, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule ScaleRule
			err := rule.AssignProperties_From_ScaleRule(&ruleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ScaleRule() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		profile.Rules = ruleList
	} else {
		profile.Rules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AutoscaleProfile populates the provided destination AutoscaleProfile from our AutoscaleProfile
func (profile *AutoscaleProfile) AssignProperties_To_AutoscaleProfile(destination *storage.AutoscaleProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Capacity
	if profile.Capacity != nil {
		var capacity storage.ScaleCapacity
		err := profile.Capacity.AssignProperties_To_ScaleCapacity(&capacity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ScaleCapacity() to populate field Capacity")
		}
		destination.Capacity = &capacity
	} else {
		destination.Capacity = nil
	}

	// FixedDate
	if profile.FixedDate != nil {
		var fixedDate storage.TimeWindow
		err := profile.FixedDate.AssignProperties_To_TimeWindow(&fixedDate)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_TimeWindow() to populate field FixedDate")
		}
		destination.FixedDate = &fixedDate
	} else {
		destination.FixedDate = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(profile.Name)

	// Recurrence
	if profile.Recurrence != nil {
		var recurrence storage.Recurrence
		err := profile.Recurrence.AssignProperties_To_Recurrence(&recurrence)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Recurrence() to populate field Recurrence")
		}
		destination.Recurrence = &recurrence
	} else {
		destination.Recurrence = nil
	}

	// Rules
	if profile.Rules != nil {
		ruleList := make([]storage.ScaleRule, len(profile.Rules))
		for ruleIndex, ruleItem := range profile.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule storage.ScaleRule
			err := ruleItem.AssignProperties_To_ScaleRule(&rule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ScaleRule() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AutoscaleProfile_STATUS populates our AutoscaleProfile from the provided source AutoscaleProfile_STATUS
func (profile *AutoscaleProfile) Initialize_From_AutoscaleProfile_STATUS(source *AutoscaleProfile_STATUS) error {

	// Capacity
	if source.Capacity != nil {
		var capacity ScaleCapacity
		err := capacity.Initialize_From_ScaleCapacity_STATUS(source.Capacity)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ScaleCapacity_STATUS() to populate field Capacity")
		}
		profile.Capacity = &capacity
	} else {
		profile.Capacity = nil
	}

	// FixedDate
	if source.FixedDate != nil {
		var fixedDate TimeWindow
		err := fixedDate.Initialize_From_TimeWindow_STATUS(source.FixedDate)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_TimeWindow_STATUS() to populate field FixedDate")
		}
		profile.FixedDate = &fixedDate
	} else {
		profile.FixedDate = nil
	}

	// Name
	profile.Name = genruntime.ClonePointerToString(source.Name)

	// Recurrence
	if source.Recurrence != nil {
		var recurrence Recurrence
		err := recurrence.Initialize_From_Recurrence_STATUS(source.Recurrence)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_Recurrence_STATUS() to populate field Recurrence")
		}
		profile.Recurrence = &recurrence
	} else {
		profile.Recurrence = nil
	}

	// Rules
	if source.Rules != nil {
		ruleList := make([]ScaleRule, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule ScaleRule
			err := rule.Initialize_From_ScaleRule_STATUS(&ruleItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ScaleRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		profile.Rules = ruleList
	} else {
		profile.Rules = nil
	}

	// No error
	return nil
}

// Autoscale profile.
type AutoscaleProfile_STATUS struct {
	// +kubebuilder:validation:Required
	// Capacity: the number of instances that can be used during this profile.
	Capacity *ScaleCapacity_STATUS `json:"capacity,omitempty"`

	// FixedDate: the specific date-time for the profile. This element is not used if the Recurrence element is used.
	FixedDate *TimeWindow_STATUS `json:"fixedDate,omitempty"`

	// +kubebuilder:validation:Required
	// Name: the name of the profile.
	Name *string `json:"name,omitempty"`

	// Recurrence: the repeating times at which this profile begins. This element is not used if the FixedDate element is used.
	Recurrence *Recurrence_STATUS `json:"recurrence,omitempty"`

	// +kubebuilder:validation:Required
	// Rules: the collection of rules that provide the triggers and parameters for the scaling action. A maximum of 10 rules
	// can be specified.
	Rules []ScaleRule_STATUS `json:"rules,omitempty"`
}

var _ genruntime.FromARMConverter = &AutoscaleProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *AutoscaleProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AutoscaleProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *AutoscaleProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AutoscaleProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AutoscaleProfile_STATUS, got %T", armInput)
	}

	// Set property "Capacity":
	if typedInput.Capacity != nil {
		var capacity1 ScaleCapacity_STATUS
		err := capacity1.PopulateFromARM(owner, *typedInput.Capacity)
		if err != nil {
			return err
		}
		capacity := capacity1
		profile.Capacity = &capacity
	}

	// Set property "FixedDate":
	if typedInput.FixedDate != nil {
		var fixedDate1 TimeWindow_STATUS
		err := fixedDate1.PopulateFromARM(owner, *typedInput.FixedDate)
		if err != nil {
			return err
		}
		fixedDate := fixedDate1
		profile.FixedDate = &fixedDate
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		profile.Name = &name
	}

	// Set property "Recurrence":
	if typedInput.Recurrence != nil {
		var recurrence1 Recurrence_STATUS
		err := recurrence1.PopulateFromARM(owner, *typedInput.Recurrence)
		if err != nil {
			return err
		}
		recurrence := recurrence1
		profile.Recurrence = &recurrence
	}

	// Set property "Rules":
	for _, item := range typedInput.Rules {
		var item1 ScaleRule_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.Rules = append(profile.Rules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_AutoscaleProfile_STATUS populates our AutoscaleProfile_STATUS from the provided source AutoscaleProfile_STATUS
func (profile *AutoscaleProfile_STATUS) AssignProperties_From_AutoscaleProfile_STATUS(source *storage.AutoscaleProfile_STATUS) error {

	// Capacity
	if source.Capacity != nil {
		var capacity ScaleCapacity_STATUS
		err := capacity.AssignProperties_From_ScaleCapacity_STATUS(source.Capacity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ScaleCapacity_STATUS() to populate field Capacity")
		}
		profile.Capacity = &capacity
	} else {
		profile.Capacity = nil
	}

	// FixedDate
	if source.FixedDate != nil {
		var fixedDate TimeWindow_STATUS
		err := fixedDate.AssignProperties_From_TimeWindow_STATUS(source.FixedDate)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_TimeWindow_STATUS() to populate field FixedDate")
		}
		profile.FixedDate = &fixedDate
	} else {
		profile.FixedDate = nil
	}

	// Name
	profile.Name = genruntime.ClonePointerToString(source.Name)

	// Recurrence
	if source.Recurrence != nil {
		var recurrence Recurrence_STATUS
		err := recurrence.AssignProperties_From_Recurrence_STATUS(source.Recurrence)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Recurrence_STATUS() to populate field Recurrence")
		}
		profile.Recurrence = &recurrence
	} else {
		profile.Recurrence = nil
	}

	// Rules
	if source.Rules != nil {
		ruleList := make([]ScaleRule_STATUS, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule ScaleRule_STATUS
			err := rule.AssignProperties_From_ScaleRule_STATUS(&ruleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ScaleRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		profile.Rules = ruleList
	} else {
		profile.Rules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AutoscaleProfile_STATUS populates the provided destination AutoscaleProfile_STATUS from our AutoscaleProfile_STATUS
func (profile *AutoscaleProfile_STATUS) AssignProperties_To_AutoscaleProfile_STATUS(destination *storage.AutoscaleProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Capacity
	if profile.Capacity != nil {
		var capacity storage.ScaleCapacity_STATUS
		err := profile.Capacity.AssignProperties_To_ScaleCapacity_STATUS(&capacity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ScaleCapacity_STATUS() to populate field Capacity")
		}
		destination.Capacity = &capacity
	} else {
		destination.Capacity = nil
	}

	// FixedDate
	if profile.FixedDate != nil {
		var fixedDate storage.TimeWindow_STATUS
		err := profile.FixedDate.AssignProperties_To_TimeWindow_STATUS(&fixedDate)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_TimeWindow_STATUS() to populate field FixedDate")
		}
		destination.FixedDate = &fixedDate
	} else {
		destination.FixedDate = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(profile.Name)

	// Recurrence
	if profile.Recurrence != nil {
		var recurrence storage.Recurrence_STATUS
		err := profile.Recurrence.AssignProperties_To_Recurrence_STATUS(&recurrence)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Recurrence_STATUS() to populate field Recurrence")
		}
		destination.Recurrence = &recurrence
	} else {
		destination.Recurrence = nil
	}

	// Rules
	if profile.Rules != nil {
		ruleList := make([]storage.ScaleRule_STATUS, len(profile.Rules))
		for ruleIndex, ruleItem := range profile.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule storage.ScaleRule_STATUS
			err := ruleItem.AssignProperties_To_ScaleRule_STATUS(&rule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ScaleRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type AutoscaleSettingOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_AutoscaleSettingOperatorSpec populates our AutoscaleSettingOperatorSpec from the provided source AutoscaleSettingOperatorSpec
func (operator *AutoscaleSettingOperatorSpec) AssignProperties_From_AutoscaleSettingOperatorSpec(source *storage.AutoscaleSettingOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AutoscaleSettingOperatorSpec populates the provided destination AutoscaleSettingOperatorSpec from our AutoscaleSettingOperatorSpec
func (operator *AutoscaleSettingOperatorSpec) AssignProperties_To_AutoscaleSettingOperatorSpec(destination *storage.AutoscaleSettingOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The parameters for enabling predictive autoscale.
type PredictiveAutoscalePolicy struct {
	// ScaleLookAheadTime: the amount of time to specify by which instances are launched in advance. It must be between 1
	// minute and 60 minutes in ISO 8601 format.
	ScaleLookAheadTime *string `json:"scaleLookAheadTime,omitempty"`

	// +kubebuilder:validation:Required
	// ScaleMode: the predictive autoscale mode
	ScaleMode *PredictiveAutoscalePolicy_ScaleMode `json:"scaleMode,omitempty"`
}

var _ genruntime.ARMTransformer = &PredictiveAutoscalePolicy{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *PredictiveAutoscalePolicy) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	result := &arm.PredictiveAutoscalePolicy{}

	// Set property "ScaleLookAheadTime":
	if policy.ScaleLookAheadTime != nil {
		scaleLookAheadTime := *policy.ScaleLookAheadTime
		result.ScaleLookAheadTime = &scaleLookAheadTime
	}

	// Set property "ScaleMode":
	if policy.ScaleMode != nil {
		var temp string
		temp = string(*policy.ScaleMode)
		scaleMode := arm.PredictiveAutoscalePolicy_ScaleMode(temp)
		result.ScaleMode = &scaleMode
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *PredictiveAutoscalePolicy) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PredictiveAutoscalePolicy{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *PredictiveAutoscalePolicy) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PredictiveAutoscalePolicy)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PredictiveAutoscalePolicy, got %T", armInput)
	}

	// Set property "ScaleLookAheadTime":
	if typedInput.ScaleLookAheadTime != nil {
		scaleLookAheadTime := *typedInput.ScaleLookAheadTime
		policy.ScaleLookAheadTime = &scaleLookAheadTime
	}

	// Set property "ScaleMode":
	if typedInput.ScaleMode != nil {
		var temp string
		temp = string(*typedInput.ScaleMode)
		scaleMode := PredictiveAutoscalePolicy_ScaleMode(temp)
		policy.ScaleMode = &scaleMode
	}

	// No error
	return nil
}

// AssignProperties_From_PredictiveAutoscalePolicy populates our PredictiveAutoscalePolicy from the provided source PredictiveAutoscalePolicy
func (policy *PredictiveAutoscalePolicy) AssignProperties_From_PredictiveAutoscalePolicy(source *storage.PredictiveAutoscalePolicy) error {

	// ScaleLookAheadTime
	policy.ScaleLookAheadTime = genruntime.ClonePointerToString(source.ScaleLookAheadTime)

	// ScaleMode
	if source.ScaleMode != nil {
		scaleMode := *source.ScaleMode
		scaleModeTemp := genruntime.ToEnum(scaleMode, predictiveAutoscalePolicy_ScaleMode_Values)
		policy.ScaleMode = &scaleModeTemp
	} else {
		policy.ScaleMode = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PredictiveAutoscalePolicy populates the provided destination PredictiveAutoscalePolicy from our PredictiveAutoscalePolicy
func (policy *PredictiveAutoscalePolicy) AssignProperties_To_PredictiveAutoscalePolicy(destination *storage.PredictiveAutoscalePolicy) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ScaleLookAheadTime
	destination.ScaleLookAheadTime = genruntime.ClonePointerToString(policy.ScaleLookAheadTime)

	// ScaleMode
	if policy.ScaleMode != nil {
		scaleMode := string(*policy.ScaleMode)
		destination.ScaleMode = &scaleMode
	} else {
		destination.ScaleMode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_PredictiveAutoscalePolicy_STATUS populates our PredictiveAutoscalePolicy from the provided source PredictiveAutoscalePolicy_STATUS
func (policy *PredictiveAutoscalePolicy) Initialize_From_PredictiveAutoscalePolicy_STATUS(source *PredictiveAutoscalePolicy_STATUS) error {

	// ScaleLookAheadTime
	policy.ScaleLookAheadTime = genruntime.ClonePointerToString(source.ScaleLookAheadTime)

	// ScaleMode
	if source.ScaleMode != nil {
		scaleMode := genruntime.ToEnum(string(*source.ScaleMode), predictiveAutoscalePolicy_ScaleMode_Values)
		policy.ScaleMode = &scaleMode
	} else {
		policy.ScaleMode = nil
	}

	// No error
	return nil
}

// The parameters for enabling predictive autoscale.
type PredictiveAutoscalePolicy_STATUS struct {
	// ScaleLookAheadTime: the amount of time to specify by which instances are launched in advance. It must be between 1
	// minute and 60 minutes in ISO 8601 format.
	ScaleLookAheadTime *string `json:"scaleLookAheadTime,omitempty"`

	// ScaleMode: the predictive autoscale mode
	ScaleMode *PredictiveAutoscalePolicy_ScaleMode_STATUS `json:"scaleMode,omitempty"`
}

var _ genruntime.FromARMConverter = &PredictiveAutoscalePolicy_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *PredictiveAutoscalePolicy_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PredictiveAutoscalePolicy_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *PredictiveAutoscalePolicy_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PredictiveAutoscalePolicy_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PredictiveAutoscalePolicy_STATUS, got %T", armInput)
	}

	// Set property "ScaleLookAheadTime":
	if typedInput.ScaleLookAheadTime != nil {
		scaleLookAheadTime := *typedInput.ScaleLookAheadTime
		policy.ScaleLookAheadTime = &scaleLookAheadTime
	}

	// Set property "ScaleMode":
	if typedInput.ScaleMode != nil {
		var temp string
		temp = string(*typedInput.ScaleMode)
		scaleMode := PredictiveAutoscalePolicy_ScaleMode_STATUS(temp)
		policy.ScaleMode = &scaleMode
	}

	// No error
	return nil
}

// AssignProperties_From_PredictiveAutoscalePolicy_STATUS populates our PredictiveAutoscalePolicy_STATUS from the provided source PredictiveAutoscalePolicy_STATUS
func (policy *PredictiveAutoscalePolicy_STATUS) AssignProperties_From_PredictiveAutoscalePolicy_STATUS(source *storage.PredictiveAutoscalePolicy_STATUS) error {

	// ScaleLookAheadTime
	policy.ScaleLookAheadTime = genruntime.ClonePointerToString(source.ScaleLookAheadTime)

	// ScaleMode
	if source.ScaleMode != nil {
		scaleMode := *source.ScaleMode
		scaleModeTemp := genruntime.ToEnum(scaleMode, predictiveAutoscalePolicy_ScaleMode_STATUS_Values)
		policy.ScaleMode = &scaleModeTemp
	} else {
		policy.ScaleMode = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PredictiveAutoscalePolicy_STATUS populates the provided destination PredictiveAutoscalePolicy_STATUS from our PredictiveAutoscalePolicy_STATUS
func (policy *PredictiveAutoscalePolicy_STATUS) AssignProperties_To_PredictiveAutoscalePolicy_STATUS(destination *storage.PredictiveAutoscalePolicy_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ScaleLookAheadTime
	destination.ScaleLookAheadTime = genruntime.ClonePointerToString(policy.ScaleLookAheadTime)

	// ScaleMode
	if policy.ScaleMode != nil {
		scaleMode := string(*policy.ScaleMode)
		destination.ScaleMode = &scaleMode
	} else {
		destination.ScaleMode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Metadata pertaining to creation and last modification of the resource.
type SystemData_STATUS struct {
	// CreatedAt: The timestamp of resource creation (UTC).
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy: The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`

	// CreatedByType: The type of identity that created the resource.
	CreatedByType *SystemData_CreatedByType_STATUS `json:"createdByType,omitempty"`

	// LastModifiedAt: The timestamp of resource last modification (UTC)
	LastModifiedAt *string `json:"lastModifiedAt,omitempty"`

	// LastModifiedBy: The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`

	// LastModifiedByType: The type of identity that last modified the resource.
	LastModifiedByType *SystemData_LastModifiedByType_STATUS `json:"lastModifiedByType,omitempty"`
}

var _ genruntime.FromARMConverter = &SystemData_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (data *SystemData_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SystemData_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (data *SystemData_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SystemData_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SystemData_STATUS, got %T", armInput)
	}

	// Set property "CreatedAt":
	if typedInput.CreatedAt != nil {
		createdAt := *typedInput.CreatedAt
		data.CreatedAt = &createdAt
	}

	// Set property "CreatedBy":
	if typedInput.CreatedBy != nil {
		createdBy := *typedInput.CreatedBy
		data.CreatedBy = &createdBy
	}

	// Set property "CreatedByType":
	if typedInput.CreatedByType != nil {
		var temp string
		temp = string(*typedInput.CreatedByType)
		createdByType := SystemData_CreatedByType_STATUS(temp)
		data.CreatedByType = &createdByType
	}

	// Set property "LastModifiedAt":
	if typedInput.LastModifiedAt != nil {
		lastModifiedAt := *typedInput.LastModifiedAt
		data.LastModifiedAt = &lastModifiedAt
	}

	// Set property "LastModifiedBy":
	if typedInput.LastModifiedBy != nil {
		lastModifiedBy := *typedInput.LastModifiedBy
		data.LastModifiedBy = &lastModifiedBy
	}

	// Set property "LastModifiedByType":
	if typedInput.LastModifiedByType != nil {
		var temp string
		temp = string(*typedInput.LastModifiedByType)
		lastModifiedByType := SystemData_LastModifiedByType_STATUS(temp)
		data.LastModifiedByType = &lastModifiedByType
	}

	// No error
	return nil
}

// AssignProperties_From_SystemData_STATUS populates our SystemData_STATUS from the provided source SystemData_STATUS
func (data *SystemData_STATUS) AssignProperties_From_SystemData_STATUS(source *storage.SystemData_STATUS) error {

	// CreatedAt
	data.CreatedAt = genruntime.ClonePointerToString(source.CreatedAt)

	// CreatedBy
	data.CreatedBy = genruntime.ClonePointerToString(source.CreatedBy)

	// CreatedByType
	if source.CreatedByType != nil {
		createdByType := *source.CreatedByType
		createdByTypeTemp := genruntime.ToEnum(createdByType, systemData_CreatedByType_STATUS_Values)
		data.CreatedByType = &createdByTypeTemp
	} else {
		data.CreatedByType = nil
	}

	// LastModifiedAt
	data.LastModifiedAt = genruntime.ClonePointerToString(source.LastModifiedAt)

	// LastModifiedBy
	data.LastModifiedBy = genruntime.ClonePointerToString(source.LastModifiedBy)

	// LastModifiedByType
	if source.LastModifiedByType != nil {
		lastModifiedByType := *source.LastModifiedByType
		lastModifiedByTypeTemp := genruntime.ToEnum(lastModifiedByType, systemData_LastModifiedByType_STATUS_Values)
		data.LastModifiedByType = &lastModifiedByTypeTemp
	} else {
		data.LastModifiedByType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SystemData_STATUS populates the provided destination SystemData_STATUS from our SystemData_STATUS
func (data *SystemData_STATUS) AssignProperties_To_SystemData_STATUS(destination *storage.SystemData_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CreatedAt
	destination.CreatedAt = genruntime.ClonePointerToString(data.CreatedAt)

	// CreatedBy
	destination.CreatedBy = genruntime.ClonePointerToString(data.CreatedBy)

	// CreatedByType
	if data.CreatedByType != nil {
		createdByType := string(*data.CreatedByType)
		destination.CreatedByType = &createdByType
	} else {
		destination.CreatedByType = nil
	}

	// LastModifiedAt
	destination.LastModifiedAt = genruntime.ClonePointerToString(data.LastModifiedAt)

	// LastModifiedBy
	destination.LastModifiedBy = genruntime.ClonePointerToString(data.LastModifiedBy)

	// LastModifiedByType
	if data.LastModifiedByType != nil {
		lastModifiedByType := string(*data.LastModifiedByType)
		destination.LastModifiedByType = &lastModifiedByType
	} else {
		destination.LastModifiedByType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Scale"}
type AutoscaleNotification_Operation string

const AutoscaleNotification_Operation_Scale = AutoscaleNotification_Operation("Scale")

// Mapping from string to AutoscaleNotification_Operation
var autoscaleNotification_Operation_Values = map[string]AutoscaleNotification_Operation{
	"scale": AutoscaleNotification_Operation_Scale,
}

type AutoscaleNotification_Operation_STATUS string

const AutoscaleNotification_Operation_STATUS_Scale = AutoscaleNotification_Operation_STATUS("Scale")

// Mapping from string to AutoscaleNotification_Operation_STATUS
var autoscaleNotification_Operation_STATUS_Values = map[string]AutoscaleNotification_Operation_STATUS{
	"scale": AutoscaleNotification_Operation_STATUS_Scale,
}

// Email notification of an autoscale event.
type EmailNotification struct {
	// CustomEmails: the custom e-mails list. This value can be null or empty, in which case this attribute will be ignored.
	CustomEmails []string `json:"customEmails,omitempty"`

	// SendToSubscriptionAdministrator: a value indicating whether to send email to subscription administrator.
	SendToSubscriptionAdministrator *bool `json:"sendToSubscriptionAdministrator,omitempty"`

	// SendToSubscriptionCoAdministrators: a value indicating whether to send email to subscription co-administrators.
	SendToSubscriptionCoAdministrators *bool `json:"sendToSubscriptionCoAdministrators,omitempty"`
}

var _ genruntime.ARMTransformer = &EmailNotification{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (notification *EmailNotification) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if notification == nil {
		return nil, nil
	}
	result := &arm.EmailNotification{}

	// Set property "CustomEmails":
	for _, item := range notification.CustomEmails {
		result.CustomEmails = append(result.CustomEmails, item)
	}

	// Set property "SendToSubscriptionAdministrator":
	if notification.SendToSubscriptionAdministrator != nil {
		sendToSubscriptionAdministrator := *notification.SendToSubscriptionAdministrator
		result.SendToSubscriptionAdministrator = &sendToSubscriptionAdministrator
	}

	// Set property "SendToSubscriptionCoAdministrators":
	if notification.SendToSubscriptionCoAdministrators != nil {
		sendToSubscriptionCoAdministrators := *notification.SendToSubscriptionCoAdministrators
		result.SendToSubscriptionCoAdministrators = &sendToSubscriptionCoAdministrators
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (notification *EmailNotification) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EmailNotification{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (notification *EmailNotification) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EmailNotification)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EmailNotification, got %T", armInput)
	}

	// Set property "CustomEmails":
	for _, item := range typedInput.CustomEmails {
		notification.CustomEmails = append(notification.CustomEmails, item)
	}

	// Set property "SendToSubscriptionAdministrator":
	if typedInput.SendToSubscriptionAdministrator != nil {
		sendToSubscriptionAdministrator := *typedInput.SendToSubscriptionAdministrator
		notification.SendToSubscriptionAdministrator = &sendToSubscriptionAdministrator
	}

	// Set property "SendToSubscriptionCoAdministrators":
	if typedInput.SendToSubscriptionCoAdministrators != nil {
		sendToSubscriptionCoAdministrators := *typedInput.SendToSubscriptionCoAdministrators
		notification.SendToSubscriptionCoAdministrators = &sendToSubscriptionCoAdministrators
	}

	// No error
	return nil
}

// AssignProperties_From_EmailNotification populates our EmailNotification from the provided source EmailNotification
func (notification *EmailNotification) AssignProperties_From_EmailNotification(source *storage.EmailNotification) error {

	// CustomEmails
	notification.CustomEmails = genruntime.CloneSliceOfString(source.CustomEmails)

	// SendToSubscriptionAdministrator
	if source.SendToSubscriptionAdministrator != nil {
		sendToSubscriptionAdministrator := *source.SendToSubscriptionAdministrator
		notification.SendToSubscriptionAdministrator = &sendToSubscriptionAdministrator
	} else {
		notification.SendToSubscriptionAdministrator = nil
	}

	// SendToSubscriptionCoAdministrators
	if source.SendToSubscriptionCoAdministrators != nil {
		sendToSubscriptionCoAdministrator := *source.SendToSubscriptionCoAdministrators
		notification.SendToSubscriptionCoAdministrators = &sendToSubscriptionCoAdministrator
	} else {
		notification.SendToSubscriptionCoAdministrators = nil
	}

	// No error
	return nil
}

// AssignProperties_To_EmailNotification populates the provided destination EmailNotification from our EmailNotification
func (notification *EmailNotification) AssignProperties_To_EmailNotification(destination *storage.EmailNotification) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CustomEmails
	destination.CustomEmails = genruntime.CloneSliceOfString(notification.CustomEmails)

	// SendToSubscriptionAdministrator
	if notification.SendToSubscriptionAdministrator != nil {
		sendToSubscriptionAdministrator := *notification.SendToSubscriptionAdministrator
		destination.SendToSubscriptionAdministrator = &sendToSubscriptionAdministrator
	} else {
		destination.SendToSubscriptionAdministrator = nil
	}

	// SendToSubscriptionCoAdministrators
	if notification.SendToSubscriptionCoAdministrators != nil {
		sendToSubscriptionCoAdministrator := *notification.SendToSubscriptionCoAdministrators
		destination.SendToSubscriptionCoAdministrators = &sendToSubscriptionCoAdministrator
	} else {
		destination.SendToSubscriptionCoAdministrators = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_EmailNotification_STATUS populates our EmailNotification from the provided source EmailNotification_STATUS
func (notification *EmailNotification) Initialize_From_EmailNotification_STATUS(source *EmailNotification_STATUS) error {

	// CustomEmails
	notification.CustomEmails = genruntime.CloneSliceOfString(source.CustomEmails)

	// SendToSubscriptionAdministrator
	if source.SendToSubscriptionAdministrator != nil {
		sendToSubscriptionAdministrator := *source.SendToSubscriptionAdministrator
		notification.SendToSubscriptionAdministrator = &sendToSubscriptionAdministrator
	} else {
		notification.SendToSubscriptionAdministrator = nil
	}

	// SendToSubscriptionCoAdministrators
	if source.SendToSubscriptionCoAdministrators != nil {
		sendToSubscriptionCoAdministrator := *source.SendToSubscriptionCoAdministrators
		notification.SendToSubscriptionCoAdministrators = &sendToSubscriptionCoAdministrator
	} else {
		notification.SendToSubscriptionCoAdministrators = nil
	}

	// No error
	return nil
}

// Email notification of an autoscale event.
type EmailNotification_STATUS struct {
	// CustomEmails: the custom e-mails list. This value can be null or empty, in which case this attribute will be ignored.
	CustomEmails []string `json:"customEmails,omitempty"`

	// SendToSubscriptionAdministrator: a value indicating whether to send email to subscription administrator.
	SendToSubscriptionAdministrator *bool `json:"sendToSubscriptionAdministrator,omitempty"`

	// SendToSubscriptionCoAdministrators: a value indicating whether to send email to subscription co-administrators.
	SendToSubscriptionCoAdministrators *bool `json:"sendToSubscriptionCoAdministrators,omitempty"`
}

var _ genruntime.FromARMConverter = &EmailNotification_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (notification *EmailNotification_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EmailNotification_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (notification *EmailNotification_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EmailNotification_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EmailNotification_STATUS, got %T", armInput)
	}

	// Set property "CustomEmails":
	for _, item := range typedInput.CustomEmails {
		notification.CustomEmails = append(notification.CustomEmails, item)
	}

	// Set property "SendToSubscriptionAdministrator":
	if typedInput.SendToSubscriptionAdministrator != nil {
		sendToSubscriptionAdministrator := *typedInput.SendToSubscriptionAdministrator
		notification.SendToSubscriptionAdministrator = &sendToSubscriptionAdministrator
	}

	// Set property "SendToSubscriptionCoAdministrators":
	if typedInput.SendToSubscriptionCoAdministrators != nil {
		sendToSubscriptionCoAdministrators := *typedInput.SendToSubscriptionCoAdministrators
		notification.SendToSubscriptionCoAdministrators = &sendToSubscriptionCoAdministrators
	}

	// No error
	return nil
}

// AssignProperties_From_EmailNotification_STATUS populates our EmailNotification_STATUS from the provided source EmailNotification_STATUS
func (notification *EmailNotification_STATUS) AssignProperties_From_EmailNotification_STATUS(source *storage.EmailNotification_STATUS) error {

	// CustomEmails
	notification.CustomEmails = genruntime.CloneSliceOfString(source.CustomEmails)

	// SendToSubscriptionAdministrator
	if source.SendToSubscriptionAdministrator != nil {
		sendToSubscriptionAdministrator := *source.SendToSubscriptionAdministrator
		notification.SendToSubscriptionAdministrator = &sendToSubscriptionAdministrator
	} else {
		notification.SendToSubscriptionAdministrator = nil
	}

	// SendToSubscriptionCoAdministrators
	if source.SendToSubscriptionCoAdministrators != nil {
		sendToSubscriptionCoAdministrator := *source.SendToSubscriptionCoAdministrators
		notification.SendToSubscriptionCoAdministrators = &sendToSubscriptionCoAdministrator
	} else {
		notification.SendToSubscriptionCoAdministrators = nil
	}

	// No error
	return nil
}

// AssignProperties_To_EmailNotification_STATUS populates the provided destination EmailNotification_STATUS from our EmailNotification_STATUS
func (notification *EmailNotification_STATUS) AssignProperties_To_EmailNotification_STATUS(destination *storage.EmailNotification_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CustomEmails
	destination.CustomEmails = genruntime.CloneSliceOfString(notification.CustomEmails)

	// SendToSubscriptionAdministrator
	if notification.SendToSubscriptionAdministrator != nil {
		sendToSubscriptionAdministrator := *notification.SendToSubscriptionAdministrator
		destination.SendToSubscriptionAdministrator = &sendToSubscriptionAdministrator
	} else {
		destination.SendToSubscriptionAdministrator = nil
	}

	// SendToSubscriptionCoAdministrators
	if notification.SendToSubscriptionCoAdministrators != nil {
		sendToSubscriptionCoAdministrator := *notification.SendToSubscriptionCoAdministrators
		destination.SendToSubscriptionCoAdministrators = &sendToSubscriptionCoAdministrator
	} else {
		destination.SendToSubscriptionCoAdministrators = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Disabled","Enabled","ForecastOnly"}
type PredictiveAutoscalePolicy_ScaleMode string

const (
	PredictiveAutoscalePolicy_ScaleMode_Disabled     = PredictiveAutoscalePolicy_ScaleMode("Disabled")
	PredictiveAutoscalePolicy_ScaleMode_Enabled      = PredictiveAutoscalePolicy_ScaleMode("Enabled")
	PredictiveAutoscalePolicy_ScaleMode_ForecastOnly = PredictiveAutoscalePolicy_ScaleMode("ForecastOnly")
)

// Mapping from string to PredictiveAutoscalePolicy_ScaleMode
var predictiveAutoscalePolicy_ScaleMode_Values = map[string]PredictiveAutoscalePolicy_ScaleMode{
	"disabled":     PredictiveAutoscalePolicy_ScaleMode_Disabled,
	"enabled":      PredictiveAutoscalePolicy_ScaleMode_Enabled,
	"forecastonly": PredictiveAutoscalePolicy_ScaleMode_ForecastOnly,
}

type PredictiveAutoscalePolicy_ScaleMode_STATUS string

const (
	PredictiveAutoscalePolicy_ScaleMode_STATUS_Disabled     = PredictiveAutoscalePolicy_ScaleMode_STATUS("Disabled")
	PredictiveAutoscalePolicy_ScaleMode_STATUS_Enabled      = PredictiveAutoscalePolicy_ScaleMode_STATUS("Enabled")
	PredictiveAutoscalePolicy_ScaleMode_STATUS_ForecastOnly = PredictiveAutoscalePolicy_ScaleMode_STATUS("ForecastOnly")
)

// Mapping from string to PredictiveAutoscalePolicy_ScaleMode_STATUS
var predictiveAutoscalePolicy_ScaleMode_STATUS_Values = map[string]PredictiveAutoscalePolicy_ScaleMode_STATUS{
	"disabled":     PredictiveAutoscalePolicy_ScaleMode_STATUS_Disabled,
	"enabled":      PredictiveAutoscalePolicy_ScaleMode_STATUS_Enabled,
	"forecastonly": PredictiveAutoscalePolicy_ScaleMode_STATUS_ForecastOnly,
}

// The repeating times at which this profile begins. This element is not used if the FixedDate element is used.
type Recurrence struct {
	// +kubebuilder:validation:Required
	// Frequency: the recurrence frequency. How often the schedule profile should take effect. This value must be Week, meaning
	// each week will have the same set of profiles. For example, to set a daily schedule, set schedule to every day of the
	// week. The frequency property specifies that the schedule is repeated weekly.
	Frequency *Recurrence_Frequency `json:"frequency,omitempty"`

	// +kubebuilder:validation:Required
	// Schedule: the scheduling constraints for when the profile begins.
	Schedule *RecurrentSchedule `json:"schedule,omitempty"`
}

var _ genruntime.ARMTransformer = &Recurrence{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (recurrence *Recurrence) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if recurrence == nil {
		return nil, nil
	}
	result := &arm.Recurrence{}

	// Set property "Frequency":
	if recurrence.Frequency != nil {
		var temp string
		temp = string(*recurrence.Frequency)
		frequency := arm.Recurrence_Frequency(temp)
		result.Frequency = &frequency
	}

	// Set property "Schedule":
	if recurrence.Schedule != nil {
		schedule_ARM, err := (*recurrence.Schedule).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		schedule := *schedule_ARM.(*arm.RecurrentSchedule)
		result.Schedule = &schedule
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (recurrence *Recurrence) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Recurrence{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (recurrence *Recurrence) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Recurrence)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Recurrence, got %T", armInput)
	}

	// Set property "Frequency":
	if typedInput.Frequency != nil {
		var temp string
		temp = string(*typedInput.Frequency)
		frequency := Recurrence_Frequency(temp)
		recurrence.Frequency = &frequency
	}

	// Set property "Schedule":
	if typedInput.Schedule != nil {
		var schedule1 RecurrentSchedule
		err := schedule1.PopulateFromARM(owner, *typedInput.Schedule)
		if err != nil {
			return err
		}
		schedule := schedule1
		recurrence.Schedule = &schedule
	}

	// No error
	return nil
}

// AssignProperties_From_Recurrence populates our Recurrence from the provided source Recurrence
func (recurrence *Recurrence) AssignProperties_From_Recurrence(source *storage.Recurrence) error {

	// Frequency
	if source.Frequency != nil {
		frequency := *source.Frequency
		frequencyTemp := genruntime.ToEnum(frequency, recurrence_Frequency_Values)
		recurrence.Frequency = &frequencyTemp
	} else {
		recurrence.Frequency = nil
	}

	// Schedule
	if source.Schedule != nil {
		var schedule RecurrentSchedule
		err := schedule.AssignProperties_From_RecurrentSchedule(source.Schedule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RecurrentSchedule() to populate field Schedule")
		}
		recurrence.Schedule = &schedule
	} else {
		recurrence.Schedule = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Recurrence populates the provided destination Recurrence from our Recurrence
func (recurrence *Recurrence) AssignProperties_To_Recurrence(destination *storage.Recurrence) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Frequency
	if recurrence.Frequency != nil {
		frequency := string(*recurrence.Frequency)
		destination.Frequency = &frequency
	} else {
		destination.Frequency = nil
	}

	// Schedule
	if recurrence.Schedule != nil {
		var schedule storage.RecurrentSchedule
		err := recurrence.Schedule.AssignProperties_To_RecurrentSchedule(&schedule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RecurrentSchedule() to populate field Schedule")
		}
		destination.Schedule = &schedule
	} else {
		destination.Schedule = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Recurrence_STATUS populates our Recurrence from the provided source Recurrence_STATUS
func (recurrence *Recurrence) Initialize_From_Recurrence_STATUS(source *Recurrence_STATUS) error {

	// Frequency
	if source.Frequency != nil {
		frequency := genruntime.ToEnum(string(*source.Frequency), recurrence_Frequency_Values)
		recurrence.Frequency = &frequency
	} else {
		recurrence.Frequency = nil
	}

	// Schedule
	if source.Schedule != nil {
		var schedule RecurrentSchedule
		err := schedule.Initialize_From_RecurrentSchedule_STATUS(source.Schedule)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_RecurrentSchedule_STATUS() to populate field Schedule")
		}
		recurrence.Schedule = &schedule
	} else {
		recurrence.Schedule = nil
	}

	// No error
	return nil
}

// The repeating times at which this profile begins. This element is not used if the FixedDate element is used.
type Recurrence_STATUS struct {
	// +kubebuilder:validation:Required
	// Frequency: the recurrence frequency. How often the schedule profile should take effect. This value must be Week, meaning
	// each week will have the same set of profiles. For example, to set a daily schedule, set schedule to every day of the
	// week. The frequency property specifies that the schedule is repeated weekly.
	Frequency *Recurrence_Frequency_STATUS `json:"frequency,omitempty"`

	// +kubebuilder:validation:Required
	// Schedule: the scheduling constraints for when the profile begins.
	Schedule *RecurrentSchedule_STATUS `json:"schedule,omitempty"`
}

var _ genruntime.FromARMConverter = &Recurrence_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (recurrence *Recurrence_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Recurrence_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (recurrence *Recurrence_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Recurrence_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Recurrence_STATUS, got %T", armInput)
	}

	// Set property "Frequency":
	if typedInput.Frequency != nil {
		var temp string
		temp = string(*typedInput.Frequency)
		frequency := Recurrence_Frequency_STATUS(temp)
		recurrence.Frequency = &frequency
	}

	// Set property "Schedule":
	if typedInput.Schedule != nil {
		var schedule1 RecurrentSchedule_STATUS
		err := schedule1.PopulateFromARM(owner, *typedInput.Schedule)
		if err != nil {
			return err
		}
		schedule := schedule1
		recurrence.Schedule = &schedule
	}

	// No error
	return nil
}

// AssignProperties_From_Recurrence_STATUS populates our Recurrence_STATUS from the provided source Recurrence_STATUS
func (recurrence *Recurrence_STATUS) AssignProperties_From_Recurrence_STATUS(source *storage.Recurrence_STATUS) error {

	// Frequency
	if source.Frequency != nil {
		frequency := *source.Frequency
		frequencyTemp := genruntime.ToEnum(frequency, recurrence_Frequency_STATUS_Values)
		recurrence.Frequency = &frequencyTemp
	} else {
		recurrence.Frequency = nil
	}

	// Schedule
	if source.Schedule != nil {
		var schedule RecurrentSchedule_STATUS
		err := schedule.AssignProperties_From_RecurrentSchedule_STATUS(source.Schedule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RecurrentSchedule_STATUS() to populate field Schedule")
		}
		recurrence.Schedule = &schedule
	} else {
		recurrence.Schedule = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Recurrence_STATUS populates the provided destination Recurrence_STATUS from our Recurrence_STATUS
func (recurrence *Recurrence_STATUS) AssignProperties_To_Recurrence_STATUS(destination *storage.Recurrence_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Frequency
	if recurrence.Frequency != nil {
		frequency := string(*recurrence.Frequency)
		destination.Frequency = &frequency
	} else {
		destination.Frequency = nil
	}

	// Schedule
	if recurrence.Schedule != nil {
		var schedule storage.RecurrentSchedule_STATUS
		err := recurrence.Schedule.AssignProperties_To_RecurrentSchedule_STATUS(&schedule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RecurrentSchedule_STATUS() to populate field Schedule")
		}
		destination.Schedule = &schedule
	} else {
		destination.Schedule = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The number of instances that can be used during this profile.
type ScaleCapacity struct {
	// +kubebuilder:validation:Required
	// Default: the number of instances that will be set if metrics are not available for evaluation. The default is only used
	// if the current instance count is lower than the default.
	Default *string `json:"default,omitempty"`

	// +kubebuilder:validation:Required
	// Maximum: the maximum number of instances for the resource. The actual maximum number of instances is limited by the
	// cores that are available in the subscription.
	Maximum *string `json:"maximum,omitempty"`

	// +kubebuilder:validation:Required
	// Minimum: the minimum number of instances for the resource.
	Minimum *string `json:"minimum,omitempty"`
}

var _ genruntime.ARMTransformer = &ScaleCapacity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (capacity *ScaleCapacity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if capacity == nil {
		return nil, nil
	}
	result := &arm.ScaleCapacity{}

	// Set property "Default":
	if capacity.Default != nil {
		def := *capacity.Default
		result.Default = &def
	}

	// Set property "Maximum":
	if capacity.Maximum != nil {
		maximum := *capacity.Maximum
		result.Maximum = &maximum
	}

	// Set property "Minimum":
	if capacity.Minimum != nil {
		minimum := *capacity.Minimum
		result.Minimum = &minimum
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (capacity *ScaleCapacity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ScaleCapacity{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (capacity *ScaleCapacity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ScaleCapacity)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ScaleCapacity, got %T", armInput)
	}

	// Set property "Default":
	if typedInput.Default != nil {
		def := *typedInput.Default
		capacity.Default = &def
	}

	// Set property "Maximum":
	if typedInput.Maximum != nil {
		maximum := *typedInput.Maximum
		capacity.Maximum = &maximum
	}

	// Set property "Minimum":
	if typedInput.Minimum != nil {
		minimum := *typedInput.Minimum
		capacity.Minimum = &minimum
	}

	// No error
	return nil
}

// AssignProperties_From_ScaleCapacity populates our ScaleCapacity from the provided source ScaleCapacity
func (capacity *ScaleCapacity) AssignProperties_From_ScaleCapacity(source *storage.ScaleCapacity) error {

	// Default
	capacity.Default = genruntime.ClonePointerToString(source.Default)

	// Maximum
	capacity.Maximum = genruntime.ClonePointerToString(source.Maximum)

	// Minimum
	capacity.Minimum = genruntime.ClonePointerToString(source.Minimum)

	// No error
	return nil
}

// AssignProperties_To_ScaleCapacity populates the provided destination ScaleCapacity from our ScaleCapacity
func (capacity *ScaleCapacity) AssignProperties_To_ScaleCapacity(destination *storage.ScaleCapacity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Default
	destination.Default = genruntime.ClonePointerToString(capacity.Default)

	// Maximum
	destination.Maximum = genruntime.ClonePointerToString(capacity.Maximum)

	// Minimum
	destination.Minimum = genruntime.ClonePointerToString(capacity.Minimum)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ScaleCapacity_STATUS populates our ScaleCapacity from the provided source ScaleCapacity_STATUS
func (capacity *ScaleCapacity) Initialize_From_ScaleCapacity_STATUS(source *ScaleCapacity_STATUS) error {

	// Default
	capacity.Default = genruntime.ClonePointerToString(source.Default)

	// Maximum
	capacity.Maximum = genruntime.ClonePointerToString(source.Maximum)

	// Minimum
	capacity.Minimum = genruntime.ClonePointerToString(source.Minimum)

	// No error
	return nil
}

// The number of instances that can be used during this profile.
type ScaleCapacity_STATUS struct {
	// +kubebuilder:validation:Required
	// Default: the number of instances that will be set if metrics are not available for evaluation. The default is only used
	// if the current instance count is lower than the default.
	Default *string `json:"default,omitempty"`

	// +kubebuilder:validation:Required
	// Maximum: the maximum number of instances for the resource. The actual maximum number of instances is limited by the
	// cores that are available in the subscription.
	Maximum *string `json:"maximum,omitempty"`

	// +kubebuilder:validation:Required
	// Minimum: the minimum number of instances for the resource.
	Minimum *string `json:"minimum,omitempty"`
}

var _ genruntime.FromARMConverter = &ScaleCapacity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (capacity *ScaleCapacity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ScaleCapacity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (capacity *ScaleCapacity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ScaleCapacity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ScaleCapacity_STATUS, got %T", armInput)
	}

	// Set property "Default":
	if typedInput.Default != nil {
		def := *typedInput.Default
		capacity.Default = &def
	}

	// Set property "Maximum":
	if typedInput.Maximum != nil {
		maximum := *typedInput.Maximum
		capacity.Maximum = &maximum
	}

	// Set property "Minimum":
	if typedInput.Minimum != nil {
		minimum := *typedInput.Minimum
		capacity.Minimum = &minimum
	}

	// No error
	return nil
}

// AssignProperties_From_ScaleCapacity_STATUS populates our ScaleCapacity_STATUS from the provided source ScaleCapacity_STATUS
func (capacity *ScaleCapacity_STATUS) AssignProperties_From_ScaleCapacity_STATUS(source *storage.ScaleCapacity_STATUS) error {

	// Default
	capacity.Default = genruntime.ClonePointerToString(source.Default)

	// Maximum
	capacity.Maximum = genruntime.ClonePointerToString(source.Maximum)

	// Minimum
	capacity.Minimum = genruntime.ClonePointerToString(source.Minimum)

	// No error
	return nil
}

// AssignProperties_To_ScaleCapacity_STATUS populates the provided destination ScaleCapacity_STATUS from our ScaleCapacity_STATUS
func (capacity *ScaleCapacity_STATUS) AssignProperties_To_ScaleCapacity_STATUS(destination *storage.ScaleCapacity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Default
	destination.Default = genruntime.ClonePointerToString(capacity.Default)

	// Maximum
	destination.Maximum = genruntime.ClonePointerToString(capacity.Maximum)

	// Minimum
	destination.Minimum = genruntime.ClonePointerToString(capacity.Minimum)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// A rule that provide the triggers and parameters for the scaling action.
type ScaleRule struct {
	// +kubebuilder:validation:Required
	// MetricTrigger: the trigger that results in a scaling action.
	MetricTrigger *MetricTrigger `json:"metricTrigger,omitempty"`

	// +kubebuilder:validation:Required
	// ScaleAction: the parameters for the scaling action.
	ScaleAction *ScaleAction `json:"scaleAction,omitempty"`
}

var _ genruntime.ARMTransformer = &ScaleRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *ScaleRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.ScaleRule{}

	// Set property "MetricTrigger":
	if rule.MetricTrigger != nil {
		metricTrigger_ARM, err := (*rule.MetricTrigger).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		metricTrigger := *metricTrigger_ARM.(*arm.MetricTrigger)
		result.MetricTrigger = &metricTrigger
	}

	// Set property "ScaleAction":
	if rule.ScaleAction != nil {
		scaleAction_ARM, err := (*rule.ScaleAction).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		scaleAction := *scaleAction_ARM.(*arm.ScaleAction)
		result.ScaleAction = &scaleAction
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *ScaleRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ScaleRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *ScaleRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ScaleRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ScaleRule, got %T", armInput)
	}

	// Set property "MetricTrigger":
	if typedInput.MetricTrigger != nil {
		var metricTrigger1 MetricTrigger
		err := metricTrigger1.PopulateFromARM(owner, *typedInput.MetricTrigger)
		if err != nil {
			return err
		}
		metricTrigger := metricTrigger1
		rule.MetricTrigger = &metricTrigger
	}

	// Set property "ScaleAction":
	if typedInput.ScaleAction != nil {
		var scaleAction1 ScaleAction
		err := scaleAction1.PopulateFromARM(owner, *typedInput.ScaleAction)
		if err != nil {
			return err
		}
		scaleAction := scaleAction1
		rule.ScaleAction = &scaleAction
	}

	// No error
	return nil
}

// AssignProperties_From_ScaleRule populates our ScaleRule from the provided source ScaleRule
func (rule *ScaleRule) AssignProperties_From_ScaleRule(source *storage.ScaleRule) error {

	// MetricTrigger
	if source.MetricTrigger != nil {
		var metricTrigger MetricTrigger
		err := metricTrigger.AssignProperties_From_MetricTrigger(source.MetricTrigger)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_MetricTrigger() to populate field MetricTrigger")
		}
		rule.MetricTrigger = &metricTrigger
	} else {
		rule.MetricTrigger = nil
	}

	// ScaleAction
	if source.ScaleAction != nil {
		var scaleAction ScaleAction
		err := scaleAction.AssignProperties_From_ScaleAction(source.ScaleAction)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ScaleAction() to populate field ScaleAction")
		}
		rule.ScaleAction = &scaleAction
	} else {
		rule.ScaleAction = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ScaleRule populates the provided destination ScaleRule from our ScaleRule
func (rule *ScaleRule) AssignProperties_To_ScaleRule(destination *storage.ScaleRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MetricTrigger
	if rule.MetricTrigger != nil {
		var metricTrigger storage.MetricTrigger
		err := rule.MetricTrigger.AssignProperties_To_MetricTrigger(&metricTrigger)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_MetricTrigger() to populate field MetricTrigger")
		}
		destination.MetricTrigger = &metricTrigger
	} else {
		destination.MetricTrigger = nil
	}

	// ScaleAction
	if rule.ScaleAction != nil {
		var scaleAction storage.ScaleAction
		err := rule.ScaleAction.AssignProperties_To_ScaleAction(&scaleAction)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ScaleAction() to populate field ScaleAction")
		}
		destination.ScaleAction = &scaleAction
	} else {
		destination.ScaleAction = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ScaleRule_STATUS populates our ScaleRule from the provided source ScaleRule_STATUS
func (rule *ScaleRule) Initialize_From_ScaleRule_STATUS(source *ScaleRule_STATUS) error {

	// MetricTrigger
	if source.MetricTrigger != nil {
		var metricTrigger MetricTrigger
		err := metricTrigger.Initialize_From_MetricTrigger_STATUS(source.MetricTrigger)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_MetricTrigger_STATUS() to populate field MetricTrigger")
		}
		rule.MetricTrigger = &metricTrigger
	} else {
		rule.MetricTrigger = nil
	}

	// ScaleAction
	if source.ScaleAction != nil {
		var scaleAction ScaleAction
		err := scaleAction.Initialize_From_ScaleAction_STATUS(source.ScaleAction)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ScaleAction_STATUS() to populate field ScaleAction")
		}
		rule.ScaleAction = &scaleAction
	} else {
		rule.ScaleAction = nil
	}

	// No error
	return nil
}

// A rule that provide the triggers and parameters for the scaling action.
type ScaleRule_STATUS struct {
	// +kubebuilder:validation:Required
	// MetricTrigger: the trigger that results in a scaling action.
	MetricTrigger *MetricTrigger_STATUS `json:"metricTrigger,omitempty"`

	// +kubebuilder:validation:Required
	// ScaleAction: the parameters for the scaling action.
	ScaleAction *ScaleAction_STATUS `json:"scaleAction,omitempty"`
}

var _ genruntime.FromARMConverter = &ScaleRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *ScaleRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ScaleRule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *ScaleRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ScaleRule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ScaleRule_STATUS, got %T", armInput)
	}

	// Set property "MetricTrigger":
	if typedInput.MetricTrigger != nil {
		var metricTrigger1 MetricTrigger_STATUS
		err := metricTrigger1.PopulateFromARM(owner, *typedInput.MetricTrigger)
		if err != nil {
			return err
		}
		metricTrigger := metricTrigger1
		rule.MetricTrigger = &metricTrigger
	}

	// Set property "ScaleAction":
	if typedInput.ScaleAction != nil {
		var scaleAction1 ScaleAction_STATUS
		err := scaleAction1.PopulateFromARM(owner, *typedInput.ScaleAction)
		if err != nil {
			return err
		}
		scaleAction := scaleAction1
		rule.ScaleAction = &scaleAction
	}

	// No error
	return nil
}

// AssignProperties_From_ScaleRule_STATUS populates our ScaleRule_STATUS from the provided source ScaleRule_STATUS
func (rule *ScaleRule_STATUS) AssignProperties_From_ScaleRule_STATUS(source *storage.ScaleRule_STATUS) error {

	// MetricTrigger
	if source.MetricTrigger != nil {
		var metricTrigger MetricTrigger_STATUS
		err := metricTrigger.AssignProperties_From_MetricTrigger_STATUS(source.MetricTrigger)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_MetricTrigger_STATUS() to populate field MetricTrigger")
		}
		rule.MetricTrigger = &metricTrigger
	} else {
		rule.MetricTrigger = nil
	}

	// ScaleAction
	if source.ScaleAction != nil {
		var scaleAction ScaleAction_STATUS
		err := scaleAction.AssignProperties_From_ScaleAction_STATUS(source.ScaleAction)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ScaleAction_STATUS() to populate field ScaleAction")
		}
		rule.ScaleAction = &scaleAction
	} else {
		rule.ScaleAction = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ScaleRule_STATUS populates the provided destination ScaleRule_STATUS from our ScaleRule_STATUS
func (rule *ScaleRule_STATUS) AssignProperties_To_ScaleRule_STATUS(destination *storage.ScaleRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MetricTrigger
	if rule.MetricTrigger != nil {
		var metricTrigger storage.MetricTrigger_STATUS
		err := rule.MetricTrigger.AssignProperties_To_MetricTrigger_STATUS(&metricTrigger)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_MetricTrigger_STATUS() to populate field MetricTrigger")
		}
		destination.MetricTrigger = &metricTrigger
	} else {
		destination.MetricTrigger = nil
	}

	// ScaleAction
	if rule.ScaleAction != nil {
		var scaleAction storage.ScaleAction_STATUS
		err := rule.ScaleAction.AssignProperties_To_ScaleAction_STATUS(&scaleAction)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ScaleAction_STATUS() to populate field ScaleAction")
		}
		destination.ScaleAction = &scaleAction
	} else {
		destination.ScaleAction = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type SystemData_CreatedByType_STATUS string

const (
	SystemData_CreatedByType_STATUS_Application     = SystemData_CreatedByType_STATUS("Application")
	SystemData_CreatedByType_STATUS_Key             = SystemData_CreatedByType_STATUS("Key")
	SystemData_CreatedByType_STATUS_ManagedIdentity = SystemData_CreatedByType_STATUS("ManagedIdentity")
	SystemData_CreatedByType_STATUS_User            = SystemData_CreatedByType_STATUS("User")
)

// Mapping from string to SystemData_CreatedByType_STATUS
var systemData_CreatedByType_STATUS_Values = map[string]SystemData_CreatedByType_STATUS{
	"application":     SystemData_CreatedByType_STATUS_Application,
	"key":             SystemData_CreatedByType_STATUS_Key,
	"managedidentity": SystemData_CreatedByType_STATUS_ManagedIdentity,
	"user":            SystemData_CreatedByType_STATUS_User,
}

type SystemData_LastModifiedByType_STATUS string

const (
	SystemData_LastModifiedByType_STATUS_Application     = SystemData_LastModifiedByType_STATUS("Application")
	SystemData_LastModifiedByType_STATUS_Key             = SystemData_LastModifiedByType_STATUS("Key")
	SystemData_LastModifiedByType_STATUS_ManagedIdentity = SystemData_LastModifiedByType_STATUS("ManagedIdentity")
	SystemData_LastModifiedByType_STATUS_User            = SystemData_LastModifiedByType_STATUS("User")
)

// Mapping from string to SystemData_LastModifiedByType_STATUS
var systemData_LastModifiedByType_STATUS_Values = map[string]SystemData_LastModifiedByType_STATUS{
	"application":     SystemData_LastModifiedByType_STATUS_Application,
	"key":             SystemData_LastModifiedByType_STATUS_Key,
	"managedidentity": SystemData_LastModifiedByType_STATUS_ManagedIdentity,
	"user":            SystemData_LastModifiedByType_STATUS_User,
}

// A specific date-time for the profile.
type TimeWindow struct {
	// +kubebuilder:validation:Required
	// End: the end time for the profile in ISO 8601 format.
	End *string `json:"end,omitempty"`

	// +kubebuilder:validation:Required
	// Start: the start time for the profile in ISO 8601 format.
	Start *string `json:"start,omitempty"`

	// TimeZone: the timezone of the start and end times for the profile. Some examples of valid time zones are: Dateline
	// Standard Time, UTC-11, Hawaiian Standard Time, Alaskan Standard Time, Pacific Standard Time (Mexico), Pacific Standard
	// Time, US Mountain Standard Time, Mountain Standard Time (Mexico), Mountain Standard Time, Central America Standard Time,
	// Central Standard Time, Central Standard Time (Mexico), Canada Central Standard Time, SA Pacific Standard Time, Eastern
	// Standard Time, US Eastern Standard Time, Venezuela Standard Time, Paraguay Standard Time, Atlantic Standard Time,
	// Central Brazilian Standard Time, SA Western Standard Time, Pacific SA Standard Time, Newfoundland Standard Time, E.
	// South America Standard Time, Argentina Standard Time, SA Eastern Standard Time, Greenland Standard Time, Montevideo
	// Standard Time, Bahia Standard Time, UTC-02, Mid-Atlantic Standard Time, Azores Standard Time, Cape Verde Standard Time,
	// Morocco Standard Time, UTC, GMT Standard Time, Greenwich Standard Time, W. Europe Standard Time, Central Europe Standard
	// Time, Romance Standard Time, Central European Standard Time, W. Central Africa Standard Time, Namibia Standard Time,
	// Jordan Standard Time, GTB Standard Time, Middle East Standard Time, Egypt Standard Time, Syria Standard Time, E. Europe
	// Standard Time, South Africa Standard Time, FLE Standard Time, Turkey Standard Time, Israel Standard Time, Kaliningrad
	// Standard Time, Libya Standard Time, Arabic Standard Time, Arab Standard Time, Belarus Standard Time, Russian Standard
	// Time, E. Africa Standard Time, Iran Standard Time, Arabian Standard Time, Azerbaijan Standard Time, Russia Time Zone 3,
	// Mauritius Standard Time, Georgian Standard Time, Caucasus Standard Time, Afghanistan Standard Time, West Asia Standard
	// Time, Ekaterinburg Standard Time, Pakistan Standard Time, India Standard Time, Sri Lanka Standard Time, Nepal Standard
	// Time, Central Asia Standard Time, Bangladesh Standard Time, N. Central Asia Standard Time, Myanmar Standard Time, SE
	// Asia Standard Time, North Asia Standard Time, China Standard Time, North Asia East Standard Time, Singapore Standard
	// Time, W. Australia Standard Time, Taipei Standard Time, Ulaanbaatar Standard Time, Tokyo Standard Time, Korea Standard
	// Time, Yakutsk Standard Time, Cen. Australia Standard Time, AUS Central Standard Time, E. Australia Standard Time, AUS
	// Eastern Standard Time, West Pacific Standard Time, Tasmania Standard Time, Magadan Standard Time, Vladivostok Standard
	// Time, Russia Time Zone 10, Central Pacific Standard Time, Russia Time Zone 11, New Zealand Standard Time, UTC+12, Fiji
	// Standard Time, Kamchatka Standard Time, Tonga Standard Time, Samoa Standard Time, Line Islands Standard Time
	TimeZone *string `json:"timeZone,omitempty"`
}

var _ genruntime.ARMTransformer = &TimeWindow{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (window *TimeWindow) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if window == nil {
		return nil, nil
	}
	result := &arm.TimeWindow{}

	// Set property "End":
	if window.End != nil {
		end := *window.End
		result.End = &end
	}

	// Set property "Start":
	if window.Start != nil {
		start := *window.Start
		result.Start = &start
	}

	// Set property "TimeZone":
	if window.TimeZone != nil {
		timeZone := *window.TimeZone
		result.TimeZone = &timeZone
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (window *TimeWindow) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TimeWindow{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (window *TimeWindow) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TimeWindow)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TimeWindow, got %T", armInput)
	}

	// Set property "End":
	if typedInput.End != nil {
		end := *typedInput.End
		window.End = &end
	}

	// Set property "Start":
	if typedInput.Start != nil {
		start := *typedInput.Start
		window.Start = &start
	}

	// Set property "TimeZone":
	if typedInput.TimeZone != nil {
		timeZone := *typedInput.TimeZone
		window.TimeZone = &timeZone
	}

	// No error
	return nil
}

// AssignProperties_From_TimeWindow populates our TimeWindow from the provided source TimeWindow
func (window *TimeWindow) AssignProperties_From_TimeWindow(source *storage.TimeWindow) error {

	// End
	window.End = genruntime.ClonePointerToString(source.End)

	// Start
	window.Start = genruntime.ClonePointerToString(source.Start)

	// TimeZone
	window.TimeZone = genruntime.ClonePointerToString(source.TimeZone)

	// No error
	return nil
}

// AssignProperties_To_TimeWindow populates the provided destination TimeWindow from our TimeWindow
func (window *TimeWindow) AssignProperties_To_TimeWindow(destination *storage.TimeWindow) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// End
	destination.End = genruntime.ClonePointerToString(window.End)

	// Start
	destination.Start = genruntime.ClonePointerToString(window.Start)

	// TimeZone
	destination.TimeZone = genruntime.ClonePointerToString(window.TimeZone)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_TimeWindow_STATUS populates our TimeWindow from the provided source TimeWindow_STATUS
func (window *TimeWindow) Initialize_From_TimeWindow_STATUS(source *TimeWindow_STATUS) error {

	// End
	window.End = genruntime.ClonePointerToString(source.End)

	// Start
	window.Start = genruntime.ClonePointerToString(source.Start)

	// TimeZone
	window.TimeZone = genruntime.ClonePointerToString(source.TimeZone)

	// No error
	return nil
}

// A specific date-time for the profile.
type TimeWindow_STATUS struct {
	// +kubebuilder:validation:Required
	// End: the end time for the profile in ISO 8601 format.
	End *string `json:"end,omitempty"`

	// +kubebuilder:validation:Required
	// Start: the start time for the profile in ISO 8601 format.
	Start *string `json:"start,omitempty"`

	// TimeZone: the timezone of the start and end times for the profile. Some examples of valid time zones are: Dateline
	// Standard Time, UTC-11, Hawaiian Standard Time, Alaskan Standard Time, Pacific Standard Time (Mexico), Pacific Standard
	// Time, US Mountain Standard Time, Mountain Standard Time (Mexico), Mountain Standard Time, Central America Standard Time,
	// Central Standard Time, Central Standard Time (Mexico), Canada Central Standard Time, SA Pacific Standard Time, Eastern
	// Standard Time, US Eastern Standard Time, Venezuela Standard Time, Paraguay Standard Time, Atlantic Standard Time,
	// Central Brazilian Standard Time, SA Western Standard Time, Pacific SA Standard Time, Newfoundland Standard Time, E.
	// South America Standard Time, Argentina Standard Time, SA Eastern Standard Time, Greenland Standard Time, Montevideo
	// Standard Time, Bahia Standard Time, UTC-02, Mid-Atlantic Standard Time, Azores Standard Time, Cape Verde Standard Time,
	// Morocco Standard Time, UTC, GMT Standard Time, Greenwich Standard Time, W. Europe Standard Time, Central Europe Standard
	// Time, Romance Standard Time, Central European Standard Time, W. Central Africa Standard Time, Namibia Standard Time,
	// Jordan Standard Time, GTB Standard Time, Middle East Standard Time, Egypt Standard Time, Syria Standard Time, E. Europe
	// Standard Time, South Africa Standard Time, FLE Standard Time, Turkey Standard Time, Israel Standard Time, Kaliningrad
	// Standard Time, Libya Standard Time, Arabic Standard Time, Arab Standard Time, Belarus Standard Time, Russian Standard
	// Time, E. Africa Standard Time, Iran Standard Time, Arabian Standard Time, Azerbaijan Standard Time, Russia Time Zone 3,
	// Mauritius Standard Time, Georgian Standard Time, Caucasus Standard Time, Afghanistan Standard Time, West Asia Standard
	// Time, Ekaterinburg Standard Time, Pakistan Standard Time, India Standard Time, Sri Lanka Standard Time, Nepal Standard
	// Time, Central Asia Standard Time, Bangladesh Standard Time, N. Central Asia Standard Time, Myanmar Standard Time, SE
	// Asia Standard Time, North Asia Standard Time, China Standard Time, North Asia East Standard Time, Singapore Standard
	// Time, W. Australia Standard Time, Taipei Standard Time, Ulaanbaatar Standard Time, Tokyo Standard Time, Korea Standard
	// Time, Yakutsk Standard Time, Cen. Australia Standard Time, AUS Central Standard Time, E. Australia Standard Time, AUS
	// Eastern Standard Time, West Pacific Standard Time, Tasmania Standard Time, Magadan Standard Time, Vladivostok Standard
	// Time, Russia Time Zone 10, Central Pacific Standard Time, Russia Time Zone 11, New Zealand Standard Time, UTC+12, Fiji
	// Standard Time, Kamchatka Standard Time, Tonga Standard Time, Samoa Standard Time, Line Islands Standard Time
	TimeZone *string `json:"timeZone,omitempty"`
}

var _ genruntime.FromARMConverter = &TimeWindow_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (window *TimeWindow_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TimeWindow_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (window *TimeWindow_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TimeWindow_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TimeWindow_STATUS, got %T", armInput)
	}

	// Set property "End":
	if typedInput.End != nil {
		end := *typedInput.End
		window.End = &end
	}

	// Set property "Start":
	if typedInput.Start != nil {
		start := *typedInput.Start
		window.Start = &start
	}

	// Set property "TimeZone":
	if typedInput.TimeZone != nil {
		timeZone := *typedInput.TimeZone
		window.TimeZone = &timeZone
	}

	// No error
	return nil
}

// AssignProperties_From_TimeWindow_STATUS populates our TimeWindow_STATUS from the provided source TimeWindow_STATUS
func (window *TimeWindow_STATUS) AssignProperties_From_TimeWindow_STATUS(source *storage.TimeWindow_STATUS) error {

	// End
	window.End = genruntime.ClonePointerToString(source.End)

	// Start
	window.Start = genruntime.ClonePointerToString(source.Start)

	// TimeZone
	window.TimeZone = genruntime.ClonePointerToString(source.TimeZone)

	// No error
	return nil
}

// AssignProperties_To_TimeWindow_STATUS populates the provided destination TimeWindow_STATUS from our TimeWindow_STATUS
func (window *TimeWindow_STATUS) AssignProperties_To_TimeWindow_STATUS(destination *storage.TimeWindow_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// End
	destination.End = genruntime.ClonePointerToString(window.End)

	// Start
	destination.Start = genruntime.ClonePointerToString(window.Start)

	// TimeZone
	destination.TimeZone = genruntime.ClonePointerToString(window.TimeZone)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Webhook notification of an autoscale event.
type WebhookNotification struct {
	// Properties: a property bag of settings. This value can be empty.
	Properties map[string]string `json:"properties,omitempty"`

	// ServiceUri: the service address to receive the notification.
	ServiceUri *string `json:"serviceUri,omitempty"`
}

var _ genruntime.ARMTransformer = &WebhookNotification{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (notification *WebhookNotification) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if notification == nil {
		return nil, nil
	}
	result := &arm.WebhookNotification{}

	// Set property "Properties":
	if notification.Properties != nil {
		result.Properties = make(map[string]string, len(notification.Properties))
		for key, value := range notification.Properties {
			result.Properties[key] = value
		}
	}

	// Set property "ServiceUri":
	if notification.ServiceUri != nil {
		serviceUri := *notification.ServiceUri
		result.ServiceUri = &serviceUri
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (notification *WebhookNotification) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WebhookNotification{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (notification *WebhookNotification) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WebhookNotification)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WebhookNotification, got %T", armInput)
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		notification.Properties = make(map[string]string, len(typedInput.Properties))
		for key, value := range typedInput.Properties {
			notification.Properties[key] = value
		}
	}

	// Set property "ServiceUri":
	if typedInput.ServiceUri != nil {
		serviceUri := *typedInput.ServiceUri
		notification.ServiceUri = &serviceUri
	}

	// No error
	return nil
}

// AssignProperties_From_WebhookNotification populates our WebhookNotification from the provided source WebhookNotification
func (notification *WebhookNotification) AssignProperties_From_WebhookNotification(source *storage.WebhookNotification) error {

	// Properties
	notification.Properties = genruntime.CloneMapOfStringToString(source.Properties)

	// ServiceUri
	notification.ServiceUri = genruntime.ClonePointerToString(source.ServiceUri)

	// No error
	return nil
}

// AssignProperties_To_WebhookNotification populates the provided destination WebhookNotification from our WebhookNotification
func (notification *WebhookNotification) AssignProperties_To_WebhookNotification(destination *storage.WebhookNotification) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Properties
	destination.Properties = genruntime.CloneMapOfStringToString(notification.Properties)

	// ServiceUri
	destination.ServiceUri = genruntime.ClonePointerToString(notification.ServiceUri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_WebhookNotification_STATUS populates our WebhookNotification from the provided source WebhookNotification_STATUS
func (notification *WebhookNotification) Initialize_From_WebhookNotification_STATUS(source *WebhookNotification_STATUS) error {

	// Properties
	notification.Properties = genruntime.CloneMapOfStringToString(source.Properties)

	// ServiceUri
	notification.ServiceUri = genruntime.ClonePointerToString(source.ServiceUri)

	// No error
	return nil
}

// Webhook notification of an autoscale event.
type WebhookNotification_STATUS struct {
	// Properties: a property bag of settings. This value can be empty.
	Properties map[string]string `json:"properties,omitempty"`

	// ServiceUri: the service address to receive the notification.
	ServiceUri *string `json:"serviceUri,omitempty"`
}

var _ genruntime.FromARMConverter = &WebhookNotification_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (notification *WebhookNotification_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WebhookNotification_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (notification *WebhookNotification_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WebhookNotification_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WebhookNotification_STATUS, got %T", armInput)
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		notification.Properties = make(map[string]string, len(typedInput.Properties))
		for key, value := range typedInput.Properties {
			notification.Properties[key] = value
		}
	}

	// Set property "ServiceUri":
	if typedInput.ServiceUri != nil {
		serviceUri := *typedInput.ServiceUri
		notification.ServiceUri = &serviceUri
	}

	// No error
	return nil
}

// AssignProperties_From_WebhookNotification_STATUS populates our WebhookNotification_STATUS from the provided source WebhookNotification_STATUS
func (notification *WebhookNotification_STATUS) AssignProperties_From_WebhookNotification_STATUS(source *storage.WebhookNotification_STATUS) error {

	// Properties
	notification.Properties = genruntime.CloneMapOfStringToString(source.Properties)

	// ServiceUri
	notification.ServiceUri = genruntime.ClonePointerToString(source.ServiceUri)

	// No error
	return nil
}

// AssignProperties_To_WebhookNotification_STATUS populates the provided destination WebhookNotification_STATUS from our WebhookNotification_STATUS
func (notification *WebhookNotification_STATUS) AssignProperties_To_WebhookNotification_STATUS(destination *storage.WebhookNotification_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Properties
	destination.Properties = genruntime.CloneMapOfStringToString(notification.Properties)

	// ServiceUri
	destination.ServiceUri = genruntime.ClonePointerToString(notification.ServiceUri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The trigger that results in a scaling action.
type MetricTrigger struct {
	// Dimensions: List of dimension conditions. For example:
	// [{"DimensionName":"AppName","Operator":"Equals","Values":["App1"]},{"DimensionName":"Deployment","Operator":"Equals","Values":["default"]}].
	Dimensions []ScaleRuleMetricDimension `json:"dimensions,omitempty"`

	// DividePerInstance: a value indicating whether metric should divide per instance.
	DividePerInstance *bool `json:"dividePerInstance,omitempty"`

	// +kubebuilder:validation:Required
	// MetricName: the name of the metric that defines what the rule monitors.
	MetricName *string `json:"metricName,omitempty"`

	// MetricNamespace: the namespace of the metric that defines what the rule monitors.
	MetricNamespace *string `json:"metricNamespace,omitempty"`

	// MetricResourceLocation: the location of the resource the rule monitors.
	MetricResourceLocation *string `json:"metricResourceLocation,omitempty"`

	// +kubebuilder:validation:Required
	// MetricResourceUriReference: the resource identifier of the resource the rule monitors.
	MetricResourceUriReference *genruntime.ResourceReference `armReference:"MetricResourceUri" json:"metricResourceUriReference,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: the operator that is used to compare the metric data and the threshold.
	Operator *MetricTrigger_Operator `json:"operator,omitempty"`

	// +kubebuilder:validation:Required
	// Statistic: the metric statistic type. How the metrics from multiple instances are combined.
	Statistic *MetricTrigger_Statistic `json:"statistic,omitempty"`

	// +kubebuilder:validation:Required
	// Threshold: the threshold of the metric that triggers the scale action.
	Threshold *float64 `json:"threshold,omitempty"`

	// +kubebuilder:validation:Required
	// TimeAggregation: time aggregation type. How the data that is collected should be combined over time. The default value
	// is Average.
	TimeAggregation *MetricTrigger_TimeAggregation `json:"timeAggregation,omitempty"`

	// +kubebuilder:validation:Required
	// TimeGrain: the granularity of metrics the rule monitors. Must be one of the predefined values returned from metric
	// definitions for the metric. Must be between 12 hours and 1 minute.
	TimeGrain *string `json:"timeGrain,omitempty"`

	// +kubebuilder:validation:Required
	// TimeWindow: the range of time in which instance data is collected. This value must be greater than the delay in metric
	// collection, which can vary from resource-to-resource. Must be between 12 hours and 5 minutes.
	TimeWindow *string `json:"timeWindow,omitempty"`
}

var _ genruntime.ARMTransformer = &MetricTrigger{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (trigger *MetricTrigger) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if trigger == nil {
		return nil, nil
	}
	result := &arm.MetricTrigger{}

	// Set property "Dimensions":
	for _, item := range trigger.Dimensions {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Dimensions = append(result.Dimensions, *item_ARM.(*arm.ScaleRuleMetricDimension))
	}

	// Set property "DividePerInstance":
	if trigger.DividePerInstance != nil {
		dividePerInstance := *trigger.DividePerInstance
		result.DividePerInstance = &dividePerInstance
	}

	// Set property "MetricName":
	if trigger.MetricName != nil {
		metricName := *trigger.MetricName
		result.MetricName = &metricName
	}

	// Set property "MetricNamespace":
	if trigger.MetricNamespace != nil {
		metricNamespace := *trigger.MetricNamespace
		result.MetricNamespace = &metricNamespace
	}

	// Set property "MetricResourceLocation":
	if trigger.MetricResourceLocation != nil {
		metricResourceLocation := *trigger.MetricResourceLocation
		result.MetricResourceLocation = &metricResourceLocation
	}

	// Set property "MetricResourceUri":
	if trigger.MetricResourceUriReference != nil {
		metricResourceUriReferenceARMID, err := resolved.ResolvedReferences.Lookup(*trigger.MetricResourceUriReference)
		if err != nil {
			return nil, err
		}
		metricResourceUriReference := metricResourceUriReferenceARMID
		result.MetricResourceUri = &metricResourceUriReference
	}

	// Set property "Operator":
	if trigger.Operator != nil {
		var temp string
		temp = string(*trigger.Operator)
		operator := arm.MetricTrigger_Operator(temp)
		result.Operator = &operator
	}

	// Set property "Statistic":
	if trigger.Statistic != nil {
		var temp string
		temp = string(*trigger.Statistic)
		statistic := arm.MetricTrigger_Statistic(temp)
		result.Statistic = &statistic
	}

	// Set property "Threshold":
	if trigger.Threshold != nil {
		threshold := *trigger.Threshold
		result.Threshold = &threshold
	}

	// Set property "TimeAggregation":
	if trigger.TimeAggregation != nil {
		var temp string
		temp = string(*trigger.TimeAggregation)
		timeAggregation := arm.MetricTrigger_TimeAggregation(temp)
		result.TimeAggregation = &timeAggregation
	}

	// Set property "TimeGrain":
	if trigger.TimeGrain != nil {
		timeGrain := *trigger.TimeGrain
		result.TimeGrain = &timeGrain
	}

	// Set property "TimeWindow":
	if trigger.TimeWindow != nil {
		timeWindow := *trigger.TimeWindow
		result.TimeWindow = &timeWindow
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (trigger *MetricTrigger) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.MetricTrigger{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (trigger *MetricTrigger) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.MetricTrigger)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.MetricTrigger, got %T", armInput)
	}

	// Set property "Dimensions":
	for _, item := range typedInput.Dimensions {
		var item1 ScaleRuleMetricDimension
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		trigger.Dimensions = append(trigger.Dimensions, item1)
	}

	// Set property "DividePerInstance":
	if typedInput.DividePerInstance != nil {
		dividePerInstance := *typedInput.DividePerInstance
		trigger.DividePerInstance = &dividePerInstance
	}

	// Set property "MetricName":
	if typedInput.MetricName != nil {
		metricName := *typedInput.MetricName
		trigger.MetricName = &metricName
	}

	// Set property "MetricNamespace":
	if typedInput.MetricNamespace != nil {
		metricNamespace := *typedInput.MetricNamespace
		trigger.MetricNamespace = &metricNamespace
	}

	// Set property "MetricResourceLocation":
	if typedInput.MetricResourceLocation != nil {
		metricResourceLocation := *typedInput.MetricResourceLocation
		trigger.MetricResourceLocation = &metricResourceLocation
	}

	// no assignment for property "MetricResourceUriReference"

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := MetricTrigger_Operator(temp)
		trigger.Operator = &operator
	}

	// Set property "Statistic":
	if typedInput.Statistic != nil {
		var temp string
		temp = string(*typedInput.Statistic)
		statistic := MetricTrigger_Statistic(temp)
		trigger.Statistic = &statistic
	}

	// Set property "Threshold":
	if typedInput.Threshold != nil {
		threshold := *typedInput.Threshold
		trigger.Threshold = &threshold
	}

	// Set property "TimeAggregation":
	if typedInput.TimeAggregation != nil {
		var temp string
		temp = string(*typedInput.TimeAggregation)
		timeAggregation := MetricTrigger_TimeAggregation(temp)
		trigger.TimeAggregation = &timeAggregation
	}

	// Set property "TimeGrain":
	if typedInput.TimeGrain != nil {
		timeGrain := *typedInput.TimeGrain
		trigger.TimeGrain = &timeGrain
	}

	// Set property "TimeWindow":
	if typedInput.TimeWindow != nil {
		timeWindow := *typedInput.TimeWindow
		trigger.TimeWindow = &timeWindow
	}

	// No error
	return nil
}

// AssignProperties_From_MetricTrigger populates our MetricTrigger from the provided source MetricTrigger
func (trigger *MetricTrigger) AssignProperties_From_MetricTrigger(source *storage.MetricTrigger) error {

	// Dimensions
	if source.Dimensions != nil {
		dimensionList := make([]ScaleRuleMetricDimension, len(source.Dimensions))
		for dimensionIndex, dimensionItem := range source.Dimensions {
			// Shadow the loop variable to avoid aliasing
			dimensionItem := dimensionItem
			var dimension ScaleRuleMetricDimension
			err := dimension.AssignProperties_From_ScaleRuleMetricDimension(&dimensionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ScaleRuleMetricDimension() to populate field Dimensions")
			}
			dimensionList[dimensionIndex] = dimension
		}
		trigger.Dimensions = dimensionList
	} else {
		trigger.Dimensions = nil
	}

	// DividePerInstance
	if source.DividePerInstance != nil {
		dividePerInstance := *source.DividePerInstance
		trigger.DividePerInstance = &dividePerInstance
	} else {
		trigger.DividePerInstance = nil
	}

	// MetricName
	trigger.MetricName = genruntime.ClonePointerToString(source.MetricName)

	// MetricNamespace
	trigger.MetricNamespace = genruntime.ClonePointerToString(source.MetricNamespace)

	// MetricResourceLocation
	trigger.MetricResourceLocation = genruntime.ClonePointerToString(source.MetricResourceLocation)

	// MetricResourceUriReference
	if source.MetricResourceUriReference != nil {
		metricResourceUriReference := source.MetricResourceUriReference.Copy()
		trigger.MetricResourceUriReference = &metricResourceUriReference
	} else {
		trigger.MetricResourceUriReference = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, metricTrigger_Operator_Values)
		trigger.Operator = &operatorTemp
	} else {
		trigger.Operator = nil
	}

	// Statistic
	if source.Statistic != nil {
		statistic := *source.Statistic
		statisticTemp := genruntime.ToEnum(statistic, metricTrigger_Statistic_Values)
		trigger.Statistic = &statisticTemp
	} else {
		trigger.Statistic = nil
	}

	// Threshold
	if source.Threshold != nil {
		threshold := *source.Threshold
		trigger.Threshold = &threshold
	} else {
		trigger.Threshold = nil
	}

	// TimeAggregation
	if source.TimeAggregation != nil {
		timeAggregation := *source.TimeAggregation
		timeAggregationTemp := genruntime.ToEnum(timeAggregation, metricTrigger_TimeAggregation_Values)
		trigger.TimeAggregation = &timeAggregationTemp
	} else {
		trigger.TimeAggregation = nil
	}

	// TimeGrain
	trigger.TimeGrain = genruntime.ClonePointerToString(source.TimeGrain)

	// TimeWindow
	trigger.TimeWindow = genruntime.ClonePointerToString(source.TimeWindow)

	// No error
	return nil
}

// AssignProperties_To_MetricTrigger populates the provided destination MetricTrigger from our MetricTrigger
func (trigger *MetricTrigger) AssignProperties_To_MetricTrigger(destination *storage.MetricTrigger) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Dimensions
	if trigger.Dimensions != nil {
		dimensionList := make([]storage.ScaleRuleMetricDimension, len(trigger.Dimensions))
		for dimensionIndex, dimensionItem := range trigger.Dimensions {
			// Shadow the loop variable to avoid aliasing
			dimensionItem := dimensionItem
			var dimension storage.ScaleRuleMetricDimension
			err := dimensionItem.AssignProperties_To_ScaleRuleMetricDimension(&dimension)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ScaleRuleMetricDimension() to populate field Dimensions")
			}
			dimensionList[dimensionIndex] = dimension
		}
		destination.Dimensions = dimensionList
	} else {
		destination.Dimensions = nil
	}

	// DividePerInstance
	if trigger.DividePerInstance != nil {
		dividePerInstance := *trigger.DividePerInstance
		destination.DividePerInstance = &dividePerInstance
	} else {
		destination.DividePerInstance = nil
	}

	// MetricName
	destination.MetricName = genruntime.ClonePointerToString(trigger.MetricName)

	// MetricNamespace
	destination.MetricNamespace = genruntime.ClonePointerToString(trigger.MetricNamespace)

	// MetricResourceLocation
	destination.MetricResourceLocation = genruntime.ClonePointerToString(trigger.MetricResourceLocation)

	// MetricResourceUriReference
	if trigger.MetricResourceUriReference != nil {
		metricResourceUriReference := trigger.MetricResourceUriReference.Copy()
		destination.MetricResourceUriReference = &metricResourceUriReference
	} else {
		destination.MetricResourceUriReference = nil
	}

	// Operator
	if trigger.Operator != nil {
		operator := string(*trigger.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Statistic
	if trigger.Statistic != nil {
		statistic := string(*trigger.Statistic)
		destination.Statistic = &statistic
	} else {
		destination.Statistic = nil
	}

	// Threshold
	if trigger.Threshold != nil {
		threshold := *trigger.Threshold
		destination.Threshold = &threshold
	} else {
		destination.Threshold = nil
	}

	// TimeAggregation
	if trigger.TimeAggregation != nil {
		timeAggregation := string(*trigger.TimeAggregation)
		destination.TimeAggregation = &timeAggregation
	} else {
		destination.TimeAggregation = nil
	}

	// TimeGrain
	destination.TimeGrain = genruntime.ClonePointerToString(trigger.TimeGrain)

	// TimeWindow
	destination.TimeWindow = genruntime.ClonePointerToString(trigger.TimeWindow)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_MetricTrigger_STATUS populates our MetricTrigger from the provided source MetricTrigger_STATUS
func (trigger *MetricTrigger) Initialize_From_MetricTrigger_STATUS(source *MetricTrigger_STATUS) error {

	// Dimensions
	if source.Dimensions != nil {
		dimensionList := make([]ScaleRuleMetricDimension, len(source.Dimensions))
		for dimensionIndex, dimensionItem := range source.Dimensions {
			// Shadow the loop variable to avoid aliasing
			dimensionItem := dimensionItem
			var dimension ScaleRuleMetricDimension
			err := dimension.Initialize_From_ScaleRuleMetricDimension_STATUS(&dimensionItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ScaleRuleMetricDimension_STATUS() to populate field Dimensions")
			}
			dimensionList[dimensionIndex] = dimension
		}
		trigger.Dimensions = dimensionList
	} else {
		trigger.Dimensions = nil
	}

	// DividePerInstance
	if source.DividePerInstance != nil {
		dividePerInstance := *source.DividePerInstance
		trigger.DividePerInstance = &dividePerInstance
	} else {
		trigger.DividePerInstance = nil
	}

	// MetricName
	trigger.MetricName = genruntime.ClonePointerToString(source.MetricName)

	// MetricNamespace
	trigger.MetricNamespace = genruntime.ClonePointerToString(source.MetricNamespace)

	// MetricResourceLocation
	trigger.MetricResourceLocation = genruntime.ClonePointerToString(source.MetricResourceLocation)

	// Operator
	if source.Operator != nil {
		operator := genruntime.ToEnum(string(*source.Operator), metricTrigger_Operator_Values)
		trigger.Operator = &operator
	} else {
		trigger.Operator = nil
	}

	// Statistic
	if source.Statistic != nil {
		statistic := genruntime.ToEnum(string(*source.Statistic), metricTrigger_Statistic_Values)
		trigger.Statistic = &statistic
	} else {
		trigger.Statistic = nil
	}

	// Threshold
	if source.Threshold != nil {
		threshold := *source.Threshold
		trigger.Threshold = &threshold
	} else {
		trigger.Threshold = nil
	}

	// TimeAggregation
	if source.TimeAggregation != nil {
		timeAggregation := genruntime.ToEnum(string(*source.TimeAggregation), metricTrigger_TimeAggregation_Values)
		trigger.TimeAggregation = &timeAggregation
	} else {
		trigger.TimeAggregation = nil
	}

	// TimeGrain
	trigger.TimeGrain = genruntime.ClonePointerToString(source.TimeGrain)

	// TimeWindow
	trigger.TimeWindow = genruntime.ClonePointerToString(source.TimeWindow)

	// No error
	return nil
}

// The trigger that results in a scaling action.
type MetricTrigger_STATUS struct {
	// Dimensions: List of dimension conditions. For example:
	// [{"DimensionName":"AppName","Operator":"Equals","Values":["App1"]},{"DimensionName":"Deployment","Operator":"Equals","Values":["default"]}].
	Dimensions []ScaleRuleMetricDimension_STATUS `json:"dimensions,omitempty"`

	// DividePerInstance: a value indicating whether metric should divide per instance.
	DividePerInstance *bool `json:"dividePerInstance,omitempty"`

	// +kubebuilder:validation:Required
	// MetricName: the name of the metric that defines what the rule monitors.
	MetricName *string `json:"metricName,omitempty"`

	// MetricNamespace: the namespace of the metric that defines what the rule monitors.
	MetricNamespace *string `json:"metricNamespace,omitempty"`

	// MetricResourceLocation: the location of the resource the rule monitors.
	MetricResourceLocation *string `json:"metricResourceLocation,omitempty"`

	// +kubebuilder:validation:Required
	// MetricResourceUri: the resource identifier of the resource the rule monitors.
	MetricResourceUri *string `json:"metricResourceUri,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: the operator that is used to compare the metric data and the threshold.
	Operator *MetricTrigger_Operator_STATUS `json:"operator,omitempty"`

	// +kubebuilder:validation:Required
	// Statistic: the metric statistic type. How the metrics from multiple instances are combined.
	Statistic *MetricTrigger_Statistic_STATUS `json:"statistic,omitempty"`

	// +kubebuilder:validation:Required
	// Threshold: the threshold of the metric that triggers the scale action.
	Threshold *float64 `json:"threshold,omitempty"`

	// +kubebuilder:validation:Required
	// TimeAggregation: time aggregation type. How the data that is collected should be combined over time. The default value
	// is Average.
	TimeAggregation *MetricTrigger_TimeAggregation_STATUS `json:"timeAggregation,omitempty"`

	// +kubebuilder:validation:Required
	// TimeGrain: the granularity of metrics the rule monitors. Must be one of the predefined values returned from metric
	// definitions for the metric. Must be between 12 hours and 1 minute.
	TimeGrain *string `json:"timeGrain,omitempty"`

	// +kubebuilder:validation:Required
	// TimeWindow: the range of time in which instance data is collected. This value must be greater than the delay in metric
	// collection, which can vary from resource-to-resource. Must be between 12 hours and 5 minutes.
	TimeWindow *string `json:"timeWindow,omitempty"`
}

var _ genruntime.FromARMConverter = &MetricTrigger_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (trigger *MetricTrigger_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.MetricTrigger_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (trigger *MetricTrigger_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.MetricTrigger_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.MetricTrigger_STATUS, got %T", armInput)
	}

	// Set property "Dimensions":
	for _, item := range typedInput.Dimensions {
		var item1 ScaleRuleMetricDimension_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		trigger.Dimensions = append(trigger.Dimensions, item1)
	}

	// Set property "DividePerInstance":
	if typedInput.DividePerInstance != nil {
		dividePerInstance := *typedInput.DividePerInstance
		trigger.DividePerInstance = &dividePerInstance
	}

	// Set property "MetricName":
	if typedInput.MetricName != nil {
		metricName := *typedInput.MetricName
		trigger.MetricName = &metricName
	}

	// Set property "MetricNamespace":
	if typedInput.MetricNamespace != nil {
		metricNamespace := *typedInput.MetricNamespace
		trigger.MetricNamespace = &metricNamespace
	}

	// Set property "MetricResourceLocation":
	if typedInput.MetricResourceLocation != nil {
		metricResourceLocation := *typedInput.MetricResourceLocation
		trigger.MetricResourceLocation = &metricResourceLocation
	}

	// Set property "MetricResourceUri":
	if typedInput.MetricResourceUri != nil {
		metricResourceUri := *typedInput.MetricResourceUri
		trigger.MetricResourceUri = &metricResourceUri
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := MetricTrigger_Operator_STATUS(temp)
		trigger.Operator = &operator
	}

	// Set property "Statistic":
	if typedInput.Statistic != nil {
		var temp string
		temp = string(*typedInput.Statistic)
		statistic := MetricTrigger_Statistic_STATUS(temp)
		trigger.Statistic = &statistic
	}

	// Set property "Threshold":
	if typedInput.Threshold != nil {
		threshold := *typedInput.Threshold
		trigger.Threshold = &threshold
	}

	// Set property "TimeAggregation":
	if typedInput.TimeAggregation != nil {
		var temp string
		temp = string(*typedInput.TimeAggregation)
		timeAggregation := MetricTrigger_TimeAggregation_STATUS(temp)
		trigger.TimeAggregation = &timeAggregation
	}

	// Set property "TimeGrain":
	if typedInput.TimeGrain != nil {
		timeGrain := *typedInput.TimeGrain
		trigger.TimeGrain = &timeGrain
	}

	// Set property "TimeWindow":
	if typedInput.TimeWindow != nil {
		timeWindow := *typedInput.TimeWindow
		trigger.TimeWindow = &timeWindow
	}

	// No error
	return nil
}

// AssignProperties_From_MetricTrigger_STATUS populates our MetricTrigger_STATUS from the provided source MetricTrigger_STATUS
func (trigger *MetricTrigger_STATUS) AssignProperties_From_MetricTrigger_STATUS(source *storage.MetricTrigger_STATUS) error {

	// Dimensions
	if source.Dimensions != nil {
		dimensionList := make([]ScaleRuleMetricDimension_STATUS, len(source.Dimensions))
		for dimensionIndex, dimensionItem := range source.Dimensions {
			// Shadow the loop variable to avoid aliasing
			dimensionItem := dimensionItem
			var dimension ScaleRuleMetricDimension_STATUS
			err := dimension.AssignProperties_From_ScaleRuleMetricDimension_STATUS(&dimensionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ScaleRuleMetricDimension_STATUS() to populate field Dimensions")
			}
			dimensionList[dimensionIndex] = dimension
		}
		trigger.Dimensions = dimensionList
	} else {
		trigger.Dimensions = nil
	}

	// DividePerInstance
	if source.DividePerInstance != nil {
		dividePerInstance := *source.DividePerInstance
		trigger.DividePerInstance = &dividePerInstance
	} else {
		trigger.DividePerInstance = nil
	}

	// MetricName
	trigger.MetricName = genruntime.ClonePointerToString(source.MetricName)

	// MetricNamespace
	trigger.MetricNamespace = genruntime.ClonePointerToString(source.MetricNamespace)

	// MetricResourceLocation
	trigger.MetricResourceLocation = genruntime.ClonePointerToString(source.MetricResourceLocation)

	// MetricResourceUri
	trigger.MetricResourceUri = genruntime.ClonePointerToString(source.MetricResourceUri)

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, metricTrigger_Operator_STATUS_Values)
		trigger.Operator = &operatorTemp
	} else {
		trigger.Operator = nil
	}

	// Statistic
	if source.Statistic != nil {
		statistic := *source.Statistic
		statisticTemp := genruntime.ToEnum(statistic, metricTrigger_Statistic_STATUS_Values)
		trigger.Statistic = &statisticTemp
	} else {
		trigger.Statistic = nil
	}

	// Threshold
	if source.Threshold != nil {
		threshold := *source.Threshold
		trigger.Threshold = &threshold
	} else {
		trigger.Threshold = nil
	}

	// TimeAggregation
	if source.TimeAggregation != nil {
		timeAggregation := *source.TimeAggregation
		timeAggregationTemp := genruntime.ToEnum(timeAggregation, metricTrigger_TimeAggregation_STATUS_Values)
		trigger.TimeAggregation = &timeAggregationTemp
	} else {
		trigger.TimeAggregation = nil
	}

	// TimeGrain
	trigger.TimeGrain = genruntime.ClonePointerToString(source.TimeGrain)

	// TimeWindow
	trigger.TimeWindow = genruntime.ClonePointerToString(source.TimeWindow)

	// No error
	return nil
}

// AssignProperties_To_MetricTrigger_STATUS populates the provided destination MetricTrigger_STATUS from our MetricTrigger_STATUS
func (trigger *MetricTrigger_STATUS) AssignProperties_To_MetricTrigger_STATUS(destination *storage.MetricTrigger_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Dimensions
	if trigger.Dimensions != nil {
		dimensionList := make([]storage.ScaleRuleMetricDimension_STATUS, len(trigger.Dimensions))
		for dimensionIndex, dimensionItem := range trigger.Dimensions {
			// Shadow the loop variable to avoid aliasing
			dimensionItem := dimensionItem
			var dimension storage.ScaleRuleMetricDimension_STATUS
			err := dimensionItem.AssignProperties_To_ScaleRuleMetricDimension_STATUS(&dimension)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ScaleRuleMetricDimension_STATUS() to populate field Dimensions")
			}
			dimensionList[dimensionIndex] = dimension
		}
		destination.Dimensions = dimensionList
	} else {
		destination.Dimensions = nil
	}

	// DividePerInstance
	if trigger.DividePerInstance != nil {
		dividePerInstance := *trigger.DividePerInstance
		destination.DividePerInstance = &dividePerInstance
	} else {
		destination.DividePerInstance = nil
	}

	// MetricName
	destination.MetricName = genruntime.ClonePointerToString(trigger.MetricName)

	// MetricNamespace
	destination.MetricNamespace = genruntime.ClonePointerToString(trigger.MetricNamespace)

	// MetricResourceLocation
	destination.MetricResourceLocation = genruntime.ClonePointerToString(trigger.MetricResourceLocation)

	// MetricResourceUri
	destination.MetricResourceUri = genruntime.ClonePointerToString(trigger.MetricResourceUri)

	// Operator
	if trigger.Operator != nil {
		operator := string(*trigger.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Statistic
	if trigger.Statistic != nil {
		statistic := string(*trigger.Statistic)
		destination.Statistic = &statistic
	} else {
		destination.Statistic = nil
	}

	// Threshold
	if trigger.Threshold != nil {
		threshold := *trigger.Threshold
		destination.Threshold = &threshold
	} else {
		destination.Threshold = nil
	}

	// TimeAggregation
	if trigger.TimeAggregation != nil {
		timeAggregation := string(*trigger.TimeAggregation)
		destination.TimeAggregation = &timeAggregation
	} else {
		destination.TimeAggregation = nil
	}

	// TimeGrain
	destination.TimeGrain = genruntime.ClonePointerToString(trigger.TimeGrain)

	// TimeWindow
	destination.TimeWindow = genruntime.ClonePointerToString(trigger.TimeWindow)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Day","Hour","Minute","Month","None","Second","Week","Year"}
type Recurrence_Frequency string

const (
	Recurrence_Frequency_Day    = Recurrence_Frequency("Day")
	Recurrence_Frequency_Hour   = Recurrence_Frequency("Hour")
	Recurrence_Frequency_Minute = Recurrence_Frequency("Minute")
	Recurrence_Frequency_Month  = Recurrence_Frequency("Month")
	Recurrence_Frequency_None   = Recurrence_Frequency("None")
	Recurrence_Frequency_Second = Recurrence_Frequency("Second")
	Recurrence_Frequency_Week   = Recurrence_Frequency("Week")
	Recurrence_Frequency_Year   = Recurrence_Frequency("Year")
)

// Mapping from string to Recurrence_Frequency
var recurrence_Frequency_Values = map[string]Recurrence_Frequency{
	"day":    Recurrence_Frequency_Day,
	"hour":   Recurrence_Frequency_Hour,
	"minute": Recurrence_Frequency_Minute,
	"month":  Recurrence_Frequency_Month,
	"none":   Recurrence_Frequency_None,
	"second": Recurrence_Frequency_Second,
	"week":   Recurrence_Frequency_Week,
	"year":   Recurrence_Frequency_Year,
}

// +kubebuilder:validation:Enum={"Day","Hour","Minute","Month","None","Second","Week","Year"}
type Recurrence_Frequency_STATUS string

const (
	Recurrence_Frequency_STATUS_Day    = Recurrence_Frequency_STATUS("Day")
	Recurrence_Frequency_STATUS_Hour   = Recurrence_Frequency_STATUS("Hour")
	Recurrence_Frequency_STATUS_Minute = Recurrence_Frequency_STATUS("Minute")
	Recurrence_Frequency_STATUS_Month  = Recurrence_Frequency_STATUS("Month")
	Recurrence_Frequency_STATUS_None   = Recurrence_Frequency_STATUS("None")
	Recurrence_Frequency_STATUS_Second = Recurrence_Frequency_STATUS("Second")
	Recurrence_Frequency_STATUS_Week   = Recurrence_Frequency_STATUS("Week")
	Recurrence_Frequency_STATUS_Year   = Recurrence_Frequency_STATUS("Year")
)

// Mapping from string to Recurrence_Frequency_STATUS
var recurrence_Frequency_STATUS_Values = map[string]Recurrence_Frequency_STATUS{
	"day":    Recurrence_Frequency_STATUS_Day,
	"hour":   Recurrence_Frequency_STATUS_Hour,
	"minute": Recurrence_Frequency_STATUS_Minute,
	"month":  Recurrence_Frequency_STATUS_Month,
	"none":   Recurrence_Frequency_STATUS_None,
	"second": Recurrence_Frequency_STATUS_Second,
	"week":   Recurrence_Frequency_STATUS_Week,
	"year":   Recurrence_Frequency_STATUS_Year,
}

// The scheduling constraints for when the profile begins.
type RecurrentSchedule struct {
	// +kubebuilder:validation:Required
	// Days: the collection of days that the profile takes effect on. Possible values are Sunday through Saturday.
	Days []string `json:"days,omitempty"`

	// +kubebuilder:validation:Required
	// Hours: A collection of hours that the profile takes effect on. Values supported are 0 to 23 on the 24-hour clock (AM/PM
	// times are not supported).
	Hours []int `json:"hours,omitempty"`

	// +kubebuilder:validation:Required
	// Minutes: A collection of minutes at which the profile takes effect at.
	Minutes []int `json:"minutes,omitempty"`

	// +kubebuilder:validation:Required
	// TimeZone: the timezone for the hours of the profile. Some examples of valid time zones are: Dateline Standard Time,
	// UTC-11, Hawaiian Standard Time, Alaskan Standard Time, Pacific Standard Time (Mexico), Pacific Standard Time, US
	// Mountain Standard Time, Mountain Standard Time (Mexico), Mountain Standard Time, Central America Standard Time, Central
	// Standard Time, Central Standard Time (Mexico), Canada Central Standard Time, SA Pacific Standard Time, Eastern Standard
	// Time, US Eastern Standard Time, Venezuela Standard Time, Paraguay Standard Time, Atlantic Standard Time, Central
	// Brazilian Standard Time, SA Western Standard Time, Pacific SA Standard Time, Newfoundland Standard Time, E. South
	// America Standard Time, Argentina Standard Time, SA Eastern Standard Time, Greenland Standard Time, Montevideo Standard
	// Time, Bahia Standard Time, UTC-02, Mid-Atlantic Standard Time, Azores Standard Time, Cape Verde Standard Time, Morocco
	// Standard Time, UTC, GMT Standard Time, Greenwich Standard Time, W. Europe Standard Time, Central Europe Standard Time,
	// Romance Standard Time, Central European Standard Time, W. Central Africa Standard Time, Namibia Standard Time, Jordan
	// Standard Time, GTB Standard Time, Middle East Standard Time, Egypt Standard Time, Syria Standard Time, E. Europe
	// Standard Time, South Africa Standard Time, FLE Standard Time, Turkey Standard Time, Israel Standard Time, Kaliningrad
	// Standard Time, Libya Standard Time, Arabic Standard Time, Arab Standard Time, Belarus Standard Time, Russian Standard
	// Time, E. Africa Standard Time, Iran Standard Time, Arabian Standard Time, Azerbaijan Standard Time, Russia Time Zone 3,
	// Mauritius Standard Time, Georgian Standard Time, Caucasus Standard Time, Afghanistan Standard Time, West Asia Standard
	// Time, Ekaterinburg Standard Time, Pakistan Standard Time, India Standard Time, Sri Lanka Standard Time, Nepal Standard
	// Time, Central Asia Standard Time, Bangladesh Standard Time, N. Central Asia Standard Time, Myanmar Standard Time, SE
	// Asia Standard Time, North Asia Standard Time, China Standard Time, North Asia East Standard Time, Singapore Standard
	// Time, W. Australia Standard Time, Taipei Standard Time, Ulaanbaatar Standard Time, Tokyo Standard Time, Korea Standard
	// Time, Yakutsk Standard Time, Cen. Australia Standard Time, AUS Central Standard Time, E. Australia Standard Time, AUS
	// Eastern Standard Time, West Pacific Standard Time, Tasmania Standard Time, Magadan Standard Time, Vladivostok Standard
	// Time, Russia Time Zone 10, Central Pacific Standard Time, Russia Time Zone 11, New Zealand Standard Time, UTC+12, Fiji
	// Standard Time, Kamchatka Standard Time, Tonga Standard Time, Samoa Standard Time, Line Islands Standard Time
	TimeZone *string `json:"timeZone,omitempty"`
}

var _ genruntime.ARMTransformer = &RecurrentSchedule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (schedule *RecurrentSchedule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if schedule == nil {
		return nil, nil
	}
	result := &arm.RecurrentSchedule{}

	// Set property "Days":
	for _, item := range schedule.Days {
		result.Days = append(result.Days, item)
	}

	// Set property "Hours":
	for _, item := range schedule.Hours {
		result.Hours = append(result.Hours, item)
	}

	// Set property "Minutes":
	for _, item := range schedule.Minutes {
		result.Minutes = append(result.Minutes, item)
	}

	// Set property "TimeZone":
	if schedule.TimeZone != nil {
		timeZone := *schedule.TimeZone
		result.TimeZone = &timeZone
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (schedule *RecurrentSchedule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RecurrentSchedule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (schedule *RecurrentSchedule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RecurrentSchedule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RecurrentSchedule, got %T", armInput)
	}

	// Set property "Days":
	for _, item := range typedInput.Days {
		schedule.Days = append(schedule.Days, item)
	}

	// Set property "Hours":
	for _, item := range typedInput.Hours {
		schedule.Hours = append(schedule.Hours, item)
	}

	// Set property "Minutes":
	for _, item := range typedInput.Minutes {
		schedule.Minutes = append(schedule.Minutes, item)
	}

	// Set property "TimeZone":
	if typedInput.TimeZone != nil {
		timeZone := *typedInput.TimeZone
		schedule.TimeZone = &timeZone
	}

	// No error
	return nil
}

// AssignProperties_From_RecurrentSchedule populates our RecurrentSchedule from the provided source RecurrentSchedule
func (schedule *RecurrentSchedule) AssignProperties_From_RecurrentSchedule(source *storage.RecurrentSchedule) error {

	// Days
	schedule.Days = genruntime.CloneSliceOfString(source.Days)

	// Hours
	if source.Hours != nil {
		hourList := make([]int, len(source.Hours))
		for hourIndex, hourItem := range source.Hours {
			// Shadow the loop variable to avoid aliasing
			hourItem := hourItem
			hourList[hourIndex] = hourItem
		}
		schedule.Hours = hourList
	} else {
		schedule.Hours = nil
	}

	// Minutes
	if source.Minutes != nil {
		minuteList := make([]int, len(source.Minutes))
		for minuteIndex, minuteItem := range source.Minutes {
			// Shadow the loop variable to avoid aliasing
			minuteItem := minuteItem
			minuteList[minuteIndex] = minuteItem
		}
		schedule.Minutes = minuteList
	} else {
		schedule.Minutes = nil
	}

	// TimeZone
	schedule.TimeZone = genruntime.ClonePointerToString(source.TimeZone)

	// No error
	return nil
}

// AssignProperties_To_RecurrentSchedule populates the provided destination RecurrentSchedule from our RecurrentSchedule
func (schedule *RecurrentSchedule) AssignProperties_To_RecurrentSchedule(destination *storage.RecurrentSchedule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Days
	destination.Days = genruntime.CloneSliceOfString(schedule.Days)

	// Hours
	if schedule.Hours != nil {
		hourList := make([]int, len(schedule.Hours))
		for hourIndex, hourItem := range schedule.Hours {
			// Shadow the loop variable to avoid aliasing
			hourItem := hourItem
			hourList[hourIndex] = hourItem
		}
		destination.Hours = hourList
	} else {
		destination.Hours = nil
	}

	// Minutes
	if schedule.Minutes != nil {
		minuteList := make([]int, len(schedule.Minutes))
		for minuteIndex, minuteItem := range schedule.Minutes {
			// Shadow the loop variable to avoid aliasing
			minuteItem := minuteItem
			minuteList[minuteIndex] = minuteItem
		}
		destination.Minutes = minuteList
	} else {
		destination.Minutes = nil
	}

	// TimeZone
	destination.TimeZone = genruntime.ClonePointerToString(schedule.TimeZone)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RecurrentSchedule_STATUS populates our RecurrentSchedule from the provided source RecurrentSchedule_STATUS
func (schedule *RecurrentSchedule) Initialize_From_RecurrentSchedule_STATUS(source *RecurrentSchedule_STATUS) error {

	// Days
	schedule.Days = genruntime.CloneSliceOfString(source.Days)

	// Hours
	if source.Hours != nil {
		hourList := make([]int, len(source.Hours))
		for hourIndex, hourItem := range source.Hours {
			// Shadow the loop variable to avoid aliasing
			hourItem := hourItem
			hourList[hourIndex] = hourItem
		}
		schedule.Hours = hourList
	} else {
		schedule.Hours = nil
	}

	// Minutes
	if source.Minutes != nil {
		minuteList := make([]int, len(source.Minutes))
		for minuteIndex, minuteItem := range source.Minutes {
			// Shadow the loop variable to avoid aliasing
			minuteItem := minuteItem
			minuteList[minuteIndex] = minuteItem
		}
		schedule.Minutes = minuteList
	} else {
		schedule.Minutes = nil
	}

	// TimeZone
	schedule.TimeZone = genruntime.ClonePointerToString(source.TimeZone)

	// No error
	return nil
}

// The scheduling constraints for when the profile begins.
type RecurrentSchedule_STATUS struct {
	// +kubebuilder:validation:Required
	// Days: the collection of days that the profile takes effect on. Possible values are Sunday through Saturday.
	Days []string `json:"days,omitempty"`

	// +kubebuilder:validation:Required
	// Hours: A collection of hours that the profile takes effect on. Values supported are 0 to 23 on the 24-hour clock (AM/PM
	// times are not supported).
	Hours []int `json:"hours,omitempty"`

	// +kubebuilder:validation:Required
	// Minutes: A collection of minutes at which the profile takes effect at.
	Minutes []int `json:"minutes,omitempty"`

	// +kubebuilder:validation:Required
	// TimeZone: the timezone for the hours of the profile. Some examples of valid time zones are: Dateline Standard Time,
	// UTC-11, Hawaiian Standard Time, Alaskan Standard Time, Pacific Standard Time (Mexico), Pacific Standard Time, US
	// Mountain Standard Time, Mountain Standard Time (Mexico), Mountain Standard Time, Central America Standard Time, Central
	// Standard Time, Central Standard Time (Mexico), Canada Central Standard Time, SA Pacific Standard Time, Eastern Standard
	// Time, US Eastern Standard Time, Venezuela Standard Time, Paraguay Standard Time, Atlantic Standard Time, Central
	// Brazilian Standard Time, SA Western Standard Time, Pacific SA Standard Time, Newfoundland Standard Time, E. South
	// America Standard Time, Argentina Standard Time, SA Eastern Standard Time, Greenland Standard Time, Montevideo Standard
	// Time, Bahia Standard Time, UTC-02, Mid-Atlantic Standard Time, Azores Standard Time, Cape Verde Standard Time, Morocco
	// Standard Time, UTC, GMT Standard Time, Greenwich Standard Time, W. Europe Standard Time, Central Europe Standard Time,
	// Romance Standard Time, Central European Standard Time, W. Central Africa Standard Time, Namibia Standard Time, Jordan
	// Standard Time, GTB Standard Time, Middle East Standard Time, Egypt Standard Time, Syria Standard Time, E. Europe
	// Standard Time, South Africa Standard Time, FLE Standard Time, Turkey Standard Time, Israel Standard Time, Kaliningrad
	// Standard Time, Libya Standard Time, Arabic Standard Time, Arab Standard Time, Belarus Standard Time, Russian Standard
	// Time, E. Africa Standard Time, Iran Standard Time, Arabian Standard Time, Azerbaijan Standard Time, Russia Time Zone 3,
	// Mauritius Standard Time, Georgian Standard Time, Caucasus Standard Time, Afghanistan Standard Time, West Asia Standard
	// Time, Ekaterinburg Standard Time, Pakistan Standard Time, India Standard Time, Sri Lanka Standard Time, Nepal Standard
	// Time, Central Asia Standard Time, Bangladesh Standard Time, N. Central Asia Standard Time, Myanmar Standard Time, SE
	// Asia Standard Time, North Asia Standard Time, China Standard Time, North Asia East Standard Time, Singapore Standard
	// Time, W. Australia Standard Time, Taipei Standard Time, Ulaanbaatar Standard Time, Tokyo Standard Time, Korea Standard
	// Time, Yakutsk Standard Time, Cen. Australia Standard Time, AUS Central Standard Time, E. Australia Standard Time, AUS
	// Eastern Standard Time, West Pacific Standard Time, Tasmania Standard Time, Magadan Standard Time, Vladivostok Standard
	// Time, Russia Time Zone 10, Central Pacific Standard Time, Russia Time Zone 11, New Zealand Standard Time, UTC+12, Fiji
	// Standard Time, Kamchatka Standard Time, Tonga Standard Time, Samoa Standard Time, Line Islands Standard Time
	TimeZone *string `json:"timeZone,omitempty"`
}

var _ genruntime.FromARMConverter = &RecurrentSchedule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (schedule *RecurrentSchedule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RecurrentSchedule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (schedule *RecurrentSchedule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RecurrentSchedule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RecurrentSchedule_STATUS, got %T", armInput)
	}

	// Set property "Days":
	for _, item := range typedInput.Days {
		schedule.Days = append(schedule.Days, item)
	}

	// Set property "Hours":
	for _, item := range typedInput.Hours {
		schedule.Hours = append(schedule.Hours, item)
	}

	// Set property "Minutes":
	for _, item := range typedInput.Minutes {
		schedule.Minutes = append(schedule.Minutes, item)
	}

	// Set property "TimeZone":
	if typedInput.TimeZone != nil {
		timeZone := *typedInput.TimeZone
		schedule.TimeZone = &timeZone
	}

	// No error
	return nil
}

// AssignProperties_From_RecurrentSchedule_STATUS populates our RecurrentSchedule_STATUS from the provided source RecurrentSchedule_STATUS
func (schedule *RecurrentSchedule_STATUS) AssignProperties_From_RecurrentSchedule_STATUS(source *storage.RecurrentSchedule_STATUS) error {

	// Days
	schedule.Days = genruntime.CloneSliceOfString(source.Days)

	// Hours
	if source.Hours != nil {
		hourList := make([]int, len(source.Hours))
		for hourIndex, hourItem := range source.Hours {
			// Shadow the loop variable to avoid aliasing
			hourItem := hourItem
			hourList[hourIndex] = hourItem
		}
		schedule.Hours = hourList
	} else {
		schedule.Hours = nil
	}

	// Minutes
	if source.Minutes != nil {
		minuteList := make([]int, len(source.Minutes))
		for minuteIndex, minuteItem := range source.Minutes {
			// Shadow the loop variable to avoid aliasing
			minuteItem := minuteItem
			minuteList[minuteIndex] = minuteItem
		}
		schedule.Minutes = minuteList
	} else {
		schedule.Minutes = nil
	}

	// TimeZone
	schedule.TimeZone = genruntime.ClonePointerToString(source.TimeZone)

	// No error
	return nil
}

// AssignProperties_To_RecurrentSchedule_STATUS populates the provided destination RecurrentSchedule_STATUS from our RecurrentSchedule_STATUS
func (schedule *RecurrentSchedule_STATUS) AssignProperties_To_RecurrentSchedule_STATUS(destination *storage.RecurrentSchedule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Days
	destination.Days = genruntime.CloneSliceOfString(schedule.Days)

	// Hours
	if schedule.Hours != nil {
		hourList := make([]int, len(schedule.Hours))
		for hourIndex, hourItem := range schedule.Hours {
			// Shadow the loop variable to avoid aliasing
			hourItem := hourItem
			hourList[hourIndex] = hourItem
		}
		destination.Hours = hourList
	} else {
		destination.Hours = nil
	}

	// Minutes
	if schedule.Minutes != nil {
		minuteList := make([]int, len(schedule.Minutes))
		for minuteIndex, minuteItem := range schedule.Minutes {
			// Shadow the loop variable to avoid aliasing
			minuteItem := minuteItem
			minuteList[minuteIndex] = minuteItem
		}
		destination.Minutes = minuteList
	} else {
		destination.Minutes = nil
	}

	// TimeZone
	destination.TimeZone = genruntime.ClonePointerToString(schedule.TimeZone)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The parameters for the scaling action.
type ScaleAction struct {
	// +kubebuilder:validation:Required
	// Cooldown: the amount of time to wait since the last scaling action before this action occurs. It must be between 1 week
	// and 1 minute in ISO 8601 format.
	Cooldown *string `json:"cooldown,omitempty"`

	// +kubebuilder:validation:Required
	// Direction: the scale direction. Whether the scaling action increases or decreases the number of instances.
	Direction *ScaleAction_Direction `json:"direction,omitempty"`

	// +kubebuilder:validation:Required
	// Type: the type of action that should occur when the scale rule fires.
	Type *ScaleAction_Type `json:"type,omitempty"`

	// Value: the number of instances that are involved in the scaling action. This value must be 1 or greater. The default
	// value is 1.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &ScaleAction{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (action *ScaleAction) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if action == nil {
		return nil, nil
	}
	result := &arm.ScaleAction{}

	// Set property "Cooldown":
	if action.Cooldown != nil {
		cooldown := *action.Cooldown
		result.Cooldown = &cooldown
	}

	// Set property "Direction":
	if action.Direction != nil {
		var temp string
		temp = string(*action.Direction)
		direction := arm.ScaleAction_Direction(temp)
		result.Direction = &direction
	}

	// Set property "Type":
	if action.Type != nil {
		var temp string
		temp = string(*action.Type)
		typeVar := arm.ScaleAction_Type(temp)
		result.Type = &typeVar
	}

	// Set property "Value":
	if action.Value != nil {
		value := *action.Value
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *ScaleAction) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ScaleAction{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *ScaleAction) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ScaleAction)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ScaleAction, got %T", armInput)
	}

	// Set property "Cooldown":
	if typedInput.Cooldown != nil {
		cooldown := *typedInput.Cooldown
		action.Cooldown = &cooldown
	}

	// Set property "Direction":
	if typedInput.Direction != nil {
		var temp string
		temp = string(*typedInput.Direction)
		direction := ScaleAction_Direction(temp)
		action.Direction = &direction
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ScaleAction_Type(temp)
		action.Type = &typeVar
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		action.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_ScaleAction populates our ScaleAction from the provided source ScaleAction
func (action *ScaleAction) AssignProperties_From_ScaleAction(source *storage.ScaleAction) error {

	// Cooldown
	action.Cooldown = genruntime.ClonePointerToString(source.Cooldown)

	// Direction
	if source.Direction != nil {
		direction := *source.Direction
		directionTemp := genruntime.ToEnum(direction, scaleAction_Direction_Values)
		action.Direction = &directionTemp
	} else {
		action.Direction = nil
	}

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, scaleAction_Type_Values)
		action.Type = &typeTemp
	} else {
		action.Type = nil
	}

	// Value
	action.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_ScaleAction populates the provided destination ScaleAction from our ScaleAction
func (action *ScaleAction) AssignProperties_To_ScaleAction(destination *storage.ScaleAction) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Cooldown
	destination.Cooldown = genruntime.ClonePointerToString(action.Cooldown)

	// Direction
	if action.Direction != nil {
		direction := string(*action.Direction)
		destination.Direction = &direction
	} else {
		destination.Direction = nil
	}

	// Type
	if action.Type != nil {
		typeVar := string(*action.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Value
	destination.Value = genruntime.ClonePointerToString(action.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ScaleAction_STATUS populates our ScaleAction from the provided source ScaleAction_STATUS
func (action *ScaleAction) Initialize_From_ScaleAction_STATUS(source *ScaleAction_STATUS) error {

	// Cooldown
	action.Cooldown = genruntime.ClonePointerToString(source.Cooldown)

	// Direction
	if source.Direction != nil {
		direction := genruntime.ToEnum(string(*source.Direction), scaleAction_Direction_Values)
		action.Direction = &direction
	} else {
		action.Direction = nil
	}

	// Type
	if source.Type != nil {
		typeVar := genruntime.ToEnum(string(*source.Type), scaleAction_Type_Values)
		action.Type = &typeVar
	} else {
		action.Type = nil
	}

	// Value
	action.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// The parameters for the scaling action.
type ScaleAction_STATUS struct {
	// +kubebuilder:validation:Required
	// Cooldown: the amount of time to wait since the last scaling action before this action occurs. It must be between 1 week
	// and 1 minute in ISO 8601 format.
	Cooldown *string `json:"cooldown,omitempty"`

	// +kubebuilder:validation:Required
	// Direction: the scale direction. Whether the scaling action increases or decreases the number of instances.
	Direction *ScaleAction_Direction_STATUS `json:"direction,omitempty"`

	// +kubebuilder:validation:Required
	// Type: the type of action that should occur when the scale rule fires.
	Type *ScaleAction_Type_STATUS `json:"type,omitempty"`

	// Value: the number of instances that are involved in the scaling action. This value must be 1 or greater. The default
	// value is 1.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &ScaleAction_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *ScaleAction_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ScaleAction_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *ScaleAction_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ScaleAction_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ScaleAction_STATUS, got %T", armInput)
	}

	// Set property "Cooldown":
	if typedInput.Cooldown != nil {
		cooldown := *typedInput.Cooldown
		action.Cooldown = &cooldown
	}

	// Set property "Direction":
	if typedInput.Direction != nil {
		var temp string
		temp = string(*typedInput.Direction)
		direction := ScaleAction_Direction_STATUS(temp)
		action.Direction = &direction
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ScaleAction_Type_STATUS(temp)
		action.Type = &typeVar
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		action.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_ScaleAction_STATUS populates our ScaleAction_STATUS from the provided source ScaleAction_STATUS
func (action *ScaleAction_STATUS) AssignProperties_From_ScaleAction_STATUS(source *storage.ScaleAction_STATUS) error {

	// Cooldown
	action.Cooldown = genruntime.ClonePointerToString(source.Cooldown)

	// Direction
	if source.Direction != nil {
		direction := *source.Direction
		directionTemp := genruntime.ToEnum(direction, scaleAction_Direction_STATUS_Values)
		action.Direction = &directionTemp
	} else {
		action.Direction = nil
	}

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, scaleAction_Type_STATUS_Values)
		action.Type = &typeTemp
	} else {
		action.Type = nil
	}

	// Value
	action.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_ScaleAction_STATUS populates the provided destination ScaleAction_STATUS from our ScaleAction_STATUS
func (action *ScaleAction_STATUS) AssignProperties_To_ScaleAction_STATUS(destination *storage.ScaleAction_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Cooldown
	destination.Cooldown = genruntime.ClonePointerToString(action.Cooldown)

	// Direction
	if action.Direction != nil {
		direction := string(*action.Direction)
		destination.Direction = &direction
	} else {
		destination.Direction = nil
	}

	// Type
	if action.Type != nil {
		typeVar := string(*action.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Value
	destination.Value = genruntime.ClonePointerToString(action.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Equals","GreaterThan","GreaterThanOrEqual","LessThan","LessThanOrEqual","NotEquals"}
type MetricTrigger_Operator string

const (
	MetricTrigger_Operator_Equals             = MetricTrigger_Operator("Equals")
	MetricTrigger_Operator_GreaterThan        = MetricTrigger_Operator("GreaterThan")
	MetricTrigger_Operator_GreaterThanOrEqual = MetricTrigger_Operator("GreaterThanOrEqual")
	MetricTrigger_Operator_LessThan           = MetricTrigger_Operator("LessThan")
	MetricTrigger_Operator_LessThanOrEqual    = MetricTrigger_Operator("LessThanOrEqual")
	MetricTrigger_Operator_NotEquals          = MetricTrigger_Operator("NotEquals")
)

// Mapping from string to MetricTrigger_Operator
var metricTrigger_Operator_Values = map[string]MetricTrigger_Operator{
	"equals":             MetricTrigger_Operator_Equals,
	"greaterthan":        MetricTrigger_Operator_GreaterThan,
	"greaterthanorequal": MetricTrigger_Operator_GreaterThanOrEqual,
	"lessthan":           MetricTrigger_Operator_LessThan,
	"lessthanorequal":    MetricTrigger_Operator_LessThanOrEqual,
	"notequals":          MetricTrigger_Operator_NotEquals,
}

// +kubebuilder:validation:Enum={"Equals","GreaterThan","GreaterThanOrEqual","LessThan","LessThanOrEqual","NotEquals"}
type MetricTrigger_Operator_STATUS string

const (
	MetricTrigger_Operator_STATUS_Equals             = MetricTrigger_Operator_STATUS("Equals")
	MetricTrigger_Operator_STATUS_GreaterThan        = MetricTrigger_Operator_STATUS("GreaterThan")
	MetricTrigger_Operator_STATUS_GreaterThanOrEqual = MetricTrigger_Operator_STATUS("GreaterThanOrEqual")
	MetricTrigger_Operator_STATUS_LessThan           = MetricTrigger_Operator_STATUS("LessThan")
	MetricTrigger_Operator_STATUS_LessThanOrEqual    = MetricTrigger_Operator_STATUS("LessThanOrEqual")
	MetricTrigger_Operator_STATUS_NotEquals          = MetricTrigger_Operator_STATUS("NotEquals")
)

// Mapping from string to MetricTrigger_Operator_STATUS
var metricTrigger_Operator_STATUS_Values = map[string]MetricTrigger_Operator_STATUS{
	"equals":             MetricTrigger_Operator_STATUS_Equals,
	"greaterthan":        MetricTrigger_Operator_STATUS_GreaterThan,
	"greaterthanorequal": MetricTrigger_Operator_STATUS_GreaterThanOrEqual,
	"lessthan":           MetricTrigger_Operator_STATUS_LessThan,
	"lessthanorequal":    MetricTrigger_Operator_STATUS_LessThanOrEqual,
	"notequals":          MetricTrigger_Operator_STATUS_NotEquals,
}

// +kubebuilder:validation:Enum={"Average","Count","Max","Min","Sum"}
type MetricTrigger_Statistic string

const (
	MetricTrigger_Statistic_Average = MetricTrigger_Statistic("Average")
	MetricTrigger_Statistic_Count   = MetricTrigger_Statistic("Count")
	MetricTrigger_Statistic_Max     = MetricTrigger_Statistic("Max")
	MetricTrigger_Statistic_Min     = MetricTrigger_Statistic("Min")
	MetricTrigger_Statistic_Sum     = MetricTrigger_Statistic("Sum")
)

// Mapping from string to MetricTrigger_Statistic
var metricTrigger_Statistic_Values = map[string]MetricTrigger_Statistic{
	"average": MetricTrigger_Statistic_Average,
	"count":   MetricTrigger_Statistic_Count,
	"max":     MetricTrigger_Statistic_Max,
	"min":     MetricTrigger_Statistic_Min,
	"sum":     MetricTrigger_Statistic_Sum,
}

// +kubebuilder:validation:Enum={"Average","Count","Max","Min","Sum"}
type MetricTrigger_Statistic_STATUS string

const (
	MetricTrigger_Statistic_STATUS_Average = MetricTrigger_Statistic_STATUS("Average")
	MetricTrigger_Statistic_STATUS_Count   = MetricTrigger_Statistic_STATUS("Count")
	MetricTrigger_Statistic_STATUS_Max     = MetricTrigger_Statistic_STATUS("Max")
	MetricTrigger_Statistic_STATUS_Min     = MetricTrigger_Statistic_STATUS("Min")
	MetricTrigger_Statistic_STATUS_Sum     = MetricTrigger_Statistic_STATUS("Sum")
)

// Mapping from string to MetricTrigger_Statistic_STATUS
var metricTrigger_Statistic_STATUS_Values = map[string]MetricTrigger_Statistic_STATUS{
	"average": MetricTrigger_Statistic_STATUS_Average,
	"count":   MetricTrigger_Statistic_STATUS_Count,
	"max":     MetricTrigger_Statistic_STATUS_Max,
	"min":     MetricTrigger_Statistic_STATUS_Min,
	"sum":     MetricTrigger_Statistic_STATUS_Sum,
}

// +kubebuilder:validation:Enum={"Average","Count","Last","Maximum","Minimum","Total"}
type MetricTrigger_TimeAggregation string

const (
	MetricTrigger_TimeAggregation_Average = MetricTrigger_TimeAggregation("Average")
	MetricTrigger_TimeAggregation_Count   = MetricTrigger_TimeAggregation("Count")
	MetricTrigger_TimeAggregation_Last    = MetricTrigger_TimeAggregation("Last")
	MetricTrigger_TimeAggregation_Maximum = MetricTrigger_TimeAggregation("Maximum")
	MetricTrigger_TimeAggregation_Minimum = MetricTrigger_TimeAggregation("Minimum")
	MetricTrigger_TimeAggregation_Total   = MetricTrigger_TimeAggregation("Total")
)

// Mapping from string to MetricTrigger_TimeAggregation
var metricTrigger_TimeAggregation_Values = map[string]MetricTrigger_TimeAggregation{
	"average": MetricTrigger_TimeAggregation_Average,
	"count":   MetricTrigger_TimeAggregation_Count,
	"last":    MetricTrigger_TimeAggregation_Last,
	"maximum": MetricTrigger_TimeAggregation_Maximum,
	"minimum": MetricTrigger_TimeAggregation_Minimum,
	"total":   MetricTrigger_TimeAggregation_Total,
}

// +kubebuilder:validation:Enum={"Average","Count","Last","Maximum","Minimum","Total"}
type MetricTrigger_TimeAggregation_STATUS string

const (
	MetricTrigger_TimeAggregation_STATUS_Average = MetricTrigger_TimeAggregation_STATUS("Average")
	MetricTrigger_TimeAggregation_STATUS_Count   = MetricTrigger_TimeAggregation_STATUS("Count")
	MetricTrigger_TimeAggregation_STATUS_Last    = MetricTrigger_TimeAggregation_STATUS("Last")
	MetricTrigger_TimeAggregation_STATUS_Maximum = MetricTrigger_TimeAggregation_STATUS("Maximum")
	MetricTrigger_TimeAggregation_STATUS_Minimum = MetricTrigger_TimeAggregation_STATUS("Minimum")
	MetricTrigger_TimeAggregation_STATUS_Total   = MetricTrigger_TimeAggregation_STATUS("Total")
)

// Mapping from string to MetricTrigger_TimeAggregation_STATUS
var metricTrigger_TimeAggregation_STATUS_Values = map[string]MetricTrigger_TimeAggregation_STATUS{
	"average": MetricTrigger_TimeAggregation_STATUS_Average,
	"count":   MetricTrigger_TimeAggregation_STATUS_Count,
	"last":    MetricTrigger_TimeAggregation_STATUS_Last,
	"maximum": MetricTrigger_TimeAggregation_STATUS_Maximum,
	"minimum": MetricTrigger_TimeAggregation_STATUS_Minimum,
	"total":   MetricTrigger_TimeAggregation_STATUS_Total,
}

// +kubebuilder:validation:Enum={"Decrease","Increase","None"}
type ScaleAction_Direction string

const (
	ScaleAction_Direction_Decrease = ScaleAction_Direction("Decrease")
	ScaleAction_Direction_Increase = ScaleAction_Direction("Increase")
	ScaleAction_Direction_None     = ScaleAction_Direction("None")
)

// Mapping from string to ScaleAction_Direction
var scaleAction_Direction_Values = map[string]ScaleAction_Direction{
	"decrease": ScaleAction_Direction_Decrease,
	"increase": ScaleAction_Direction_Increase,
	"none":     ScaleAction_Direction_None,
}

// +kubebuilder:validation:Enum={"Decrease","Increase","None"}
type ScaleAction_Direction_STATUS string

const (
	ScaleAction_Direction_STATUS_Decrease = ScaleAction_Direction_STATUS("Decrease")
	ScaleAction_Direction_STATUS_Increase = ScaleAction_Direction_STATUS("Increase")
	ScaleAction_Direction_STATUS_None     = ScaleAction_Direction_STATUS("None")
)

// Mapping from string to ScaleAction_Direction_STATUS
var scaleAction_Direction_STATUS_Values = map[string]ScaleAction_Direction_STATUS{
	"decrease": ScaleAction_Direction_STATUS_Decrease,
	"increase": ScaleAction_Direction_STATUS_Increase,
	"none":     ScaleAction_Direction_STATUS_None,
}

// +kubebuilder:validation:Enum={"ChangeCount","ExactCount","PercentChangeCount","ServiceAllowedNextValue"}
type ScaleAction_Type string

const (
	ScaleAction_Type_ChangeCount             = ScaleAction_Type("ChangeCount")
	ScaleAction_Type_ExactCount              = ScaleAction_Type("ExactCount")
	ScaleAction_Type_PercentChangeCount      = ScaleAction_Type("PercentChangeCount")
	ScaleAction_Type_ServiceAllowedNextValue = ScaleAction_Type("ServiceAllowedNextValue")
)

// Mapping from string to ScaleAction_Type
var scaleAction_Type_Values = map[string]ScaleAction_Type{
	"changecount":             ScaleAction_Type_ChangeCount,
	"exactcount":              ScaleAction_Type_ExactCount,
	"percentchangecount":      ScaleAction_Type_PercentChangeCount,
	"serviceallowednextvalue": ScaleAction_Type_ServiceAllowedNextValue,
}

// +kubebuilder:validation:Enum={"ChangeCount","ExactCount","PercentChangeCount","ServiceAllowedNextValue"}
type ScaleAction_Type_STATUS string

const (
	ScaleAction_Type_STATUS_ChangeCount             = ScaleAction_Type_STATUS("ChangeCount")
	ScaleAction_Type_STATUS_ExactCount              = ScaleAction_Type_STATUS("ExactCount")
	ScaleAction_Type_STATUS_PercentChangeCount      = ScaleAction_Type_STATUS("PercentChangeCount")
	ScaleAction_Type_STATUS_ServiceAllowedNextValue = ScaleAction_Type_STATUS("ServiceAllowedNextValue")
)

// Mapping from string to ScaleAction_Type_STATUS
var scaleAction_Type_STATUS_Values = map[string]ScaleAction_Type_STATUS{
	"changecount":             ScaleAction_Type_STATUS_ChangeCount,
	"exactcount":              ScaleAction_Type_STATUS_ExactCount,
	"percentchangecount":      ScaleAction_Type_STATUS_PercentChangeCount,
	"serviceallowednextvalue": ScaleAction_Type_STATUS_ServiceAllowedNextValue,
}

// Specifies an auto scale rule metric dimension.
type ScaleRuleMetricDimension struct {
	// +kubebuilder:validation:Required
	// DimensionName: Name of the dimension.
	DimensionName *string `json:"DimensionName,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: the dimension operator. Only 'Equals' and 'NotEquals' are supported. 'Equals' being equal to any of the
	// values. 'NotEquals' being not equal to all of the values
	Operator *ScaleRuleMetricDimension_Operator `json:"Operator,omitempty"`

	// +kubebuilder:validation:Required
	// Values: list of dimension values. For example: ["App1","App2"].
	Values []string `json:"Values,omitempty"`
}

var _ genruntime.ARMTransformer = &ScaleRuleMetricDimension{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (dimension *ScaleRuleMetricDimension) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if dimension == nil {
		return nil, nil
	}
	result := &arm.ScaleRuleMetricDimension{}

	// Set property "DimensionName":
	if dimension.DimensionName != nil {
		dimensionName := *dimension.DimensionName
		result.DimensionName = &dimensionName
	}

	// Set property "Operator":
	if dimension.Operator != nil {
		var temp string
		temp = string(*dimension.Operator)
		operator := arm.ScaleRuleMetricDimension_Operator(temp)
		result.Operator = &operator
	}

	// Set property "Values":
	for _, item := range dimension.Values {
		result.Values = append(result.Values, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (dimension *ScaleRuleMetricDimension) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ScaleRuleMetricDimension{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (dimension *ScaleRuleMetricDimension) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ScaleRuleMetricDimension)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ScaleRuleMetricDimension, got %T", armInput)
	}

	// Set property "DimensionName":
	if typedInput.DimensionName != nil {
		dimensionName := *typedInput.DimensionName
		dimension.DimensionName = &dimensionName
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := ScaleRuleMetricDimension_Operator(temp)
		dimension.Operator = &operator
	}

	// Set property "Values":
	for _, item := range typedInput.Values {
		dimension.Values = append(dimension.Values, item)
	}

	// No error
	return nil
}

// AssignProperties_From_ScaleRuleMetricDimension populates our ScaleRuleMetricDimension from the provided source ScaleRuleMetricDimension
func (dimension *ScaleRuleMetricDimension) AssignProperties_From_ScaleRuleMetricDimension(source *storage.ScaleRuleMetricDimension) error {

	// DimensionName
	dimension.DimensionName = genruntime.ClonePointerToString(source.DimensionName)

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, scaleRuleMetricDimension_Operator_Values)
		dimension.Operator = &operatorTemp
	} else {
		dimension.Operator = nil
	}

	// Values
	dimension.Values = genruntime.CloneSliceOfString(source.Values)

	// No error
	return nil
}

// AssignProperties_To_ScaleRuleMetricDimension populates the provided destination ScaleRuleMetricDimension from our ScaleRuleMetricDimension
func (dimension *ScaleRuleMetricDimension) AssignProperties_To_ScaleRuleMetricDimension(destination *storage.ScaleRuleMetricDimension) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DimensionName
	destination.DimensionName = genruntime.ClonePointerToString(dimension.DimensionName)

	// Operator
	if dimension.Operator != nil {
		operator := string(*dimension.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Values
	destination.Values = genruntime.CloneSliceOfString(dimension.Values)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ScaleRuleMetricDimension_STATUS populates our ScaleRuleMetricDimension from the provided source ScaleRuleMetricDimension_STATUS
func (dimension *ScaleRuleMetricDimension) Initialize_From_ScaleRuleMetricDimension_STATUS(source *ScaleRuleMetricDimension_STATUS) error {

	// DimensionName
	dimension.DimensionName = genruntime.ClonePointerToString(source.DimensionName)

	// Operator
	if source.Operator != nil {
		operator := genruntime.ToEnum(string(*source.Operator), scaleRuleMetricDimension_Operator_Values)
		dimension.Operator = &operator
	} else {
		dimension.Operator = nil
	}

	// Values
	dimension.Values = genruntime.CloneSliceOfString(source.Values)

	// No error
	return nil
}

// Specifies an auto scale rule metric dimension.
type ScaleRuleMetricDimension_STATUS struct {
	// +kubebuilder:validation:Required
	// DimensionName: Name of the dimension.
	DimensionName *string `json:"DimensionName,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: the dimension operator. Only 'Equals' and 'NotEquals' are supported. 'Equals' being equal to any of the
	// values. 'NotEquals' being not equal to all of the values
	Operator *ScaleRuleMetricDimension_Operator_STATUS `json:"Operator,omitempty"`

	// +kubebuilder:validation:Required
	// Values: list of dimension values. For example: ["App1","App2"].
	Values []string `json:"Values,omitempty"`
}

var _ genruntime.FromARMConverter = &ScaleRuleMetricDimension_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (dimension *ScaleRuleMetricDimension_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ScaleRuleMetricDimension_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (dimension *ScaleRuleMetricDimension_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ScaleRuleMetricDimension_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ScaleRuleMetricDimension_STATUS, got %T", armInput)
	}

	// Set property "DimensionName":
	if typedInput.DimensionName != nil {
		dimensionName := *typedInput.DimensionName
		dimension.DimensionName = &dimensionName
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := ScaleRuleMetricDimension_Operator_STATUS(temp)
		dimension.Operator = &operator
	}

	// Set property "Values":
	for _, item := range typedInput.Values {
		dimension.Values = append(dimension.Values, item)
	}

	// No error
	return nil
}

// AssignProperties_From_ScaleRuleMetricDimension_STATUS populates our ScaleRuleMetricDimension_STATUS from the provided source ScaleRuleMetricDimension_STATUS
func (dimension *ScaleRuleMetricDimension_STATUS) AssignProperties_From_ScaleRuleMetricDimension_STATUS(source *storage.ScaleRuleMetricDimension_STATUS) error {

	// DimensionName
	dimension.DimensionName = genruntime.ClonePointerToString(source.DimensionName)

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, scaleRuleMetricDimension_Operator_STATUS_Values)
		dimension.Operator = &operatorTemp
	} else {
		dimension.Operator = nil
	}

	// Values
	dimension.Values = genruntime.CloneSliceOfString(source.Values)

	// No error
	return nil
}

// AssignProperties_To_ScaleRuleMetricDimension_STATUS populates the provided destination ScaleRuleMetricDimension_STATUS from our ScaleRuleMetricDimension_STATUS
func (dimension *ScaleRuleMetricDimension_STATUS) AssignProperties_To_ScaleRuleMetricDimension_STATUS(destination *storage.ScaleRuleMetricDimension_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DimensionName
	destination.DimensionName = genruntime.ClonePointerToString(dimension.DimensionName)

	// Operator
	if dimension.Operator != nil {
		operator := string(*dimension.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Values
	destination.Values = genruntime.CloneSliceOfString(dimension.Values)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Equals","NotEquals"}
type ScaleRuleMetricDimension_Operator string

const (
	ScaleRuleMetricDimension_Operator_Equals    = ScaleRuleMetricDimension_Operator("Equals")
	ScaleRuleMetricDimension_Operator_NotEquals = ScaleRuleMetricDimension_Operator("NotEquals")
)

// Mapping from string to ScaleRuleMetricDimension_Operator
var scaleRuleMetricDimension_Operator_Values = map[string]ScaleRuleMetricDimension_Operator{
	"equals":    ScaleRuleMetricDimension_Operator_Equals,
	"notequals": ScaleRuleMetricDimension_Operator_NotEquals,
}

// +kubebuilder:validation:Enum={"Equals","NotEquals"}
type ScaleRuleMetricDimension_Operator_STATUS string

const (
	ScaleRuleMetricDimension_Operator_STATUS_Equals    = ScaleRuleMetricDimension_Operator_STATUS("Equals")
	ScaleRuleMetricDimension_Operator_STATUS_NotEquals = ScaleRuleMetricDimension_Operator_STATUS("NotEquals")
)

// Mapping from string to ScaleRuleMetricDimension_Operator_STATUS
var scaleRuleMetricDimension_Operator_STATUS_Values = map[string]ScaleRuleMetricDimension_Operator_STATUS{
	"equals":    ScaleRuleMetricDimension_Operator_STATUS_Equals,
	"notequals": ScaleRuleMetricDimension_Operator_STATUS_NotEquals,
}

func init() {
	SchemeBuilder.Register(&AutoscaleSetting{}, &AutoscaleSettingList{})
}
