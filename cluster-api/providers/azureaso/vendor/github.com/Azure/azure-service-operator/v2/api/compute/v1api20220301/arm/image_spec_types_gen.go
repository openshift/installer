// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import "github.com/Azure/azure-service-operator/v2/pkg/genruntime"

type Image_Spec struct {
	// ExtendedLocation: The extended location of the Image.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`

	// Location: Resource location
	Location *string `json:"location,omitempty"`
	Name     string  `json:"name,omitempty"`

	// Properties: Describes the properties of an Image.
	Properties *ImageProperties `json:"properties,omitempty"`

	// Tags: Resource tags
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMResourceSpec = &Image_Spec{}

// GetAPIVersion returns the ARM API version of the resource. This is always "2022-03-01"
func (image Image_Spec) GetAPIVersion() string {
	return "2022-03-01"
}

// GetName returns the Name of the resource
func (image *Image_Spec) GetName() string {
	return image.Name
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Compute/images"
func (image *Image_Spec) GetType() string {
	return "Microsoft.Compute/images"
}

// The complex type of the extended location.
type ExtendedLocation struct {
	// Name: The name of the extended location.
	Name *string `json:"name,omitempty"`

	// Type: The type of the extended location.
	Type *ExtendedLocationType `json:"type,omitempty"`
}

// Describes the properties of an Image.
type ImageProperties struct {
	// HyperVGeneration: Specifies the HyperVGenerationType of the VirtualMachine created from the image. From API Version
	// 2019-03-01 if the image source is a blob, then we need the user to specify the value, if the source is managed resource
	// like disk or snapshot, we may require the user to specify the property if we cannot deduce it from the source managed
	// resource.
	HyperVGeneration *HyperVGenerationType `json:"hyperVGeneration,omitempty"`

	// SourceVirtualMachine: The source virtual machine from which Image is created.
	SourceVirtualMachine *SubResource `json:"sourceVirtualMachine,omitempty"`

	// StorageProfile: Specifies the storage settings for the virtual machine disks.
	StorageProfile *ImageStorageProfile `json:"storageProfile,omitempty"`
}

// The type of extendedLocation.
// +kubebuilder:validation:Enum={"EdgeZone"}
type ExtendedLocationType string

const ExtendedLocationType_EdgeZone = ExtendedLocationType("EdgeZone")

// Mapping from string to ExtendedLocationType
var extendedLocationType_Values = map[string]ExtendedLocationType{
	"edgezone": ExtendedLocationType_EdgeZone,
}

// Specifies the HyperVGeneration Type
// +kubebuilder:validation:Enum={"V1","V2"}
type HyperVGenerationType string

const (
	HyperVGenerationType_V1 = HyperVGenerationType("V1")
	HyperVGenerationType_V2 = HyperVGenerationType("V2")
)

// Mapping from string to HyperVGenerationType
var hyperVGenerationType_Values = map[string]HyperVGenerationType{
	"v1": HyperVGenerationType_V1,
	"v2": HyperVGenerationType_V2,
}

// Describes a storage profile.
type ImageStorageProfile struct {
	// DataDisks: Specifies the parameters that are used to add a data disk to a virtual machine.
	// For more information about disks, see [About disks and VHDs for Azure virtual
	// machines](https://docs.microsoft.com/azure/virtual-machines/managed-disks-overview).
	DataDisks []ImageDataDisk `json:"dataDisks,omitempty"`

	// OsDisk: Specifies information about the operating system disk used by the virtual machine.
	// For more information about disks, see [About disks and VHDs for Azure virtual
	// machines](https://docs.microsoft.com/azure/virtual-machines/managed-disks-overview).
	OsDisk *ImageOSDisk `json:"osDisk,omitempty"`

	// ZoneResilient: Specifies whether an image is zone resilient or not. Default is false. Zone resilient images can be
	// created only in regions that provide Zone Redundant Storage (ZRS).
	ZoneResilient *bool `json:"zoneResilient,omitempty"`
}

type SubResource struct {
	Id *string `json:"id,omitempty"`
}

// Describes a data disk.
type ImageDataDisk struct {
	// BlobUri: The Virtual Hard Disk.
	BlobUri *string `json:"blobUri,omitempty"`

	// Caching: Specifies the caching requirements.
	// Possible values are:
	// None
	// ReadOnly
	// ReadWrite
	// Default: None for Standard storage. ReadOnly for Premium storage
	Caching *ImageDataDisk_Caching `json:"caching,omitempty"`

	// DiskEncryptionSet: Specifies the customer managed disk encryption set resource id for the managed image disk.
	DiskEncryptionSet *SubResource `json:"diskEncryptionSet,omitempty"`

	// DiskSizeGB: Specifies the size of empty data disks in gigabytes. This element can be used to overwrite the name of the
	// disk in a virtual machine image.
	// This value cannot be larger than 1023 GB
	DiskSizeGB *int `json:"diskSizeGB,omitempty"`

	// Lun: Specifies the logical unit number of the data disk. This value is used to identify data disks within the VM and
	// therefore must be unique for each data disk attached to a VM.
	Lun *int `json:"lun,omitempty"`

	// ManagedDisk: The managedDisk.
	ManagedDisk *SubResource `json:"managedDisk,omitempty"`

	// Snapshot: The snapshot.
	Snapshot *SubResource `json:"snapshot,omitempty"`

	// StorageAccountType: Specifies the storage account type for the managed disk. NOTE: UltraSSD_LRS can only be used with
	// data disks, it cannot be used with OS Disk.
	StorageAccountType *StorageAccountType `json:"storageAccountType,omitempty"`
}

// Describes an Operating System disk.
type ImageOSDisk struct {
	// BlobUri: The Virtual Hard Disk.
	BlobUri *string `json:"blobUri,omitempty"`

	// Caching: Specifies the caching requirements.
	// Possible values are:
	// None
	// ReadOnly
	// ReadWrite
	// Default: None for Standard storage. ReadOnly for Premium storage
	Caching *ImageOSDisk_Caching `json:"caching,omitempty"`

	// DiskEncryptionSet: Specifies the customer managed disk encryption set resource id for the managed image disk.
	DiskEncryptionSet *SubResource `json:"diskEncryptionSet,omitempty"`

	// DiskSizeGB: Specifies the size of empty data disks in gigabytes. This element can be used to overwrite the name of the
	// disk in a virtual machine image.
	// This value cannot be larger than 1023 GB
	DiskSizeGB *int `json:"diskSizeGB,omitempty"`

	// ManagedDisk: The managedDisk.
	ManagedDisk *SubResource `json:"managedDisk,omitempty"`

	// OsState: The OS State. For managed images, use Generalized.
	OsState *ImageOSDisk_OsState `json:"osState,omitempty"`

	// OsType: This property allows you to specify the type of the OS that is included in the disk if creating a VM from a
	// custom image.
	// Possible values are:
	// Windows
	// Linux
	OsType *ImageOSDisk_OsType `json:"osType,omitempty"`

	// Snapshot: The snapshot.
	Snapshot *SubResource `json:"snapshot,omitempty"`

	// StorageAccountType: Specifies the storage account type for the managed disk. NOTE: UltraSSD_LRS can only be used with
	// data disks, it cannot be used with OS Disk.
	StorageAccountType *StorageAccountType `json:"storageAccountType,omitempty"`
}

// +kubebuilder:validation:Enum={"None","ReadOnly","ReadWrite"}
type ImageDataDisk_Caching string

const (
	ImageDataDisk_Caching_None      = ImageDataDisk_Caching("None")
	ImageDataDisk_Caching_ReadOnly  = ImageDataDisk_Caching("ReadOnly")
	ImageDataDisk_Caching_ReadWrite = ImageDataDisk_Caching("ReadWrite")
)

// Mapping from string to ImageDataDisk_Caching
var imageDataDisk_Caching_Values = map[string]ImageDataDisk_Caching{
	"none":      ImageDataDisk_Caching_None,
	"readonly":  ImageDataDisk_Caching_ReadOnly,
	"readwrite": ImageDataDisk_Caching_ReadWrite,
}

// +kubebuilder:validation:Enum={"None","ReadOnly","ReadWrite"}
type ImageOSDisk_Caching string

const (
	ImageOSDisk_Caching_None      = ImageOSDisk_Caching("None")
	ImageOSDisk_Caching_ReadOnly  = ImageOSDisk_Caching("ReadOnly")
	ImageOSDisk_Caching_ReadWrite = ImageOSDisk_Caching("ReadWrite")
)

// Mapping from string to ImageOSDisk_Caching
var imageOSDisk_Caching_Values = map[string]ImageOSDisk_Caching{
	"none":      ImageOSDisk_Caching_None,
	"readonly":  ImageOSDisk_Caching_ReadOnly,
	"readwrite": ImageOSDisk_Caching_ReadWrite,
}

// +kubebuilder:validation:Enum={"Generalized","Specialized"}
type ImageOSDisk_OsState string

const (
	ImageOSDisk_OsState_Generalized = ImageOSDisk_OsState("Generalized")
	ImageOSDisk_OsState_Specialized = ImageOSDisk_OsState("Specialized")
)

// Mapping from string to ImageOSDisk_OsState
var imageOSDisk_OsState_Values = map[string]ImageOSDisk_OsState{
	"generalized": ImageOSDisk_OsState_Generalized,
	"specialized": ImageOSDisk_OsState_Specialized,
}

// +kubebuilder:validation:Enum={"Linux","Windows"}
type ImageOSDisk_OsType string

const (
	ImageOSDisk_OsType_Linux   = ImageOSDisk_OsType("Linux")
	ImageOSDisk_OsType_Windows = ImageOSDisk_OsType("Windows")
)

// Mapping from string to ImageOSDisk_OsType
var imageOSDisk_OsType_Values = map[string]ImageOSDisk_OsType{
	"linux":   ImageOSDisk_OsType_Linux,
	"windows": ImageOSDisk_OsType_Windows,
}

// Specifies the storage account type for the managed disk. Managed OS disk storage account type can only be set when you
// create the scale set. NOTE: UltraSSD_LRS can only be used with data disks. It cannot be used with OS Disk. Standard_LRS
// uses Standard HDD. StandardSSD_LRS uses Standard SSD. Premium_LRS uses Premium SSD. UltraSSD_LRS uses Ultra disk.
// Premium_ZRS uses Premium SSD zone redundant storage. StandardSSD_ZRS uses Standard SSD zone redundant storage. For more
// information regarding disks supported for Windows Virtual Machines, refer to
// https://docs.microsoft.com/azure/virtual-machines/windows/disks-types and, for Linux Virtual Machines, refer to
// https://docs.microsoft.com/azure/virtual-machines/linux/disks-types
// +kubebuilder:validation:Enum={"PremiumV2_LRS","Premium_LRS","Premium_ZRS","StandardSSD_LRS","StandardSSD_ZRS","Standard_LRS","UltraSSD_LRS"}
type StorageAccountType string

const (
	StorageAccountType_PremiumV2_LRS   = StorageAccountType("PremiumV2_LRS")
	StorageAccountType_Premium_LRS     = StorageAccountType("Premium_LRS")
	StorageAccountType_Premium_ZRS     = StorageAccountType("Premium_ZRS")
	StorageAccountType_StandardSSD_LRS = StorageAccountType("StandardSSD_LRS")
	StorageAccountType_StandardSSD_ZRS = StorageAccountType("StandardSSD_ZRS")
	StorageAccountType_Standard_LRS    = StorageAccountType("Standard_LRS")
	StorageAccountType_UltraSSD_LRS    = StorageAccountType("UltraSSD_LRS")
)

// Mapping from string to StorageAccountType
var storageAccountType_Values = map[string]StorageAccountType{
	"premiumv2_lrs":   StorageAccountType_PremiumV2_LRS,
	"premium_lrs":     StorageAccountType_Premium_LRS,
	"premium_zrs":     StorageAccountType_Premium_ZRS,
	"standardssd_lrs": StorageAccountType_StandardSSD_LRS,
	"standardssd_zrs": StorageAccountType_StandardSSD_ZRS,
	"standard_lrs":    StorageAccountType_Standard_LRS,
	"ultrassd_lrs":    StorageAccountType_UltraSSD_LRS,
}
