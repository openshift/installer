// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20210601

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/cdn/v1api20210601/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/cdn/v1api20210601/storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /cdn/resource-manager/Microsoft.Cdn/stable/2021-06-01/cdn.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}
type ProfilesEndpoint struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ProfilesEndpoint_Spec   `json:"spec,omitempty"`
	Status            ProfilesEndpoint_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &ProfilesEndpoint{}

// GetConditions returns the conditions of the resource
func (endpoint *ProfilesEndpoint) GetConditions() conditions.Conditions {
	return endpoint.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (endpoint *ProfilesEndpoint) SetConditions(conditions conditions.Conditions) {
	endpoint.Status.Conditions = conditions
}

var _ conversion.Convertible = &ProfilesEndpoint{}

// ConvertFrom populates our ProfilesEndpoint from the provided hub ProfilesEndpoint
func (endpoint *ProfilesEndpoint) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.ProfilesEndpoint)
	if !ok {
		return fmt.Errorf("expected cdn/v1api20210601/storage/ProfilesEndpoint but received %T instead", hub)
	}

	return endpoint.AssignProperties_From_ProfilesEndpoint(source)
}

// ConvertTo populates the provided hub ProfilesEndpoint from our ProfilesEndpoint
func (endpoint *ProfilesEndpoint) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.ProfilesEndpoint)
	if !ok {
		return fmt.Errorf("expected cdn/v1api20210601/storage/ProfilesEndpoint but received %T instead", hub)
	}

	return endpoint.AssignProperties_To_ProfilesEndpoint(destination)
}

// +kubebuilder:webhook:path=/mutate-cdn-azure-com-v1api20210601-profilesendpoint,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=cdn.azure.com,resources=profilesendpoints,verbs=create;update,versions=v1api20210601,name=default.v1api20210601.profilesendpoints.cdn.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &ProfilesEndpoint{}

// Default applies defaults to the ProfilesEndpoint resource
func (endpoint *ProfilesEndpoint) Default() {
	endpoint.defaultImpl()
	var temp any = endpoint
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (endpoint *ProfilesEndpoint) defaultAzureName() {
	if endpoint.Spec.AzureName == "" {
		endpoint.Spec.AzureName = endpoint.Name
	}
}

// defaultImpl applies the code generated defaults to the ProfilesEndpoint resource
func (endpoint *ProfilesEndpoint) defaultImpl() { endpoint.defaultAzureName() }

var _ configmaps.Exporter = &ProfilesEndpoint{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (endpoint *ProfilesEndpoint) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if endpoint.Spec.OperatorSpec == nil {
		return nil
	}
	return endpoint.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &ProfilesEndpoint{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (endpoint *ProfilesEndpoint) SecretDestinationExpressions() []*core.DestinationExpression {
	if endpoint.Spec.OperatorSpec == nil {
		return nil
	}
	return endpoint.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &ProfilesEndpoint{}

// InitializeSpec initializes the spec for this resource from the given status
func (endpoint *ProfilesEndpoint) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*ProfilesEndpoint_STATUS); ok {
		return endpoint.Spec.Initialize_From_ProfilesEndpoint_STATUS(s)
	}

	return fmt.Errorf("expected Status of type ProfilesEndpoint_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &ProfilesEndpoint{}

// AzureName returns the Azure name of the resource
func (endpoint *ProfilesEndpoint) AzureName() string {
	return endpoint.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2021-06-01"
func (endpoint ProfilesEndpoint) GetAPIVersion() string {
	return "2021-06-01"
}

// GetResourceScope returns the scope of the resource
func (endpoint *ProfilesEndpoint) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (endpoint *ProfilesEndpoint) GetSpec() genruntime.ConvertibleSpec {
	return &endpoint.Spec
}

// GetStatus returns the status of this resource
func (endpoint *ProfilesEndpoint) GetStatus() genruntime.ConvertibleStatus {
	return &endpoint.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (endpoint *ProfilesEndpoint) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Cdn/profiles/endpoints"
func (endpoint *ProfilesEndpoint) GetType() string {
	return "Microsoft.Cdn/profiles/endpoints"
}

// NewEmptyStatus returns a new empty (blank) status
func (endpoint *ProfilesEndpoint) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &ProfilesEndpoint_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (endpoint *ProfilesEndpoint) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(endpoint.Spec)
	return endpoint.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (endpoint *ProfilesEndpoint) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*ProfilesEndpoint_STATUS); ok {
		endpoint.Status = *st
		return nil
	}

	// Convert status to required version
	var st ProfilesEndpoint_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	endpoint.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-cdn-azure-com-v1api20210601-profilesendpoint,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=cdn.azure.com,resources=profilesendpoints,verbs=create;update,versions=v1api20210601,name=validate.v1api20210601.profilesendpoints.cdn.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &ProfilesEndpoint{}

// ValidateCreate validates the creation of the resource
func (endpoint *ProfilesEndpoint) ValidateCreate() (admission.Warnings, error) {
	validations := endpoint.createValidations()
	var temp any = endpoint
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	return genruntime.ValidateCreate(validations)
}

// ValidateDelete validates the deletion of the resource
func (endpoint *ProfilesEndpoint) ValidateDelete() (admission.Warnings, error) {
	validations := endpoint.deleteValidations()
	var temp any = endpoint
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	return genruntime.ValidateDelete(validations)
}

// ValidateUpdate validates an update of the resource
func (endpoint *ProfilesEndpoint) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	validations := endpoint.updateValidations()
	var temp any = endpoint
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	return genruntime.ValidateUpdate(old, validations)
}

// createValidations validates the creation of the resource
func (endpoint *ProfilesEndpoint) createValidations() []func() (admission.Warnings, error) {
	return []func() (admission.Warnings, error){endpoint.validateResourceReferences, endpoint.validateOwnerReference, endpoint.validateSecretDestinations, endpoint.validateConfigMapDestinations}
}

// deleteValidations validates the deletion of the resource
func (endpoint *ProfilesEndpoint) deleteValidations() []func() (admission.Warnings, error) {
	return nil
}

// updateValidations validates the update of the resource
func (endpoint *ProfilesEndpoint) updateValidations() []func(old runtime.Object) (admission.Warnings, error) {
	return []func(old runtime.Object) (admission.Warnings, error){
		func(old runtime.Object) (admission.Warnings, error) {
			return endpoint.validateResourceReferences()
		},
		endpoint.validateWriteOnceProperties,
		func(old runtime.Object) (admission.Warnings, error) {
			return endpoint.validateOwnerReference()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return endpoint.validateSecretDestinations()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return endpoint.validateConfigMapDestinations()
		},
	}
}

// validateConfigMapDestinations validates there are no colliding genruntime.ConfigMapDestinations
func (endpoint *ProfilesEndpoint) validateConfigMapDestinations() (admission.Warnings, error) {
	if endpoint.Spec.OperatorSpec == nil {
		return nil, nil
	}
	return configmaps.ValidateDestinations(endpoint, nil, endpoint.Spec.OperatorSpec.ConfigMapExpressions)
}

// validateOwnerReference validates the owner field
func (endpoint *ProfilesEndpoint) validateOwnerReference() (admission.Warnings, error) {
	return genruntime.ValidateOwner(endpoint)
}

// validateResourceReferences validates all resource references
func (endpoint *ProfilesEndpoint) validateResourceReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindResourceReferences(&endpoint.Spec)
	if err != nil {
		return nil, err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateSecretDestinations validates there are no colliding genruntime.SecretDestination's
func (endpoint *ProfilesEndpoint) validateSecretDestinations() (admission.Warnings, error) {
	if endpoint.Spec.OperatorSpec == nil {
		return nil, nil
	}
	return secrets.ValidateDestinations(endpoint, nil, endpoint.Spec.OperatorSpec.SecretExpressions)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (endpoint *ProfilesEndpoint) validateWriteOnceProperties(old runtime.Object) (admission.Warnings, error) {
	oldObj, ok := old.(*ProfilesEndpoint)
	if !ok {
		return nil, nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, endpoint)
}

// AssignProperties_From_ProfilesEndpoint populates our ProfilesEndpoint from the provided source ProfilesEndpoint
func (endpoint *ProfilesEndpoint) AssignProperties_From_ProfilesEndpoint(source *storage.ProfilesEndpoint) error {

	// ObjectMeta
	endpoint.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec ProfilesEndpoint_Spec
	err := spec.AssignProperties_From_ProfilesEndpoint_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_ProfilesEndpoint_Spec() to populate field Spec")
	}
	endpoint.Spec = spec

	// Status
	var status ProfilesEndpoint_STATUS
	err = status.AssignProperties_From_ProfilesEndpoint_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_ProfilesEndpoint_STATUS() to populate field Status")
	}
	endpoint.Status = status

	// No error
	return nil
}

// AssignProperties_To_ProfilesEndpoint populates the provided destination ProfilesEndpoint from our ProfilesEndpoint
func (endpoint *ProfilesEndpoint) AssignProperties_To_ProfilesEndpoint(destination *storage.ProfilesEndpoint) error {

	// ObjectMeta
	destination.ObjectMeta = *endpoint.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.ProfilesEndpoint_Spec
	err := endpoint.Spec.AssignProperties_To_ProfilesEndpoint_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_ProfilesEndpoint_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.ProfilesEndpoint_STATUS
	err = endpoint.Status.AssignProperties_To_ProfilesEndpoint_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_ProfilesEndpoint_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (endpoint *ProfilesEndpoint) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: endpoint.Spec.OriginalVersion(),
		Kind:    "ProfilesEndpoint",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /cdn/resource-manager/Microsoft.Cdn/stable/2021-06-01/cdn.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}
type ProfilesEndpointList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ProfilesEndpoint `json:"items"`
}

type ProfilesEndpoint_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// ContentTypesToCompress: List of content types on which compression applies. The value should be a valid MIME type.
	ContentTypesToCompress []string `json:"contentTypesToCompress,omitempty"`

	// DefaultOriginGroup: A reference to the origin group.
	DefaultOriginGroup *ResourceReference `json:"defaultOriginGroup,omitempty"`

	// DeliveryPolicy: A policy that specifies the delivery rules to be used for an endpoint.
	DeliveryPolicy *EndpointProperties_DeliveryPolicy `json:"deliveryPolicy,omitempty"`

	// GeoFilters: List of rules defining the user's geo access within a CDN endpoint. Each geo filter defines an access rule
	// to a specified path or content, e.g. block APAC for path /pictures/
	GeoFilters []GeoFilter `json:"geoFilters,omitempty"`

	// IsCompressionEnabled: Indicates whether content compression is enabled on CDN. Default value is false. If compression is
	// enabled, content will be served as compressed if user requests for a compressed version. Content won't be compressed on
	// CDN when requested content is smaller than 1 byte or larger than 1 MB.
	IsCompressionEnabled *bool `json:"isCompressionEnabled,omitempty"`

	// IsHttpAllowed: Indicates whether HTTP traffic is allowed on the endpoint. Default value is true. At least one protocol
	// (HTTP or HTTPS) must be allowed.
	IsHttpAllowed *bool `json:"isHttpAllowed,omitempty"`

	// IsHttpsAllowed: Indicates whether HTTPS traffic is allowed on the endpoint. Default value is true. At least one protocol
	// (HTTP or HTTPS) must be allowed.
	IsHttpsAllowed *bool `json:"isHttpsAllowed,omitempty"`

	// +kubebuilder:validation:Required
	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *ProfilesEndpointOperatorSpec `json:"operatorSpec,omitempty"`

	// OptimizationType: Specifies what scenario the customer wants this CDN endpoint to optimize for, e.g. Download, Media
	// services. With this information, CDN can apply scenario driven optimization.
	OptimizationType *OptimizationType `json:"optimizationType,omitempty"`

	// OriginGroups: The origin groups comprising of origins that are used for load balancing the traffic based on availability.
	OriginGroups []DeepCreatedOriginGroup `json:"originGroups,omitempty"`

	// OriginHostHeader: The host header value sent to the origin with each request. This property at Endpoint is only allowed
	// when endpoint uses single origin and can be overridden by the same property specified at origin.If you leave this blank,
	// the request hostname determines this value. Azure CDN origins, such as Web Apps, Blob Storage, and Cloud Services
	// require this host header value to match the origin hostname by default.
	OriginHostHeader *string `json:"originHostHeader,omitempty"`

	// OriginPath: A directory path on the origin that CDN can use to retrieve content from, e.g.
	// contoso.cloudapp.net/originpath.
	OriginPath *string `json:"originPath,omitempty"`

	// +kubebuilder:validation:Required
	// Origins: The source of the content being delivered via CDN.
	Origins []DeepCreatedOrigin `json:"origins,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a cdn.azure.com/Profile resource
	Owner *genruntime.KnownResourceReference `group:"cdn.azure.com" json:"owner,omitempty" kind:"Profile"`

	// ProbePath: Path to a file hosted on the origin which helps accelerate delivery of the dynamic content and calculate the
	// most optimal routes for the CDN. This is relative to the origin path. This property is only relevant when using a single
	// origin.
	ProbePath *string `json:"probePath,omitempty"`

	// QueryStringCachingBehavior: Defines how CDN caches requests that include query strings. You can ignore any query strings
	// when caching, bypass caching to prevent requests that contain query strings from being cached, or cache every request
	// with a unique URL.
	QueryStringCachingBehavior *QueryStringCachingBehavior `json:"queryStringCachingBehavior,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// UrlSigningKeys: List of keys used to validate the signed URL hashes.
	UrlSigningKeys []UrlSigningKey `json:"urlSigningKeys,omitempty"`

	// WebApplicationFirewallPolicyLink: Defines the Web Application Firewall policy for the endpoint (if applicable)
	WebApplicationFirewallPolicyLink *EndpointProperties_WebApplicationFirewallPolicyLink `json:"webApplicationFirewallPolicyLink,omitempty"`
}

var _ genruntime.ARMTransformer = &ProfilesEndpoint_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (endpoint *ProfilesEndpoint_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if endpoint == nil {
		return nil, nil
	}
	result := &arm.ProfilesEndpoint_Spec{}

	// Set property "Location":
	if endpoint.Location != nil {
		location := *endpoint.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if endpoint.ContentTypesToCompress != nil ||
		endpoint.DefaultOriginGroup != nil ||
		endpoint.DeliveryPolicy != nil ||
		endpoint.GeoFilters != nil ||
		endpoint.IsCompressionEnabled != nil ||
		endpoint.IsHttpAllowed != nil ||
		endpoint.IsHttpsAllowed != nil ||
		endpoint.OptimizationType != nil ||
		endpoint.OriginGroups != nil ||
		endpoint.OriginHostHeader != nil ||
		endpoint.OriginPath != nil ||
		endpoint.Origins != nil ||
		endpoint.ProbePath != nil ||
		endpoint.QueryStringCachingBehavior != nil ||
		endpoint.UrlSigningKeys != nil ||
		endpoint.WebApplicationFirewallPolicyLink != nil {
		result.Properties = &arm.EndpointProperties{}
	}
	for _, item := range endpoint.ContentTypesToCompress {
		result.Properties.ContentTypesToCompress = append(result.Properties.ContentTypesToCompress, item)
	}
	if endpoint.DefaultOriginGroup != nil {
		defaultOriginGroup_ARM, err := (*endpoint.DefaultOriginGroup).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		defaultOriginGroup := *defaultOriginGroup_ARM.(*arm.ResourceReference)
		result.Properties.DefaultOriginGroup = &defaultOriginGroup
	}
	if endpoint.DeliveryPolicy != nil {
		deliveryPolicy_ARM, err := (*endpoint.DeliveryPolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		deliveryPolicy := *deliveryPolicy_ARM.(*arm.EndpointProperties_DeliveryPolicy)
		result.Properties.DeliveryPolicy = &deliveryPolicy
	}
	for _, item := range endpoint.GeoFilters {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.GeoFilters = append(result.Properties.GeoFilters, *item_ARM.(*arm.GeoFilter))
	}
	if endpoint.IsCompressionEnabled != nil {
		isCompressionEnabled := *endpoint.IsCompressionEnabled
		result.Properties.IsCompressionEnabled = &isCompressionEnabled
	}
	if endpoint.IsHttpAllowed != nil {
		isHttpAllowed := *endpoint.IsHttpAllowed
		result.Properties.IsHttpAllowed = &isHttpAllowed
	}
	if endpoint.IsHttpsAllowed != nil {
		isHttpsAllowed := *endpoint.IsHttpsAllowed
		result.Properties.IsHttpsAllowed = &isHttpsAllowed
	}
	if endpoint.OptimizationType != nil {
		var temp string
		temp = string(*endpoint.OptimizationType)
		optimizationType := arm.OptimizationType(temp)
		result.Properties.OptimizationType = &optimizationType
	}
	for _, item := range endpoint.OriginGroups {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.OriginGroups = append(result.Properties.OriginGroups, *item_ARM.(*arm.DeepCreatedOriginGroup))
	}
	if endpoint.OriginHostHeader != nil {
		originHostHeader := *endpoint.OriginHostHeader
		result.Properties.OriginHostHeader = &originHostHeader
	}
	if endpoint.OriginPath != nil {
		originPath := *endpoint.OriginPath
		result.Properties.OriginPath = &originPath
	}
	for _, item := range endpoint.Origins {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.Origins = append(result.Properties.Origins, *item_ARM.(*arm.DeepCreatedOrigin))
	}
	if endpoint.ProbePath != nil {
		probePath := *endpoint.ProbePath
		result.Properties.ProbePath = &probePath
	}
	if endpoint.QueryStringCachingBehavior != nil {
		var temp string
		temp = string(*endpoint.QueryStringCachingBehavior)
		queryStringCachingBehavior := arm.QueryStringCachingBehavior(temp)
		result.Properties.QueryStringCachingBehavior = &queryStringCachingBehavior
	}
	for _, item := range endpoint.UrlSigningKeys {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.UrlSigningKeys = append(result.Properties.UrlSigningKeys, *item_ARM.(*arm.UrlSigningKey))
	}
	if endpoint.WebApplicationFirewallPolicyLink != nil {
		webApplicationFirewallPolicyLink_ARM, err := (*endpoint.WebApplicationFirewallPolicyLink).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		webApplicationFirewallPolicyLink := *webApplicationFirewallPolicyLink_ARM.(*arm.EndpointProperties_WebApplicationFirewallPolicyLink)
		result.Properties.WebApplicationFirewallPolicyLink = &webApplicationFirewallPolicyLink
	}

	// Set property "Tags":
	if endpoint.Tags != nil {
		result.Tags = make(map[string]string, len(endpoint.Tags))
		for key, value := range endpoint.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (endpoint *ProfilesEndpoint_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ProfilesEndpoint_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (endpoint *ProfilesEndpoint_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ProfilesEndpoint_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ProfilesEndpoint_Spec, got %T", armInput)
	}

	// Set property "AzureName":
	endpoint.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "ContentTypesToCompress":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ContentTypesToCompress {
			endpoint.ContentTypesToCompress = append(endpoint.ContentTypesToCompress, item)
		}
	}

	// Set property "DefaultOriginGroup":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DefaultOriginGroup != nil {
			var defaultOriginGroup1 ResourceReference
			err := defaultOriginGroup1.PopulateFromARM(owner, *typedInput.Properties.DefaultOriginGroup)
			if err != nil {
				return err
			}
			defaultOriginGroup := defaultOriginGroup1
			endpoint.DefaultOriginGroup = &defaultOriginGroup
		}
	}

	// Set property "DeliveryPolicy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DeliveryPolicy != nil {
			var deliveryPolicy1 EndpointProperties_DeliveryPolicy
			err := deliveryPolicy1.PopulateFromARM(owner, *typedInput.Properties.DeliveryPolicy)
			if err != nil {
				return err
			}
			deliveryPolicy := deliveryPolicy1
			endpoint.DeliveryPolicy = &deliveryPolicy
		}
	}

	// Set property "GeoFilters":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.GeoFilters {
			var item1 GeoFilter
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.GeoFilters = append(endpoint.GeoFilters, item1)
		}
	}

	// Set property "IsCompressionEnabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IsCompressionEnabled != nil {
			isCompressionEnabled := *typedInput.Properties.IsCompressionEnabled
			endpoint.IsCompressionEnabled = &isCompressionEnabled
		}
	}

	// Set property "IsHttpAllowed":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IsHttpAllowed != nil {
			isHttpAllowed := *typedInput.Properties.IsHttpAllowed
			endpoint.IsHttpAllowed = &isHttpAllowed
		}
	}

	// Set property "IsHttpsAllowed":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IsHttpsAllowed != nil {
			isHttpsAllowed := *typedInput.Properties.IsHttpsAllowed
			endpoint.IsHttpsAllowed = &isHttpsAllowed
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		endpoint.Location = &location
	}

	// no assignment for property "OperatorSpec"

	// Set property "OptimizationType":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OptimizationType != nil {
			var temp string
			temp = string(*typedInput.Properties.OptimizationType)
			optimizationType := OptimizationType(temp)
			endpoint.OptimizationType = &optimizationType
		}
	}

	// Set property "OriginGroups":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.OriginGroups {
			var item1 DeepCreatedOriginGroup
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.OriginGroups = append(endpoint.OriginGroups, item1)
		}
	}

	// Set property "OriginHostHeader":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OriginHostHeader != nil {
			originHostHeader := *typedInput.Properties.OriginHostHeader
			endpoint.OriginHostHeader = &originHostHeader
		}
	}

	// Set property "OriginPath":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OriginPath != nil {
			originPath := *typedInput.Properties.OriginPath
			endpoint.OriginPath = &originPath
		}
	}

	// Set property "Origins":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Origins {
			var item1 DeepCreatedOrigin
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.Origins = append(endpoint.Origins, item1)
		}
	}

	// Set property "Owner":
	endpoint.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "ProbePath":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProbePath != nil {
			probePath := *typedInput.Properties.ProbePath
			endpoint.ProbePath = &probePath
		}
	}

	// Set property "QueryStringCachingBehavior":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.QueryStringCachingBehavior != nil {
			var temp string
			temp = string(*typedInput.Properties.QueryStringCachingBehavior)
			queryStringCachingBehavior := QueryStringCachingBehavior(temp)
			endpoint.QueryStringCachingBehavior = &queryStringCachingBehavior
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		endpoint.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			endpoint.Tags[key] = value
		}
	}

	// Set property "UrlSigningKeys":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.UrlSigningKeys {
			var item1 UrlSigningKey
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.UrlSigningKeys = append(endpoint.UrlSigningKeys, item1)
		}
	}

	// Set property "WebApplicationFirewallPolicyLink":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.WebApplicationFirewallPolicyLink != nil {
			var webApplicationFirewallPolicyLink1 EndpointProperties_WebApplicationFirewallPolicyLink
			err := webApplicationFirewallPolicyLink1.PopulateFromARM(owner, *typedInput.Properties.WebApplicationFirewallPolicyLink)
			if err != nil {
				return err
			}
			webApplicationFirewallPolicyLink := webApplicationFirewallPolicyLink1
			endpoint.WebApplicationFirewallPolicyLink = &webApplicationFirewallPolicyLink
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &ProfilesEndpoint_Spec{}

// ConvertSpecFrom populates our ProfilesEndpoint_Spec from the provided source
func (endpoint *ProfilesEndpoint_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.ProfilesEndpoint_Spec)
	if ok {
		// Populate our instance from source
		return endpoint.AssignProperties_From_ProfilesEndpoint_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.ProfilesEndpoint_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = endpoint.AssignProperties_From_ProfilesEndpoint_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our ProfilesEndpoint_Spec
func (endpoint *ProfilesEndpoint_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.ProfilesEndpoint_Spec)
	if ok {
		// Populate destination from our instance
		return endpoint.AssignProperties_To_ProfilesEndpoint_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.ProfilesEndpoint_Spec{}
	err := endpoint.AssignProperties_To_ProfilesEndpoint_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_ProfilesEndpoint_Spec populates our ProfilesEndpoint_Spec from the provided source ProfilesEndpoint_Spec
func (endpoint *ProfilesEndpoint_Spec) AssignProperties_From_ProfilesEndpoint_Spec(source *storage.ProfilesEndpoint_Spec) error {

	// AzureName
	endpoint.AzureName = source.AzureName

	// ContentTypesToCompress
	endpoint.ContentTypesToCompress = genruntime.CloneSliceOfString(source.ContentTypesToCompress)

	// DefaultOriginGroup
	if source.DefaultOriginGroup != nil {
		var defaultOriginGroup ResourceReference
		err := defaultOriginGroup.AssignProperties_From_ResourceReference(source.DefaultOriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceReference() to populate field DefaultOriginGroup")
		}
		endpoint.DefaultOriginGroup = &defaultOriginGroup
	} else {
		endpoint.DefaultOriginGroup = nil
	}

	// DeliveryPolicy
	if source.DeliveryPolicy != nil {
		var deliveryPolicy EndpointProperties_DeliveryPolicy
		err := deliveryPolicy.AssignProperties_From_EndpointProperties_DeliveryPolicy(source.DeliveryPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_EndpointProperties_DeliveryPolicy() to populate field DeliveryPolicy")
		}
		endpoint.DeliveryPolicy = &deliveryPolicy
	} else {
		endpoint.DeliveryPolicy = nil
	}

	// GeoFilters
	if source.GeoFilters != nil {
		geoFilterList := make([]GeoFilter, len(source.GeoFilters))
		for geoFilterIndex, geoFilterItem := range source.GeoFilters {
			// Shadow the loop variable to avoid aliasing
			geoFilterItem := geoFilterItem
			var geoFilter GeoFilter
			err := geoFilter.AssignProperties_From_GeoFilter(&geoFilterItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_GeoFilter() to populate field GeoFilters")
			}
			geoFilterList[geoFilterIndex] = geoFilter
		}
		endpoint.GeoFilters = geoFilterList
	} else {
		endpoint.GeoFilters = nil
	}

	// IsCompressionEnabled
	if source.IsCompressionEnabled != nil {
		isCompressionEnabled := *source.IsCompressionEnabled
		endpoint.IsCompressionEnabled = &isCompressionEnabled
	} else {
		endpoint.IsCompressionEnabled = nil
	}

	// IsHttpAllowed
	if source.IsHttpAllowed != nil {
		isHttpAllowed := *source.IsHttpAllowed
		endpoint.IsHttpAllowed = &isHttpAllowed
	} else {
		endpoint.IsHttpAllowed = nil
	}

	// IsHttpsAllowed
	if source.IsHttpsAllowed != nil {
		isHttpsAllowed := *source.IsHttpsAllowed
		endpoint.IsHttpsAllowed = &isHttpsAllowed
	} else {
		endpoint.IsHttpsAllowed = nil
	}

	// Location
	endpoint.Location = genruntime.ClonePointerToString(source.Location)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec ProfilesEndpointOperatorSpec
		err := operatorSpec.AssignProperties_From_ProfilesEndpointOperatorSpec(source.OperatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ProfilesEndpointOperatorSpec() to populate field OperatorSpec")
		}
		endpoint.OperatorSpec = &operatorSpec
	} else {
		endpoint.OperatorSpec = nil
	}

	// OptimizationType
	if source.OptimizationType != nil {
		optimizationType := *source.OptimizationType
		optimizationTypeTemp := genruntime.ToEnum(optimizationType, optimizationType_Values)
		endpoint.OptimizationType = &optimizationTypeTemp
	} else {
		endpoint.OptimizationType = nil
	}

	// OriginGroups
	if source.OriginGroups != nil {
		originGroupList := make([]DeepCreatedOriginGroup, len(source.OriginGroups))
		for originGroupIndex, originGroupItem := range source.OriginGroups {
			// Shadow the loop variable to avoid aliasing
			originGroupItem := originGroupItem
			var originGroup DeepCreatedOriginGroup
			err := originGroup.AssignProperties_From_DeepCreatedOriginGroup(&originGroupItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DeepCreatedOriginGroup() to populate field OriginGroups")
			}
			originGroupList[originGroupIndex] = originGroup
		}
		endpoint.OriginGroups = originGroupList
	} else {
		endpoint.OriginGroups = nil
	}

	// OriginHostHeader
	endpoint.OriginHostHeader = genruntime.ClonePointerToString(source.OriginHostHeader)

	// OriginPath
	endpoint.OriginPath = genruntime.ClonePointerToString(source.OriginPath)

	// Origins
	if source.Origins != nil {
		originList := make([]DeepCreatedOrigin, len(source.Origins))
		for originIndex, originItem := range source.Origins {
			// Shadow the loop variable to avoid aliasing
			originItem := originItem
			var origin DeepCreatedOrigin
			err := origin.AssignProperties_From_DeepCreatedOrigin(&originItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DeepCreatedOrigin() to populate field Origins")
			}
			originList[originIndex] = origin
		}
		endpoint.Origins = originList
	} else {
		endpoint.Origins = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		endpoint.Owner = &owner
	} else {
		endpoint.Owner = nil
	}

	// ProbePath
	endpoint.ProbePath = genruntime.ClonePointerToString(source.ProbePath)

	// QueryStringCachingBehavior
	if source.QueryStringCachingBehavior != nil {
		queryStringCachingBehavior := *source.QueryStringCachingBehavior
		queryStringCachingBehaviorTemp := genruntime.ToEnum(queryStringCachingBehavior, queryStringCachingBehavior_Values)
		endpoint.QueryStringCachingBehavior = &queryStringCachingBehaviorTemp
	} else {
		endpoint.QueryStringCachingBehavior = nil
	}

	// Tags
	endpoint.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// UrlSigningKeys
	if source.UrlSigningKeys != nil {
		urlSigningKeyList := make([]UrlSigningKey, len(source.UrlSigningKeys))
		for urlSigningKeyIndex, urlSigningKeyItem := range source.UrlSigningKeys {
			// Shadow the loop variable to avoid aliasing
			urlSigningKeyItem := urlSigningKeyItem
			var urlSigningKey UrlSigningKey
			err := urlSigningKey.AssignProperties_From_UrlSigningKey(&urlSigningKeyItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_UrlSigningKey() to populate field UrlSigningKeys")
			}
			urlSigningKeyList[urlSigningKeyIndex] = urlSigningKey
		}
		endpoint.UrlSigningKeys = urlSigningKeyList
	} else {
		endpoint.UrlSigningKeys = nil
	}

	// WebApplicationFirewallPolicyLink
	if source.WebApplicationFirewallPolicyLink != nil {
		var webApplicationFirewallPolicyLink EndpointProperties_WebApplicationFirewallPolicyLink
		err := webApplicationFirewallPolicyLink.AssignProperties_From_EndpointProperties_WebApplicationFirewallPolicyLink(source.WebApplicationFirewallPolicyLink)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_EndpointProperties_WebApplicationFirewallPolicyLink() to populate field WebApplicationFirewallPolicyLink")
		}
		endpoint.WebApplicationFirewallPolicyLink = &webApplicationFirewallPolicyLink
	} else {
		endpoint.WebApplicationFirewallPolicyLink = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ProfilesEndpoint_Spec populates the provided destination ProfilesEndpoint_Spec from our ProfilesEndpoint_Spec
func (endpoint *ProfilesEndpoint_Spec) AssignProperties_To_ProfilesEndpoint_Spec(destination *storage.ProfilesEndpoint_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = endpoint.AzureName

	// ContentTypesToCompress
	destination.ContentTypesToCompress = genruntime.CloneSliceOfString(endpoint.ContentTypesToCompress)

	// DefaultOriginGroup
	if endpoint.DefaultOriginGroup != nil {
		var defaultOriginGroup storage.ResourceReference
		err := endpoint.DefaultOriginGroup.AssignProperties_To_ResourceReference(&defaultOriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceReference() to populate field DefaultOriginGroup")
		}
		destination.DefaultOriginGroup = &defaultOriginGroup
	} else {
		destination.DefaultOriginGroup = nil
	}

	// DeliveryPolicy
	if endpoint.DeliveryPolicy != nil {
		var deliveryPolicy storage.EndpointProperties_DeliveryPolicy
		err := endpoint.DeliveryPolicy.AssignProperties_To_EndpointProperties_DeliveryPolicy(&deliveryPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_EndpointProperties_DeliveryPolicy() to populate field DeliveryPolicy")
		}
		destination.DeliveryPolicy = &deliveryPolicy
	} else {
		destination.DeliveryPolicy = nil
	}

	// GeoFilters
	if endpoint.GeoFilters != nil {
		geoFilterList := make([]storage.GeoFilter, len(endpoint.GeoFilters))
		for geoFilterIndex, geoFilterItem := range endpoint.GeoFilters {
			// Shadow the loop variable to avoid aliasing
			geoFilterItem := geoFilterItem
			var geoFilter storage.GeoFilter
			err := geoFilterItem.AssignProperties_To_GeoFilter(&geoFilter)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_GeoFilter() to populate field GeoFilters")
			}
			geoFilterList[geoFilterIndex] = geoFilter
		}
		destination.GeoFilters = geoFilterList
	} else {
		destination.GeoFilters = nil
	}

	// IsCompressionEnabled
	if endpoint.IsCompressionEnabled != nil {
		isCompressionEnabled := *endpoint.IsCompressionEnabled
		destination.IsCompressionEnabled = &isCompressionEnabled
	} else {
		destination.IsCompressionEnabled = nil
	}

	// IsHttpAllowed
	if endpoint.IsHttpAllowed != nil {
		isHttpAllowed := *endpoint.IsHttpAllowed
		destination.IsHttpAllowed = &isHttpAllowed
	} else {
		destination.IsHttpAllowed = nil
	}

	// IsHttpsAllowed
	if endpoint.IsHttpsAllowed != nil {
		isHttpsAllowed := *endpoint.IsHttpsAllowed
		destination.IsHttpsAllowed = &isHttpsAllowed
	} else {
		destination.IsHttpsAllowed = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(endpoint.Location)

	// OperatorSpec
	if endpoint.OperatorSpec != nil {
		var operatorSpec storage.ProfilesEndpointOperatorSpec
		err := endpoint.OperatorSpec.AssignProperties_To_ProfilesEndpointOperatorSpec(&operatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ProfilesEndpointOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OptimizationType
	if endpoint.OptimizationType != nil {
		optimizationType := string(*endpoint.OptimizationType)
		destination.OptimizationType = &optimizationType
	} else {
		destination.OptimizationType = nil
	}

	// OriginGroups
	if endpoint.OriginGroups != nil {
		originGroupList := make([]storage.DeepCreatedOriginGroup, len(endpoint.OriginGroups))
		for originGroupIndex, originGroupItem := range endpoint.OriginGroups {
			// Shadow the loop variable to avoid aliasing
			originGroupItem := originGroupItem
			var originGroup storage.DeepCreatedOriginGroup
			err := originGroupItem.AssignProperties_To_DeepCreatedOriginGroup(&originGroup)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DeepCreatedOriginGroup() to populate field OriginGroups")
			}
			originGroupList[originGroupIndex] = originGroup
		}
		destination.OriginGroups = originGroupList
	} else {
		destination.OriginGroups = nil
	}

	// OriginHostHeader
	destination.OriginHostHeader = genruntime.ClonePointerToString(endpoint.OriginHostHeader)

	// OriginPath
	destination.OriginPath = genruntime.ClonePointerToString(endpoint.OriginPath)

	// OriginalVersion
	destination.OriginalVersion = endpoint.OriginalVersion()

	// Origins
	if endpoint.Origins != nil {
		originList := make([]storage.DeepCreatedOrigin, len(endpoint.Origins))
		for originIndex, originItem := range endpoint.Origins {
			// Shadow the loop variable to avoid aliasing
			originItem := originItem
			var origin storage.DeepCreatedOrigin
			err := originItem.AssignProperties_To_DeepCreatedOrigin(&origin)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DeepCreatedOrigin() to populate field Origins")
			}
			originList[originIndex] = origin
		}
		destination.Origins = originList
	} else {
		destination.Origins = nil
	}

	// Owner
	if endpoint.Owner != nil {
		owner := endpoint.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// ProbePath
	destination.ProbePath = genruntime.ClonePointerToString(endpoint.ProbePath)

	// QueryStringCachingBehavior
	if endpoint.QueryStringCachingBehavior != nil {
		queryStringCachingBehavior := string(*endpoint.QueryStringCachingBehavior)
		destination.QueryStringCachingBehavior = &queryStringCachingBehavior
	} else {
		destination.QueryStringCachingBehavior = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(endpoint.Tags)

	// UrlSigningKeys
	if endpoint.UrlSigningKeys != nil {
		urlSigningKeyList := make([]storage.UrlSigningKey, len(endpoint.UrlSigningKeys))
		for urlSigningKeyIndex, urlSigningKeyItem := range endpoint.UrlSigningKeys {
			// Shadow the loop variable to avoid aliasing
			urlSigningKeyItem := urlSigningKeyItem
			var urlSigningKey storage.UrlSigningKey
			err := urlSigningKeyItem.AssignProperties_To_UrlSigningKey(&urlSigningKey)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_UrlSigningKey() to populate field UrlSigningKeys")
			}
			urlSigningKeyList[urlSigningKeyIndex] = urlSigningKey
		}
		destination.UrlSigningKeys = urlSigningKeyList
	} else {
		destination.UrlSigningKeys = nil
	}

	// WebApplicationFirewallPolicyLink
	if endpoint.WebApplicationFirewallPolicyLink != nil {
		var webApplicationFirewallPolicyLink storage.EndpointProperties_WebApplicationFirewallPolicyLink
		err := endpoint.WebApplicationFirewallPolicyLink.AssignProperties_To_EndpointProperties_WebApplicationFirewallPolicyLink(&webApplicationFirewallPolicyLink)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_EndpointProperties_WebApplicationFirewallPolicyLink() to populate field WebApplicationFirewallPolicyLink")
		}
		destination.WebApplicationFirewallPolicyLink = &webApplicationFirewallPolicyLink
	} else {
		destination.WebApplicationFirewallPolicyLink = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ProfilesEndpoint_STATUS populates our ProfilesEndpoint_Spec from the provided source ProfilesEndpoint_STATUS
func (endpoint *ProfilesEndpoint_Spec) Initialize_From_ProfilesEndpoint_STATUS(source *ProfilesEndpoint_STATUS) error {

	// ContentTypesToCompress
	endpoint.ContentTypesToCompress = genruntime.CloneSliceOfString(source.ContentTypesToCompress)

	// DefaultOriginGroup
	if source.DefaultOriginGroup != nil {
		var defaultOriginGroup ResourceReference
		err := defaultOriginGroup.Initialize_From_ResourceReference_STATUS(source.DefaultOriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ResourceReference_STATUS() to populate field DefaultOriginGroup")
		}
		endpoint.DefaultOriginGroup = &defaultOriginGroup
	} else {
		endpoint.DefaultOriginGroup = nil
	}

	// DeliveryPolicy
	if source.DeliveryPolicy != nil {
		var deliveryPolicy EndpointProperties_DeliveryPolicy
		err := deliveryPolicy.Initialize_From_EndpointProperties_DeliveryPolicy_STATUS(source.DeliveryPolicy)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_EndpointProperties_DeliveryPolicy_STATUS() to populate field DeliveryPolicy")
		}
		endpoint.DeliveryPolicy = &deliveryPolicy
	} else {
		endpoint.DeliveryPolicy = nil
	}

	// GeoFilters
	if source.GeoFilters != nil {
		geoFilterList := make([]GeoFilter, len(source.GeoFilters))
		for geoFilterIndex, geoFilterItem := range source.GeoFilters {
			// Shadow the loop variable to avoid aliasing
			geoFilterItem := geoFilterItem
			var geoFilter GeoFilter
			err := geoFilter.Initialize_From_GeoFilter_STATUS(&geoFilterItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_GeoFilter_STATUS() to populate field GeoFilters")
			}
			geoFilterList[geoFilterIndex] = geoFilter
		}
		endpoint.GeoFilters = geoFilterList
	} else {
		endpoint.GeoFilters = nil
	}

	// IsCompressionEnabled
	if source.IsCompressionEnabled != nil {
		isCompressionEnabled := *source.IsCompressionEnabled
		endpoint.IsCompressionEnabled = &isCompressionEnabled
	} else {
		endpoint.IsCompressionEnabled = nil
	}

	// IsHttpAllowed
	if source.IsHttpAllowed != nil {
		isHttpAllowed := *source.IsHttpAllowed
		endpoint.IsHttpAllowed = &isHttpAllowed
	} else {
		endpoint.IsHttpAllowed = nil
	}

	// IsHttpsAllowed
	if source.IsHttpsAllowed != nil {
		isHttpsAllowed := *source.IsHttpsAllowed
		endpoint.IsHttpsAllowed = &isHttpsAllowed
	} else {
		endpoint.IsHttpsAllowed = nil
	}

	// Location
	endpoint.Location = genruntime.ClonePointerToString(source.Location)

	// OptimizationType
	if source.OptimizationType != nil {
		optimizationType := genruntime.ToEnum(string(*source.OptimizationType), optimizationType_Values)
		endpoint.OptimizationType = &optimizationType
	} else {
		endpoint.OptimizationType = nil
	}

	// OriginGroups
	if source.OriginGroups != nil {
		originGroupList := make([]DeepCreatedOriginGroup, len(source.OriginGroups))
		for originGroupIndex, originGroupItem := range source.OriginGroups {
			// Shadow the loop variable to avoid aliasing
			originGroupItem := originGroupItem
			var originGroup DeepCreatedOriginGroup
			err := originGroup.Initialize_From_DeepCreatedOriginGroup_STATUS(&originGroupItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_DeepCreatedOriginGroup_STATUS() to populate field OriginGroups")
			}
			originGroupList[originGroupIndex] = originGroup
		}
		endpoint.OriginGroups = originGroupList
	} else {
		endpoint.OriginGroups = nil
	}

	// OriginHostHeader
	endpoint.OriginHostHeader = genruntime.ClonePointerToString(source.OriginHostHeader)

	// OriginPath
	endpoint.OriginPath = genruntime.ClonePointerToString(source.OriginPath)

	// Origins
	if source.Origins != nil {
		originList := make([]DeepCreatedOrigin, len(source.Origins))
		for originIndex, originItem := range source.Origins {
			// Shadow the loop variable to avoid aliasing
			originItem := originItem
			var origin DeepCreatedOrigin
			err := origin.Initialize_From_DeepCreatedOrigin_STATUS(&originItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_DeepCreatedOrigin_STATUS() to populate field Origins")
			}
			originList[originIndex] = origin
		}
		endpoint.Origins = originList
	} else {
		endpoint.Origins = nil
	}

	// ProbePath
	endpoint.ProbePath = genruntime.ClonePointerToString(source.ProbePath)

	// QueryStringCachingBehavior
	if source.QueryStringCachingBehavior != nil {
		queryStringCachingBehavior := genruntime.ToEnum(string(*source.QueryStringCachingBehavior), queryStringCachingBehavior_Values)
		endpoint.QueryStringCachingBehavior = &queryStringCachingBehavior
	} else {
		endpoint.QueryStringCachingBehavior = nil
	}

	// Tags
	endpoint.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// UrlSigningKeys
	if source.UrlSigningKeys != nil {
		urlSigningKeyList := make([]UrlSigningKey, len(source.UrlSigningKeys))
		for urlSigningKeyIndex, urlSigningKeyItem := range source.UrlSigningKeys {
			// Shadow the loop variable to avoid aliasing
			urlSigningKeyItem := urlSigningKeyItem
			var urlSigningKey UrlSigningKey
			err := urlSigningKey.Initialize_From_UrlSigningKey_STATUS(&urlSigningKeyItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_UrlSigningKey_STATUS() to populate field UrlSigningKeys")
			}
			urlSigningKeyList[urlSigningKeyIndex] = urlSigningKey
		}
		endpoint.UrlSigningKeys = urlSigningKeyList
	} else {
		endpoint.UrlSigningKeys = nil
	}

	// WebApplicationFirewallPolicyLink
	if source.WebApplicationFirewallPolicyLink != nil {
		var webApplicationFirewallPolicyLink EndpointProperties_WebApplicationFirewallPolicyLink
		err := webApplicationFirewallPolicyLink.Initialize_From_EndpointProperties_WebApplicationFirewallPolicyLink_STATUS(source.WebApplicationFirewallPolicyLink)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_EndpointProperties_WebApplicationFirewallPolicyLink_STATUS() to populate field WebApplicationFirewallPolicyLink")
		}
		endpoint.WebApplicationFirewallPolicyLink = &webApplicationFirewallPolicyLink
	} else {
		endpoint.WebApplicationFirewallPolicyLink = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (endpoint *ProfilesEndpoint_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (endpoint *ProfilesEndpoint_Spec) SetAzureName(azureName string) { endpoint.AzureName = azureName }

type ProfilesEndpoint_STATUS struct {
	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// ContentTypesToCompress: List of content types on which compression applies. The value should be a valid MIME type.
	ContentTypesToCompress []string `json:"contentTypesToCompress,omitempty"`

	// CustomDomains: The custom domains under the endpoint.
	CustomDomains []DeepCreatedCustomDomain_STATUS `json:"customDomains,omitempty"`

	// DefaultOriginGroup: A reference to the origin group.
	DefaultOriginGroup *ResourceReference_STATUS `json:"defaultOriginGroup,omitempty"`

	// DeliveryPolicy: A policy that specifies the delivery rules to be used for an endpoint.
	DeliveryPolicy *EndpointProperties_DeliveryPolicy_STATUS `json:"deliveryPolicy,omitempty"`

	// GeoFilters: List of rules defining the user's geo access within a CDN endpoint. Each geo filter defines an access rule
	// to a specified path or content, e.g. block APAC for path /pictures/
	GeoFilters []GeoFilter_STATUS `json:"geoFilters,omitempty"`

	// HostName: The host name of the endpoint structured as {endpointName}.{DNSZone}, e.g. contoso.azureedge.net
	HostName *string `json:"hostName,omitempty"`

	// Id: Resource ID.
	Id *string `json:"id,omitempty"`

	// IsCompressionEnabled: Indicates whether content compression is enabled on CDN. Default value is false. If compression is
	// enabled, content will be served as compressed if user requests for a compressed version. Content won't be compressed on
	// CDN when requested content is smaller than 1 byte or larger than 1 MB.
	IsCompressionEnabled *bool `json:"isCompressionEnabled,omitempty"`

	// IsHttpAllowed: Indicates whether HTTP traffic is allowed on the endpoint. Default value is true. At least one protocol
	// (HTTP or HTTPS) must be allowed.
	IsHttpAllowed *bool `json:"isHttpAllowed,omitempty"`

	// IsHttpsAllowed: Indicates whether HTTPS traffic is allowed on the endpoint. Default value is true. At least one protocol
	// (HTTP or HTTPS) must be allowed.
	IsHttpsAllowed *bool `json:"isHttpsAllowed,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// Name: Resource name.
	Name *string `json:"name,omitempty"`

	// OptimizationType: Specifies what scenario the customer wants this CDN endpoint to optimize for, e.g. Download, Media
	// services. With this information, CDN can apply scenario driven optimization.
	OptimizationType *OptimizationType_STATUS `json:"optimizationType,omitempty"`

	// OriginGroups: The origin groups comprising of origins that are used for load balancing the traffic based on availability.
	OriginGroups []DeepCreatedOriginGroup_STATUS `json:"originGroups,omitempty"`

	// OriginHostHeader: The host header value sent to the origin with each request. This property at Endpoint is only allowed
	// when endpoint uses single origin and can be overridden by the same property specified at origin.If you leave this blank,
	// the request hostname determines this value. Azure CDN origins, such as Web Apps, Blob Storage, and Cloud Services
	// require this host header value to match the origin hostname by default.
	OriginHostHeader *string `json:"originHostHeader,omitempty"`

	// OriginPath: A directory path on the origin that CDN can use to retrieve content from, e.g.
	// contoso.cloudapp.net/originpath.
	OriginPath *string `json:"originPath,omitempty"`

	// Origins: The source of the content being delivered via CDN.
	Origins []DeepCreatedOrigin_STATUS `json:"origins,omitempty"`

	// ProbePath: Path to a file hosted on the origin which helps accelerate delivery of the dynamic content and calculate the
	// most optimal routes for the CDN. This is relative to the origin path. This property is only relevant when using a single
	// origin.
	ProbePath *string `json:"probePath,omitempty"`

	// ProvisioningState: Provisioning status of the endpoint.
	ProvisioningState *EndpointProperties_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// QueryStringCachingBehavior: Defines how CDN caches requests that include query strings. You can ignore any query strings
	// when caching, bypass caching to prevent requests that contain query strings from being cached, or cache every request
	// with a unique URL.
	QueryStringCachingBehavior *QueryStringCachingBehavior_STATUS `json:"queryStringCachingBehavior,omitempty"`

	// ResourceState: Resource status of the endpoint.
	ResourceState *EndpointProperties_ResourceState_STATUS `json:"resourceState,omitempty"`

	// SystemData: Read only system data
	SystemData *SystemData_STATUS `json:"systemData,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: Resource type.
	Type *string `json:"type,omitempty"`

	// UrlSigningKeys: List of keys used to validate the signed URL hashes.
	UrlSigningKeys []UrlSigningKey_STATUS `json:"urlSigningKeys,omitempty"`

	// WebApplicationFirewallPolicyLink: Defines the Web Application Firewall policy for the endpoint (if applicable)
	WebApplicationFirewallPolicyLink *EndpointProperties_WebApplicationFirewallPolicyLink_STATUS `json:"webApplicationFirewallPolicyLink,omitempty"`
}

var _ genruntime.ConvertibleStatus = &ProfilesEndpoint_STATUS{}

// ConvertStatusFrom populates our ProfilesEndpoint_STATUS from the provided source
func (endpoint *ProfilesEndpoint_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.ProfilesEndpoint_STATUS)
	if ok {
		// Populate our instance from source
		return endpoint.AssignProperties_From_ProfilesEndpoint_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.ProfilesEndpoint_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = endpoint.AssignProperties_From_ProfilesEndpoint_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our ProfilesEndpoint_STATUS
func (endpoint *ProfilesEndpoint_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.ProfilesEndpoint_STATUS)
	if ok {
		// Populate destination from our instance
		return endpoint.AssignProperties_To_ProfilesEndpoint_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.ProfilesEndpoint_STATUS{}
	err := endpoint.AssignProperties_To_ProfilesEndpoint_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &ProfilesEndpoint_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (endpoint *ProfilesEndpoint_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ProfilesEndpoint_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (endpoint *ProfilesEndpoint_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ProfilesEndpoint_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ProfilesEndpoint_STATUS, got %T", armInput)
	}

	// no assignment for property "Conditions"

	// Set property "ContentTypesToCompress":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ContentTypesToCompress {
			endpoint.ContentTypesToCompress = append(endpoint.ContentTypesToCompress, item)
		}
	}

	// Set property "CustomDomains":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.CustomDomains {
			var item1 DeepCreatedCustomDomain_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.CustomDomains = append(endpoint.CustomDomains, item1)
		}
	}

	// Set property "DefaultOriginGroup":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DefaultOriginGroup != nil {
			var defaultOriginGroup1 ResourceReference_STATUS
			err := defaultOriginGroup1.PopulateFromARM(owner, *typedInput.Properties.DefaultOriginGroup)
			if err != nil {
				return err
			}
			defaultOriginGroup := defaultOriginGroup1
			endpoint.DefaultOriginGroup = &defaultOriginGroup
		}
	}

	// Set property "DeliveryPolicy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DeliveryPolicy != nil {
			var deliveryPolicy1 EndpointProperties_DeliveryPolicy_STATUS
			err := deliveryPolicy1.PopulateFromARM(owner, *typedInput.Properties.DeliveryPolicy)
			if err != nil {
				return err
			}
			deliveryPolicy := deliveryPolicy1
			endpoint.DeliveryPolicy = &deliveryPolicy
		}
	}

	// Set property "GeoFilters":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.GeoFilters {
			var item1 GeoFilter_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.GeoFilters = append(endpoint.GeoFilters, item1)
		}
	}

	// Set property "HostName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostName != nil {
			hostName := *typedInput.Properties.HostName
			endpoint.HostName = &hostName
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		endpoint.Id = &id
	}

	// Set property "IsCompressionEnabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IsCompressionEnabled != nil {
			isCompressionEnabled := *typedInput.Properties.IsCompressionEnabled
			endpoint.IsCompressionEnabled = &isCompressionEnabled
		}
	}

	// Set property "IsHttpAllowed":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IsHttpAllowed != nil {
			isHttpAllowed := *typedInput.Properties.IsHttpAllowed
			endpoint.IsHttpAllowed = &isHttpAllowed
		}
	}

	// Set property "IsHttpsAllowed":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IsHttpsAllowed != nil {
			isHttpsAllowed := *typedInput.Properties.IsHttpsAllowed
			endpoint.IsHttpsAllowed = &isHttpsAllowed
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		endpoint.Location = &location
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		endpoint.Name = &name
	}

	// Set property "OptimizationType":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OptimizationType != nil {
			var temp string
			temp = string(*typedInput.Properties.OptimizationType)
			optimizationType := OptimizationType_STATUS(temp)
			endpoint.OptimizationType = &optimizationType
		}
	}

	// Set property "OriginGroups":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.OriginGroups {
			var item1 DeepCreatedOriginGroup_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.OriginGroups = append(endpoint.OriginGroups, item1)
		}
	}

	// Set property "OriginHostHeader":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OriginHostHeader != nil {
			originHostHeader := *typedInput.Properties.OriginHostHeader
			endpoint.OriginHostHeader = &originHostHeader
		}
	}

	// Set property "OriginPath":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OriginPath != nil {
			originPath := *typedInput.Properties.OriginPath
			endpoint.OriginPath = &originPath
		}
	}

	// Set property "Origins":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Origins {
			var item1 DeepCreatedOrigin_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.Origins = append(endpoint.Origins, item1)
		}
	}

	// Set property "ProbePath":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProbePath != nil {
			probePath := *typedInput.Properties.ProbePath
			endpoint.ProbePath = &probePath
		}
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			var temp string
			temp = string(*typedInput.Properties.ProvisioningState)
			provisioningState := EndpointProperties_ProvisioningState_STATUS(temp)
			endpoint.ProvisioningState = &provisioningState
		}
	}

	// Set property "QueryStringCachingBehavior":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.QueryStringCachingBehavior != nil {
			var temp string
			temp = string(*typedInput.Properties.QueryStringCachingBehavior)
			queryStringCachingBehavior := QueryStringCachingBehavior_STATUS(temp)
			endpoint.QueryStringCachingBehavior = &queryStringCachingBehavior
		}
	}

	// Set property "ResourceState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ResourceState != nil {
			var temp string
			temp = string(*typedInput.Properties.ResourceState)
			resourceState := EndpointProperties_ResourceState_STATUS(temp)
			endpoint.ResourceState = &resourceState
		}
	}

	// Set property "SystemData":
	if typedInput.SystemData != nil {
		var systemData1 SystemData_STATUS
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		endpoint.SystemData = &systemData
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		endpoint.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			endpoint.Tags[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		endpoint.Type = &typeVar
	}

	// Set property "UrlSigningKeys":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.UrlSigningKeys {
			var item1 UrlSigningKey_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.UrlSigningKeys = append(endpoint.UrlSigningKeys, item1)
		}
	}

	// Set property "WebApplicationFirewallPolicyLink":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.WebApplicationFirewallPolicyLink != nil {
			var webApplicationFirewallPolicyLink1 EndpointProperties_WebApplicationFirewallPolicyLink_STATUS
			err := webApplicationFirewallPolicyLink1.PopulateFromARM(owner, *typedInput.Properties.WebApplicationFirewallPolicyLink)
			if err != nil {
				return err
			}
			webApplicationFirewallPolicyLink := webApplicationFirewallPolicyLink1
			endpoint.WebApplicationFirewallPolicyLink = &webApplicationFirewallPolicyLink
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ProfilesEndpoint_STATUS populates our ProfilesEndpoint_STATUS from the provided source ProfilesEndpoint_STATUS
func (endpoint *ProfilesEndpoint_STATUS) AssignProperties_From_ProfilesEndpoint_STATUS(source *storage.ProfilesEndpoint_STATUS) error {

	// Conditions
	endpoint.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// ContentTypesToCompress
	endpoint.ContentTypesToCompress = genruntime.CloneSliceOfString(source.ContentTypesToCompress)

	// CustomDomains
	if source.CustomDomains != nil {
		customDomainList := make([]DeepCreatedCustomDomain_STATUS, len(source.CustomDomains))
		for customDomainIndex, customDomainItem := range source.CustomDomains {
			// Shadow the loop variable to avoid aliasing
			customDomainItem := customDomainItem
			var customDomain DeepCreatedCustomDomain_STATUS
			err := customDomain.AssignProperties_From_DeepCreatedCustomDomain_STATUS(&customDomainItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DeepCreatedCustomDomain_STATUS() to populate field CustomDomains")
			}
			customDomainList[customDomainIndex] = customDomain
		}
		endpoint.CustomDomains = customDomainList
	} else {
		endpoint.CustomDomains = nil
	}

	// DefaultOriginGroup
	if source.DefaultOriginGroup != nil {
		var defaultOriginGroup ResourceReference_STATUS
		err := defaultOriginGroup.AssignProperties_From_ResourceReference_STATUS(source.DefaultOriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceReference_STATUS() to populate field DefaultOriginGroup")
		}
		endpoint.DefaultOriginGroup = &defaultOriginGroup
	} else {
		endpoint.DefaultOriginGroup = nil
	}

	// DeliveryPolicy
	if source.DeliveryPolicy != nil {
		var deliveryPolicy EndpointProperties_DeliveryPolicy_STATUS
		err := deliveryPolicy.AssignProperties_From_EndpointProperties_DeliveryPolicy_STATUS(source.DeliveryPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_EndpointProperties_DeliveryPolicy_STATUS() to populate field DeliveryPolicy")
		}
		endpoint.DeliveryPolicy = &deliveryPolicy
	} else {
		endpoint.DeliveryPolicy = nil
	}

	// GeoFilters
	if source.GeoFilters != nil {
		geoFilterList := make([]GeoFilter_STATUS, len(source.GeoFilters))
		for geoFilterIndex, geoFilterItem := range source.GeoFilters {
			// Shadow the loop variable to avoid aliasing
			geoFilterItem := geoFilterItem
			var geoFilter GeoFilter_STATUS
			err := geoFilter.AssignProperties_From_GeoFilter_STATUS(&geoFilterItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_GeoFilter_STATUS() to populate field GeoFilters")
			}
			geoFilterList[geoFilterIndex] = geoFilter
		}
		endpoint.GeoFilters = geoFilterList
	} else {
		endpoint.GeoFilters = nil
	}

	// HostName
	endpoint.HostName = genruntime.ClonePointerToString(source.HostName)

	// Id
	endpoint.Id = genruntime.ClonePointerToString(source.Id)

	// IsCompressionEnabled
	if source.IsCompressionEnabled != nil {
		isCompressionEnabled := *source.IsCompressionEnabled
		endpoint.IsCompressionEnabled = &isCompressionEnabled
	} else {
		endpoint.IsCompressionEnabled = nil
	}

	// IsHttpAllowed
	if source.IsHttpAllowed != nil {
		isHttpAllowed := *source.IsHttpAllowed
		endpoint.IsHttpAllowed = &isHttpAllowed
	} else {
		endpoint.IsHttpAllowed = nil
	}

	// IsHttpsAllowed
	if source.IsHttpsAllowed != nil {
		isHttpsAllowed := *source.IsHttpsAllowed
		endpoint.IsHttpsAllowed = &isHttpsAllowed
	} else {
		endpoint.IsHttpsAllowed = nil
	}

	// Location
	endpoint.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	endpoint.Name = genruntime.ClonePointerToString(source.Name)

	// OptimizationType
	if source.OptimizationType != nil {
		optimizationType := *source.OptimizationType
		optimizationTypeTemp := genruntime.ToEnum(optimizationType, optimizationType_STATUS_Values)
		endpoint.OptimizationType = &optimizationTypeTemp
	} else {
		endpoint.OptimizationType = nil
	}

	// OriginGroups
	if source.OriginGroups != nil {
		originGroupList := make([]DeepCreatedOriginGroup_STATUS, len(source.OriginGroups))
		for originGroupIndex, originGroupItem := range source.OriginGroups {
			// Shadow the loop variable to avoid aliasing
			originGroupItem := originGroupItem
			var originGroup DeepCreatedOriginGroup_STATUS
			err := originGroup.AssignProperties_From_DeepCreatedOriginGroup_STATUS(&originGroupItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DeepCreatedOriginGroup_STATUS() to populate field OriginGroups")
			}
			originGroupList[originGroupIndex] = originGroup
		}
		endpoint.OriginGroups = originGroupList
	} else {
		endpoint.OriginGroups = nil
	}

	// OriginHostHeader
	endpoint.OriginHostHeader = genruntime.ClonePointerToString(source.OriginHostHeader)

	// OriginPath
	endpoint.OriginPath = genruntime.ClonePointerToString(source.OriginPath)

	// Origins
	if source.Origins != nil {
		originList := make([]DeepCreatedOrigin_STATUS, len(source.Origins))
		for originIndex, originItem := range source.Origins {
			// Shadow the loop variable to avoid aliasing
			originItem := originItem
			var origin DeepCreatedOrigin_STATUS
			err := origin.AssignProperties_From_DeepCreatedOrigin_STATUS(&originItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DeepCreatedOrigin_STATUS() to populate field Origins")
			}
			originList[originIndex] = origin
		}
		endpoint.Origins = originList
	} else {
		endpoint.Origins = nil
	}

	// ProbePath
	endpoint.ProbePath = genruntime.ClonePointerToString(source.ProbePath)

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, endpointProperties_ProvisioningState_STATUS_Values)
		endpoint.ProvisioningState = &provisioningStateTemp
	} else {
		endpoint.ProvisioningState = nil
	}

	// QueryStringCachingBehavior
	if source.QueryStringCachingBehavior != nil {
		queryStringCachingBehavior := *source.QueryStringCachingBehavior
		queryStringCachingBehaviorTemp := genruntime.ToEnum(queryStringCachingBehavior, queryStringCachingBehavior_STATUS_Values)
		endpoint.QueryStringCachingBehavior = &queryStringCachingBehaviorTemp
	} else {
		endpoint.QueryStringCachingBehavior = nil
	}

	// ResourceState
	if source.ResourceState != nil {
		resourceState := *source.ResourceState
		resourceStateTemp := genruntime.ToEnum(resourceState, endpointProperties_ResourceState_STATUS_Values)
		endpoint.ResourceState = &resourceStateTemp
	} else {
		endpoint.ResourceState = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		endpoint.SystemData = &systemDatum
	} else {
		endpoint.SystemData = nil
	}

	// Tags
	endpoint.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	endpoint.Type = genruntime.ClonePointerToString(source.Type)

	// UrlSigningKeys
	if source.UrlSigningKeys != nil {
		urlSigningKeyList := make([]UrlSigningKey_STATUS, len(source.UrlSigningKeys))
		for urlSigningKeyIndex, urlSigningKeyItem := range source.UrlSigningKeys {
			// Shadow the loop variable to avoid aliasing
			urlSigningKeyItem := urlSigningKeyItem
			var urlSigningKey UrlSigningKey_STATUS
			err := urlSigningKey.AssignProperties_From_UrlSigningKey_STATUS(&urlSigningKeyItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_UrlSigningKey_STATUS() to populate field UrlSigningKeys")
			}
			urlSigningKeyList[urlSigningKeyIndex] = urlSigningKey
		}
		endpoint.UrlSigningKeys = urlSigningKeyList
	} else {
		endpoint.UrlSigningKeys = nil
	}

	// WebApplicationFirewallPolicyLink
	if source.WebApplicationFirewallPolicyLink != nil {
		var webApplicationFirewallPolicyLink EndpointProperties_WebApplicationFirewallPolicyLink_STATUS
		err := webApplicationFirewallPolicyLink.AssignProperties_From_EndpointProperties_WebApplicationFirewallPolicyLink_STATUS(source.WebApplicationFirewallPolicyLink)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_EndpointProperties_WebApplicationFirewallPolicyLink_STATUS() to populate field WebApplicationFirewallPolicyLink")
		}
		endpoint.WebApplicationFirewallPolicyLink = &webApplicationFirewallPolicyLink
	} else {
		endpoint.WebApplicationFirewallPolicyLink = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ProfilesEndpoint_STATUS populates the provided destination ProfilesEndpoint_STATUS from our ProfilesEndpoint_STATUS
func (endpoint *ProfilesEndpoint_STATUS) AssignProperties_To_ProfilesEndpoint_STATUS(destination *storage.ProfilesEndpoint_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(endpoint.Conditions)

	// ContentTypesToCompress
	destination.ContentTypesToCompress = genruntime.CloneSliceOfString(endpoint.ContentTypesToCompress)

	// CustomDomains
	if endpoint.CustomDomains != nil {
		customDomainList := make([]storage.DeepCreatedCustomDomain_STATUS, len(endpoint.CustomDomains))
		for customDomainIndex, customDomainItem := range endpoint.CustomDomains {
			// Shadow the loop variable to avoid aliasing
			customDomainItem := customDomainItem
			var customDomain storage.DeepCreatedCustomDomain_STATUS
			err := customDomainItem.AssignProperties_To_DeepCreatedCustomDomain_STATUS(&customDomain)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DeepCreatedCustomDomain_STATUS() to populate field CustomDomains")
			}
			customDomainList[customDomainIndex] = customDomain
		}
		destination.CustomDomains = customDomainList
	} else {
		destination.CustomDomains = nil
	}

	// DefaultOriginGroup
	if endpoint.DefaultOriginGroup != nil {
		var defaultOriginGroup storage.ResourceReference_STATUS
		err := endpoint.DefaultOriginGroup.AssignProperties_To_ResourceReference_STATUS(&defaultOriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceReference_STATUS() to populate field DefaultOriginGroup")
		}
		destination.DefaultOriginGroup = &defaultOriginGroup
	} else {
		destination.DefaultOriginGroup = nil
	}

	// DeliveryPolicy
	if endpoint.DeliveryPolicy != nil {
		var deliveryPolicy storage.EndpointProperties_DeliveryPolicy_STATUS
		err := endpoint.DeliveryPolicy.AssignProperties_To_EndpointProperties_DeliveryPolicy_STATUS(&deliveryPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_EndpointProperties_DeliveryPolicy_STATUS() to populate field DeliveryPolicy")
		}
		destination.DeliveryPolicy = &deliveryPolicy
	} else {
		destination.DeliveryPolicy = nil
	}

	// GeoFilters
	if endpoint.GeoFilters != nil {
		geoFilterList := make([]storage.GeoFilter_STATUS, len(endpoint.GeoFilters))
		for geoFilterIndex, geoFilterItem := range endpoint.GeoFilters {
			// Shadow the loop variable to avoid aliasing
			geoFilterItem := geoFilterItem
			var geoFilter storage.GeoFilter_STATUS
			err := geoFilterItem.AssignProperties_To_GeoFilter_STATUS(&geoFilter)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_GeoFilter_STATUS() to populate field GeoFilters")
			}
			geoFilterList[geoFilterIndex] = geoFilter
		}
		destination.GeoFilters = geoFilterList
	} else {
		destination.GeoFilters = nil
	}

	// HostName
	destination.HostName = genruntime.ClonePointerToString(endpoint.HostName)

	// Id
	destination.Id = genruntime.ClonePointerToString(endpoint.Id)

	// IsCompressionEnabled
	if endpoint.IsCompressionEnabled != nil {
		isCompressionEnabled := *endpoint.IsCompressionEnabled
		destination.IsCompressionEnabled = &isCompressionEnabled
	} else {
		destination.IsCompressionEnabled = nil
	}

	// IsHttpAllowed
	if endpoint.IsHttpAllowed != nil {
		isHttpAllowed := *endpoint.IsHttpAllowed
		destination.IsHttpAllowed = &isHttpAllowed
	} else {
		destination.IsHttpAllowed = nil
	}

	// IsHttpsAllowed
	if endpoint.IsHttpsAllowed != nil {
		isHttpsAllowed := *endpoint.IsHttpsAllowed
		destination.IsHttpsAllowed = &isHttpsAllowed
	} else {
		destination.IsHttpsAllowed = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(endpoint.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(endpoint.Name)

	// OptimizationType
	if endpoint.OptimizationType != nil {
		optimizationType := string(*endpoint.OptimizationType)
		destination.OptimizationType = &optimizationType
	} else {
		destination.OptimizationType = nil
	}

	// OriginGroups
	if endpoint.OriginGroups != nil {
		originGroupList := make([]storage.DeepCreatedOriginGroup_STATUS, len(endpoint.OriginGroups))
		for originGroupIndex, originGroupItem := range endpoint.OriginGroups {
			// Shadow the loop variable to avoid aliasing
			originGroupItem := originGroupItem
			var originGroup storage.DeepCreatedOriginGroup_STATUS
			err := originGroupItem.AssignProperties_To_DeepCreatedOriginGroup_STATUS(&originGroup)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DeepCreatedOriginGroup_STATUS() to populate field OriginGroups")
			}
			originGroupList[originGroupIndex] = originGroup
		}
		destination.OriginGroups = originGroupList
	} else {
		destination.OriginGroups = nil
	}

	// OriginHostHeader
	destination.OriginHostHeader = genruntime.ClonePointerToString(endpoint.OriginHostHeader)

	// OriginPath
	destination.OriginPath = genruntime.ClonePointerToString(endpoint.OriginPath)

	// Origins
	if endpoint.Origins != nil {
		originList := make([]storage.DeepCreatedOrigin_STATUS, len(endpoint.Origins))
		for originIndex, originItem := range endpoint.Origins {
			// Shadow the loop variable to avoid aliasing
			originItem := originItem
			var origin storage.DeepCreatedOrigin_STATUS
			err := originItem.AssignProperties_To_DeepCreatedOrigin_STATUS(&origin)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DeepCreatedOrigin_STATUS() to populate field Origins")
			}
			originList[originIndex] = origin
		}
		destination.Origins = originList
	} else {
		destination.Origins = nil
	}

	// ProbePath
	destination.ProbePath = genruntime.ClonePointerToString(endpoint.ProbePath)

	// ProvisioningState
	if endpoint.ProvisioningState != nil {
		provisioningState := string(*endpoint.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// QueryStringCachingBehavior
	if endpoint.QueryStringCachingBehavior != nil {
		queryStringCachingBehavior := string(*endpoint.QueryStringCachingBehavior)
		destination.QueryStringCachingBehavior = &queryStringCachingBehavior
	} else {
		destination.QueryStringCachingBehavior = nil
	}

	// ResourceState
	if endpoint.ResourceState != nil {
		resourceState := string(*endpoint.ResourceState)
		destination.ResourceState = &resourceState
	} else {
		destination.ResourceState = nil
	}

	// SystemData
	if endpoint.SystemData != nil {
		var systemDatum storage.SystemData_STATUS
		err := endpoint.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(endpoint.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(endpoint.Type)

	// UrlSigningKeys
	if endpoint.UrlSigningKeys != nil {
		urlSigningKeyList := make([]storage.UrlSigningKey_STATUS, len(endpoint.UrlSigningKeys))
		for urlSigningKeyIndex, urlSigningKeyItem := range endpoint.UrlSigningKeys {
			// Shadow the loop variable to avoid aliasing
			urlSigningKeyItem := urlSigningKeyItem
			var urlSigningKey storage.UrlSigningKey_STATUS
			err := urlSigningKeyItem.AssignProperties_To_UrlSigningKey_STATUS(&urlSigningKey)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_UrlSigningKey_STATUS() to populate field UrlSigningKeys")
			}
			urlSigningKeyList[urlSigningKeyIndex] = urlSigningKey
		}
		destination.UrlSigningKeys = urlSigningKeyList
	} else {
		destination.UrlSigningKeys = nil
	}

	// WebApplicationFirewallPolicyLink
	if endpoint.WebApplicationFirewallPolicyLink != nil {
		var webApplicationFirewallPolicyLink storage.EndpointProperties_WebApplicationFirewallPolicyLink_STATUS
		err := endpoint.WebApplicationFirewallPolicyLink.AssignProperties_To_EndpointProperties_WebApplicationFirewallPolicyLink_STATUS(&webApplicationFirewallPolicyLink)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_EndpointProperties_WebApplicationFirewallPolicyLink_STATUS() to populate field WebApplicationFirewallPolicyLink")
		}
		destination.WebApplicationFirewallPolicyLink = &webApplicationFirewallPolicyLink
	} else {
		destination.WebApplicationFirewallPolicyLink = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Custom domains created on the CDN endpoint.
type DeepCreatedCustomDomain_STATUS struct {
	// HostName: The host name of the custom domain. Must be a domain name.
	HostName *string `json:"hostName,omitempty"`

	// Name: Custom domain name.
	Name *string `json:"name,omitempty"`

	// ValidationData: Special validation or data may be required when delivering CDN to some regions due to local compliance
	// reasons. E.g. ICP license number of a custom domain is required to deliver content in China.
	ValidationData *string `json:"validationData,omitempty"`
}

var _ genruntime.FromARMConverter = &DeepCreatedCustomDomain_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (domain *DeepCreatedCustomDomain_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeepCreatedCustomDomain_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (domain *DeepCreatedCustomDomain_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeepCreatedCustomDomain_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeepCreatedCustomDomain_STATUS, got %T", armInput)
	}

	// Set property "HostName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostName != nil {
			hostName := *typedInput.Properties.HostName
			domain.HostName = &hostName
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		domain.Name = &name
	}

	// Set property "ValidationData":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ValidationData != nil {
			validationData := *typedInput.Properties.ValidationData
			domain.ValidationData = &validationData
		}
	}

	// No error
	return nil
}

// AssignProperties_From_DeepCreatedCustomDomain_STATUS populates our DeepCreatedCustomDomain_STATUS from the provided source DeepCreatedCustomDomain_STATUS
func (domain *DeepCreatedCustomDomain_STATUS) AssignProperties_From_DeepCreatedCustomDomain_STATUS(source *storage.DeepCreatedCustomDomain_STATUS) error {

	// HostName
	domain.HostName = genruntime.ClonePointerToString(source.HostName)

	// Name
	domain.Name = genruntime.ClonePointerToString(source.Name)

	// ValidationData
	domain.ValidationData = genruntime.ClonePointerToString(source.ValidationData)

	// No error
	return nil
}

// AssignProperties_To_DeepCreatedCustomDomain_STATUS populates the provided destination DeepCreatedCustomDomain_STATUS from our DeepCreatedCustomDomain_STATUS
func (domain *DeepCreatedCustomDomain_STATUS) AssignProperties_To_DeepCreatedCustomDomain_STATUS(destination *storage.DeepCreatedCustomDomain_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HostName
	destination.HostName = genruntime.ClonePointerToString(domain.HostName)

	// Name
	destination.Name = genruntime.ClonePointerToString(domain.Name)

	// ValidationData
	destination.ValidationData = genruntime.ClonePointerToString(domain.ValidationData)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The main origin of CDN content which is added when creating a CDN endpoint.
type DeepCreatedOrigin struct {
	// Enabled: Origin is enabled for load balancing or not. By default, origin is always enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// +kubebuilder:validation:Required
	// HostName: The address of the origin. It can be a domain name, IPv4 address, or IPv6 address. This should be unique
	// across all origins in an endpoint.
	HostName *string `json:"hostName,omitempty"`

	// +kubebuilder:validation:Maximum=65535
	// +kubebuilder:validation:Minimum=1
	// HttpPort: The value of the HTTP port. Must be between 1 and 65535.
	HttpPort *int `json:"httpPort,omitempty"`

	// +kubebuilder:validation:Maximum=65535
	// +kubebuilder:validation:Minimum=1
	// HttpsPort: The value of the HTTPS port. Must be between 1 and 65535.
	HttpsPort *int `json:"httpsPort,omitempty"`

	// +kubebuilder:validation:Required
	// Name: Origin name which must be unique within the endpoint.
	Name *string `json:"name,omitempty"`

	// OriginHostHeader: The host header value sent to the origin with each request. If you leave this blank, the request
	// hostname determines this value. Azure CDN origins, such as Web Apps, Blob Storage, and Cloud Services require this host
	// header value to match the origin hostname by default.
	OriginHostHeader *string `json:"originHostHeader,omitempty"`

	// +kubebuilder:validation:Maximum=5
	// +kubebuilder:validation:Minimum=1
	// Priority: Priority of origin in given origin group for load balancing. Higher priorities will not be used for load
	// balancing if any lower priority origin is healthy.Must be between 1 and 5.
	Priority *int `json:"priority,omitempty"`

	// PrivateLinkAlias: The Alias of the Private Link resource. Populating this optional field indicates that this origin is
	// 'Private'
	PrivateLinkAlias *string `json:"privateLinkAlias,omitempty"`

	// PrivateLinkApprovalMessage: A custom message to be included in the approval request to connect to the Private Link.
	PrivateLinkApprovalMessage *string `json:"privateLinkApprovalMessage,omitempty"`

	// PrivateLinkLocationReference: The location of the Private Link resource. Required only if 'privateLinkResourceId' is
	// populated
	PrivateLinkLocationReference *genruntime.ResourceReference `armReference:"PrivateLinkLocation" json:"privateLinkLocationReference,omitempty"`

	// PrivateLinkResourceReference: The Resource Id of the Private Link resource. Populating this optional field indicates
	// that this backend is 'Private'
	PrivateLinkResourceReference *genruntime.ResourceReference `armReference:"PrivateLinkResourceId" json:"privateLinkResourceReference,omitempty"`

	// +kubebuilder:validation:Maximum=1000
	// +kubebuilder:validation:Minimum=1
	// Weight: Weight of the origin in given origin group for load balancing. Must be between 1 and 1000
	Weight *int `json:"weight,omitempty"`
}

var _ genruntime.ARMTransformer = &DeepCreatedOrigin{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (origin *DeepCreatedOrigin) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if origin == nil {
		return nil, nil
	}
	result := &arm.DeepCreatedOrigin{}

	// Set property "Name":
	if origin.Name != nil {
		name := *origin.Name
		result.Name = &name
	}

	// Set property "Properties":
	if origin.Enabled != nil ||
		origin.HostName != nil ||
		origin.HttpPort != nil ||
		origin.HttpsPort != nil ||
		origin.OriginHostHeader != nil ||
		origin.Priority != nil ||
		origin.PrivateLinkAlias != nil ||
		origin.PrivateLinkApprovalMessage != nil ||
		origin.PrivateLinkLocationReference != nil ||
		origin.PrivateLinkResourceReference != nil ||
		origin.Weight != nil {
		result.Properties = &arm.DeepCreatedOriginProperties{}
	}
	if origin.Enabled != nil {
		enabled := *origin.Enabled
		result.Properties.Enabled = &enabled
	}
	if origin.HostName != nil {
		hostName := *origin.HostName
		result.Properties.HostName = &hostName
	}
	if origin.HttpPort != nil {
		httpPort := *origin.HttpPort
		result.Properties.HttpPort = &httpPort
	}
	if origin.HttpsPort != nil {
		httpsPort := *origin.HttpsPort
		result.Properties.HttpsPort = &httpsPort
	}
	if origin.OriginHostHeader != nil {
		originHostHeader := *origin.OriginHostHeader
		result.Properties.OriginHostHeader = &originHostHeader
	}
	if origin.Priority != nil {
		priority := *origin.Priority
		result.Properties.Priority = &priority
	}
	if origin.PrivateLinkAlias != nil {
		privateLinkAlias := *origin.PrivateLinkAlias
		result.Properties.PrivateLinkAlias = &privateLinkAlias
	}
	if origin.PrivateLinkApprovalMessage != nil {
		privateLinkApprovalMessage := *origin.PrivateLinkApprovalMessage
		result.Properties.PrivateLinkApprovalMessage = &privateLinkApprovalMessage
	}
	if origin.PrivateLinkLocationReference != nil {
		privateLinkLocationARMID, err := resolved.ResolvedReferences.Lookup(*origin.PrivateLinkLocationReference)
		if err != nil {
			return nil, err
		}
		privateLinkLocation := privateLinkLocationARMID
		result.Properties.PrivateLinkLocation = &privateLinkLocation
	}
	if origin.PrivateLinkResourceReference != nil {
		privateLinkResourceIdARMID, err := resolved.ResolvedReferences.Lookup(*origin.PrivateLinkResourceReference)
		if err != nil {
			return nil, err
		}
		privateLinkResourceId := privateLinkResourceIdARMID
		result.Properties.PrivateLinkResourceId = &privateLinkResourceId
	}
	if origin.Weight != nil {
		weight := *origin.Weight
		result.Properties.Weight = &weight
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (origin *DeepCreatedOrigin) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeepCreatedOrigin{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (origin *DeepCreatedOrigin) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeepCreatedOrigin)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeepCreatedOrigin, got %T", armInput)
	}

	// Set property "Enabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Enabled != nil {
			enabled := *typedInput.Properties.Enabled
			origin.Enabled = &enabled
		}
	}

	// Set property "HostName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostName != nil {
			hostName := *typedInput.Properties.HostName
			origin.HostName = &hostName
		}
	}

	// Set property "HttpPort":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HttpPort != nil {
			httpPort := *typedInput.Properties.HttpPort
			origin.HttpPort = &httpPort
		}
	}

	// Set property "HttpsPort":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HttpsPort != nil {
			httpsPort := *typedInput.Properties.HttpsPort
			origin.HttpsPort = &httpsPort
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		origin.Name = &name
	}

	// Set property "OriginHostHeader":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OriginHostHeader != nil {
			originHostHeader := *typedInput.Properties.OriginHostHeader
			origin.OriginHostHeader = &originHostHeader
		}
	}

	// Set property "Priority":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Priority != nil {
			priority := *typedInput.Properties.Priority
			origin.Priority = &priority
		}
	}

	// Set property "PrivateLinkAlias":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateLinkAlias != nil {
			privateLinkAlias := *typedInput.Properties.PrivateLinkAlias
			origin.PrivateLinkAlias = &privateLinkAlias
		}
	}

	// Set property "PrivateLinkApprovalMessage":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateLinkApprovalMessage != nil {
			privateLinkApprovalMessage := *typedInput.Properties.PrivateLinkApprovalMessage
			origin.PrivateLinkApprovalMessage = &privateLinkApprovalMessage
		}
	}

	// no assignment for property "PrivateLinkLocationReference"

	// no assignment for property "PrivateLinkResourceReference"

	// Set property "Weight":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Weight != nil {
			weight := *typedInput.Properties.Weight
			origin.Weight = &weight
		}
	}

	// No error
	return nil
}

// AssignProperties_From_DeepCreatedOrigin populates our DeepCreatedOrigin from the provided source DeepCreatedOrigin
func (origin *DeepCreatedOrigin) AssignProperties_From_DeepCreatedOrigin(source *storage.DeepCreatedOrigin) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		origin.Enabled = &enabled
	} else {
		origin.Enabled = nil
	}

	// HostName
	origin.HostName = genruntime.ClonePointerToString(source.HostName)

	// HttpPort
	if source.HttpPort != nil {
		httpPort := *source.HttpPort
		origin.HttpPort = &httpPort
	} else {
		origin.HttpPort = nil
	}

	// HttpsPort
	if source.HttpsPort != nil {
		httpsPort := *source.HttpsPort
		origin.HttpsPort = &httpsPort
	} else {
		origin.HttpsPort = nil
	}

	// Name
	origin.Name = genruntime.ClonePointerToString(source.Name)

	// OriginHostHeader
	origin.OriginHostHeader = genruntime.ClonePointerToString(source.OriginHostHeader)

	// Priority
	if source.Priority != nil {
		priority := *source.Priority
		origin.Priority = &priority
	} else {
		origin.Priority = nil
	}

	// PrivateLinkAlias
	origin.PrivateLinkAlias = genruntime.ClonePointerToString(source.PrivateLinkAlias)

	// PrivateLinkApprovalMessage
	origin.PrivateLinkApprovalMessage = genruntime.ClonePointerToString(source.PrivateLinkApprovalMessage)

	// PrivateLinkLocationReference
	if source.PrivateLinkLocationReference != nil {
		privateLinkLocationReference := source.PrivateLinkLocationReference.Copy()
		origin.PrivateLinkLocationReference = &privateLinkLocationReference
	} else {
		origin.PrivateLinkLocationReference = nil
	}

	// PrivateLinkResourceReference
	if source.PrivateLinkResourceReference != nil {
		privateLinkResourceReference := source.PrivateLinkResourceReference.Copy()
		origin.PrivateLinkResourceReference = &privateLinkResourceReference
	} else {
		origin.PrivateLinkResourceReference = nil
	}

	// Weight
	if source.Weight != nil {
		weight := *source.Weight
		origin.Weight = &weight
	} else {
		origin.Weight = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeepCreatedOrigin populates the provided destination DeepCreatedOrigin from our DeepCreatedOrigin
func (origin *DeepCreatedOrigin) AssignProperties_To_DeepCreatedOrigin(destination *storage.DeepCreatedOrigin) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if origin.Enabled != nil {
		enabled := *origin.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// HostName
	destination.HostName = genruntime.ClonePointerToString(origin.HostName)

	// HttpPort
	if origin.HttpPort != nil {
		httpPort := *origin.HttpPort
		destination.HttpPort = &httpPort
	} else {
		destination.HttpPort = nil
	}

	// HttpsPort
	if origin.HttpsPort != nil {
		httpsPort := *origin.HttpsPort
		destination.HttpsPort = &httpsPort
	} else {
		destination.HttpsPort = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(origin.Name)

	// OriginHostHeader
	destination.OriginHostHeader = genruntime.ClonePointerToString(origin.OriginHostHeader)

	// Priority
	if origin.Priority != nil {
		priority := *origin.Priority
		destination.Priority = &priority
	} else {
		destination.Priority = nil
	}

	// PrivateLinkAlias
	destination.PrivateLinkAlias = genruntime.ClonePointerToString(origin.PrivateLinkAlias)

	// PrivateLinkApprovalMessage
	destination.PrivateLinkApprovalMessage = genruntime.ClonePointerToString(origin.PrivateLinkApprovalMessage)

	// PrivateLinkLocationReference
	if origin.PrivateLinkLocationReference != nil {
		privateLinkLocationReference := origin.PrivateLinkLocationReference.Copy()
		destination.PrivateLinkLocationReference = &privateLinkLocationReference
	} else {
		destination.PrivateLinkLocationReference = nil
	}

	// PrivateLinkResourceReference
	if origin.PrivateLinkResourceReference != nil {
		privateLinkResourceReference := origin.PrivateLinkResourceReference.Copy()
		destination.PrivateLinkResourceReference = &privateLinkResourceReference
	} else {
		destination.PrivateLinkResourceReference = nil
	}

	// Weight
	if origin.Weight != nil {
		weight := *origin.Weight
		destination.Weight = &weight
	} else {
		destination.Weight = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeepCreatedOrigin_STATUS populates our DeepCreatedOrigin from the provided source DeepCreatedOrigin_STATUS
func (origin *DeepCreatedOrigin) Initialize_From_DeepCreatedOrigin_STATUS(source *DeepCreatedOrigin_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		origin.Enabled = &enabled
	} else {
		origin.Enabled = nil
	}

	// HostName
	origin.HostName = genruntime.ClonePointerToString(source.HostName)

	// HttpPort
	if source.HttpPort != nil {
		httpPort := *source.HttpPort
		origin.HttpPort = &httpPort
	} else {
		origin.HttpPort = nil
	}

	// HttpsPort
	if source.HttpsPort != nil {
		httpsPort := *source.HttpsPort
		origin.HttpsPort = &httpsPort
	} else {
		origin.HttpsPort = nil
	}

	// Name
	origin.Name = genruntime.ClonePointerToString(source.Name)

	// OriginHostHeader
	origin.OriginHostHeader = genruntime.ClonePointerToString(source.OriginHostHeader)

	// Priority
	if source.Priority != nil {
		priority := *source.Priority
		origin.Priority = &priority
	} else {
		origin.Priority = nil
	}

	// PrivateLinkAlias
	origin.PrivateLinkAlias = genruntime.ClonePointerToString(source.PrivateLinkAlias)

	// PrivateLinkApprovalMessage
	origin.PrivateLinkApprovalMessage = genruntime.ClonePointerToString(source.PrivateLinkApprovalMessage)

	// PrivateLinkResourceReference
	if source.PrivateLinkResourceId != nil {
		privateLinkResourceReference := genruntime.CreateResourceReferenceFromARMID(*source.PrivateLinkResourceId)
		origin.PrivateLinkResourceReference = &privateLinkResourceReference
	} else {
		origin.PrivateLinkResourceReference = nil
	}

	// Weight
	if source.Weight != nil {
		weight := *source.Weight
		origin.Weight = &weight
	} else {
		origin.Weight = nil
	}

	// No error
	return nil
}

// The main origin of CDN content which is added when creating a CDN endpoint.
type DeepCreatedOrigin_STATUS struct {
	// Enabled: Origin is enabled for load balancing or not. By default, origin is always enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// HostName: The address of the origin. It can be a domain name, IPv4 address, or IPv6 address. This should be unique
	// across all origins in an endpoint.
	HostName *string `json:"hostName,omitempty"`

	// HttpPort: The value of the HTTP port. Must be between 1 and 65535.
	HttpPort *int `json:"httpPort,omitempty"`

	// HttpsPort: The value of the HTTPS port. Must be between 1 and 65535.
	HttpsPort *int `json:"httpsPort,omitempty"`

	// Name: Origin name which must be unique within the endpoint.
	Name *string `json:"name,omitempty"`

	// OriginHostHeader: The host header value sent to the origin with each request. If you leave this blank, the request
	// hostname determines this value. Azure CDN origins, such as Web Apps, Blob Storage, and Cloud Services require this host
	// header value to match the origin hostname by default.
	OriginHostHeader *string `json:"originHostHeader,omitempty"`

	// Priority: Priority of origin in given origin group for load balancing. Higher priorities will not be used for load
	// balancing if any lower priority origin is healthy.Must be between 1 and 5.
	Priority *int `json:"priority,omitempty"`

	// PrivateEndpointStatus: The approval status for the connection to the Private Link
	PrivateEndpointStatus *PrivateEndpointStatus_STATUS `json:"privateEndpointStatus,omitempty"`

	// PrivateLinkAlias: The Alias of the Private Link resource. Populating this optional field indicates that this origin is
	// 'Private'
	PrivateLinkAlias *string `json:"privateLinkAlias,omitempty"`

	// PrivateLinkApprovalMessage: A custom message to be included in the approval request to connect to the Private Link.
	PrivateLinkApprovalMessage *string `json:"privateLinkApprovalMessage,omitempty"`

	// PrivateLinkLocation: The location of the Private Link resource. Required only if 'privateLinkResourceId' is populated
	PrivateLinkLocation *string `json:"privateLinkLocation,omitempty"`

	// PrivateLinkResourceId: The Resource Id of the Private Link resource. Populating this optional field indicates that this
	// backend is 'Private'
	PrivateLinkResourceId *string `json:"privateLinkResourceId,omitempty"`

	// Weight: Weight of the origin in given origin group for load balancing. Must be between 1 and 1000
	Weight *int `json:"weight,omitempty"`
}

var _ genruntime.FromARMConverter = &DeepCreatedOrigin_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (origin *DeepCreatedOrigin_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeepCreatedOrigin_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (origin *DeepCreatedOrigin_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeepCreatedOrigin_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeepCreatedOrigin_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Enabled != nil {
			enabled := *typedInput.Properties.Enabled
			origin.Enabled = &enabled
		}
	}

	// Set property "HostName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostName != nil {
			hostName := *typedInput.Properties.HostName
			origin.HostName = &hostName
		}
	}

	// Set property "HttpPort":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HttpPort != nil {
			httpPort := *typedInput.Properties.HttpPort
			origin.HttpPort = &httpPort
		}
	}

	// Set property "HttpsPort":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HttpsPort != nil {
			httpsPort := *typedInput.Properties.HttpsPort
			origin.HttpsPort = &httpsPort
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		origin.Name = &name
	}

	// Set property "OriginHostHeader":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OriginHostHeader != nil {
			originHostHeader := *typedInput.Properties.OriginHostHeader
			origin.OriginHostHeader = &originHostHeader
		}
	}

	// Set property "Priority":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Priority != nil {
			priority := *typedInput.Properties.Priority
			origin.Priority = &priority
		}
	}

	// Set property "PrivateEndpointStatus":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateEndpointStatus != nil {
			var temp string
			temp = string(*typedInput.Properties.PrivateEndpointStatus)
			privateEndpointStatus := PrivateEndpointStatus_STATUS(temp)
			origin.PrivateEndpointStatus = &privateEndpointStatus
		}
	}

	// Set property "PrivateLinkAlias":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateLinkAlias != nil {
			privateLinkAlias := *typedInput.Properties.PrivateLinkAlias
			origin.PrivateLinkAlias = &privateLinkAlias
		}
	}

	// Set property "PrivateLinkApprovalMessage":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateLinkApprovalMessage != nil {
			privateLinkApprovalMessage := *typedInput.Properties.PrivateLinkApprovalMessage
			origin.PrivateLinkApprovalMessage = &privateLinkApprovalMessage
		}
	}

	// Set property "PrivateLinkLocation":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateLinkLocation != nil {
			privateLinkLocation := *typedInput.Properties.PrivateLinkLocation
			origin.PrivateLinkLocation = &privateLinkLocation
		}
	}

	// Set property "PrivateLinkResourceId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateLinkResourceId != nil {
			privateLinkResourceId := *typedInput.Properties.PrivateLinkResourceId
			origin.PrivateLinkResourceId = &privateLinkResourceId
		}
	}

	// Set property "Weight":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Weight != nil {
			weight := *typedInput.Properties.Weight
			origin.Weight = &weight
		}
	}

	// No error
	return nil
}

// AssignProperties_From_DeepCreatedOrigin_STATUS populates our DeepCreatedOrigin_STATUS from the provided source DeepCreatedOrigin_STATUS
func (origin *DeepCreatedOrigin_STATUS) AssignProperties_From_DeepCreatedOrigin_STATUS(source *storage.DeepCreatedOrigin_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		origin.Enabled = &enabled
	} else {
		origin.Enabled = nil
	}

	// HostName
	origin.HostName = genruntime.ClonePointerToString(source.HostName)

	// HttpPort
	origin.HttpPort = genruntime.ClonePointerToInt(source.HttpPort)

	// HttpsPort
	origin.HttpsPort = genruntime.ClonePointerToInt(source.HttpsPort)

	// Name
	origin.Name = genruntime.ClonePointerToString(source.Name)

	// OriginHostHeader
	origin.OriginHostHeader = genruntime.ClonePointerToString(source.OriginHostHeader)

	// Priority
	origin.Priority = genruntime.ClonePointerToInt(source.Priority)

	// PrivateEndpointStatus
	if source.PrivateEndpointStatus != nil {
		privateEndpointStatus := *source.PrivateEndpointStatus
		privateEndpointStatusTemp := genruntime.ToEnum(privateEndpointStatus, privateEndpointStatus_STATUS_Values)
		origin.PrivateEndpointStatus = &privateEndpointStatusTemp
	} else {
		origin.PrivateEndpointStatus = nil
	}

	// PrivateLinkAlias
	origin.PrivateLinkAlias = genruntime.ClonePointerToString(source.PrivateLinkAlias)

	// PrivateLinkApprovalMessage
	origin.PrivateLinkApprovalMessage = genruntime.ClonePointerToString(source.PrivateLinkApprovalMessage)

	// PrivateLinkLocation
	origin.PrivateLinkLocation = genruntime.ClonePointerToString(source.PrivateLinkLocation)

	// PrivateLinkResourceId
	origin.PrivateLinkResourceId = genruntime.ClonePointerToString(source.PrivateLinkResourceId)

	// Weight
	origin.Weight = genruntime.ClonePointerToInt(source.Weight)

	// No error
	return nil
}

// AssignProperties_To_DeepCreatedOrigin_STATUS populates the provided destination DeepCreatedOrigin_STATUS from our DeepCreatedOrigin_STATUS
func (origin *DeepCreatedOrigin_STATUS) AssignProperties_To_DeepCreatedOrigin_STATUS(destination *storage.DeepCreatedOrigin_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if origin.Enabled != nil {
		enabled := *origin.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// HostName
	destination.HostName = genruntime.ClonePointerToString(origin.HostName)

	// HttpPort
	destination.HttpPort = genruntime.ClonePointerToInt(origin.HttpPort)

	// HttpsPort
	destination.HttpsPort = genruntime.ClonePointerToInt(origin.HttpsPort)

	// Name
	destination.Name = genruntime.ClonePointerToString(origin.Name)

	// OriginHostHeader
	destination.OriginHostHeader = genruntime.ClonePointerToString(origin.OriginHostHeader)

	// Priority
	destination.Priority = genruntime.ClonePointerToInt(origin.Priority)

	// PrivateEndpointStatus
	if origin.PrivateEndpointStatus != nil {
		privateEndpointStatus := string(*origin.PrivateEndpointStatus)
		destination.PrivateEndpointStatus = &privateEndpointStatus
	} else {
		destination.PrivateEndpointStatus = nil
	}

	// PrivateLinkAlias
	destination.PrivateLinkAlias = genruntime.ClonePointerToString(origin.PrivateLinkAlias)

	// PrivateLinkApprovalMessage
	destination.PrivateLinkApprovalMessage = genruntime.ClonePointerToString(origin.PrivateLinkApprovalMessage)

	// PrivateLinkLocation
	destination.PrivateLinkLocation = genruntime.ClonePointerToString(origin.PrivateLinkLocation)

	// PrivateLinkResourceId
	destination.PrivateLinkResourceId = genruntime.ClonePointerToString(origin.PrivateLinkResourceId)

	// Weight
	destination.Weight = genruntime.ClonePointerToInt(origin.Weight)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The origin group for CDN content which is added when creating a CDN endpoint. Traffic is sent to the origins within the
// origin group based on origin health.
type DeepCreatedOriginGroup struct {
	// HealthProbeSettings: Health probe settings to the origin that is used to determine the health of the origin.
	HealthProbeSettings *HealthProbeParameters `json:"healthProbeSettings,omitempty"`

	// +kubebuilder:validation:Required
	// Name: Origin group name which must be unique within the endpoint.
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Origins: The source of the content being delivered via CDN within given origin group.
	Origins []ResourceReference `json:"origins,omitempty"`

	// ResponseBasedOriginErrorDetectionSettings: The JSON object that contains the properties to determine origin health using
	// real requests/responses.This property is currently not supported.
	ResponseBasedOriginErrorDetectionSettings *ResponseBasedOriginErrorDetectionParameters `json:"responseBasedOriginErrorDetectionSettings,omitempty"`

	// +kubebuilder:validation:Maximum=50
	// +kubebuilder:validation:Minimum=0
	// TrafficRestorationTimeToHealedOrNewEndpointsInMinutes: Time in minutes to shift the traffic to the endpoint gradually
	// when an unhealthy endpoint comes healthy or a new endpoint is added. Default is 10 mins. This property is currently not
	// supported.
	TrafficRestorationTimeToHealedOrNewEndpointsInMinutes *int `json:"trafficRestorationTimeToHealedOrNewEndpointsInMinutes,omitempty"`
}

var _ genruntime.ARMTransformer = &DeepCreatedOriginGroup{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (group *DeepCreatedOriginGroup) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if group == nil {
		return nil, nil
	}
	result := &arm.DeepCreatedOriginGroup{}

	// Set property "Name":
	if group.Name != nil {
		name := *group.Name
		result.Name = &name
	}

	// Set property "Properties":
	if group.HealthProbeSettings != nil ||
		group.Origins != nil ||
		group.ResponseBasedOriginErrorDetectionSettings != nil ||
		group.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes != nil {
		result.Properties = &arm.DeepCreatedOriginGroupProperties{}
	}
	if group.HealthProbeSettings != nil {
		healthProbeSettings_ARM, err := (*group.HealthProbeSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		healthProbeSettings := *healthProbeSettings_ARM.(*arm.HealthProbeParameters)
		result.Properties.HealthProbeSettings = &healthProbeSettings
	}
	for _, item := range group.Origins {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.Origins = append(result.Properties.Origins, *item_ARM.(*arm.ResourceReference))
	}
	if group.ResponseBasedOriginErrorDetectionSettings != nil {
		responseBasedOriginErrorDetectionSettings_ARM, err := (*group.ResponseBasedOriginErrorDetectionSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		responseBasedOriginErrorDetectionSettings := *responseBasedOriginErrorDetectionSettings_ARM.(*arm.ResponseBasedOriginErrorDetectionParameters)
		result.Properties.ResponseBasedOriginErrorDetectionSettings = &responseBasedOriginErrorDetectionSettings
	}
	if group.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes != nil {
		trafficRestorationTimeToHealedOrNewEndpointsInMinutes := *group.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes
		result.Properties.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes = &trafficRestorationTimeToHealedOrNewEndpointsInMinutes
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (group *DeepCreatedOriginGroup) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeepCreatedOriginGroup{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (group *DeepCreatedOriginGroup) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeepCreatedOriginGroup)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeepCreatedOriginGroup, got %T", armInput)
	}

	// Set property "HealthProbeSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HealthProbeSettings != nil {
			var healthProbeSettings1 HealthProbeParameters
			err := healthProbeSettings1.PopulateFromARM(owner, *typedInput.Properties.HealthProbeSettings)
			if err != nil {
				return err
			}
			healthProbeSettings := healthProbeSettings1
			group.HealthProbeSettings = &healthProbeSettings
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		group.Name = &name
	}

	// Set property "Origins":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Origins {
			var item1 ResourceReference
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			group.Origins = append(group.Origins, item1)
		}
	}

	// Set property "ResponseBasedOriginErrorDetectionSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ResponseBasedOriginErrorDetectionSettings != nil {
			var responseBasedOriginErrorDetectionSettings1 ResponseBasedOriginErrorDetectionParameters
			err := responseBasedOriginErrorDetectionSettings1.PopulateFromARM(owner, *typedInput.Properties.ResponseBasedOriginErrorDetectionSettings)
			if err != nil {
				return err
			}
			responseBasedOriginErrorDetectionSettings := responseBasedOriginErrorDetectionSettings1
			group.ResponseBasedOriginErrorDetectionSettings = &responseBasedOriginErrorDetectionSettings
		}
	}

	// Set property "TrafficRestorationTimeToHealedOrNewEndpointsInMinutes":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes != nil {
			trafficRestorationTimeToHealedOrNewEndpointsInMinutes := *typedInput.Properties.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes
			group.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes = &trafficRestorationTimeToHealedOrNewEndpointsInMinutes
		}
	}

	// No error
	return nil
}

// AssignProperties_From_DeepCreatedOriginGroup populates our DeepCreatedOriginGroup from the provided source DeepCreatedOriginGroup
func (group *DeepCreatedOriginGroup) AssignProperties_From_DeepCreatedOriginGroup(source *storage.DeepCreatedOriginGroup) error {

	// HealthProbeSettings
	if source.HealthProbeSettings != nil {
		var healthProbeSetting HealthProbeParameters
		err := healthProbeSetting.AssignProperties_From_HealthProbeParameters(source.HealthProbeSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HealthProbeParameters() to populate field HealthProbeSettings")
		}
		group.HealthProbeSettings = &healthProbeSetting
	} else {
		group.HealthProbeSettings = nil
	}

	// Name
	group.Name = genruntime.ClonePointerToString(source.Name)

	// Origins
	if source.Origins != nil {
		originList := make([]ResourceReference, len(source.Origins))
		for originIndex, originItem := range source.Origins {
			// Shadow the loop variable to avoid aliasing
			originItem := originItem
			var origin ResourceReference
			err := origin.AssignProperties_From_ResourceReference(&originItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ResourceReference() to populate field Origins")
			}
			originList[originIndex] = origin
		}
		group.Origins = originList
	} else {
		group.Origins = nil
	}

	// ResponseBasedOriginErrorDetectionSettings
	if source.ResponseBasedOriginErrorDetectionSettings != nil {
		var responseBasedOriginErrorDetectionSetting ResponseBasedOriginErrorDetectionParameters
		err := responseBasedOriginErrorDetectionSetting.AssignProperties_From_ResponseBasedOriginErrorDetectionParameters(source.ResponseBasedOriginErrorDetectionSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResponseBasedOriginErrorDetectionParameters() to populate field ResponseBasedOriginErrorDetectionSettings")
		}
		group.ResponseBasedOriginErrorDetectionSettings = &responseBasedOriginErrorDetectionSetting
	} else {
		group.ResponseBasedOriginErrorDetectionSettings = nil
	}

	// TrafficRestorationTimeToHealedOrNewEndpointsInMinutes
	if source.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes != nil {
		trafficRestorationTimeToHealedOrNewEndpointsInMinute := *source.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes
		group.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes = &trafficRestorationTimeToHealedOrNewEndpointsInMinute
	} else {
		group.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeepCreatedOriginGroup populates the provided destination DeepCreatedOriginGroup from our DeepCreatedOriginGroup
func (group *DeepCreatedOriginGroup) AssignProperties_To_DeepCreatedOriginGroup(destination *storage.DeepCreatedOriginGroup) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HealthProbeSettings
	if group.HealthProbeSettings != nil {
		var healthProbeSetting storage.HealthProbeParameters
		err := group.HealthProbeSettings.AssignProperties_To_HealthProbeParameters(&healthProbeSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HealthProbeParameters() to populate field HealthProbeSettings")
		}
		destination.HealthProbeSettings = &healthProbeSetting
	} else {
		destination.HealthProbeSettings = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(group.Name)

	// Origins
	if group.Origins != nil {
		originList := make([]storage.ResourceReference, len(group.Origins))
		for originIndex, originItem := range group.Origins {
			// Shadow the loop variable to avoid aliasing
			originItem := originItem
			var origin storage.ResourceReference
			err := originItem.AssignProperties_To_ResourceReference(&origin)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ResourceReference() to populate field Origins")
			}
			originList[originIndex] = origin
		}
		destination.Origins = originList
	} else {
		destination.Origins = nil
	}

	// ResponseBasedOriginErrorDetectionSettings
	if group.ResponseBasedOriginErrorDetectionSettings != nil {
		var responseBasedOriginErrorDetectionSetting storage.ResponseBasedOriginErrorDetectionParameters
		err := group.ResponseBasedOriginErrorDetectionSettings.AssignProperties_To_ResponseBasedOriginErrorDetectionParameters(&responseBasedOriginErrorDetectionSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResponseBasedOriginErrorDetectionParameters() to populate field ResponseBasedOriginErrorDetectionSettings")
		}
		destination.ResponseBasedOriginErrorDetectionSettings = &responseBasedOriginErrorDetectionSetting
	} else {
		destination.ResponseBasedOriginErrorDetectionSettings = nil
	}

	// TrafficRestorationTimeToHealedOrNewEndpointsInMinutes
	if group.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes != nil {
		trafficRestorationTimeToHealedOrNewEndpointsInMinute := *group.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes
		destination.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes = &trafficRestorationTimeToHealedOrNewEndpointsInMinute
	} else {
		destination.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeepCreatedOriginGroup_STATUS populates our DeepCreatedOriginGroup from the provided source DeepCreatedOriginGroup_STATUS
func (group *DeepCreatedOriginGroup) Initialize_From_DeepCreatedOriginGroup_STATUS(source *DeepCreatedOriginGroup_STATUS) error {

	// HealthProbeSettings
	if source.HealthProbeSettings != nil {
		var healthProbeSetting HealthProbeParameters
		err := healthProbeSetting.Initialize_From_HealthProbeParameters_STATUS(source.HealthProbeSettings)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_HealthProbeParameters_STATUS() to populate field HealthProbeSettings")
		}
		group.HealthProbeSettings = &healthProbeSetting
	} else {
		group.HealthProbeSettings = nil
	}

	// Name
	group.Name = genruntime.ClonePointerToString(source.Name)

	// Origins
	if source.Origins != nil {
		originList := make([]ResourceReference, len(source.Origins))
		for originIndex, originItem := range source.Origins {
			// Shadow the loop variable to avoid aliasing
			originItem := originItem
			var origin ResourceReference
			err := origin.Initialize_From_ResourceReference_STATUS(&originItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ResourceReference_STATUS() to populate field Origins")
			}
			originList[originIndex] = origin
		}
		group.Origins = originList
	} else {
		group.Origins = nil
	}

	// ResponseBasedOriginErrorDetectionSettings
	if source.ResponseBasedOriginErrorDetectionSettings != nil {
		var responseBasedOriginErrorDetectionSetting ResponseBasedOriginErrorDetectionParameters
		err := responseBasedOriginErrorDetectionSetting.Initialize_From_ResponseBasedOriginErrorDetectionParameters_STATUS(source.ResponseBasedOriginErrorDetectionSettings)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ResponseBasedOriginErrorDetectionParameters_STATUS() to populate field ResponseBasedOriginErrorDetectionSettings")
		}
		group.ResponseBasedOriginErrorDetectionSettings = &responseBasedOriginErrorDetectionSetting
	} else {
		group.ResponseBasedOriginErrorDetectionSettings = nil
	}

	// TrafficRestorationTimeToHealedOrNewEndpointsInMinutes
	if source.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes != nil {
		trafficRestorationTimeToHealedOrNewEndpointsInMinute := *source.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes
		group.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes = &trafficRestorationTimeToHealedOrNewEndpointsInMinute
	} else {
		group.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes = nil
	}

	// No error
	return nil
}

// The origin group for CDN content which is added when creating a CDN endpoint. Traffic is sent to the origins within the
// origin group based on origin health.
type DeepCreatedOriginGroup_STATUS struct {
	// HealthProbeSettings: Health probe settings to the origin that is used to determine the health of the origin.
	HealthProbeSettings *HealthProbeParameters_STATUS `json:"healthProbeSettings,omitempty"`

	// Name: Origin group name which must be unique within the endpoint.
	Name *string `json:"name,omitempty"`

	// Origins: The source of the content being delivered via CDN within given origin group.
	Origins []ResourceReference_STATUS `json:"origins,omitempty"`

	// ResponseBasedOriginErrorDetectionSettings: The JSON object that contains the properties to determine origin health using
	// real requests/responses.This property is currently not supported.
	ResponseBasedOriginErrorDetectionSettings *ResponseBasedOriginErrorDetectionParameters_STATUS `json:"responseBasedOriginErrorDetectionSettings,omitempty"`

	// TrafficRestorationTimeToHealedOrNewEndpointsInMinutes: Time in minutes to shift the traffic to the endpoint gradually
	// when an unhealthy endpoint comes healthy or a new endpoint is added. Default is 10 mins. This property is currently not
	// supported.
	TrafficRestorationTimeToHealedOrNewEndpointsInMinutes *int `json:"trafficRestorationTimeToHealedOrNewEndpointsInMinutes,omitempty"`
}

var _ genruntime.FromARMConverter = &DeepCreatedOriginGroup_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (group *DeepCreatedOriginGroup_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeepCreatedOriginGroup_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (group *DeepCreatedOriginGroup_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeepCreatedOriginGroup_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeepCreatedOriginGroup_STATUS, got %T", armInput)
	}

	// Set property "HealthProbeSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HealthProbeSettings != nil {
			var healthProbeSettings1 HealthProbeParameters_STATUS
			err := healthProbeSettings1.PopulateFromARM(owner, *typedInput.Properties.HealthProbeSettings)
			if err != nil {
				return err
			}
			healthProbeSettings := healthProbeSettings1
			group.HealthProbeSettings = &healthProbeSettings
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		group.Name = &name
	}

	// Set property "Origins":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Origins {
			var item1 ResourceReference_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			group.Origins = append(group.Origins, item1)
		}
	}

	// Set property "ResponseBasedOriginErrorDetectionSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ResponseBasedOriginErrorDetectionSettings != nil {
			var responseBasedOriginErrorDetectionSettings1 ResponseBasedOriginErrorDetectionParameters_STATUS
			err := responseBasedOriginErrorDetectionSettings1.PopulateFromARM(owner, *typedInput.Properties.ResponseBasedOriginErrorDetectionSettings)
			if err != nil {
				return err
			}
			responseBasedOriginErrorDetectionSettings := responseBasedOriginErrorDetectionSettings1
			group.ResponseBasedOriginErrorDetectionSettings = &responseBasedOriginErrorDetectionSettings
		}
	}

	// Set property "TrafficRestorationTimeToHealedOrNewEndpointsInMinutes":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes != nil {
			trafficRestorationTimeToHealedOrNewEndpointsInMinutes := *typedInput.Properties.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes
			group.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes = &trafficRestorationTimeToHealedOrNewEndpointsInMinutes
		}
	}

	// No error
	return nil
}

// AssignProperties_From_DeepCreatedOriginGroup_STATUS populates our DeepCreatedOriginGroup_STATUS from the provided source DeepCreatedOriginGroup_STATUS
func (group *DeepCreatedOriginGroup_STATUS) AssignProperties_From_DeepCreatedOriginGroup_STATUS(source *storage.DeepCreatedOriginGroup_STATUS) error {

	// HealthProbeSettings
	if source.HealthProbeSettings != nil {
		var healthProbeSetting HealthProbeParameters_STATUS
		err := healthProbeSetting.AssignProperties_From_HealthProbeParameters_STATUS(source.HealthProbeSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HealthProbeParameters_STATUS() to populate field HealthProbeSettings")
		}
		group.HealthProbeSettings = &healthProbeSetting
	} else {
		group.HealthProbeSettings = nil
	}

	// Name
	group.Name = genruntime.ClonePointerToString(source.Name)

	// Origins
	if source.Origins != nil {
		originList := make([]ResourceReference_STATUS, len(source.Origins))
		for originIndex, originItem := range source.Origins {
			// Shadow the loop variable to avoid aliasing
			originItem := originItem
			var origin ResourceReference_STATUS
			err := origin.AssignProperties_From_ResourceReference_STATUS(&originItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ResourceReference_STATUS() to populate field Origins")
			}
			originList[originIndex] = origin
		}
		group.Origins = originList
	} else {
		group.Origins = nil
	}

	// ResponseBasedOriginErrorDetectionSettings
	if source.ResponseBasedOriginErrorDetectionSettings != nil {
		var responseBasedOriginErrorDetectionSetting ResponseBasedOriginErrorDetectionParameters_STATUS
		err := responseBasedOriginErrorDetectionSetting.AssignProperties_From_ResponseBasedOriginErrorDetectionParameters_STATUS(source.ResponseBasedOriginErrorDetectionSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResponseBasedOriginErrorDetectionParameters_STATUS() to populate field ResponseBasedOriginErrorDetectionSettings")
		}
		group.ResponseBasedOriginErrorDetectionSettings = &responseBasedOriginErrorDetectionSetting
	} else {
		group.ResponseBasedOriginErrorDetectionSettings = nil
	}

	// TrafficRestorationTimeToHealedOrNewEndpointsInMinutes
	group.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes = genruntime.ClonePointerToInt(source.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes)

	// No error
	return nil
}

// AssignProperties_To_DeepCreatedOriginGroup_STATUS populates the provided destination DeepCreatedOriginGroup_STATUS from our DeepCreatedOriginGroup_STATUS
func (group *DeepCreatedOriginGroup_STATUS) AssignProperties_To_DeepCreatedOriginGroup_STATUS(destination *storage.DeepCreatedOriginGroup_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HealthProbeSettings
	if group.HealthProbeSettings != nil {
		var healthProbeSetting storage.HealthProbeParameters_STATUS
		err := group.HealthProbeSettings.AssignProperties_To_HealthProbeParameters_STATUS(&healthProbeSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HealthProbeParameters_STATUS() to populate field HealthProbeSettings")
		}
		destination.HealthProbeSettings = &healthProbeSetting
	} else {
		destination.HealthProbeSettings = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(group.Name)

	// Origins
	if group.Origins != nil {
		originList := make([]storage.ResourceReference_STATUS, len(group.Origins))
		for originIndex, originItem := range group.Origins {
			// Shadow the loop variable to avoid aliasing
			originItem := originItem
			var origin storage.ResourceReference_STATUS
			err := originItem.AssignProperties_To_ResourceReference_STATUS(&origin)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ResourceReference_STATUS() to populate field Origins")
			}
			originList[originIndex] = origin
		}
		destination.Origins = originList
	} else {
		destination.Origins = nil
	}

	// ResponseBasedOriginErrorDetectionSettings
	if group.ResponseBasedOriginErrorDetectionSettings != nil {
		var responseBasedOriginErrorDetectionSetting storage.ResponseBasedOriginErrorDetectionParameters_STATUS
		err := group.ResponseBasedOriginErrorDetectionSettings.AssignProperties_To_ResponseBasedOriginErrorDetectionParameters_STATUS(&responseBasedOriginErrorDetectionSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResponseBasedOriginErrorDetectionParameters_STATUS() to populate field ResponseBasedOriginErrorDetectionSettings")
		}
		destination.ResponseBasedOriginErrorDetectionSettings = &responseBasedOriginErrorDetectionSetting
	} else {
		destination.ResponseBasedOriginErrorDetectionSettings = nil
	}

	// TrafficRestorationTimeToHealedOrNewEndpointsInMinutes
	destination.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes = genruntime.ClonePointerToInt(group.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type EndpointProperties_DeliveryPolicy struct {
	// Description: User-friendly description of the policy.
	Description *string `json:"description,omitempty"`

	// +kubebuilder:validation:Required
	// Rules: A list of the delivery rules.
	Rules []DeliveryRule `json:"rules,omitempty"`
}

var _ genruntime.ARMTransformer = &EndpointProperties_DeliveryPolicy{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *EndpointProperties_DeliveryPolicy) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	result := &arm.EndpointProperties_DeliveryPolicy{}

	// Set property "Description":
	if policy.Description != nil {
		description := *policy.Description
		result.Description = &description
	}

	// Set property "Rules":
	for _, item := range policy.Rules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Rules = append(result.Rules, *item_ARM.(*arm.DeliveryRule))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *EndpointProperties_DeliveryPolicy) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EndpointProperties_DeliveryPolicy{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *EndpointProperties_DeliveryPolicy) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EndpointProperties_DeliveryPolicy)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EndpointProperties_DeliveryPolicy, got %T", armInput)
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		policy.Description = &description
	}

	// Set property "Rules":
	for _, item := range typedInput.Rules {
		var item1 DeliveryRule
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		policy.Rules = append(policy.Rules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_EndpointProperties_DeliveryPolicy populates our EndpointProperties_DeliveryPolicy from the provided source EndpointProperties_DeliveryPolicy
func (policy *EndpointProperties_DeliveryPolicy) AssignProperties_From_EndpointProperties_DeliveryPolicy(source *storage.EndpointProperties_DeliveryPolicy) error {

	// Description
	policy.Description = genruntime.ClonePointerToString(source.Description)

	// Rules
	if source.Rules != nil {
		ruleList := make([]DeliveryRule, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule DeliveryRule
			err := rule.AssignProperties_From_DeliveryRule(&ruleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DeliveryRule() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		policy.Rules = ruleList
	} else {
		policy.Rules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_EndpointProperties_DeliveryPolicy populates the provided destination EndpointProperties_DeliveryPolicy from our EndpointProperties_DeliveryPolicy
func (policy *EndpointProperties_DeliveryPolicy) AssignProperties_To_EndpointProperties_DeliveryPolicy(destination *storage.EndpointProperties_DeliveryPolicy) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Description
	destination.Description = genruntime.ClonePointerToString(policy.Description)

	// Rules
	if policy.Rules != nil {
		ruleList := make([]storage.DeliveryRule, len(policy.Rules))
		for ruleIndex, ruleItem := range policy.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule storage.DeliveryRule
			err := ruleItem.AssignProperties_To_DeliveryRule(&rule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DeliveryRule() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_EndpointProperties_DeliveryPolicy_STATUS populates our EndpointProperties_DeliveryPolicy from the provided source EndpointProperties_DeliveryPolicy_STATUS
func (policy *EndpointProperties_DeliveryPolicy) Initialize_From_EndpointProperties_DeliveryPolicy_STATUS(source *EndpointProperties_DeliveryPolicy_STATUS) error {

	// Description
	policy.Description = genruntime.ClonePointerToString(source.Description)

	// Rules
	if source.Rules != nil {
		ruleList := make([]DeliveryRule, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule DeliveryRule
			err := rule.Initialize_From_DeliveryRule_STATUS(&ruleItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_DeliveryRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		policy.Rules = ruleList
	} else {
		policy.Rules = nil
	}

	// No error
	return nil
}

type EndpointProperties_DeliveryPolicy_STATUS struct {
	// Description: User-friendly description of the policy.
	Description *string `json:"description,omitempty"`

	// Rules: A list of the delivery rules.
	Rules []DeliveryRule_STATUS `json:"rules,omitempty"`
}

var _ genruntime.FromARMConverter = &EndpointProperties_DeliveryPolicy_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *EndpointProperties_DeliveryPolicy_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EndpointProperties_DeliveryPolicy_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *EndpointProperties_DeliveryPolicy_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EndpointProperties_DeliveryPolicy_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EndpointProperties_DeliveryPolicy_STATUS, got %T", armInput)
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		policy.Description = &description
	}

	// Set property "Rules":
	for _, item := range typedInput.Rules {
		var item1 DeliveryRule_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		policy.Rules = append(policy.Rules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_EndpointProperties_DeliveryPolicy_STATUS populates our EndpointProperties_DeliveryPolicy_STATUS from the provided source EndpointProperties_DeliveryPolicy_STATUS
func (policy *EndpointProperties_DeliveryPolicy_STATUS) AssignProperties_From_EndpointProperties_DeliveryPolicy_STATUS(source *storage.EndpointProperties_DeliveryPolicy_STATUS) error {

	// Description
	policy.Description = genruntime.ClonePointerToString(source.Description)

	// Rules
	if source.Rules != nil {
		ruleList := make([]DeliveryRule_STATUS, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule DeliveryRule_STATUS
			err := rule.AssignProperties_From_DeliveryRule_STATUS(&ruleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DeliveryRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		policy.Rules = ruleList
	} else {
		policy.Rules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_EndpointProperties_DeliveryPolicy_STATUS populates the provided destination EndpointProperties_DeliveryPolicy_STATUS from our EndpointProperties_DeliveryPolicy_STATUS
func (policy *EndpointProperties_DeliveryPolicy_STATUS) AssignProperties_To_EndpointProperties_DeliveryPolicy_STATUS(destination *storage.EndpointProperties_DeliveryPolicy_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Description
	destination.Description = genruntime.ClonePointerToString(policy.Description)

	// Rules
	if policy.Rules != nil {
		ruleList := make([]storage.DeliveryRule_STATUS, len(policy.Rules))
		for ruleIndex, ruleItem := range policy.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule storage.DeliveryRule_STATUS
			err := ruleItem.AssignProperties_To_DeliveryRule_STATUS(&rule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DeliveryRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type EndpointProperties_ProvisioningState_STATUS string

const (
	EndpointProperties_ProvisioningState_STATUS_Creating  = EndpointProperties_ProvisioningState_STATUS("Creating")
	EndpointProperties_ProvisioningState_STATUS_Deleting  = EndpointProperties_ProvisioningState_STATUS("Deleting")
	EndpointProperties_ProvisioningState_STATUS_Failed    = EndpointProperties_ProvisioningState_STATUS("Failed")
	EndpointProperties_ProvisioningState_STATUS_Succeeded = EndpointProperties_ProvisioningState_STATUS("Succeeded")
	EndpointProperties_ProvisioningState_STATUS_Updating  = EndpointProperties_ProvisioningState_STATUS("Updating")
)

// Mapping from string to EndpointProperties_ProvisioningState_STATUS
var endpointProperties_ProvisioningState_STATUS_Values = map[string]EndpointProperties_ProvisioningState_STATUS{
	"creating":  EndpointProperties_ProvisioningState_STATUS_Creating,
	"deleting":  EndpointProperties_ProvisioningState_STATUS_Deleting,
	"failed":    EndpointProperties_ProvisioningState_STATUS_Failed,
	"succeeded": EndpointProperties_ProvisioningState_STATUS_Succeeded,
	"updating":  EndpointProperties_ProvisioningState_STATUS_Updating,
}

type EndpointProperties_ResourceState_STATUS string

const (
	EndpointProperties_ResourceState_STATUS_Creating = EndpointProperties_ResourceState_STATUS("Creating")
	EndpointProperties_ResourceState_STATUS_Deleting = EndpointProperties_ResourceState_STATUS("Deleting")
	EndpointProperties_ResourceState_STATUS_Running  = EndpointProperties_ResourceState_STATUS("Running")
	EndpointProperties_ResourceState_STATUS_Starting = EndpointProperties_ResourceState_STATUS("Starting")
	EndpointProperties_ResourceState_STATUS_Stopped  = EndpointProperties_ResourceState_STATUS("Stopped")
	EndpointProperties_ResourceState_STATUS_Stopping = EndpointProperties_ResourceState_STATUS("Stopping")
)

// Mapping from string to EndpointProperties_ResourceState_STATUS
var endpointProperties_ResourceState_STATUS_Values = map[string]EndpointProperties_ResourceState_STATUS{
	"creating": EndpointProperties_ResourceState_STATUS_Creating,
	"deleting": EndpointProperties_ResourceState_STATUS_Deleting,
	"running":  EndpointProperties_ResourceState_STATUS_Running,
	"starting": EndpointProperties_ResourceState_STATUS_Starting,
	"stopped":  EndpointProperties_ResourceState_STATUS_Stopped,
	"stopping": EndpointProperties_ResourceState_STATUS_Stopping,
}

type EndpointProperties_WebApplicationFirewallPolicyLink struct {
	// Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &EndpointProperties_WebApplicationFirewallPolicyLink{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (link *EndpointProperties_WebApplicationFirewallPolicyLink) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if link == nil {
		return nil, nil
	}
	result := &arm.EndpointProperties_WebApplicationFirewallPolicyLink{}

	// Set property "Id":
	if link.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*link.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (link *EndpointProperties_WebApplicationFirewallPolicyLink) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EndpointProperties_WebApplicationFirewallPolicyLink{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (link *EndpointProperties_WebApplicationFirewallPolicyLink) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(arm.EndpointProperties_WebApplicationFirewallPolicyLink)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EndpointProperties_WebApplicationFirewallPolicyLink, got %T", armInput)
	}

	// no assignment for property "Reference"

	// No error
	return nil
}

// AssignProperties_From_EndpointProperties_WebApplicationFirewallPolicyLink populates our EndpointProperties_WebApplicationFirewallPolicyLink from the provided source EndpointProperties_WebApplicationFirewallPolicyLink
func (link *EndpointProperties_WebApplicationFirewallPolicyLink) AssignProperties_From_EndpointProperties_WebApplicationFirewallPolicyLink(source *storage.EndpointProperties_WebApplicationFirewallPolicyLink) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		link.Reference = &reference
	} else {
		link.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_EndpointProperties_WebApplicationFirewallPolicyLink populates the provided destination EndpointProperties_WebApplicationFirewallPolicyLink from our EndpointProperties_WebApplicationFirewallPolicyLink
func (link *EndpointProperties_WebApplicationFirewallPolicyLink) AssignProperties_To_EndpointProperties_WebApplicationFirewallPolicyLink(destination *storage.EndpointProperties_WebApplicationFirewallPolicyLink) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if link.Reference != nil {
		reference := link.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_EndpointProperties_WebApplicationFirewallPolicyLink_STATUS populates our EndpointProperties_WebApplicationFirewallPolicyLink from the provided source EndpointProperties_WebApplicationFirewallPolicyLink_STATUS
func (link *EndpointProperties_WebApplicationFirewallPolicyLink) Initialize_From_EndpointProperties_WebApplicationFirewallPolicyLink_STATUS(source *EndpointProperties_WebApplicationFirewallPolicyLink_STATUS) error {

	// Reference
	if source.Id != nil {
		reference := genruntime.CreateResourceReferenceFromARMID(*source.Id)
		link.Reference = &reference
	} else {
		link.Reference = nil
	}

	// No error
	return nil
}

type EndpointProperties_WebApplicationFirewallPolicyLink_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &EndpointProperties_WebApplicationFirewallPolicyLink_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (link *EndpointProperties_WebApplicationFirewallPolicyLink_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EndpointProperties_WebApplicationFirewallPolicyLink_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (link *EndpointProperties_WebApplicationFirewallPolicyLink_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EndpointProperties_WebApplicationFirewallPolicyLink_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EndpointProperties_WebApplicationFirewallPolicyLink_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		link.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_EndpointProperties_WebApplicationFirewallPolicyLink_STATUS populates our EndpointProperties_WebApplicationFirewallPolicyLink_STATUS from the provided source EndpointProperties_WebApplicationFirewallPolicyLink_STATUS
func (link *EndpointProperties_WebApplicationFirewallPolicyLink_STATUS) AssignProperties_From_EndpointProperties_WebApplicationFirewallPolicyLink_STATUS(source *storage.EndpointProperties_WebApplicationFirewallPolicyLink_STATUS) error {

	// Id
	link.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_EndpointProperties_WebApplicationFirewallPolicyLink_STATUS populates the provided destination EndpointProperties_WebApplicationFirewallPolicyLink_STATUS from our EndpointProperties_WebApplicationFirewallPolicyLink_STATUS
func (link *EndpointProperties_WebApplicationFirewallPolicyLink_STATUS) AssignProperties_To_EndpointProperties_WebApplicationFirewallPolicyLink_STATUS(destination *storage.EndpointProperties_WebApplicationFirewallPolicyLink_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(link.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Rules defining user's geo access within a CDN endpoint.
type GeoFilter struct {
	// +kubebuilder:validation:Required
	// Action: Action of the geo filter, i.e. allow or block access.
	Action *GeoFilter_Action `json:"action,omitempty"`

	// +kubebuilder:validation:Required
	// CountryCodes: Two letter country or region codes defining user country or region access in a geo filter, e.g. AU, MX, US.
	CountryCodes []string `json:"countryCodes,omitempty"`

	// +kubebuilder:validation:Required
	// RelativePath: Relative path applicable to geo filter. (e.g. '/mypictures', '/mypicture/kitty.jpg', and etc.)
	RelativePath *string `json:"relativePath,omitempty"`
}

var _ genruntime.ARMTransformer = &GeoFilter{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (filter *GeoFilter) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if filter == nil {
		return nil, nil
	}
	result := &arm.GeoFilter{}

	// Set property "Action":
	if filter.Action != nil {
		var temp string
		temp = string(*filter.Action)
		action := arm.GeoFilter_Action(temp)
		result.Action = &action
	}

	// Set property "CountryCodes":
	for _, item := range filter.CountryCodes {
		result.CountryCodes = append(result.CountryCodes, item)
	}

	// Set property "RelativePath":
	if filter.RelativePath != nil {
		relativePath := *filter.RelativePath
		result.RelativePath = &relativePath
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (filter *GeoFilter) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.GeoFilter{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (filter *GeoFilter) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.GeoFilter)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.GeoFilter, got %T", armInput)
	}

	// Set property "Action":
	if typedInput.Action != nil {
		var temp string
		temp = string(*typedInput.Action)
		action := GeoFilter_Action(temp)
		filter.Action = &action
	}

	// Set property "CountryCodes":
	for _, item := range typedInput.CountryCodes {
		filter.CountryCodes = append(filter.CountryCodes, item)
	}

	// Set property "RelativePath":
	if typedInput.RelativePath != nil {
		relativePath := *typedInput.RelativePath
		filter.RelativePath = &relativePath
	}

	// No error
	return nil
}

// AssignProperties_From_GeoFilter populates our GeoFilter from the provided source GeoFilter
func (filter *GeoFilter) AssignProperties_From_GeoFilter(source *storage.GeoFilter) error {

	// Action
	if source.Action != nil {
		action := *source.Action
		actionTemp := genruntime.ToEnum(action, geoFilter_Action_Values)
		filter.Action = &actionTemp
	} else {
		filter.Action = nil
	}

	// CountryCodes
	filter.CountryCodes = genruntime.CloneSliceOfString(source.CountryCodes)

	// RelativePath
	filter.RelativePath = genruntime.ClonePointerToString(source.RelativePath)

	// No error
	return nil
}

// AssignProperties_To_GeoFilter populates the provided destination GeoFilter from our GeoFilter
func (filter *GeoFilter) AssignProperties_To_GeoFilter(destination *storage.GeoFilter) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	if filter.Action != nil {
		action := string(*filter.Action)
		destination.Action = &action
	} else {
		destination.Action = nil
	}

	// CountryCodes
	destination.CountryCodes = genruntime.CloneSliceOfString(filter.CountryCodes)

	// RelativePath
	destination.RelativePath = genruntime.ClonePointerToString(filter.RelativePath)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_GeoFilter_STATUS populates our GeoFilter from the provided source GeoFilter_STATUS
func (filter *GeoFilter) Initialize_From_GeoFilter_STATUS(source *GeoFilter_STATUS) error {

	// Action
	if source.Action != nil {
		action := genruntime.ToEnum(string(*source.Action), geoFilter_Action_Values)
		filter.Action = &action
	} else {
		filter.Action = nil
	}

	// CountryCodes
	filter.CountryCodes = genruntime.CloneSliceOfString(source.CountryCodes)

	// RelativePath
	filter.RelativePath = genruntime.ClonePointerToString(source.RelativePath)

	// No error
	return nil
}

// Rules defining user's geo access within a CDN endpoint.
type GeoFilter_STATUS struct {
	// Action: Action of the geo filter, i.e. allow or block access.
	Action *GeoFilter_Action_STATUS `json:"action,omitempty"`

	// CountryCodes: Two letter country or region codes defining user country or region access in a geo filter, e.g. AU, MX, US.
	CountryCodes []string `json:"countryCodes,omitempty"`

	// RelativePath: Relative path applicable to geo filter. (e.g. '/mypictures', '/mypicture/kitty.jpg', and etc.)
	RelativePath *string `json:"relativePath,omitempty"`
}

var _ genruntime.FromARMConverter = &GeoFilter_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (filter *GeoFilter_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.GeoFilter_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (filter *GeoFilter_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.GeoFilter_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.GeoFilter_STATUS, got %T", armInput)
	}

	// Set property "Action":
	if typedInput.Action != nil {
		var temp string
		temp = string(*typedInput.Action)
		action := GeoFilter_Action_STATUS(temp)
		filter.Action = &action
	}

	// Set property "CountryCodes":
	for _, item := range typedInput.CountryCodes {
		filter.CountryCodes = append(filter.CountryCodes, item)
	}

	// Set property "RelativePath":
	if typedInput.RelativePath != nil {
		relativePath := *typedInput.RelativePath
		filter.RelativePath = &relativePath
	}

	// No error
	return nil
}

// AssignProperties_From_GeoFilter_STATUS populates our GeoFilter_STATUS from the provided source GeoFilter_STATUS
func (filter *GeoFilter_STATUS) AssignProperties_From_GeoFilter_STATUS(source *storage.GeoFilter_STATUS) error {

	// Action
	if source.Action != nil {
		action := *source.Action
		actionTemp := genruntime.ToEnum(action, geoFilter_Action_STATUS_Values)
		filter.Action = &actionTemp
	} else {
		filter.Action = nil
	}

	// CountryCodes
	filter.CountryCodes = genruntime.CloneSliceOfString(source.CountryCodes)

	// RelativePath
	filter.RelativePath = genruntime.ClonePointerToString(source.RelativePath)

	// No error
	return nil
}

// AssignProperties_To_GeoFilter_STATUS populates the provided destination GeoFilter_STATUS from our GeoFilter_STATUS
func (filter *GeoFilter_STATUS) AssignProperties_To_GeoFilter_STATUS(destination *storage.GeoFilter_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	if filter.Action != nil {
		action := string(*filter.Action)
		destination.Action = &action
	} else {
		destination.Action = nil
	}

	// CountryCodes
	destination.CountryCodes = genruntime.CloneSliceOfString(filter.CountryCodes)

	// RelativePath
	destination.RelativePath = genruntime.ClonePointerToString(filter.RelativePath)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Specifies what scenario the customer wants this CDN endpoint to optimize, e.g. Download, Media services. With this
// information we can apply scenario driven optimization.
// +kubebuilder:validation:Enum={"DynamicSiteAcceleration","GeneralMediaStreaming","GeneralWebDelivery","LargeFileDownload","VideoOnDemandMediaStreaming"}
type OptimizationType string

const (
	OptimizationType_DynamicSiteAcceleration     = OptimizationType("DynamicSiteAcceleration")
	OptimizationType_GeneralMediaStreaming       = OptimizationType("GeneralMediaStreaming")
	OptimizationType_GeneralWebDelivery          = OptimizationType("GeneralWebDelivery")
	OptimizationType_LargeFileDownload           = OptimizationType("LargeFileDownload")
	OptimizationType_VideoOnDemandMediaStreaming = OptimizationType("VideoOnDemandMediaStreaming")
)

// Mapping from string to OptimizationType
var optimizationType_Values = map[string]OptimizationType{
	"dynamicsiteacceleration":     OptimizationType_DynamicSiteAcceleration,
	"generalmediastreaming":       OptimizationType_GeneralMediaStreaming,
	"generalwebdelivery":          OptimizationType_GeneralWebDelivery,
	"largefiledownload":           OptimizationType_LargeFileDownload,
	"videoondemandmediastreaming": OptimizationType_VideoOnDemandMediaStreaming,
}

// Specifies what scenario the customer wants this CDN endpoint to optimize, e.g. Download, Media services. With this
// information we can apply scenario driven optimization.
type OptimizationType_STATUS string

const (
	OptimizationType_STATUS_DynamicSiteAcceleration     = OptimizationType_STATUS("DynamicSiteAcceleration")
	OptimizationType_STATUS_GeneralMediaStreaming       = OptimizationType_STATUS("GeneralMediaStreaming")
	OptimizationType_STATUS_GeneralWebDelivery          = OptimizationType_STATUS("GeneralWebDelivery")
	OptimizationType_STATUS_LargeFileDownload           = OptimizationType_STATUS("LargeFileDownload")
	OptimizationType_STATUS_VideoOnDemandMediaStreaming = OptimizationType_STATUS("VideoOnDemandMediaStreaming")
)

// Mapping from string to OptimizationType_STATUS
var optimizationType_STATUS_Values = map[string]OptimizationType_STATUS{
	"dynamicsiteacceleration":     OptimizationType_STATUS_DynamicSiteAcceleration,
	"generalmediastreaming":       OptimizationType_STATUS_GeneralMediaStreaming,
	"generalwebdelivery":          OptimizationType_STATUS_GeneralWebDelivery,
	"largefiledownload":           OptimizationType_STATUS_LargeFileDownload,
	"videoondemandmediastreaming": OptimizationType_STATUS_VideoOnDemandMediaStreaming,
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type ProfilesEndpointOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_ProfilesEndpointOperatorSpec populates our ProfilesEndpointOperatorSpec from the provided source ProfilesEndpointOperatorSpec
func (operator *ProfilesEndpointOperatorSpec) AssignProperties_From_ProfilesEndpointOperatorSpec(source *storage.ProfilesEndpointOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ProfilesEndpointOperatorSpec populates the provided destination ProfilesEndpointOperatorSpec from our ProfilesEndpointOperatorSpec
func (operator *ProfilesEndpointOperatorSpec) AssignProperties_To_ProfilesEndpointOperatorSpec(destination *storage.ProfilesEndpointOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines how CDN caches requests that include query strings. You can ignore any query strings when caching, bypass
// caching to prevent requests that contain query strings from being cached, or cache every request with a unique URL.
// +kubebuilder:validation:Enum={"BypassCaching","IgnoreQueryString","NotSet","UseQueryString"}
type QueryStringCachingBehavior string

const (
	QueryStringCachingBehavior_BypassCaching     = QueryStringCachingBehavior("BypassCaching")
	QueryStringCachingBehavior_IgnoreQueryString = QueryStringCachingBehavior("IgnoreQueryString")
	QueryStringCachingBehavior_NotSet            = QueryStringCachingBehavior("NotSet")
	QueryStringCachingBehavior_UseQueryString    = QueryStringCachingBehavior("UseQueryString")
)

// Mapping from string to QueryStringCachingBehavior
var queryStringCachingBehavior_Values = map[string]QueryStringCachingBehavior{
	"bypasscaching":     QueryStringCachingBehavior_BypassCaching,
	"ignorequerystring": QueryStringCachingBehavior_IgnoreQueryString,
	"notset":            QueryStringCachingBehavior_NotSet,
	"usequerystring":    QueryStringCachingBehavior_UseQueryString,
}

// Defines how CDN caches requests that include query strings. You can ignore any query strings when caching, bypass
// caching to prevent requests that contain query strings from being cached, or cache every request with a unique URL.
type QueryStringCachingBehavior_STATUS string

const (
	QueryStringCachingBehavior_STATUS_BypassCaching     = QueryStringCachingBehavior_STATUS("BypassCaching")
	QueryStringCachingBehavior_STATUS_IgnoreQueryString = QueryStringCachingBehavior_STATUS("IgnoreQueryString")
	QueryStringCachingBehavior_STATUS_NotSet            = QueryStringCachingBehavior_STATUS("NotSet")
	QueryStringCachingBehavior_STATUS_UseQueryString    = QueryStringCachingBehavior_STATUS("UseQueryString")
)

// Mapping from string to QueryStringCachingBehavior_STATUS
var queryStringCachingBehavior_STATUS_Values = map[string]QueryStringCachingBehavior_STATUS{
	"bypasscaching":     QueryStringCachingBehavior_STATUS_BypassCaching,
	"ignorequerystring": QueryStringCachingBehavior_STATUS_IgnoreQueryString,
	"notset":            QueryStringCachingBehavior_STATUS_NotSet,
	"usequerystring":    QueryStringCachingBehavior_STATUS_UseQueryString,
}

// Reference to another resource.
type ResourceReference struct {
	// Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &ResourceReference{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (reference *ResourceReference) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if reference == nil {
		return nil, nil
	}
	result := &arm.ResourceReference{}

	// Set property "Id":
	if reference.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*reference.Reference)
		if err != nil {
			return nil, err
		}
		reference1 := referenceARMID
		result.Id = &reference1
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *ResourceReference) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ResourceReference{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *ResourceReference) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(arm.ResourceReference)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ResourceReference, got %T", armInput)
	}

	// no assignment for property "Reference"

	// No error
	return nil
}

// AssignProperties_From_ResourceReference populates our ResourceReference from the provided source ResourceReference
func (reference *ResourceReference) AssignProperties_From_ResourceReference(source *storage.ResourceReference) error {

	// Reference
	if source.Reference != nil {
		referenceTemp := source.Reference.Copy()
		reference.Reference = &referenceTemp
	} else {
		reference.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ResourceReference populates the provided destination ResourceReference from our ResourceReference
func (reference *ResourceReference) AssignProperties_To_ResourceReference(destination *storage.ResourceReference) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if reference.Reference != nil {
		referenceTemp := reference.Reference.Copy()
		destination.Reference = &referenceTemp
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ResourceReference_STATUS populates our ResourceReference from the provided source ResourceReference_STATUS
func (reference *ResourceReference) Initialize_From_ResourceReference_STATUS(source *ResourceReference_STATUS) error {

	// Reference
	if source.Id != nil {
		referenceTemp := genruntime.CreateResourceReferenceFromARMID(*source.Id)
		reference.Reference = &referenceTemp
	} else {
		reference.Reference = nil
	}

	// No error
	return nil
}

// Reference to another resource.
type ResourceReference_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ResourceReference_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *ResourceReference_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ResourceReference_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *ResourceReference_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ResourceReference_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ResourceReference_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		reference.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_ResourceReference_STATUS populates our ResourceReference_STATUS from the provided source ResourceReference_STATUS
func (reference *ResourceReference_STATUS) AssignProperties_From_ResourceReference_STATUS(source *storage.ResourceReference_STATUS) error {

	// Id
	reference.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_ResourceReference_STATUS populates the provided destination ResourceReference_STATUS from our ResourceReference_STATUS
func (reference *ResourceReference_STATUS) AssignProperties_To_ResourceReference_STATUS(destination *storage.ResourceReference_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(reference.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Url signing key
type UrlSigningKey struct {
	// +kubebuilder:validation:Required
	// KeyId: Defines the customer defined key Id. This id will exist in the incoming request to indicate the key used to form
	// the hash.
	KeyId *string `json:"keyId,omitempty"`

	// +kubebuilder:validation:Required
	// KeySourceParameters: Defines the parameters for using customer key vault for Url Signing Key.
	KeySourceParameters *KeyVaultSigningKeyParameters `json:"keySourceParameters,omitempty"`
}

var _ genruntime.ARMTransformer = &UrlSigningKey{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (signingKey *UrlSigningKey) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if signingKey == nil {
		return nil, nil
	}
	result := &arm.UrlSigningKey{}

	// Set property "KeyId":
	if signingKey.KeyId != nil {
		keyId := *signingKey.KeyId
		result.KeyId = &keyId
	}

	// Set property "KeySourceParameters":
	if signingKey.KeySourceParameters != nil {
		keySourceParameters_ARM, err := (*signingKey.KeySourceParameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		keySourceParameters := *keySourceParameters_ARM.(*arm.KeyVaultSigningKeyParameters)
		result.KeySourceParameters = &keySourceParameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (signingKey *UrlSigningKey) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UrlSigningKey{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (signingKey *UrlSigningKey) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UrlSigningKey)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UrlSigningKey, got %T", armInput)
	}

	// Set property "KeyId":
	if typedInput.KeyId != nil {
		keyId := *typedInput.KeyId
		signingKey.KeyId = &keyId
	}

	// Set property "KeySourceParameters":
	if typedInput.KeySourceParameters != nil {
		var keySourceParameters1 KeyVaultSigningKeyParameters
		err := keySourceParameters1.PopulateFromARM(owner, *typedInput.KeySourceParameters)
		if err != nil {
			return err
		}
		keySourceParameters := keySourceParameters1
		signingKey.KeySourceParameters = &keySourceParameters
	}

	// No error
	return nil
}

// AssignProperties_From_UrlSigningKey populates our UrlSigningKey from the provided source UrlSigningKey
func (signingKey *UrlSigningKey) AssignProperties_From_UrlSigningKey(source *storage.UrlSigningKey) error {

	// KeyId
	signingKey.KeyId = genruntime.ClonePointerToString(source.KeyId)

	// KeySourceParameters
	if source.KeySourceParameters != nil {
		var keySourceParameter KeyVaultSigningKeyParameters
		err := keySourceParameter.AssignProperties_From_KeyVaultSigningKeyParameters(source.KeySourceParameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_KeyVaultSigningKeyParameters() to populate field KeySourceParameters")
		}
		signingKey.KeySourceParameters = &keySourceParameter
	} else {
		signingKey.KeySourceParameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlSigningKey populates the provided destination UrlSigningKey from our UrlSigningKey
func (signingKey *UrlSigningKey) AssignProperties_To_UrlSigningKey(destination *storage.UrlSigningKey) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyId
	destination.KeyId = genruntime.ClonePointerToString(signingKey.KeyId)

	// KeySourceParameters
	if signingKey.KeySourceParameters != nil {
		var keySourceParameter storage.KeyVaultSigningKeyParameters
		err := signingKey.KeySourceParameters.AssignProperties_To_KeyVaultSigningKeyParameters(&keySourceParameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_KeyVaultSigningKeyParameters() to populate field KeySourceParameters")
		}
		destination.KeySourceParameters = &keySourceParameter
	} else {
		destination.KeySourceParameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_UrlSigningKey_STATUS populates our UrlSigningKey from the provided source UrlSigningKey_STATUS
func (signingKey *UrlSigningKey) Initialize_From_UrlSigningKey_STATUS(source *UrlSigningKey_STATUS) error {

	// KeyId
	signingKey.KeyId = genruntime.ClonePointerToString(source.KeyId)

	// KeySourceParameters
	if source.KeySourceParameters != nil {
		var keySourceParameter KeyVaultSigningKeyParameters
		err := keySourceParameter.Initialize_From_KeyVaultSigningKeyParameters_STATUS(source.KeySourceParameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_KeyVaultSigningKeyParameters_STATUS() to populate field KeySourceParameters")
		}
		signingKey.KeySourceParameters = &keySourceParameter
	} else {
		signingKey.KeySourceParameters = nil
	}

	// No error
	return nil
}

// Url signing key
type UrlSigningKey_STATUS struct {
	// KeyId: Defines the customer defined key Id. This id will exist in the incoming request to indicate the key used to form
	// the hash.
	KeyId *string `json:"keyId,omitempty"`

	// KeySourceParameters: Defines the parameters for using customer key vault for Url Signing Key.
	KeySourceParameters *KeyVaultSigningKeyParameters_STATUS `json:"keySourceParameters,omitempty"`
}

var _ genruntime.FromARMConverter = &UrlSigningKey_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (signingKey *UrlSigningKey_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UrlSigningKey_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (signingKey *UrlSigningKey_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UrlSigningKey_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UrlSigningKey_STATUS, got %T", armInput)
	}

	// Set property "KeyId":
	if typedInput.KeyId != nil {
		keyId := *typedInput.KeyId
		signingKey.KeyId = &keyId
	}

	// Set property "KeySourceParameters":
	if typedInput.KeySourceParameters != nil {
		var keySourceParameters1 KeyVaultSigningKeyParameters_STATUS
		err := keySourceParameters1.PopulateFromARM(owner, *typedInput.KeySourceParameters)
		if err != nil {
			return err
		}
		keySourceParameters := keySourceParameters1
		signingKey.KeySourceParameters = &keySourceParameters
	}

	// No error
	return nil
}

// AssignProperties_From_UrlSigningKey_STATUS populates our UrlSigningKey_STATUS from the provided source UrlSigningKey_STATUS
func (signingKey *UrlSigningKey_STATUS) AssignProperties_From_UrlSigningKey_STATUS(source *storage.UrlSigningKey_STATUS) error {

	// KeyId
	signingKey.KeyId = genruntime.ClonePointerToString(source.KeyId)

	// KeySourceParameters
	if source.KeySourceParameters != nil {
		var keySourceParameter KeyVaultSigningKeyParameters_STATUS
		err := keySourceParameter.AssignProperties_From_KeyVaultSigningKeyParameters_STATUS(source.KeySourceParameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_KeyVaultSigningKeyParameters_STATUS() to populate field KeySourceParameters")
		}
		signingKey.KeySourceParameters = &keySourceParameter
	} else {
		signingKey.KeySourceParameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlSigningKey_STATUS populates the provided destination UrlSigningKey_STATUS from our UrlSigningKey_STATUS
func (signingKey *UrlSigningKey_STATUS) AssignProperties_To_UrlSigningKey_STATUS(destination *storage.UrlSigningKey_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyId
	destination.KeyId = genruntime.ClonePointerToString(signingKey.KeyId)

	// KeySourceParameters
	if signingKey.KeySourceParameters != nil {
		var keySourceParameter storage.KeyVaultSigningKeyParameters_STATUS
		err := signingKey.KeySourceParameters.AssignProperties_To_KeyVaultSigningKeyParameters_STATUS(&keySourceParameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_KeyVaultSigningKeyParameters_STATUS() to populate field KeySourceParameters")
		}
		destination.KeySourceParameters = &keySourceParameter
	} else {
		destination.KeySourceParameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// A rule that specifies a set of actions and conditions
type DeliveryRule struct {
	// +kubebuilder:validation:Required
	// Actions: A list of actions that are executed when all the conditions of a rule are satisfied.
	Actions []DeliveryRuleAction `json:"actions,omitempty"`

	// Conditions: A list of conditions that must be matched for the actions to be executed
	Conditions []DeliveryRuleCondition `json:"conditions,omitempty"`

	// Name: Name of the rule
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Order: The order in which the rules are applied for the endpoint. Possible values {0,1,2,3,………}. A rule with a
	// lesser order will be applied before a rule with a greater order. Rule with order 0 is a special rule. It does not
	// require any condition and actions listed in it will always be applied.
	Order *int `json:"order,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *DeliveryRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.DeliveryRule{}

	// Set property "Actions":
	for _, item := range rule.Actions {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Actions = append(result.Actions, *item_ARM.(*arm.DeliveryRuleAction))
	}

	// Set property "Conditions":
	for _, item := range rule.Conditions {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Conditions = append(result.Conditions, *item_ARM.(*arm.DeliveryRuleCondition))
	}

	// Set property "Name":
	if rule.Name != nil {
		name := *rule.Name
		result.Name = &name
	}

	// Set property "Order":
	if rule.Order != nil {
		order := *rule.Order
		result.Order = &order
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *DeliveryRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *DeliveryRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRule, got %T", armInput)
	}

	// Set property "Actions":
	for _, item := range typedInput.Actions {
		var item1 DeliveryRuleAction
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		rule.Actions = append(rule.Actions, item1)
	}

	// Set property "Conditions":
	for _, item := range typedInput.Conditions {
		var item1 DeliveryRuleCondition
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		rule.Conditions = append(rule.Conditions, item1)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property "Order":
	if typedInput.Order != nil {
		order := *typedInput.Order
		rule.Order = &order
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRule populates our DeliveryRule from the provided source DeliveryRule
func (rule *DeliveryRule) AssignProperties_From_DeliveryRule(source *storage.DeliveryRule) error {

	// Actions
	if source.Actions != nil {
		actionList := make([]DeliveryRuleAction, len(source.Actions))
		for actionIndex, actionItem := range source.Actions {
			// Shadow the loop variable to avoid aliasing
			actionItem := actionItem
			var action DeliveryRuleAction
			err := action.AssignProperties_From_DeliveryRuleAction(&actionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleAction() to populate field Actions")
			}
			actionList[actionIndex] = action
		}
		rule.Actions = actionList
	} else {
		rule.Actions = nil
	}

	// Conditions
	if source.Conditions != nil {
		conditionList := make([]DeliveryRuleCondition, len(source.Conditions))
		for conditionIndex, conditionItem := range source.Conditions {
			// Shadow the loop variable to avoid aliasing
			conditionItem := conditionItem
			var condition DeliveryRuleCondition
			err := condition.AssignProperties_From_DeliveryRuleCondition(&conditionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleCondition() to populate field Conditions")
			}
			conditionList[conditionIndex] = condition
		}
		rule.Conditions = conditionList
	} else {
		rule.Conditions = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Order
	rule.Order = genruntime.ClonePointerToInt(source.Order)

	// No error
	return nil
}

// AssignProperties_To_DeliveryRule populates the provided destination DeliveryRule from our DeliveryRule
func (rule *DeliveryRule) AssignProperties_To_DeliveryRule(destination *storage.DeliveryRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Actions
	if rule.Actions != nil {
		actionList := make([]storage.DeliveryRuleAction, len(rule.Actions))
		for actionIndex, actionItem := range rule.Actions {
			// Shadow the loop variable to avoid aliasing
			actionItem := actionItem
			var action storage.DeliveryRuleAction
			err := actionItem.AssignProperties_To_DeliveryRuleAction(&action)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleAction() to populate field Actions")
			}
			actionList[actionIndex] = action
		}
		destination.Actions = actionList
	} else {
		destination.Actions = nil
	}

	// Conditions
	if rule.Conditions != nil {
		conditionList := make([]storage.DeliveryRuleCondition, len(rule.Conditions))
		for conditionIndex, conditionItem := range rule.Conditions {
			// Shadow the loop variable to avoid aliasing
			conditionItem := conditionItem
			var condition storage.DeliveryRuleCondition
			err := conditionItem.AssignProperties_To_DeliveryRuleCondition(&condition)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleCondition() to populate field Conditions")
			}
			conditionList[conditionIndex] = condition
		}
		destination.Conditions = conditionList
	} else {
		destination.Conditions = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Order
	destination.Order = genruntime.ClonePointerToInt(rule.Order)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRule_STATUS populates our DeliveryRule from the provided source DeliveryRule_STATUS
func (rule *DeliveryRule) Initialize_From_DeliveryRule_STATUS(source *DeliveryRule_STATUS) error {

	// Actions
	if source.Actions != nil {
		actionList := make([]DeliveryRuleAction, len(source.Actions))
		for actionIndex, actionItem := range source.Actions {
			// Shadow the loop variable to avoid aliasing
			actionItem := actionItem
			var action DeliveryRuleAction
			err := action.Initialize_From_DeliveryRuleAction_STATUS(&actionItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_DeliveryRuleAction_STATUS() to populate field Actions")
			}
			actionList[actionIndex] = action
		}
		rule.Actions = actionList
	} else {
		rule.Actions = nil
	}

	// Conditions
	if source.Conditions != nil {
		conditionList := make([]DeliveryRuleCondition, len(source.Conditions))
		for conditionIndex, conditionItem := range source.Conditions {
			// Shadow the loop variable to avoid aliasing
			conditionItem := conditionItem
			var condition DeliveryRuleCondition
			err := condition.Initialize_From_DeliveryRuleCondition_STATUS(&conditionItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_DeliveryRuleCondition_STATUS() to populate field Conditions")
			}
			conditionList[conditionIndex] = condition
		}
		rule.Conditions = conditionList
	} else {
		rule.Conditions = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Order
	rule.Order = genruntime.ClonePointerToInt(source.Order)

	// No error
	return nil
}

// A rule that specifies a set of actions and conditions
type DeliveryRule_STATUS struct {
	// Actions: A list of actions that are executed when all the conditions of a rule are satisfied.
	Actions []DeliveryRuleAction_STATUS `json:"actions,omitempty"`

	// Conditions: A list of conditions that must be matched for the actions to be executed
	Conditions []DeliveryRuleCondition_STATUS `json:"conditions,omitempty"`

	// Name: Name of the rule
	Name *string `json:"name,omitempty"`

	// Order: The order in which the rules are applied for the endpoint. Possible values {0,1,2,3,………}. A rule with a
	// lesser order will be applied before a rule with a greater order. Rule with order 0 is a special rule. It does not
	// require any condition and actions listed in it will always be applied.
	Order *int `json:"order,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *DeliveryRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *DeliveryRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRule_STATUS, got %T", armInput)
	}

	// Set property "Actions":
	for _, item := range typedInput.Actions {
		var item1 DeliveryRuleAction_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		rule.Actions = append(rule.Actions, item1)
	}

	// no assignment for property "Conditions"

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property "Order":
	if typedInput.Order != nil {
		order := *typedInput.Order
		rule.Order = &order
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRule_STATUS populates our DeliveryRule_STATUS from the provided source DeliveryRule_STATUS
func (rule *DeliveryRule_STATUS) AssignProperties_From_DeliveryRule_STATUS(source *storage.DeliveryRule_STATUS) error {

	// Actions
	if source.Actions != nil {
		actionList := make([]DeliveryRuleAction_STATUS, len(source.Actions))
		for actionIndex, actionItem := range source.Actions {
			// Shadow the loop variable to avoid aliasing
			actionItem := actionItem
			var action DeliveryRuleAction_STATUS
			err := action.AssignProperties_From_DeliveryRuleAction_STATUS(&actionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleAction_STATUS() to populate field Actions")
			}
			actionList[actionIndex] = action
		}
		rule.Actions = actionList
	} else {
		rule.Actions = nil
	}

	// Conditions
	if source.Conditions != nil {
		conditionList := make([]DeliveryRuleCondition_STATUS, len(source.Conditions))
		for conditionIndex, conditionItem := range source.Conditions {
			// Shadow the loop variable to avoid aliasing
			conditionItem := conditionItem
			var condition DeliveryRuleCondition_STATUS
			err := condition.AssignProperties_From_DeliveryRuleCondition_STATUS(&conditionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleCondition_STATUS() to populate field Conditions")
			}
			conditionList[conditionIndex] = condition
		}
		rule.Conditions = conditionList
	} else {
		rule.Conditions = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Order
	rule.Order = genruntime.ClonePointerToInt(source.Order)

	// No error
	return nil
}

// AssignProperties_To_DeliveryRule_STATUS populates the provided destination DeliveryRule_STATUS from our DeliveryRule_STATUS
func (rule *DeliveryRule_STATUS) AssignProperties_To_DeliveryRule_STATUS(destination *storage.DeliveryRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Actions
	if rule.Actions != nil {
		actionList := make([]storage.DeliveryRuleAction_STATUS, len(rule.Actions))
		for actionIndex, actionItem := range rule.Actions {
			// Shadow the loop variable to avoid aliasing
			actionItem := actionItem
			var action storage.DeliveryRuleAction_STATUS
			err := actionItem.AssignProperties_To_DeliveryRuleAction_STATUS(&action)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleAction_STATUS() to populate field Actions")
			}
			actionList[actionIndex] = action
		}
		destination.Actions = actionList
	} else {
		destination.Actions = nil
	}

	// Conditions
	if rule.Conditions != nil {
		conditionList := make([]storage.DeliveryRuleCondition_STATUS, len(rule.Conditions))
		for conditionIndex, conditionItem := range rule.Conditions {
			// Shadow the loop variable to avoid aliasing
			conditionItem := conditionItem
			var condition storage.DeliveryRuleCondition_STATUS
			err := conditionItem.AssignProperties_To_DeliveryRuleCondition_STATUS(&condition)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleCondition_STATUS() to populate field Conditions")
			}
			conditionList[conditionIndex] = condition
		}
		destination.Conditions = conditionList
	} else {
		destination.Conditions = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Order
	destination.Order = genruntime.ClonePointerToInt(rule.Order)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Allow","Block"}
type GeoFilter_Action string

const (
	GeoFilter_Action_Allow = GeoFilter_Action("Allow")
	GeoFilter_Action_Block = GeoFilter_Action("Block")
)

// Mapping from string to GeoFilter_Action
var geoFilter_Action_Values = map[string]GeoFilter_Action{
	"allow": GeoFilter_Action_Allow,
	"block": GeoFilter_Action_Block,
}

type GeoFilter_Action_STATUS string

const (
	GeoFilter_Action_STATUS_Allow = GeoFilter_Action_STATUS("Allow")
	GeoFilter_Action_STATUS_Block = GeoFilter_Action_STATUS("Block")
)

// Mapping from string to GeoFilter_Action_STATUS
var geoFilter_Action_STATUS_Values = map[string]GeoFilter_Action_STATUS{
	"allow": GeoFilter_Action_STATUS_Allow,
	"block": GeoFilter_Action_STATUS_Block,
}

// The JSON object that contains the properties to send health probes to origin.
type HealthProbeParameters struct {
	// +kubebuilder:validation:Maximum=255
	// +kubebuilder:validation:Minimum=1
	// ProbeIntervalInSeconds: The number of seconds between health probes.Default is 240sec.
	ProbeIntervalInSeconds *int `json:"probeIntervalInSeconds,omitempty"`

	// ProbePath: The path relative to the origin that is used to determine the health of the origin.
	ProbePath *string `json:"probePath,omitempty"`

	// ProbeProtocol: Protocol to use for health probe.
	ProbeProtocol *HealthProbeParameters_ProbeProtocol `json:"probeProtocol,omitempty"`

	// ProbeRequestType: The type of health probe request that is made.
	ProbeRequestType *HealthProbeParameters_ProbeRequestType `json:"probeRequestType,omitempty"`
}

var _ genruntime.ARMTransformer = &HealthProbeParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *HealthProbeParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.HealthProbeParameters{}

	// Set property "ProbeIntervalInSeconds":
	if parameters.ProbeIntervalInSeconds != nil {
		probeIntervalInSeconds := *parameters.ProbeIntervalInSeconds
		result.ProbeIntervalInSeconds = &probeIntervalInSeconds
	}

	// Set property "ProbePath":
	if parameters.ProbePath != nil {
		probePath := *parameters.ProbePath
		result.ProbePath = &probePath
	}

	// Set property "ProbeProtocol":
	if parameters.ProbeProtocol != nil {
		var temp string
		temp = string(*parameters.ProbeProtocol)
		probeProtocol := arm.HealthProbeParameters_ProbeProtocol(temp)
		result.ProbeProtocol = &probeProtocol
	}

	// Set property "ProbeRequestType":
	if parameters.ProbeRequestType != nil {
		var temp string
		temp = string(*parameters.ProbeRequestType)
		probeRequestType := arm.HealthProbeParameters_ProbeRequestType(temp)
		result.ProbeRequestType = &probeRequestType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *HealthProbeParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HealthProbeParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *HealthProbeParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HealthProbeParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HealthProbeParameters, got %T", armInput)
	}

	// Set property "ProbeIntervalInSeconds":
	if typedInput.ProbeIntervalInSeconds != nil {
		probeIntervalInSeconds := *typedInput.ProbeIntervalInSeconds
		parameters.ProbeIntervalInSeconds = &probeIntervalInSeconds
	}

	// Set property "ProbePath":
	if typedInput.ProbePath != nil {
		probePath := *typedInput.ProbePath
		parameters.ProbePath = &probePath
	}

	// Set property "ProbeProtocol":
	if typedInput.ProbeProtocol != nil {
		var temp string
		temp = string(*typedInput.ProbeProtocol)
		probeProtocol := HealthProbeParameters_ProbeProtocol(temp)
		parameters.ProbeProtocol = &probeProtocol
	}

	// Set property "ProbeRequestType":
	if typedInput.ProbeRequestType != nil {
		var temp string
		temp = string(*typedInput.ProbeRequestType)
		probeRequestType := HealthProbeParameters_ProbeRequestType(temp)
		parameters.ProbeRequestType = &probeRequestType
	}

	// No error
	return nil
}

// AssignProperties_From_HealthProbeParameters populates our HealthProbeParameters from the provided source HealthProbeParameters
func (parameters *HealthProbeParameters) AssignProperties_From_HealthProbeParameters(source *storage.HealthProbeParameters) error {

	// ProbeIntervalInSeconds
	if source.ProbeIntervalInSeconds != nil {
		probeIntervalInSecond := *source.ProbeIntervalInSeconds
		parameters.ProbeIntervalInSeconds = &probeIntervalInSecond
	} else {
		parameters.ProbeIntervalInSeconds = nil
	}

	// ProbePath
	parameters.ProbePath = genruntime.ClonePointerToString(source.ProbePath)

	// ProbeProtocol
	if source.ProbeProtocol != nil {
		probeProtocol := *source.ProbeProtocol
		probeProtocolTemp := genruntime.ToEnum(probeProtocol, healthProbeParameters_ProbeProtocol_Values)
		parameters.ProbeProtocol = &probeProtocolTemp
	} else {
		parameters.ProbeProtocol = nil
	}

	// ProbeRequestType
	if source.ProbeRequestType != nil {
		probeRequestType := *source.ProbeRequestType
		probeRequestTypeTemp := genruntime.ToEnum(probeRequestType, healthProbeParameters_ProbeRequestType_Values)
		parameters.ProbeRequestType = &probeRequestTypeTemp
	} else {
		parameters.ProbeRequestType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_HealthProbeParameters populates the provided destination HealthProbeParameters from our HealthProbeParameters
func (parameters *HealthProbeParameters) AssignProperties_To_HealthProbeParameters(destination *storage.HealthProbeParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ProbeIntervalInSeconds
	if parameters.ProbeIntervalInSeconds != nil {
		probeIntervalInSecond := *parameters.ProbeIntervalInSeconds
		destination.ProbeIntervalInSeconds = &probeIntervalInSecond
	} else {
		destination.ProbeIntervalInSeconds = nil
	}

	// ProbePath
	destination.ProbePath = genruntime.ClonePointerToString(parameters.ProbePath)

	// ProbeProtocol
	if parameters.ProbeProtocol != nil {
		probeProtocol := string(*parameters.ProbeProtocol)
		destination.ProbeProtocol = &probeProtocol
	} else {
		destination.ProbeProtocol = nil
	}

	// ProbeRequestType
	if parameters.ProbeRequestType != nil {
		probeRequestType := string(*parameters.ProbeRequestType)
		destination.ProbeRequestType = &probeRequestType
	} else {
		destination.ProbeRequestType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_HealthProbeParameters_STATUS populates our HealthProbeParameters from the provided source HealthProbeParameters_STATUS
func (parameters *HealthProbeParameters) Initialize_From_HealthProbeParameters_STATUS(source *HealthProbeParameters_STATUS) error {

	// ProbeIntervalInSeconds
	if source.ProbeIntervalInSeconds != nil {
		probeIntervalInSecond := *source.ProbeIntervalInSeconds
		parameters.ProbeIntervalInSeconds = &probeIntervalInSecond
	} else {
		parameters.ProbeIntervalInSeconds = nil
	}

	// ProbePath
	parameters.ProbePath = genruntime.ClonePointerToString(source.ProbePath)

	// ProbeProtocol
	if source.ProbeProtocol != nil {
		probeProtocol := genruntime.ToEnum(string(*source.ProbeProtocol), healthProbeParameters_ProbeProtocol_Values)
		parameters.ProbeProtocol = &probeProtocol
	} else {
		parameters.ProbeProtocol = nil
	}

	// ProbeRequestType
	if source.ProbeRequestType != nil {
		probeRequestType := genruntime.ToEnum(string(*source.ProbeRequestType), healthProbeParameters_ProbeRequestType_Values)
		parameters.ProbeRequestType = &probeRequestType
	} else {
		parameters.ProbeRequestType = nil
	}

	// No error
	return nil
}

// The JSON object that contains the properties to send health probes to origin.
type HealthProbeParameters_STATUS struct {
	// ProbeIntervalInSeconds: The number of seconds between health probes.Default is 240sec.
	ProbeIntervalInSeconds *int `json:"probeIntervalInSeconds,omitempty"`

	// ProbePath: The path relative to the origin that is used to determine the health of the origin.
	ProbePath *string `json:"probePath,omitempty"`

	// ProbeProtocol: Protocol to use for health probe.
	ProbeProtocol *HealthProbeParameters_ProbeProtocol_STATUS `json:"probeProtocol,omitempty"`

	// ProbeRequestType: The type of health probe request that is made.
	ProbeRequestType *HealthProbeParameters_ProbeRequestType_STATUS `json:"probeRequestType,omitempty"`
}

var _ genruntime.FromARMConverter = &HealthProbeParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *HealthProbeParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HealthProbeParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *HealthProbeParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HealthProbeParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HealthProbeParameters_STATUS, got %T", armInput)
	}

	// Set property "ProbeIntervalInSeconds":
	if typedInput.ProbeIntervalInSeconds != nil {
		probeIntervalInSeconds := *typedInput.ProbeIntervalInSeconds
		parameters.ProbeIntervalInSeconds = &probeIntervalInSeconds
	}

	// Set property "ProbePath":
	if typedInput.ProbePath != nil {
		probePath := *typedInput.ProbePath
		parameters.ProbePath = &probePath
	}

	// Set property "ProbeProtocol":
	if typedInput.ProbeProtocol != nil {
		var temp string
		temp = string(*typedInput.ProbeProtocol)
		probeProtocol := HealthProbeParameters_ProbeProtocol_STATUS(temp)
		parameters.ProbeProtocol = &probeProtocol
	}

	// Set property "ProbeRequestType":
	if typedInput.ProbeRequestType != nil {
		var temp string
		temp = string(*typedInput.ProbeRequestType)
		probeRequestType := HealthProbeParameters_ProbeRequestType_STATUS(temp)
		parameters.ProbeRequestType = &probeRequestType
	}

	// No error
	return nil
}

// AssignProperties_From_HealthProbeParameters_STATUS populates our HealthProbeParameters_STATUS from the provided source HealthProbeParameters_STATUS
func (parameters *HealthProbeParameters_STATUS) AssignProperties_From_HealthProbeParameters_STATUS(source *storage.HealthProbeParameters_STATUS) error {

	// ProbeIntervalInSeconds
	parameters.ProbeIntervalInSeconds = genruntime.ClonePointerToInt(source.ProbeIntervalInSeconds)

	// ProbePath
	parameters.ProbePath = genruntime.ClonePointerToString(source.ProbePath)

	// ProbeProtocol
	if source.ProbeProtocol != nil {
		probeProtocol := *source.ProbeProtocol
		probeProtocolTemp := genruntime.ToEnum(probeProtocol, healthProbeParameters_ProbeProtocol_STATUS_Values)
		parameters.ProbeProtocol = &probeProtocolTemp
	} else {
		parameters.ProbeProtocol = nil
	}

	// ProbeRequestType
	if source.ProbeRequestType != nil {
		probeRequestType := *source.ProbeRequestType
		probeRequestTypeTemp := genruntime.ToEnum(probeRequestType, healthProbeParameters_ProbeRequestType_STATUS_Values)
		parameters.ProbeRequestType = &probeRequestTypeTemp
	} else {
		parameters.ProbeRequestType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_HealthProbeParameters_STATUS populates the provided destination HealthProbeParameters_STATUS from our HealthProbeParameters_STATUS
func (parameters *HealthProbeParameters_STATUS) AssignProperties_To_HealthProbeParameters_STATUS(destination *storage.HealthProbeParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ProbeIntervalInSeconds
	destination.ProbeIntervalInSeconds = genruntime.ClonePointerToInt(parameters.ProbeIntervalInSeconds)

	// ProbePath
	destination.ProbePath = genruntime.ClonePointerToString(parameters.ProbePath)

	// ProbeProtocol
	if parameters.ProbeProtocol != nil {
		probeProtocol := string(*parameters.ProbeProtocol)
		destination.ProbeProtocol = &probeProtocol
	} else {
		destination.ProbeProtocol = nil
	}

	// ProbeRequestType
	if parameters.ProbeRequestType != nil {
		probeRequestType := string(*parameters.ProbeRequestType)
		destination.ProbeRequestType = &probeRequestType
	} else {
		destination.ProbeRequestType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes the parameters for using a user's KeyVault for URL Signing Key.
type KeyVaultSigningKeyParameters struct {
	// +kubebuilder:validation:Required
	// ResourceGroupName: Resource group of the user's Key Vault containing the secret
	ResourceGroupName *string `json:"resourceGroupName,omitempty"`

	// +kubebuilder:validation:Required
	// SecretName: The name of secret in Key Vault.
	SecretName *string `json:"secretName,omitempty"`

	// +kubebuilder:validation:Required
	// SecretVersion: The version(GUID) of secret in Key Vault.
	SecretVersion *string `json:"secretVersion,omitempty"`

	// +kubebuilder:validation:Required
	// SubscriptionId: Subscription Id of the user's Key Vault containing the secret
	SubscriptionId *string `json:"subscriptionId,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *KeyVaultSigningKeyParameters_TypeName `json:"typeName,omitempty"`

	// +kubebuilder:validation:Required
	// VaultName: The name of the user's Key Vault containing the secret
	VaultName *string `json:"vaultName,omitempty"`
}

var _ genruntime.ARMTransformer = &KeyVaultSigningKeyParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *KeyVaultSigningKeyParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.KeyVaultSigningKeyParameters{}

	// Set property "ResourceGroupName":
	if parameters.ResourceGroupName != nil {
		resourceGroupName := *parameters.ResourceGroupName
		result.ResourceGroupName = &resourceGroupName
	}

	// Set property "SecretName":
	if parameters.SecretName != nil {
		secretName := *parameters.SecretName
		result.SecretName = &secretName
	}

	// Set property "SecretVersion":
	if parameters.SecretVersion != nil {
		secretVersion := *parameters.SecretVersion
		result.SecretVersion = &secretVersion
	}

	// Set property "SubscriptionId":
	if parameters.SubscriptionId != nil {
		subscriptionId := *parameters.SubscriptionId
		result.SubscriptionId = &subscriptionId
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		var temp string
		temp = string(*parameters.TypeName)
		typeName := arm.KeyVaultSigningKeyParameters_TypeName(temp)
		result.TypeName = &typeName
	}

	// Set property "VaultName":
	if parameters.VaultName != nil {
		vaultName := *parameters.VaultName
		result.VaultName = &vaultName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *KeyVaultSigningKeyParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KeyVaultSigningKeyParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *KeyVaultSigningKeyParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KeyVaultSigningKeyParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KeyVaultSigningKeyParameters, got %T", armInput)
	}

	// Set property "ResourceGroupName":
	if typedInput.ResourceGroupName != nil {
		resourceGroupName := *typedInput.ResourceGroupName
		parameters.ResourceGroupName = &resourceGroupName
	}

	// Set property "SecretName":
	if typedInput.SecretName != nil {
		secretName := *typedInput.SecretName
		parameters.SecretName = &secretName
	}

	// Set property "SecretVersion":
	if typedInput.SecretVersion != nil {
		secretVersion := *typedInput.SecretVersion
		parameters.SecretVersion = &secretVersion
	}

	// Set property "SubscriptionId":
	if typedInput.SubscriptionId != nil {
		subscriptionId := *typedInput.SubscriptionId
		parameters.SubscriptionId = &subscriptionId
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := KeyVaultSigningKeyParameters_TypeName(temp)
		parameters.TypeName = &typeName
	}

	// Set property "VaultName":
	if typedInput.VaultName != nil {
		vaultName := *typedInput.VaultName
		parameters.VaultName = &vaultName
	}

	// No error
	return nil
}

// AssignProperties_From_KeyVaultSigningKeyParameters populates our KeyVaultSigningKeyParameters from the provided source KeyVaultSigningKeyParameters
func (parameters *KeyVaultSigningKeyParameters) AssignProperties_From_KeyVaultSigningKeyParameters(source *storage.KeyVaultSigningKeyParameters) error {

	// ResourceGroupName
	parameters.ResourceGroupName = genruntime.ClonePointerToString(source.ResourceGroupName)

	// SecretName
	parameters.SecretName = genruntime.ClonePointerToString(source.SecretName)

	// SecretVersion
	parameters.SecretVersion = genruntime.ClonePointerToString(source.SecretVersion)

	// SubscriptionId
	parameters.SubscriptionId = genruntime.ClonePointerToString(source.SubscriptionId)

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, keyVaultSigningKeyParameters_TypeName_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// VaultName
	parameters.VaultName = genruntime.ClonePointerToString(source.VaultName)

	// No error
	return nil
}

// AssignProperties_To_KeyVaultSigningKeyParameters populates the provided destination KeyVaultSigningKeyParameters from our KeyVaultSigningKeyParameters
func (parameters *KeyVaultSigningKeyParameters) AssignProperties_To_KeyVaultSigningKeyParameters(destination *storage.KeyVaultSigningKeyParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ResourceGroupName
	destination.ResourceGroupName = genruntime.ClonePointerToString(parameters.ResourceGroupName)

	// SecretName
	destination.SecretName = genruntime.ClonePointerToString(parameters.SecretName)

	// SecretVersion
	destination.SecretVersion = genruntime.ClonePointerToString(parameters.SecretVersion)

	// SubscriptionId
	destination.SubscriptionId = genruntime.ClonePointerToString(parameters.SubscriptionId)

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// VaultName
	destination.VaultName = genruntime.ClonePointerToString(parameters.VaultName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_KeyVaultSigningKeyParameters_STATUS populates our KeyVaultSigningKeyParameters from the provided source KeyVaultSigningKeyParameters_STATUS
func (parameters *KeyVaultSigningKeyParameters) Initialize_From_KeyVaultSigningKeyParameters_STATUS(source *KeyVaultSigningKeyParameters_STATUS) error {

	// ResourceGroupName
	parameters.ResourceGroupName = genruntime.ClonePointerToString(source.ResourceGroupName)

	// SecretName
	parameters.SecretName = genruntime.ClonePointerToString(source.SecretName)

	// SecretVersion
	parameters.SecretVersion = genruntime.ClonePointerToString(source.SecretVersion)

	// SubscriptionId
	parameters.SubscriptionId = genruntime.ClonePointerToString(source.SubscriptionId)

	// TypeName
	if source.TypeName != nil {
		typeName := genruntime.ToEnum(string(*source.TypeName), keyVaultSigningKeyParameters_TypeName_Values)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// VaultName
	parameters.VaultName = genruntime.ClonePointerToString(source.VaultName)

	// No error
	return nil
}

// Describes the parameters for using a user's KeyVault for URL Signing Key.
type KeyVaultSigningKeyParameters_STATUS struct {
	// ResourceGroupName: Resource group of the user's Key Vault containing the secret
	ResourceGroupName *string `json:"resourceGroupName,omitempty"`

	// SecretName: The name of secret in Key Vault.
	SecretName *string `json:"secretName,omitempty"`

	// SecretVersion: The version(GUID) of secret in Key Vault.
	SecretVersion *string `json:"secretVersion,omitempty"`

	// SubscriptionId: Subscription Id of the user's Key Vault containing the secret
	SubscriptionId *string                                       `json:"subscriptionId,omitempty"`
	TypeName       *KeyVaultSigningKeyParameters_TypeName_STATUS `json:"typeName,omitempty"`

	// VaultName: The name of the user's Key Vault containing the secret
	VaultName *string `json:"vaultName,omitempty"`
}

var _ genruntime.FromARMConverter = &KeyVaultSigningKeyParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *KeyVaultSigningKeyParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KeyVaultSigningKeyParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *KeyVaultSigningKeyParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KeyVaultSigningKeyParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KeyVaultSigningKeyParameters_STATUS, got %T", armInput)
	}

	// Set property "ResourceGroupName":
	if typedInput.ResourceGroupName != nil {
		resourceGroupName := *typedInput.ResourceGroupName
		parameters.ResourceGroupName = &resourceGroupName
	}

	// Set property "SecretName":
	if typedInput.SecretName != nil {
		secretName := *typedInput.SecretName
		parameters.SecretName = &secretName
	}

	// Set property "SecretVersion":
	if typedInput.SecretVersion != nil {
		secretVersion := *typedInput.SecretVersion
		parameters.SecretVersion = &secretVersion
	}

	// Set property "SubscriptionId":
	if typedInput.SubscriptionId != nil {
		subscriptionId := *typedInput.SubscriptionId
		parameters.SubscriptionId = &subscriptionId
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := KeyVaultSigningKeyParameters_TypeName_STATUS(temp)
		parameters.TypeName = &typeName
	}

	// Set property "VaultName":
	if typedInput.VaultName != nil {
		vaultName := *typedInput.VaultName
		parameters.VaultName = &vaultName
	}

	// No error
	return nil
}

// AssignProperties_From_KeyVaultSigningKeyParameters_STATUS populates our KeyVaultSigningKeyParameters_STATUS from the provided source KeyVaultSigningKeyParameters_STATUS
func (parameters *KeyVaultSigningKeyParameters_STATUS) AssignProperties_From_KeyVaultSigningKeyParameters_STATUS(source *storage.KeyVaultSigningKeyParameters_STATUS) error {

	// ResourceGroupName
	parameters.ResourceGroupName = genruntime.ClonePointerToString(source.ResourceGroupName)

	// SecretName
	parameters.SecretName = genruntime.ClonePointerToString(source.SecretName)

	// SecretVersion
	parameters.SecretVersion = genruntime.ClonePointerToString(source.SecretVersion)

	// SubscriptionId
	parameters.SubscriptionId = genruntime.ClonePointerToString(source.SubscriptionId)

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, keyVaultSigningKeyParameters_TypeName_STATUS_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// VaultName
	parameters.VaultName = genruntime.ClonePointerToString(source.VaultName)

	// No error
	return nil
}

// AssignProperties_To_KeyVaultSigningKeyParameters_STATUS populates the provided destination KeyVaultSigningKeyParameters_STATUS from our KeyVaultSigningKeyParameters_STATUS
func (parameters *KeyVaultSigningKeyParameters_STATUS) AssignProperties_To_KeyVaultSigningKeyParameters_STATUS(destination *storage.KeyVaultSigningKeyParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ResourceGroupName
	destination.ResourceGroupName = genruntime.ClonePointerToString(parameters.ResourceGroupName)

	// SecretName
	destination.SecretName = genruntime.ClonePointerToString(parameters.SecretName)

	// SecretVersion
	destination.SecretVersion = genruntime.ClonePointerToString(parameters.SecretVersion)

	// SubscriptionId
	destination.SubscriptionId = genruntime.ClonePointerToString(parameters.SubscriptionId)

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// VaultName
	destination.VaultName = genruntime.ClonePointerToString(parameters.VaultName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The approval status for the connection to the Private Link
type PrivateEndpointStatus_STATUS string

const (
	PrivateEndpointStatus_STATUS_Approved     = PrivateEndpointStatus_STATUS("Approved")
	PrivateEndpointStatus_STATUS_Disconnected = PrivateEndpointStatus_STATUS("Disconnected")
	PrivateEndpointStatus_STATUS_Pending      = PrivateEndpointStatus_STATUS("Pending")
	PrivateEndpointStatus_STATUS_Rejected     = PrivateEndpointStatus_STATUS("Rejected")
	PrivateEndpointStatus_STATUS_Timeout      = PrivateEndpointStatus_STATUS("Timeout")
)

// Mapping from string to PrivateEndpointStatus_STATUS
var privateEndpointStatus_STATUS_Values = map[string]PrivateEndpointStatus_STATUS{
	"approved":     PrivateEndpointStatus_STATUS_Approved,
	"disconnected": PrivateEndpointStatus_STATUS_Disconnected,
	"pending":      PrivateEndpointStatus_STATUS_Pending,
	"rejected":     PrivateEndpointStatus_STATUS_Rejected,
	"timeout":      PrivateEndpointStatus_STATUS_Timeout,
}

// The JSON object that contains the properties to determine origin health using real requests/responses.
type ResponseBasedOriginErrorDetectionParameters struct {
	// HttpErrorRanges: The list of Http status code ranges that are considered as server errors for origin and it is marked as
	// unhealthy.
	HttpErrorRanges []HttpErrorRangeParameters `json:"httpErrorRanges,omitempty"`

	// ResponseBasedDetectedErrorTypes: Type of response errors for real user requests for which origin will be deemed unhealthy
	ResponseBasedDetectedErrorTypes *ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes `json:"responseBasedDetectedErrorTypes,omitempty"`

	// +kubebuilder:validation:Maximum=100
	// +kubebuilder:validation:Minimum=0
	// ResponseBasedFailoverThresholdPercentage: The percentage of failed requests in the sample where failover should trigger.
	ResponseBasedFailoverThresholdPercentage *int `json:"responseBasedFailoverThresholdPercentage,omitempty"`
}

var _ genruntime.ARMTransformer = &ResponseBasedOriginErrorDetectionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *ResponseBasedOriginErrorDetectionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.ResponseBasedOriginErrorDetectionParameters{}

	// Set property "HttpErrorRanges":
	for _, item := range parameters.HttpErrorRanges {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.HttpErrorRanges = append(result.HttpErrorRanges, *item_ARM.(*arm.HttpErrorRangeParameters))
	}

	// Set property "ResponseBasedDetectedErrorTypes":
	if parameters.ResponseBasedDetectedErrorTypes != nil {
		var temp string
		temp = string(*parameters.ResponseBasedDetectedErrorTypes)
		responseBasedDetectedErrorTypes := arm.ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes(temp)
		result.ResponseBasedDetectedErrorTypes = &responseBasedDetectedErrorTypes
	}

	// Set property "ResponseBasedFailoverThresholdPercentage":
	if parameters.ResponseBasedFailoverThresholdPercentage != nil {
		responseBasedFailoverThresholdPercentage := *parameters.ResponseBasedFailoverThresholdPercentage
		result.ResponseBasedFailoverThresholdPercentage = &responseBasedFailoverThresholdPercentage
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *ResponseBasedOriginErrorDetectionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ResponseBasedOriginErrorDetectionParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *ResponseBasedOriginErrorDetectionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ResponseBasedOriginErrorDetectionParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ResponseBasedOriginErrorDetectionParameters, got %T", armInput)
	}

	// Set property "HttpErrorRanges":
	for _, item := range typedInput.HttpErrorRanges {
		var item1 HttpErrorRangeParameters
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		parameters.HttpErrorRanges = append(parameters.HttpErrorRanges, item1)
	}

	// Set property "ResponseBasedDetectedErrorTypes":
	if typedInput.ResponseBasedDetectedErrorTypes != nil {
		var temp string
		temp = string(*typedInput.ResponseBasedDetectedErrorTypes)
		responseBasedDetectedErrorTypes := ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes(temp)
		parameters.ResponseBasedDetectedErrorTypes = &responseBasedDetectedErrorTypes
	}

	// Set property "ResponseBasedFailoverThresholdPercentage":
	if typedInput.ResponseBasedFailoverThresholdPercentage != nil {
		responseBasedFailoverThresholdPercentage := *typedInput.ResponseBasedFailoverThresholdPercentage
		parameters.ResponseBasedFailoverThresholdPercentage = &responseBasedFailoverThresholdPercentage
	}

	// No error
	return nil
}

// AssignProperties_From_ResponseBasedOriginErrorDetectionParameters populates our ResponseBasedOriginErrorDetectionParameters from the provided source ResponseBasedOriginErrorDetectionParameters
func (parameters *ResponseBasedOriginErrorDetectionParameters) AssignProperties_From_ResponseBasedOriginErrorDetectionParameters(source *storage.ResponseBasedOriginErrorDetectionParameters) error {

	// HttpErrorRanges
	if source.HttpErrorRanges != nil {
		httpErrorRangeList := make([]HttpErrorRangeParameters, len(source.HttpErrorRanges))
		for httpErrorRangeIndex, httpErrorRangeItem := range source.HttpErrorRanges {
			// Shadow the loop variable to avoid aliasing
			httpErrorRangeItem := httpErrorRangeItem
			var httpErrorRange HttpErrorRangeParameters
			err := httpErrorRange.AssignProperties_From_HttpErrorRangeParameters(&httpErrorRangeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_HttpErrorRangeParameters() to populate field HttpErrorRanges")
			}
			httpErrorRangeList[httpErrorRangeIndex] = httpErrorRange
		}
		parameters.HttpErrorRanges = httpErrorRangeList
	} else {
		parameters.HttpErrorRanges = nil
	}

	// ResponseBasedDetectedErrorTypes
	if source.ResponseBasedDetectedErrorTypes != nil {
		responseBasedDetectedErrorType := *source.ResponseBasedDetectedErrorTypes
		responseBasedDetectedErrorTypeTemp := genruntime.ToEnum(responseBasedDetectedErrorType, responseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_Values)
		parameters.ResponseBasedDetectedErrorTypes = &responseBasedDetectedErrorTypeTemp
	} else {
		parameters.ResponseBasedDetectedErrorTypes = nil
	}

	// ResponseBasedFailoverThresholdPercentage
	if source.ResponseBasedFailoverThresholdPercentage != nil {
		responseBasedFailoverThresholdPercentage := *source.ResponseBasedFailoverThresholdPercentage
		parameters.ResponseBasedFailoverThresholdPercentage = &responseBasedFailoverThresholdPercentage
	} else {
		parameters.ResponseBasedFailoverThresholdPercentage = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ResponseBasedOriginErrorDetectionParameters populates the provided destination ResponseBasedOriginErrorDetectionParameters from our ResponseBasedOriginErrorDetectionParameters
func (parameters *ResponseBasedOriginErrorDetectionParameters) AssignProperties_To_ResponseBasedOriginErrorDetectionParameters(destination *storage.ResponseBasedOriginErrorDetectionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HttpErrorRanges
	if parameters.HttpErrorRanges != nil {
		httpErrorRangeList := make([]storage.HttpErrorRangeParameters, len(parameters.HttpErrorRanges))
		for httpErrorRangeIndex, httpErrorRangeItem := range parameters.HttpErrorRanges {
			// Shadow the loop variable to avoid aliasing
			httpErrorRangeItem := httpErrorRangeItem
			var httpErrorRange storage.HttpErrorRangeParameters
			err := httpErrorRangeItem.AssignProperties_To_HttpErrorRangeParameters(&httpErrorRange)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_HttpErrorRangeParameters() to populate field HttpErrorRanges")
			}
			httpErrorRangeList[httpErrorRangeIndex] = httpErrorRange
		}
		destination.HttpErrorRanges = httpErrorRangeList
	} else {
		destination.HttpErrorRanges = nil
	}

	// ResponseBasedDetectedErrorTypes
	if parameters.ResponseBasedDetectedErrorTypes != nil {
		responseBasedDetectedErrorType := string(*parameters.ResponseBasedDetectedErrorTypes)
		destination.ResponseBasedDetectedErrorTypes = &responseBasedDetectedErrorType
	} else {
		destination.ResponseBasedDetectedErrorTypes = nil
	}

	// ResponseBasedFailoverThresholdPercentage
	if parameters.ResponseBasedFailoverThresholdPercentage != nil {
		responseBasedFailoverThresholdPercentage := *parameters.ResponseBasedFailoverThresholdPercentage
		destination.ResponseBasedFailoverThresholdPercentage = &responseBasedFailoverThresholdPercentage
	} else {
		destination.ResponseBasedFailoverThresholdPercentage = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ResponseBasedOriginErrorDetectionParameters_STATUS populates our ResponseBasedOriginErrorDetectionParameters from the provided source ResponseBasedOriginErrorDetectionParameters_STATUS
func (parameters *ResponseBasedOriginErrorDetectionParameters) Initialize_From_ResponseBasedOriginErrorDetectionParameters_STATUS(source *ResponseBasedOriginErrorDetectionParameters_STATUS) error {

	// HttpErrorRanges
	if source.HttpErrorRanges != nil {
		httpErrorRangeList := make([]HttpErrorRangeParameters, len(source.HttpErrorRanges))
		for httpErrorRangeIndex, httpErrorRangeItem := range source.HttpErrorRanges {
			// Shadow the loop variable to avoid aliasing
			httpErrorRangeItem := httpErrorRangeItem
			var httpErrorRange HttpErrorRangeParameters
			err := httpErrorRange.Initialize_From_HttpErrorRangeParameters_STATUS(&httpErrorRangeItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_HttpErrorRangeParameters_STATUS() to populate field HttpErrorRanges")
			}
			httpErrorRangeList[httpErrorRangeIndex] = httpErrorRange
		}
		parameters.HttpErrorRanges = httpErrorRangeList
	} else {
		parameters.HttpErrorRanges = nil
	}

	// ResponseBasedDetectedErrorTypes
	if source.ResponseBasedDetectedErrorTypes != nil {
		responseBasedDetectedErrorType := genruntime.ToEnum(string(*source.ResponseBasedDetectedErrorTypes), responseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_Values)
		parameters.ResponseBasedDetectedErrorTypes = &responseBasedDetectedErrorType
	} else {
		parameters.ResponseBasedDetectedErrorTypes = nil
	}

	// ResponseBasedFailoverThresholdPercentage
	if source.ResponseBasedFailoverThresholdPercentage != nil {
		responseBasedFailoverThresholdPercentage := *source.ResponseBasedFailoverThresholdPercentage
		parameters.ResponseBasedFailoverThresholdPercentage = &responseBasedFailoverThresholdPercentage
	} else {
		parameters.ResponseBasedFailoverThresholdPercentage = nil
	}

	// No error
	return nil
}

// The JSON object that contains the properties to determine origin health using real requests/responses.
type ResponseBasedOriginErrorDetectionParameters_STATUS struct {
	// HttpErrorRanges: The list of Http status code ranges that are considered as server errors for origin and it is marked as
	// unhealthy.
	HttpErrorRanges []HttpErrorRangeParameters_STATUS `json:"httpErrorRanges,omitempty"`

	// ResponseBasedDetectedErrorTypes: Type of response errors for real user requests for which origin will be deemed unhealthy
	ResponseBasedDetectedErrorTypes *ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_STATUS `json:"responseBasedDetectedErrorTypes,omitempty"`

	// ResponseBasedFailoverThresholdPercentage: The percentage of failed requests in the sample where failover should trigger.
	ResponseBasedFailoverThresholdPercentage *int `json:"responseBasedFailoverThresholdPercentage,omitempty"`
}

var _ genruntime.FromARMConverter = &ResponseBasedOriginErrorDetectionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *ResponseBasedOriginErrorDetectionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ResponseBasedOriginErrorDetectionParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *ResponseBasedOriginErrorDetectionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ResponseBasedOriginErrorDetectionParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ResponseBasedOriginErrorDetectionParameters_STATUS, got %T", armInput)
	}

	// Set property "HttpErrorRanges":
	for _, item := range typedInput.HttpErrorRanges {
		var item1 HttpErrorRangeParameters_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		parameters.HttpErrorRanges = append(parameters.HttpErrorRanges, item1)
	}

	// Set property "ResponseBasedDetectedErrorTypes":
	if typedInput.ResponseBasedDetectedErrorTypes != nil {
		var temp string
		temp = string(*typedInput.ResponseBasedDetectedErrorTypes)
		responseBasedDetectedErrorTypes := ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_STATUS(temp)
		parameters.ResponseBasedDetectedErrorTypes = &responseBasedDetectedErrorTypes
	}

	// Set property "ResponseBasedFailoverThresholdPercentage":
	if typedInput.ResponseBasedFailoverThresholdPercentage != nil {
		responseBasedFailoverThresholdPercentage := *typedInput.ResponseBasedFailoverThresholdPercentage
		parameters.ResponseBasedFailoverThresholdPercentage = &responseBasedFailoverThresholdPercentage
	}

	// No error
	return nil
}

// AssignProperties_From_ResponseBasedOriginErrorDetectionParameters_STATUS populates our ResponseBasedOriginErrorDetectionParameters_STATUS from the provided source ResponseBasedOriginErrorDetectionParameters_STATUS
func (parameters *ResponseBasedOriginErrorDetectionParameters_STATUS) AssignProperties_From_ResponseBasedOriginErrorDetectionParameters_STATUS(source *storage.ResponseBasedOriginErrorDetectionParameters_STATUS) error {

	// HttpErrorRanges
	if source.HttpErrorRanges != nil {
		httpErrorRangeList := make([]HttpErrorRangeParameters_STATUS, len(source.HttpErrorRanges))
		for httpErrorRangeIndex, httpErrorRangeItem := range source.HttpErrorRanges {
			// Shadow the loop variable to avoid aliasing
			httpErrorRangeItem := httpErrorRangeItem
			var httpErrorRange HttpErrorRangeParameters_STATUS
			err := httpErrorRange.AssignProperties_From_HttpErrorRangeParameters_STATUS(&httpErrorRangeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_HttpErrorRangeParameters_STATUS() to populate field HttpErrorRanges")
			}
			httpErrorRangeList[httpErrorRangeIndex] = httpErrorRange
		}
		parameters.HttpErrorRanges = httpErrorRangeList
	} else {
		parameters.HttpErrorRanges = nil
	}

	// ResponseBasedDetectedErrorTypes
	if source.ResponseBasedDetectedErrorTypes != nil {
		responseBasedDetectedErrorType := *source.ResponseBasedDetectedErrorTypes
		responseBasedDetectedErrorTypeTemp := genruntime.ToEnum(responseBasedDetectedErrorType, responseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_STATUS_Values)
		parameters.ResponseBasedDetectedErrorTypes = &responseBasedDetectedErrorTypeTemp
	} else {
		parameters.ResponseBasedDetectedErrorTypes = nil
	}

	// ResponseBasedFailoverThresholdPercentage
	parameters.ResponseBasedFailoverThresholdPercentage = genruntime.ClonePointerToInt(source.ResponseBasedFailoverThresholdPercentage)

	// No error
	return nil
}

// AssignProperties_To_ResponseBasedOriginErrorDetectionParameters_STATUS populates the provided destination ResponseBasedOriginErrorDetectionParameters_STATUS from our ResponseBasedOriginErrorDetectionParameters_STATUS
func (parameters *ResponseBasedOriginErrorDetectionParameters_STATUS) AssignProperties_To_ResponseBasedOriginErrorDetectionParameters_STATUS(destination *storage.ResponseBasedOriginErrorDetectionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HttpErrorRanges
	if parameters.HttpErrorRanges != nil {
		httpErrorRangeList := make([]storage.HttpErrorRangeParameters_STATUS, len(parameters.HttpErrorRanges))
		for httpErrorRangeIndex, httpErrorRangeItem := range parameters.HttpErrorRanges {
			// Shadow the loop variable to avoid aliasing
			httpErrorRangeItem := httpErrorRangeItem
			var httpErrorRange storage.HttpErrorRangeParameters_STATUS
			err := httpErrorRangeItem.AssignProperties_To_HttpErrorRangeParameters_STATUS(&httpErrorRange)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_HttpErrorRangeParameters_STATUS() to populate field HttpErrorRanges")
			}
			httpErrorRangeList[httpErrorRangeIndex] = httpErrorRange
		}
		destination.HttpErrorRanges = httpErrorRangeList
	} else {
		destination.HttpErrorRanges = nil
	}

	// ResponseBasedDetectedErrorTypes
	if parameters.ResponseBasedDetectedErrorTypes != nil {
		responseBasedDetectedErrorType := string(*parameters.ResponseBasedDetectedErrorTypes)
		destination.ResponseBasedDetectedErrorTypes = &responseBasedDetectedErrorType
	} else {
		destination.ResponseBasedDetectedErrorTypes = nil
	}

	// ResponseBasedFailoverThresholdPercentage
	destination.ResponseBasedFailoverThresholdPercentage = genruntime.ClonePointerToInt(parameters.ResponseBasedFailoverThresholdPercentage)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// An action for the delivery rule.
type DeliveryRuleAction struct {
	// CacheExpiration: Mutually exclusive with all other properties
	CacheExpiration *DeliveryRuleCacheExpirationAction `json:"cacheExpiration,omitempty"`

	// CacheKeyQueryString: Mutually exclusive with all other properties
	CacheKeyQueryString *DeliveryRuleCacheKeyQueryStringAction `json:"cacheKeyQueryString,omitempty"`

	// ModifyRequestHeader: Mutually exclusive with all other properties
	ModifyRequestHeader *DeliveryRuleRequestHeaderAction `json:"modifyRequestHeader,omitempty"`

	// ModifyResponseHeader: Mutually exclusive with all other properties
	ModifyResponseHeader *DeliveryRuleResponseHeaderAction `json:"modifyResponseHeader,omitempty"`

	// OriginGroupOverride: Mutually exclusive with all other properties
	OriginGroupOverride *OriginGroupOverrideAction `json:"originGroupOverride,omitempty"`

	// RouteConfigurationOverride: Mutually exclusive with all other properties
	RouteConfigurationOverride *DeliveryRuleRouteConfigurationOverrideAction `json:"routeConfigurationOverride,omitempty"`

	// UrlRedirect: Mutually exclusive with all other properties
	UrlRedirect *UrlRedirectAction `json:"urlRedirect,omitempty"`

	// UrlRewrite: Mutually exclusive with all other properties
	UrlRewrite *UrlRewriteAction `json:"urlRewrite,omitempty"`

	// UrlSigning: Mutually exclusive with all other properties
	UrlSigning *UrlSigningAction `json:"urlSigning,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleAction{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (action *DeliveryRuleAction) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if action == nil {
		return nil, nil
	}
	result := &arm.DeliveryRuleAction{}

	// Set property "CacheExpiration":
	if action.CacheExpiration != nil {
		cacheExpiration_ARM, err := (*action.CacheExpiration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		cacheExpiration := *cacheExpiration_ARM.(*arm.DeliveryRuleCacheExpirationAction)
		result.CacheExpiration = &cacheExpiration
	}

	// Set property "CacheKeyQueryString":
	if action.CacheKeyQueryString != nil {
		cacheKeyQueryString_ARM, err := (*action.CacheKeyQueryString).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		cacheKeyQueryString := *cacheKeyQueryString_ARM.(*arm.DeliveryRuleCacheKeyQueryStringAction)
		result.CacheKeyQueryString = &cacheKeyQueryString
	}

	// Set property "ModifyRequestHeader":
	if action.ModifyRequestHeader != nil {
		modifyRequestHeader_ARM, err := (*action.ModifyRequestHeader).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		modifyRequestHeader := *modifyRequestHeader_ARM.(*arm.DeliveryRuleRequestHeaderAction)
		result.ModifyRequestHeader = &modifyRequestHeader
	}

	// Set property "ModifyResponseHeader":
	if action.ModifyResponseHeader != nil {
		modifyResponseHeader_ARM, err := (*action.ModifyResponseHeader).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		modifyResponseHeader := *modifyResponseHeader_ARM.(*arm.DeliveryRuleResponseHeaderAction)
		result.ModifyResponseHeader = &modifyResponseHeader
	}

	// Set property "OriginGroupOverride":
	if action.OriginGroupOverride != nil {
		originGroupOverride_ARM, err := (*action.OriginGroupOverride).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		originGroupOverride := *originGroupOverride_ARM.(*arm.OriginGroupOverrideAction)
		result.OriginGroupOverride = &originGroupOverride
	}

	// Set property "RouteConfigurationOverride":
	if action.RouteConfigurationOverride != nil {
		routeConfigurationOverride_ARM, err := (*action.RouteConfigurationOverride).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		routeConfigurationOverride := *routeConfigurationOverride_ARM.(*arm.DeliveryRuleRouteConfigurationOverrideAction)
		result.RouteConfigurationOverride = &routeConfigurationOverride
	}

	// Set property "UrlRedirect":
	if action.UrlRedirect != nil {
		urlRedirect_ARM, err := (*action.UrlRedirect).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		urlRedirect := *urlRedirect_ARM.(*arm.UrlRedirectAction)
		result.UrlRedirect = &urlRedirect
	}

	// Set property "UrlRewrite":
	if action.UrlRewrite != nil {
		urlRewrite_ARM, err := (*action.UrlRewrite).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		urlRewrite := *urlRewrite_ARM.(*arm.UrlRewriteAction)
		result.UrlRewrite = &urlRewrite
	}

	// Set property "UrlSigning":
	if action.UrlSigning != nil {
		urlSigning_ARM, err := (*action.UrlSigning).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		urlSigning := *urlSigning_ARM.(*arm.UrlSigningAction)
		result.UrlSigning = &urlSigning
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *DeliveryRuleAction) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleAction{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *DeliveryRuleAction) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleAction)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleAction, got %T", armInput)
	}

	// Set property "CacheExpiration":
	if typedInput.CacheExpiration != nil {
		var cacheExpiration1 DeliveryRuleCacheExpirationAction
		err := cacheExpiration1.PopulateFromARM(owner, *typedInput.CacheExpiration)
		if err != nil {
			return err
		}
		cacheExpiration := cacheExpiration1
		action.CacheExpiration = &cacheExpiration
	}

	// Set property "CacheKeyQueryString":
	if typedInput.CacheKeyQueryString != nil {
		var cacheKeyQueryString1 DeliveryRuleCacheKeyQueryStringAction
		err := cacheKeyQueryString1.PopulateFromARM(owner, *typedInput.CacheKeyQueryString)
		if err != nil {
			return err
		}
		cacheKeyQueryString := cacheKeyQueryString1
		action.CacheKeyQueryString = &cacheKeyQueryString
	}

	// Set property "ModifyRequestHeader":
	if typedInput.ModifyRequestHeader != nil {
		var modifyRequestHeader1 DeliveryRuleRequestHeaderAction
		err := modifyRequestHeader1.PopulateFromARM(owner, *typedInput.ModifyRequestHeader)
		if err != nil {
			return err
		}
		modifyRequestHeader := modifyRequestHeader1
		action.ModifyRequestHeader = &modifyRequestHeader
	}

	// Set property "ModifyResponseHeader":
	if typedInput.ModifyResponseHeader != nil {
		var modifyResponseHeader1 DeliveryRuleResponseHeaderAction
		err := modifyResponseHeader1.PopulateFromARM(owner, *typedInput.ModifyResponseHeader)
		if err != nil {
			return err
		}
		modifyResponseHeader := modifyResponseHeader1
		action.ModifyResponseHeader = &modifyResponseHeader
	}

	// Set property "OriginGroupOverride":
	if typedInput.OriginGroupOverride != nil {
		var originGroupOverride1 OriginGroupOverrideAction
		err := originGroupOverride1.PopulateFromARM(owner, *typedInput.OriginGroupOverride)
		if err != nil {
			return err
		}
		originGroupOverride := originGroupOverride1
		action.OriginGroupOverride = &originGroupOverride
	}

	// Set property "RouteConfigurationOverride":
	if typedInput.RouteConfigurationOverride != nil {
		var routeConfigurationOverride1 DeliveryRuleRouteConfigurationOverrideAction
		err := routeConfigurationOverride1.PopulateFromARM(owner, *typedInput.RouteConfigurationOverride)
		if err != nil {
			return err
		}
		routeConfigurationOverride := routeConfigurationOverride1
		action.RouteConfigurationOverride = &routeConfigurationOverride
	}

	// Set property "UrlRedirect":
	if typedInput.UrlRedirect != nil {
		var urlRedirect1 UrlRedirectAction
		err := urlRedirect1.PopulateFromARM(owner, *typedInput.UrlRedirect)
		if err != nil {
			return err
		}
		urlRedirect := urlRedirect1
		action.UrlRedirect = &urlRedirect
	}

	// Set property "UrlRewrite":
	if typedInput.UrlRewrite != nil {
		var urlRewrite1 UrlRewriteAction
		err := urlRewrite1.PopulateFromARM(owner, *typedInput.UrlRewrite)
		if err != nil {
			return err
		}
		urlRewrite := urlRewrite1
		action.UrlRewrite = &urlRewrite
	}

	// Set property "UrlSigning":
	if typedInput.UrlSigning != nil {
		var urlSigning1 UrlSigningAction
		err := urlSigning1.PopulateFromARM(owner, *typedInput.UrlSigning)
		if err != nil {
			return err
		}
		urlSigning := urlSigning1
		action.UrlSigning = &urlSigning
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleAction populates our DeliveryRuleAction from the provided source DeliveryRuleAction
func (action *DeliveryRuleAction) AssignProperties_From_DeliveryRuleAction(source *storage.DeliveryRuleAction) error {

	// CacheExpiration
	if source.CacheExpiration != nil {
		var cacheExpiration DeliveryRuleCacheExpirationAction
		err := cacheExpiration.AssignProperties_From_DeliveryRuleCacheExpirationAction(source.CacheExpiration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleCacheExpirationAction() to populate field CacheExpiration")
		}
		action.CacheExpiration = &cacheExpiration
	} else {
		action.CacheExpiration = nil
	}

	// CacheKeyQueryString
	if source.CacheKeyQueryString != nil {
		var cacheKeyQueryString DeliveryRuleCacheKeyQueryStringAction
		err := cacheKeyQueryString.AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction(source.CacheKeyQueryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction() to populate field CacheKeyQueryString")
		}
		action.CacheKeyQueryString = &cacheKeyQueryString
	} else {
		action.CacheKeyQueryString = nil
	}

	// ModifyRequestHeader
	if source.ModifyRequestHeader != nil {
		var modifyRequestHeader DeliveryRuleRequestHeaderAction
		err := modifyRequestHeader.AssignProperties_From_DeliveryRuleRequestHeaderAction(source.ModifyRequestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestHeaderAction() to populate field ModifyRequestHeader")
		}
		action.ModifyRequestHeader = &modifyRequestHeader
	} else {
		action.ModifyRequestHeader = nil
	}

	// ModifyResponseHeader
	if source.ModifyResponseHeader != nil {
		var modifyResponseHeader DeliveryRuleResponseHeaderAction
		err := modifyResponseHeader.AssignProperties_From_DeliveryRuleResponseHeaderAction(source.ModifyResponseHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleResponseHeaderAction() to populate field ModifyResponseHeader")
		}
		action.ModifyResponseHeader = &modifyResponseHeader
	} else {
		action.ModifyResponseHeader = nil
	}

	// OriginGroupOverride
	if source.OriginGroupOverride != nil {
		var originGroupOverride OriginGroupOverrideAction
		err := originGroupOverride.AssignProperties_From_OriginGroupOverrideAction(source.OriginGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OriginGroupOverrideAction() to populate field OriginGroupOverride")
		}
		action.OriginGroupOverride = &originGroupOverride
	} else {
		action.OriginGroupOverride = nil
	}

	// RouteConfigurationOverride
	if source.RouteConfigurationOverride != nil {
		var routeConfigurationOverride DeliveryRuleRouteConfigurationOverrideAction
		err := routeConfigurationOverride.AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction(source.RouteConfigurationOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction() to populate field RouteConfigurationOverride")
		}
		action.RouteConfigurationOverride = &routeConfigurationOverride
	} else {
		action.RouteConfigurationOverride = nil
	}

	// UrlRedirect
	if source.UrlRedirect != nil {
		var urlRedirect UrlRedirectAction
		err := urlRedirect.AssignProperties_From_UrlRedirectAction(source.UrlRedirect)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlRedirectAction() to populate field UrlRedirect")
		}
		action.UrlRedirect = &urlRedirect
	} else {
		action.UrlRedirect = nil
	}

	// UrlRewrite
	if source.UrlRewrite != nil {
		var urlRewrite UrlRewriteAction
		err := urlRewrite.AssignProperties_From_UrlRewriteAction(source.UrlRewrite)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlRewriteAction() to populate field UrlRewrite")
		}
		action.UrlRewrite = &urlRewrite
	} else {
		action.UrlRewrite = nil
	}

	// UrlSigning
	if source.UrlSigning != nil {
		var urlSigning UrlSigningAction
		err := urlSigning.AssignProperties_From_UrlSigningAction(source.UrlSigning)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlSigningAction() to populate field UrlSigning")
		}
		action.UrlSigning = &urlSigning
	} else {
		action.UrlSigning = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleAction populates the provided destination DeliveryRuleAction from our DeliveryRuleAction
func (action *DeliveryRuleAction) AssignProperties_To_DeliveryRuleAction(destination *storage.DeliveryRuleAction) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CacheExpiration
	if action.CacheExpiration != nil {
		var cacheExpiration storage.DeliveryRuleCacheExpirationAction
		err := action.CacheExpiration.AssignProperties_To_DeliveryRuleCacheExpirationAction(&cacheExpiration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleCacheExpirationAction() to populate field CacheExpiration")
		}
		destination.CacheExpiration = &cacheExpiration
	} else {
		destination.CacheExpiration = nil
	}

	// CacheKeyQueryString
	if action.CacheKeyQueryString != nil {
		var cacheKeyQueryString storage.DeliveryRuleCacheKeyQueryStringAction
		err := action.CacheKeyQueryString.AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction(&cacheKeyQueryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction() to populate field CacheKeyQueryString")
		}
		destination.CacheKeyQueryString = &cacheKeyQueryString
	} else {
		destination.CacheKeyQueryString = nil
	}

	// ModifyRequestHeader
	if action.ModifyRequestHeader != nil {
		var modifyRequestHeader storage.DeliveryRuleRequestHeaderAction
		err := action.ModifyRequestHeader.AssignProperties_To_DeliveryRuleRequestHeaderAction(&modifyRequestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestHeaderAction() to populate field ModifyRequestHeader")
		}
		destination.ModifyRequestHeader = &modifyRequestHeader
	} else {
		destination.ModifyRequestHeader = nil
	}

	// ModifyResponseHeader
	if action.ModifyResponseHeader != nil {
		var modifyResponseHeader storage.DeliveryRuleResponseHeaderAction
		err := action.ModifyResponseHeader.AssignProperties_To_DeliveryRuleResponseHeaderAction(&modifyResponseHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleResponseHeaderAction() to populate field ModifyResponseHeader")
		}
		destination.ModifyResponseHeader = &modifyResponseHeader
	} else {
		destination.ModifyResponseHeader = nil
	}

	// OriginGroupOverride
	if action.OriginGroupOverride != nil {
		var originGroupOverride storage.OriginGroupOverrideAction
		err := action.OriginGroupOverride.AssignProperties_To_OriginGroupOverrideAction(&originGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OriginGroupOverrideAction() to populate field OriginGroupOverride")
		}
		destination.OriginGroupOverride = &originGroupOverride
	} else {
		destination.OriginGroupOverride = nil
	}

	// RouteConfigurationOverride
	if action.RouteConfigurationOverride != nil {
		var routeConfigurationOverride storage.DeliveryRuleRouteConfigurationOverrideAction
		err := action.RouteConfigurationOverride.AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction(&routeConfigurationOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction() to populate field RouteConfigurationOverride")
		}
		destination.RouteConfigurationOverride = &routeConfigurationOverride
	} else {
		destination.RouteConfigurationOverride = nil
	}

	// UrlRedirect
	if action.UrlRedirect != nil {
		var urlRedirect storage.UrlRedirectAction
		err := action.UrlRedirect.AssignProperties_To_UrlRedirectAction(&urlRedirect)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlRedirectAction() to populate field UrlRedirect")
		}
		destination.UrlRedirect = &urlRedirect
	} else {
		destination.UrlRedirect = nil
	}

	// UrlRewrite
	if action.UrlRewrite != nil {
		var urlRewrite storage.UrlRewriteAction
		err := action.UrlRewrite.AssignProperties_To_UrlRewriteAction(&urlRewrite)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlRewriteAction() to populate field UrlRewrite")
		}
		destination.UrlRewrite = &urlRewrite
	} else {
		destination.UrlRewrite = nil
	}

	// UrlSigning
	if action.UrlSigning != nil {
		var urlSigning storage.UrlSigningAction
		err := action.UrlSigning.AssignProperties_To_UrlSigningAction(&urlSigning)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlSigningAction() to populate field UrlSigning")
		}
		destination.UrlSigning = &urlSigning
	} else {
		destination.UrlSigning = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleAction_STATUS populates our DeliveryRuleAction from the provided source DeliveryRuleAction_STATUS
func (action *DeliveryRuleAction) Initialize_From_DeliveryRuleAction_STATUS(source *DeliveryRuleAction_STATUS) error {

	// CacheExpiration
	if source.CacheExpiration != nil {
		var cacheExpiration DeliveryRuleCacheExpirationAction
		err := cacheExpiration.Initialize_From_DeliveryRuleCacheExpirationAction_STATUS(source.CacheExpiration)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleCacheExpirationAction_STATUS() to populate field CacheExpiration")
		}
		action.CacheExpiration = &cacheExpiration
	} else {
		action.CacheExpiration = nil
	}

	// CacheKeyQueryString
	if source.CacheKeyQueryString != nil {
		var cacheKeyQueryString DeliveryRuleCacheKeyQueryStringAction
		err := cacheKeyQueryString.Initialize_From_DeliveryRuleCacheKeyQueryStringAction_STATUS(source.CacheKeyQueryString)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleCacheKeyQueryStringAction_STATUS() to populate field CacheKeyQueryString")
		}
		action.CacheKeyQueryString = &cacheKeyQueryString
	} else {
		action.CacheKeyQueryString = nil
	}

	// ModifyRequestHeader
	if source.ModifyRequestHeader != nil {
		var modifyRequestHeader DeliveryRuleRequestHeaderAction
		err := modifyRequestHeader.Initialize_From_DeliveryRuleRequestHeaderAction_STATUS(source.ModifyRequestHeader)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleRequestHeaderAction_STATUS() to populate field ModifyRequestHeader")
		}
		action.ModifyRequestHeader = &modifyRequestHeader
	} else {
		action.ModifyRequestHeader = nil
	}

	// ModifyResponseHeader
	if source.ModifyResponseHeader != nil {
		var modifyResponseHeader DeliveryRuleResponseHeaderAction
		err := modifyResponseHeader.Initialize_From_DeliveryRuleResponseHeaderAction_STATUS(source.ModifyResponseHeader)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleResponseHeaderAction_STATUS() to populate field ModifyResponseHeader")
		}
		action.ModifyResponseHeader = &modifyResponseHeader
	} else {
		action.ModifyResponseHeader = nil
	}

	// OriginGroupOverride
	if source.OriginGroupOverride != nil {
		var originGroupOverride OriginGroupOverrideAction
		err := originGroupOverride.Initialize_From_OriginGroupOverrideAction_STATUS(source.OriginGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_OriginGroupOverrideAction_STATUS() to populate field OriginGroupOverride")
		}
		action.OriginGroupOverride = &originGroupOverride
	} else {
		action.OriginGroupOverride = nil
	}

	// RouteConfigurationOverride
	if source.RouteConfigurationOverride != nil {
		var routeConfigurationOverride DeliveryRuleRouteConfigurationOverrideAction
		err := routeConfigurationOverride.Initialize_From_DeliveryRuleRouteConfigurationOverrideAction_STATUS(source.RouteConfigurationOverride)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleRouteConfigurationOverrideAction_STATUS() to populate field RouteConfigurationOverride")
		}
		action.RouteConfigurationOverride = &routeConfigurationOverride
	} else {
		action.RouteConfigurationOverride = nil
	}

	// UrlRedirect
	if source.UrlRedirect != nil {
		var urlRedirect UrlRedirectAction
		err := urlRedirect.Initialize_From_UrlRedirectAction_STATUS(source.UrlRedirect)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_UrlRedirectAction_STATUS() to populate field UrlRedirect")
		}
		action.UrlRedirect = &urlRedirect
	} else {
		action.UrlRedirect = nil
	}

	// UrlRewrite
	if source.UrlRewrite != nil {
		var urlRewrite UrlRewriteAction
		err := urlRewrite.Initialize_From_UrlRewriteAction_STATUS(source.UrlRewrite)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_UrlRewriteAction_STATUS() to populate field UrlRewrite")
		}
		action.UrlRewrite = &urlRewrite
	} else {
		action.UrlRewrite = nil
	}

	// UrlSigning
	if source.UrlSigning != nil {
		var urlSigning UrlSigningAction
		err := urlSigning.Initialize_From_UrlSigningAction_STATUS(source.UrlSigning)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_UrlSigningAction_STATUS() to populate field UrlSigning")
		}
		action.UrlSigning = &urlSigning
	} else {
		action.UrlSigning = nil
	}

	// No error
	return nil
}

// An action for the delivery rule.
type DeliveryRuleAction_STATUS struct {
	// CacheExpiration: Mutually exclusive with all other properties
	CacheExpiration *DeliveryRuleCacheExpirationAction_STATUS `json:"cacheExpiration,omitempty"`

	// CacheKeyQueryString: Mutually exclusive with all other properties
	CacheKeyQueryString *DeliveryRuleCacheKeyQueryStringAction_STATUS `json:"cacheKeyQueryString,omitempty"`

	// ModifyRequestHeader: Mutually exclusive with all other properties
	ModifyRequestHeader *DeliveryRuleRequestHeaderAction_STATUS `json:"modifyRequestHeader,omitempty"`

	// ModifyResponseHeader: Mutually exclusive with all other properties
	ModifyResponseHeader *DeliveryRuleResponseHeaderAction_STATUS `json:"modifyResponseHeader,omitempty"`

	// OriginGroupOverride: Mutually exclusive with all other properties
	OriginGroupOverride *OriginGroupOverrideAction_STATUS `json:"originGroupOverride,omitempty"`

	// RouteConfigurationOverride: Mutually exclusive with all other properties
	RouteConfigurationOverride *DeliveryRuleRouteConfigurationOverrideAction_STATUS `json:"routeConfigurationOverride,omitempty"`

	// UrlRedirect: Mutually exclusive with all other properties
	UrlRedirect *UrlRedirectAction_STATUS `json:"urlRedirect,omitempty"`

	// UrlRewrite: Mutually exclusive with all other properties
	UrlRewrite *UrlRewriteAction_STATUS `json:"urlRewrite,omitempty"`

	// UrlSigning: Mutually exclusive with all other properties
	UrlSigning *UrlSigningAction_STATUS `json:"urlSigning,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleAction_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *DeliveryRuleAction_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleAction_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *DeliveryRuleAction_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleAction_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleAction_STATUS, got %T", armInput)
	}

	// Set property "CacheExpiration":
	if typedInput.CacheExpiration != nil {
		var cacheExpiration1 DeliveryRuleCacheExpirationAction_STATUS
		err := cacheExpiration1.PopulateFromARM(owner, *typedInput.CacheExpiration)
		if err != nil {
			return err
		}
		cacheExpiration := cacheExpiration1
		action.CacheExpiration = &cacheExpiration
	}

	// Set property "CacheKeyQueryString":
	if typedInput.CacheKeyQueryString != nil {
		var cacheKeyQueryString1 DeliveryRuleCacheKeyQueryStringAction_STATUS
		err := cacheKeyQueryString1.PopulateFromARM(owner, *typedInput.CacheKeyQueryString)
		if err != nil {
			return err
		}
		cacheKeyQueryString := cacheKeyQueryString1
		action.CacheKeyQueryString = &cacheKeyQueryString
	}

	// Set property "ModifyRequestHeader":
	if typedInput.ModifyRequestHeader != nil {
		var modifyRequestHeader1 DeliveryRuleRequestHeaderAction_STATUS
		err := modifyRequestHeader1.PopulateFromARM(owner, *typedInput.ModifyRequestHeader)
		if err != nil {
			return err
		}
		modifyRequestHeader := modifyRequestHeader1
		action.ModifyRequestHeader = &modifyRequestHeader
	}

	// Set property "ModifyResponseHeader":
	if typedInput.ModifyResponseHeader != nil {
		var modifyResponseHeader1 DeliveryRuleResponseHeaderAction_STATUS
		err := modifyResponseHeader1.PopulateFromARM(owner, *typedInput.ModifyResponseHeader)
		if err != nil {
			return err
		}
		modifyResponseHeader := modifyResponseHeader1
		action.ModifyResponseHeader = &modifyResponseHeader
	}

	// Set property "OriginGroupOverride":
	if typedInput.OriginGroupOverride != nil {
		var originGroupOverride1 OriginGroupOverrideAction_STATUS
		err := originGroupOverride1.PopulateFromARM(owner, *typedInput.OriginGroupOverride)
		if err != nil {
			return err
		}
		originGroupOverride := originGroupOverride1
		action.OriginGroupOverride = &originGroupOverride
	}

	// Set property "RouteConfigurationOverride":
	if typedInput.RouteConfigurationOverride != nil {
		var routeConfigurationOverride1 DeliveryRuleRouteConfigurationOverrideAction_STATUS
		err := routeConfigurationOverride1.PopulateFromARM(owner, *typedInput.RouteConfigurationOverride)
		if err != nil {
			return err
		}
		routeConfigurationOverride := routeConfigurationOverride1
		action.RouteConfigurationOverride = &routeConfigurationOverride
	}

	// Set property "UrlRedirect":
	if typedInput.UrlRedirect != nil {
		var urlRedirect1 UrlRedirectAction_STATUS
		err := urlRedirect1.PopulateFromARM(owner, *typedInput.UrlRedirect)
		if err != nil {
			return err
		}
		urlRedirect := urlRedirect1
		action.UrlRedirect = &urlRedirect
	}

	// Set property "UrlRewrite":
	if typedInput.UrlRewrite != nil {
		var urlRewrite1 UrlRewriteAction_STATUS
		err := urlRewrite1.PopulateFromARM(owner, *typedInput.UrlRewrite)
		if err != nil {
			return err
		}
		urlRewrite := urlRewrite1
		action.UrlRewrite = &urlRewrite
	}

	// Set property "UrlSigning":
	if typedInput.UrlSigning != nil {
		var urlSigning1 UrlSigningAction_STATUS
		err := urlSigning1.PopulateFromARM(owner, *typedInput.UrlSigning)
		if err != nil {
			return err
		}
		urlSigning := urlSigning1
		action.UrlSigning = &urlSigning
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleAction_STATUS populates our DeliveryRuleAction_STATUS from the provided source DeliveryRuleAction_STATUS
func (action *DeliveryRuleAction_STATUS) AssignProperties_From_DeliveryRuleAction_STATUS(source *storage.DeliveryRuleAction_STATUS) error {

	// CacheExpiration
	if source.CacheExpiration != nil {
		var cacheExpiration DeliveryRuleCacheExpirationAction_STATUS
		err := cacheExpiration.AssignProperties_From_DeliveryRuleCacheExpirationAction_STATUS(source.CacheExpiration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleCacheExpirationAction_STATUS() to populate field CacheExpiration")
		}
		action.CacheExpiration = &cacheExpiration
	} else {
		action.CacheExpiration = nil
	}

	// CacheKeyQueryString
	if source.CacheKeyQueryString != nil {
		var cacheKeyQueryString DeliveryRuleCacheKeyQueryStringAction_STATUS
		err := cacheKeyQueryString.AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction_STATUS(source.CacheKeyQueryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction_STATUS() to populate field CacheKeyQueryString")
		}
		action.CacheKeyQueryString = &cacheKeyQueryString
	} else {
		action.CacheKeyQueryString = nil
	}

	// ModifyRequestHeader
	if source.ModifyRequestHeader != nil {
		var modifyRequestHeader DeliveryRuleRequestHeaderAction_STATUS
		err := modifyRequestHeader.AssignProperties_From_DeliveryRuleRequestHeaderAction_STATUS(source.ModifyRequestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestHeaderAction_STATUS() to populate field ModifyRequestHeader")
		}
		action.ModifyRequestHeader = &modifyRequestHeader
	} else {
		action.ModifyRequestHeader = nil
	}

	// ModifyResponseHeader
	if source.ModifyResponseHeader != nil {
		var modifyResponseHeader DeliveryRuleResponseHeaderAction_STATUS
		err := modifyResponseHeader.AssignProperties_From_DeliveryRuleResponseHeaderAction_STATUS(source.ModifyResponseHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleResponseHeaderAction_STATUS() to populate field ModifyResponseHeader")
		}
		action.ModifyResponseHeader = &modifyResponseHeader
	} else {
		action.ModifyResponseHeader = nil
	}

	// OriginGroupOverride
	if source.OriginGroupOverride != nil {
		var originGroupOverride OriginGroupOverrideAction_STATUS
		err := originGroupOverride.AssignProperties_From_OriginGroupOverrideAction_STATUS(source.OriginGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OriginGroupOverrideAction_STATUS() to populate field OriginGroupOverride")
		}
		action.OriginGroupOverride = &originGroupOverride
	} else {
		action.OriginGroupOverride = nil
	}

	// RouteConfigurationOverride
	if source.RouteConfigurationOverride != nil {
		var routeConfigurationOverride DeliveryRuleRouteConfigurationOverrideAction_STATUS
		err := routeConfigurationOverride.AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction_STATUS(source.RouteConfigurationOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction_STATUS() to populate field RouteConfigurationOverride")
		}
		action.RouteConfigurationOverride = &routeConfigurationOverride
	} else {
		action.RouteConfigurationOverride = nil
	}

	// UrlRedirect
	if source.UrlRedirect != nil {
		var urlRedirect UrlRedirectAction_STATUS
		err := urlRedirect.AssignProperties_From_UrlRedirectAction_STATUS(source.UrlRedirect)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlRedirectAction_STATUS() to populate field UrlRedirect")
		}
		action.UrlRedirect = &urlRedirect
	} else {
		action.UrlRedirect = nil
	}

	// UrlRewrite
	if source.UrlRewrite != nil {
		var urlRewrite UrlRewriteAction_STATUS
		err := urlRewrite.AssignProperties_From_UrlRewriteAction_STATUS(source.UrlRewrite)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlRewriteAction_STATUS() to populate field UrlRewrite")
		}
		action.UrlRewrite = &urlRewrite
	} else {
		action.UrlRewrite = nil
	}

	// UrlSigning
	if source.UrlSigning != nil {
		var urlSigning UrlSigningAction_STATUS
		err := urlSigning.AssignProperties_From_UrlSigningAction_STATUS(source.UrlSigning)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlSigningAction_STATUS() to populate field UrlSigning")
		}
		action.UrlSigning = &urlSigning
	} else {
		action.UrlSigning = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleAction_STATUS populates the provided destination DeliveryRuleAction_STATUS from our DeliveryRuleAction_STATUS
func (action *DeliveryRuleAction_STATUS) AssignProperties_To_DeliveryRuleAction_STATUS(destination *storage.DeliveryRuleAction_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CacheExpiration
	if action.CacheExpiration != nil {
		var cacheExpiration storage.DeliveryRuleCacheExpirationAction_STATUS
		err := action.CacheExpiration.AssignProperties_To_DeliveryRuleCacheExpirationAction_STATUS(&cacheExpiration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleCacheExpirationAction_STATUS() to populate field CacheExpiration")
		}
		destination.CacheExpiration = &cacheExpiration
	} else {
		destination.CacheExpiration = nil
	}

	// CacheKeyQueryString
	if action.CacheKeyQueryString != nil {
		var cacheKeyQueryString storage.DeliveryRuleCacheKeyQueryStringAction_STATUS
		err := action.CacheKeyQueryString.AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction_STATUS(&cacheKeyQueryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction_STATUS() to populate field CacheKeyQueryString")
		}
		destination.CacheKeyQueryString = &cacheKeyQueryString
	} else {
		destination.CacheKeyQueryString = nil
	}

	// ModifyRequestHeader
	if action.ModifyRequestHeader != nil {
		var modifyRequestHeader storage.DeliveryRuleRequestHeaderAction_STATUS
		err := action.ModifyRequestHeader.AssignProperties_To_DeliveryRuleRequestHeaderAction_STATUS(&modifyRequestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestHeaderAction_STATUS() to populate field ModifyRequestHeader")
		}
		destination.ModifyRequestHeader = &modifyRequestHeader
	} else {
		destination.ModifyRequestHeader = nil
	}

	// ModifyResponseHeader
	if action.ModifyResponseHeader != nil {
		var modifyResponseHeader storage.DeliveryRuleResponseHeaderAction_STATUS
		err := action.ModifyResponseHeader.AssignProperties_To_DeliveryRuleResponseHeaderAction_STATUS(&modifyResponseHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleResponseHeaderAction_STATUS() to populate field ModifyResponseHeader")
		}
		destination.ModifyResponseHeader = &modifyResponseHeader
	} else {
		destination.ModifyResponseHeader = nil
	}

	// OriginGroupOverride
	if action.OriginGroupOverride != nil {
		var originGroupOverride storage.OriginGroupOverrideAction_STATUS
		err := action.OriginGroupOverride.AssignProperties_To_OriginGroupOverrideAction_STATUS(&originGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OriginGroupOverrideAction_STATUS() to populate field OriginGroupOverride")
		}
		destination.OriginGroupOverride = &originGroupOverride
	} else {
		destination.OriginGroupOverride = nil
	}

	// RouteConfigurationOverride
	if action.RouteConfigurationOverride != nil {
		var routeConfigurationOverride storage.DeliveryRuleRouteConfigurationOverrideAction_STATUS
		err := action.RouteConfigurationOverride.AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction_STATUS(&routeConfigurationOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction_STATUS() to populate field RouteConfigurationOverride")
		}
		destination.RouteConfigurationOverride = &routeConfigurationOverride
	} else {
		destination.RouteConfigurationOverride = nil
	}

	// UrlRedirect
	if action.UrlRedirect != nil {
		var urlRedirect storage.UrlRedirectAction_STATUS
		err := action.UrlRedirect.AssignProperties_To_UrlRedirectAction_STATUS(&urlRedirect)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlRedirectAction_STATUS() to populate field UrlRedirect")
		}
		destination.UrlRedirect = &urlRedirect
	} else {
		destination.UrlRedirect = nil
	}

	// UrlRewrite
	if action.UrlRewrite != nil {
		var urlRewrite storage.UrlRewriteAction_STATUS
		err := action.UrlRewrite.AssignProperties_To_UrlRewriteAction_STATUS(&urlRewrite)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlRewriteAction_STATUS() to populate field UrlRewrite")
		}
		destination.UrlRewrite = &urlRewrite
	} else {
		destination.UrlRewrite = nil
	}

	// UrlSigning
	if action.UrlSigning != nil {
		var urlSigning storage.UrlSigningAction_STATUS
		err := action.UrlSigning.AssignProperties_To_UrlSigningAction_STATUS(&urlSigning)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlSigningAction_STATUS() to populate field UrlSigning")
		}
		destination.UrlSigning = &urlSigning
	} else {
		destination.UrlSigning = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// A condition for the delivery rule.
type DeliveryRuleCondition struct {
	// ClientPort: Mutually exclusive with all other properties
	ClientPort *DeliveryRuleClientPortCondition `json:"clientPort,omitempty"`

	// Cookies: Mutually exclusive with all other properties
	Cookies *DeliveryRuleCookiesCondition `json:"cookies,omitempty"`

	// HostName: Mutually exclusive with all other properties
	HostName *DeliveryRuleHostNameCondition `json:"hostName,omitempty"`

	// HttpVersion: Mutually exclusive with all other properties
	HttpVersion *DeliveryRuleHttpVersionCondition `json:"httpVersion,omitempty"`

	// IsDevice: Mutually exclusive with all other properties
	IsDevice *DeliveryRuleIsDeviceCondition `json:"isDevice,omitempty"`

	// PostArgs: Mutually exclusive with all other properties
	PostArgs *DeliveryRulePostArgsCondition `json:"postArgs,omitempty"`

	// QueryString: Mutually exclusive with all other properties
	QueryString *DeliveryRuleQueryStringCondition `json:"queryString,omitempty"`

	// RemoteAddress: Mutually exclusive with all other properties
	RemoteAddress *DeliveryRuleRemoteAddressCondition `json:"remoteAddress,omitempty"`

	// RequestBody: Mutually exclusive with all other properties
	RequestBody *DeliveryRuleRequestBodyCondition `json:"requestBody,omitempty"`

	// RequestHeader: Mutually exclusive with all other properties
	RequestHeader *DeliveryRuleRequestHeaderCondition `json:"requestHeader,omitempty"`

	// RequestMethod: Mutually exclusive with all other properties
	RequestMethod *DeliveryRuleRequestMethodCondition `json:"requestMethod,omitempty"`

	// RequestScheme: Mutually exclusive with all other properties
	RequestScheme *DeliveryRuleRequestSchemeCondition `json:"requestScheme,omitempty"`

	// RequestUri: Mutually exclusive with all other properties
	RequestUri *DeliveryRuleRequestUriCondition `json:"requestUri,omitempty"`

	// ServerPort: Mutually exclusive with all other properties
	ServerPort *DeliveryRuleServerPortCondition `json:"serverPort,omitempty"`

	// SocketAddr: Mutually exclusive with all other properties
	SocketAddr *DeliveryRuleSocketAddrCondition `json:"socketAddr,omitempty"`

	// SslProtocol: Mutually exclusive with all other properties
	SslProtocol *DeliveryRuleSslProtocolCondition `json:"sslProtocol,omitempty"`

	// UrlFileExtension: Mutually exclusive with all other properties
	UrlFileExtension *DeliveryRuleUrlFileExtensionCondition `json:"urlFileExtension,omitempty"`

	// UrlFileName: Mutually exclusive with all other properties
	UrlFileName *DeliveryRuleUrlFileNameCondition `json:"urlFileName,omitempty"`

	// UrlPath: Mutually exclusive with all other properties
	UrlPath *DeliveryRuleUrlPathCondition `json:"urlPath,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &arm.DeliveryRuleCondition{}

	// Set property "ClientPort":
	if condition.ClientPort != nil {
		clientPort_ARM, err := (*condition.ClientPort).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		clientPort := *clientPort_ARM.(*arm.DeliveryRuleClientPortCondition)
		result.ClientPort = &clientPort
	}

	// Set property "Cookies":
	if condition.Cookies != nil {
		cookies_ARM, err := (*condition.Cookies).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		cookies := *cookies_ARM.(*arm.DeliveryRuleCookiesCondition)
		result.Cookies = &cookies
	}

	// Set property "HostName":
	if condition.HostName != nil {
		hostName_ARM, err := (*condition.HostName).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		hostName := *hostName_ARM.(*arm.DeliveryRuleHostNameCondition)
		result.HostName = &hostName
	}

	// Set property "HttpVersion":
	if condition.HttpVersion != nil {
		httpVersion_ARM, err := (*condition.HttpVersion).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		httpVersion := *httpVersion_ARM.(*arm.DeliveryRuleHttpVersionCondition)
		result.HttpVersion = &httpVersion
	}

	// Set property "IsDevice":
	if condition.IsDevice != nil {
		isDevice_ARM, err := (*condition.IsDevice).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		isDevice := *isDevice_ARM.(*arm.DeliveryRuleIsDeviceCondition)
		result.IsDevice = &isDevice
	}

	// Set property "PostArgs":
	if condition.PostArgs != nil {
		postArgs_ARM, err := (*condition.PostArgs).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		postArgs := *postArgs_ARM.(*arm.DeliveryRulePostArgsCondition)
		result.PostArgs = &postArgs
	}

	// Set property "QueryString":
	if condition.QueryString != nil {
		queryString_ARM, err := (*condition.QueryString).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		queryString := *queryString_ARM.(*arm.DeliveryRuleQueryStringCondition)
		result.QueryString = &queryString
	}

	// Set property "RemoteAddress":
	if condition.RemoteAddress != nil {
		remoteAddress_ARM, err := (*condition.RemoteAddress).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		remoteAddress := *remoteAddress_ARM.(*arm.DeliveryRuleRemoteAddressCondition)
		result.RemoteAddress = &remoteAddress
	}

	// Set property "RequestBody":
	if condition.RequestBody != nil {
		requestBody_ARM, err := (*condition.RequestBody).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		requestBody := *requestBody_ARM.(*arm.DeliveryRuleRequestBodyCondition)
		result.RequestBody = &requestBody
	}

	// Set property "RequestHeader":
	if condition.RequestHeader != nil {
		requestHeader_ARM, err := (*condition.RequestHeader).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		requestHeader := *requestHeader_ARM.(*arm.DeliveryRuleRequestHeaderCondition)
		result.RequestHeader = &requestHeader
	}

	// Set property "RequestMethod":
	if condition.RequestMethod != nil {
		requestMethod_ARM, err := (*condition.RequestMethod).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		requestMethod := *requestMethod_ARM.(*arm.DeliveryRuleRequestMethodCondition)
		result.RequestMethod = &requestMethod
	}

	// Set property "RequestScheme":
	if condition.RequestScheme != nil {
		requestScheme_ARM, err := (*condition.RequestScheme).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		requestScheme := *requestScheme_ARM.(*arm.DeliveryRuleRequestSchemeCondition)
		result.RequestScheme = &requestScheme
	}

	// Set property "RequestUri":
	if condition.RequestUri != nil {
		requestUri_ARM, err := (*condition.RequestUri).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		requestUri := *requestUri_ARM.(*arm.DeliveryRuleRequestUriCondition)
		result.RequestUri = &requestUri
	}

	// Set property "ServerPort":
	if condition.ServerPort != nil {
		serverPort_ARM, err := (*condition.ServerPort).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		serverPort := *serverPort_ARM.(*arm.DeliveryRuleServerPortCondition)
		result.ServerPort = &serverPort
	}

	// Set property "SocketAddr":
	if condition.SocketAddr != nil {
		socketAddr_ARM, err := (*condition.SocketAddr).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		socketAddr := *socketAddr_ARM.(*arm.DeliveryRuleSocketAddrCondition)
		result.SocketAddr = &socketAddr
	}

	// Set property "SslProtocol":
	if condition.SslProtocol != nil {
		sslProtocol_ARM, err := (*condition.SslProtocol).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sslProtocol := *sslProtocol_ARM.(*arm.DeliveryRuleSslProtocolCondition)
		result.SslProtocol = &sslProtocol
	}

	// Set property "UrlFileExtension":
	if condition.UrlFileExtension != nil {
		urlFileExtension_ARM, err := (*condition.UrlFileExtension).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		urlFileExtension := *urlFileExtension_ARM.(*arm.DeliveryRuleUrlFileExtensionCondition)
		result.UrlFileExtension = &urlFileExtension
	}

	// Set property "UrlFileName":
	if condition.UrlFileName != nil {
		urlFileName_ARM, err := (*condition.UrlFileName).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		urlFileName := *urlFileName_ARM.(*arm.DeliveryRuleUrlFileNameCondition)
		result.UrlFileName = &urlFileName
	}

	// Set property "UrlPath":
	if condition.UrlPath != nil {
		urlPath_ARM, err := (*condition.UrlPath).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		urlPath := *urlPath_ARM.(*arm.DeliveryRuleUrlPathCondition)
		result.UrlPath = &urlPath
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleCondition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleCondition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleCondition, got %T", armInput)
	}

	// Set property "ClientPort":
	if typedInput.ClientPort != nil {
		var clientPort1 DeliveryRuleClientPortCondition
		err := clientPort1.PopulateFromARM(owner, *typedInput.ClientPort)
		if err != nil {
			return err
		}
		clientPort := clientPort1
		condition.ClientPort = &clientPort
	}

	// Set property "Cookies":
	if typedInput.Cookies != nil {
		var cookies1 DeliveryRuleCookiesCondition
		err := cookies1.PopulateFromARM(owner, *typedInput.Cookies)
		if err != nil {
			return err
		}
		cookies := cookies1
		condition.Cookies = &cookies
	}

	// Set property "HostName":
	if typedInput.HostName != nil {
		var hostName1 DeliveryRuleHostNameCondition
		err := hostName1.PopulateFromARM(owner, *typedInput.HostName)
		if err != nil {
			return err
		}
		hostName := hostName1
		condition.HostName = &hostName
	}

	// Set property "HttpVersion":
	if typedInput.HttpVersion != nil {
		var httpVersion1 DeliveryRuleHttpVersionCondition
		err := httpVersion1.PopulateFromARM(owner, *typedInput.HttpVersion)
		if err != nil {
			return err
		}
		httpVersion := httpVersion1
		condition.HttpVersion = &httpVersion
	}

	// Set property "IsDevice":
	if typedInput.IsDevice != nil {
		var isDevice1 DeliveryRuleIsDeviceCondition
		err := isDevice1.PopulateFromARM(owner, *typedInput.IsDevice)
		if err != nil {
			return err
		}
		isDevice := isDevice1
		condition.IsDevice = &isDevice
	}

	// Set property "PostArgs":
	if typedInput.PostArgs != nil {
		var postArgs1 DeliveryRulePostArgsCondition
		err := postArgs1.PopulateFromARM(owner, *typedInput.PostArgs)
		if err != nil {
			return err
		}
		postArgs := postArgs1
		condition.PostArgs = &postArgs
	}

	// Set property "QueryString":
	if typedInput.QueryString != nil {
		var queryString1 DeliveryRuleQueryStringCondition
		err := queryString1.PopulateFromARM(owner, *typedInput.QueryString)
		if err != nil {
			return err
		}
		queryString := queryString1
		condition.QueryString = &queryString
	}

	// Set property "RemoteAddress":
	if typedInput.RemoteAddress != nil {
		var remoteAddress1 DeliveryRuleRemoteAddressCondition
		err := remoteAddress1.PopulateFromARM(owner, *typedInput.RemoteAddress)
		if err != nil {
			return err
		}
		remoteAddress := remoteAddress1
		condition.RemoteAddress = &remoteAddress
	}

	// Set property "RequestBody":
	if typedInput.RequestBody != nil {
		var requestBody1 DeliveryRuleRequestBodyCondition
		err := requestBody1.PopulateFromARM(owner, *typedInput.RequestBody)
		if err != nil {
			return err
		}
		requestBody := requestBody1
		condition.RequestBody = &requestBody
	}

	// Set property "RequestHeader":
	if typedInput.RequestHeader != nil {
		var requestHeader1 DeliveryRuleRequestHeaderCondition
		err := requestHeader1.PopulateFromARM(owner, *typedInput.RequestHeader)
		if err != nil {
			return err
		}
		requestHeader := requestHeader1
		condition.RequestHeader = &requestHeader
	}

	// Set property "RequestMethod":
	if typedInput.RequestMethod != nil {
		var requestMethod1 DeliveryRuleRequestMethodCondition
		err := requestMethod1.PopulateFromARM(owner, *typedInput.RequestMethod)
		if err != nil {
			return err
		}
		requestMethod := requestMethod1
		condition.RequestMethod = &requestMethod
	}

	// Set property "RequestScheme":
	if typedInput.RequestScheme != nil {
		var requestScheme1 DeliveryRuleRequestSchemeCondition
		err := requestScheme1.PopulateFromARM(owner, *typedInput.RequestScheme)
		if err != nil {
			return err
		}
		requestScheme := requestScheme1
		condition.RequestScheme = &requestScheme
	}

	// Set property "RequestUri":
	if typedInput.RequestUri != nil {
		var requestUri1 DeliveryRuleRequestUriCondition
		err := requestUri1.PopulateFromARM(owner, *typedInput.RequestUri)
		if err != nil {
			return err
		}
		requestUri := requestUri1
		condition.RequestUri = &requestUri
	}

	// Set property "ServerPort":
	if typedInput.ServerPort != nil {
		var serverPort1 DeliveryRuleServerPortCondition
		err := serverPort1.PopulateFromARM(owner, *typedInput.ServerPort)
		if err != nil {
			return err
		}
		serverPort := serverPort1
		condition.ServerPort = &serverPort
	}

	// Set property "SocketAddr":
	if typedInput.SocketAddr != nil {
		var socketAddr1 DeliveryRuleSocketAddrCondition
		err := socketAddr1.PopulateFromARM(owner, *typedInput.SocketAddr)
		if err != nil {
			return err
		}
		socketAddr := socketAddr1
		condition.SocketAddr = &socketAddr
	}

	// Set property "SslProtocol":
	if typedInput.SslProtocol != nil {
		var sslProtocol1 DeliveryRuleSslProtocolCondition
		err := sslProtocol1.PopulateFromARM(owner, *typedInput.SslProtocol)
		if err != nil {
			return err
		}
		sslProtocol := sslProtocol1
		condition.SslProtocol = &sslProtocol
	}

	// Set property "UrlFileExtension":
	if typedInput.UrlFileExtension != nil {
		var urlFileExtension1 DeliveryRuleUrlFileExtensionCondition
		err := urlFileExtension1.PopulateFromARM(owner, *typedInput.UrlFileExtension)
		if err != nil {
			return err
		}
		urlFileExtension := urlFileExtension1
		condition.UrlFileExtension = &urlFileExtension
	}

	// Set property "UrlFileName":
	if typedInput.UrlFileName != nil {
		var urlFileName1 DeliveryRuleUrlFileNameCondition
		err := urlFileName1.PopulateFromARM(owner, *typedInput.UrlFileName)
		if err != nil {
			return err
		}
		urlFileName := urlFileName1
		condition.UrlFileName = &urlFileName
	}

	// Set property "UrlPath":
	if typedInput.UrlPath != nil {
		var urlPath1 DeliveryRuleUrlPathCondition
		err := urlPath1.PopulateFromARM(owner, *typedInput.UrlPath)
		if err != nil {
			return err
		}
		urlPath := urlPath1
		condition.UrlPath = &urlPath
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleCondition populates our DeliveryRuleCondition from the provided source DeliveryRuleCondition
func (condition *DeliveryRuleCondition) AssignProperties_From_DeliveryRuleCondition(source *storage.DeliveryRuleCondition) error {

	// ClientPort
	if source.ClientPort != nil {
		var clientPort DeliveryRuleClientPortCondition
		err := clientPort.AssignProperties_From_DeliveryRuleClientPortCondition(source.ClientPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleClientPortCondition() to populate field ClientPort")
		}
		condition.ClientPort = &clientPort
	} else {
		condition.ClientPort = nil
	}

	// Cookies
	if source.Cookies != nil {
		var cookie DeliveryRuleCookiesCondition
		err := cookie.AssignProperties_From_DeliveryRuleCookiesCondition(source.Cookies)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleCookiesCondition() to populate field Cookies")
		}
		condition.Cookies = &cookie
	} else {
		condition.Cookies = nil
	}

	// HostName
	if source.HostName != nil {
		var hostName DeliveryRuleHostNameCondition
		err := hostName.AssignProperties_From_DeliveryRuleHostNameCondition(source.HostName)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleHostNameCondition() to populate field HostName")
		}
		condition.HostName = &hostName
	} else {
		condition.HostName = nil
	}

	// HttpVersion
	if source.HttpVersion != nil {
		var httpVersion DeliveryRuleHttpVersionCondition
		err := httpVersion.AssignProperties_From_DeliveryRuleHttpVersionCondition(source.HttpVersion)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleHttpVersionCondition() to populate field HttpVersion")
		}
		condition.HttpVersion = &httpVersion
	} else {
		condition.HttpVersion = nil
	}

	// IsDevice
	if source.IsDevice != nil {
		var isDevice DeliveryRuleIsDeviceCondition
		err := isDevice.AssignProperties_From_DeliveryRuleIsDeviceCondition(source.IsDevice)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleIsDeviceCondition() to populate field IsDevice")
		}
		condition.IsDevice = &isDevice
	} else {
		condition.IsDevice = nil
	}

	// PostArgs
	if source.PostArgs != nil {
		var postArg DeliveryRulePostArgsCondition
		err := postArg.AssignProperties_From_DeliveryRulePostArgsCondition(source.PostArgs)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRulePostArgsCondition() to populate field PostArgs")
		}
		condition.PostArgs = &postArg
	} else {
		condition.PostArgs = nil
	}

	// QueryString
	if source.QueryString != nil {
		var queryString DeliveryRuleQueryStringCondition
		err := queryString.AssignProperties_From_DeliveryRuleQueryStringCondition(source.QueryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleQueryStringCondition() to populate field QueryString")
		}
		condition.QueryString = &queryString
	} else {
		condition.QueryString = nil
	}

	// RemoteAddress
	if source.RemoteAddress != nil {
		var remoteAddress DeliveryRuleRemoteAddressCondition
		err := remoteAddress.AssignProperties_From_DeliveryRuleRemoteAddressCondition(source.RemoteAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRemoteAddressCondition() to populate field RemoteAddress")
		}
		condition.RemoteAddress = &remoteAddress
	} else {
		condition.RemoteAddress = nil
	}

	// RequestBody
	if source.RequestBody != nil {
		var requestBody DeliveryRuleRequestBodyCondition
		err := requestBody.AssignProperties_From_DeliveryRuleRequestBodyCondition(source.RequestBody)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestBodyCondition() to populate field RequestBody")
		}
		condition.RequestBody = &requestBody
	} else {
		condition.RequestBody = nil
	}

	// RequestHeader
	if source.RequestHeader != nil {
		var requestHeader DeliveryRuleRequestHeaderCondition
		err := requestHeader.AssignProperties_From_DeliveryRuleRequestHeaderCondition(source.RequestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestHeaderCondition() to populate field RequestHeader")
		}
		condition.RequestHeader = &requestHeader
	} else {
		condition.RequestHeader = nil
	}

	// RequestMethod
	if source.RequestMethod != nil {
		var requestMethod DeliveryRuleRequestMethodCondition
		err := requestMethod.AssignProperties_From_DeliveryRuleRequestMethodCondition(source.RequestMethod)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestMethodCondition() to populate field RequestMethod")
		}
		condition.RequestMethod = &requestMethod
	} else {
		condition.RequestMethod = nil
	}

	// RequestScheme
	if source.RequestScheme != nil {
		var requestScheme DeliveryRuleRequestSchemeCondition
		err := requestScheme.AssignProperties_From_DeliveryRuleRequestSchemeCondition(source.RequestScheme)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestSchemeCondition() to populate field RequestScheme")
		}
		condition.RequestScheme = &requestScheme
	} else {
		condition.RequestScheme = nil
	}

	// RequestUri
	if source.RequestUri != nil {
		var requestUri DeliveryRuleRequestUriCondition
		err := requestUri.AssignProperties_From_DeliveryRuleRequestUriCondition(source.RequestUri)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestUriCondition() to populate field RequestUri")
		}
		condition.RequestUri = &requestUri
	} else {
		condition.RequestUri = nil
	}

	// ServerPort
	if source.ServerPort != nil {
		var serverPort DeliveryRuleServerPortCondition
		err := serverPort.AssignProperties_From_DeliveryRuleServerPortCondition(source.ServerPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleServerPortCondition() to populate field ServerPort")
		}
		condition.ServerPort = &serverPort
	} else {
		condition.ServerPort = nil
	}

	// SocketAddr
	if source.SocketAddr != nil {
		var socketAddr DeliveryRuleSocketAddrCondition
		err := socketAddr.AssignProperties_From_DeliveryRuleSocketAddrCondition(source.SocketAddr)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleSocketAddrCondition() to populate field SocketAddr")
		}
		condition.SocketAddr = &socketAddr
	} else {
		condition.SocketAddr = nil
	}

	// SslProtocol
	if source.SslProtocol != nil {
		var sslProtocol DeliveryRuleSslProtocolCondition
		err := sslProtocol.AssignProperties_From_DeliveryRuleSslProtocolCondition(source.SslProtocol)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleSslProtocolCondition() to populate field SslProtocol")
		}
		condition.SslProtocol = &sslProtocol
	} else {
		condition.SslProtocol = nil
	}

	// UrlFileExtension
	if source.UrlFileExtension != nil {
		var urlFileExtension DeliveryRuleUrlFileExtensionCondition
		err := urlFileExtension.AssignProperties_From_DeliveryRuleUrlFileExtensionCondition(source.UrlFileExtension)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleUrlFileExtensionCondition() to populate field UrlFileExtension")
		}
		condition.UrlFileExtension = &urlFileExtension
	} else {
		condition.UrlFileExtension = nil
	}

	// UrlFileName
	if source.UrlFileName != nil {
		var urlFileName DeliveryRuleUrlFileNameCondition
		err := urlFileName.AssignProperties_From_DeliveryRuleUrlFileNameCondition(source.UrlFileName)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleUrlFileNameCondition() to populate field UrlFileName")
		}
		condition.UrlFileName = &urlFileName
	} else {
		condition.UrlFileName = nil
	}

	// UrlPath
	if source.UrlPath != nil {
		var urlPath DeliveryRuleUrlPathCondition
		err := urlPath.AssignProperties_From_DeliveryRuleUrlPathCondition(source.UrlPath)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleUrlPathCondition() to populate field UrlPath")
		}
		condition.UrlPath = &urlPath
	} else {
		condition.UrlPath = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleCondition populates the provided destination DeliveryRuleCondition from our DeliveryRuleCondition
func (condition *DeliveryRuleCondition) AssignProperties_To_DeliveryRuleCondition(destination *storage.DeliveryRuleCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientPort
	if condition.ClientPort != nil {
		var clientPort storage.DeliveryRuleClientPortCondition
		err := condition.ClientPort.AssignProperties_To_DeliveryRuleClientPortCondition(&clientPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleClientPortCondition() to populate field ClientPort")
		}
		destination.ClientPort = &clientPort
	} else {
		destination.ClientPort = nil
	}

	// Cookies
	if condition.Cookies != nil {
		var cookie storage.DeliveryRuleCookiesCondition
		err := condition.Cookies.AssignProperties_To_DeliveryRuleCookiesCondition(&cookie)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleCookiesCondition() to populate field Cookies")
		}
		destination.Cookies = &cookie
	} else {
		destination.Cookies = nil
	}

	// HostName
	if condition.HostName != nil {
		var hostName storage.DeliveryRuleHostNameCondition
		err := condition.HostName.AssignProperties_To_DeliveryRuleHostNameCondition(&hostName)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleHostNameCondition() to populate field HostName")
		}
		destination.HostName = &hostName
	} else {
		destination.HostName = nil
	}

	// HttpVersion
	if condition.HttpVersion != nil {
		var httpVersion storage.DeliveryRuleHttpVersionCondition
		err := condition.HttpVersion.AssignProperties_To_DeliveryRuleHttpVersionCondition(&httpVersion)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleHttpVersionCondition() to populate field HttpVersion")
		}
		destination.HttpVersion = &httpVersion
	} else {
		destination.HttpVersion = nil
	}

	// IsDevice
	if condition.IsDevice != nil {
		var isDevice storage.DeliveryRuleIsDeviceCondition
		err := condition.IsDevice.AssignProperties_To_DeliveryRuleIsDeviceCondition(&isDevice)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleIsDeviceCondition() to populate field IsDevice")
		}
		destination.IsDevice = &isDevice
	} else {
		destination.IsDevice = nil
	}

	// PostArgs
	if condition.PostArgs != nil {
		var postArg storage.DeliveryRulePostArgsCondition
		err := condition.PostArgs.AssignProperties_To_DeliveryRulePostArgsCondition(&postArg)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRulePostArgsCondition() to populate field PostArgs")
		}
		destination.PostArgs = &postArg
	} else {
		destination.PostArgs = nil
	}

	// QueryString
	if condition.QueryString != nil {
		var queryString storage.DeliveryRuleQueryStringCondition
		err := condition.QueryString.AssignProperties_To_DeliveryRuleQueryStringCondition(&queryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleQueryStringCondition() to populate field QueryString")
		}
		destination.QueryString = &queryString
	} else {
		destination.QueryString = nil
	}

	// RemoteAddress
	if condition.RemoteAddress != nil {
		var remoteAddress storage.DeliveryRuleRemoteAddressCondition
		err := condition.RemoteAddress.AssignProperties_To_DeliveryRuleRemoteAddressCondition(&remoteAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRemoteAddressCondition() to populate field RemoteAddress")
		}
		destination.RemoteAddress = &remoteAddress
	} else {
		destination.RemoteAddress = nil
	}

	// RequestBody
	if condition.RequestBody != nil {
		var requestBody storage.DeliveryRuleRequestBodyCondition
		err := condition.RequestBody.AssignProperties_To_DeliveryRuleRequestBodyCondition(&requestBody)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestBodyCondition() to populate field RequestBody")
		}
		destination.RequestBody = &requestBody
	} else {
		destination.RequestBody = nil
	}

	// RequestHeader
	if condition.RequestHeader != nil {
		var requestHeader storage.DeliveryRuleRequestHeaderCondition
		err := condition.RequestHeader.AssignProperties_To_DeliveryRuleRequestHeaderCondition(&requestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestHeaderCondition() to populate field RequestHeader")
		}
		destination.RequestHeader = &requestHeader
	} else {
		destination.RequestHeader = nil
	}

	// RequestMethod
	if condition.RequestMethod != nil {
		var requestMethod storage.DeliveryRuleRequestMethodCondition
		err := condition.RequestMethod.AssignProperties_To_DeliveryRuleRequestMethodCondition(&requestMethod)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestMethodCondition() to populate field RequestMethod")
		}
		destination.RequestMethod = &requestMethod
	} else {
		destination.RequestMethod = nil
	}

	// RequestScheme
	if condition.RequestScheme != nil {
		var requestScheme storage.DeliveryRuleRequestSchemeCondition
		err := condition.RequestScheme.AssignProperties_To_DeliveryRuleRequestSchemeCondition(&requestScheme)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestSchemeCondition() to populate field RequestScheme")
		}
		destination.RequestScheme = &requestScheme
	} else {
		destination.RequestScheme = nil
	}

	// RequestUri
	if condition.RequestUri != nil {
		var requestUri storage.DeliveryRuleRequestUriCondition
		err := condition.RequestUri.AssignProperties_To_DeliveryRuleRequestUriCondition(&requestUri)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestUriCondition() to populate field RequestUri")
		}
		destination.RequestUri = &requestUri
	} else {
		destination.RequestUri = nil
	}

	// ServerPort
	if condition.ServerPort != nil {
		var serverPort storage.DeliveryRuleServerPortCondition
		err := condition.ServerPort.AssignProperties_To_DeliveryRuleServerPortCondition(&serverPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleServerPortCondition() to populate field ServerPort")
		}
		destination.ServerPort = &serverPort
	} else {
		destination.ServerPort = nil
	}

	// SocketAddr
	if condition.SocketAddr != nil {
		var socketAddr storage.DeliveryRuleSocketAddrCondition
		err := condition.SocketAddr.AssignProperties_To_DeliveryRuleSocketAddrCondition(&socketAddr)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleSocketAddrCondition() to populate field SocketAddr")
		}
		destination.SocketAddr = &socketAddr
	} else {
		destination.SocketAddr = nil
	}

	// SslProtocol
	if condition.SslProtocol != nil {
		var sslProtocol storage.DeliveryRuleSslProtocolCondition
		err := condition.SslProtocol.AssignProperties_To_DeliveryRuleSslProtocolCondition(&sslProtocol)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleSslProtocolCondition() to populate field SslProtocol")
		}
		destination.SslProtocol = &sslProtocol
	} else {
		destination.SslProtocol = nil
	}

	// UrlFileExtension
	if condition.UrlFileExtension != nil {
		var urlFileExtension storage.DeliveryRuleUrlFileExtensionCondition
		err := condition.UrlFileExtension.AssignProperties_To_DeliveryRuleUrlFileExtensionCondition(&urlFileExtension)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleUrlFileExtensionCondition() to populate field UrlFileExtension")
		}
		destination.UrlFileExtension = &urlFileExtension
	} else {
		destination.UrlFileExtension = nil
	}

	// UrlFileName
	if condition.UrlFileName != nil {
		var urlFileName storage.DeliveryRuleUrlFileNameCondition
		err := condition.UrlFileName.AssignProperties_To_DeliveryRuleUrlFileNameCondition(&urlFileName)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleUrlFileNameCondition() to populate field UrlFileName")
		}
		destination.UrlFileName = &urlFileName
	} else {
		destination.UrlFileName = nil
	}

	// UrlPath
	if condition.UrlPath != nil {
		var urlPath storage.DeliveryRuleUrlPathCondition
		err := condition.UrlPath.AssignProperties_To_DeliveryRuleUrlPathCondition(&urlPath)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleUrlPathCondition() to populate field UrlPath")
		}
		destination.UrlPath = &urlPath
	} else {
		destination.UrlPath = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleCondition_STATUS populates our DeliveryRuleCondition from the provided source DeliveryRuleCondition_STATUS
func (condition *DeliveryRuleCondition) Initialize_From_DeliveryRuleCondition_STATUS(source *DeliveryRuleCondition_STATUS) error {

	// ClientPort
	if source.ClientPort != nil {
		var clientPort DeliveryRuleClientPortCondition
		err := clientPort.Initialize_From_DeliveryRuleClientPortCondition_STATUS(source.ClientPort)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleClientPortCondition_STATUS() to populate field ClientPort")
		}
		condition.ClientPort = &clientPort
	} else {
		condition.ClientPort = nil
	}

	// Cookies
	if source.Cookies != nil {
		var cookie DeliveryRuleCookiesCondition
		err := cookie.Initialize_From_DeliveryRuleCookiesCondition_STATUS(source.Cookies)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleCookiesCondition_STATUS() to populate field Cookies")
		}
		condition.Cookies = &cookie
	} else {
		condition.Cookies = nil
	}

	// HostName
	if source.HostName != nil {
		var hostName DeliveryRuleHostNameCondition
		err := hostName.Initialize_From_DeliveryRuleHostNameCondition_STATUS(source.HostName)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleHostNameCondition_STATUS() to populate field HostName")
		}
		condition.HostName = &hostName
	} else {
		condition.HostName = nil
	}

	// HttpVersion
	if source.HttpVersion != nil {
		var httpVersion DeliveryRuleHttpVersionCondition
		err := httpVersion.Initialize_From_DeliveryRuleHttpVersionCondition_STATUS(source.HttpVersion)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleHttpVersionCondition_STATUS() to populate field HttpVersion")
		}
		condition.HttpVersion = &httpVersion
	} else {
		condition.HttpVersion = nil
	}

	// IsDevice
	if source.IsDevice != nil {
		var isDevice DeliveryRuleIsDeviceCondition
		err := isDevice.Initialize_From_DeliveryRuleIsDeviceCondition_STATUS(source.IsDevice)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleIsDeviceCondition_STATUS() to populate field IsDevice")
		}
		condition.IsDevice = &isDevice
	} else {
		condition.IsDevice = nil
	}

	// PostArgs
	if source.PostArgs != nil {
		var postArg DeliveryRulePostArgsCondition
		err := postArg.Initialize_From_DeliveryRulePostArgsCondition_STATUS(source.PostArgs)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRulePostArgsCondition_STATUS() to populate field PostArgs")
		}
		condition.PostArgs = &postArg
	} else {
		condition.PostArgs = nil
	}

	// QueryString
	if source.QueryString != nil {
		var queryString DeliveryRuleQueryStringCondition
		err := queryString.Initialize_From_DeliveryRuleQueryStringCondition_STATUS(source.QueryString)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleQueryStringCondition_STATUS() to populate field QueryString")
		}
		condition.QueryString = &queryString
	} else {
		condition.QueryString = nil
	}

	// RemoteAddress
	if source.RemoteAddress != nil {
		var remoteAddress DeliveryRuleRemoteAddressCondition
		err := remoteAddress.Initialize_From_DeliveryRuleRemoteAddressCondition_STATUS(source.RemoteAddress)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleRemoteAddressCondition_STATUS() to populate field RemoteAddress")
		}
		condition.RemoteAddress = &remoteAddress
	} else {
		condition.RemoteAddress = nil
	}

	// RequestBody
	if source.RequestBody != nil {
		var requestBody DeliveryRuleRequestBodyCondition
		err := requestBody.Initialize_From_DeliveryRuleRequestBodyCondition_STATUS(source.RequestBody)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleRequestBodyCondition_STATUS() to populate field RequestBody")
		}
		condition.RequestBody = &requestBody
	} else {
		condition.RequestBody = nil
	}

	// RequestHeader
	if source.RequestHeader != nil {
		var requestHeader DeliveryRuleRequestHeaderCondition
		err := requestHeader.Initialize_From_DeliveryRuleRequestHeaderCondition_STATUS(source.RequestHeader)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleRequestHeaderCondition_STATUS() to populate field RequestHeader")
		}
		condition.RequestHeader = &requestHeader
	} else {
		condition.RequestHeader = nil
	}

	// RequestMethod
	if source.RequestMethod != nil {
		var requestMethod DeliveryRuleRequestMethodCondition
		err := requestMethod.Initialize_From_DeliveryRuleRequestMethodCondition_STATUS(source.RequestMethod)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleRequestMethodCondition_STATUS() to populate field RequestMethod")
		}
		condition.RequestMethod = &requestMethod
	} else {
		condition.RequestMethod = nil
	}

	// RequestScheme
	if source.RequestScheme != nil {
		var requestScheme DeliveryRuleRequestSchemeCondition
		err := requestScheme.Initialize_From_DeliveryRuleRequestSchemeCondition_STATUS(source.RequestScheme)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleRequestSchemeCondition_STATUS() to populate field RequestScheme")
		}
		condition.RequestScheme = &requestScheme
	} else {
		condition.RequestScheme = nil
	}

	// RequestUri
	if source.RequestUri != nil {
		var requestUri DeliveryRuleRequestUriCondition
		err := requestUri.Initialize_From_DeliveryRuleRequestUriCondition_STATUS(source.RequestUri)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleRequestUriCondition_STATUS() to populate field RequestUri")
		}
		condition.RequestUri = &requestUri
	} else {
		condition.RequestUri = nil
	}

	// ServerPort
	if source.ServerPort != nil {
		var serverPort DeliveryRuleServerPortCondition
		err := serverPort.Initialize_From_DeliveryRuleServerPortCondition_STATUS(source.ServerPort)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleServerPortCondition_STATUS() to populate field ServerPort")
		}
		condition.ServerPort = &serverPort
	} else {
		condition.ServerPort = nil
	}

	// SocketAddr
	if source.SocketAddr != nil {
		var socketAddr DeliveryRuleSocketAddrCondition
		err := socketAddr.Initialize_From_DeliveryRuleSocketAddrCondition_STATUS(source.SocketAddr)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleSocketAddrCondition_STATUS() to populate field SocketAddr")
		}
		condition.SocketAddr = &socketAddr
	} else {
		condition.SocketAddr = nil
	}

	// SslProtocol
	if source.SslProtocol != nil {
		var sslProtocol DeliveryRuleSslProtocolCondition
		err := sslProtocol.Initialize_From_DeliveryRuleSslProtocolCondition_STATUS(source.SslProtocol)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleSslProtocolCondition_STATUS() to populate field SslProtocol")
		}
		condition.SslProtocol = &sslProtocol
	} else {
		condition.SslProtocol = nil
	}

	// UrlFileExtension
	if source.UrlFileExtension != nil {
		var urlFileExtension DeliveryRuleUrlFileExtensionCondition
		err := urlFileExtension.Initialize_From_DeliveryRuleUrlFileExtensionCondition_STATUS(source.UrlFileExtension)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleUrlFileExtensionCondition_STATUS() to populate field UrlFileExtension")
		}
		condition.UrlFileExtension = &urlFileExtension
	} else {
		condition.UrlFileExtension = nil
	}

	// UrlFileName
	if source.UrlFileName != nil {
		var urlFileName DeliveryRuleUrlFileNameCondition
		err := urlFileName.Initialize_From_DeliveryRuleUrlFileNameCondition_STATUS(source.UrlFileName)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleUrlFileNameCondition_STATUS() to populate field UrlFileName")
		}
		condition.UrlFileName = &urlFileName
	} else {
		condition.UrlFileName = nil
	}

	// UrlPath
	if source.UrlPath != nil {
		var urlPath DeliveryRuleUrlPathCondition
		err := urlPath.Initialize_From_DeliveryRuleUrlPathCondition_STATUS(source.UrlPath)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleUrlPathCondition_STATUS() to populate field UrlPath")
		}
		condition.UrlPath = &urlPath
	} else {
		condition.UrlPath = nil
	}

	// No error
	return nil
}

// A condition for the delivery rule.
type DeliveryRuleCondition_STATUS struct {
	// ClientPort: Mutually exclusive with all other properties
	ClientPort *DeliveryRuleClientPortCondition_STATUS `json:"clientPort,omitempty"`

	// Cookies: Mutually exclusive with all other properties
	Cookies *DeliveryRuleCookiesCondition_STATUS `json:"cookies,omitempty"`

	// HostName: Mutually exclusive with all other properties
	HostName *DeliveryRuleHostNameCondition_STATUS `json:"hostName,omitempty"`

	// HttpVersion: Mutually exclusive with all other properties
	HttpVersion *DeliveryRuleHttpVersionCondition_STATUS `json:"httpVersion,omitempty"`

	// IsDevice: Mutually exclusive with all other properties
	IsDevice *DeliveryRuleIsDeviceCondition_STATUS `json:"isDevice,omitempty"`

	// PostArgs: Mutually exclusive with all other properties
	PostArgs *DeliveryRulePostArgsCondition_STATUS `json:"postArgs,omitempty"`

	// QueryString: Mutually exclusive with all other properties
	QueryString *DeliveryRuleQueryStringCondition_STATUS `json:"queryString,omitempty"`

	// RemoteAddress: Mutually exclusive with all other properties
	RemoteAddress *DeliveryRuleRemoteAddressCondition_STATUS `json:"remoteAddress,omitempty"`

	// RequestBody: Mutually exclusive with all other properties
	RequestBody *DeliveryRuleRequestBodyCondition_STATUS `json:"requestBody,omitempty"`

	// RequestHeader: Mutually exclusive with all other properties
	RequestHeader *DeliveryRuleRequestHeaderCondition_STATUS `json:"requestHeader,omitempty"`

	// RequestMethod: Mutually exclusive with all other properties
	RequestMethod *DeliveryRuleRequestMethodCondition_STATUS `json:"requestMethod,omitempty"`

	// RequestScheme: Mutually exclusive with all other properties
	RequestScheme *DeliveryRuleRequestSchemeCondition_STATUS `json:"requestScheme,omitempty"`

	// RequestUri: Mutually exclusive with all other properties
	RequestUri *DeliveryRuleRequestUriCondition_STATUS `json:"requestUri,omitempty"`

	// ServerPort: Mutually exclusive with all other properties
	ServerPort *DeliveryRuleServerPortCondition_STATUS `json:"serverPort,omitempty"`

	// SocketAddr: Mutually exclusive with all other properties
	SocketAddr *DeliveryRuleSocketAddrCondition_STATUS `json:"socketAddr,omitempty"`

	// SslProtocol: Mutually exclusive with all other properties
	SslProtocol *DeliveryRuleSslProtocolCondition_STATUS `json:"sslProtocol,omitempty"`

	// UrlFileExtension: Mutually exclusive with all other properties
	UrlFileExtension *DeliveryRuleUrlFileExtensionCondition_STATUS `json:"urlFileExtension,omitempty"`

	// UrlFileName: Mutually exclusive with all other properties
	UrlFileName *DeliveryRuleUrlFileNameCondition_STATUS `json:"urlFileName,omitempty"`

	// UrlPath: Mutually exclusive with all other properties
	UrlPath *DeliveryRuleUrlPathCondition_STATUS `json:"urlPath,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleCondition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleCondition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleCondition_STATUS, got %T", armInput)
	}

	// Set property "ClientPort":
	if typedInput.ClientPort != nil {
		var clientPort1 DeliveryRuleClientPortCondition_STATUS
		err := clientPort1.PopulateFromARM(owner, *typedInput.ClientPort)
		if err != nil {
			return err
		}
		clientPort := clientPort1
		condition.ClientPort = &clientPort
	}

	// Set property "Cookies":
	if typedInput.Cookies != nil {
		var cookies1 DeliveryRuleCookiesCondition_STATUS
		err := cookies1.PopulateFromARM(owner, *typedInput.Cookies)
		if err != nil {
			return err
		}
		cookies := cookies1
		condition.Cookies = &cookies
	}

	// Set property "HostName":
	if typedInput.HostName != nil {
		var hostName1 DeliveryRuleHostNameCondition_STATUS
		err := hostName1.PopulateFromARM(owner, *typedInput.HostName)
		if err != nil {
			return err
		}
		hostName := hostName1
		condition.HostName = &hostName
	}

	// Set property "HttpVersion":
	if typedInput.HttpVersion != nil {
		var httpVersion1 DeliveryRuleHttpVersionCondition_STATUS
		err := httpVersion1.PopulateFromARM(owner, *typedInput.HttpVersion)
		if err != nil {
			return err
		}
		httpVersion := httpVersion1
		condition.HttpVersion = &httpVersion
	}

	// Set property "IsDevice":
	if typedInput.IsDevice != nil {
		var isDevice1 DeliveryRuleIsDeviceCondition_STATUS
		err := isDevice1.PopulateFromARM(owner, *typedInput.IsDevice)
		if err != nil {
			return err
		}
		isDevice := isDevice1
		condition.IsDevice = &isDevice
	}

	// Set property "PostArgs":
	if typedInput.PostArgs != nil {
		var postArgs1 DeliveryRulePostArgsCondition_STATUS
		err := postArgs1.PopulateFromARM(owner, *typedInput.PostArgs)
		if err != nil {
			return err
		}
		postArgs := postArgs1
		condition.PostArgs = &postArgs
	}

	// Set property "QueryString":
	if typedInput.QueryString != nil {
		var queryString1 DeliveryRuleQueryStringCondition_STATUS
		err := queryString1.PopulateFromARM(owner, *typedInput.QueryString)
		if err != nil {
			return err
		}
		queryString := queryString1
		condition.QueryString = &queryString
	}

	// Set property "RemoteAddress":
	if typedInput.RemoteAddress != nil {
		var remoteAddress1 DeliveryRuleRemoteAddressCondition_STATUS
		err := remoteAddress1.PopulateFromARM(owner, *typedInput.RemoteAddress)
		if err != nil {
			return err
		}
		remoteAddress := remoteAddress1
		condition.RemoteAddress = &remoteAddress
	}

	// Set property "RequestBody":
	if typedInput.RequestBody != nil {
		var requestBody1 DeliveryRuleRequestBodyCondition_STATUS
		err := requestBody1.PopulateFromARM(owner, *typedInput.RequestBody)
		if err != nil {
			return err
		}
		requestBody := requestBody1
		condition.RequestBody = &requestBody
	}

	// Set property "RequestHeader":
	if typedInput.RequestHeader != nil {
		var requestHeader1 DeliveryRuleRequestHeaderCondition_STATUS
		err := requestHeader1.PopulateFromARM(owner, *typedInput.RequestHeader)
		if err != nil {
			return err
		}
		requestHeader := requestHeader1
		condition.RequestHeader = &requestHeader
	}

	// Set property "RequestMethod":
	if typedInput.RequestMethod != nil {
		var requestMethod1 DeliveryRuleRequestMethodCondition_STATUS
		err := requestMethod1.PopulateFromARM(owner, *typedInput.RequestMethod)
		if err != nil {
			return err
		}
		requestMethod := requestMethod1
		condition.RequestMethod = &requestMethod
	}

	// Set property "RequestScheme":
	if typedInput.RequestScheme != nil {
		var requestScheme1 DeliveryRuleRequestSchemeCondition_STATUS
		err := requestScheme1.PopulateFromARM(owner, *typedInput.RequestScheme)
		if err != nil {
			return err
		}
		requestScheme := requestScheme1
		condition.RequestScheme = &requestScheme
	}

	// Set property "RequestUri":
	if typedInput.RequestUri != nil {
		var requestUri1 DeliveryRuleRequestUriCondition_STATUS
		err := requestUri1.PopulateFromARM(owner, *typedInput.RequestUri)
		if err != nil {
			return err
		}
		requestUri := requestUri1
		condition.RequestUri = &requestUri
	}

	// Set property "ServerPort":
	if typedInput.ServerPort != nil {
		var serverPort1 DeliveryRuleServerPortCondition_STATUS
		err := serverPort1.PopulateFromARM(owner, *typedInput.ServerPort)
		if err != nil {
			return err
		}
		serverPort := serverPort1
		condition.ServerPort = &serverPort
	}

	// Set property "SocketAddr":
	if typedInput.SocketAddr != nil {
		var socketAddr1 DeliveryRuleSocketAddrCondition_STATUS
		err := socketAddr1.PopulateFromARM(owner, *typedInput.SocketAddr)
		if err != nil {
			return err
		}
		socketAddr := socketAddr1
		condition.SocketAddr = &socketAddr
	}

	// Set property "SslProtocol":
	if typedInput.SslProtocol != nil {
		var sslProtocol1 DeliveryRuleSslProtocolCondition_STATUS
		err := sslProtocol1.PopulateFromARM(owner, *typedInput.SslProtocol)
		if err != nil {
			return err
		}
		sslProtocol := sslProtocol1
		condition.SslProtocol = &sslProtocol
	}

	// Set property "UrlFileExtension":
	if typedInput.UrlFileExtension != nil {
		var urlFileExtension1 DeliveryRuleUrlFileExtensionCondition_STATUS
		err := urlFileExtension1.PopulateFromARM(owner, *typedInput.UrlFileExtension)
		if err != nil {
			return err
		}
		urlFileExtension := urlFileExtension1
		condition.UrlFileExtension = &urlFileExtension
	}

	// Set property "UrlFileName":
	if typedInput.UrlFileName != nil {
		var urlFileName1 DeliveryRuleUrlFileNameCondition_STATUS
		err := urlFileName1.PopulateFromARM(owner, *typedInput.UrlFileName)
		if err != nil {
			return err
		}
		urlFileName := urlFileName1
		condition.UrlFileName = &urlFileName
	}

	// Set property "UrlPath":
	if typedInput.UrlPath != nil {
		var urlPath1 DeliveryRuleUrlPathCondition_STATUS
		err := urlPath1.PopulateFromARM(owner, *typedInput.UrlPath)
		if err != nil {
			return err
		}
		urlPath := urlPath1
		condition.UrlPath = &urlPath
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleCondition_STATUS populates our DeliveryRuleCondition_STATUS from the provided source DeliveryRuleCondition_STATUS
func (condition *DeliveryRuleCondition_STATUS) AssignProperties_From_DeliveryRuleCondition_STATUS(source *storage.DeliveryRuleCondition_STATUS) error {

	// ClientPort
	if source.ClientPort != nil {
		var clientPort DeliveryRuleClientPortCondition_STATUS
		err := clientPort.AssignProperties_From_DeliveryRuleClientPortCondition_STATUS(source.ClientPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleClientPortCondition_STATUS() to populate field ClientPort")
		}
		condition.ClientPort = &clientPort
	} else {
		condition.ClientPort = nil
	}

	// Cookies
	if source.Cookies != nil {
		var cookie DeliveryRuleCookiesCondition_STATUS
		err := cookie.AssignProperties_From_DeliveryRuleCookiesCondition_STATUS(source.Cookies)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleCookiesCondition_STATUS() to populate field Cookies")
		}
		condition.Cookies = &cookie
	} else {
		condition.Cookies = nil
	}

	// HostName
	if source.HostName != nil {
		var hostName DeliveryRuleHostNameCondition_STATUS
		err := hostName.AssignProperties_From_DeliveryRuleHostNameCondition_STATUS(source.HostName)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleHostNameCondition_STATUS() to populate field HostName")
		}
		condition.HostName = &hostName
	} else {
		condition.HostName = nil
	}

	// HttpVersion
	if source.HttpVersion != nil {
		var httpVersion DeliveryRuleHttpVersionCondition_STATUS
		err := httpVersion.AssignProperties_From_DeliveryRuleHttpVersionCondition_STATUS(source.HttpVersion)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleHttpVersionCondition_STATUS() to populate field HttpVersion")
		}
		condition.HttpVersion = &httpVersion
	} else {
		condition.HttpVersion = nil
	}

	// IsDevice
	if source.IsDevice != nil {
		var isDevice DeliveryRuleIsDeviceCondition_STATUS
		err := isDevice.AssignProperties_From_DeliveryRuleIsDeviceCondition_STATUS(source.IsDevice)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleIsDeviceCondition_STATUS() to populate field IsDevice")
		}
		condition.IsDevice = &isDevice
	} else {
		condition.IsDevice = nil
	}

	// PostArgs
	if source.PostArgs != nil {
		var postArg DeliveryRulePostArgsCondition_STATUS
		err := postArg.AssignProperties_From_DeliveryRulePostArgsCondition_STATUS(source.PostArgs)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRulePostArgsCondition_STATUS() to populate field PostArgs")
		}
		condition.PostArgs = &postArg
	} else {
		condition.PostArgs = nil
	}

	// QueryString
	if source.QueryString != nil {
		var queryString DeliveryRuleQueryStringCondition_STATUS
		err := queryString.AssignProperties_From_DeliveryRuleQueryStringCondition_STATUS(source.QueryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleQueryStringCondition_STATUS() to populate field QueryString")
		}
		condition.QueryString = &queryString
	} else {
		condition.QueryString = nil
	}

	// RemoteAddress
	if source.RemoteAddress != nil {
		var remoteAddress DeliveryRuleRemoteAddressCondition_STATUS
		err := remoteAddress.AssignProperties_From_DeliveryRuleRemoteAddressCondition_STATUS(source.RemoteAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRemoteAddressCondition_STATUS() to populate field RemoteAddress")
		}
		condition.RemoteAddress = &remoteAddress
	} else {
		condition.RemoteAddress = nil
	}

	// RequestBody
	if source.RequestBody != nil {
		var requestBody DeliveryRuleRequestBodyCondition_STATUS
		err := requestBody.AssignProperties_From_DeliveryRuleRequestBodyCondition_STATUS(source.RequestBody)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestBodyCondition_STATUS() to populate field RequestBody")
		}
		condition.RequestBody = &requestBody
	} else {
		condition.RequestBody = nil
	}

	// RequestHeader
	if source.RequestHeader != nil {
		var requestHeader DeliveryRuleRequestHeaderCondition_STATUS
		err := requestHeader.AssignProperties_From_DeliveryRuleRequestHeaderCondition_STATUS(source.RequestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestHeaderCondition_STATUS() to populate field RequestHeader")
		}
		condition.RequestHeader = &requestHeader
	} else {
		condition.RequestHeader = nil
	}

	// RequestMethod
	if source.RequestMethod != nil {
		var requestMethod DeliveryRuleRequestMethodCondition_STATUS
		err := requestMethod.AssignProperties_From_DeliveryRuleRequestMethodCondition_STATUS(source.RequestMethod)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestMethodCondition_STATUS() to populate field RequestMethod")
		}
		condition.RequestMethod = &requestMethod
	} else {
		condition.RequestMethod = nil
	}

	// RequestScheme
	if source.RequestScheme != nil {
		var requestScheme DeliveryRuleRequestSchemeCondition_STATUS
		err := requestScheme.AssignProperties_From_DeliveryRuleRequestSchemeCondition_STATUS(source.RequestScheme)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestSchemeCondition_STATUS() to populate field RequestScheme")
		}
		condition.RequestScheme = &requestScheme
	} else {
		condition.RequestScheme = nil
	}

	// RequestUri
	if source.RequestUri != nil {
		var requestUri DeliveryRuleRequestUriCondition_STATUS
		err := requestUri.AssignProperties_From_DeliveryRuleRequestUriCondition_STATUS(source.RequestUri)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestUriCondition_STATUS() to populate field RequestUri")
		}
		condition.RequestUri = &requestUri
	} else {
		condition.RequestUri = nil
	}

	// ServerPort
	if source.ServerPort != nil {
		var serverPort DeliveryRuleServerPortCondition_STATUS
		err := serverPort.AssignProperties_From_DeliveryRuleServerPortCondition_STATUS(source.ServerPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleServerPortCondition_STATUS() to populate field ServerPort")
		}
		condition.ServerPort = &serverPort
	} else {
		condition.ServerPort = nil
	}

	// SocketAddr
	if source.SocketAddr != nil {
		var socketAddr DeliveryRuleSocketAddrCondition_STATUS
		err := socketAddr.AssignProperties_From_DeliveryRuleSocketAddrCondition_STATUS(source.SocketAddr)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleSocketAddrCondition_STATUS() to populate field SocketAddr")
		}
		condition.SocketAddr = &socketAddr
	} else {
		condition.SocketAddr = nil
	}

	// SslProtocol
	if source.SslProtocol != nil {
		var sslProtocol DeliveryRuleSslProtocolCondition_STATUS
		err := sslProtocol.AssignProperties_From_DeliveryRuleSslProtocolCondition_STATUS(source.SslProtocol)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleSslProtocolCondition_STATUS() to populate field SslProtocol")
		}
		condition.SslProtocol = &sslProtocol
	} else {
		condition.SslProtocol = nil
	}

	// UrlFileExtension
	if source.UrlFileExtension != nil {
		var urlFileExtension DeliveryRuleUrlFileExtensionCondition_STATUS
		err := urlFileExtension.AssignProperties_From_DeliveryRuleUrlFileExtensionCondition_STATUS(source.UrlFileExtension)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleUrlFileExtensionCondition_STATUS() to populate field UrlFileExtension")
		}
		condition.UrlFileExtension = &urlFileExtension
	} else {
		condition.UrlFileExtension = nil
	}

	// UrlFileName
	if source.UrlFileName != nil {
		var urlFileName DeliveryRuleUrlFileNameCondition_STATUS
		err := urlFileName.AssignProperties_From_DeliveryRuleUrlFileNameCondition_STATUS(source.UrlFileName)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleUrlFileNameCondition_STATUS() to populate field UrlFileName")
		}
		condition.UrlFileName = &urlFileName
	} else {
		condition.UrlFileName = nil
	}

	// UrlPath
	if source.UrlPath != nil {
		var urlPath DeliveryRuleUrlPathCondition_STATUS
		err := urlPath.AssignProperties_From_DeliveryRuleUrlPathCondition_STATUS(source.UrlPath)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleUrlPathCondition_STATUS() to populate field UrlPath")
		}
		condition.UrlPath = &urlPath
	} else {
		condition.UrlPath = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleCondition_STATUS populates the provided destination DeliveryRuleCondition_STATUS from our DeliveryRuleCondition_STATUS
func (condition *DeliveryRuleCondition_STATUS) AssignProperties_To_DeliveryRuleCondition_STATUS(destination *storage.DeliveryRuleCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientPort
	if condition.ClientPort != nil {
		var clientPort storage.DeliveryRuleClientPortCondition_STATUS
		err := condition.ClientPort.AssignProperties_To_DeliveryRuleClientPortCondition_STATUS(&clientPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleClientPortCondition_STATUS() to populate field ClientPort")
		}
		destination.ClientPort = &clientPort
	} else {
		destination.ClientPort = nil
	}

	// Cookies
	if condition.Cookies != nil {
		var cookie storage.DeliveryRuleCookiesCondition_STATUS
		err := condition.Cookies.AssignProperties_To_DeliveryRuleCookiesCondition_STATUS(&cookie)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleCookiesCondition_STATUS() to populate field Cookies")
		}
		destination.Cookies = &cookie
	} else {
		destination.Cookies = nil
	}

	// HostName
	if condition.HostName != nil {
		var hostName storage.DeliveryRuleHostNameCondition_STATUS
		err := condition.HostName.AssignProperties_To_DeliveryRuleHostNameCondition_STATUS(&hostName)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleHostNameCondition_STATUS() to populate field HostName")
		}
		destination.HostName = &hostName
	} else {
		destination.HostName = nil
	}

	// HttpVersion
	if condition.HttpVersion != nil {
		var httpVersion storage.DeliveryRuleHttpVersionCondition_STATUS
		err := condition.HttpVersion.AssignProperties_To_DeliveryRuleHttpVersionCondition_STATUS(&httpVersion)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleHttpVersionCondition_STATUS() to populate field HttpVersion")
		}
		destination.HttpVersion = &httpVersion
	} else {
		destination.HttpVersion = nil
	}

	// IsDevice
	if condition.IsDevice != nil {
		var isDevice storage.DeliveryRuleIsDeviceCondition_STATUS
		err := condition.IsDevice.AssignProperties_To_DeliveryRuleIsDeviceCondition_STATUS(&isDevice)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleIsDeviceCondition_STATUS() to populate field IsDevice")
		}
		destination.IsDevice = &isDevice
	} else {
		destination.IsDevice = nil
	}

	// PostArgs
	if condition.PostArgs != nil {
		var postArg storage.DeliveryRulePostArgsCondition_STATUS
		err := condition.PostArgs.AssignProperties_To_DeliveryRulePostArgsCondition_STATUS(&postArg)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRulePostArgsCondition_STATUS() to populate field PostArgs")
		}
		destination.PostArgs = &postArg
	} else {
		destination.PostArgs = nil
	}

	// QueryString
	if condition.QueryString != nil {
		var queryString storage.DeliveryRuleQueryStringCondition_STATUS
		err := condition.QueryString.AssignProperties_To_DeliveryRuleQueryStringCondition_STATUS(&queryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleQueryStringCondition_STATUS() to populate field QueryString")
		}
		destination.QueryString = &queryString
	} else {
		destination.QueryString = nil
	}

	// RemoteAddress
	if condition.RemoteAddress != nil {
		var remoteAddress storage.DeliveryRuleRemoteAddressCondition_STATUS
		err := condition.RemoteAddress.AssignProperties_To_DeliveryRuleRemoteAddressCondition_STATUS(&remoteAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRemoteAddressCondition_STATUS() to populate field RemoteAddress")
		}
		destination.RemoteAddress = &remoteAddress
	} else {
		destination.RemoteAddress = nil
	}

	// RequestBody
	if condition.RequestBody != nil {
		var requestBody storage.DeliveryRuleRequestBodyCondition_STATUS
		err := condition.RequestBody.AssignProperties_To_DeliveryRuleRequestBodyCondition_STATUS(&requestBody)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestBodyCondition_STATUS() to populate field RequestBody")
		}
		destination.RequestBody = &requestBody
	} else {
		destination.RequestBody = nil
	}

	// RequestHeader
	if condition.RequestHeader != nil {
		var requestHeader storage.DeliveryRuleRequestHeaderCondition_STATUS
		err := condition.RequestHeader.AssignProperties_To_DeliveryRuleRequestHeaderCondition_STATUS(&requestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestHeaderCondition_STATUS() to populate field RequestHeader")
		}
		destination.RequestHeader = &requestHeader
	} else {
		destination.RequestHeader = nil
	}

	// RequestMethod
	if condition.RequestMethod != nil {
		var requestMethod storage.DeliveryRuleRequestMethodCondition_STATUS
		err := condition.RequestMethod.AssignProperties_To_DeliveryRuleRequestMethodCondition_STATUS(&requestMethod)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestMethodCondition_STATUS() to populate field RequestMethod")
		}
		destination.RequestMethod = &requestMethod
	} else {
		destination.RequestMethod = nil
	}

	// RequestScheme
	if condition.RequestScheme != nil {
		var requestScheme storage.DeliveryRuleRequestSchemeCondition_STATUS
		err := condition.RequestScheme.AssignProperties_To_DeliveryRuleRequestSchemeCondition_STATUS(&requestScheme)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestSchemeCondition_STATUS() to populate field RequestScheme")
		}
		destination.RequestScheme = &requestScheme
	} else {
		destination.RequestScheme = nil
	}

	// RequestUri
	if condition.RequestUri != nil {
		var requestUri storage.DeliveryRuleRequestUriCondition_STATUS
		err := condition.RequestUri.AssignProperties_To_DeliveryRuleRequestUriCondition_STATUS(&requestUri)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestUriCondition_STATUS() to populate field RequestUri")
		}
		destination.RequestUri = &requestUri
	} else {
		destination.RequestUri = nil
	}

	// ServerPort
	if condition.ServerPort != nil {
		var serverPort storage.DeliveryRuleServerPortCondition_STATUS
		err := condition.ServerPort.AssignProperties_To_DeliveryRuleServerPortCondition_STATUS(&serverPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleServerPortCondition_STATUS() to populate field ServerPort")
		}
		destination.ServerPort = &serverPort
	} else {
		destination.ServerPort = nil
	}

	// SocketAddr
	if condition.SocketAddr != nil {
		var socketAddr storage.DeliveryRuleSocketAddrCondition_STATUS
		err := condition.SocketAddr.AssignProperties_To_DeliveryRuleSocketAddrCondition_STATUS(&socketAddr)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleSocketAddrCondition_STATUS() to populate field SocketAddr")
		}
		destination.SocketAddr = &socketAddr
	} else {
		destination.SocketAddr = nil
	}

	// SslProtocol
	if condition.SslProtocol != nil {
		var sslProtocol storage.DeliveryRuleSslProtocolCondition_STATUS
		err := condition.SslProtocol.AssignProperties_To_DeliveryRuleSslProtocolCondition_STATUS(&sslProtocol)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleSslProtocolCondition_STATUS() to populate field SslProtocol")
		}
		destination.SslProtocol = &sslProtocol
	} else {
		destination.SslProtocol = nil
	}

	// UrlFileExtension
	if condition.UrlFileExtension != nil {
		var urlFileExtension storage.DeliveryRuleUrlFileExtensionCondition_STATUS
		err := condition.UrlFileExtension.AssignProperties_To_DeliveryRuleUrlFileExtensionCondition_STATUS(&urlFileExtension)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleUrlFileExtensionCondition_STATUS() to populate field UrlFileExtension")
		}
		destination.UrlFileExtension = &urlFileExtension
	} else {
		destination.UrlFileExtension = nil
	}

	// UrlFileName
	if condition.UrlFileName != nil {
		var urlFileName storage.DeliveryRuleUrlFileNameCondition_STATUS
		err := condition.UrlFileName.AssignProperties_To_DeliveryRuleUrlFileNameCondition_STATUS(&urlFileName)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleUrlFileNameCondition_STATUS() to populate field UrlFileName")
		}
		destination.UrlFileName = &urlFileName
	} else {
		destination.UrlFileName = nil
	}

	// UrlPath
	if condition.UrlPath != nil {
		var urlPath storage.DeliveryRuleUrlPathCondition_STATUS
		err := condition.UrlPath.AssignProperties_To_DeliveryRuleUrlPathCondition_STATUS(&urlPath)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleUrlPathCondition_STATUS() to populate field UrlPath")
		}
		destination.UrlPath = &urlPath
	} else {
		destination.UrlPath = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Http","Https","NotSet"}
type HealthProbeParameters_ProbeProtocol string

const (
	HealthProbeParameters_ProbeProtocol_Http   = HealthProbeParameters_ProbeProtocol("Http")
	HealthProbeParameters_ProbeProtocol_Https  = HealthProbeParameters_ProbeProtocol("Https")
	HealthProbeParameters_ProbeProtocol_NotSet = HealthProbeParameters_ProbeProtocol("NotSet")
)

// Mapping from string to HealthProbeParameters_ProbeProtocol
var healthProbeParameters_ProbeProtocol_Values = map[string]HealthProbeParameters_ProbeProtocol{
	"http":   HealthProbeParameters_ProbeProtocol_Http,
	"https":  HealthProbeParameters_ProbeProtocol_Https,
	"notset": HealthProbeParameters_ProbeProtocol_NotSet,
}

type HealthProbeParameters_ProbeProtocol_STATUS string

const (
	HealthProbeParameters_ProbeProtocol_STATUS_Http   = HealthProbeParameters_ProbeProtocol_STATUS("Http")
	HealthProbeParameters_ProbeProtocol_STATUS_Https  = HealthProbeParameters_ProbeProtocol_STATUS("Https")
	HealthProbeParameters_ProbeProtocol_STATUS_NotSet = HealthProbeParameters_ProbeProtocol_STATUS("NotSet")
)

// Mapping from string to HealthProbeParameters_ProbeProtocol_STATUS
var healthProbeParameters_ProbeProtocol_STATUS_Values = map[string]HealthProbeParameters_ProbeProtocol_STATUS{
	"http":   HealthProbeParameters_ProbeProtocol_STATUS_Http,
	"https":  HealthProbeParameters_ProbeProtocol_STATUS_Https,
	"notset": HealthProbeParameters_ProbeProtocol_STATUS_NotSet,
}

// +kubebuilder:validation:Enum={"GET","HEAD","NotSet"}
type HealthProbeParameters_ProbeRequestType string

const (
	HealthProbeParameters_ProbeRequestType_GET    = HealthProbeParameters_ProbeRequestType("GET")
	HealthProbeParameters_ProbeRequestType_HEAD   = HealthProbeParameters_ProbeRequestType("HEAD")
	HealthProbeParameters_ProbeRequestType_NotSet = HealthProbeParameters_ProbeRequestType("NotSet")
)

// Mapping from string to HealthProbeParameters_ProbeRequestType
var healthProbeParameters_ProbeRequestType_Values = map[string]HealthProbeParameters_ProbeRequestType{
	"get":    HealthProbeParameters_ProbeRequestType_GET,
	"head":   HealthProbeParameters_ProbeRequestType_HEAD,
	"notset": HealthProbeParameters_ProbeRequestType_NotSet,
}

type HealthProbeParameters_ProbeRequestType_STATUS string

const (
	HealthProbeParameters_ProbeRequestType_STATUS_GET    = HealthProbeParameters_ProbeRequestType_STATUS("GET")
	HealthProbeParameters_ProbeRequestType_STATUS_HEAD   = HealthProbeParameters_ProbeRequestType_STATUS("HEAD")
	HealthProbeParameters_ProbeRequestType_STATUS_NotSet = HealthProbeParameters_ProbeRequestType_STATUS("NotSet")
)

// Mapping from string to HealthProbeParameters_ProbeRequestType_STATUS
var healthProbeParameters_ProbeRequestType_STATUS_Values = map[string]HealthProbeParameters_ProbeRequestType_STATUS{
	"get":    HealthProbeParameters_ProbeRequestType_STATUS_GET,
	"head":   HealthProbeParameters_ProbeRequestType_STATUS_HEAD,
	"notset": HealthProbeParameters_ProbeRequestType_STATUS_NotSet,
}

// The JSON object that represents the range for http status codes
type HttpErrorRangeParameters struct {
	// +kubebuilder:validation:Maximum=999
	// +kubebuilder:validation:Minimum=100
	// Begin: The inclusive start of the http status code range.
	Begin *int `json:"begin,omitempty"`

	// +kubebuilder:validation:Maximum=999
	// +kubebuilder:validation:Minimum=100
	// End: The inclusive end of the http status code range.
	End *int `json:"end,omitempty"`
}

var _ genruntime.ARMTransformer = &HttpErrorRangeParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *HttpErrorRangeParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.HttpErrorRangeParameters{}

	// Set property "Begin":
	if parameters.Begin != nil {
		begin := *parameters.Begin
		result.Begin = &begin
	}

	// Set property "End":
	if parameters.End != nil {
		end := *parameters.End
		result.End = &end
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *HttpErrorRangeParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HttpErrorRangeParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *HttpErrorRangeParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HttpErrorRangeParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HttpErrorRangeParameters, got %T", armInput)
	}

	// Set property "Begin":
	if typedInput.Begin != nil {
		begin := *typedInput.Begin
		parameters.Begin = &begin
	}

	// Set property "End":
	if typedInput.End != nil {
		end := *typedInput.End
		parameters.End = &end
	}

	// No error
	return nil
}

// AssignProperties_From_HttpErrorRangeParameters populates our HttpErrorRangeParameters from the provided source HttpErrorRangeParameters
func (parameters *HttpErrorRangeParameters) AssignProperties_From_HttpErrorRangeParameters(source *storage.HttpErrorRangeParameters) error {

	// Begin
	if source.Begin != nil {
		begin := *source.Begin
		parameters.Begin = &begin
	} else {
		parameters.Begin = nil
	}

	// End
	if source.End != nil {
		end := *source.End
		parameters.End = &end
	} else {
		parameters.End = nil
	}

	// No error
	return nil
}

// AssignProperties_To_HttpErrorRangeParameters populates the provided destination HttpErrorRangeParameters from our HttpErrorRangeParameters
func (parameters *HttpErrorRangeParameters) AssignProperties_To_HttpErrorRangeParameters(destination *storage.HttpErrorRangeParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Begin
	if parameters.Begin != nil {
		begin := *parameters.Begin
		destination.Begin = &begin
	} else {
		destination.Begin = nil
	}

	// End
	if parameters.End != nil {
		end := *parameters.End
		destination.End = &end
	} else {
		destination.End = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_HttpErrorRangeParameters_STATUS populates our HttpErrorRangeParameters from the provided source HttpErrorRangeParameters_STATUS
func (parameters *HttpErrorRangeParameters) Initialize_From_HttpErrorRangeParameters_STATUS(source *HttpErrorRangeParameters_STATUS) error {

	// Begin
	if source.Begin != nil {
		begin := *source.Begin
		parameters.Begin = &begin
	} else {
		parameters.Begin = nil
	}

	// End
	if source.End != nil {
		end := *source.End
		parameters.End = &end
	} else {
		parameters.End = nil
	}

	// No error
	return nil
}

// The JSON object that represents the range for http status codes
type HttpErrorRangeParameters_STATUS struct {
	// Begin: The inclusive start of the http status code range.
	Begin *int `json:"begin,omitempty"`

	// End: The inclusive end of the http status code range.
	End *int `json:"end,omitempty"`
}

var _ genruntime.FromARMConverter = &HttpErrorRangeParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *HttpErrorRangeParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HttpErrorRangeParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *HttpErrorRangeParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HttpErrorRangeParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HttpErrorRangeParameters_STATUS, got %T", armInput)
	}

	// Set property "Begin":
	if typedInput.Begin != nil {
		begin := *typedInput.Begin
		parameters.Begin = &begin
	}

	// Set property "End":
	if typedInput.End != nil {
		end := *typedInput.End
		parameters.End = &end
	}

	// No error
	return nil
}

// AssignProperties_From_HttpErrorRangeParameters_STATUS populates our HttpErrorRangeParameters_STATUS from the provided source HttpErrorRangeParameters_STATUS
func (parameters *HttpErrorRangeParameters_STATUS) AssignProperties_From_HttpErrorRangeParameters_STATUS(source *storage.HttpErrorRangeParameters_STATUS) error {

	// Begin
	parameters.Begin = genruntime.ClonePointerToInt(source.Begin)

	// End
	parameters.End = genruntime.ClonePointerToInt(source.End)

	// No error
	return nil
}

// AssignProperties_To_HttpErrorRangeParameters_STATUS populates the provided destination HttpErrorRangeParameters_STATUS from our HttpErrorRangeParameters_STATUS
func (parameters *HttpErrorRangeParameters_STATUS) AssignProperties_To_HttpErrorRangeParameters_STATUS(destination *storage.HttpErrorRangeParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Begin
	destination.Begin = genruntime.ClonePointerToInt(parameters.Begin)

	// End
	destination.End = genruntime.ClonePointerToInt(parameters.End)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"KeyVaultSigningKeyParameters"}
type KeyVaultSigningKeyParameters_TypeName string

const KeyVaultSigningKeyParameters_TypeName_KeyVaultSigningKeyParameters = KeyVaultSigningKeyParameters_TypeName("KeyVaultSigningKeyParameters")

// Mapping from string to KeyVaultSigningKeyParameters_TypeName
var keyVaultSigningKeyParameters_TypeName_Values = map[string]KeyVaultSigningKeyParameters_TypeName{
	"keyvaultsigningkeyparameters": KeyVaultSigningKeyParameters_TypeName_KeyVaultSigningKeyParameters,
}

type KeyVaultSigningKeyParameters_TypeName_STATUS string

const KeyVaultSigningKeyParameters_TypeName_STATUS_KeyVaultSigningKeyParameters = KeyVaultSigningKeyParameters_TypeName_STATUS("KeyVaultSigningKeyParameters")

// Mapping from string to KeyVaultSigningKeyParameters_TypeName_STATUS
var keyVaultSigningKeyParameters_TypeName_STATUS_Values = map[string]KeyVaultSigningKeyParameters_TypeName_STATUS{
	"keyvaultsigningkeyparameters": KeyVaultSigningKeyParameters_TypeName_STATUS_KeyVaultSigningKeyParameters,
}

// +kubebuilder:validation:Enum={"None","TcpAndHttpErrors","TcpErrorsOnly"}
type ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes string

const (
	ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_None             = ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes("None")
	ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_TcpAndHttpErrors = ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes("TcpAndHttpErrors")
	ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_TcpErrorsOnly    = ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes("TcpErrorsOnly")
)

// Mapping from string to ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes
var responseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_Values = map[string]ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes{
	"none":             ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_None,
	"tcpandhttperrors": ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_TcpAndHttpErrors,
	"tcperrorsonly":    ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_TcpErrorsOnly,
}

type ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_STATUS string

const (
	ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_STATUS_None             = ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_STATUS("None")
	ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_STATUS_TcpAndHttpErrors = ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_STATUS("TcpAndHttpErrors")
	ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_STATUS_TcpErrorsOnly    = ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_STATUS("TcpErrorsOnly")
)

// Mapping from string to ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_STATUS
var responseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_STATUS_Values = map[string]ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_STATUS{
	"none":             ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_STATUS_None,
	"tcpandhttperrors": ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_STATUS_TcpAndHttpErrors,
	"tcperrorsonly":    ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_STATUS_TcpErrorsOnly,
}

type DeliveryRuleCacheExpirationAction struct {
	// +kubebuilder:validation:Required
	// Name: The name of the action for the delivery rule.
	Name *DeliveryRuleCacheExpirationAction_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the action.
	Parameters *CacheExpirationActionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleCacheExpirationAction{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (action *DeliveryRuleCacheExpirationAction) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if action == nil {
		return nil, nil
	}
	result := &arm.DeliveryRuleCacheExpirationAction{}

	// Set property "Name":
	if action.Name != nil {
		var temp arm.DeliveryRuleCacheExpirationAction_Name
		var temp1 string
		temp1 = string(*action.Name)
		temp = arm.DeliveryRuleCacheExpirationAction_Name(temp1)
		result.Name = temp
	}

	// Set property "Parameters":
	if action.Parameters != nil {
		parameters_ARM, err := (*action.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*arm.CacheExpirationActionParameters)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *DeliveryRuleCacheExpirationAction) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleCacheExpirationAction{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *DeliveryRuleCacheExpirationAction) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleCacheExpirationAction)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleCacheExpirationAction, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleCacheExpirationAction_Name
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleCacheExpirationAction_Name(temp1)
	action.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 CacheExpirationActionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleCacheExpirationAction populates our DeliveryRuleCacheExpirationAction from the provided source DeliveryRuleCacheExpirationAction
func (action *DeliveryRuleCacheExpirationAction) AssignProperties_From_DeliveryRuleCacheExpirationAction(source *storage.DeliveryRuleCacheExpirationAction) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleCacheExpirationAction_Name_Values)
		action.Name = &nameTemp
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter CacheExpirationActionParameters
		err := parameter.AssignProperties_From_CacheExpirationActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CacheExpirationActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleCacheExpirationAction populates the provided destination DeliveryRuleCacheExpirationAction from our DeliveryRuleCacheExpirationAction
func (action *DeliveryRuleCacheExpirationAction) AssignProperties_To_DeliveryRuleCacheExpirationAction(destination *storage.DeliveryRuleCacheExpirationAction) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter storage.CacheExpirationActionParameters
		err := action.Parameters.AssignProperties_To_CacheExpirationActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CacheExpirationActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleCacheExpirationAction_STATUS populates our DeliveryRuleCacheExpirationAction from the provided source DeliveryRuleCacheExpirationAction_STATUS
func (action *DeliveryRuleCacheExpirationAction) Initialize_From_DeliveryRuleCacheExpirationAction_STATUS(source *DeliveryRuleCacheExpirationAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), deliveryRuleCacheExpirationAction_Name_Values)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter CacheExpirationActionParameters
		err := parameter.Initialize_From_CacheExpirationActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_CacheExpirationActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleCacheExpirationAction_STATUS struct {
	// Name: The name of the action for the delivery rule.
	Name *DeliveryRuleCacheExpirationAction_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the action.
	Parameters *CacheExpirationActionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleCacheExpirationAction_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *DeliveryRuleCacheExpirationAction_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleCacheExpirationAction_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *DeliveryRuleCacheExpirationAction_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleCacheExpirationAction_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleCacheExpirationAction_STATUS, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleCacheExpirationAction_Name_STATUS
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleCacheExpirationAction_Name_STATUS(temp1)
	action.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 CacheExpirationActionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleCacheExpirationAction_STATUS populates our DeliveryRuleCacheExpirationAction_STATUS from the provided source DeliveryRuleCacheExpirationAction_STATUS
func (action *DeliveryRuleCacheExpirationAction_STATUS) AssignProperties_From_DeliveryRuleCacheExpirationAction_STATUS(source *storage.DeliveryRuleCacheExpirationAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleCacheExpirationAction_Name_STATUS_Values)
		action.Name = &nameTemp
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter CacheExpirationActionParameters_STATUS
		err := parameter.AssignProperties_From_CacheExpirationActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CacheExpirationActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleCacheExpirationAction_STATUS populates the provided destination DeliveryRuleCacheExpirationAction_STATUS from our DeliveryRuleCacheExpirationAction_STATUS
func (action *DeliveryRuleCacheExpirationAction_STATUS) AssignProperties_To_DeliveryRuleCacheExpirationAction_STATUS(destination *storage.DeliveryRuleCacheExpirationAction_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter storage.CacheExpirationActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_CacheExpirationActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CacheExpirationActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleCacheKeyQueryStringAction struct {
	// +kubebuilder:validation:Required
	// Name: The name of the action for the delivery rule.
	Name *DeliveryRuleCacheKeyQueryStringAction_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the action.
	Parameters *CacheKeyQueryStringActionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleCacheKeyQueryStringAction{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (action *DeliveryRuleCacheKeyQueryStringAction) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if action == nil {
		return nil, nil
	}
	result := &arm.DeliveryRuleCacheKeyQueryStringAction{}

	// Set property "Name":
	if action.Name != nil {
		var temp arm.DeliveryRuleCacheKeyQueryStringAction_Name
		var temp1 string
		temp1 = string(*action.Name)
		temp = arm.DeliveryRuleCacheKeyQueryStringAction_Name(temp1)
		result.Name = temp
	}

	// Set property "Parameters":
	if action.Parameters != nil {
		parameters_ARM, err := (*action.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*arm.CacheKeyQueryStringActionParameters)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *DeliveryRuleCacheKeyQueryStringAction) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleCacheKeyQueryStringAction{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *DeliveryRuleCacheKeyQueryStringAction) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleCacheKeyQueryStringAction)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleCacheKeyQueryStringAction, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleCacheKeyQueryStringAction_Name
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleCacheKeyQueryStringAction_Name(temp1)
	action.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 CacheKeyQueryStringActionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction populates our DeliveryRuleCacheKeyQueryStringAction from the provided source DeliveryRuleCacheKeyQueryStringAction
func (action *DeliveryRuleCacheKeyQueryStringAction) AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction(source *storage.DeliveryRuleCacheKeyQueryStringAction) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleCacheKeyQueryStringAction_Name_Values)
		action.Name = &nameTemp
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter CacheKeyQueryStringActionParameters
		err := parameter.AssignProperties_From_CacheKeyQueryStringActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CacheKeyQueryStringActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction populates the provided destination DeliveryRuleCacheKeyQueryStringAction from our DeliveryRuleCacheKeyQueryStringAction
func (action *DeliveryRuleCacheKeyQueryStringAction) AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction(destination *storage.DeliveryRuleCacheKeyQueryStringAction) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter storage.CacheKeyQueryStringActionParameters
		err := action.Parameters.AssignProperties_To_CacheKeyQueryStringActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CacheKeyQueryStringActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleCacheKeyQueryStringAction_STATUS populates our DeliveryRuleCacheKeyQueryStringAction from the provided source DeliveryRuleCacheKeyQueryStringAction_STATUS
func (action *DeliveryRuleCacheKeyQueryStringAction) Initialize_From_DeliveryRuleCacheKeyQueryStringAction_STATUS(source *DeliveryRuleCacheKeyQueryStringAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), deliveryRuleCacheKeyQueryStringAction_Name_Values)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter CacheKeyQueryStringActionParameters
		err := parameter.Initialize_From_CacheKeyQueryStringActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_CacheKeyQueryStringActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleCacheKeyQueryStringAction_STATUS struct {
	// Name: The name of the action for the delivery rule.
	Name *DeliveryRuleCacheKeyQueryStringAction_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the action.
	Parameters *CacheKeyQueryStringActionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleCacheKeyQueryStringAction_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *DeliveryRuleCacheKeyQueryStringAction_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleCacheKeyQueryStringAction_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *DeliveryRuleCacheKeyQueryStringAction_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleCacheKeyQueryStringAction_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleCacheKeyQueryStringAction_STATUS, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleCacheKeyQueryStringAction_Name_STATUS
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleCacheKeyQueryStringAction_Name_STATUS(temp1)
	action.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 CacheKeyQueryStringActionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction_STATUS populates our DeliveryRuleCacheKeyQueryStringAction_STATUS from the provided source DeliveryRuleCacheKeyQueryStringAction_STATUS
func (action *DeliveryRuleCacheKeyQueryStringAction_STATUS) AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction_STATUS(source *storage.DeliveryRuleCacheKeyQueryStringAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleCacheKeyQueryStringAction_Name_STATUS_Values)
		action.Name = &nameTemp
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter CacheKeyQueryStringActionParameters_STATUS
		err := parameter.AssignProperties_From_CacheKeyQueryStringActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CacheKeyQueryStringActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction_STATUS populates the provided destination DeliveryRuleCacheKeyQueryStringAction_STATUS from our DeliveryRuleCacheKeyQueryStringAction_STATUS
func (action *DeliveryRuleCacheKeyQueryStringAction_STATUS) AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction_STATUS(destination *storage.DeliveryRuleCacheKeyQueryStringAction_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter storage.CacheKeyQueryStringActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_CacheKeyQueryStringActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CacheKeyQueryStringActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleClientPortCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleClientPortCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *ClientPortMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleClientPortCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleClientPortCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &arm.DeliveryRuleClientPortCondition{}

	// Set property "Name":
	if condition.Name != nil {
		var temp arm.DeliveryRuleClientPortCondition_Name
		var temp1 string
		temp1 = string(*condition.Name)
		temp = arm.DeliveryRuleClientPortCondition_Name(temp1)
		result.Name = temp
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*arm.ClientPortMatchConditionParameters)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleClientPortCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleClientPortCondition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleClientPortCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleClientPortCondition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleClientPortCondition, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleClientPortCondition_Name
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleClientPortCondition_Name(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 ClientPortMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleClientPortCondition populates our DeliveryRuleClientPortCondition from the provided source DeliveryRuleClientPortCondition
func (condition *DeliveryRuleClientPortCondition) AssignProperties_From_DeliveryRuleClientPortCondition(source *storage.DeliveryRuleClientPortCondition) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleClientPortCondition_Name_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter ClientPortMatchConditionParameters
		err := parameter.AssignProperties_From_ClientPortMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ClientPortMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleClientPortCondition populates the provided destination DeliveryRuleClientPortCondition from our DeliveryRuleClientPortCondition
func (condition *DeliveryRuleClientPortCondition) AssignProperties_To_DeliveryRuleClientPortCondition(destination *storage.DeliveryRuleClientPortCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.ClientPortMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_ClientPortMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ClientPortMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleClientPortCondition_STATUS populates our DeliveryRuleClientPortCondition from the provided source DeliveryRuleClientPortCondition_STATUS
func (condition *DeliveryRuleClientPortCondition) Initialize_From_DeliveryRuleClientPortCondition_STATUS(source *DeliveryRuleClientPortCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), deliveryRuleClientPortCondition_Name_Values)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter ClientPortMatchConditionParameters
		err := parameter.Initialize_From_ClientPortMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ClientPortMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleClientPortCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleClientPortCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *ClientPortMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleClientPortCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleClientPortCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleClientPortCondition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleClientPortCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleClientPortCondition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleClientPortCondition_STATUS, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleClientPortCondition_Name_STATUS
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleClientPortCondition_Name_STATUS(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 ClientPortMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleClientPortCondition_STATUS populates our DeliveryRuleClientPortCondition_STATUS from the provided source DeliveryRuleClientPortCondition_STATUS
func (condition *DeliveryRuleClientPortCondition_STATUS) AssignProperties_From_DeliveryRuleClientPortCondition_STATUS(source *storage.DeliveryRuleClientPortCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleClientPortCondition_Name_STATUS_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter ClientPortMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_ClientPortMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ClientPortMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleClientPortCondition_STATUS populates the provided destination DeliveryRuleClientPortCondition_STATUS from our DeliveryRuleClientPortCondition_STATUS
func (condition *DeliveryRuleClientPortCondition_STATUS) AssignProperties_To_DeliveryRuleClientPortCondition_STATUS(destination *storage.DeliveryRuleClientPortCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.ClientPortMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_ClientPortMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ClientPortMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleCookiesCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleCookiesCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *CookiesMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleCookiesCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleCookiesCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &arm.DeliveryRuleCookiesCondition{}

	// Set property "Name":
	if condition.Name != nil {
		var temp arm.DeliveryRuleCookiesCondition_Name
		var temp1 string
		temp1 = string(*condition.Name)
		temp = arm.DeliveryRuleCookiesCondition_Name(temp1)
		result.Name = temp
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*arm.CookiesMatchConditionParameters)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleCookiesCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleCookiesCondition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleCookiesCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleCookiesCondition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleCookiesCondition, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleCookiesCondition_Name
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleCookiesCondition_Name(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 CookiesMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleCookiesCondition populates our DeliveryRuleCookiesCondition from the provided source DeliveryRuleCookiesCondition
func (condition *DeliveryRuleCookiesCondition) AssignProperties_From_DeliveryRuleCookiesCondition(source *storage.DeliveryRuleCookiesCondition) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleCookiesCondition_Name_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter CookiesMatchConditionParameters
		err := parameter.AssignProperties_From_CookiesMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CookiesMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleCookiesCondition populates the provided destination DeliveryRuleCookiesCondition from our DeliveryRuleCookiesCondition
func (condition *DeliveryRuleCookiesCondition) AssignProperties_To_DeliveryRuleCookiesCondition(destination *storage.DeliveryRuleCookiesCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.CookiesMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_CookiesMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CookiesMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleCookiesCondition_STATUS populates our DeliveryRuleCookiesCondition from the provided source DeliveryRuleCookiesCondition_STATUS
func (condition *DeliveryRuleCookiesCondition) Initialize_From_DeliveryRuleCookiesCondition_STATUS(source *DeliveryRuleCookiesCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), deliveryRuleCookiesCondition_Name_Values)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter CookiesMatchConditionParameters
		err := parameter.Initialize_From_CookiesMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_CookiesMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleCookiesCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleCookiesCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *CookiesMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleCookiesCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleCookiesCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleCookiesCondition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleCookiesCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleCookiesCondition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleCookiesCondition_STATUS, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleCookiesCondition_Name_STATUS
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleCookiesCondition_Name_STATUS(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 CookiesMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleCookiesCondition_STATUS populates our DeliveryRuleCookiesCondition_STATUS from the provided source DeliveryRuleCookiesCondition_STATUS
func (condition *DeliveryRuleCookiesCondition_STATUS) AssignProperties_From_DeliveryRuleCookiesCondition_STATUS(source *storage.DeliveryRuleCookiesCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleCookiesCondition_Name_STATUS_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter CookiesMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_CookiesMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CookiesMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleCookiesCondition_STATUS populates the provided destination DeliveryRuleCookiesCondition_STATUS from our DeliveryRuleCookiesCondition_STATUS
func (condition *DeliveryRuleCookiesCondition_STATUS) AssignProperties_To_DeliveryRuleCookiesCondition_STATUS(destination *storage.DeliveryRuleCookiesCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.CookiesMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_CookiesMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CookiesMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleHostNameCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleHostNameCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *HostNameMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleHostNameCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleHostNameCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &arm.DeliveryRuleHostNameCondition{}

	// Set property "Name":
	if condition.Name != nil {
		var temp arm.DeliveryRuleHostNameCondition_Name
		var temp1 string
		temp1 = string(*condition.Name)
		temp = arm.DeliveryRuleHostNameCondition_Name(temp1)
		result.Name = temp
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*arm.HostNameMatchConditionParameters)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleHostNameCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleHostNameCondition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleHostNameCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleHostNameCondition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleHostNameCondition, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleHostNameCondition_Name
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleHostNameCondition_Name(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 HostNameMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleHostNameCondition populates our DeliveryRuleHostNameCondition from the provided source DeliveryRuleHostNameCondition
func (condition *DeliveryRuleHostNameCondition) AssignProperties_From_DeliveryRuleHostNameCondition(source *storage.DeliveryRuleHostNameCondition) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleHostNameCondition_Name_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter HostNameMatchConditionParameters
		err := parameter.AssignProperties_From_HostNameMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HostNameMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleHostNameCondition populates the provided destination DeliveryRuleHostNameCondition from our DeliveryRuleHostNameCondition
func (condition *DeliveryRuleHostNameCondition) AssignProperties_To_DeliveryRuleHostNameCondition(destination *storage.DeliveryRuleHostNameCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.HostNameMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_HostNameMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HostNameMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleHostNameCondition_STATUS populates our DeliveryRuleHostNameCondition from the provided source DeliveryRuleHostNameCondition_STATUS
func (condition *DeliveryRuleHostNameCondition) Initialize_From_DeliveryRuleHostNameCondition_STATUS(source *DeliveryRuleHostNameCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), deliveryRuleHostNameCondition_Name_Values)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter HostNameMatchConditionParameters
		err := parameter.Initialize_From_HostNameMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_HostNameMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleHostNameCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleHostNameCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *HostNameMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleHostNameCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleHostNameCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleHostNameCondition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleHostNameCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleHostNameCondition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleHostNameCondition_STATUS, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleHostNameCondition_Name_STATUS
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleHostNameCondition_Name_STATUS(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 HostNameMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleHostNameCondition_STATUS populates our DeliveryRuleHostNameCondition_STATUS from the provided source DeliveryRuleHostNameCondition_STATUS
func (condition *DeliveryRuleHostNameCondition_STATUS) AssignProperties_From_DeliveryRuleHostNameCondition_STATUS(source *storage.DeliveryRuleHostNameCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleHostNameCondition_Name_STATUS_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter HostNameMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_HostNameMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HostNameMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleHostNameCondition_STATUS populates the provided destination DeliveryRuleHostNameCondition_STATUS from our DeliveryRuleHostNameCondition_STATUS
func (condition *DeliveryRuleHostNameCondition_STATUS) AssignProperties_To_DeliveryRuleHostNameCondition_STATUS(destination *storage.DeliveryRuleHostNameCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.HostNameMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_HostNameMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HostNameMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleHttpVersionCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleHttpVersionCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *HttpVersionMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleHttpVersionCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleHttpVersionCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &arm.DeliveryRuleHttpVersionCondition{}

	// Set property "Name":
	if condition.Name != nil {
		var temp arm.DeliveryRuleHttpVersionCondition_Name
		var temp1 string
		temp1 = string(*condition.Name)
		temp = arm.DeliveryRuleHttpVersionCondition_Name(temp1)
		result.Name = temp
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*arm.HttpVersionMatchConditionParameters)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleHttpVersionCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleHttpVersionCondition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleHttpVersionCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleHttpVersionCondition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleHttpVersionCondition, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleHttpVersionCondition_Name
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleHttpVersionCondition_Name(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 HttpVersionMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleHttpVersionCondition populates our DeliveryRuleHttpVersionCondition from the provided source DeliveryRuleHttpVersionCondition
func (condition *DeliveryRuleHttpVersionCondition) AssignProperties_From_DeliveryRuleHttpVersionCondition(source *storage.DeliveryRuleHttpVersionCondition) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleHttpVersionCondition_Name_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter HttpVersionMatchConditionParameters
		err := parameter.AssignProperties_From_HttpVersionMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HttpVersionMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleHttpVersionCondition populates the provided destination DeliveryRuleHttpVersionCondition from our DeliveryRuleHttpVersionCondition
func (condition *DeliveryRuleHttpVersionCondition) AssignProperties_To_DeliveryRuleHttpVersionCondition(destination *storage.DeliveryRuleHttpVersionCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.HttpVersionMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_HttpVersionMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HttpVersionMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleHttpVersionCondition_STATUS populates our DeliveryRuleHttpVersionCondition from the provided source DeliveryRuleHttpVersionCondition_STATUS
func (condition *DeliveryRuleHttpVersionCondition) Initialize_From_DeliveryRuleHttpVersionCondition_STATUS(source *DeliveryRuleHttpVersionCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), deliveryRuleHttpVersionCondition_Name_Values)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter HttpVersionMatchConditionParameters
		err := parameter.Initialize_From_HttpVersionMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_HttpVersionMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleHttpVersionCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleHttpVersionCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *HttpVersionMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleHttpVersionCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleHttpVersionCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleHttpVersionCondition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleHttpVersionCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleHttpVersionCondition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleHttpVersionCondition_STATUS, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleHttpVersionCondition_Name_STATUS
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleHttpVersionCondition_Name_STATUS(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 HttpVersionMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleHttpVersionCondition_STATUS populates our DeliveryRuleHttpVersionCondition_STATUS from the provided source DeliveryRuleHttpVersionCondition_STATUS
func (condition *DeliveryRuleHttpVersionCondition_STATUS) AssignProperties_From_DeliveryRuleHttpVersionCondition_STATUS(source *storage.DeliveryRuleHttpVersionCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleHttpVersionCondition_Name_STATUS_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter HttpVersionMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_HttpVersionMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HttpVersionMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleHttpVersionCondition_STATUS populates the provided destination DeliveryRuleHttpVersionCondition_STATUS from our DeliveryRuleHttpVersionCondition_STATUS
func (condition *DeliveryRuleHttpVersionCondition_STATUS) AssignProperties_To_DeliveryRuleHttpVersionCondition_STATUS(destination *storage.DeliveryRuleHttpVersionCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.HttpVersionMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_HttpVersionMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HttpVersionMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleIsDeviceCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleIsDeviceCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *IsDeviceMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleIsDeviceCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleIsDeviceCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &arm.DeliveryRuleIsDeviceCondition{}

	// Set property "Name":
	if condition.Name != nil {
		var temp arm.DeliveryRuleIsDeviceCondition_Name
		var temp1 string
		temp1 = string(*condition.Name)
		temp = arm.DeliveryRuleIsDeviceCondition_Name(temp1)
		result.Name = temp
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*arm.IsDeviceMatchConditionParameters)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleIsDeviceCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleIsDeviceCondition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleIsDeviceCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleIsDeviceCondition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleIsDeviceCondition, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleIsDeviceCondition_Name
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleIsDeviceCondition_Name(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 IsDeviceMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleIsDeviceCondition populates our DeliveryRuleIsDeviceCondition from the provided source DeliveryRuleIsDeviceCondition
func (condition *DeliveryRuleIsDeviceCondition) AssignProperties_From_DeliveryRuleIsDeviceCondition(source *storage.DeliveryRuleIsDeviceCondition) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleIsDeviceCondition_Name_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter IsDeviceMatchConditionParameters
		err := parameter.AssignProperties_From_IsDeviceMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_IsDeviceMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleIsDeviceCondition populates the provided destination DeliveryRuleIsDeviceCondition from our DeliveryRuleIsDeviceCondition
func (condition *DeliveryRuleIsDeviceCondition) AssignProperties_To_DeliveryRuleIsDeviceCondition(destination *storage.DeliveryRuleIsDeviceCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.IsDeviceMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_IsDeviceMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_IsDeviceMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleIsDeviceCondition_STATUS populates our DeliveryRuleIsDeviceCondition from the provided source DeliveryRuleIsDeviceCondition_STATUS
func (condition *DeliveryRuleIsDeviceCondition) Initialize_From_DeliveryRuleIsDeviceCondition_STATUS(source *DeliveryRuleIsDeviceCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), deliveryRuleIsDeviceCondition_Name_Values)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter IsDeviceMatchConditionParameters
		err := parameter.Initialize_From_IsDeviceMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_IsDeviceMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleIsDeviceCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleIsDeviceCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *IsDeviceMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleIsDeviceCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleIsDeviceCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleIsDeviceCondition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleIsDeviceCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleIsDeviceCondition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleIsDeviceCondition_STATUS, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleIsDeviceCondition_Name_STATUS
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleIsDeviceCondition_Name_STATUS(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 IsDeviceMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleIsDeviceCondition_STATUS populates our DeliveryRuleIsDeviceCondition_STATUS from the provided source DeliveryRuleIsDeviceCondition_STATUS
func (condition *DeliveryRuleIsDeviceCondition_STATUS) AssignProperties_From_DeliveryRuleIsDeviceCondition_STATUS(source *storage.DeliveryRuleIsDeviceCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleIsDeviceCondition_Name_STATUS_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter IsDeviceMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_IsDeviceMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_IsDeviceMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleIsDeviceCondition_STATUS populates the provided destination DeliveryRuleIsDeviceCondition_STATUS from our DeliveryRuleIsDeviceCondition_STATUS
func (condition *DeliveryRuleIsDeviceCondition_STATUS) AssignProperties_To_DeliveryRuleIsDeviceCondition_STATUS(destination *storage.DeliveryRuleIsDeviceCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.IsDeviceMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_IsDeviceMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_IsDeviceMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRulePostArgsCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRulePostArgsCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *PostArgsMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRulePostArgsCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRulePostArgsCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &arm.DeliveryRulePostArgsCondition{}

	// Set property "Name":
	if condition.Name != nil {
		var temp arm.DeliveryRulePostArgsCondition_Name
		var temp1 string
		temp1 = string(*condition.Name)
		temp = arm.DeliveryRulePostArgsCondition_Name(temp1)
		result.Name = temp
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*arm.PostArgsMatchConditionParameters)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRulePostArgsCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRulePostArgsCondition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRulePostArgsCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRulePostArgsCondition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRulePostArgsCondition, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRulePostArgsCondition_Name
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRulePostArgsCondition_Name(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 PostArgsMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRulePostArgsCondition populates our DeliveryRulePostArgsCondition from the provided source DeliveryRulePostArgsCondition
func (condition *DeliveryRulePostArgsCondition) AssignProperties_From_DeliveryRulePostArgsCondition(source *storage.DeliveryRulePostArgsCondition) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRulePostArgsCondition_Name_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter PostArgsMatchConditionParameters
		err := parameter.AssignProperties_From_PostArgsMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PostArgsMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRulePostArgsCondition populates the provided destination DeliveryRulePostArgsCondition from our DeliveryRulePostArgsCondition
func (condition *DeliveryRulePostArgsCondition) AssignProperties_To_DeliveryRulePostArgsCondition(destination *storage.DeliveryRulePostArgsCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.PostArgsMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_PostArgsMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PostArgsMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRulePostArgsCondition_STATUS populates our DeliveryRulePostArgsCondition from the provided source DeliveryRulePostArgsCondition_STATUS
func (condition *DeliveryRulePostArgsCondition) Initialize_From_DeliveryRulePostArgsCondition_STATUS(source *DeliveryRulePostArgsCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), deliveryRulePostArgsCondition_Name_Values)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter PostArgsMatchConditionParameters
		err := parameter.Initialize_From_PostArgsMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_PostArgsMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRulePostArgsCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRulePostArgsCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *PostArgsMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRulePostArgsCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRulePostArgsCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRulePostArgsCondition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRulePostArgsCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRulePostArgsCondition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRulePostArgsCondition_STATUS, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRulePostArgsCondition_Name_STATUS
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRulePostArgsCondition_Name_STATUS(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 PostArgsMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRulePostArgsCondition_STATUS populates our DeliveryRulePostArgsCondition_STATUS from the provided source DeliveryRulePostArgsCondition_STATUS
func (condition *DeliveryRulePostArgsCondition_STATUS) AssignProperties_From_DeliveryRulePostArgsCondition_STATUS(source *storage.DeliveryRulePostArgsCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRulePostArgsCondition_Name_STATUS_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter PostArgsMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_PostArgsMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PostArgsMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRulePostArgsCondition_STATUS populates the provided destination DeliveryRulePostArgsCondition_STATUS from our DeliveryRulePostArgsCondition_STATUS
func (condition *DeliveryRulePostArgsCondition_STATUS) AssignProperties_To_DeliveryRulePostArgsCondition_STATUS(destination *storage.DeliveryRulePostArgsCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.PostArgsMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_PostArgsMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PostArgsMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleQueryStringCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleQueryStringCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *QueryStringMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleQueryStringCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleQueryStringCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &arm.DeliveryRuleQueryStringCondition{}

	// Set property "Name":
	if condition.Name != nil {
		var temp arm.DeliveryRuleQueryStringCondition_Name
		var temp1 string
		temp1 = string(*condition.Name)
		temp = arm.DeliveryRuleQueryStringCondition_Name(temp1)
		result.Name = temp
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*arm.QueryStringMatchConditionParameters)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleQueryStringCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleQueryStringCondition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleQueryStringCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleQueryStringCondition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleQueryStringCondition, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleQueryStringCondition_Name
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleQueryStringCondition_Name(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 QueryStringMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleQueryStringCondition populates our DeliveryRuleQueryStringCondition from the provided source DeliveryRuleQueryStringCondition
func (condition *DeliveryRuleQueryStringCondition) AssignProperties_From_DeliveryRuleQueryStringCondition(source *storage.DeliveryRuleQueryStringCondition) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleQueryStringCondition_Name_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter QueryStringMatchConditionParameters
		err := parameter.AssignProperties_From_QueryStringMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_QueryStringMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleQueryStringCondition populates the provided destination DeliveryRuleQueryStringCondition from our DeliveryRuleQueryStringCondition
func (condition *DeliveryRuleQueryStringCondition) AssignProperties_To_DeliveryRuleQueryStringCondition(destination *storage.DeliveryRuleQueryStringCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.QueryStringMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_QueryStringMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_QueryStringMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleQueryStringCondition_STATUS populates our DeliveryRuleQueryStringCondition from the provided source DeliveryRuleQueryStringCondition_STATUS
func (condition *DeliveryRuleQueryStringCondition) Initialize_From_DeliveryRuleQueryStringCondition_STATUS(source *DeliveryRuleQueryStringCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), deliveryRuleQueryStringCondition_Name_Values)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter QueryStringMatchConditionParameters
		err := parameter.Initialize_From_QueryStringMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_QueryStringMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleQueryStringCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleQueryStringCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *QueryStringMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleQueryStringCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleQueryStringCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleQueryStringCondition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleQueryStringCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleQueryStringCondition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleQueryStringCondition_STATUS, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleQueryStringCondition_Name_STATUS
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleQueryStringCondition_Name_STATUS(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 QueryStringMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleQueryStringCondition_STATUS populates our DeliveryRuleQueryStringCondition_STATUS from the provided source DeliveryRuleQueryStringCondition_STATUS
func (condition *DeliveryRuleQueryStringCondition_STATUS) AssignProperties_From_DeliveryRuleQueryStringCondition_STATUS(source *storage.DeliveryRuleQueryStringCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleQueryStringCondition_Name_STATUS_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter QueryStringMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_QueryStringMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_QueryStringMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleQueryStringCondition_STATUS populates the provided destination DeliveryRuleQueryStringCondition_STATUS from our DeliveryRuleQueryStringCondition_STATUS
func (condition *DeliveryRuleQueryStringCondition_STATUS) AssignProperties_To_DeliveryRuleQueryStringCondition_STATUS(destination *storage.DeliveryRuleQueryStringCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.QueryStringMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_QueryStringMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_QueryStringMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleRemoteAddressCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleRemoteAddressCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *RemoteAddressMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleRemoteAddressCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleRemoteAddressCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &arm.DeliveryRuleRemoteAddressCondition{}

	// Set property "Name":
	if condition.Name != nil {
		var temp arm.DeliveryRuleRemoteAddressCondition_Name
		var temp1 string
		temp1 = string(*condition.Name)
		temp = arm.DeliveryRuleRemoteAddressCondition_Name(temp1)
		result.Name = temp
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*arm.RemoteAddressMatchConditionParameters)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleRemoteAddressCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleRemoteAddressCondition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleRemoteAddressCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleRemoteAddressCondition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleRemoteAddressCondition, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleRemoteAddressCondition_Name
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleRemoteAddressCondition_Name(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 RemoteAddressMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleRemoteAddressCondition populates our DeliveryRuleRemoteAddressCondition from the provided source DeliveryRuleRemoteAddressCondition
func (condition *DeliveryRuleRemoteAddressCondition) AssignProperties_From_DeliveryRuleRemoteAddressCondition(source *storage.DeliveryRuleRemoteAddressCondition) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleRemoteAddressCondition_Name_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RemoteAddressMatchConditionParameters
		err := parameter.AssignProperties_From_RemoteAddressMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RemoteAddressMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRemoteAddressCondition populates the provided destination DeliveryRuleRemoteAddressCondition from our DeliveryRuleRemoteAddressCondition
func (condition *DeliveryRuleRemoteAddressCondition) AssignProperties_To_DeliveryRuleRemoteAddressCondition(destination *storage.DeliveryRuleRemoteAddressCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.RemoteAddressMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_RemoteAddressMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RemoteAddressMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleRemoteAddressCondition_STATUS populates our DeliveryRuleRemoteAddressCondition from the provided source DeliveryRuleRemoteAddressCondition_STATUS
func (condition *DeliveryRuleRemoteAddressCondition) Initialize_From_DeliveryRuleRemoteAddressCondition_STATUS(source *DeliveryRuleRemoteAddressCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), deliveryRuleRemoteAddressCondition_Name_Values)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RemoteAddressMatchConditionParameters
		err := parameter.Initialize_From_RemoteAddressMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_RemoteAddressMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleRemoteAddressCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleRemoteAddressCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *RemoteAddressMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleRemoteAddressCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleRemoteAddressCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleRemoteAddressCondition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleRemoteAddressCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleRemoteAddressCondition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleRemoteAddressCondition_STATUS, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleRemoteAddressCondition_Name_STATUS
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleRemoteAddressCondition_Name_STATUS(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 RemoteAddressMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleRemoteAddressCondition_STATUS populates our DeliveryRuleRemoteAddressCondition_STATUS from the provided source DeliveryRuleRemoteAddressCondition_STATUS
func (condition *DeliveryRuleRemoteAddressCondition_STATUS) AssignProperties_From_DeliveryRuleRemoteAddressCondition_STATUS(source *storage.DeliveryRuleRemoteAddressCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleRemoteAddressCondition_Name_STATUS_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RemoteAddressMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_RemoteAddressMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RemoteAddressMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRemoteAddressCondition_STATUS populates the provided destination DeliveryRuleRemoteAddressCondition_STATUS from our DeliveryRuleRemoteAddressCondition_STATUS
func (condition *DeliveryRuleRemoteAddressCondition_STATUS) AssignProperties_To_DeliveryRuleRemoteAddressCondition_STATUS(destination *storage.DeliveryRuleRemoteAddressCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.RemoteAddressMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_RemoteAddressMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RemoteAddressMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleRequestBodyCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleRequestBodyCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *RequestBodyMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleRequestBodyCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleRequestBodyCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &arm.DeliveryRuleRequestBodyCondition{}

	// Set property "Name":
	if condition.Name != nil {
		var temp arm.DeliveryRuleRequestBodyCondition_Name
		var temp1 string
		temp1 = string(*condition.Name)
		temp = arm.DeliveryRuleRequestBodyCondition_Name(temp1)
		result.Name = temp
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*arm.RequestBodyMatchConditionParameters)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleRequestBodyCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleRequestBodyCondition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleRequestBodyCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleRequestBodyCondition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleRequestBodyCondition, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleRequestBodyCondition_Name
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleRequestBodyCondition_Name(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 RequestBodyMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleRequestBodyCondition populates our DeliveryRuleRequestBodyCondition from the provided source DeliveryRuleRequestBodyCondition
func (condition *DeliveryRuleRequestBodyCondition) AssignProperties_From_DeliveryRuleRequestBodyCondition(source *storage.DeliveryRuleRequestBodyCondition) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleRequestBodyCondition_Name_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RequestBodyMatchConditionParameters
		err := parameter.AssignProperties_From_RequestBodyMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestBodyMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestBodyCondition populates the provided destination DeliveryRuleRequestBodyCondition from our DeliveryRuleRequestBodyCondition
func (condition *DeliveryRuleRequestBodyCondition) AssignProperties_To_DeliveryRuleRequestBodyCondition(destination *storage.DeliveryRuleRequestBodyCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.RequestBodyMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_RequestBodyMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestBodyMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleRequestBodyCondition_STATUS populates our DeliveryRuleRequestBodyCondition from the provided source DeliveryRuleRequestBodyCondition_STATUS
func (condition *DeliveryRuleRequestBodyCondition) Initialize_From_DeliveryRuleRequestBodyCondition_STATUS(source *DeliveryRuleRequestBodyCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), deliveryRuleRequestBodyCondition_Name_Values)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RequestBodyMatchConditionParameters
		err := parameter.Initialize_From_RequestBodyMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_RequestBodyMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleRequestBodyCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleRequestBodyCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *RequestBodyMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleRequestBodyCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleRequestBodyCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleRequestBodyCondition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleRequestBodyCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleRequestBodyCondition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleRequestBodyCondition_STATUS, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleRequestBodyCondition_Name_STATUS
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleRequestBodyCondition_Name_STATUS(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 RequestBodyMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleRequestBodyCondition_STATUS populates our DeliveryRuleRequestBodyCondition_STATUS from the provided source DeliveryRuleRequestBodyCondition_STATUS
func (condition *DeliveryRuleRequestBodyCondition_STATUS) AssignProperties_From_DeliveryRuleRequestBodyCondition_STATUS(source *storage.DeliveryRuleRequestBodyCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleRequestBodyCondition_Name_STATUS_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RequestBodyMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_RequestBodyMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestBodyMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestBodyCondition_STATUS populates the provided destination DeliveryRuleRequestBodyCondition_STATUS from our DeliveryRuleRequestBodyCondition_STATUS
func (condition *DeliveryRuleRequestBodyCondition_STATUS) AssignProperties_To_DeliveryRuleRequestBodyCondition_STATUS(destination *storage.DeliveryRuleRequestBodyCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.RequestBodyMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_RequestBodyMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestBodyMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleRequestHeaderAction struct {
	// +kubebuilder:validation:Required
	// Name: The name of the action for the delivery rule.
	Name *DeliveryRuleRequestHeaderAction_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the action.
	Parameters *HeaderActionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleRequestHeaderAction{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (action *DeliveryRuleRequestHeaderAction) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if action == nil {
		return nil, nil
	}
	result := &arm.DeliveryRuleRequestHeaderAction{}

	// Set property "Name":
	if action.Name != nil {
		var temp arm.DeliveryRuleRequestHeaderAction_Name
		var temp1 string
		temp1 = string(*action.Name)
		temp = arm.DeliveryRuleRequestHeaderAction_Name(temp1)
		result.Name = temp
	}

	// Set property "Parameters":
	if action.Parameters != nil {
		parameters_ARM, err := (*action.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*arm.HeaderActionParameters)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *DeliveryRuleRequestHeaderAction) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleRequestHeaderAction{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *DeliveryRuleRequestHeaderAction) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleRequestHeaderAction)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleRequestHeaderAction, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleRequestHeaderAction_Name
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleRequestHeaderAction_Name(temp1)
	action.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 HeaderActionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleRequestHeaderAction populates our DeliveryRuleRequestHeaderAction from the provided source DeliveryRuleRequestHeaderAction
func (action *DeliveryRuleRequestHeaderAction) AssignProperties_From_DeliveryRuleRequestHeaderAction(source *storage.DeliveryRuleRequestHeaderAction) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleRequestHeaderAction_Name_Values)
		action.Name = &nameTemp
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter HeaderActionParameters
		err := parameter.AssignProperties_From_HeaderActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HeaderActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestHeaderAction populates the provided destination DeliveryRuleRequestHeaderAction from our DeliveryRuleRequestHeaderAction
func (action *DeliveryRuleRequestHeaderAction) AssignProperties_To_DeliveryRuleRequestHeaderAction(destination *storage.DeliveryRuleRequestHeaderAction) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter storage.HeaderActionParameters
		err := action.Parameters.AssignProperties_To_HeaderActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HeaderActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleRequestHeaderAction_STATUS populates our DeliveryRuleRequestHeaderAction from the provided source DeliveryRuleRequestHeaderAction_STATUS
func (action *DeliveryRuleRequestHeaderAction) Initialize_From_DeliveryRuleRequestHeaderAction_STATUS(source *DeliveryRuleRequestHeaderAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), deliveryRuleRequestHeaderAction_Name_Values)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter HeaderActionParameters
		err := parameter.Initialize_From_HeaderActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_HeaderActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleRequestHeaderAction_STATUS struct {
	// Name: The name of the action for the delivery rule.
	Name *DeliveryRuleRequestHeaderAction_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the action.
	Parameters *HeaderActionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleRequestHeaderAction_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *DeliveryRuleRequestHeaderAction_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleRequestHeaderAction_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *DeliveryRuleRequestHeaderAction_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleRequestHeaderAction_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleRequestHeaderAction_STATUS, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleRequestHeaderAction_Name_STATUS
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleRequestHeaderAction_Name_STATUS(temp1)
	action.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 HeaderActionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleRequestHeaderAction_STATUS populates our DeliveryRuleRequestHeaderAction_STATUS from the provided source DeliveryRuleRequestHeaderAction_STATUS
func (action *DeliveryRuleRequestHeaderAction_STATUS) AssignProperties_From_DeliveryRuleRequestHeaderAction_STATUS(source *storage.DeliveryRuleRequestHeaderAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleRequestHeaderAction_Name_STATUS_Values)
		action.Name = &nameTemp
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter HeaderActionParameters_STATUS
		err := parameter.AssignProperties_From_HeaderActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HeaderActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestHeaderAction_STATUS populates the provided destination DeliveryRuleRequestHeaderAction_STATUS from our DeliveryRuleRequestHeaderAction_STATUS
func (action *DeliveryRuleRequestHeaderAction_STATUS) AssignProperties_To_DeliveryRuleRequestHeaderAction_STATUS(destination *storage.DeliveryRuleRequestHeaderAction_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter storage.HeaderActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_HeaderActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HeaderActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleRequestHeaderCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleRequestHeaderCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *RequestHeaderMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleRequestHeaderCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleRequestHeaderCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &arm.DeliveryRuleRequestHeaderCondition{}

	// Set property "Name":
	if condition.Name != nil {
		var temp arm.DeliveryRuleRequestHeaderCondition_Name
		var temp1 string
		temp1 = string(*condition.Name)
		temp = arm.DeliveryRuleRequestHeaderCondition_Name(temp1)
		result.Name = temp
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*arm.RequestHeaderMatchConditionParameters)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleRequestHeaderCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleRequestHeaderCondition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleRequestHeaderCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleRequestHeaderCondition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleRequestHeaderCondition, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleRequestHeaderCondition_Name
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleRequestHeaderCondition_Name(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 RequestHeaderMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleRequestHeaderCondition populates our DeliveryRuleRequestHeaderCondition from the provided source DeliveryRuleRequestHeaderCondition
func (condition *DeliveryRuleRequestHeaderCondition) AssignProperties_From_DeliveryRuleRequestHeaderCondition(source *storage.DeliveryRuleRequestHeaderCondition) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleRequestHeaderCondition_Name_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RequestHeaderMatchConditionParameters
		err := parameter.AssignProperties_From_RequestHeaderMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestHeaderMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestHeaderCondition populates the provided destination DeliveryRuleRequestHeaderCondition from our DeliveryRuleRequestHeaderCondition
func (condition *DeliveryRuleRequestHeaderCondition) AssignProperties_To_DeliveryRuleRequestHeaderCondition(destination *storage.DeliveryRuleRequestHeaderCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.RequestHeaderMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_RequestHeaderMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestHeaderMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleRequestHeaderCondition_STATUS populates our DeliveryRuleRequestHeaderCondition from the provided source DeliveryRuleRequestHeaderCondition_STATUS
func (condition *DeliveryRuleRequestHeaderCondition) Initialize_From_DeliveryRuleRequestHeaderCondition_STATUS(source *DeliveryRuleRequestHeaderCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), deliveryRuleRequestHeaderCondition_Name_Values)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RequestHeaderMatchConditionParameters
		err := parameter.Initialize_From_RequestHeaderMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_RequestHeaderMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleRequestHeaderCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleRequestHeaderCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *RequestHeaderMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleRequestHeaderCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleRequestHeaderCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleRequestHeaderCondition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleRequestHeaderCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleRequestHeaderCondition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleRequestHeaderCondition_STATUS, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleRequestHeaderCondition_Name_STATUS
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleRequestHeaderCondition_Name_STATUS(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 RequestHeaderMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleRequestHeaderCondition_STATUS populates our DeliveryRuleRequestHeaderCondition_STATUS from the provided source DeliveryRuleRequestHeaderCondition_STATUS
func (condition *DeliveryRuleRequestHeaderCondition_STATUS) AssignProperties_From_DeliveryRuleRequestHeaderCondition_STATUS(source *storage.DeliveryRuleRequestHeaderCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleRequestHeaderCondition_Name_STATUS_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RequestHeaderMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_RequestHeaderMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestHeaderMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestHeaderCondition_STATUS populates the provided destination DeliveryRuleRequestHeaderCondition_STATUS from our DeliveryRuleRequestHeaderCondition_STATUS
func (condition *DeliveryRuleRequestHeaderCondition_STATUS) AssignProperties_To_DeliveryRuleRequestHeaderCondition_STATUS(destination *storage.DeliveryRuleRequestHeaderCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.RequestHeaderMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_RequestHeaderMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestHeaderMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleRequestMethodCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleRequestMethodCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *RequestMethodMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleRequestMethodCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleRequestMethodCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &arm.DeliveryRuleRequestMethodCondition{}

	// Set property "Name":
	if condition.Name != nil {
		var temp arm.DeliveryRuleRequestMethodCondition_Name
		var temp1 string
		temp1 = string(*condition.Name)
		temp = arm.DeliveryRuleRequestMethodCondition_Name(temp1)
		result.Name = temp
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*arm.RequestMethodMatchConditionParameters)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleRequestMethodCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleRequestMethodCondition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleRequestMethodCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleRequestMethodCondition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleRequestMethodCondition, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleRequestMethodCondition_Name
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleRequestMethodCondition_Name(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 RequestMethodMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleRequestMethodCondition populates our DeliveryRuleRequestMethodCondition from the provided source DeliveryRuleRequestMethodCondition
func (condition *DeliveryRuleRequestMethodCondition) AssignProperties_From_DeliveryRuleRequestMethodCondition(source *storage.DeliveryRuleRequestMethodCondition) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleRequestMethodCondition_Name_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RequestMethodMatchConditionParameters
		err := parameter.AssignProperties_From_RequestMethodMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestMethodMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestMethodCondition populates the provided destination DeliveryRuleRequestMethodCondition from our DeliveryRuleRequestMethodCondition
func (condition *DeliveryRuleRequestMethodCondition) AssignProperties_To_DeliveryRuleRequestMethodCondition(destination *storage.DeliveryRuleRequestMethodCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.RequestMethodMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_RequestMethodMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestMethodMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleRequestMethodCondition_STATUS populates our DeliveryRuleRequestMethodCondition from the provided source DeliveryRuleRequestMethodCondition_STATUS
func (condition *DeliveryRuleRequestMethodCondition) Initialize_From_DeliveryRuleRequestMethodCondition_STATUS(source *DeliveryRuleRequestMethodCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), deliveryRuleRequestMethodCondition_Name_Values)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RequestMethodMatchConditionParameters
		err := parameter.Initialize_From_RequestMethodMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_RequestMethodMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleRequestMethodCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleRequestMethodCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *RequestMethodMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleRequestMethodCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleRequestMethodCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleRequestMethodCondition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleRequestMethodCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleRequestMethodCondition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleRequestMethodCondition_STATUS, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleRequestMethodCondition_Name_STATUS
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleRequestMethodCondition_Name_STATUS(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 RequestMethodMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleRequestMethodCondition_STATUS populates our DeliveryRuleRequestMethodCondition_STATUS from the provided source DeliveryRuleRequestMethodCondition_STATUS
func (condition *DeliveryRuleRequestMethodCondition_STATUS) AssignProperties_From_DeliveryRuleRequestMethodCondition_STATUS(source *storage.DeliveryRuleRequestMethodCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleRequestMethodCondition_Name_STATUS_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RequestMethodMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_RequestMethodMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestMethodMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestMethodCondition_STATUS populates the provided destination DeliveryRuleRequestMethodCondition_STATUS from our DeliveryRuleRequestMethodCondition_STATUS
func (condition *DeliveryRuleRequestMethodCondition_STATUS) AssignProperties_To_DeliveryRuleRequestMethodCondition_STATUS(destination *storage.DeliveryRuleRequestMethodCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.RequestMethodMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_RequestMethodMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestMethodMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleRequestSchemeCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleRequestSchemeCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *RequestSchemeMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleRequestSchemeCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleRequestSchemeCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &arm.DeliveryRuleRequestSchemeCondition{}

	// Set property "Name":
	if condition.Name != nil {
		var temp arm.DeliveryRuleRequestSchemeCondition_Name
		var temp1 string
		temp1 = string(*condition.Name)
		temp = arm.DeliveryRuleRequestSchemeCondition_Name(temp1)
		result.Name = temp
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*arm.RequestSchemeMatchConditionParameters)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleRequestSchemeCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleRequestSchemeCondition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleRequestSchemeCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleRequestSchemeCondition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleRequestSchemeCondition, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleRequestSchemeCondition_Name
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleRequestSchemeCondition_Name(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 RequestSchemeMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleRequestSchemeCondition populates our DeliveryRuleRequestSchemeCondition from the provided source DeliveryRuleRequestSchemeCondition
func (condition *DeliveryRuleRequestSchemeCondition) AssignProperties_From_DeliveryRuleRequestSchemeCondition(source *storage.DeliveryRuleRequestSchemeCondition) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleRequestSchemeCondition_Name_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RequestSchemeMatchConditionParameters
		err := parameter.AssignProperties_From_RequestSchemeMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestSchemeMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestSchemeCondition populates the provided destination DeliveryRuleRequestSchemeCondition from our DeliveryRuleRequestSchemeCondition
func (condition *DeliveryRuleRequestSchemeCondition) AssignProperties_To_DeliveryRuleRequestSchemeCondition(destination *storage.DeliveryRuleRequestSchemeCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.RequestSchemeMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_RequestSchemeMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestSchemeMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleRequestSchemeCondition_STATUS populates our DeliveryRuleRequestSchemeCondition from the provided source DeliveryRuleRequestSchemeCondition_STATUS
func (condition *DeliveryRuleRequestSchemeCondition) Initialize_From_DeliveryRuleRequestSchemeCondition_STATUS(source *DeliveryRuleRequestSchemeCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), deliveryRuleRequestSchemeCondition_Name_Values)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RequestSchemeMatchConditionParameters
		err := parameter.Initialize_From_RequestSchemeMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_RequestSchemeMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleRequestSchemeCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleRequestSchemeCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *RequestSchemeMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleRequestSchemeCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleRequestSchemeCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleRequestSchemeCondition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleRequestSchemeCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleRequestSchemeCondition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleRequestSchemeCondition_STATUS, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleRequestSchemeCondition_Name_STATUS
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleRequestSchemeCondition_Name_STATUS(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 RequestSchemeMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleRequestSchemeCondition_STATUS populates our DeliveryRuleRequestSchemeCondition_STATUS from the provided source DeliveryRuleRequestSchemeCondition_STATUS
func (condition *DeliveryRuleRequestSchemeCondition_STATUS) AssignProperties_From_DeliveryRuleRequestSchemeCondition_STATUS(source *storage.DeliveryRuleRequestSchemeCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleRequestSchemeCondition_Name_STATUS_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RequestSchemeMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_RequestSchemeMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestSchemeMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestSchemeCondition_STATUS populates the provided destination DeliveryRuleRequestSchemeCondition_STATUS from our DeliveryRuleRequestSchemeCondition_STATUS
func (condition *DeliveryRuleRequestSchemeCondition_STATUS) AssignProperties_To_DeliveryRuleRequestSchemeCondition_STATUS(destination *storage.DeliveryRuleRequestSchemeCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.RequestSchemeMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_RequestSchemeMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestSchemeMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleRequestUriCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleRequestUriCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *RequestUriMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleRequestUriCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleRequestUriCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &arm.DeliveryRuleRequestUriCondition{}

	// Set property "Name":
	if condition.Name != nil {
		var temp arm.DeliveryRuleRequestUriCondition_Name
		var temp1 string
		temp1 = string(*condition.Name)
		temp = arm.DeliveryRuleRequestUriCondition_Name(temp1)
		result.Name = temp
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*arm.RequestUriMatchConditionParameters)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleRequestUriCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleRequestUriCondition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleRequestUriCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleRequestUriCondition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleRequestUriCondition, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleRequestUriCondition_Name
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleRequestUriCondition_Name(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 RequestUriMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleRequestUriCondition populates our DeliveryRuleRequestUriCondition from the provided source DeliveryRuleRequestUriCondition
func (condition *DeliveryRuleRequestUriCondition) AssignProperties_From_DeliveryRuleRequestUriCondition(source *storage.DeliveryRuleRequestUriCondition) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleRequestUriCondition_Name_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RequestUriMatchConditionParameters
		err := parameter.AssignProperties_From_RequestUriMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestUriMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestUriCondition populates the provided destination DeliveryRuleRequestUriCondition from our DeliveryRuleRequestUriCondition
func (condition *DeliveryRuleRequestUriCondition) AssignProperties_To_DeliveryRuleRequestUriCondition(destination *storage.DeliveryRuleRequestUriCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.RequestUriMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_RequestUriMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestUriMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleRequestUriCondition_STATUS populates our DeliveryRuleRequestUriCondition from the provided source DeliveryRuleRequestUriCondition_STATUS
func (condition *DeliveryRuleRequestUriCondition) Initialize_From_DeliveryRuleRequestUriCondition_STATUS(source *DeliveryRuleRequestUriCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), deliveryRuleRequestUriCondition_Name_Values)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RequestUriMatchConditionParameters
		err := parameter.Initialize_From_RequestUriMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_RequestUriMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleRequestUriCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleRequestUriCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *RequestUriMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleRequestUriCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleRequestUriCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleRequestUriCondition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleRequestUriCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleRequestUriCondition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleRequestUriCondition_STATUS, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleRequestUriCondition_Name_STATUS
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleRequestUriCondition_Name_STATUS(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 RequestUriMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleRequestUriCondition_STATUS populates our DeliveryRuleRequestUriCondition_STATUS from the provided source DeliveryRuleRequestUriCondition_STATUS
func (condition *DeliveryRuleRequestUriCondition_STATUS) AssignProperties_From_DeliveryRuleRequestUriCondition_STATUS(source *storage.DeliveryRuleRequestUriCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleRequestUriCondition_Name_STATUS_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RequestUriMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_RequestUriMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestUriMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestUriCondition_STATUS populates the provided destination DeliveryRuleRequestUriCondition_STATUS from our DeliveryRuleRequestUriCondition_STATUS
func (condition *DeliveryRuleRequestUriCondition_STATUS) AssignProperties_To_DeliveryRuleRequestUriCondition_STATUS(destination *storage.DeliveryRuleRequestUriCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.RequestUriMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_RequestUriMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestUriMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleResponseHeaderAction struct {
	// +kubebuilder:validation:Required
	// Name: The name of the action for the delivery rule.
	Name *DeliveryRuleResponseHeaderAction_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the action.
	Parameters *HeaderActionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleResponseHeaderAction{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (action *DeliveryRuleResponseHeaderAction) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if action == nil {
		return nil, nil
	}
	result := &arm.DeliveryRuleResponseHeaderAction{}

	// Set property "Name":
	if action.Name != nil {
		var temp arm.DeliveryRuleResponseHeaderAction_Name
		var temp1 string
		temp1 = string(*action.Name)
		temp = arm.DeliveryRuleResponseHeaderAction_Name(temp1)
		result.Name = temp
	}

	// Set property "Parameters":
	if action.Parameters != nil {
		parameters_ARM, err := (*action.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*arm.HeaderActionParameters)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *DeliveryRuleResponseHeaderAction) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleResponseHeaderAction{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *DeliveryRuleResponseHeaderAction) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleResponseHeaderAction)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleResponseHeaderAction, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleResponseHeaderAction_Name
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleResponseHeaderAction_Name(temp1)
	action.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 HeaderActionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleResponseHeaderAction populates our DeliveryRuleResponseHeaderAction from the provided source DeliveryRuleResponseHeaderAction
func (action *DeliveryRuleResponseHeaderAction) AssignProperties_From_DeliveryRuleResponseHeaderAction(source *storage.DeliveryRuleResponseHeaderAction) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleResponseHeaderAction_Name_Values)
		action.Name = &nameTemp
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter HeaderActionParameters
		err := parameter.AssignProperties_From_HeaderActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HeaderActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleResponseHeaderAction populates the provided destination DeliveryRuleResponseHeaderAction from our DeliveryRuleResponseHeaderAction
func (action *DeliveryRuleResponseHeaderAction) AssignProperties_To_DeliveryRuleResponseHeaderAction(destination *storage.DeliveryRuleResponseHeaderAction) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter storage.HeaderActionParameters
		err := action.Parameters.AssignProperties_To_HeaderActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HeaderActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleResponseHeaderAction_STATUS populates our DeliveryRuleResponseHeaderAction from the provided source DeliveryRuleResponseHeaderAction_STATUS
func (action *DeliveryRuleResponseHeaderAction) Initialize_From_DeliveryRuleResponseHeaderAction_STATUS(source *DeliveryRuleResponseHeaderAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), deliveryRuleResponseHeaderAction_Name_Values)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter HeaderActionParameters
		err := parameter.Initialize_From_HeaderActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_HeaderActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleResponseHeaderAction_STATUS struct {
	// Name: The name of the action for the delivery rule.
	Name *DeliveryRuleResponseHeaderAction_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the action.
	Parameters *HeaderActionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleResponseHeaderAction_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *DeliveryRuleResponseHeaderAction_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleResponseHeaderAction_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *DeliveryRuleResponseHeaderAction_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleResponseHeaderAction_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleResponseHeaderAction_STATUS, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleResponseHeaderAction_Name_STATUS
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleResponseHeaderAction_Name_STATUS(temp1)
	action.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 HeaderActionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleResponseHeaderAction_STATUS populates our DeliveryRuleResponseHeaderAction_STATUS from the provided source DeliveryRuleResponseHeaderAction_STATUS
func (action *DeliveryRuleResponseHeaderAction_STATUS) AssignProperties_From_DeliveryRuleResponseHeaderAction_STATUS(source *storage.DeliveryRuleResponseHeaderAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleResponseHeaderAction_Name_STATUS_Values)
		action.Name = &nameTemp
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter HeaderActionParameters_STATUS
		err := parameter.AssignProperties_From_HeaderActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HeaderActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleResponseHeaderAction_STATUS populates the provided destination DeliveryRuleResponseHeaderAction_STATUS from our DeliveryRuleResponseHeaderAction_STATUS
func (action *DeliveryRuleResponseHeaderAction_STATUS) AssignProperties_To_DeliveryRuleResponseHeaderAction_STATUS(destination *storage.DeliveryRuleResponseHeaderAction_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter storage.HeaderActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_HeaderActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HeaderActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleRouteConfigurationOverrideAction struct {
	// +kubebuilder:validation:Required
	// Name: The name of the action for the delivery rule.
	Name *DeliveryRuleRouteConfigurationOverrideAction_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the action.
	Parameters *RouteConfigurationOverrideActionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleRouteConfigurationOverrideAction{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (action *DeliveryRuleRouteConfigurationOverrideAction) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if action == nil {
		return nil, nil
	}
	result := &arm.DeliveryRuleRouteConfigurationOverrideAction{}

	// Set property "Name":
	if action.Name != nil {
		var temp arm.DeliveryRuleRouteConfigurationOverrideAction_Name
		var temp1 string
		temp1 = string(*action.Name)
		temp = arm.DeliveryRuleRouteConfigurationOverrideAction_Name(temp1)
		result.Name = temp
	}

	// Set property "Parameters":
	if action.Parameters != nil {
		parameters_ARM, err := (*action.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*arm.RouteConfigurationOverrideActionParameters)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *DeliveryRuleRouteConfigurationOverrideAction) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleRouteConfigurationOverrideAction{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *DeliveryRuleRouteConfigurationOverrideAction) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleRouteConfigurationOverrideAction)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleRouteConfigurationOverrideAction, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleRouteConfigurationOverrideAction_Name
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleRouteConfigurationOverrideAction_Name(temp1)
	action.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 RouteConfigurationOverrideActionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction populates our DeliveryRuleRouteConfigurationOverrideAction from the provided source DeliveryRuleRouteConfigurationOverrideAction
func (action *DeliveryRuleRouteConfigurationOverrideAction) AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction(source *storage.DeliveryRuleRouteConfigurationOverrideAction) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleRouteConfigurationOverrideAction_Name_Values)
		action.Name = &nameTemp
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RouteConfigurationOverrideActionParameters
		err := parameter.AssignProperties_From_RouteConfigurationOverrideActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RouteConfigurationOverrideActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction populates the provided destination DeliveryRuleRouteConfigurationOverrideAction from our DeliveryRuleRouteConfigurationOverrideAction
func (action *DeliveryRuleRouteConfigurationOverrideAction) AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction(destination *storage.DeliveryRuleRouteConfigurationOverrideAction) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter storage.RouteConfigurationOverrideActionParameters
		err := action.Parameters.AssignProperties_To_RouteConfigurationOverrideActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RouteConfigurationOverrideActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleRouteConfigurationOverrideAction_STATUS populates our DeliveryRuleRouteConfigurationOverrideAction from the provided source DeliveryRuleRouteConfigurationOverrideAction_STATUS
func (action *DeliveryRuleRouteConfigurationOverrideAction) Initialize_From_DeliveryRuleRouteConfigurationOverrideAction_STATUS(source *DeliveryRuleRouteConfigurationOverrideAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), deliveryRuleRouteConfigurationOverrideAction_Name_Values)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RouteConfigurationOverrideActionParameters
		err := parameter.Initialize_From_RouteConfigurationOverrideActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_RouteConfigurationOverrideActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleRouteConfigurationOverrideAction_STATUS struct {
	// Name: The name of the action for the delivery rule.
	Name *DeliveryRuleRouteConfigurationOverrideAction_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the action.
	Parameters *RouteConfigurationOverrideActionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleRouteConfigurationOverrideAction_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *DeliveryRuleRouteConfigurationOverrideAction_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleRouteConfigurationOverrideAction_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *DeliveryRuleRouteConfigurationOverrideAction_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleRouteConfigurationOverrideAction_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleRouteConfigurationOverrideAction_STATUS, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleRouteConfigurationOverrideAction_Name_STATUS
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleRouteConfigurationOverrideAction_Name_STATUS(temp1)
	action.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 RouteConfigurationOverrideActionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction_STATUS populates our DeliveryRuleRouteConfigurationOverrideAction_STATUS from the provided source DeliveryRuleRouteConfigurationOverrideAction_STATUS
func (action *DeliveryRuleRouteConfigurationOverrideAction_STATUS) AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction_STATUS(source *storage.DeliveryRuleRouteConfigurationOverrideAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleRouteConfigurationOverrideAction_Name_STATUS_Values)
		action.Name = &nameTemp
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RouteConfigurationOverrideActionParameters_STATUS
		err := parameter.AssignProperties_From_RouteConfigurationOverrideActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RouteConfigurationOverrideActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction_STATUS populates the provided destination DeliveryRuleRouteConfigurationOverrideAction_STATUS from our DeliveryRuleRouteConfigurationOverrideAction_STATUS
func (action *DeliveryRuleRouteConfigurationOverrideAction_STATUS) AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction_STATUS(destination *storage.DeliveryRuleRouteConfigurationOverrideAction_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter storage.RouteConfigurationOverrideActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_RouteConfigurationOverrideActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RouteConfigurationOverrideActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleServerPortCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleServerPortCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *ServerPortMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleServerPortCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleServerPortCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &arm.DeliveryRuleServerPortCondition{}

	// Set property "Name":
	if condition.Name != nil {
		var temp arm.DeliveryRuleServerPortCondition_Name
		var temp1 string
		temp1 = string(*condition.Name)
		temp = arm.DeliveryRuleServerPortCondition_Name(temp1)
		result.Name = temp
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*arm.ServerPortMatchConditionParameters)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleServerPortCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleServerPortCondition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleServerPortCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleServerPortCondition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleServerPortCondition, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleServerPortCondition_Name
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleServerPortCondition_Name(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 ServerPortMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleServerPortCondition populates our DeliveryRuleServerPortCondition from the provided source DeliveryRuleServerPortCondition
func (condition *DeliveryRuleServerPortCondition) AssignProperties_From_DeliveryRuleServerPortCondition(source *storage.DeliveryRuleServerPortCondition) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleServerPortCondition_Name_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter ServerPortMatchConditionParameters
		err := parameter.AssignProperties_From_ServerPortMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ServerPortMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleServerPortCondition populates the provided destination DeliveryRuleServerPortCondition from our DeliveryRuleServerPortCondition
func (condition *DeliveryRuleServerPortCondition) AssignProperties_To_DeliveryRuleServerPortCondition(destination *storage.DeliveryRuleServerPortCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.ServerPortMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_ServerPortMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ServerPortMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleServerPortCondition_STATUS populates our DeliveryRuleServerPortCondition from the provided source DeliveryRuleServerPortCondition_STATUS
func (condition *DeliveryRuleServerPortCondition) Initialize_From_DeliveryRuleServerPortCondition_STATUS(source *DeliveryRuleServerPortCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), deliveryRuleServerPortCondition_Name_Values)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter ServerPortMatchConditionParameters
		err := parameter.Initialize_From_ServerPortMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ServerPortMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleServerPortCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleServerPortCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *ServerPortMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleServerPortCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleServerPortCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleServerPortCondition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleServerPortCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleServerPortCondition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleServerPortCondition_STATUS, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleServerPortCondition_Name_STATUS
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleServerPortCondition_Name_STATUS(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 ServerPortMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleServerPortCondition_STATUS populates our DeliveryRuleServerPortCondition_STATUS from the provided source DeliveryRuleServerPortCondition_STATUS
func (condition *DeliveryRuleServerPortCondition_STATUS) AssignProperties_From_DeliveryRuleServerPortCondition_STATUS(source *storage.DeliveryRuleServerPortCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleServerPortCondition_Name_STATUS_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter ServerPortMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_ServerPortMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ServerPortMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleServerPortCondition_STATUS populates the provided destination DeliveryRuleServerPortCondition_STATUS from our DeliveryRuleServerPortCondition_STATUS
func (condition *DeliveryRuleServerPortCondition_STATUS) AssignProperties_To_DeliveryRuleServerPortCondition_STATUS(destination *storage.DeliveryRuleServerPortCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.ServerPortMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_ServerPortMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ServerPortMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleSocketAddrCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleSocketAddrCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *SocketAddrMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleSocketAddrCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleSocketAddrCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &arm.DeliveryRuleSocketAddrCondition{}

	// Set property "Name":
	if condition.Name != nil {
		var temp arm.DeliveryRuleSocketAddrCondition_Name
		var temp1 string
		temp1 = string(*condition.Name)
		temp = arm.DeliveryRuleSocketAddrCondition_Name(temp1)
		result.Name = temp
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*arm.SocketAddrMatchConditionParameters)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleSocketAddrCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleSocketAddrCondition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleSocketAddrCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleSocketAddrCondition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleSocketAddrCondition, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleSocketAddrCondition_Name
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleSocketAddrCondition_Name(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 SocketAddrMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleSocketAddrCondition populates our DeliveryRuleSocketAddrCondition from the provided source DeliveryRuleSocketAddrCondition
func (condition *DeliveryRuleSocketAddrCondition) AssignProperties_From_DeliveryRuleSocketAddrCondition(source *storage.DeliveryRuleSocketAddrCondition) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleSocketAddrCondition_Name_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter SocketAddrMatchConditionParameters
		err := parameter.AssignProperties_From_SocketAddrMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SocketAddrMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleSocketAddrCondition populates the provided destination DeliveryRuleSocketAddrCondition from our DeliveryRuleSocketAddrCondition
func (condition *DeliveryRuleSocketAddrCondition) AssignProperties_To_DeliveryRuleSocketAddrCondition(destination *storage.DeliveryRuleSocketAddrCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.SocketAddrMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_SocketAddrMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SocketAddrMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleSocketAddrCondition_STATUS populates our DeliveryRuleSocketAddrCondition from the provided source DeliveryRuleSocketAddrCondition_STATUS
func (condition *DeliveryRuleSocketAddrCondition) Initialize_From_DeliveryRuleSocketAddrCondition_STATUS(source *DeliveryRuleSocketAddrCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), deliveryRuleSocketAddrCondition_Name_Values)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter SocketAddrMatchConditionParameters
		err := parameter.Initialize_From_SocketAddrMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SocketAddrMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleSocketAddrCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleSocketAddrCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *SocketAddrMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleSocketAddrCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleSocketAddrCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleSocketAddrCondition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleSocketAddrCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleSocketAddrCondition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleSocketAddrCondition_STATUS, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleSocketAddrCondition_Name_STATUS
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleSocketAddrCondition_Name_STATUS(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 SocketAddrMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleSocketAddrCondition_STATUS populates our DeliveryRuleSocketAddrCondition_STATUS from the provided source DeliveryRuleSocketAddrCondition_STATUS
func (condition *DeliveryRuleSocketAddrCondition_STATUS) AssignProperties_From_DeliveryRuleSocketAddrCondition_STATUS(source *storage.DeliveryRuleSocketAddrCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleSocketAddrCondition_Name_STATUS_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter SocketAddrMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_SocketAddrMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SocketAddrMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleSocketAddrCondition_STATUS populates the provided destination DeliveryRuleSocketAddrCondition_STATUS from our DeliveryRuleSocketAddrCondition_STATUS
func (condition *DeliveryRuleSocketAddrCondition_STATUS) AssignProperties_To_DeliveryRuleSocketAddrCondition_STATUS(destination *storage.DeliveryRuleSocketAddrCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.SocketAddrMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_SocketAddrMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SocketAddrMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleSslProtocolCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleSslProtocolCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *SslProtocolMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleSslProtocolCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleSslProtocolCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &arm.DeliveryRuleSslProtocolCondition{}

	// Set property "Name":
	if condition.Name != nil {
		var temp arm.DeliveryRuleSslProtocolCondition_Name
		var temp1 string
		temp1 = string(*condition.Name)
		temp = arm.DeliveryRuleSslProtocolCondition_Name(temp1)
		result.Name = temp
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*arm.SslProtocolMatchConditionParameters)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleSslProtocolCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleSslProtocolCondition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleSslProtocolCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleSslProtocolCondition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleSslProtocolCondition, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleSslProtocolCondition_Name
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleSslProtocolCondition_Name(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 SslProtocolMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleSslProtocolCondition populates our DeliveryRuleSslProtocolCondition from the provided source DeliveryRuleSslProtocolCondition
func (condition *DeliveryRuleSslProtocolCondition) AssignProperties_From_DeliveryRuleSslProtocolCondition(source *storage.DeliveryRuleSslProtocolCondition) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleSslProtocolCondition_Name_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter SslProtocolMatchConditionParameters
		err := parameter.AssignProperties_From_SslProtocolMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SslProtocolMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleSslProtocolCondition populates the provided destination DeliveryRuleSslProtocolCondition from our DeliveryRuleSslProtocolCondition
func (condition *DeliveryRuleSslProtocolCondition) AssignProperties_To_DeliveryRuleSslProtocolCondition(destination *storage.DeliveryRuleSslProtocolCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.SslProtocolMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_SslProtocolMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SslProtocolMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleSslProtocolCondition_STATUS populates our DeliveryRuleSslProtocolCondition from the provided source DeliveryRuleSslProtocolCondition_STATUS
func (condition *DeliveryRuleSslProtocolCondition) Initialize_From_DeliveryRuleSslProtocolCondition_STATUS(source *DeliveryRuleSslProtocolCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), deliveryRuleSslProtocolCondition_Name_Values)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter SslProtocolMatchConditionParameters
		err := parameter.Initialize_From_SslProtocolMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SslProtocolMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleSslProtocolCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleSslProtocolCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *SslProtocolMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleSslProtocolCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleSslProtocolCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleSslProtocolCondition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleSslProtocolCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleSslProtocolCondition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleSslProtocolCondition_STATUS, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleSslProtocolCondition_Name_STATUS
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleSslProtocolCondition_Name_STATUS(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 SslProtocolMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleSslProtocolCondition_STATUS populates our DeliveryRuleSslProtocolCondition_STATUS from the provided source DeliveryRuleSslProtocolCondition_STATUS
func (condition *DeliveryRuleSslProtocolCondition_STATUS) AssignProperties_From_DeliveryRuleSslProtocolCondition_STATUS(source *storage.DeliveryRuleSslProtocolCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleSslProtocolCondition_Name_STATUS_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter SslProtocolMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_SslProtocolMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SslProtocolMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleSslProtocolCondition_STATUS populates the provided destination DeliveryRuleSslProtocolCondition_STATUS from our DeliveryRuleSslProtocolCondition_STATUS
func (condition *DeliveryRuleSslProtocolCondition_STATUS) AssignProperties_To_DeliveryRuleSslProtocolCondition_STATUS(destination *storage.DeliveryRuleSslProtocolCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.SslProtocolMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_SslProtocolMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SslProtocolMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleUrlFileExtensionCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleUrlFileExtensionCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *UrlFileExtensionMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleUrlFileExtensionCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleUrlFileExtensionCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &arm.DeliveryRuleUrlFileExtensionCondition{}

	// Set property "Name":
	if condition.Name != nil {
		var temp arm.DeliveryRuleUrlFileExtensionCondition_Name
		var temp1 string
		temp1 = string(*condition.Name)
		temp = arm.DeliveryRuleUrlFileExtensionCondition_Name(temp1)
		result.Name = temp
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*arm.UrlFileExtensionMatchConditionParameters)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleUrlFileExtensionCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleUrlFileExtensionCondition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleUrlFileExtensionCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleUrlFileExtensionCondition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleUrlFileExtensionCondition, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleUrlFileExtensionCondition_Name
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleUrlFileExtensionCondition_Name(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 UrlFileExtensionMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleUrlFileExtensionCondition populates our DeliveryRuleUrlFileExtensionCondition from the provided source DeliveryRuleUrlFileExtensionCondition
func (condition *DeliveryRuleUrlFileExtensionCondition) AssignProperties_From_DeliveryRuleUrlFileExtensionCondition(source *storage.DeliveryRuleUrlFileExtensionCondition) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleUrlFileExtensionCondition_Name_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlFileExtensionMatchConditionParameters
		err := parameter.AssignProperties_From_UrlFileExtensionMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlFileExtensionMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleUrlFileExtensionCondition populates the provided destination DeliveryRuleUrlFileExtensionCondition from our DeliveryRuleUrlFileExtensionCondition
func (condition *DeliveryRuleUrlFileExtensionCondition) AssignProperties_To_DeliveryRuleUrlFileExtensionCondition(destination *storage.DeliveryRuleUrlFileExtensionCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.UrlFileExtensionMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_UrlFileExtensionMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlFileExtensionMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleUrlFileExtensionCondition_STATUS populates our DeliveryRuleUrlFileExtensionCondition from the provided source DeliveryRuleUrlFileExtensionCondition_STATUS
func (condition *DeliveryRuleUrlFileExtensionCondition) Initialize_From_DeliveryRuleUrlFileExtensionCondition_STATUS(source *DeliveryRuleUrlFileExtensionCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), deliveryRuleUrlFileExtensionCondition_Name_Values)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlFileExtensionMatchConditionParameters
		err := parameter.Initialize_From_UrlFileExtensionMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_UrlFileExtensionMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleUrlFileExtensionCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleUrlFileExtensionCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *UrlFileExtensionMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleUrlFileExtensionCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleUrlFileExtensionCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleUrlFileExtensionCondition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleUrlFileExtensionCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleUrlFileExtensionCondition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleUrlFileExtensionCondition_STATUS, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleUrlFileExtensionCondition_Name_STATUS
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleUrlFileExtensionCondition_Name_STATUS(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 UrlFileExtensionMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleUrlFileExtensionCondition_STATUS populates our DeliveryRuleUrlFileExtensionCondition_STATUS from the provided source DeliveryRuleUrlFileExtensionCondition_STATUS
func (condition *DeliveryRuleUrlFileExtensionCondition_STATUS) AssignProperties_From_DeliveryRuleUrlFileExtensionCondition_STATUS(source *storage.DeliveryRuleUrlFileExtensionCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleUrlFileExtensionCondition_Name_STATUS_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlFileExtensionMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_UrlFileExtensionMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlFileExtensionMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleUrlFileExtensionCondition_STATUS populates the provided destination DeliveryRuleUrlFileExtensionCondition_STATUS from our DeliveryRuleUrlFileExtensionCondition_STATUS
func (condition *DeliveryRuleUrlFileExtensionCondition_STATUS) AssignProperties_To_DeliveryRuleUrlFileExtensionCondition_STATUS(destination *storage.DeliveryRuleUrlFileExtensionCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.UrlFileExtensionMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_UrlFileExtensionMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlFileExtensionMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleUrlFileNameCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleUrlFileNameCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *UrlFileNameMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleUrlFileNameCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleUrlFileNameCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &arm.DeliveryRuleUrlFileNameCondition{}

	// Set property "Name":
	if condition.Name != nil {
		var temp arm.DeliveryRuleUrlFileNameCondition_Name
		var temp1 string
		temp1 = string(*condition.Name)
		temp = arm.DeliveryRuleUrlFileNameCondition_Name(temp1)
		result.Name = temp
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*arm.UrlFileNameMatchConditionParameters)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleUrlFileNameCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleUrlFileNameCondition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleUrlFileNameCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleUrlFileNameCondition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleUrlFileNameCondition, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleUrlFileNameCondition_Name
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleUrlFileNameCondition_Name(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 UrlFileNameMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleUrlFileNameCondition populates our DeliveryRuleUrlFileNameCondition from the provided source DeliveryRuleUrlFileNameCondition
func (condition *DeliveryRuleUrlFileNameCondition) AssignProperties_From_DeliveryRuleUrlFileNameCondition(source *storage.DeliveryRuleUrlFileNameCondition) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleUrlFileNameCondition_Name_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlFileNameMatchConditionParameters
		err := parameter.AssignProperties_From_UrlFileNameMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlFileNameMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleUrlFileNameCondition populates the provided destination DeliveryRuleUrlFileNameCondition from our DeliveryRuleUrlFileNameCondition
func (condition *DeliveryRuleUrlFileNameCondition) AssignProperties_To_DeliveryRuleUrlFileNameCondition(destination *storage.DeliveryRuleUrlFileNameCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.UrlFileNameMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_UrlFileNameMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlFileNameMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleUrlFileNameCondition_STATUS populates our DeliveryRuleUrlFileNameCondition from the provided source DeliveryRuleUrlFileNameCondition_STATUS
func (condition *DeliveryRuleUrlFileNameCondition) Initialize_From_DeliveryRuleUrlFileNameCondition_STATUS(source *DeliveryRuleUrlFileNameCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), deliveryRuleUrlFileNameCondition_Name_Values)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlFileNameMatchConditionParameters
		err := parameter.Initialize_From_UrlFileNameMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_UrlFileNameMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleUrlFileNameCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleUrlFileNameCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *UrlFileNameMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleUrlFileNameCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleUrlFileNameCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleUrlFileNameCondition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleUrlFileNameCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleUrlFileNameCondition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleUrlFileNameCondition_STATUS, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleUrlFileNameCondition_Name_STATUS
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleUrlFileNameCondition_Name_STATUS(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 UrlFileNameMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleUrlFileNameCondition_STATUS populates our DeliveryRuleUrlFileNameCondition_STATUS from the provided source DeliveryRuleUrlFileNameCondition_STATUS
func (condition *DeliveryRuleUrlFileNameCondition_STATUS) AssignProperties_From_DeliveryRuleUrlFileNameCondition_STATUS(source *storage.DeliveryRuleUrlFileNameCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleUrlFileNameCondition_Name_STATUS_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlFileNameMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_UrlFileNameMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlFileNameMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleUrlFileNameCondition_STATUS populates the provided destination DeliveryRuleUrlFileNameCondition_STATUS from our DeliveryRuleUrlFileNameCondition_STATUS
func (condition *DeliveryRuleUrlFileNameCondition_STATUS) AssignProperties_To_DeliveryRuleUrlFileNameCondition_STATUS(destination *storage.DeliveryRuleUrlFileNameCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.UrlFileNameMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_UrlFileNameMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlFileNameMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleUrlPathCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleUrlPathCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *UrlPathMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleUrlPathCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleUrlPathCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &arm.DeliveryRuleUrlPathCondition{}

	// Set property "Name":
	if condition.Name != nil {
		var temp arm.DeliveryRuleUrlPathCondition_Name
		var temp1 string
		temp1 = string(*condition.Name)
		temp = arm.DeliveryRuleUrlPathCondition_Name(temp1)
		result.Name = temp
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*arm.UrlPathMatchConditionParameters)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleUrlPathCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleUrlPathCondition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleUrlPathCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleUrlPathCondition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleUrlPathCondition, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleUrlPathCondition_Name
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleUrlPathCondition_Name(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 UrlPathMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleUrlPathCondition populates our DeliveryRuleUrlPathCondition from the provided source DeliveryRuleUrlPathCondition
func (condition *DeliveryRuleUrlPathCondition) AssignProperties_From_DeliveryRuleUrlPathCondition(source *storage.DeliveryRuleUrlPathCondition) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleUrlPathCondition_Name_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlPathMatchConditionParameters
		err := parameter.AssignProperties_From_UrlPathMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlPathMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleUrlPathCondition populates the provided destination DeliveryRuleUrlPathCondition from our DeliveryRuleUrlPathCondition
func (condition *DeliveryRuleUrlPathCondition) AssignProperties_To_DeliveryRuleUrlPathCondition(destination *storage.DeliveryRuleUrlPathCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.UrlPathMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_UrlPathMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlPathMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleUrlPathCondition_STATUS populates our DeliveryRuleUrlPathCondition from the provided source DeliveryRuleUrlPathCondition_STATUS
func (condition *DeliveryRuleUrlPathCondition) Initialize_From_DeliveryRuleUrlPathCondition_STATUS(source *DeliveryRuleUrlPathCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), deliveryRuleUrlPathCondition_Name_Values)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlPathMatchConditionParameters
		err := parameter.Initialize_From_UrlPathMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_UrlPathMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleUrlPathCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleUrlPathCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *UrlPathMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleUrlPathCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleUrlPathCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DeliveryRuleUrlPathCondition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleUrlPathCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DeliveryRuleUrlPathCondition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DeliveryRuleUrlPathCondition_STATUS, got %T", armInput)
	}

	// Set property "Name":
	var temp DeliveryRuleUrlPathCondition_Name_STATUS
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = DeliveryRuleUrlPathCondition_Name_STATUS(temp1)
	condition.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 UrlPathMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleUrlPathCondition_STATUS populates our DeliveryRuleUrlPathCondition_STATUS from the provided source DeliveryRuleUrlPathCondition_STATUS
func (condition *DeliveryRuleUrlPathCondition_STATUS) AssignProperties_From_DeliveryRuleUrlPathCondition_STATUS(source *storage.DeliveryRuleUrlPathCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, deliveryRuleUrlPathCondition_Name_STATUS_Values)
		condition.Name = &nameTemp
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlPathMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_UrlPathMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlPathMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleUrlPathCondition_STATUS populates the provided destination DeliveryRuleUrlPathCondition_STATUS from our DeliveryRuleUrlPathCondition_STATUS
func (condition *DeliveryRuleUrlPathCondition_STATUS) AssignProperties_To_DeliveryRuleUrlPathCondition_STATUS(destination *storage.DeliveryRuleUrlPathCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.UrlPathMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_UrlPathMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlPathMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type OriginGroupOverrideAction struct {
	// +kubebuilder:validation:Required
	// Name: The name of the action for the delivery rule.
	Name *OriginGroupOverrideAction_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the action.
	Parameters *OriginGroupOverrideActionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &OriginGroupOverrideAction{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (action *OriginGroupOverrideAction) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if action == nil {
		return nil, nil
	}
	result := &arm.OriginGroupOverrideAction{}

	// Set property "Name":
	if action.Name != nil {
		var temp arm.OriginGroupOverrideAction_Name
		var temp1 string
		temp1 = string(*action.Name)
		temp = arm.OriginGroupOverrideAction_Name(temp1)
		result.Name = temp
	}

	// Set property "Parameters":
	if action.Parameters != nil {
		parameters_ARM, err := (*action.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*arm.OriginGroupOverrideActionParameters)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *OriginGroupOverrideAction) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.OriginGroupOverrideAction{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *OriginGroupOverrideAction) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.OriginGroupOverrideAction)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.OriginGroupOverrideAction, got %T", armInput)
	}

	// Set property "Name":
	var temp OriginGroupOverrideAction_Name
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = OriginGroupOverrideAction_Name(temp1)
	action.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 OriginGroupOverrideActionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_OriginGroupOverrideAction populates our OriginGroupOverrideAction from the provided source OriginGroupOverrideAction
func (action *OriginGroupOverrideAction) AssignProperties_From_OriginGroupOverrideAction(source *storage.OriginGroupOverrideAction) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, originGroupOverrideAction_Name_Values)
		action.Name = &nameTemp
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter OriginGroupOverrideActionParameters
		err := parameter.AssignProperties_From_OriginGroupOverrideActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OriginGroupOverrideActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_OriginGroupOverrideAction populates the provided destination OriginGroupOverrideAction from our OriginGroupOverrideAction
func (action *OriginGroupOverrideAction) AssignProperties_To_OriginGroupOverrideAction(destination *storage.OriginGroupOverrideAction) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter storage.OriginGroupOverrideActionParameters
		err := action.Parameters.AssignProperties_To_OriginGroupOverrideActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OriginGroupOverrideActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_OriginGroupOverrideAction_STATUS populates our OriginGroupOverrideAction from the provided source OriginGroupOverrideAction_STATUS
func (action *OriginGroupOverrideAction) Initialize_From_OriginGroupOverrideAction_STATUS(source *OriginGroupOverrideAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), originGroupOverrideAction_Name_Values)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter OriginGroupOverrideActionParameters
		err := parameter.Initialize_From_OriginGroupOverrideActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_OriginGroupOverrideActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

type OriginGroupOverrideAction_STATUS struct {
	// Name: The name of the action for the delivery rule.
	Name *OriginGroupOverrideAction_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the action.
	Parameters *OriginGroupOverrideActionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &OriginGroupOverrideAction_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *OriginGroupOverrideAction_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.OriginGroupOverrideAction_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *OriginGroupOverrideAction_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.OriginGroupOverrideAction_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.OriginGroupOverrideAction_STATUS, got %T", armInput)
	}

	// Set property "Name":
	var temp OriginGroupOverrideAction_Name_STATUS
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = OriginGroupOverrideAction_Name_STATUS(temp1)
	action.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 OriginGroupOverrideActionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_OriginGroupOverrideAction_STATUS populates our OriginGroupOverrideAction_STATUS from the provided source OriginGroupOverrideAction_STATUS
func (action *OriginGroupOverrideAction_STATUS) AssignProperties_From_OriginGroupOverrideAction_STATUS(source *storage.OriginGroupOverrideAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, originGroupOverrideAction_Name_STATUS_Values)
		action.Name = &nameTemp
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter OriginGroupOverrideActionParameters_STATUS
		err := parameter.AssignProperties_From_OriginGroupOverrideActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OriginGroupOverrideActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_OriginGroupOverrideAction_STATUS populates the provided destination OriginGroupOverrideAction_STATUS from our OriginGroupOverrideAction_STATUS
func (action *OriginGroupOverrideAction_STATUS) AssignProperties_To_OriginGroupOverrideAction_STATUS(destination *storage.OriginGroupOverrideAction_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter storage.OriginGroupOverrideActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_OriginGroupOverrideActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OriginGroupOverrideActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type UrlRedirectAction struct {
	// +kubebuilder:validation:Required
	// Name: The name of the action for the delivery rule.
	Name *UrlRedirectAction_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the action.
	Parameters *UrlRedirectActionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &UrlRedirectAction{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (action *UrlRedirectAction) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if action == nil {
		return nil, nil
	}
	result := &arm.UrlRedirectAction{}

	// Set property "Name":
	if action.Name != nil {
		var temp arm.UrlRedirectAction_Name
		var temp1 string
		temp1 = string(*action.Name)
		temp = arm.UrlRedirectAction_Name(temp1)
		result.Name = temp
	}

	// Set property "Parameters":
	if action.Parameters != nil {
		parameters_ARM, err := (*action.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*arm.UrlRedirectActionParameters)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *UrlRedirectAction) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UrlRedirectAction{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *UrlRedirectAction) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UrlRedirectAction)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UrlRedirectAction, got %T", armInput)
	}

	// Set property "Name":
	var temp UrlRedirectAction_Name
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = UrlRedirectAction_Name(temp1)
	action.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 UrlRedirectActionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_UrlRedirectAction populates our UrlRedirectAction from the provided source UrlRedirectAction
func (action *UrlRedirectAction) AssignProperties_From_UrlRedirectAction(source *storage.UrlRedirectAction) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, urlRedirectAction_Name_Values)
		action.Name = &nameTemp
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlRedirectActionParameters
		err := parameter.AssignProperties_From_UrlRedirectActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlRedirectActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlRedirectAction populates the provided destination UrlRedirectAction from our UrlRedirectAction
func (action *UrlRedirectAction) AssignProperties_To_UrlRedirectAction(destination *storage.UrlRedirectAction) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter storage.UrlRedirectActionParameters
		err := action.Parameters.AssignProperties_To_UrlRedirectActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlRedirectActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_UrlRedirectAction_STATUS populates our UrlRedirectAction from the provided source UrlRedirectAction_STATUS
func (action *UrlRedirectAction) Initialize_From_UrlRedirectAction_STATUS(source *UrlRedirectAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), urlRedirectAction_Name_Values)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlRedirectActionParameters
		err := parameter.Initialize_From_UrlRedirectActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_UrlRedirectActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

type UrlRedirectAction_STATUS struct {
	// Name: The name of the action for the delivery rule.
	Name *UrlRedirectAction_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the action.
	Parameters *UrlRedirectActionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &UrlRedirectAction_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *UrlRedirectAction_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UrlRedirectAction_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *UrlRedirectAction_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UrlRedirectAction_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UrlRedirectAction_STATUS, got %T", armInput)
	}

	// Set property "Name":
	var temp UrlRedirectAction_Name_STATUS
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = UrlRedirectAction_Name_STATUS(temp1)
	action.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 UrlRedirectActionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_UrlRedirectAction_STATUS populates our UrlRedirectAction_STATUS from the provided source UrlRedirectAction_STATUS
func (action *UrlRedirectAction_STATUS) AssignProperties_From_UrlRedirectAction_STATUS(source *storage.UrlRedirectAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, urlRedirectAction_Name_STATUS_Values)
		action.Name = &nameTemp
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlRedirectActionParameters_STATUS
		err := parameter.AssignProperties_From_UrlRedirectActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlRedirectActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlRedirectAction_STATUS populates the provided destination UrlRedirectAction_STATUS from our UrlRedirectAction_STATUS
func (action *UrlRedirectAction_STATUS) AssignProperties_To_UrlRedirectAction_STATUS(destination *storage.UrlRedirectAction_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter storage.UrlRedirectActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_UrlRedirectActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlRedirectActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type UrlRewriteAction struct {
	// +kubebuilder:validation:Required
	// Name: The name of the action for the delivery rule.
	Name *UrlRewriteAction_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the action.
	Parameters *UrlRewriteActionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &UrlRewriteAction{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (action *UrlRewriteAction) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if action == nil {
		return nil, nil
	}
	result := &arm.UrlRewriteAction{}

	// Set property "Name":
	if action.Name != nil {
		var temp arm.UrlRewriteAction_Name
		var temp1 string
		temp1 = string(*action.Name)
		temp = arm.UrlRewriteAction_Name(temp1)
		result.Name = temp
	}

	// Set property "Parameters":
	if action.Parameters != nil {
		parameters_ARM, err := (*action.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*arm.UrlRewriteActionParameters)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *UrlRewriteAction) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UrlRewriteAction{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *UrlRewriteAction) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UrlRewriteAction)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UrlRewriteAction, got %T", armInput)
	}

	// Set property "Name":
	var temp UrlRewriteAction_Name
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = UrlRewriteAction_Name(temp1)
	action.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 UrlRewriteActionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_UrlRewriteAction populates our UrlRewriteAction from the provided source UrlRewriteAction
func (action *UrlRewriteAction) AssignProperties_From_UrlRewriteAction(source *storage.UrlRewriteAction) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, urlRewriteAction_Name_Values)
		action.Name = &nameTemp
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlRewriteActionParameters
		err := parameter.AssignProperties_From_UrlRewriteActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlRewriteActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlRewriteAction populates the provided destination UrlRewriteAction from our UrlRewriteAction
func (action *UrlRewriteAction) AssignProperties_To_UrlRewriteAction(destination *storage.UrlRewriteAction) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter storage.UrlRewriteActionParameters
		err := action.Parameters.AssignProperties_To_UrlRewriteActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlRewriteActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_UrlRewriteAction_STATUS populates our UrlRewriteAction from the provided source UrlRewriteAction_STATUS
func (action *UrlRewriteAction) Initialize_From_UrlRewriteAction_STATUS(source *UrlRewriteAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), urlRewriteAction_Name_Values)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlRewriteActionParameters
		err := parameter.Initialize_From_UrlRewriteActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_UrlRewriteActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

type UrlRewriteAction_STATUS struct {
	// Name: The name of the action for the delivery rule.
	Name *UrlRewriteAction_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the action.
	Parameters *UrlRewriteActionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &UrlRewriteAction_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *UrlRewriteAction_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UrlRewriteAction_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *UrlRewriteAction_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UrlRewriteAction_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UrlRewriteAction_STATUS, got %T", armInput)
	}

	// Set property "Name":
	var temp UrlRewriteAction_Name_STATUS
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = UrlRewriteAction_Name_STATUS(temp1)
	action.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 UrlRewriteActionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_UrlRewriteAction_STATUS populates our UrlRewriteAction_STATUS from the provided source UrlRewriteAction_STATUS
func (action *UrlRewriteAction_STATUS) AssignProperties_From_UrlRewriteAction_STATUS(source *storage.UrlRewriteAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, urlRewriteAction_Name_STATUS_Values)
		action.Name = &nameTemp
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlRewriteActionParameters_STATUS
		err := parameter.AssignProperties_From_UrlRewriteActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlRewriteActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlRewriteAction_STATUS populates the provided destination UrlRewriteAction_STATUS from our UrlRewriteAction_STATUS
func (action *UrlRewriteAction_STATUS) AssignProperties_To_UrlRewriteAction_STATUS(destination *storage.UrlRewriteAction_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter storage.UrlRewriteActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_UrlRewriteActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlRewriteActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type UrlSigningAction struct {
	// +kubebuilder:validation:Required
	// Name: The name of the action for the delivery rule.
	Name *UrlSigningAction_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the action.
	Parameters *UrlSigningActionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &UrlSigningAction{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (action *UrlSigningAction) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if action == nil {
		return nil, nil
	}
	result := &arm.UrlSigningAction{}

	// Set property "Name":
	if action.Name != nil {
		var temp arm.UrlSigningAction_Name
		var temp1 string
		temp1 = string(*action.Name)
		temp = arm.UrlSigningAction_Name(temp1)
		result.Name = temp
	}

	// Set property "Parameters":
	if action.Parameters != nil {
		parameters_ARM, err := (*action.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*arm.UrlSigningActionParameters)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *UrlSigningAction) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UrlSigningAction{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *UrlSigningAction) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UrlSigningAction)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UrlSigningAction, got %T", armInput)
	}

	// Set property "Name":
	var temp UrlSigningAction_Name
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = UrlSigningAction_Name(temp1)
	action.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 UrlSigningActionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_UrlSigningAction populates our UrlSigningAction from the provided source UrlSigningAction
func (action *UrlSigningAction) AssignProperties_From_UrlSigningAction(source *storage.UrlSigningAction) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, urlSigningAction_Name_Values)
		action.Name = &nameTemp
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlSigningActionParameters
		err := parameter.AssignProperties_From_UrlSigningActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlSigningActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlSigningAction populates the provided destination UrlSigningAction from our UrlSigningAction
func (action *UrlSigningAction) AssignProperties_To_UrlSigningAction(destination *storage.UrlSigningAction) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter storage.UrlSigningActionParameters
		err := action.Parameters.AssignProperties_To_UrlSigningActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlSigningActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_UrlSigningAction_STATUS populates our UrlSigningAction from the provided source UrlSigningAction_STATUS
func (action *UrlSigningAction) Initialize_From_UrlSigningAction_STATUS(source *UrlSigningAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), urlSigningAction_Name_Values)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlSigningActionParameters
		err := parameter.Initialize_From_UrlSigningActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_UrlSigningActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

type UrlSigningAction_STATUS struct {
	// Name: The name of the action for the delivery rule.
	Name *UrlSigningAction_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the action.
	Parameters *UrlSigningActionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &UrlSigningAction_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *UrlSigningAction_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UrlSigningAction_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *UrlSigningAction_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UrlSigningAction_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UrlSigningAction_STATUS, got %T", armInput)
	}

	// Set property "Name":
	var temp UrlSigningAction_Name_STATUS
	var temp1 string
	temp1 = string(typedInput.Name)
	temp = UrlSigningAction_Name_STATUS(temp1)
	action.Name = &temp

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 UrlSigningActionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_UrlSigningAction_STATUS populates our UrlSigningAction_STATUS from the provided source UrlSigningAction_STATUS
func (action *UrlSigningAction_STATUS) AssignProperties_From_UrlSigningAction_STATUS(source *storage.UrlSigningAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, urlSigningAction_Name_STATUS_Values)
		action.Name = &nameTemp
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlSigningActionParameters_STATUS
		err := parameter.AssignProperties_From_UrlSigningActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlSigningActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlSigningAction_STATUS populates the provided destination UrlSigningAction_STATUS from our UrlSigningAction_STATUS
func (action *UrlSigningAction_STATUS) AssignProperties_To_UrlSigningAction_STATUS(destination *storage.UrlSigningAction_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter storage.UrlSigningActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_UrlSigningActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlSigningActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for the cache expiration action.
type CacheExpirationActionParameters struct {
	// +kubebuilder:validation:Required
	// CacheBehavior: Caching behavior for the requests
	CacheBehavior *CacheExpirationActionParameters_CacheBehavior `json:"cacheBehavior,omitempty"`

	// CacheDuration: The duration for which the content needs to be cached. Allowed format is [d.]hh:mm:ss
	CacheDuration *string `json:"cacheDuration,omitempty"`

	// +kubebuilder:validation:Required
	// CacheType: The level at which the content needs to be cached.
	CacheType *CacheExpirationActionParameters_CacheType `json:"cacheType,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *CacheExpirationActionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &CacheExpirationActionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *CacheExpirationActionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.CacheExpirationActionParameters{}

	// Set property "CacheBehavior":
	if parameters.CacheBehavior != nil {
		var temp string
		temp = string(*parameters.CacheBehavior)
		cacheBehavior := arm.CacheExpirationActionParameters_CacheBehavior(temp)
		result.CacheBehavior = &cacheBehavior
	}

	// Set property "CacheDuration":
	if parameters.CacheDuration != nil {
		cacheDuration := *parameters.CacheDuration
		result.CacheDuration = &cacheDuration
	}

	// Set property "CacheType":
	if parameters.CacheType != nil {
		var temp string
		temp = string(*parameters.CacheType)
		cacheType := arm.CacheExpirationActionParameters_CacheType(temp)
		result.CacheType = &cacheType
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		var temp string
		temp = string(*parameters.TypeName)
		typeName := arm.CacheExpirationActionParameters_TypeName(temp)
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *CacheExpirationActionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CacheExpirationActionParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *CacheExpirationActionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CacheExpirationActionParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CacheExpirationActionParameters, got %T", armInput)
	}

	// Set property "CacheBehavior":
	if typedInput.CacheBehavior != nil {
		var temp string
		temp = string(*typedInput.CacheBehavior)
		cacheBehavior := CacheExpirationActionParameters_CacheBehavior(temp)
		parameters.CacheBehavior = &cacheBehavior
	}

	// Set property "CacheDuration":
	if typedInput.CacheDuration != nil {
		cacheDuration := *typedInput.CacheDuration
		parameters.CacheDuration = &cacheDuration
	}

	// Set property "CacheType":
	if typedInput.CacheType != nil {
		var temp string
		temp = string(*typedInput.CacheType)
		cacheType := CacheExpirationActionParameters_CacheType(temp)
		parameters.CacheType = &cacheType
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := CacheExpirationActionParameters_TypeName(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_CacheExpirationActionParameters populates our CacheExpirationActionParameters from the provided source CacheExpirationActionParameters
func (parameters *CacheExpirationActionParameters) AssignProperties_From_CacheExpirationActionParameters(source *storage.CacheExpirationActionParameters) error {

	// CacheBehavior
	if source.CacheBehavior != nil {
		cacheBehavior := *source.CacheBehavior
		cacheBehaviorTemp := genruntime.ToEnum(cacheBehavior, cacheExpirationActionParameters_CacheBehavior_Values)
		parameters.CacheBehavior = &cacheBehaviorTemp
	} else {
		parameters.CacheBehavior = nil
	}

	// CacheDuration
	parameters.CacheDuration = genruntime.ClonePointerToString(source.CacheDuration)

	// CacheType
	if source.CacheType != nil {
		cacheType := *source.CacheType
		cacheTypeTemp := genruntime.ToEnum(cacheType, cacheExpirationActionParameters_CacheType_Values)
		parameters.CacheType = &cacheTypeTemp
	} else {
		parameters.CacheType = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, cacheExpirationActionParameters_TypeName_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CacheExpirationActionParameters populates the provided destination CacheExpirationActionParameters from our CacheExpirationActionParameters
func (parameters *CacheExpirationActionParameters) AssignProperties_To_CacheExpirationActionParameters(destination *storage.CacheExpirationActionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CacheBehavior
	if parameters.CacheBehavior != nil {
		cacheBehavior := string(*parameters.CacheBehavior)
		destination.CacheBehavior = &cacheBehavior
	} else {
		destination.CacheBehavior = nil
	}

	// CacheDuration
	destination.CacheDuration = genruntime.ClonePointerToString(parameters.CacheDuration)

	// CacheType
	if parameters.CacheType != nil {
		cacheType := string(*parameters.CacheType)
		destination.CacheType = &cacheType
	} else {
		destination.CacheType = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_CacheExpirationActionParameters_STATUS populates our CacheExpirationActionParameters from the provided source CacheExpirationActionParameters_STATUS
func (parameters *CacheExpirationActionParameters) Initialize_From_CacheExpirationActionParameters_STATUS(source *CacheExpirationActionParameters_STATUS) error {

	// CacheBehavior
	if source.CacheBehavior != nil {
		cacheBehavior := genruntime.ToEnum(string(*source.CacheBehavior), cacheExpirationActionParameters_CacheBehavior_Values)
		parameters.CacheBehavior = &cacheBehavior
	} else {
		parameters.CacheBehavior = nil
	}

	// CacheDuration
	parameters.CacheDuration = genruntime.ClonePointerToString(source.CacheDuration)

	// CacheType
	if source.CacheType != nil {
		cacheType := genruntime.ToEnum(string(*source.CacheType), cacheExpirationActionParameters_CacheType_Values)
		parameters.CacheType = &cacheType
	} else {
		parameters.CacheType = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := genruntime.ToEnum(string(*source.TypeName), cacheExpirationActionParameters_TypeName_Values)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for the cache expiration action.
type CacheExpirationActionParameters_STATUS struct {
	// CacheBehavior: Caching behavior for the requests
	CacheBehavior *CacheExpirationActionParameters_CacheBehavior_STATUS `json:"cacheBehavior,omitempty"`

	// CacheDuration: The duration for which the content needs to be cached. Allowed format is [d.]hh:mm:ss
	CacheDuration *string `json:"cacheDuration,omitempty"`

	// CacheType: The level at which the content needs to be cached.
	CacheType *CacheExpirationActionParameters_CacheType_STATUS `json:"cacheType,omitempty"`
	TypeName  *CacheExpirationActionParameters_TypeName_STATUS  `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &CacheExpirationActionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *CacheExpirationActionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CacheExpirationActionParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *CacheExpirationActionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CacheExpirationActionParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CacheExpirationActionParameters_STATUS, got %T", armInput)
	}

	// Set property "CacheBehavior":
	if typedInput.CacheBehavior != nil {
		var temp string
		temp = string(*typedInput.CacheBehavior)
		cacheBehavior := CacheExpirationActionParameters_CacheBehavior_STATUS(temp)
		parameters.CacheBehavior = &cacheBehavior
	}

	// Set property "CacheDuration":
	if typedInput.CacheDuration != nil {
		cacheDuration := *typedInput.CacheDuration
		parameters.CacheDuration = &cacheDuration
	}

	// Set property "CacheType":
	if typedInput.CacheType != nil {
		var temp string
		temp = string(*typedInput.CacheType)
		cacheType := CacheExpirationActionParameters_CacheType_STATUS(temp)
		parameters.CacheType = &cacheType
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := CacheExpirationActionParameters_TypeName_STATUS(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_CacheExpirationActionParameters_STATUS populates our CacheExpirationActionParameters_STATUS from the provided source CacheExpirationActionParameters_STATUS
func (parameters *CacheExpirationActionParameters_STATUS) AssignProperties_From_CacheExpirationActionParameters_STATUS(source *storage.CacheExpirationActionParameters_STATUS) error {

	// CacheBehavior
	if source.CacheBehavior != nil {
		cacheBehavior := *source.CacheBehavior
		cacheBehaviorTemp := genruntime.ToEnum(cacheBehavior, cacheExpirationActionParameters_CacheBehavior_STATUS_Values)
		parameters.CacheBehavior = &cacheBehaviorTemp
	} else {
		parameters.CacheBehavior = nil
	}

	// CacheDuration
	parameters.CacheDuration = genruntime.ClonePointerToString(source.CacheDuration)

	// CacheType
	if source.CacheType != nil {
		cacheType := *source.CacheType
		cacheTypeTemp := genruntime.ToEnum(cacheType, cacheExpirationActionParameters_CacheType_STATUS_Values)
		parameters.CacheType = &cacheTypeTemp
	} else {
		parameters.CacheType = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, cacheExpirationActionParameters_TypeName_STATUS_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CacheExpirationActionParameters_STATUS populates the provided destination CacheExpirationActionParameters_STATUS from our CacheExpirationActionParameters_STATUS
func (parameters *CacheExpirationActionParameters_STATUS) AssignProperties_To_CacheExpirationActionParameters_STATUS(destination *storage.CacheExpirationActionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CacheBehavior
	if parameters.CacheBehavior != nil {
		cacheBehavior := string(*parameters.CacheBehavior)
		destination.CacheBehavior = &cacheBehavior
	} else {
		destination.CacheBehavior = nil
	}

	// CacheDuration
	destination.CacheDuration = genruntime.ClonePointerToString(parameters.CacheDuration)

	// CacheType
	if parameters.CacheType != nil {
		cacheType := string(*parameters.CacheType)
		destination.CacheType = &cacheType
	} else {
		destination.CacheType = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for the cache-key query string action.
type CacheKeyQueryStringActionParameters struct {
	// QueryParameters: query parameters to include or exclude (comma separated).
	QueryParameters *string `json:"queryParameters,omitempty"`

	// +kubebuilder:validation:Required
	// QueryStringBehavior: Caching behavior for the requests
	QueryStringBehavior *CacheKeyQueryStringActionParameters_QueryStringBehavior `json:"queryStringBehavior,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *CacheKeyQueryStringActionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &CacheKeyQueryStringActionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *CacheKeyQueryStringActionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.CacheKeyQueryStringActionParameters{}

	// Set property "QueryParameters":
	if parameters.QueryParameters != nil {
		queryParameters := *parameters.QueryParameters
		result.QueryParameters = &queryParameters
	}

	// Set property "QueryStringBehavior":
	if parameters.QueryStringBehavior != nil {
		var temp string
		temp = string(*parameters.QueryStringBehavior)
		queryStringBehavior := arm.CacheKeyQueryStringActionParameters_QueryStringBehavior(temp)
		result.QueryStringBehavior = &queryStringBehavior
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		var temp string
		temp = string(*parameters.TypeName)
		typeName := arm.CacheKeyQueryStringActionParameters_TypeName(temp)
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *CacheKeyQueryStringActionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CacheKeyQueryStringActionParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *CacheKeyQueryStringActionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CacheKeyQueryStringActionParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CacheKeyQueryStringActionParameters, got %T", armInput)
	}

	// Set property "QueryParameters":
	if typedInput.QueryParameters != nil {
		queryParameters := *typedInput.QueryParameters
		parameters.QueryParameters = &queryParameters
	}

	// Set property "QueryStringBehavior":
	if typedInput.QueryStringBehavior != nil {
		var temp string
		temp = string(*typedInput.QueryStringBehavior)
		queryStringBehavior := CacheKeyQueryStringActionParameters_QueryStringBehavior(temp)
		parameters.QueryStringBehavior = &queryStringBehavior
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := CacheKeyQueryStringActionParameters_TypeName(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_CacheKeyQueryStringActionParameters populates our CacheKeyQueryStringActionParameters from the provided source CacheKeyQueryStringActionParameters
func (parameters *CacheKeyQueryStringActionParameters) AssignProperties_From_CacheKeyQueryStringActionParameters(source *storage.CacheKeyQueryStringActionParameters) error {

	// QueryParameters
	parameters.QueryParameters = genruntime.ClonePointerToString(source.QueryParameters)

	// QueryStringBehavior
	if source.QueryStringBehavior != nil {
		queryStringBehavior := *source.QueryStringBehavior
		queryStringBehaviorTemp := genruntime.ToEnum(queryStringBehavior, cacheKeyQueryStringActionParameters_QueryStringBehavior_Values)
		parameters.QueryStringBehavior = &queryStringBehaviorTemp
	} else {
		parameters.QueryStringBehavior = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, cacheKeyQueryStringActionParameters_TypeName_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CacheKeyQueryStringActionParameters populates the provided destination CacheKeyQueryStringActionParameters from our CacheKeyQueryStringActionParameters
func (parameters *CacheKeyQueryStringActionParameters) AssignProperties_To_CacheKeyQueryStringActionParameters(destination *storage.CacheKeyQueryStringActionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// QueryParameters
	destination.QueryParameters = genruntime.ClonePointerToString(parameters.QueryParameters)

	// QueryStringBehavior
	if parameters.QueryStringBehavior != nil {
		queryStringBehavior := string(*parameters.QueryStringBehavior)
		destination.QueryStringBehavior = &queryStringBehavior
	} else {
		destination.QueryStringBehavior = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_CacheKeyQueryStringActionParameters_STATUS populates our CacheKeyQueryStringActionParameters from the provided source CacheKeyQueryStringActionParameters_STATUS
func (parameters *CacheKeyQueryStringActionParameters) Initialize_From_CacheKeyQueryStringActionParameters_STATUS(source *CacheKeyQueryStringActionParameters_STATUS) error {

	// QueryParameters
	parameters.QueryParameters = genruntime.ClonePointerToString(source.QueryParameters)

	// QueryStringBehavior
	if source.QueryStringBehavior != nil {
		queryStringBehavior := genruntime.ToEnum(string(*source.QueryStringBehavior), cacheKeyQueryStringActionParameters_QueryStringBehavior_Values)
		parameters.QueryStringBehavior = &queryStringBehavior
	} else {
		parameters.QueryStringBehavior = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := genruntime.ToEnum(string(*source.TypeName), cacheKeyQueryStringActionParameters_TypeName_Values)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for the cache-key query string action.
type CacheKeyQueryStringActionParameters_STATUS struct {
	// QueryParameters: query parameters to include or exclude (comma separated).
	QueryParameters *string `json:"queryParameters,omitempty"`

	// QueryStringBehavior: Caching behavior for the requests
	QueryStringBehavior *CacheKeyQueryStringActionParameters_QueryStringBehavior_STATUS `json:"queryStringBehavior,omitempty"`
	TypeName            *CacheKeyQueryStringActionParameters_TypeName_STATUS            `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &CacheKeyQueryStringActionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *CacheKeyQueryStringActionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CacheKeyQueryStringActionParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *CacheKeyQueryStringActionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CacheKeyQueryStringActionParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CacheKeyQueryStringActionParameters_STATUS, got %T", armInput)
	}

	// Set property "QueryParameters":
	if typedInput.QueryParameters != nil {
		queryParameters := *typedInput.QueryParameters
		parameters.QueryParameters = &queryParameters
	}

	// Set property "QueryStringBehavior":
	if typedInput.QueryStringBehavior != nil {
		var temp string
		temp = string(*typedInput.QueryStringBehavior)
		queryStringBehavior := CacheKeyQueryStringActionParameters_QueryStringBehavior_STATUS(temp)
		parameters.QueryStringBehavior = &queryStringBehavior
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := CacheKeyQueryStringActionParameters_TypeName_STATUS(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_CacheKeyQueryStringActionParameters_STATUS populates our CacheKeyQueryStringActionParameters_STATUS from the provided source CacheKeyQueryStringActionParameters_STATUS
func (parameters *CacheKeyQueryStringActionParameters_STATUS) AssignProperties_From_CacheKeyQueryStringActionParameters_STATUS(source *storage.CacheKeyQueryStringActionParameters_STATUS) error {

	// QueryParameters
	parameters.QueryParameters = genruntime.ClonePointerToString(source.QueryParameters)

	// QueryStringBehavior
	if source.QueryStringBehavior != nil {
		queryStringBehavior := *source.QueryStringBehavior
		queryStringBehaviorTemp := genruntime.ToEnum(queryStringBehavior, cacheKeyQueryStringActionParameters_QueryStringBehavior_STATUS_Values)
		parameters.QueryStringBehavior = &queryStringBehaviorTemp
	} else {
		parameters.QueryStringBehavior = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, cacheKeyQueryStringActionParameters_TypeName_STATUS_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CacheKeyQueryStringActionParameters_STATUS populates the provided destination CacheKeyQueryStringActionParameters_STATUS from our CacheKeyQueryStringActionParameters_STATUS
func (parameters *CacheKeyQueryStringActionParameters_STATUS) AssignProperties_To_CacheKeyQueryStringActionParameters_STATUS(destination *storage.CacheKeyQueryStringActionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// QueryParameters
	destination.QueryParameters = genruntime.ClonePointerToString(parameters.QueryParameters)

	// QueryStringBehavior
	if parameters.QueryStringBehavior != nil {
		queryStringBehavior := string(*parameters.QueryStringBehavior)
		destination.QueryStringBehavior = &queryStringBehavior
	} else {
		destination.QueryStringBehavior = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for ClientPort match conditions
type ClientPortMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *ClientPortMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *ClientPortMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &ClientPortMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *ClientPortMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.ClientPortMatchConditionParameters{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		result.MatchValues = append(result.MatchValues, item)
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		var temp string
		temp = string(*parameters.Operator)
		operator := arm.ClientPortMatchConditionParameters_Operator(temp)
		result.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		var temp string
		temp = string(item)
		result.Transforms = append(result.Transforms, arm.Transform(temp))
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		var temp string
		temp = string(*parameters.TypeName)
		typeName := arm.ClientPortMatchConditionParameters_TypeName(temp)
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *ClientPortMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ClientPortMatchConditionParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *ClientPortMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ClientPortMatchConditionParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ClientPortMatchConditionParameters, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := ClientPortMatchConditionParameters_Operator(temp)
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := ClientPortMatchConditionParameters_TypeName(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_ClientPortMatchConditionParameters populates our ClientPortMatchConditionParameters from the provided source ClientPortMatchConditionParameters
func (parameters *ClientPortMatchConditionParameters) AssignProperties_From_ClientPortMatchConditionParameters(source *storage.ClientPortMatchConditionParameters) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, clientPortMatchConditionParameters_Operator_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, clientPortMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ClientPortMatchConditionParameters populates the provided destination ClientPortMatchConditionParameters from our ClientPortMatchConditionParameters
func (parameters *ClientPortMatchConditionParameters) AssignProperties_To_ClientPortMatchConditionParameters(destination *storage.ClientPortMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ClientPortMatchConditionParameters_STATUS populates our ClientPortMatchConditionParameters from the provided source ClientPortMatchConditionParameters_STATUS
func (parameters *ClientPortMatchConditionParameters) Initialize_From_ClientPortMatchConditionParameters_STATUS(source *ClientPortMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := genruntime.ToEnum(string(*source.Operator), clientPortMatchConditionParameters_Operator_Values)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := genruntime.ToEnum(string(transformItem), transform_Values)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := genruntime.ToEnum(string(*source.TypeName), clientPortMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for ClientPort match conditions
type ClientPortMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *ClientPortMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                                  `json:"transforms,omitempty"`
	TypeName   *ClientPortMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &ClientPortMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *ClientPortMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ClientPortMatchConditionParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *ClientPortMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ClientPortMatchConditionParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ClientPortMatchConditionParameters_STATUS, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := ClientPortMatchConditionParameters_Operator_STATUS(temp)
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform_STATUS(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := ClientPortMatchConditionParameters_TypeName_STATUS(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_ClientPortMatchConditionParameters_STATUS populates our ClientPortMatchConditionParameters_STATUS from the provided source ClientPortMatchConditionParameters_STATUS
func (parameters *ClientPortMatchConditionParameters_STATUS) AssignProperties_From_ClientPortMatchConditionParameters_STATUS(source *storage.ClientPortMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, clientPortMatchConditionParameters_Operator_STATUS_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_STATUS_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, clientPortMatchConditionParameters_TypeName_STATUS_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ClientPortMatchConditionParameters_STATUS populates the provided destination ClientPortMatchConditionParameters_STATUS from our ClientPortMatchConditionParameters_STATUS
func (parameters *ClientPortMatchConditionParameters_STATUS) AssignProperties_To_ClientPortMatchConditionParameters_STATUS(destination *storage.ClientPortMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for Cookies match conditions
type CookiesMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *CookiesMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Selector: Name of Cookies to be matched
	Selector *string `json:"selector,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *CookiesMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &CookiesMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *CookiesMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.CookiesMatchConditionParameters{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		result.MatchValues = append(result.MatchValues, item)
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		var temp string
		temp = string(*parameters.Operator)
		operator := arm.CookiesMatchConditionParameters_Operator(temp)
		result.Operator = &operator
	}

	// Set property "Selector":
	if parameters.Selector != nil {
		selector := *parameters.Selector
		result.Selector = &selector
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		var temp string
		temp = string(item)
		result.Transforms = append(result.Transforms, arm.Transform(temp))
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		var temp string
		temp = string(*parameters.TypeName)
		typeName := arm.CookiesMatchConditionParameters_TypeName(temp)
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *CookiesMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CookiesMatchConditionParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *CookiesMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CookiesMatchConditionParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CookiesMatchConditionParameters, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := CookiesMatchConditionParameters_Operator(temp)
		parameters.Operator = &operator
	}

	// Set property "Selector":
	if typedInput.Selector != nil {
		selector := *typedInput.Selector
		parameters.Selector = &selector
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := CookiesMatchConditionParameters_TypeName(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_CookiesMatchConditionParameters populates our CookiesMatchConditionParameters from the provided source CookiesMatchConditionParameters
func (parameters *CookiesMatchConditionParameters) AssignProperties_From_CookiesMatchConditionParameters(source *storage.CookiesMatchConditionParameters) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, cookiesMatchConditionParameters_Operator_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Selector
	parameters.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, cookiesMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CookiesMatchConditionParameters populates the provided destination CookiesMatchConditionParameters from our CookiesMatchConditionParameters
func (parameters *CookiesMatchConditionParameters) AssignProperties_To_CookiesMatchConditionParameters(destination *storage.CookiesMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Selector
	destination.Selector = genruntime.ClonePointerToString(parameters.Selector)

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_CookiesMatchConditionParameters_STATUS populates our CookiesMatchConditionParameters from the provided source CookiesMatchConditionParameters_STATUS
func (parameters *CookiesMatchConditionParameters) Initialize_From_CookiesMatchConditionParameters_STATUS(source *CookiesMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := genruntime.ToEnum(string(*source.Operator), cookiesMatchConditionParameters_Operator_Values)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Selector
	parameters.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := genruntime.ToEnum(string(transformItem), transform_Values)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := genruntime.ToEnum(string(*source.TypeName), cookiesMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for Cookies match conditions
type CookiesMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *CookiesMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Selector: Name of Cookies to be matched
	Selector *string `json:"selector,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                               `json:"transforms,omitempty"`
	TypeName   *CookiesMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &CookiesMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *CookiesMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CookiesMatchConditionParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *CookiesMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CookiesMatchConditionParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CookiesMatchConditionParameters_STATUS, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := CookiesMatchConditionParameters_Operator_STATUS(temp)
		parameters.Operator = &operator
	}

	// Set property "Selector":
	if typedInput.Selector != nil {
		selector := *typedInput.Selector
		parameters.Selector = &selector
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform_STATUS(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := CookiesMatchConditionParameters_TypeName_STATUS(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_CookiesMatchConditionParameters_STATUS populates our CookiesMatchConditionParameters_STATUS from the provided source CookiesMatchConditionParameters_STATUS
func (parameters *CookiesMatchConditionParameters_STATUS) AssignProperties_From_CookiesMatchConditionParameters_STATUS(source *storage.CookiesMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, cookiesMatchConditionParameters_Operator_STATUS_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Selector
	parameters.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_STATUS_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, cookiesMatchConditionParameters_TypeName_STATUS_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CookiesMatchConditionParameters_STATUS populates the provided destination CookiesMatchConditionParameters_STATUS from our CookiesMatchConditionParameters_STATUS
func (parameters *CookiesMatchConditionParameters_STATUS) AssignProperties_To_CookiesMatchConditionParameters_STATUS(destination *storage.CookiesMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Selector
	destination.Selector = genruntime.ClonePointerToString(parameters.Selector)

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"CacheExpiration"}
type DeliveryRuleCacheExpirationAction_Name string

const DeliveryRuleCacheExpirationAction_Name_CacheExpiration = DeliveryRuleCacheExpirationAction_Name("CacheExpiration")

// Mapping from string to DeliveryRuleCacheExpirationAction_Name
var deliveryRuleCacheExpirationAction_Name_Values = map[string]DeliveryRuleCacheExpirationAction_Name{
	"cacheexpiration": DeliveryRuleCacheExpirationAction_Name_CacheExpiration,
}

type DeliveryRuleCacheExpirationAction_Name_STATUS string

const DeliveryRuleCacheExpirationAction_Name_STATUS_CacheExpiration = DeliveryRuleCacheExpirationAction_Name_STATUS("CacheExpiration")

// Mapping from string to DeliveryRuleCacheExpirationAction_Name_STATUS
var deliveryRuleCacheExpirationAction_Name_STATUS_Values = map[string]DeliveryRuleCacheExpirationAction_Name_STATUS{
	"cacheexpiration": DeliveryRuleCacheExpirationAction_Name_STATUS_CacheExpiration,
}

// +kubebuilder:validation:Enum={"CacheKeyQueryString"}
type DeliveryRuleCacheKeyQueryStringAction_Name string

const DeliveryRuleCacheKeyQueryStringAction_Name_CacheKeyQueryString = DeliveryRuleCacheKeyQueryStringAction_Name("CacheKeyQueryString")

// Mapping from string to DeliveryRuleCacheKeyQueryStringAction_Name
var deliveryRuleCacheKeyQueryStringAction_Name_Values = map[string]DeliveryRuleCacheKeyQueryStringAction_Name{
	"cachekeyquerystring": DeliveryRuleCacheKeyQueryStringAction_Name_CacheKeyQueryString,
}

type DeliveryRuleCacheKeyQueryStringAction_Name_STATUS string

const DeliveryRuleCacheKeyQueryStringAction_Name_STATUS_CacheKeyQueryString = DeliveryRuleCacheKeyQueryStringAction_Name_STATUS("CacheKeyQueryString")

// Mapping from string to DeliveryRuleCacheKeyQueryStringAction_Name_STATUS
var deliveryRuleCacheKeyQueryStringAction_Name_STATUS_Values = map[string]DeliveryRuleCacheKeyQueryStringAction_Name_STATUS{
	"cachekeyquerystring": DeliveryRuleCacheKeyQueryStringAction_Name_STATUS_CacheKeyQueryString,
}

// +kubebuilder:validation:Enum={"ClientPort"}
type DeliveryRuleClientPortCondition_Name string

const DeliveryRuleClientPortCondition_Name_ClientPort = DeliveryRuleClientPortCondition_Name("ClientPort")

// Mapping from string to DeliveryRuleClientPortCondition_Name
var deliveryRuleClientPortCondition_Name_Values = map[string]DeliveryRuleClientPortCondition_Name{
	"clientport": DeliveryRuleClientPortCondition_Name_ClientPort,
}

type DeliveryRuleClientPortCondition_Name_STATUS string

const DeliveryRuleClientPortCondition_Name_STATUS_ClientPort = DeliveryRuleClientPortCondition_Name_STATUS("ClientPort")

// Mapping from string to DeliveryRuleClientPortCondition_Name_STATUS
var deliveryRuleClientPortCondition_Name_STATUS_Values = map[string]DeliveryRuleClientPortCondition_Name_STATUS{
	"clientport": DeliveryRuleClientPortCondition_Name_STATUS_ClientPort,
}

// +kubebuilder:validation:Enum={"Cookies"}
type DeliveryRuleCookiesCondition_Name string

const DeliveryRuleCookiesCondition_Name_Cookies = DeliveryRuleCookiesCondition_Name("Cookies")

// Mapping from string to DeliveryRuleCookiesCondition_Name
var deliveryRuleCookiesCondition_Name_Values = map[string]DeliveryRuleCookiesCondition_Name{
	"cookies": DeliveryRuleCookiesCondition_Name_Cookies,
}

type DeliveryRuleCookiesCondition_Name_STATUS string

const DeliveryRuleCookiesCondition_Name_STATUS_Cookies = DeliveryRuleCookiesCondition_Name_STATUS("Cookies")

// Mapping from string to DeliveryRuleCookiesCondition_Name_STATUS
var deliveryRuleCookiesCondition_Name_STATUS_Values = map[string]DeliveryRuleCookiesCondition_Name_STATUS{
	"cookies": DeliveryRuleCookiesCondition_Name_STATUS_Cookies,
}

// +kubebuilder:validation:Enum={"HostName"}
type DeliveryRuleHostNameCondition_Name string

const DeliveryRuleHostNameCondition_Name_HostName = DeliveryRuleHostNameCondition_Name("HostName")

// Mapping from string to DeliveryRuleHostNameCondition_Name
var deliveryRuleHostNameCondition_Name_Values = map[string]DeliveryRuleHostNameCondition_Name{
	"hostname": DeliveryRuleHostNameCondition_Name_HostName,
}

type DeliveryRuleHostNameCondition_Name_STATUS string

const DeliveryRuleHostNameCondition_Name_STATUS_HostName = DeliveryRuleHostNameCondition_Name_STATUS("HostName")

// Mapping from string to DeliveryRuleHostNameCondition_Name_STATUS
var deliveryRuleHostNameCondition_Name_STATUS_Values = map[string]DeliveryRuleHostNameCondition_Name_STATUS{
	"hostname": DeliveryRuleHostNameCondition_Name_STATUS_HostName,
}

// +kubebuilder:validation:Enum={"HttpVersion"}
type DeliveryRuleHttpVersionCondition_Name string

const DeliveryRuleHttpVersionCondition_Name_HttpVersion = DeliveryRuleHttpVersionCondition_Name("HttpVersion")

// Mapping from string to DeliveryRuleHttpVersionCondition_Name
var deliveryRuleHttpVersionCondition_Name_Values = map[string]DeliveryRuleHttpVersionCondition_Name{
	"httpversion": DeliveryRuleHttpVersionCondition_Name_HttpVersion,
}

type DeliveryRuleHttpVersionCondition_Name_STATUS string

const DeliveryRuleHttpVersionCondition_Name_STATUS_HttpVersion = DeliveryRuleHttpVersionCondition_Name_STATUS("HttpVersion")

// Mapping from string to DeliveryRuleHttpVersionCondition_Name_STATUS
var deliveryRuleHttpVersionCondition_Name_STATUS_Values = map[string]DeliveryRuleHttpVersionCondition_Name_STATUS{
	"httpversion": DeliveryRuleHttpVersionCondition_Name_STATUS_HttpVersion,
}

// +kubebuilder:validation:Enum={"IsDevice"}
type DeliveryRuleIsDeviceCondition_Name string

const DeliveryRuleIsDeviceCondition_Name_IsDevice = DeliveryRuleIsDeviceCondition_Name("IsDevice")

// Mapping from string to DeliveryRuleIsDeviceCondition_Name
var deliveryRuleIsDeviceCondition_Name_Values = map[string]DeliveryRuleIsDeviceCondition_Name{
	"isdevice": DeliveryRuleIsDeviceCondition_Name_IsDevice,
}

type DeliveryRuleIsDeviceCondition_Name_STATUS string

const DeliveryRuleIsDeviceCondition_Name_STATUS_IsDevice = DeliveryRuleIsDeviceCondition_Name_STATUS("IsDevice")

// Mapping from string to DeliveryRuleIsDeviceCondition_Name_STATUS
var deliveryRuleIsDeviceCondition_Name_STATUS_Values = map[string]DeliveryRuleIsDeviceCondition_Name_STATUS{
	"isdevice": DeliveryRuleIsDeviceCondition_Name_STATUS_IsDevice,
}

// +kubebuilder:validation:Enum={"PostArgs"}
type DeliveryRulePostArgsCondition_Name string

const DeliveryRulePostArgsCondition_Name_PostArgs = DeliveryRulePostArgsCondition_Name("PostArgs")

// Mapping from string to DeliveryRulePostArgsCondition_Name
var deliveryRulePostArgsCondition_Name_Values = map[string]DeliveryRulePostArgsCondition_Name{
	"postargs": DeliveryRulePostArgsCondition_Name_PostArgs,
}

type DeliveryRulePostArgsCondition_Name_STATUS string

const DeliveryRulePostArgsCondition_Name_STATUS_PostArgs = DeliveryRulePostArgsCondition_Name_STATUS("PostArgs")

// Mapping from string to DeliveryRulePostArgsCondition_Name_STATUS
var deliveryRulePostArgsCondition_Name_STATUS_Values = map[string]DeliveryRulePostArgsCondition_Name_STATUS{
	"postargs": DeliveryRulePostArgsCondition_Name_STATUS_PostArgs,
}

// +kubebuilder:validation:Enum={"QueryString"}
type DeliveryRuleQueryStringCondition_Name string

const DeliveryRuleQueryStringCondition_Name_QueryString = DeliveryRuleQueryStringCondition_Name("QueryString")

// Mapping from string to DeliveryRuleQueryStringCondition_Name
var deliveryRuleQueryStringCondition_Name_Values = map[string]DeliveryRuleQueryStringCondition_Name{
	"querystring": DeliveryRuleQueryStringCondition_Name_QueryString,
}

type DeliveryRuleQueryStringCondition_Name_STATUS string

const DeliveryRuleQueryStringCondition_Name_STATUS_QueryString = DeliveryRuleQueryStringCondition_Name_STATUS("QueryString")

// Mapping from string to DeliveryRuleQueryStringCondition_Name_STATUS
var deliveryRuleQueryStringCondition_Name_STATUS_Values = map[string]DeliveryRuleQueryStringCondition_Name_STATUS{
	"querystring": DeliveryRuleQueryStringCondition_Name_STATUS_QueryString,
}

// +kubebuilder:validation:Enum={"RemoteAddress"}
type DeliveryRuleRemoteAddressCondition_Name string

const DeliveryRuleRemoteAddressCondition_Name_RemoteAddress = DeliveryRuleRemoteAddressCondition_Name("RemoteAddress")

// Mapping from string to DeliveryRuleRemoteAddressCondition_Name
var deliveryRuleRemoteAddressCondition_Name_Values = map[string]DeliveryRuleRemoteAddressCondition_Name{
	"remoteaddress": DeliveryRuleRemoteAddressCondition_Name_RemoteAddress,
}

type DeliveryRuleRemoteAddressCondition_Name_STATUS string

const DeliveryRuleRemoteAddressCondition_Name_STATUS_RemoteAddress = DeliveryRuleRemoteAddressCondition_Name_STATUS("RemoteAddress")

// Mapping from string to DeliveryRuleRemoteAddressCondition_Name_STATUS
var deliveryRuleRemoteAddressCondition_Name_STATUS_Values = map[string]DeliveryRuleRemoteAddressCondition_Name_STATUS{
	"remoteaddress": DeliveryRuleRemoteAddressCondition_Name_STATUS_RemoteAddress,
}

// +kubebuilder:validation:Enum={"RequestBody"}
type DeliveryRuleRequestBodyCondition_Name string

const DeliveryRuleRequestBodyCondition_Name_RequestBody = DeliveryRuleRequestBodyCondition_Name("RequestBody")

// Mapping from string to DeliveryRuleRequestBodyCondition_Name
var deliveryRuleRequestBodyCondition_Name_Values = map[string]DeliveryRuleRequestBodyCondition_Name{
	"requestbody": DeliveryRuleRequestBodyCondition_Name_RequestBody,
}

type DeliveryRuleRequestBodyCondition_Name_STATUS string

const DeliveryRuleRequestBodyCondition_Name_STATUS_RequestBody = DeliveryRuleRequestBodyCondition_Name_STATUS("RequestBody")

// Mapping from string to DeliveryRuleRequestBodyCondition_Name_STATUS
var deliveryRuleRequestBodyCondition_Name_STATUS_Values = map[string]DeliveryRuleRequestBodyCondition_Name_STATUS{
	"requestbody": DeliveryRuleRequestBodyCondition_Name_STATUS_RequestBody,
}

// +kubebuilder:validation:Enum={"ModifyRequestHeader"}
type DeliveryRuleRequestHeaderAction_Name string

const DeliveryRuleRequestHeaderAction_Name_ModifyRequestHeader = DeliveryRuleRequestHeaderAction_Name("ModifyRequestHeader")

// Mapping from string to DeliveryRuleRequestHeaderAction_Name
var deliveryRuleRequestHeaderAction_Name_Values = map[string]DeliveryRuleRequestHeaderAction_Name{
	"modifyrequestheader": DeliveryRuleRequestHeaderAction_Name_ModifyRequestHeader,
}

type DeliveryRuleRequestHeaderAction_Name_STATUS string

const DeliveryRuleRequestHeaderAction_Name_STATUS_ModifyRequestHeader = DeliveryRuleRequestHeaderAction_Name_STATUS("ModifyRequestHeader")

// Mapping from string to DeliveryRuleRequestHeaderAction_Name_STATUS
var deliveryRuleRequestHeaderAction_Name_STATUS_Values = map[string]DeliveryRuleRequestHeaderAction_Name_STATUS{
	"modifyrequestheader": DeliveryRuleRequestHeaderAction_Name_STATUS_ModifyRequestHeader,
}

// +kubebuilder:validation:Enum={"RequestHeader"}
type DeliveryRuleRequestHeaderCondition_Name string

const DeliveryRuleRequestHeaderCondition_Name_RequestHeader = DeliveryRuleRequestHeaderCondition_Name("RequestHeader")

// Mapping from string to DeliveryRuleRequestHeaderCondition_Name
var deliveryRuleRequestHeaderCondition_Name_Values = map[string]DeliveryRuleRequestHeaderCondition_Name{
	"requestheader": DeliveryRuleRequestHeaderCondition_Name_RequestHeader,
}

type DeliveryRuleRequestHeaderCondition_Name_STATUS string

const DeliveryRuleRequestHeaderCondition_Name_STATUS_RequestHeader = DeliveryRuleRequestHeaderCondition_Name_STATUS("RequestHeader")

// Mapping from string to DeliveryRuleRequestHeaderCondition_Name_STATUS
var deliveryRuleRequestHeaderCondition_Name_STATUS_Values = map[string]DeliveryRuleRequestHeaderCondition_Name_STATUS{
	"requestheader": DeliveryRuleRequestHeaderCondition_Name_STATUS_RequestHeader,
}

// +kubebuilder:validation:Enum={"RequestMethod"}
type DeliveryRuleRequestMethodCondition_Name string

const DeliveryRuleRequestMethodCondition_Name_RequestMethod = DeliveryRuleRequestMethodCondition_Name("RequestMethod")

// Mapping from string to DeliveryRuleRequestMethodCondition_Name
var deliveryRuleRequestMethodCondition_Name_Values = map[string]DeliveryRuleRequestMethodCondition_Name{
	"requestmethod": DeliveryRuleRequestMethodCondition_Name_RequestMethod,
}

type DeliveryRuleRequestMethodCondition_Name_STATUS string

const DeliveryRuleRequestMethodCondition_Name_STATUS_RequestMethod = DeliveryRuleRequestMethodCondition_Name_STATUS("RequestMethod")

// Mapping from string to DeliveryRuleRequestMethodCondition_Name_STATUS
var deliveryRuleRequestMethodCondition_Name_STATUS_Values = map[string]DeliveryRuleRequestMethodCondition_Name_STATUS{
	"requestmethod": DeliveryRuleRequestMethodCondition_Name_STATUS_RequestMethod,
}

// +kubebuilder:validation:Enum={"RequestScheme"}
type DeliveryRuleRequestSchemeCondition_Name string

const DeliveryRuleRequestSchemeCondition_Name_RequestScheme = DeliveryRuleRequestSchemeCondition_Name("RequestScheme")

// Mapping from string to DeliveryRuleRequestSchemeCondition_Name
var deliveryRuleRequestSchemeCondition_Name_Values = map[string]DeliveryRuleRequestSchemeCondition_Name{
	"requestscheme": DeliveryRuleRequestSchemeCondition_Name_RequestScheme,
}

type DeliveryRuleRequestSchemeCondition_Name_STATUS string

const DeliveryRuleRequestSchemeCondition_Name_STATUS_RequestScheme = DeliveryRuleRequestSchemeCondition_Name_STATUS("RequestScheme")

// Mapping from string to DeliveryRuleRequestSchemeCondition_Name_STATUS
var deliveryRuleRequestSchemeCondition_Name_STATUS_Values = map[string]DeliveryRuleRequestSchemeCondition_Name_STATUS{
	"requestscheme": DeliveryRuleRequestSchemeCondition_Name_STATUS_RequestScheme,
}

// +kubebuilder:validation:Enum={"RequestUri"}
type DeliveryRuleRequestUriCondition_Name string

const DeliveryRuleRequestUriCondition_Name_RequestUri = DeliveryRuleRequestUriCondition_Name("RequestUri")

// Mapping from string to DeliveryRuleRequestUriCondition_Name
var deliveryRuleRequestUriCondition_Name_Values = map[string]DeliveryRuleRequestUriCondition_Name{
	"requesturi": DeliveryRuleRequestUriCondition_Name_RequestUri,
}

type DeliveryRuleRequestUriCondition_Name_STATUS string

const DeliveryRuleRequestUriCondition_Name_STATUS_RequestUri = DeliveryRuleRequestUriCondition_Name_STATUS("RequestUri")

// Mapping from string to DeliveryRuleRequestUriCondition_Name_STATUS
var deliveryRuleRequestUriCondition_Name_STATUS_Values = map[string]DeliveryRuleRequestUriCondition_Name_STATUS{
	"requesturi": DeliveryRuleRequestUriCondition_Name_STATUS_RequestUri,
}

// +kubebuilder:validation:Enum={"ModifyResponseHeader"}
type DeliveryRuleResponseHeaderAction_Name string

const DeliveryRuleResponseHeaderAction_Name_ModifyResponseHeader = DeliveryRuleResponseHeaderAction_Name("ModifyResponseHeader")

// Mapping from string to DeliveryRuleResponseHeaderAction_Name
var deliveryRuleResponseHeaderAction_Name_Values = map[string]DeliveryRuleResponseHeaderAction_Name{
	"modifyresponseheader": DeliveryRuleResponseHeaderAction_Name_ModifyResponseHeader,
}

type DeliveryRuleResponseHeaderAction_Name_STATUS string

const DeliveryRuleResponseHeaderAction_Name_STATUS_ModifyResponseHeader = DeliveryRuleResponseHeaderAction_Name_STATUS("ModifyResponseHeader")

// Mapping from string to DeliveryRuleResponseHeaderAction_Name_STATUS
var deliveryRuleResponseHeaderAction_Name_STATUS_Values = map[string]DeliveryRuleResponseHeaderAction_Name_STATUS{
	"modifyresponseheader": DeliveryRuleResponseHeaderAction_Name_STATUS_ModifyResponseHeader,
}

// +kubebuilder:validation:Enum={"RouteConfigurationOverride"}
type DeliveryRuleRouteConfigurationOverrideAction_Name string

const DeliveryRuleRouteConfigurationOverrideAction_Name_RouteConfigurationOverride = DeliveryRuleRouteConfigurationOverrideAction_Name("RouteConfigurationOverride")

// Mapping from string to DeliveryRuleRouteConfigurationOverrideAction_Name
var deliveryRuleRouteConfigurationOverrideAction_Name_Values = map[string]DeliveryRuleRouteConfigurationOverrideAction_Name{
	"routeconfigurationoverride": DeliveryRuleRouteConfigurationOverrideAction_Name_RouteConfigurationOverride,
}

type DeliveryRuleRouteConfigurationOverrideAction_Name_STATUS string

const DeliveryRuleRouteConfigurationOverrideAction_Name_STATUS_RouteConfigurationOverride = DeliveryRuleRouteConfigurationOverrideAction_Name_STATUS("RouteConfigurationOverride")

// Mapping from string to DeliveryRuleRouteConfigurationOverrideAction_Name_STATUS
var deliveryRuleRouteConfigurationOverrideAction_Name_STATUS_Values = map[string]DeliveryRuleRouteConfigurationOverrideAction_Name_STATUS{
	"routeconfigurationoverride": DeliveryRuleRouteConfigurationOverrideAction_Name_STATUS_RouteConfigurationOverride,
}

// +kubebuilder:validation:Enum={"ServerPort"}
type DeliveryRuleServerPortCondition_Name string

const DeliveryRuleServerPortCondition_Name_ServerPort = DeliveryRuleServerPortCondition_Name("ServerPort")

// Mapping from string to DeliveryRuleServerPortCondition_Name
var deliveryRuleServerPortCondition_Name_Values = map[string]DeliveryRuleServerPortCondition_Name{
	"serverport": DeliveryRuleServerPortCondition_Name_ServerPort,
}

type DeliveryRuleServerPortCondition_Name_STATUS string

const DeliveryRuleServerPortCondition_Name_STATUS_ServerPort = DeliveryRuleServerPortCondition_Name_STATUS("ServerPort")

// Mapping from string to DeliveryRuleServerPortCondition_Name_STATUS
var deliveryRuleServerPortCondition_Name_STATUS_Values = map[string]DeliveryRuleServerPortCondition_Name_STATUS{
	"serverport": DeliveryRuleServerPortCondition_Name_STATUS_ServerPort,
}

// +kubebuilder:validation:Enum={"SocketAddr"}
type DeliveryRuleSocketAddrCondition_Name string

const DeliveryRuleSocketAddrCondition_Name_SocketAddr = DeliveryRuleSocketAddrCondition_Name("SocketAddr")

// Mapping from string to DeliveryRuleSocketAddrCondition_Name
var deliveryRuleSocketAddrCondition_Name_Values = map[string]DeliveryRuleSocketAddrCondition_Name{
	"socketaddr": DeliveryRuleSocketAddrCondition_Name_SocketAddr,
}

type DeliveryRuleSocketAddrCondition_Name_STATUS string

const DeliveryRuleSocketAddrCondition_Name_STATUS_SocketAddr = DeliveryRuleSocketAddrCondition_Name_STATUS("SocketAddr")

// Mapping from string to DeliveryRuleSocketAddrCondition_Name_STATUS
var deliveryRuleSocketAddrCondition_Name_STATUS_Values = map[string]DeliveryRuleSocketAddrCondition_Name_STATUS{
	"socketaddr": DeliveryRuleSocketAddrCondition_Name_STATUS_SocketAddr,
}

// +kubebuilder:validation:Enum={"SslProtocol"}
type DeliveryRuleSslProtocolCondition_Name string

const DeliveryRuleSslProtocolCondition_Name_SslProtocol = DeliveryRuleSslProtocolCondition_Name("SslProtocol")

// Mapping from string to DeliveryRuleSslProtocolCondition_Name
var deliveryRuleSslProtocolCondition_Name_Values = map[string]DeliveryRuleSslProtocolCondition_Name{
	"sslprotocol": DeliveryRuleSslProtocolCondition_Name_SslProtocol,
}

type DeliveryRuleSslProtocolCondition_Name_STATUS string

const DeliveryRuleSslProtocolCondition_Name_STATUS_SslProtocol = DeliveryRuleSslProtocolCondition_Name_STATUS("SslProtocol")

// Mapping from string to DeliveryRuleSslProtocolCondition_Name_STATUS
var deliveryRuleSslProtocolCondition_Name_STATUS_Values = map[string]DeliveryRuleSslProtocolCondition_Name_STATUS{
	"sslprotocol": DeliveryRuleSslProtocolCondition_Name_STATUS_SslProtocol,
}

// +kubebuilder:validation:Enum={"UrlFileExtension"}
type DeliveryRuleUrlFileExtensionCondition_Name string

const DeliveryRuleUrlFileExtensionCondition_Name_UrlFileExtension = DeliveryRuleUrlFileExtensionCondition_Name("UrlFileExtension")

// Mapping from string to DeliveryRuleUrlFileExtensionCondition_Name
var deliveryRuleUrlFileExtensionCondition_Name_Values = map[string]DeliveryRuleUrlFileExtensionCondition_Name{
	"urlfileextension": DeliveryRuleUrlFileExtensionCondition_Name_UrlFileExtension,
}

type DeliveryRuleUrlFileExtensionCondition_Name_STATUS string

const DeliveryRuleUrlFileExtensionCondition_Name_STATUS_UrlFileExtension = DeliveryRuleUrlFileExtensionCondition_Name_STATUS("UrlFileExtension")

// Mapping from string to DeliveryRuleUrlFileExtensionCondition_Name_STATUS
var deliveryRuleUrlFileExtensionCondition_Name_STATUS_Values = map[string]DeliveryRuleUrlFileExtensionCondition_Name_STATUS{
	"urlfileextension": DeliveryRuleUrlFileExtensionCondition_Name_STATUS_UrlFileExtension,
}

// +kubebuilder:validation:Enum={"UrlFileName"}
type DeliveryRuleUrlFileNameCondition_Name string

const DeliveryRuleUrlFileNameCondition_Name_UrlFileName = DeliveryRuleUrlFileNameCondition_Name("UrlFileName")

// Mapping from string to DeliveryRuleUrlFileNameCondition_Name
var deliveryRuleUrlFileNameCondition_Name_Values = map[string]DeliveryRuleUrlFileNameCondition_Name{
	"urlfilename": DeliveryRuleUrlFileNameCondition_Name_UrlFileName,
}

type DeliveryRuleUrlFileNameCondition_Name_STATUS string

const DeliveryRuleUrlFileNameCondition_Name_STATUS_UrlFileName = DeliveryRuleUrlFileNameCondition_Name_STATUS("UrlFileName")

// Mapping from string to DeliveryRuleUrlFileNameCondition_Name_STATUS
var deliveryRuleUrlFileNameCondition_Name_STATUS_Values = map[string]DeliveryRuleUrlFileNameCondition_Name_STATUS{
	"urlfilename": DeliveryRuleUrlFileNameCondition_Name_STATUS_UrlFileName,
}

// +kubebuilder:validation:Enum={"UrlPath"}
type DeliveryRuleUrlPathCondition_Name string

const DeliveryRuleUrlPathCondition_Name_UrlPath = DeliveryRuleUrlPathCondition_Name("UrlPath")

// Mapping from string to DeliveryRuleUrlPathCondition_Name
var deliveryRuleUrlPathCondition_Name_Values = map[string]DeliveryRuleUrlPathCondition_Name{
	"urlpath": DeliveryRuleUrlPathCondition_Name_UrlPath,
}

type DeliveryRuleUrlPathCondition_Name_STATUS string

const DeliveryRuleUrlPathCondition_Name_STATUS_UrlPath = DeliveryRuleUrlPathCondition_Name_STATUS("UrlPath")

// Mapping from string to DeliveryRuleUrlPathCondition_Name_STATUS
var deliveryRuleUrlPathCondition_Name_STATUS_Values = map[string]DeliveryRuleUrlPathCondition_Name_STATUS{
	"urlpath": DeliveryRuleUrlPathCondition_Name_STATUS_UrlPath,
}

// Defines the parameters for the request header action.
type HeaderActionParameters struct {
	// +kubebuilder:validation:Required
	// HeaderAction: Action to perform
	HeaderAction *HeaderActionParameters_HeaderAction `json:"headerAction,omitempty"`

	// +kubebuilder:validation:Required
	// HeaderName: Name of the header to modify
	HeaderName *string `json:"headerName,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *HeaderActionParameters_TypeName `json:"typeName,omitempty"`

	// Value: Value for the specified action
	Value *string `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &HeaderActionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *HeaderActionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.HeaderActionParameters{}

	// Set property "HeaderAction":
	if parameters.HeaderAction != nil {
		var temp string
		temp = string(*parameters.HeaderAction)
		headerAction := arm.HeaderActionParameters_HeaderAction(temp)
		result.HeaderAction = &headerAction
	}

	// Set property "HeaderName":
	if parameters.HeaderName != nil {
		headerName := *parameters.HeaderName
		result.HeaderName = &headerName
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		var temp string
		temp = string(*parameters.TypeName)
		typeName := arm.HeaderActionParameters_TypeName(temp)
		result.TypeName = &typeName
	}

	// Set property "Value":
	if parameters.Value != nil {
		value := *parameters.Value
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *HeaderActionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HeaderActionParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *HeaderActionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HeaderActionParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HeaderActionParameters, got %T", armInput)
	}

	// Set property "HeaderAction":
	if typedInput.HeaderAction != nil {
		var temp string
		temp = string(*typedInput.HeaderAction)
		headerAction := HeaderActionParameters_HeaderAction(temp)
		parameters.HeaderAction = &headerAction
	}

	// Set property "HeaderName":
	if typedInput.HeaderName != nil {
		headerName := *typedInput.HeaderName
		parameters.HeaderName = &headerName
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := HeaderActionParameters_TypeName(temp)
		parameters.TypeName = &typeName
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		parameters.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_HeaderActionParameters populates our HeaderActionParameters from the provided source HeaderActionParameters
func (parameters *HeaderActionParameters) AssignProperties_From_HeaderActionParameters(source *storage.HeaderActionParameters) error {

	// HeaderAction
	if source.HeaderAction != nil {
		headerAction := *source.HeaderAction
		headerActionTemp := genruntime.ToEnum(headerAction, headerActionParameters_HeaderAction_Values)
		parameters.HeaderAction = &headerActionTemp
	} else {
		parameters.HeaderAction = nil
	}

	// HeaderName
	parameters.HeaderName = genruntime.ClonePointerToString(source.HeaderName)

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, headerActionParameters_TypeName_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// Value
	parameters.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_HeaderActionParameters populates the provided destination HeaderActionParameters from our HeaderActionParameters
func (parameters *HeaderActionParameters) AssignProperties_To_HeaderActionParameters(destination *storage.HeaderActionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HeaderAction
	if parameters.HeaderAction != nil {
		headerAction := string(*parameters.HeaderAction)
		destination.HeaderAction = &headerAction
	} else {
		destination.HeaderAction = nil
	}

	// HeaderName
	destination.HeaderName = genruntime.ClonePointerToString(parameters.HeaderName)

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Value
	destination.Value = genruntime.ClonePointerToString(parameters.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_HeaderActionParameters_STATUS populates our HeaderActionParameters from the provided source HeaderActionParameters_STATUS
func (parameters *HeaderActionParameters) Initialize_From_HeaderActionParameters_STATUS(source *HeaderActionParameters_STATUS) error {

	// HeaderAction
	if source.HeaderAction != nil {
		headerAction := genruntime.ToEnum(string(*source.HeaderAction), headerActionParameters_HeaderAction_Values)
		parameters.HeaderAction = &headerAction
	} else {
		parameters.HeaderAction = nil
	}

	// HeaderName
	parameters.HeaderName = genruntime.ClonePointerToString(source.HeaderName)

	// TypeName
	if source.TypeName != nil {
		typeName := genruntime.ToEnum(string(*source.TypeName), headerActionParameters_TypeName_Values)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// Value
	parameters.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// Defines the parameters for the request header action.
type HeaderActionParameters_STATUS struct {
	// HeaderAction: Action to perform
	HeaderAction *HeaderActionParameters_HeaderAction_STATUS `json:"headerAction,omitempty"`

	// HeaderName: Name of the header to modify
	HeaderName *string                                 `json:"headerName,omitempty"`
	TypeName   *HeaderActionParameters_TypeName_STATUS `json:"typeName,omitempty"`

	// Value: Value for the specified action
	Value *string `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &HeaderActionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *HeaderActionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HeaderActionParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *HeaderActionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HeaderActionParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HeaderActionParameters_STATUS, got %T", armInput)
	}

	// Set property "HeaderAction":
	if typedInput.HeaderAction != nil {
		var temp string
		temp = string(*typedInput.HeaderAction)
		headerAction := HeaderActionParameters_HeaderAction_STATUS(temp)
		parameters.HeaderAction = &headerAction
	}

	// Set property "HeaderName":
	if typedInput.HeaderName != nil {
		headerName := *typedInput.HeaderName
		parameters.HeaderName = &headerName
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := HeaderActionParameters_TypeName_STATUS(temp)
		parameters.TypeName = &typeName
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		parameters.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_HeaderActionParameters_STATUS populates our HeaderActionParameters_STATUS from the provided source HeaderActionParameters_STATUS
func (parameters *HeaderActionParameters_STATUS) AssignProperties_From_HeaderActionParameters_STATUS(source *storage.HeaderActionParameters_STATUS) error {

	// HeaderAction
	if source.HeaderAction != nil {
		headerAction := *source.HeaderAction
		headerActionTemp := genruntime.ToEnum(headerAction, headerActionParameters_HeaderAction_STATUS_Values)
		parameters.HeaderAction = &headerActionTemp
	} else {
		parameters.HeaderAction = nil
	}

	// HeaderName
	parameters.HeaderName = genruntime.ClonePointerToString(source.HeaderName)

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, headerActionParameters_TypeName_STATUS_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// Value
	parameters.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_HeaderActionParameters_STATUS populates the provided destination HeaderActionParameters_STATUS from our HeaderActionParameters_STATUS
func (parameters *HeaderActionParameters_STATUS) AssignProperties_To_HeaderActionParameters_STATUS(destination *storage.HeaderActionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HeaderAction
	if parameters.HeaderAction != nil {
		headerAction := string(*parameters.HeaderAction)
		destination.HeaderAction = &headerAction
	} else {
		destination.HeaderAction = nil
	}

	// HeaderName
	destination.HeaderName = genruntime.ClonePointerToString(parameters.HeaderName)

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Value
	destination.Value = genruntime.ClonePointerToString(parameters.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for HostName match conditions
type HostNameMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *HostNameMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *HostNameMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &HostNameMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *HostNameMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.HostNameMatchConditionParameters{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		result.MatchValues = append(result.MatchValues, item)
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		var temp string
		temp = string(*parameters.Operator)
		operator := arm.HostNameMatchConditionParameters_Operator(temp)
		result.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		var temp string
		temp = string(item)
		result.Transforms = append(result.Transforms, arm.Transform(temp))
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		var temp string
		temp = string(*parameters.TypeName)
		typeName := arm.HostNameMatchConditionParameters_TypeName(temp)
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *HostNameMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HostNameMatchConditionParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *HostNameMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HostNameMatchConditionParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HostNameMatchConditionParameters, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := HostNameMatchConditionParameters_Operator(temp)
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := HostNameMatchConditionParameters_TypeName(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_HostNameMatchConditionParameters populates our HostNameMatchConditionParameters from the provided source HostNameMatchConditionParameters
func (parameters *HostNameMatchConditionParameters) AssignProperties_From_HostNameMatchConditionParameters(source *storage.HostNameMatchConditionParameters) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, hostNameMatchConditionParameters_Operator_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, hostNameMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_HostNameMatchConditionParameters populates the provided destination HostNameMatchConditionParameters from our HostNameMatchConditionParameters
func (parameters *HostNameMatchConditionParameters) AssignProperties_To_HostNameMatchConditionParameters(destination *storage.HostNameMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_HostNameMatchConditionParameters_STATUS populates our HostNameMatchConditionParameters from the provided source HostNameMatchConditionParameters_STATUS
func (parameters *HostNameMatchConditionParameters) Initialize_From_HostNameMatchConditionParameters_STATUS(source *HostNameMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := genruntime.ToEnum(string(*source.Operator), hostNameMatchConditionParameters_Operator_Values)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := genruntime.ToEnum(string(transformItem), transform_Values)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := genruntime.ToEnum(string(*source.TypeName), hostNameMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for HostName match conditions
type HostNameMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *HostNameMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                                `json:"transforms,omitempty"`
	TypeName   *HostNameMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &HostNameMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *HostNameMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HostNameMatchConditionParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *HostNameMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HostNameMatchConditionParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HostNameMatchConditionParameters_STATUS, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := HostNameMatchConditionParameters_Operator_STATUS(temp)
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform_STATUS(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := HostNameMatchConditionParameters_TypeName_STATUS(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_HostNameMatchConditionParameters_STATUS populates our HostNameMatchConditionParameters_STATUS from the provided source HostNameMatchConditionParameters_STATUS
func (parameters *HostNameMatchConditionParameters_STATUS) AssignProperties_From_HostNameMatchConditionParameters_STATUS(source *storage.HostNameMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, hostNameMatchConditionParameters_Operator_STATUS_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_STATUS_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, hostNameMatchConditionParameters_TypeName_STATUS_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_HostNameMatchConditionParameters_STATUS populates the provided destination HostNameMatchConditionParameters_STATUS from our HostNameMatchConditionParameters_STATUS
func (parameters *HostNameMatchConditionParameters_STATUS) AssignProperties_To_HostNameMatchConditionParameters_STATUS(destination *storage.HostNameMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for HttpVersion match conditions
type HttpVersionMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *HttpVersionMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *HttpVersionMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &HttpVersionMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *HttpVersionMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.HttpVersionMatchConditionParameters{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		result.MatchValues = append(result.MatchValues, item)
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		var temp string
		temp = string(*parameters.Operator)
		operator := arm.HttpVersionMatchConditionParameters_Operator(temp)
		result.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		var temp string
		temp = string(item)
		result.Transforms = append(result.Transforms, arm.Transform(temp))
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		var temp string
		temp = string(*parameters.TypeName)
		typeName := arm.HttpVersionMatchConditionParameters_TypeName(temp)
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *HttpVersionMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HttpVersionMatchConditionParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *HttpVersionMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HttpVersionMatchConditionParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HttpVersionMatchConditionParameters, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := HttpVersionMatchConditionParameters_Operator(temp)
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := HttpVersionMatchConditionParameters_TypeName(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_HttpVersionMatchConditionParameters populates our HttpVersionMatchConditionParameters from the provided source HttpVersionMatchConditionParameters
func (parameters *HttpVersionMatchConditionParameters) AssignProperties_From_HttpVersionMatchConditionParameters(source *storage.HttpVersionMatchConditionParameters) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, httpVersionMatchConditionParameters_Operator_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, httpVersionMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_HttpVersionMatchConditionParameters populates the provided destination HttpVersionMatchConditionParameters from our HttpVersionMatchConditionParameters
func (parameters *HttpVersionMatchConditionParameters) AssignProperties_To_HttpVersionMatchConditionParameters(destination *storage.HttpVersionMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_HttpVersionMatchConditionParameters_STATUS populates our HttpVersionMatchConditionParameters from the provided source HttpVersionMatchConditionParameters_STATUS
func (parameters *HttpVersionMatchConditionParameters) Initialize_From_HttpVersionMatchConditionParameters_STATUS(source *HttpVersionMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := genruntime.ToEnum(string(*source.Operator), httpVersionMatchConditionParameters_Operator_Values)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := genruntime.ToEnum(string(transformItem), transform_Values)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := genruntime.ToEnum(string(*source.TypeName), httpVersionMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for HttpVersion match conditions
type HttpVersionMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *HttpVersionMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                                   `json:"transforms,omitempty"`
	TypeName   *HttpVersionMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &HttpVersionMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *HttpVersionMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HttpVersionMatchConditionParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *HttpVersionMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HttpVersionMatchConditionParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HttpVersionMatchConditionParameters_STATUS, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := HttpVersionMatchConditionParameters_Operator_STATUS(temp)
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform_STATUS(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := HttpVersionMatchConditionParameters_TypeName_STATUS(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_HttpVersionMatchConditionParameters_STATUS populates our HttpVersionMatchConditionParameters_STATUS from the provided source HttpVersionMatchConditionParameters_STATUS
func (parameters *HttpVersionMatchConditionParameters_STATUS) AssignProperties_From_HttpVersionMatchConditionParameters_STATUS(source *storage.HttpVersionMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, httpVersionMatchConditionParameters_Operator_STATUS_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_STATUS_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, httpVersionMatchConditionParameters_TypeName_STATUS_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_HttpVersionMatchConditionParameters_STATUS populates the provided destination HttpVersionMatchConditionParameters_STATUS from our HttpVersionMatchConditionParameters_STATUS
func (parameters *HttpVersionMatchConditionParameters_STATUS) AssignProperties_To_HttpVersionMatchConditionParameters_STATUS(destination *storage.HttpVersionMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for IsDevice match conditions
type IsDeviceMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []IsDeviceMatchConditionParameters_MatchValues `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *IsDeviceMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *IsDeviceMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &IsDeviceMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *IsDeviceMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.IsDeviceMatchConditionParameters{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		var temp string
		temp = string(item)
		result.MatchValues = append(result.MatchValues, arm.IsDeviceMatchConditionParameters_MatchValues(temp))
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		var temp string
		temp = string(*parameters.Operator)
		operator := arm.IsDeviceMatchConditionParameters_Operator(temp)
		result.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		var temp string
		temp = string(item)
		result.Transforms = append(result.Transforms, arm.Transform(temp))
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		var temp string
		temp = string(*parameters.TypeName)
		typeName := arm.IsDeviceMatchConditionParameters_TypeName(temp)
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *IsDeviceMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IsDeviceMatchConditionParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *IsDeviceMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IsDeviceMatchConditionParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IsDeviceMatchConditionParameters, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		var temp string
		temp = string(item)
		parameters.MatchValues = append(parameters.MatchValues, IsDeviceMatchConditionParameters_MatchValues(temp))
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := IsDeviceMatchConditionParameters_Operator(temp)
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := IsDeviceMatchConditionParameters_TypeName(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_IsDeviceMatchConditionParameters populates our IsDeviceMatchConditionParameters from the provided source IsDeviceMatchConditionParameters
func (parameters *IsDeviceMatchConditionParameters) AssignProperties_From_IsDeviceMatchConditionParameters(source *storage.IsDeviceMatchConditionParameters) error {

	// MatchValues
	if source.MatchValues != nil {
		matchValueList := make([]IsDeviceMatchConditionParameters_MatchValues, len(source.MatchValues))
		for matchValueIndex, matchValueItem := range source.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValueList[matchValueIndex] = genruntime.ToEnum(matchValueItem, isDeviceMatchConditionParameters_MatchValues_Values)
		}
		parameters.MatchValues = matchValueList
	} else {
		parameters.MatchValues = nil
	}

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, isDeviceMatchConditionParameters_Operator_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, isDeviceMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_IsDeviceMatchConditionParameters populates the provided destination IsDeviceMatchConditionParameters from our IsDeviceMatchConditionParameters
func (parameters *IsDeviceMatchConditionParameters) AssignProperties_To_IsDeviceMatchConditionParameters(destination *storage.IsDeviceMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	if parameters.MatchValues != nil {
		matchValueList := make([]string, len(parameters.MatchValues))
		for matchValueIndex, matchValueItem := range parameters.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValueList[matchValueIndex] = string(matchValueItem)
		}
		destination.MatchValues = matchValueList
	} else {
		destination.MatchValues = nil
	}

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_IsDeviceMatchConditionParameters_STATUS populates our IsDeviceMatchConditionParameters from the provided source IsDeviceMatchConditionParameters_STATUS
func (parameters *IsDeviceMatchConditionParameters) Initialize_From_IsDeviceMatchConditionParameters_STATUS(source *IsDeviceMatchConditionParameters_STATUS) error {

	// MatchValues
	if source.MatchValues != nil {
		matchValueList := make([]IsDeviceMatchConditionParameters_MatchValues, len(source.MatchValues))
		for matchValueIndex, matchValueItem := range source.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValue := genruntime.ToEnum(string(matchValueItem), isDeviceMatchConditionParameters_MatchValues_Values)
			matchValueList[matchValueIndex] = matchValue
		}
		parameters.MatchValues = matchValueList
	} else {
		parameters.MatchValues = nil
	}

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := genruntime.ToEnum(string(*source.Operator), isDeviceMatchConditionParameters_Operator_Values)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := genruntime.ToEnum(string(transformItem), transform_Values)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := genruntime.ToEnum(string(*source.TypeName), isDeviceMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for IsDevice match conditions
type IsDeviceMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []IsDeviceMatchConditionParameters_MatchValues_STATUS `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *IsDeviceMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                                `json:"transforms,omitempty"`
	TypeName   *IsDeviceMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &IsDeviceMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *IsDeviceMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IsDeviceMatchConditionParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *IsDeviceMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IsDeviceMatchConditionParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IsDeviceMatchConditionParameters_STATUS, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		var temp string
		temp = string(item)
		parameters.MatchValues = append(parameters.MatchValues, IsDeviceMatchConditionParameters_MatchValues_STATUS(temp))
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := IsDeviceMatchConditionParameters_Operator_STATUS(temp)
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform_STATUS(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := IsDeviceMatchConditionParameters_TypeName_STATUS(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_IsDeviceMatchConditionParameters_STATUS populates our IsDeviceMatchConditionParameters_STATUS from the provided source IsDeviceMatchConditionParameters_STATUS
func (parameters *IsDeviceMatchConditionParameters_STATUS) AssignProperties_From_IsDeviceMatchConditionParameters_STATUS(source *storage.IsDeviceMatchConditionParameters_STATUS) error {

	// MatchValues
	if source.MatchValues != nil {
		matchValueList := make([]IsDeviceMatchConditionParameters_MatchValues_STATUS, len(source.MatchValues))
		for matchValueIndex, matchValueItem := range source.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValueList[matchValueIndex] = genruntime.ToEnum(matchValueItem, isDeviceMatchConditionParameters_MatchValues_STATUS_Values)
		}
		parameters.MatchValues = matchValueList
	} else {
		parameters.MatchValues = nil
	}

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, isDeviceMatchConditionParameters_Operator_STATUS_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_STATUS_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, isDeviceMatchConditionParameters_TypeName_STATUS_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_IsDeviceMatchConditionParameters_STATUS populates the provided destination IsDeviceMatchConditionParameters_STATUS from our IsDeviceMatchConditionParameters_STATUS
func (parameters *IsDeviceMatchConditionParameters_STATUS) AssignProperties_To_IsDeviceMatchConditionParameters_STATUS(destination *storage.IsDeviceMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	if parameters.MatchValues != nil {
		matchValueList := make([]string, len(parameters.MatchValues))
		for matchValueIndex, matchValueItem := range parameters.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValueList[matchValueIndex] = string(matchValueItem)
		}
		destination.MatchValues = matchValueList
	} else {
		destination.MatchValues = nil
	}

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"OriginGroupOverride"}
type OriginGroupOverrideAction_Name string

const OriginGroupOverrideAction_Name_OriginGroupOverride = OriginGroupOverrideAction_Name("OriginGroupOverride")

// Mapping from string to OriginGroupOverrideAction_Name
var originGroupOverrideAction_Name_Values = map[string]OriginGroupOverrideAction_Name{
	"origingroupoverride": OriginGroupOverrideAction_Name_OriginGroupOverride,
}

type OriginGroupOverrideAction_Name_STATUS string

const OriginGroupOverrideAction_Name_STATUS_OriginGroupOverride = OriginGroupOverrideAction_Name_STATUS("OriginGroupOverride")

// Mapping from string to OriginGroupOverrideAction_Name_STATUS
var originGroupOverrideAction_Name_STATUS_Values = map[string]OriginGroupOverrideAction_Name_STATUS{
	"origingroupoverride": OriginGroupOverrideAction_Name_STATUS_OriginGroupOverride,
}

// Defines the parameters for the origin group override action.
type OriginGroupOverrideActionParameters struct {
	// +kubebuilder:validation:Required
	// OriginGroup: defines the OriginGroup that would override the DefaultOriginGroup.
	OriginGroup *ResourceReference `json:"originGroup,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *OriginGroupOverrideActionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &OriginGroupOverrideActionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *OriginGroupOverrideActionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.OriginGroupOverrideActionParameters{}

	// Set property "OriginGroup":
	if parameters.OriginGroup != nil {
		originGroup_ARM, err := (*parameters.OriginGroup).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		originGroup := *originGroup_ARM.(*arm.ResourceReference)
		result.OriginGroup = &originGroup
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		var temp string
		temp = string(*parameters.TypeName)
		typeName := arm.OriginGroupOverrideActionParameters_TypeName(temp)
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *OriginGroupOverrideActionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.OriginGroupOverrideActionParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *OriginGroupOverrideActionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.OriginGroupOverrideActionParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.OriginGroupOverrideActionParameters, got %T", armInput)
	}

	// Set property "OriginGroup":
	if typedInput.OriginGroup != nil {
		var originGroup1 ResourceReference
		err := originGroup1.PopulateFromARM(owner, *typedInput.OriginGroup)
		if err != nil {
			return err
		}
		originGroup := originGroup1
		parameters.OriginGroup = &originGroup
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := OriginGroupOverrideActionParameters_TypeName(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_OriginGroupOverrideActionParameters populates our OriginGroupOverrideActionParameters from the provided source OriginGroupOverrideActionParameters
func (parameters *OriginGroupOverrideActionParameters) AssignProperties_From_OriginGroupOverrideActionParameters(source *storage.OriginGroupOverrideActionParameters) error {

	// OriginGroup
	if source.OriginGroup != nil {
		var originGroup ResourceReference
		err := originGroup.AssignProperties_From_ResourceReference(source.OriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceReference() to populate field OriginGroup")
		}
		parameters.OriginGroup = &originGroup
	} else {
		parameters.OriginGroup = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, originGroupOverrideActionParameters_TypeName_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_OriginGroupOverrideActionParameters populates the provided destination OriginGroupOverrideActionParameters from our OriginGroupOverrideActionParameters
func (parameters *OriginGroupOverrideActionParameters) AssignProperties_To_OriginGroupOverrideActionParameters(destination *storage.OriginGroupOverrideActionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// OriginGroup
	if parameters.OriginGroup != nil {
		var originGroup storage.ResourceReference
		err := parameters.OriginGroup.AssignProperties_To_ResourceReference(&originGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceReference() to populate field OriginGroup")
		}
		destination.OriginGroup = &originGroup
	} else {
		destination.OriginGroup = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_OriginGroupOverrideActionParameters_STATUS populates our OriginGroupOverrideActionParameters from the provided source OriginGroupOverrideActionParameters_STATUS
func (parameters *OriginGroupOverrideActionParameters) Initialize_From_OriginGroupOverrideActionParameters_STATUS(source *OriginGroupOverrideActionParameters_STATUS) error {

	// OriginGroup
	if source.OriginGroup != nil {
		var originGroup ResourceReference
		err := originGroup.Initialize_From_ResourceReference_STATUS(source.OriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ResourceReference_STATUS() to populate field OriginGroup")
		}
		parameters.OriginGroup = &originGroup
	} else {
		parameters.OriginGroup = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := genruntime.ToEnum(string(*source.TypeName), originGroupOverrideActionParameters_TypeName_Values)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for the origin group override action.
type OriginGroupOverrideActionParameters_STATUS struct {
	// OriginGroup: defines the OriginGroup that would override the DefaultOriginGroup.
	OriginGroup *ResourceReference_STATUS                            `json:"originGroup,omitempty"`
	TypeName    *OriginGroupOverrideActionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &OriginGroupOverrideActionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *OriginGroupOverrideActionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.OriginGroupOverrideActionParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *OriginGroupOverrideActionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.OriginGroupOverrideActionParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.OriginGroupOverrideActionParameters_STATUS, got %T", armInput)
	}

	// Set property "OriginGroup":
	if typedInput.OriginGroup != nil {
		var originGroup1 ResourceReference_STATUS
		err := originGroup1.PopulateFromARM(owner, *typedInput.OriginGroup)
		if err != nil {
			return err
		}
		originGroup := originGroup1
		parameters.OriginGroup = &originGroup
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := OriginGroupOverrideActionParameters_TypeName_STATUS(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_OriginGroupOverrideActionParameters_STATUS populates our OriginGroupOverrideActionParameters_STATUS from the provided source OriginGroupOverrideActionParameters_STATUS
func (parameters *OriginGroupOverrideActionParameters_STATUS) AssignProperties_From_OriginGroupOverrideActionParameters_STATUS(source *storage.OriginGroupOverrideActionParameters_STATUS) error {

	// OriginGroup
	if source.OriginGroup != nil {
		var originGroup ResourceReference_STATUS
		err := originGroup.AssignProperties_From_ResourceReference_STATUS(source.OriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceReference_STATUS() to populate field OriginGroup")
		}
		parameters.OriginGroup = &originGroup
	} else {
		parameters.OriginGroup = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, originGroupOverrideActionParameters_TypeName_STATUS_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_OriginGroupOverrideActionParameters_STATUS populates the provided destination OriginGroupOverrideActionParameters_STATUS from our OriginGroupOverrideActionParameters_STATUS
func (parameters *OriginGroupOverrideActionParameters_STATUS) AssignProperties_To_OriginGroupOverrideActionParameters_STATUS(destination *storage.OriginGroupOverrideActionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// OriginGroup
	if parameters.OriginGroup != nil {
		var originGroup storage.ResourceReference_STATUS
		err := parameters.OriginGroup.AssignProperties_To_ResourceReference_STATUS(&originGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceReference_STATUS() to populate field OriginGroup")
		}
		destination.OriginGroup = &originGroup
	} else {
		destination.OriginGroup = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for PostArgs match conditions
type PostArgsMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *PostArgsMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Selector: Name of PostArg to be matched
	Selector *string `json:"selector,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *PostArgsMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &PostArgsMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *PostArgsMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.PostArgsMatchConditionParameters{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		result.MatchValues = append(result.MatchValues, item)
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		var temp string
		temp = string(*parameters.Operator)
		operator := arm.PostArgsMatchConditionParameters_Operator(temp)
		result.Operator = &operator
	}

	// Set property "Selector":
	if parameters.Selector != nil {
		selector := *parameters.Selector
		result.Selector = &selector
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		var temp string
		temp = string(item)
		result.Transforms = append(result.Transforms, arm.Transform(temp))
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		var temp string
		temp = string(*parameters.TypeName)
		typeName := arm.PostArgsMatchConditionParameters_TypeName(temp)
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *PostArgsMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PostArgsMatchConditionParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *PostArgsMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PostArgsMatchConditionParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PostArgsMatchConditionParameters, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := PostArgsMatchConditionParameters_Operator(temp)
		parameters.Operator = &operator
	}

	// Set property "Selector":
	if typedInput.Selector != nil {
		selector := *typedInput.Selector
		parameters.Selector = &selector
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := PostArgsMatchConditionParameters_TypeName(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_PostArgsMatchConditionParameters populates our PostArgsMatchConditionParameters from the provided source PostArgsMatchConditionParameters
func (parameters *PostArgsMatchConditionParameters) AssignProperties_From_PostArgsMatchConditionParameters(source *storage.PostArgsMatchConditionParameters) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, postArgsMatchConditionParameters_Operator_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Selector
	parameters.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, postArgsMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PostArgsMatchConditionParameters populates the provided destination PostArgsMatchConditionParameters from our PostArgsMatchConditionParameters
func (parameters *PostArgsMatchConditionParameters) AssignProperties_To_PostArgsMatchConditionParameters(destination *storage.PostArgsMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Selector
	destination.Selector = genruntime.ClonePointerToString(parameters.Selector)

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_PostArgsMatchConditionParameters_STATUS populates our PostArgsMatchConditionParameters from the provided source PostArgsMatchConditionParameters_STATUS
func (parameters *PostArgsMatchConditionParameters) Initialize_From_PostArgsMatchConditionParameters_STATUS(source *PostArgsMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := genruntime.ToEnum(string(*source.Operator), postArgsMatchConditionParameters_Operator_Values)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Selector
	parameters.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := genruntime.ToEnum(string(transformItem), transform_Values)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := genruntime.ToEnum(string(*source.TypeName), postArgsMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for PostArgs match conditions
type PostArgsMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *PostArgsMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Selector: Name of PostArg to be matched
	Selector *string `json:"selector,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                                `json:"transforms,omitempty"`
	TypeName   *PostArgsMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &PostArgsMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *PostArgsMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PostArgsMatchConditionParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *PostArgsMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PostArgsMatchConditionParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PostArgsMatchConditionParameters_STATUS, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := PostArgsMatchConditionParameters_Operator_STATUS(temp)
		parameters.Operator = &operator
	}

	// Set property "Selector":
	if typedInput.Selector != nil {
		selector := *typedInput.Selector
		parameters.Selector = &selector
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform_STATUS(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := PostArgsMatchConditionParameters_TypeName_STATUS(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_PostArgsMatchConditionParameters_STATUS populates our PostArgsMatchConditionParameters_STATUS from the provided source PostArgsMatchConditionParameters_STATUS
func (parameters *PostArgsMatchConditionParameters_STATUS) AssignProperties_From_PostArgsMatchConditionParameters_STATUS(source *storage.PostArgsMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, postArgsMatchConditionParameters_Operator_STATUS_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Selector
	parameters.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_STATUS_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, postArgsMatchConditionParameters_TypeName_STATUS_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PostArgsMatchConditionParameters_STATUS populates the provided destination PostArgsMatchConditionParameters_STATUS from our PostArgsMatchConditionParameters_STATUS
func (parameters *PostArgsMatchConditionParameters_STATUS) AssignProperties_To_PostArgsMatchConditionParameters_STATUS(destination *storage.PostArgsMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Selector
	destination.Selector = genruntime.ClonePointerToString(parameters.Selector)

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for QueryString match conditions
type QueryStringMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *QueryStringMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *QueryStringMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &QueryStringMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *QueryStringMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.QueryStringMatchConditionParameters{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		result.MatchValues = append(result.MatchValues, item)
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		var temp string
		temp = string(*parameters.Operator)
		operator := arm.QueryStringMatchConditionParameters_Operator(temp)
		result.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		var temp string
		temp = string(item)
		result.Transforms = append(result.Transforms, arm.Transform(temp))
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		var temp string
		temp = string(*parameters.TypeName)
		typeName := arm.QueryStringMatchConditionParameters_TypeName(temp)
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *QueryStringMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.QueryStringMatchConditionParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *QueryStringMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.QueryStringMatchConditionParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.QueryStringMatchConditionParameters, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := QueryStringMatchConditionParameters_Operator(temp)
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := QueryStringMatchConditionParameters_TypeName(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_QueryStringMatchConditionParameters populates our QueryStringMatchConditionParameters from the provided source QueryStringMatchConditionParameters
func (parameters *QueryStringMatchConditionParameters) AssignProperties_From_QueryStringMatchConditionParameters(source *storage.QueryStringMatchConditionParameters) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, queryStringMatchConditionParameters_Operator_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, queryStringMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_QueryStringMatchConditionParameters populates the provided destination QueryStringMatchConditionParameters from our QueryStringMatchConditionParameters
func (parameters *QueryStringMatchConditionParameters) AssignProperties_To_QueryStringMatchConditionParameters(destination *storage.QueryStringMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_QueryStringMatchConditionParameters_STATUS populates our QueryStringMatchConditionParameters from the provided source QueryStringMatchConditionParameters_STATUS
func (parameters *QueryStringMatchConditionParameters) Initialize_From_QueryStringMatchConditionParameters_STATUS(source *QueryStringMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := genruntime.ToEnum(string(*source.Operator), queryStringMatchConditionParameters_Operator_Values)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := genruntime.ToEnum(string(transformItem), transform_Values)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := genruntime.ToEnum(string(*source.TypeName), queryStringMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for QueryString match conditions
type QueryStringMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *QueryStringMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                                   `json:"transforms,omitempty"`
	TypeName   *QueryStringMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &QueryStringMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *QueryStringMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.QueryStringMatchConditionParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *QueryStringMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.QueryStringMatchConditionParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.QueryStringMatchConditionParameters_STATUS, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := QueryStringMatchConditionParameters_Operator_STATUS(temp)
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform_STATUS(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := QueryStringMatchConditionParameters_TypeName_STATUS(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_QueryStringMatchConditionParameters_STATUS populates our QueryStringMatchConditionParameters_STATUS from the provided source QueryStringMatchConditionParameters_STATUS
func (parameters *QueryStringMatchConditionParameters_STATUS) AssignProperties_From_QueryStringMatchConditionParameters_STATUS(source *storage.QueryStringMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, queryStringMatchConditionParameters_Operator_STATUS_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_STATUS_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, queryStringMatchConditionParameters_TypeName_STATUS_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_QueryStringMatchConditionParameters_STATUS populates the provided destination QueryStringMatchConditionParameters_STATUS from our QueryStringMatchConditionParameters_STATUS
func (parameters *QueryStringMatchConditionParameters_STATUS) AssignProperties_To_QueryStringMatchConditionParameters_STATUS(destination *storage.QueryStringMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for RemoteAddress match conditions
type RemoteAddressMatchConditionParameters struct {
	// MatchValues: Match values to match against. The operator will apply to each value in here with OR semantics. If any of
	// them match the variable with the given operator this match condition is considered a match.
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *RemoteAddressMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *RemoteAddressMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &RemoteAddressMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *RemoteAddressMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.RemoteAddressMatchConditionParameters{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		result.MatchValues = append(result.MatchValues, item)
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		var temp string
		temp = string(*parameters.Operator)
		operator := arm.RemoteAddressMatchConditionParameters_Operator(temp)
		result.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		var temp string
		temp = string(item)
		result.Transforms = append(result.Transforms, arm.Transform(temp))
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		var temp string
		temp = string(*parameters.TypeName)
		typeName := arm.RemoteAddressMatchConditionParameters_TypeName(temp)
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *RemoteAddressMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RemoteAddressMatchConditionParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *RemoteAddressMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RemoteAddressMatchConditionParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RemoteAddressMatchConditionParameters, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := RemoteAddressMatchConditionParameters_Operator(temp)
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := RemoteAddressMatchConditionParameters_TypeName(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_RemoteAddressMatchConditionParameters populates our RemoteAddressMatchConditionParameters from the provided source RemoteAddressMatchConditionParameters
func (parameters *RemoteAddressMatchConditionParameters) AssignProperties_From_RemoteAddressMatchConditionParameters(source *storage.RemoteAddressMatchConditionParameters) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, remoteAddressMatchConditionParameters_Operator_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, remoteAddressMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RemoteAddressMatchConditionParameters populates the provided destination RemoteAddressMatchConditionParameters from our RemoteAddressMatchConditionParameters
func (parameters *RemoteAddressMatchConditionParameters) AssignProperties_To_RemoteAddressMatchConditionParameters(destination *storage.RemoteAddressMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RemoteAddressMatchConditionParameters_STATUS populates our RemoteAddressMatchConditionParameters from the provided source RemoteAddressMatchConditionParameters_STATUS
func (parameters *RemoteAddressMatchConditionParameters) Initialize_From_RemoteAddressMatchConditionParameters_STATUS(source *RemoteAddressMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := genruntime.ToEnum(string(*source.Operator), remoteAddressMatchConditionParameters_Operator_Values)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := genruntime.ToEnum(string(transformItem), transform_Values)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := genruntime.ToEnum(string(*source.TypeName), remoteAddressMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for RemoteAddress match conditions
type RemoteAddressMatchConditionParameters_STATUS struct {
	// MatchValues: Match values to match against. The operator will apply to each value in here with OR semantics. If any of
	// them match the variable with the given operator this match condition is considered a match.
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *RemoteAddressMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                                     `json:"transforms,omitempty"`
	TypeName   *RemoteAddressMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &RemoteAddressMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *RemoteAddressMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RemoteAddressMatchConditionParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *RemoteAddressMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RemoteAddressMatchConditionParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RemoteAddressMatchConditionParameters_STATUS, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := RemoteAddressMatchConditionParameters_Operator_STATUS(temp)
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform_STATUS(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := RemoteAddressMatchConditionParameters_TypeName_STATUS(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_RemoteAddressMatchConditionParameters_STATUS populates our RemoteAddressMatchConditionParameters_STATUS from the provided source RemoteAddressMatchConditionParameters_STATUS
func (parameters *RemoteAddressMatchConditionParameters_STATUS) AssignProperties_From_RemoteAddressMatchConditionParameters_STATUS(source *storage.RemoteAddressMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, remoteAddressMatchConditionParameters_Operator_STATUS_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_STATUS_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, remoteAddressMatchConditionParameters_TypeName_STATUS_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RemoteAddressMatchConditionParameters_STATUS populates the provided destination RemoteAddressMatchConditionParameters_STATUS from our RemoteAddressMatchConditionParameters_STATUS
func (parameters *RemoteAddressMatchConditionParameters_STATUS) AssignProperties_To_RemoteAddressMatchConditionParameters_STATUS(destination *storage.RemoteAddressMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for RequestBody match conditions
type RequestBodyMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *RequestBodyMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *RequestBodyMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &RequestBodyMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *RequestBodyMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.RequestBodyMatchConditionParameters{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		result.MatchValues = append(result.MatchValues, item)
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		var temp string
		temp = string(*parameters.Operator)
		operator := arm.RequestBodyMatchConditionParameters_Operator(temp)
		result.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		var temp string
		temp = string(item)
		result.Transforms = append(result.Transforms, arm.Transform(temp))
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		var temp string
		temp = string(*parameters.TypeName)
		typeName := arm.RequestBodyMatchConditionParameters_TypeName(temp)
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *RequestBodyMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RequestBodyMatchConditionParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *RequestBodyMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RequestBodyMatchConditionParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RequestBodyMatchConditionParameters, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := RequestBodyMatchConditionParameters_Operator(temp)
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := RequestBodyMatchConditionParameters_TypeName(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_RequestBodyMatchConditionParameters populates our RequestBodyMatchConditionParameters from the provided source RequestBodyMatchConditionParameters
func (parameters *RequestBodyMatchConditionParameters) AssignProperties_From_RequestBodyMatchConditionParameters(source *storage.RequestBodyMatchConditionParameters) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, requestBodyMatchConditionParameters_Operator_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, requestBodyMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RequestBodyMatchConditionParameters populates the provided destination RequestBodyMatchConditionParameters from our RequestBodyMatchConditionParameters
func (parameters *RequestBodyMatchConditionParameters) AssignProperties_To_RequestBodyMatchConditionParameters(destination *storage.RequestBodyMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RequestBodyMatchConditionParameters_STATUS populates our RequestBodyMatchConditionParameters from the provided source RequestBodyMatchConditionParameters_STATUS
func (parameters *RequestBodyMatchConditionParameters) Initialize_From_RequestBodyMatchConditionParameters_STATUS(source *RequestBodyMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := genruntime.ToEnum(string(*source.Operator), requestBodyMatchConditionParameters_Operator_Values)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := genruntime.ToEnum(string(transformItem), transform_Values)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := genruntime.ToEnum(string(*source.TypeName), requestBodyMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for RequestBody match conditions
type RequestBodyMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *RequestBodyMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                                   `json:"transforms,omitempty"`
	TypeName   *RequestBodyMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &RequestBodyMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *RequestBodyMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RequestBodyMatchConditionParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *RequestBodyMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RequestBodyMatchConditionParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RequestBodyMatchConditionParameters_STATUS, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := RequestBodyMatchConditionParameters_Operator_STATUS(temp)
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform_STATUS(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := RequestBodyMatchConditionParameters_TypeName_STATUS(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_RequestBodyMatchConditionParameters_STATUS populates our RequestBodyMatchConditionParameters_STATUS from the provided source RequestBodyMatchConditionParameters_STATUS
func (parameters *RequestBodyMatchConditionParameters_STATUS) AssignProperties_From_RequestBodyMatchConditionParameters_STATUS(source *storage.RequestBodyMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, requestBodyMatchConditionParameters_Operator_STATUS_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_STATUS_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, requestBodyMatchConditionParameters_TypeName_STATUS_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RequestBodyMatchConditionParameters_STATUS populates the provided destination RequestBodyMatchConditionParameters_STATUS from our RequestBodyMatchConditionParameters_STATUS
func (parameters *RequestBodyMatchConditionParameters_STATUS) AssignProperties_To_RequestBodyMatchConditionParameters_STATUS(destination *storage.RequestBodyMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for RequestHeader match conditions
type RequestHeaderMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *RequestHeaderMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Selector: Name of Header to be matched
	Selector *string `json:"selector,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *RequestHeaderMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &RequestHeaderMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *RequestHeaderMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.RequestHeaderMatchConditionParameters{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		result.MatchValues = append(result.MatchValues, item)
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		var temp string
		temp = string(*parameters.Operator)
		operator := arm.RequestHeaderMatchConditionParameters_Operator(temp)
		result.Operator = &operator
	}

	// Set property "Selector":
	if parameters.Selector != nil {
		selector := *parameters.Selector
		result.Selector = &selector
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		var temp string
		temp = string(item)
		result.Transforms = append(result.Transforms, arm.Transform(temp))
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		var temp string
		temp = string(*parameters.TypeName)
		typeName := arm.RequestHeaderMatchConditionParameters_TypeName(temp)
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *RequestHeaderMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RequestHeaderMatchConditionParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *RequestHeaderMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RequestHeaderMatchConditionParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RequestHeaderMatchConditionParameters, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := RequestHeaderMatchConditionParameters_Operator(temp)
		parameters.Operator = &operator
	}

	// Set property "Selector":
	if typedInput.Selector != nil {
		selector := *typedInput.Selector
		parameters.Selector = &selector
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := RequestHeaderMatchConditionParameters_TypeName(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_RequestHeaderMatchConditionParameters populates our RequestHeaderMatchConditionParameters from the provided source RequestHeaderMatchConditionParameters
func (parameters *RequestHeaderMatchConditionParameters) AssignProperties_From_RequestHeaderMatchConditionParameters(source *storage.RequestHeaderMatchConditionParameters) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, requestHeaderMatchConditionParameters_Operator_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Selector
	parameters.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, requestHeaderMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RequestHeaderMatchConditionParameters populates the provided destination RequestHeaderMatchConditionParameters from our RequestHeaderMatchConditionParameters
func (parameters *RequestHeaderMatchConditionParameters) AssignProperties_To_RequestHeaderMatchConditionParameters(destination *storage.RequestHeaderMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Selector
	destination.Selector = genruntime.ClonePointerToString(parameters.Selector)

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RequestHeaderMatchConditionParameters_STATUS populates our RequestHeaderMatchConditionParameters from the provided source RequestHeaderMatchConditionParameters_STATUS
func (parameters *RequestHeaderMatchConditionParameters) Initialize_From_RequestHeaderMatchConditionParameters_STATUS(source *RequestHeaderMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := genruntime.ToEnum(string(*source.Operator), requestHeaderMatchConditionParameters_Operator_Values)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Selector
	parameters.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := genruntime.ToEnum(string(transformItem), transform_Values)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := genruntime.ToEnum(string(*source.TypeName), requestHeaderMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for RequestHeader match conditions
type RequestHeaderMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *RequestHeaderMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Selector: Name of Header to be matched
	Selector *string `json:"selector,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                                     `json:"transforms,omitempty"`
	TypeName   *RequestHeaderMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &RequestHeaderMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *RequestHeaderMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RequestHeaderMatchConditionParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *RequestHeaderMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RequestHeaderMatchConditionParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RequestHeaderMatchConditionParameters_STATUS, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := RequestHeaderMatchConditionParameters_Operator_STATUS(temp)
		parameters.Operator = &operator
	}

	// Set property "Selector":
	if typedInput.Selector != nil {
		selector := *typedInput.Selector
		parameters.Selector = &selector
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform_STATUS(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := RequestHeaderMatchConditionParameters_TypeName_STATUS(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_RequestHeaderMatchConditionParameters_STATUS populates our RequestHeaderMatchConditionParameters_STATUS from the provided source RequestHeaderMatchConditionParameters_STATUS
func (parameters *RequestHeaderMatchConditionParameters_STATUS) AssignProperties_From_RequestHeaderMatchConditionParameters_STATUS(source *storage.RequestHeaderMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, requestHeaderMatchConditionParameters_Operator_STATUS_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Selector
	parameters.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_STATUS_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, requestHeaderMatchConditionParameters_TypeName_STATUS_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RequestHeaderMatchConditionParameters_STATUS populates the provided destination RequestHeaderMatchConditionParameters_STATUS from our RequestHeaderMatchConditionParameters_STATUS
func (parameters *RequestHeaderMatchConditionParameters_STATUS) AssignProperties_To_RequestHeaderMatchConditionParameters_STATUS(destination *storage.RequestHeaderMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Selector
	destination.Selector = genruntime.ClonePointerToString(parameters.Selector)

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for RequestMethod match conditions
type RequestMethodMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []RequestMethodMatchConditionParameters_MatchValues `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *RequestMethodMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *RequestMethodMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &RequestMethodMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *RequestMethodMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.RequestMethodMatchConditionParameters{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		var temp string
		temp = string(item)
		result.MatchValues = append(result.MatchValues, arm.RequestMethodMatchConditionParameters_MatchValues(temp))
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		var temp string
		temp = string(*parameters.Operator)
		operator := arm.RequestMethodMatchConditionParameters_Operator(temp)
		result.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		var temp string
		temp = string(item)
		result.Transforms = append(result.Transforms, arm.Transform(temp))
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		var temp string
		temp = string(*parameters.TypeName)
		typeName := arm.RequestMethodMatchConditionParameters_TypeName(temp)
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *RequestMethodMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RequestMethodMatchConditionParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *RequestMethodMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RequestMethodMatchConditionParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RequestMethodMatchConditionParameters, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		var temp string
		temp = string(item)
		parameters.MatchValues = append(parameters.MatchValues, RequestMethodMatchConditionParameters_MatchValues(temp))
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := RequestMethodMatchConditionParameters_Operator(temp)
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := RequestMethodMatchConditionParameters_TypeName(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_RequestMethodMatchConditionParameters populates our RequestMethodMatchConditionParameters from the provided source RequestMethodMatchConditionParameters
func (parameters *RequestMethodMatchConditionParameters) AssignProperties_From_RequestMethodMatchConditionParameters(source *storage.RequestMethodMatchConditionParameters) error {

	// MatchValues
	if source.MatchValues != nil {
		matchValueList := make([]RequestMethodMatchConditionParameters_MatchValues, len(source.MatchValues))
		for matchValueIndex, matchValueItem := range source.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValueList[matchValueIndex] = genruntime.ToEnum(matchValueItem, requestMethodMatchConditionParameters_MatchValues_Values)
		}
		parameters.MatchValues = matchValueList
	} else {
		parameters.MatchValues = nil
	}

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, requestMethodMatchConditionParameters_Operator_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, requestMethodMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RequestMethodMatchConditionParameters populates the provided destination RequestMethodMatchConditionParameters from our RequestMethodMatchConditionParameters
func (parameters *RequestMethodMatchConditionParameters) AssignProperties_To_RequestMethodMatchConditionParameters(destination *storage.RequestMethodMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	if parameters.MatchValues != nil {
		matchValueList := make([]string, len(parameters.MatchValues))
		for matchValueIndex, matchValueItem := range parameters.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValueList[matchValueIndex] = string(matchValueItem)
		}
		destination.MatchValues = matchValueList
	} else {
		destination.MatchValues = nil
	}

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RequestMethodMatchConditionParameters_STATUS populates our RequestMethodMatchConditionParameters from the provided source RequestMethodMatchConditionParameters_STATUS
func (parameters *RequestMethodMatchConditionParameters) Initialize_From_RequestMethodMatchConditionParameters_STATUS(source *RequestMethodMatchConditionParameters_STATUS) error {

	// MatchValues
	if source.MatchValues != nil {
		matchValueList := make([]RequestMethodMatchConditionParameters_MatchValues, len(source.MatchValues))
		for matchValueIndex, matchValueItem := range source.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValue := genruntime.ToEnum(string(matchValueItem), requestMethodMatchConditionParameters_MatchValues_Values)
			matchValueList[matchValueIndex] = matchValue
		}
		parameters.MatchValues = matchValueList
	} else {
		parameters.MatchValues = nil
	}

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := genruntime.ToEnum(string(*source.Operator), requestMethodMatchConditionParameters_Operator_Values)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := genruntime.ToEnum(string(transformItem), transform_Values)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := genruntime.ToEnum(string(*source.TypeName), requestMethodMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for RequestMethod match conditions
type RequestMethodMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []RequestMethodMatchConditionParameters_MatchValues_STATUS `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *RequestMethodMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                                     `json:"transforms,omitempty"`
	TypeName   *RequestMethodMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &RequestMethodMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *RequestMethodMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RequestMethodMatchConditionParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *RequestMethodMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RequestMethodMatchConditionParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RequestMethodMatchConditionParameters_STATUS, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		var temp string
		temp = string(item)
		parameters.MatchValues = append(parameters.MatchValues, RequestMethodMatchConditionParameters_MatchValues_STATUS(temp))
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := RequestMethodMatchConditionParameters_Operator_STATUS(temp)
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform_STATUS(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := RequestMethodMatchConditionParameters_TypeName_STATUS(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_RequestMethodMatchConditionParameters_STATUS populates our RequestMethodMatchConditionParameters_STATUS from the provided source RequestMethodMatchConditionParameters_STATUS
func (parameters *RequestMethodMatchConditionParameters_STATUS) AssignProperties_From_RequestMethodMatchConditionParameters_STATUS(source *storage.RequestMethodMatchConditionParameters_STATUS) error {

	// MatchValues
	if source.MatchValues != nil {
		matchValueList := make([]RequestMethodMatchConditionParameters_MatchValues_STATUS, len(source.MatchValues))
		for matchValueIndex, matchValueItem := range source.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValueList[matchValueIndex] = genruntime.ToEnum(matchValueItem, requestMethodMatchConditionParameters_MatchValues_STATUS_Values)
		}
		parameters.MatchValues = matchValueList
	} else {
		parameters.MatchValues = nil
	}

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, requestMethodMatchConditionParameters_Operator_STATUS_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_STATUS_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, requestMethodMatchConditionParameters_TypeName_STATUS_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RequestMethodMatchConditionParameters_STATUS populates the provided destination RequestMethodMatchConditionParameters_STATUS from our RequestMethodMatchConditionParameters_STATUS
func (parameters *RequestMethodMatchConditionParameters_STATUS) AssignProperties_To_RequestMethodMatchConditionParameters_STATUS(destination *storage.RequestMethodMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	if parameters.MatchValues != nil {
		matchValueList := make([]string, len(parameters.MatchValues))
		for matchValueIndex, matchValueItem := range parameters.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValueList[matchValueIndex] = string(matchValueItem)
		}
		destination.MatchValues = matchValueList
	} else {
		destination.MatchValues = nil
	}

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for RequestScheme match conditions
type RequestSchemeMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []RequestSchemeMatchConditionParameters_MatchValues `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *RequestSchemeMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *RequestSchemeMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &RequestSchemeMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *RequestSchemeMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.RequestSchemeMatchConditionParameters{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		var temp string
		temp = string(item)
		result.MatchValues = append(result.MatchValues, arm.RequestSchemeMatchConditionParameters_MatchValues(temp))
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		var temp string
		temp = string(*parameters.Operator)
		operator := arm.RequestSchemeMatchConditionParameters_Operator(temp)
		result.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		var temp string
		temp = string(item)
		result.Transforms = append(result.Transforms, arm.Transform(temp))
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		var temp string
		temp = string(*parameters.TypeName)
		typeName := arm.RequestSchemeMatchConditionParameters_TypeName(temp)
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *RequestSchemeMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RequestSchemeMatchConditionParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *RequestSchemeMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RequestSchemeMatchConditionParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RequestSchemeMatchConditionParameters, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		var temp string
		temp = string(item)
		parameters.MatchValues = append(parameters.MatchValues, RequestSchemeMatchConditionParameters_MatchValues(temp))
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := RequestSchemeMatchConditionParameters_Operator(temp)
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := RequestSchemeMatchConditionParameters_TypeName(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_RequestSchemeMatchConditionParameters populates our RequestSchemeMatchConditionParameters from the provided source RequestSchemeMatchConditionParameters
func (parameters *RequestSchemeMatchConditionParameters) AssignProperties_From_RequestSchemeMatchConditionParameters(source *storage.RequestSchemeMatchConditionParameters) error {

	// MatchValues
	if source.MatchValues != nil {
		matchValueList := make([]RequestSchemeMatchConditionParameters_MatchValues, len(source.MatchValues))
		for matchValueIndex, matchValueItem := range source.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValueList[matchValueIndex] = genruntime.ToEnum(matchValueItem, requestSchemeMatchConditionParameters_MatchValues_Values)
		}
		parameters.MatchValues = matchValueList
	} else {
		parameters.MatchValues = nil
	}

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, requestSchemeMatchConditionParameters_Operator_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, requestSchemeMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RequestSchemeMatchConditionParameters populates the provided destination RequestSchemeMatchConditionParameters from our RequestSchemeMatchConditionParameters
func (parameters *RequestSchemeMatchConditionParameters) AssignProperties_To_RequestSchemeMatchConditionParameters(destination *storage.RequestSchemeMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	if parameters.MatchValues != nil {
		matchValueList := make([]string, len(parameters.MatchValues))
		for matchValueIndex, matchValueItem := range parameters.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValueList[matchValueIndex] = string(matchValueItem)
		}
		destination.MatchValues = matchValueList
	} else {
		destination.MatchValues = nil
	}

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RequestSchemeMatchConditionParameters_STATUS populates our RequestSchemeMatchConditionParameters from the provided source RequestSchemeMatchConditionParameters_STATUS
func (parameters *RequestSchemeMatchConditionParameters) Initialize_From_RequestSchemeMatchConditionParameters_STATUS(source *RequestSchemeMatchConditionParameters_STATUS) error {

	// MatchValues
	if source.MatchValues != nil {
		matchValueList := make([]RequestSchemeMatchConditionParameters_MatchValues, len(source.MatchValues))
		for matchValueIndex, matchValueItem := range source.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValue := genruntime.ToEnum(string(matchValueItem), requestSchemeMatchConditionParameters_MatchValues_Values)
			matchValueList[matchValueIndex] = matchValue
		}
		parameters.MatchValues = matchValueList
	} else {
		parameters.MatchValues = nil
	}

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := genruntime.ToEnum(string(*source.Operator), requestSchemeMatchConditionParameters_Operator_Values)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := genruntime.ToEnum(string(transformItem), transform_Values)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := genruntime.ToEnum(string(*source.TypeName), requestSchemeMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for RequestScheme match conditions
type RequestSchemeMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []RequestSchemeMatchConditionParameters_MatchValues_STATUS `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *RequestSchemeMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                                     `json:"transforms,omitempty"`
	TypeName   *RequestSchemeMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &RequestSchemeMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *RequestSchemeMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RequestSchemeMatchConditionParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *RequestSchemeMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RequestSchemeMatchConditionParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RequestSchemeMatchConditionParameters_STATUS, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		var temp string
		temp = string(item)
		parameters.MatchValues = append(parameters.MatchValues, RequestSchemeMatchConditionParameters_MatchValues_STATUS(temp))
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := RequestSchemeMatchConditionParameters_Operator_STATUS(temp)
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform_STATUS(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := RequestSchemeMatchConditionParameters_TypeName_STATUS(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_RequestSchemeMatchConditionParameters_STATUS populates our RequestSchemeMatchConditionParameters_STATUS from the provided source RequestSchemeMatchConditionParameters_STATUS
func (parameters *RequestSchemeMatchConditionParameters_STATUS) AssignProperties_From_RequestSchemeMatchConditionParameters_STATUS(source *storage.RequestSchemeMatchConditionParameters_STATUS) error {

	// MatchValues
	if source.MatchValues != nil {
		matchValueList := make([]RequestSchemeMatchConditionParameters_MatchValues_STATUS, len(source.MatchValues))
		for matchValueIndex, matchValueItem := range source.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValueList[matchValueIndex] = genruntime.ToEnum(matchValueItem, requestSchemeMatchConditionParameters_MatchValues_STATUS_Values)
		}
		parameters.MatchValues = matchValueList
	} else {
		parameters.MatchValues = nil
	}

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, requestSchemeMatchConditionParameters_Operator_STATUS_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_STATUS_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, requestSchemeMatchConditionParameters_TypeName_STATUS_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RequestSchemeMatchConditionParameters_STATUS populates the provided destination RequestSchemeMatchConditionParameters_STATUS from our RequestSchemeMatchConditionParameters_STATUS
func (parameters *RequestSchemeMatchConditionParameters_STATUS) AssignProperties_To_RequestSchemeMatchConditionParameters_STATUS(destination *storage.RequestSchemeMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	if parameters.MatchValues != nil {
		matchValueList := make([]string, len(parameters.MatchValues))
		for matchValueIndex, matchValueItem := range parameters.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValueList[matchValueIndex] = string(matchValueItem)
		}
		destination.MatchValues = matchValueList
	} else {
		destination.MatchValues = nil
	}

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for RequestUri match conditions
type RequestUriMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *RequestUriMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *RequestUriMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &RequestUriMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *RequestUriMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.RequestUriMatchConditionParameters{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		result.MatchValues = append(result.MatchValues, item)
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		var temp string
		temp = string(*parameters.Operator)
		operator := arm.RequestUriMatchConditionParameters_Operator(temp)
		result.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		var temp string
		temp = string(item)
		result.Transforms = append(result.Transforms, arm.Transform(temp))
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		var temp string
		temp = string(*parameters.TypeName)
		typeName := arm.RequestUriMatchConditionParameters_TypeName(temp)
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *RequestUriMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RequestUriMatchConditionParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *RequestUriMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RequestUriMatchConditionParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RequestUriMatchConditionParameters, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := RequestUriMatchConditionParameters_Operator(temp)
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := RequestUriMatchConditionParameters_TypeName(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_RequestUriMatchConditionParameters populates our RequestUriMatchConditionParameters from the provided source RequestUriMatchConditionParameters
func (parameters *RequestUriMatchConditionParameters) AssignProperties_From_RequestUriMatchConditionParameters(source *storage.RequestUriMatchConditionParameters) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, requestUriMatchConditionParameters_Operator_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, requestUriMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RequestUriMatchConditionParameters populates the provided destination RequestUriMatchConditionParameters from our RequestUriMatchConditionParameters
func (parameters *RequestUriMatchConditionParameters) AssignProperties_To_RequestUriMatchConditionParameters(destination *storage.RequestUriMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RequestUriMatchConditionParameters_STATUS populates our RequestUriMatchConditionParameters from the provided source RequestUriMatchConditionParameters_STATUS
func (parameters *RequestUriMatchConditionParameters) Initialize_From_RequestUriMatchConditionParameters_STATUS(source *RequestUriMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := genruntime.ToEnum(string(*source.Operator), requestUriMatchConditionParameters_Operator_Values)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := genruntime.ToEnum(string(transformItem), transform_Values)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := genruntime.ToEnum(string(*source.TypeName), requestUriMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for RequestUri match conditions
type RequestUriMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *RequestUriMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                                  `json:"transforms,omitempty"`
	TypeName   *RequestUriMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &RequestUriMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *RequestUriMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RequestUriMatchConditionParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *RequestUriMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RequestUriMatchConditionParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RequestUriMatchConditionParameters_STATUS, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := RequestUriMatchConditionParameters_Operator_STATUS(temp)
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform_STATUS(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := RequestUriMatchConditionParameters_TypeName_STATUS(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_RequestUriMatchConditionParameters_STATUS populates our RequestUriMatchConditionParameters_STATUS from the provided source RequestUriMatchConditionParameters_STATUS
func (parameters *RequestUriMatchConditionParameters_STATUS) AssignProperties_From_RequestUriMatchConditionParameters_STATUS(source *storage.RequestUriMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, requestUriMatchConditionParameters_Operator_STATUS_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_STATUS_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, requestUriMatchConditionParameters_TypeName_STATUS_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RequestUriMatchConditionParameters_STATUS populates the provided destination RequestUriMatchConditionParameters_STATUS from our RequestUriMatchConditionParameters_STATUS
func (parameters *RequestUriMatchConditionParameters_STATUS) AssignProperties_To_RequestUriMatchConditionParameters_STATUS(destination *storage.RequestUriMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for the route configuration override action.
type RouteConfigurationOverrideActionParameters struct {
	// CacheConfiguration: The caching configuration associated with this rule. To disable caching, do not provide a
	// cacheConfiguration object.
	CacheConfiguration *CacheConfiguration `json:"cacheConfiguration,omitempty"`

	// OriginGroupOverride: A reference to the origin group override configuration. Leave empty to use the default origin group
	// on route.
	OriginGroupOverride *OriginGroupOverride `json:"originGroupOverride,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *RouteConfigurationOverrideActionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &RouteConfigurationOverrideActionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *RouteConfigurationOverrideActionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.RouteConfigurationOverrideActionParameters{}

	// Set property "CacheConfiguration":
	if parameters.CacheConfiguration != nil {
		cacheConfiguration_ARM, err := (*parameters.CacheConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		cacheConfiguration := *cacheConfiguration_ARM.(*arm.CacheConfiguration)
		result.CacheConfiguration = &cacheConfiguration
	}

	// Set property "OriginGroupOverride":
	if parameters.OriginGroupOverride != nil {
		originGroupOverride_ARM, err := (*parameters.OriginGroupOverride).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		originGroupOverride := *originGroupOverride_ARM.(*arm.OriginGroupOverride)
		result.OriginGroupOverride = &originGroupOverride
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		var temp string
		temp = string(*parameters.TypeName)
		typeName := arm.RouteConfigurationOverrideActionParameters_TypeName(temp)
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *RouteConfigurationOverrideActionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RouteConfigurationOverrideActionParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *RouteConfigurationOverrideActionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RouteConfigurationOverrideActionParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RouteConfigurationOverrideActionParameters, got %T", armInput)
	}

	// Set property "CacheConfiguration":
	if typedInput.CacheConfiguration != nil {
		var cacheConfiguration1 CacheConfiguration
		err := cacheConfiguration1.PopulateFromARM(owner, *typedInput.CacheConfiguration)
		if err != nil {
			return err
		}
		cacheConfiguration := cacheConfiguration1
		parameters.CacheConfiguration = &cacheConfiguration
	}

	// Set property "OriginGroupOverride":
	if typedInput.OriginGroupOverride != nil {
		var originGroupOverride1 OriginGroupOverride
		err := originGroupOverride1.PopulateFromARM(owner, *typedInput.OriginGroupOverride)
		if err != nil {
			return err
		}
		originGroupOverride := originGroupOverride1
		parameters.OriginGroupOverride = &originGroupOverride
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := RouteConfigurationOverrideActionParameters_TypeName(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_RouteConfigurationOverrideActionParameters populates our RouteConfigurationOverrideActionParameters from the provided source RouteConfigurationOverrideActionParameters
func (parameters *RouteConfigurationOverrideActionParameters) AssignProperties_From_RouteConfigurationOverrideActionParameters(source *storage.RouteConfigurationOverrideActionParameters) error {

	// CacheConfiguration
	if source.CacheConfiguration != nil {
		var cacheConfiguration CacheConfiguration
		err := cacheConfiguration.AssignProperties_From_CacheConfiguration(source.CacheConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CacheConfiguration() to populate field CacheConfiguration")
		}
		parameters.CacheConfiguration = &cacheConfiguration
	} else {
		parameters.CacheConfiguration = nil
	}

	// OriginGroupOverride
	if source.OriginGroupOverride != nil {
		var originGroupOverride OriginGroupOverride
		err := originGroupOverride.AssignProperties_From_OriginGroupOverride(source.OriginGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OriginGroupOverride() to populate field OriginGroupOverride")
		}
		parameters.OriginGroupOverride = &originGroupOverride
	} else {
		parameters.OriginGroupOverride = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, routeConfigurationOverrideActionParameters_TypeName_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RouteConfigurationOverrideActionParameters populates the provided destination RouteConfigurationOverrideActionParameters from our RouteConfigurationOverrideActionParameters
func (parameters *RouteConfigurationOverrideActionParameters) AssignProperties_To_RouteConfigurationOverrideActionParameters(destination *storage.RouteConfigurationOverrideActionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CacheConfiguration
	if parameters.CacheConfiguration != nil {
		var cacheConfiguration storage.CacheConfiguration
		err := parameters.CacheConfiguration.AssignProperties_To_CacheConfiguration(&cacheConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CacheConfiguration() to populate field CacheConfiguration")
		}
		destination.CacheConfiguration = &cacheConfiguration
	} else {
		destination.CacheConfiguration = nil
	}

	// OriginGroupOverride
	if parameters.OriginGroupOverride != nil {
		var originGroupOverride storage.OriginGroupOverride
		err := parameters.OriginGroupOverride.AssignProperties_To_OriginGroupOverride(&originGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OriginGroupOverride() to populate field OriginGroupOverride")
		}
		destination.OriginGroupOverride = &originGroupOverride
	} else {
		destination.OriginGroupOverride = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RouteConfigurationOverrideActionParameters_STATUS populates our RouteConfigurationOverrideActionParameters from the provided source RouteConfigurationOverrideActionParameters_STATUS
func (parameters *RouteConfigurationOverrideActionParameters) Initialize_From_RouteConfigurationOverrideActionParameters_STATUS(source *RouteConfigurationOverrideActionParameters_STATUS) error {

	// CacheConfiguration
	if source.CacheConfiguration != nil {
		var cacheConfiguration CacheConfiguration
		err := cacheConfiguration.Initialize_From_CacheConfiguration_STATUS(source.CacheConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_CacheConfiguration_STATUS() to populate field CacheConfiguration")
		}
		parameters.CacheConfiguration = &cacheConfiguration
	} else {
		parameters.CacheConfiguration = nil
	}

	// OriginGroupOverride
	if source.OriginGroupOverride != nil {
		var originGroupOverride OriginGroupOverride
		err := originGroupOverride.Initialize_From_OriginGroupOverride_STATUS(source.OriginGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_OriginGroupOverride_STATUS() to populate field OriginGroupOverride")
		}
		parameters.OriginGroupOverride = &originGroupOverride
	} else {
		parameters.OriginGroupOverride = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := genruntime.ToEnum(string(*source.TypeName), routeConfigurationOverrideActionParameters_TypeName_Values)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for the route configuration override action.
type RouteConfigurationOverrideActionParameters_STATUS struct {
	// CacheConfiguration: The caching configuration associated with this rule. To disable caching, do not provide a
	// cacheConfiguration object.
	CacheConfiguration *CacheConfiguration_STATUS `json:"cacheConfiguration,omitempty"`

	// OriginGroupOverride: A reference to the origin group override configuration. Leave empty to use the default origin group
	// on route.
	OriginGroupOverride *OriginGroupOverride_STATUS                                 `json:"originGroupOverride,omitempty"`
	TypeName            *RouteConfigurationOverrideActionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &RouteConfigurationOverrideActionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *RouteConfigurationOverrideActionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RouteConfigurationOverrideActionParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *RouteConfigurationOverrideActionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RouteConfigurationOverrideActionParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RouteConfigurationOverrideActionParameters_STATUS, got %T", armInput)
	}

	// Set property "CacheConfiguration":
	if typedInput.CacheConfiguration != nil {
		var cacheConfiguration1 CacheConfiguration_STATUS
		err := cacheConfiguration1.PopulateFromARM(owner, *typedInput.CacheConfiguration)
		if err != nil {
			return err
		}
		cacheConfiguration := cacheConfiguration1
		parameters.CacheConfiguration = &cacheConfiguration
	}

	// Set property "OriginGroupOverride":
	if typedInput.OriginGroupOverride != nil {
		var originGroupOverride1 OriginGroupOverride_STATUS
		err := originGroupOverride1.PopulateFromARM(owner, *typedInput.OriginGroupOverride)
		if err != nil {
			return err
		}
		originGroupOverride := originGroupOverride1
		parameters.OriginGroupOverride = &originGroupOverride
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := RouteConfigurationOverrideActionParameters_TypeName_STATUS(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_RouteConfigurationOverrideActionParameters_STATUS populates our RouteConfigurationOverrideActionParameters_STATUS from the provided source RouteConfigurationOverrideActionParameters_STATUS
func (parameters *RouteConfigurationOverrideActionParameters_STATUS) AssignProperties_From_RouteConfigurationOverrideActionParameters_STATUS(source *storage.RouteConfigurationOverrideActionParameters_STATUS) error {

	// CacheConfiguration
	if source.CacheConfiguration != nil {
		var cacheConfiguration CacheConfiguration_STATUS
		err := cacheConfiguration.AssignProperties_From_CacheConfiguration_STATUS(source.CacheConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CacheConfiguration_STATUS() to populate field CacheConfiguration")
		}
		parameters.CacheConfiguration = &cacheConfiguration
	} else {
		parameters.CacheConfiguration = nil
	}

	// OriginGroupOverride
	if source.OriginGroupOverride != nil {
		var originGroupOverride OriginGroupOverride_STATUS
		err := originGroupOverride.AssignProperties_From_OriginGroupOverride_STATUS(source.OriginGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OriginGroupOverride_STATUS() to populate field OriginGroupOverride")
		}
		parameters.OriginGroupOverride = &originGroupOverride
	} else {
		parameters.OriginGroupOverride = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, routeConfigurationOverrideActionParameters_TypeName_STATUS_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RouteConfigurationOverrideActionParameters_STATUS populates the provided destination RouteConfigurationOverrideActionParameters_STATUS from our RouteConfigurationOverrideActionParameters_STATUS
func (parameters *RouteConfigurationOverrideActionParameters_STATUS) AssignProperties_To_RouteConfigurationOverrideActionParameters_STATUS(destination *storage.RouteConfigurationOverrideActionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CacheConfiguration
	if parameters.CacheConfiguration != nil {
		var cacheConfiguration storage.CacheConfiguration_STATUS
		err := parameters.CacheConfiguration.AssignProperties_To_CacheConfiguration_STATUS(&cacheConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CacheConfiguration_STATUS() to populate field CacheConfiguration")
		}
		destination.CacheConfiguration = &cacheConfiguration
	} else {
		destination.CacheConfiguration = nil
	}

	// OriginGroupOverride
	if parameters.OriginGroupOverride != nil {
		var originGroupOverride storage.OriginGroupOverride_STATUS
		err := parameters.OriginGroupOverride.AssignProperties_To_OriginGroupOverride_STATUS(&originGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OriginGroupOverride_STATUS() to populate field OriginGroupOverride")
		}
		destination.OriginGroupOverride = &originGroupOverride
	} else {
		destination.OriginGroupOverride = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for ServerPort match conditions
type ServerPortMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *ServerPortMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *ServerPortMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &ServerPortMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *ServerPortMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.ServerPortMatchConditionParameters{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		result.MatchValues = append(result.MatchValues, item)
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		var temp string
		temp = string(*parameters.Operator)
		operator := arm.ServerPortMatchConditionParameters_Operator(temp)
		result.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		var temp string
		temp = string(item)
		result.Transforms = append(result.Transforms, arm.Transform(temp))
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		var temp string
		temp = string(*parameters.TypeName)
		typeName := arm.ServerPortMatchConditionParameters_TypeName(temp)
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *ServerPortMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ServerPortMatchConditionParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *ServerPortMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ServerPortMatchConditionParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ServerPortMatchConditionParameters, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := ServerPortMatchConditionParameters_Operator(temp)
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := ServerPortMatchConditionParameters_TypeName(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_ServerPortMatchConditionParameters populates our ServerPortMatchConditionParameters from the provided source ServerPortMatchConditionParameters
func (parameters *ServerPortMatchConditionParameters) AssignProperties_From_ServerPortMatchConditionParameters(source *storage.ServerPortMatchConditionParameters) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, serverPortMatchConditionParameters_Operator_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, serverPortMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ServerPortMatchConditionParameters populates the provided destination ServerPortMatchConditionParameters from our ServerPortMatchConditionParameters
func (parameters *ServerPortMatchConditionParameters) AssignProperties_To_ServerPortMatchConditionParameters(destination *storage.ServerPortMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ServerPortMatchConditionParameters_STATUS populates our ServerPortMatchConditionParameters from the provided source ServerPortMatchConditionParameters_STATUS
func (parameters *ServerPortMatchConditionParameters) Initialize_From_ServerPortMatchConditionParameters_STATUS(source *ServerPortMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := genruntime.ToEnum(string(*source.Operator), serverPortMatchConditionParameters_Operator_Values)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := genruntime.ToEnum(string(transformItem), transform_Values)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := genruntime.ToEnum(string(*source.TypeName), serverPortMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for ServerPort match conditions
type ServerPortMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *ServerPortMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                                  `json:"transforms,omitempty"`
	TypeName   *ServerPortMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &ServerPortMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *ServerPortMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ServerPortMatchConditionParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *ServerPortMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ServerPortMatchConditionParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ServerPortMatchConditionParameters_STATUS, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := ServerPortMatchConditionParameters_Operator_STATUS(temp)
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform_STATUS(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := ServerPortMatchConditionParameters_TypeName_STATUS(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_ServerPortMatchConditionParameters_STATUS populates our ServerPortMatchConditionParameters_STATUS from the provided source ServerPortMatchConditionParameters_STATUS
func (parameters *ServerPortMatchConditionParameters_STATUS) AssignProperties_From_ServerPortMatchConditionParameters_STATUS(source *storage.ServerPortMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, serverPortMatchConditionParameters_Operator_STATUS_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_STATUS_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, serverPortMatchConditionParameters_TypeName_STATUS_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ServerPortMatchConditionParameters_STATUS populates the provided destination ServerPortMatchConditionParameters_STATUS from our ServerPortMatchConditionParameters_STATUS
func (parameters *ServerPortMatchConditionParameters_STATUS) AssignProperties_To_ServerPortMatchConditionParameters_STATUS(destination *storage.ServerPortMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for SocketAddress match conditions
type SocketAddrMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *SocketAddrMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *SocketAddrMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &SocketAddrMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *SocketAddrMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.SocketAddrMatchConditionParameters{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		result.MatchValues = append(result.MatchValues, item)
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		var temp string
		temp = string(*parameters.Operator)
		operator := arm.SocketAddrMatchConditionParameters_Operator(temp)
		result.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		var temp string
		temp = string(item)
		result.Transforms = append(result.Transforms, arm.Transform(temp))
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		var temp string
		temp = string(*parameters.TypeName)
		typeName := arm.SocketAddrMatchConditionParameters_TypeName(temp)
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *SocketAddrMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SocketAddrMatchConditionParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *SocketAddrMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SocketAddrMatchConditionParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SocketAddrMatchConditionParameters, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := SocketAddrMatchConditionParameters_Operator(temp)
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := SocketAddrMatchConditionParameters_TypeName(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_SocketAddrMatchConditionParameters populates our SocketAddrMatchConditionParameters from the provided source SocketAddrMatchConditionParameters
func (parameters *SocketAddrMatchConditionParameters) AssignProperties_From_SocketAddrMatchConditionParameters(source *storage.SocketAddrMatchConditionParameters) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, socketAddrMatchConditionParameters_Operator_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, socketAddrMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SocketAddrMatchConditionParameters populates the provided destination SocketAddrMatchConditionParameters from our SocketAddrMatchConditionParameters
func (parameters *SocketAddrMatchConditionParameters) AssignProperties_To_SocketAddrMatchConditionParameters(destination *storage.SocketAddrMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_SocketAddrMatchConditionParameters_STATUS populates our SocketAddrMatchConditionParameters from the provided source SocketAddrMatchConditionParameters_STATUS
func (parameters *SocketAddrMatchConditionParameters) Initialize_From_SocketAddrMatchConditionParameters_STATUS(source *SocketAddrMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := genruntime.ToEnum(string(*source.Operator), socketAddrMatchConditionParameters_Operator_Values)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := genruntime.ToEnum(string(transformItem), transform_Values)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := genruntime.ToEnum(string(*source.TypeName), socketAddrMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for SocketAddress match conditions
type SocketAddrMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *SocketAddrMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                                  `json:"transforms,omitempty"`
	TypeName   *SocketAddrMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &SocketAddrMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *SocketAddrMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SocketAddrMatchConditionParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *SocketAddrMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SocketAddrMatchConditionParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SocketAddrMatchConditionParameters_STATUS, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := SocketAddrMatchConditionParameters_Operator_STATUS(temp)
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform_STATUS(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := SocketAddrMatchConditionParameters_TypeName_STATUS(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_SocketAddrMatchConditionParameters_STATUS populates our SocketAddrMatchConditionParameters_STATUS from the provided source SocketAddrMatchConditionParameters_STATUS
func (parameters *SocketAddrMatchConditionParameters_STATUS) AssignProperties_From_SocketAddrMatchConditionParameters_STATUS(source *storage.SocketAddrMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, socketAddrMatchConditionParameters_Operator_STATUS_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_STATUS_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, socketAddrMatchConditionParameters_TypeName_STATUS_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SocketAddrMatchConditionParameters_STATUS populates the provided destination SocketAddrMatchConditionParameters_STATUS from our SocketAddrMatchConditionParameters_STATUS
func (parameters *SocketAddrMatchConditionParameters_STATUS) AssignProperties_To_SocketAddrMatchConditionParameters_STATUS(destination *storage.SocketAddrMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for SslProtocol match conditions
type SslProtocolMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []SslProtocol `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *SslProtocolMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *SslProtocolMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &SslProtocolMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *SslProtocolMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.SslProtocolMatchConditionParameters{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		var temp string
		temp = string(item)
		result.MatchValues = append(result.MatchValues, arm.SslProtocol(temp))
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		var temp string
		temp = string(*parameters.Operator)
		operator := arm.SslProtocolMatchConditionParameters_Operator(temp)
		result.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		var temp string
		temp = string(item)
		result.Transforms = append(result.Transforms, arm.Transform(temp))
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		var temp string
		temp = string(*parameters.TypeName)
		typeName := arm.SslProtocolMatchConditionParameters_TypeName(temp)
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *SslProtocolMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SslProtocolMatchConditionParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *SslProtocolMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SslProtocolMatchConditionParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SslProtocolMatchConditionParameters, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		var temp string
		temp = string(item)
		parameters.MatchValues = append(parameters.MatchValues, SslProtocol(temp))
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := SslProtocolMatchConditionParameters_Operator(temp)
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := SslProtocolMatchConditionParameters_TypeName(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_SslProtocolMatchConditionParameters populates our SslProtocolMatchConditionParameters from the provided source SslProtocolMatchConditionParameters
func (parameters *SslProtocolMatchConditionParameters) AssignProperties_From_SslProtocolMatchConditionParameters(source *storage.SslProtocolMatchConditionParameters) error {

	// MatchValues
	if source.MatchValues != nil {
		matchValueList := make([]SslProtocol, len(source.MatchValues))
		for matchValueIndex, matchValueItem := range source.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValueList[matchValueIndex] = genruntime.ToEnum(matchValueItem, sslProtocol_Values)
		}
		parameters.MatchValues = matchValueList
	} else {
		parameters.MatchValues = nil
	}

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, sslProtocolMatchConditionParameters_Operator_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, sslProtocolMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SslProtocolMatchConditionParameters populates the provided destination SslProtocolMatchConditionParameters from our SslProtocolMatchConditionParameters
func (parameters *SslProtocolMatchConditionParameters) AssignProperties_To_SslProtocolMatchConditionParameters(destination *storage.SslProtocolMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	if parameters.MatchValues != nil {
		matchValueList := make([]string, len(parameters.MatchValues))
		for matchValueIndex, matchValueItem := range parameters.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValueList[matchValueIndex] = string(matchValueItem)
		}
		destination.MatchValues = matchValueList
	} else {
		destination.MatchValues = nil
	}

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_SslProtocolMatchConditionParameters_STATUS populates our SslProtocolMatchConditionParameters from the provided source SslProtocolMatchConditionParameters_STATUS
func (parameters *SslProtocolMatchConditionParameters) Initialize_From_SslProtocolMatchConditionParameters_STATUS(source *SslProtocolMatchConditionParameters_STATUS) error {

	// MatchValues
	if source.MatchValues != nil {
		matchValueList := make([]SslProtocol, len(source.MatchValues))
		for matchValueIndex, matchValueItem := range source.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValue := genruntime.ToEnum(string(matchValueItem), sslProtocol_Values)
			matchValueList[matchValueIndex] = matchValue
		}
		parameters.MatchValues = matchValueList
	} else {
		parameters.MatchValues = nil
	}

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := genruntime.ToEnum(string(*source.Operator), sslProtocolMatchConditionParameters_Operator_Values)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := genruntime.ToEnum(string(transformItem), transform_Values)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := genruntime.ToEnum(string(*source.TypeName), sslProtocolMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for SslProtocol match conditions
type SslProtocolMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []SslProtocol_STATUS `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *SslProtocolMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                                   `json:"transforms,omitempty"`
	TypeName   *SslProtocolMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &SslProtocolMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *SslProtocolMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SslProtocolMatchConditionParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *SslProtocolMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SslProtocolMatchConditionParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SslProtocolMatchConditionParameters_STATUS, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		var temp string
		temp = string(item)
		parameters.MatchValues = append(parameters.MatchValues, SslProtocol_STATUS(temp))
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := SslProtocolMatchConditionParameters_Operator_STATUS(temp)
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform_STATUS(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := SslProtocolMatchConditionParameters_TypeName_STATUS(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_SslProtocolMatchConditionParameters_STATUS populates our SslProtocolMatchConditionParameters_STATUS from the provided source SslProtocolMatchConditionParameters_STATUS
func (parameters *SslProtocolMatchConditionParameters_STATUS) AssignProperties_From_SslProtocolMatchConditionParameters_STATUS(source *storage.SslProtocolMatchConditionParameters_STATUS) error {

	// MatchValues
	if source.MatchValues != nil {
		matchValueList := make([]SslProtocol_STATUS, len(source.MatchValues))
		for matchValueIndex, matchValueItem := range source.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValueList[matchValueIndex] = genruntime.ToEnum(matchValueItem, sslProtocol_STATUS_Values)
		}
		parameters.MatchValues = matchValueList
	} else {
		parameters.MatchValues = nil
	}

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, sslProtocolMatchConditionParameters_Operator_STATUS_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_STATUS_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, sslProtocolMatchConditionParameters_TypeName_STATUS_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SslProtocolMatchConditionParameters_STATUS populates the provided destination SslProtocolMatchConditionParameters_STATUS from our SslProtocolMatchConditionParameters_STATUS
func (parameters *SslProtocolMatchConditionParameters_STATUS) AssignProperties_To_SslProtocolMatchConditionParameters_STATUS(destination *storage.SslProtocolMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	if parameters.MatchValues != nil {
		matchValueList := make([]string, len(parameters.MatchValues))
		for matchValueIndex, matchValueItem := range parameters.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValueList[matchValueIndex] = string(matchValueItem)
		}
		destination.MatchValues = matchValueList
	} else {
		destination.MatchValues = nil
	}

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for UrlFileExtension match conditions
type UrlFileExtensionMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *UrlFileExtensionMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *UrlFileExtensionMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &UrlFileExtensionMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *UrlFileExtensionMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.UrlFileExtensionMatchConditionParameters{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		result.MatchValues = append(result.MatchValues, item)
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		var temp string
		temp = string(*parameters.Operator)
		operator := arm.UrlFileExtensionMatchConditionParameters_Operator(temp)
		result.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		var temp string
		temp = string(item)
		result.Transforms = append(result.Transforms, arm.Transform(temp))
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		var temp string
		temp = string(*parameters.TypeName)
		typeName := arm.UrlFileExtensionMatchConditionParameters_TypeName(temp)
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *UrlFileExtensionMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UrlFileExtensionMatchConditionParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *UrlFileExtensionMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UrlFileExtensionMatchConditionParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UrlFileExtensionMatchConditionParameters, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := UrlFileExtensionMatchConditionParameters_Operator(temp)
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := UrlFileExtensionMatchConditionParameters_TypeName(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_UrlFileExtensionMatchConditionParameters populates our UrlFileExtensionMatchConditionParameters from the provided source UrlFileExtensionMatchConditionParameters
func (parameters *UrlFileExtensionMatchConditionParameters) AssignProperties_From_UrlFileExtensionMatchConditionParameters(source *storage.UrlFileExtensionMatchConditionParameters) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, urlFileExtensionMatchConditionParameters_Operator_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, urlFileExtensionMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlFileExtensionMatchConditionParameters populates the provided destination UrlFileExtensionMatchConditionParameters from our UrlFileExtensionMatchConditionParameters
func (parameters *UrlFileExtensionMatchConditionParameters) AssignProperties_To_UrlFileExtensionMatchConditionParameters(destination *storage.UrlFileExtensionMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_UrlFileExtensionMatchConditionParameters_STATUS populates our UrlFileExtensionMatchConditionParameters from the provided source UrlFileExtensionMatchConditionParameters_STATUS
func (parameters *UrlFileExtensionMatchConditionParameters) Initialize_From_UrlFileExtensionMatchConditionParameters_STATUS(source *UrlFileExtensionMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := genruntime.ToEnum(string(*source.Operator), urlFileExtensionMatchConditionParameters_Operator_Values)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := genruntime.ToEnum(string(transformItem), transform_Values)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := genruntime.ToEnum(string(*source.TypeName), urlFileExtensionMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for UrlFileExtension match conditions
type UrlFileExtensionMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *UrlFileExtensionMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                                        `json:"transforms,omitempty"`
	TypeName   *UrlFileExtensionMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &UrlFileExtensionMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *UrlFileExtensionMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UrlFileExtensionMatchConditionParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *UrlFileExtensionMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UrlFileExtensionMatchConditionParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UrlFileExtensionMatchConditionParameters_STATUS, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := UrlFileExtensionMatchConditionParameters_Operator_STATUS(temp)
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform_STATUS(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := UrlFileExtensionMatchConditionParameters_TypeName_STATUS(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_UrlFileExtensionMatchConditionParameters_STATUS populates our UrlFileExtensionMatchConditionParameters_STATUS from the provided source UrlFileExtensionMatchConditionParameters_STATUS
func (parameters *UrlFileExtensionMatchConditionParameters_STATUS) AssignProperties_From_UrlFileExtensionMatchConditionParameters_STATUS(source *storage.UrlFileExtensionMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, urlFileExtensionMatchConditionParameters_Operator_STATUS_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_STATUS_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, urlFileExtensionMatchConditionParameters_TypeName_STATUS_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlFileExtensionMatchConditionParameters_STATUS populates the provided destination UrlFileExtensionMatchConditionParameters_STATUS from our UrlFileExtensionMatchConditionParameters_STATUS
func (parameters *UrlFileExtensionMatchConditionParameters_STATUS) AssignProperties_To_UrlFileExtensionMatchConditionParameters_STATUS(destination *storage.UrlFileExtensionMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for UrlFilename match conditions
type UrlFileNameMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *UrlFileNameMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *UrlFileNameMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &UrlFileNameMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *UrlFileNameMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.UrlFileNameMatchConditionParameters{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		result.MatchValues = append(result.MatchValues, item)
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		var temp string
		temp = string(*parameters.Operator)
		operator := arm.UrlFileNameMatchConditionParameters_Operator(temp)
		result.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		var temp string
		temp = string(item)
		result.Transforms = append(result.Transforms, arm.Transform(temp))
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		var temp string
		temp = string(*parameters.TypeName)
		typeName := arm.UrlFileNameMatchConditionParameters_TypeName(temp)
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *UrlFileNameMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UrlFileNameMatchConditionParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *UrlFileNameMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UrlFileNameMatchConditionParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UrlFileNameMatchConditionParameters, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := UrlFileNameMatchConditionParameters_Operator(temp)
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := UrlFileNameMatchConditionParameters_TypeName(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_UrlFileNameMatchConditionParameters populates our UrlFileNameMatchConditionParameters from the provided source UrlFileNameMatchConditionParameters
func (parameters *UrlFileNameMatchConditionParameters) AssignProperties_From_UrlFileNameMatchConditionParameters(source *storage.UrlFileNameMatchConditionParameters) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, urlFileNameMatchConditionParameters_Operator_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, urlFileNameMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlFileNameMatchConditionParameters populates the provided destination UrlFileNameMatchConditionParameters from our UrlFileNameMatchConditionParameters
func (parameters *UrlFileNameMatchConditionParameters) AssignProperties_To_UrlFileNameMatchConditionParameters(destination *storage.UrlFileNameMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_UrlFileNameMatchConditionParameters_STATUS populates our UrlFileNameMatchConditionParameters from the provided source UrlFileNameMatchConditionParameters_STATUS
func (parameters *UrlFileNameMatchConditionParameters) Initialize_From_UrlFileNameMatchConditionParameters_STATUS(source *UrlFileNameMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := genruntime.ToEnum(string(*source.Operator), urlFileNameMatchConditionParameters_Operator_Values)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := genruntime.ToEnum(string(transformItem), transform_Values)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := genruntime.ToEnum(string(*source.TypeName), urlFileNameMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for UrlFilename match conditions
type UrlFileNameMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *UrlFileNameMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                                   `json:"transforms,omitempty"`
	TypeName   *UrlFileNameMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &UrlFileNameMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *UrlFileNameMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UrlFileNameMatchConditionParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *UrlFileNameMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UrlFileNameMatchConditionParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UrlFileNameMatchConditionParameters_STATUS, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := UrlFileNameMatchConditionParameters_Operator_STATUS(temp)
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform_STATUS(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := UrlFileNameMatchConditionParameters_TypeName_STATUS(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_UrlFileNameMatchConditionParameters_STATUS populates our UrlFileNameMatchConditionParameters_STATUS from the provided source UrlFileNameMatchConditionParameters_STATUS
func (parameters *UrlFileNameMatchConditionParameters_STATUS) AssignProperties_From_UrlFileNameMatchConditionParameters_STATUS(source *storage.UrlFileNameMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, urlFileNameMatchConditionParameters_Operator_STATUS_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_STATUS_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, urlFileNameMatchConditionParameters_TypeName_STATUS_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlFileNameMatchConditionParameters_STATUS populates the provided destination UrlFileNameMatchConditionParameters_STATUS from our UrlFileNameMatchConditionParameters_STATUS
func (parameters *UrlFileNameMatchConditionParameters_STATUS) AssignProperties_To_UrlFileNameMatchConditionParameters_STATUS(destination *storage.UrlFileNameMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for UrlPath match conditions
type UrlPathMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *UrlPathMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *UrlPathMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &UrlPathMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *UrlPathMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.UrlPathMatchConditionParameters{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		result.MatchValues = append(result.MatchValues, item)
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		var temp string
		temp = string(*parameters.Operator)
		operator := arm.UrlPathMatchConditionParameters_Operator(temp)
		result.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		var temp string
		temp = string(item)
		result.Transforms = append(result.Transforms, arm.Transform(temp))
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		var temp string
		temp = string(*parameters.TypeName)
		typeName := arm.UrlPathMatchConditionParameters_TypeName(temp)
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *UrlPathMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UrlPathMatchConditionParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *UrlPathMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UrlPathMatchConditionParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UrlPathMatchConditionParameters, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := UrlPathMatchConditionParameters_Operator(temp)
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := UrlPathMatchConditionParameters_TypeName(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_UrlPathMatchConditionParameters populates our UrlPathMatchConditionParameters from the provided source UrlPathMatchConditionParameters
func (parameters *UrlPathMatchConditionParameters) AssignProperties_From_UrlPathMatchConditionParameters(source *storage.UrlPathMatchConditionParameters) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, urlPathMatchConditionParameters_Operator_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, urlPathMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlPathMatchConditionParameters populates the provided destination UrlPathMatchConditionParameters from our UrlPathMatchConditionParameters
func (parameters *UrlPathMatchConditionParameters) AssignProperties_To_UrlPathMatchConditionParameters(destination *storage.UrlPathMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_UrlPathMatchConditionParameters_STATUS populates our UrlPathMatchConditionParameters from the provided source UrlPathMatchConditionParameters_STATUS
func (parameters *UrlPathMatchConditionParameters) Initialize_From_UrlPathMatchConditionParameters_STATUS(source *UrlPathMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := genruntime.ToEnum(string(*source.Operator), urlPathMatchConditionParameters_Operator_Values)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := genruntime.ToEnum(string(transformItem), transform_Values)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := genruntime.ToEnum(string(*source.TypeName), urlPathMatchConditionParameters_TypeName_Values)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for UrlPath match conditions
type UrlPathMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *UrlPathMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                               `json:"transforms,omitempty"`
	TypeName   *UrlPathMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &UrlPathMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *UrlPathMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UrlPathMatchConditionParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *UrlPathMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UrlPathMatchConditionParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UrlPathMatchConditionParameters_STATUS, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := UrlPathMatchConditionParameters_Operator_STATUS(temp)
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		parameters.Transforms = append(parameters.Transforms, Transform_STATUS(temp))
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := UrlPathMatchConditionParameters_TypeName_STATUS(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_UrlPathMatchConditionParameters_STATUS populates our UrlPathMatchConditionParameters_STATUS from the provided source UrlPathMatchConditionParameters_STATUS
func (parameters *UrlPathMatchConditionParameters_STATUS) AssignProperties_From_UrlPathMatchConditionParameters_STATUS(source *storage.UrlPathMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, urlPathMatchConditionParameters_Operator_STATUS_Values)
		parameters.Operator = &operatorTemp
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_STATUS_Values)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, urlPathMatchConditionParameters_TypeName_STATUS_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlPathMatchConditionParameters_STATUS populates the provided destination UrlPathMatchConditionParameters_STATUS from our UrlPathMatchConditionParameters_STATUS
func (parameters *UrlPathMatchConditionParameters_STATUS) AssignProperties_To_UrlPathMatchConditionParameters_STATUS(destination *storage.UrlPathMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"UrlRedirect"}
type UrlRedirectAction_Name string

const UrlRedirectAction_Name_UrlRedirect = UrlRedirectAction_Name("UrlRedirect")

// Mapping from string to UrlRedirectAction_Name
var urlRedirectAction_Name_Values = map[string]UrlRedirectAction_Name{
	"urlredirect": UrlRedirectAction_Name_UrlRedirect,
}

type UrlRedirectAction_Name_STATUS string

const UrlRedirectAction_Name_STATUS_UrlRedirect = UrlRedirectAction_Name_STATUS("UrlRedirect")

// Mapping from string to UrlRedirectAction_Name_STATUS
var urlRedirectAction_Name_STATUS_Values = map[string]UrlRedirectAction_Name_STATUS{
	"urlredirect": UrlRedirectAction_Name_STATUS_UrlRedirect,
}

// Defines the parameters for the url redirect action.
type UrlRedirectActionParameters struct {
	// CustomFragment: Fragment to add to the redirect URL. Fragment is the part of the URL that comes after #. Do not include
	// the #.
	CustomFragment *string `json:"customFragment,omitempty"`

	// CustomHostname: Host to redirect. Leave empty to use the incoming host as the destination host.
	CustomHostname *string `json:"customHostname,omitempty"`

	// CustomPath: The full path to redirect. Path cannot be empty and must start with /. Leave empty to use the incoming path
	// as destination path.
	CustomPath *string `json:"customPath,omitempty"`

	// CustomQueryString: The set of query strings to be placed in the redirect URL. Setting this value would replace any
	// existing query string; leave empty to preserve the incoming query string. Query string must be in <key>=<value> format.
	// ? and & will be added automatically so do not include them.
	CustomQueryString *string `json:"customQueryString,omitempty"`

	// DestinationProtocol: Protocol to use for the redirect. The default value is MatchRequest
	DestinationProtocol *UrlRedirectActionParameters_DestinationProtocol `json:"destinationProtocol,omitempty"`

	// +kubebuilder:validation:Required
	// RedirectType: The redirect type the rule will use when redirecting traffic.
	RedirectType *UrlRedirectActionParameters_RedirectType `json:"redirectType,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *UrlRedirectActionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &UrlRedirectActionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *UrlRedirectActionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.UrlRedirectActionParameters{}

	// Set property "CustomFragment":
	if parameters.CustomFragment != nil {
		customFragment := *parameters.CustomFragment
		result.CustomFragment = &customFragment
	}

	// Set property "CustomHostname":
	if parameters.CustomHostname != nil {
		customHostname := *parameters.CustomHostname
		result.CustomHostname = &customHostname
	}

	// Set property "CustomPath":
	if parameters.CustomPath != nil {
		customPath := *parameters.CustomPath
		result.CustomPath = &customPath
	}

	// Set property "CustomQueryString":
	if parameters.CustomQueryString != nil {
		customQueryString := *parameters.CustomQueryString
		result.CustomQueryString = &customQueryString
	}

	// Set property "DestinationProtocol":
	if parameters.DestinationProtocol != nil {
		var temp string
		temp = string(*parameters.DestinationProtocol)
		destinationProtocol := arm.UrlRedirectActionParameters_DestinationProtocol(temp)
		result.DestinationProtocol = &destinationProtocol
	}

	// Set property "RedirectType":
	if parameters.RedirectType != nil {
		var temp string
		temp = string(*parameters.RedirectType)
		redirectType := arm.UrlRedirectActionParameters_RedirectType(temp)
		result.RedirectType = &redirectType
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		var temp string
		temp = string(*parameters.TypeName)
		typeName := arm.UrlRedirectActionParameters_TypeName(temp)
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *UrlRedirectActionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UrlRedirectActionParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *UrlRedirectActionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UrlRedirectActionParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UrlRedirectActionParameters, got %T", armInput)
	}

	// Set property "CustomFragment":
	if typedInput.CustomFragment != nil {
		customFragment := *typedInput.CustomFragment
		parameters.CustomFragment = &customFragment
	}

	// Set property "CustomHostname":
	if typedInput.CustomHostname != nil {
		customHostname := *typedInput.CustomHostname
		parameters.CustomHostname = &customHostname
	}

	// Set property "CustomPath":
	if typedInput.CustomPath != nil {
		customPath := *typedInput.CustomPath
		parameters.CustomPath = &customPath
	}

	// Set property "CustomQueryString":
	if typedInput.CustomQueryString != nil {
		customQueryString := *typedInput.CustomQueryString
		parameters.CustomQueryString = &customQueryString
	}

	// Set property "DestinationProtocol":
	if typedInput.DestinationProtocol != nil {
		var temp string
		temp = string(*typedInput.DestinationProtocol)
		destinationProtocol := UrlRedirectActionParameters_DestinationProtocol(temp)
		parameters.DestinationProtocol = &destinationProtocol
	}

	// Set property "RedirectType":
	if typedInput.RedirectType != nil {
		var temp string
		temp = string(*typedInput.RedirectType)
		redirectType := UrlRedirectActionParameters_RedirectType(temp)
		parameters.RedirectType = &redirectType
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := UrlRedirectActionParameters_TypeName(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_UrlRedirectActionParameters populates our UrlRedirectActionParameters from the provided source UrlRedirectActionParameters
func (parameters *UrlRedirectActionParameters) AssignProperties_From_UrlRedirectActionParameters(source *storage.UrlRedirectActionParameters) error {

	// CustomFragment
	parameters.CustomFragment = genruntime.ClonePointerToString(source.CustomFragment)

	// CustomHostname
	parameters.CustomHostname = genruntime.ClonePointerToString(source.CustomHostname)

	// CustomPath
	parameters.CustomPath = genruntime.ClonePointerToString(source.CustomPath)

	// CustomQueryString
	parameters.CustomQueryString = genruntime.ClonePointerToString(source.CustomQueryString)

	// DestinationProtocol
	if source.DestinationProtocol != nil {
		destinationProtocol := *source.DestinationProtocol
		destinationProtocolTemp := genruntime.ToEnum(destinationProtocol, urlRedirectActionParameters_DestinationProtocol_Values)
		parameters.DestinationProtocol = &destinationProtocolTemp
	} else {
		parameters.DestinationProtocol = nil
	}

	// RedirectType
	if source.RedirectType != nil {
		redirectType := *source.RedirectType
		redirectTypeTemp := genruntime.ToEnum(redirectType, urlRedirectActionParameters_RedirectType_Values)
		parameters.RedirectType = &redirectTypeTemp
	} else {
		parameters.RedirectType = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, urlRedirectActionParameters_TypeName_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlRedirectActionParameters populates the provided destination UrlRedirectActionParameters from our UrlRedirectActionParameters
func (parameters *UrlRedirectActionParameters) AssignProperties_To_UrlRedirectActionParameters(destination *storage.UrlRedirectActionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CustomFragment
	destination.CustomFragment = genruntime.ClonePointerToString(parameters.CustomFragment)

	// CustomHostname
	destination.CustomHostname = genruntime.ClonePointerToString(parameters.CustomHostname)

	// CustomPath
	destination.CustomPath = genruntime.ClonePointerToString(parameters.CustomPath)

	// CustomQueryString
	destination.CustomQueryString = genruntime.ClonePointerToString(parameters.CustomQueryString)

	// DestinationProtocol
	if parameters.DestinationProtocol != nil {
		destinationProtocol := string(*parameters.DestinationProtocol)
		destination.DestinationProtocol = &destinationProtocol
	} else {
		destination.DestinationProtocol = nil
	}

	// RedirectType
	if parameters.RedirectType != nil {
		redirectType := string(*parameters.RedirectType)
		destination.RedirectType = &redirectType
	} else {
		destination.RedirectType = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_UrlRedirectActionParameters_STATUS populates our UrlRedirectActionParameters from the provided source UrlRedirectActionParameters_STATUS
func (parameters *UrlRedirectActionParameters) Initialize_From_UrlRedirectActionParameters_STATUS(source *UrlRedirectActionParameters_STATUS) error {

	// CustomFragment
	parameters.CustomFragment = genruntime.ClonePointerToString(source.CustomFragment)

	// CustomHostname
	parameters.CustomHostname = genruntime.ClonePointerToString(source.CustomHostname)

	// CustomPath
	parameters.CustomPath = genruntime.ClonePointerToString(source.CustomPath)

	// CustomQueryString
	parameters.CustomQueryString = genruntime.ClonePointerToString(source.CustomQueryString)

	// DestinationProtocol
	if source.DestinationProtocol != nil {
		destinationProtocol := genruntime.ToEnum(string(*source.DestinationProtocol), urlRedirectActionParameters_DestinationProtocol_Values)
		parameters.DestinationProtocol = &destinationProtocol
	} else {
		parameters.DestinationProtocol = nil
	}

	// RedirectType
	if source.RedirectType != nil {
		redirectType := genruntime.ToEnum(string(*source.RedirectType), urlRedirectActionParameters_RedirectType_Values)
		parameters.RedirectType = &redirectType
	} else {
		parameters.RedirectType = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := genruntime.ToEnum(string(*source.TypeName), urlRedirectActionParameters_TypeName_Values)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for the url redirect action.
type UrlRedirectActionParameters_STATUS struct {
	// CustomFragment: Fragment to add to the redirect URL. Fragment is the part of the URL that comes after #. Do not include
	// the #.
	CustomFragment *string `json:"customFragment,omitempty"`

	// CustomHostname: Host to redirect. Leave empty to use the incoming host as the destination host.
	CustomHostname *string `json:"customHostname,omitempty"`

	// CustomPath: The full path to redirect. Path cannot be empty and must start with /. Leave empty to use the incoming path
	// as destination path.
	CustomPath *string `json:"customPath,omitempty"`

	// CustomQueryString: The set of query strings to be placed in the redirect URL. Setting this value would replace any
	// existing query string; leave empty to preserve the incoming query string. Query string must be in <key>=<value> format.
	// ? and & will be added automatically so do not include them.
	CustomQueryString *string `json:"customQueryString,omitempty"`

	// DestinationProtocol: Protocol to use for the redirect. The default value is MatchRequest
	DestinationProtocol *UrlRedirectActionParameters_DestinationProtocol_STATUS `json:"destinationProtocol,omitempty"`

	// RedirectType: The redirect type the rule will use when redirecting traffic.
	RedirectType *UrlRedirectActionParameters_RedirectType_STATUS `json:"redirectType,omitempty"`
	TypeName     *UrlRedirectActionParameters_TypeName_STATUS     `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &UrlRedirectActionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *UrlRedirectActionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UrlRedirectActionParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *UrlRedirectActionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UrlRedirectActionParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UrlRedirectActionParameters_STATUS, got %T", armInput)
	}

	// Set property "CustomFragment":
	if typedInput.CustomFragment != nil {
		customFragment := *typedInput.CustomFragment
		parameters.CustomFragment = &customFragment
	}

	// Set property "CustomHostname":
	if typedInput.CustomHostname != nil {
		customHostname := *typedInput.CustomHostname
		parameters.CustomHostname = &customHostname
	}

	// Set property "CustomPath":
	if typedInput.CustomPath != nil {
		customPath := *typedInput.CustomPath
		parameters.CustomPath = &customPath
	}

	// Set property "CustomQueryString":
	if typedInput.CustomQueryString != nil {
		customQueryString := *typedInput.CustomQueryString
		parameters.CustomQueryString = &customQueryString
	}

	// Set property "DestinationProtocol":
	if typedInput.DestinationProtocol != nil {
		var temp string
		temp = string(*typedInput.DestinationProtocol)
		destinationProtocol := UrlRedirectActionParameters_DestinationProtocol_STATUS(temp)
		parameters.DestinationProtocol = &destinationProtocol
	}

	// Set property "RedirectType":
	if typedInput.RedirectType != nil {
		var temp string
		temp = string(*typedInput.RedirectType)
		redirectType := UrlRedirectActionParameters_RedirectType_STATUS(temp)
		parameters.RedirectType = &redirectType
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := UrlRedirectActionParameters_TypeName_STATUS(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_UrlRedirectActionParameters_STATUS populates our UrlRedirectActionParameters_STATUS from the provided source UrlRedirectActionParameters_STATUS
func (parameters *UrlRedirectActionParameters_STATUS) AssignProperties_From_UrlRedirectActionParameters_STATUS(source *storage.UrlRedirectActionParameters_STATUS) error {

	// CustomFragment
	parameters.CustomFragment = genruntime.ClonePointerToString(source.CustomFragment)

	// CustomHostname
	parameters.CustomHostname = genruntime.ClonePointerToString(source.CustomHostname)

	// CustomPath
	parameters.CustomPath = genruntime.ClonePointerToString(source.CustomPath)

	// CustomQueryString
	parameters.CustomQueryString = genruntime.ClonePointerToString(source.CustomQueryString)

	// DestinationProtocol
	if source.DestinationProtocol != nil {
		destinationProtocol := *source.DestinationProtocol
		destinationProtocolTemp := genruntime.ToEnum(destinationProtocol, urlRedirectActionParameters_DestinationProtocol_STATUS_Values)
		parameters.DestinationProtocol = &destinationProtocolTemp
	} else {
		parameters.DestinationProtocol = nil
	}

	// RedirectType
	if source.RedirectType != nil {
		redirectType := *source.RedirectType
		redirectTypeTemp := genruntime.ToEnum(redirectType, urlRedirectActionParameters_RedirectType_STATUS_Values)
		parameters.RedirectType = &redirectTypeTemp
	} else {
		parameters.RedirectType = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, urlRedirectActionParameters_TypeName_STATUS_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlRedirectActionParameters_STATUS populates the provided destination UrlRedirectActionParameters_STATUS from our UrlRedirectActionParameters_STATUS
func (parameters *UrlRedirectActionParameters_STATUS) AssignProperties_To_UrlRedirectActionParameters_STATUS(destination *storage.UrlRedirectActionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CustomFragment
	destination.CustomFragment = genruntime.ClonePointerToString(parameters.CustomFragment)

	// CustomHostname
	destination.CustomHostname = genruntime.ClonePointerToString(parameters.CustomHostname)

	// CustomPath
	destination.CustomPath = genruntime.ClonePointerToString(parameters.CustomPath)

	// CustomQueryString
	destination.CustomQueryString = genruntime.ClonePointerToString(parameters.CustomQueryString)

	// DestinationProtocol
	if parameters.DestinationProtocol != nil {
		destinationProtocol := string(*parameters.DestinationProtocol)
		destination.DestinationProtocol = &destinationProtocol
	} else {
		destination.DestinationProtocol = nil
	}

	// RedirectType
	if parameters.RedirectType != nil {
		redirectType := string(*parameters.RedirectType)
		destination.RedirectType = &redirectType
	} else {
		destination.RedirectType = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"UrlRewrite"}
type UrlRewriteAction_Name string

const UrlRewriteAction_Name_UrlRewrite = UrlRewriteAction_Name("UrlRewrite")

// Mapping from string to UrlRewriteAction_Name
var urlRewriteAction_Name_Values = map[string]UrlRewriteAction_Name{
	"urlrewrite": UrlRewriteAction_Name_UrlRewrite,
}

type UrlRewriteAction_Name_STATUS string

const UrlRewriteAction_Name_STATUS_UrlRewrite = UrlRewriteAction_Name_STATUS("UrlRewrite")

// Mapping from string to UrlRewriteAction_Name_STATUS
var urlRewriteAction_Name_STATUS_Values = map[string]UrlRewriteAction_Name_STATUS{
	"urlrewrite": UrlRewriteAction_Name_STATUS_UrlRewrite,
}

// Defines the parameters for the url rewrite action.
type UrlRewriteActionParameters struct {
	// +kubebuilder:validation:Required
	// Destination: Define the relative URL to which the above requests will be rewritten by.
	Destination *string `json:"destination,omitempty"`

	// PreserveUnmatchedPath: Whether to preserve unmatched path. Default value is true.
	PreserveUnmatchedPath *bool `json:"preserveUnmatchedPath,omitempty"`

	// +kubebuilder:validation:Required
	// SourcePattern: define a request URI pattern that identifies the type of requests that may be rewritten. If value is
	// blank, all strings are matched.
	SourcePattern *string `json:"sourcePattern,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *UrlRewriteActionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &UrlRewriteActionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *UrlRewriteActionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.UrlRewriteActionParameters{}

	// Set property "Destination":
	if parameters.Destination != nil {
		destination := *parameters.Destination
		result.Destination = &destination
	}

	// Set property "PreserveUnmatchedPath":
	if parameters.PreserveUnmatchedPath != nil {
		preserveUnmatchedPath := *parameters.PreserveUnmatchedPath
		result.PreserveUnmatchedPath = &preserveUnmatchedPath
	}

	// Set property "SourcePattern":
	if parameters.SourcePattern != nil {
		sourcePattern := *parameters.SourcePattern
		result.SourcePattern = &sourcePattern
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		var temp string
		temp = string(*parameters.TypeName)
		typeName := arm.UrlRewriteActionParameters_TypeName(temp)
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *UrlRewriteActionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UrlRewriteActionParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *UrlRewriteActionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UrlRewriteActionParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UrlRewriteActionParameters, got %T", armInput)
	}

	// Set property "Destination":
	if typedInput.Destination != nil {
		destination := *typedInput.Destination
		parameters.Destination = &destination
	}

	// Set property "PreserveUnmatchedPath":
	if typedInput.PreserveUnmatchedPath != nil {
		preserveUnmatchedPath := *typedInput.PreserveUnmatchedPath
		parameters.PreserveUnmatchedPath = &preserveUnmatchedPath
	}

	// Set property "SourcePattern":
	if typedInput.SourcePattern != nil {
		sourcePattern := *typedInput.SourcePattern
		parameters.SourcePattern = &sourcePattern
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := UrlRewriteActionParameters_TypeName(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_UrlRewriteActionParameters populates our UrlRewriteActionParameters from the provided source UrlRewriteActionParameters
func (parameters *UrlRewriteActionParameters) AssignProperties_From_UrlRewriteActionParameters(source *storage.UrlRewriteActionParameters) error {

	// Destination
	parameters.Destination = genruntime.ClonePointerToString(source.Destination)

	// PreserveUnmatchedPath
	if source.PreserveUnmatchedPath != nil {
		preserveUnmatchedPath := *source.PreserveUnmatchedPath
		parameters.PreserveUnmatchedPath = &preserveUnmatchedPath
	} else {
		parameters.PreserveUnmatchedPath = nil
	}

	// SourcePattern
	parameters.SourcePattern = genruntime.ClonePointerToString(source.SourcePattern)

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, urlRewriteActionParameters_TypeName_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlRewriteActionParameters populates the provided destination UrlRewriteActionParameters from our UrlRewriteActionParameters
func (parameters *UrlRewriteActionParameters) AssignProperties_To_UrlRewriteActionParameters(destination *storage.UrlRewriteActionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Destination
	destination.Destination = genruntime.ClonePointerToString(parameters.Destination)

	// PreserveUnmatchedPath
	if parameters.PreserveUnmatchedPath != nil {
		preserveUnmatchedPath := *parameters.PreserveUnmatchedPath
		destination.PreserveUnmatchedPath = &preserveUnmatchedPath
	} else {
		destination.PreserveUnmatchedPath = nil
	}

	// SourcePattern
	destination.SourcePattern = genruntime.ClonePointerToString(parameters.SourcePattern)

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_UrlRewriteActionParameters_STATUS populates our UrlRewriteActionParameters from the provided source UrlRewriteActionParameters_STATUS
func (parameters *UrlRewriteActionParameters) Initialize_From_UrlRewriteActionParameters_STATUS(source *UrlRewriteActionParameters_STATUS) error {

	// Destination
	parameters.Destination = genruntime.ClonePointerToString(source.Destination)

	// PreserveUnmatchedPath
	if source.PreserveUnmatchedPath != nil {
		preserveUnmatchedPath := *source.PreserveUnmatchedPath
		parameters.PreserveUnmatchedPath = &preserveUnmatchedPath
	} else {
		parameters.PreserveUnmatchedPath = nil
	}

	// SourcePattern
	parameters.SourcePattern = genruntime.ClonePointerToString(source.SourcePattern)

	// TypeName
	if source.TypeName != nil {
		typeName := genruntime.ToEnum(string(*source.TypeName), urlRewriteActionParameters_TypeName_Values)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for the url rewrite action.
type UrlRewriteActionParameters_STATUS struct {
	// Destination: Define the relative URL to which the above requests will be rewritten by.
	Destination *string `json:"destination,omitempty"`

	// PreserveUnmatchedPath: Whether to preserve unmatched path. Default value is true.
	PreserveUnmatchedPath *bool `json:"preserveUnmatchedPath,omitempty"`

	// SourcePattern: define a request URI pattern that identifies the type of requests that may be rewritten. If value is
	// blank, all strings are matched.
	SourcePattern *string                                     `json:"sourcePattern,omitempty"`
	TypeName      *UrlRewriteActionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &UrlRewriteActionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *UrlRewriteActionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UrlRewriteActionParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *UrlRewriteActionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UrlRewriteActionParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UrlRewriteActionParameters_STATUS, got %T", armInput)
	}

	// Set property "Destination":
	if typedInput.Destination != nil {
		destination := *typedInput.Destination
		parameters.Destination = &destination
	}

	// Set property "PreserveUnmatchedPath":
	if typedInput.PreserveUnmatchedPath != nil {
		preserveUnmatchedPath := *typedInput.PreserveUnmatchedPath
		parameters.PreserveUnmatchedPath = &preserveUnmatchedPath
	}

	// Set property "SourcePattern":
	if typedInput.SourcePattern != nil {
		sourcePattern := *typedInput.SourcePattern
		parameters.SourcePattern = &sourcePattern
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := UrlRewriteActionParameters_TypeName_STATUS(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_UrlRewriteActionParameters_STATUS populates our UrlRewriteActionParameters_STATUS from the provided source UrlRewriteActionParameters_STATUS
func (parameters *UrlRewriteActionParameters_STATUS) AssignProperties_From_UrlRewriteActionParameters_STATUS(source *storage.UrlRewriteActionParameters_STATUS) error {

	// Destination
	parameters.Destination = genruntime.ClonePointerToString(source.Destination)

	// PreserveUnmatchedPath
	if source.PreserveUnmatchedPath != nil {
		preserveUnmatchedPath := *source.PreserveUnmatchedPath
		parameters.PreserveUnmatchedPath = &preserveUnmatchedPath
	} else {
		parameters.PreserveUnmatchedPath = nil
	}

	// SourcePattern
	parameters.SourcePattern = genruntime.ClonePointerToString(source.SourcePattern)

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, urlRewriteActionParameters_TypeName_STATUS_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlRewriteActionParameters_STATUS populates the provided destination UrlRewriteActionParameters_STATUS from our UrlRewriteActionParameters_STATUS
func (parameters *UrlRewriteActionParameters_STATUS) AssignProperties_To_UrlRewriteActionParameters_STATUS(destination *storage.UrlRewriteActionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Destination
	destination.Destination = genruntime.ClonePointerToString(parameters.Destination)

	// PreserveUnmatchedPath
	if parameters.PreserveUnmatchedPath != nil {
		preserveUnmatchedPath := *parameters.PreserveUnmatchedPath
		destination.PreserveUnmatchedPath = &preserveUnmatchedPath
	} else {
		destination.PreserveUnmatchedPath = nil
	}

	// SourcePattern
	destination.SourcePattern = genruntime.ClonePointerToString(parameters.SourcePattern)

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"UrlSigning"}
type UrlSigningAction_Name string

const UrlSigningAction_Name_UrlSigning = UrlSigningAction_Name("UrlSigning")

// Mapping from string to UrlSigningAction_Name
var urlSigningAction_Name_Values = map[string]UrlSigningAction_Name{
	"urlsigning": UrlSigningAction_Name_UrlSigning,
}

type UrlSigningAction_Name_STATUS string

const UrlSigningAction_Name_STATUS_UrlSigning = UrlSigningAction_Name_STATUS("UrlSigning")

// Mapping from string to UrlSigningAction_Name_STATUS
var urlSigningAction_Name_STATUS_Values = map[string]UrlSigningAction_Name_STATUS{
	"urlsigning": UrlSigningAction_Name_STATUS_UrlSigning,
}

// Defines the parameters for the Url Signing action.
type UrlSigningActionParameters struct {
	// Algorithm: Algorithm to use for URL signing
	Algorithm *UrlSigningActionParameters_Algorithm `json:"algorithm,omitempty"`

	// ParameterNameOverride: Defines which query string parameters in the url to be considered for expires, key id etc.
	ParameterNameOverride []UrlSigningParamIdentifier `json:"parameterNameOverride,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *UrlSigningActionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &UrlSigningActionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *UrlSigningActionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.UrlSigningActionParameters{}

	// Set property "Algorithm":
	if parameters.Algorithm != nil {
		var temp string
		temp = string(*parameters.Algorithm)
		algorithm := arm.UrlSigningActionParameters_Algorithm(temp)
		result.Algorithm = &algorithm
	}

	// Set property "ParameterNameOverride":
	for _, item := range parameters.ParameterNameOverride {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.ParameterNameOverride = append(result.ParameterNameOverride, *item_ARM.(*arm.UrlSigningParamIdentifier))
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		var temp string
		temp = string(*parameters.TypeName)
		typeName := arm.UrlSigningActionParameters_TypeName(temp)
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *UrlSigningActionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UrlSigningActionParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *UrlSigningActionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UrlSigningActionParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UrlSigningActionParameters, got %T", armInput)
	}

	// Set property "Algorithm":
	if typedInput.Algorithm != nil {
		var temp string
		temp = string(*typedInput.Algorithm)
		algorithm := UrlSigningActionParameters_Algorithm(temp)
		parameters.Algorithm = &algorithm
	}

	// Set property "ParameterNameOverride":
	for _, item := range typedInput.ParameterNameOverride {
		var item1 UrlSigningParamIdentifier
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		parameters.ParameterNameOverride = append(parameters.ParameterNameOverride, item1)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := UrlSigningActionParameters_TypeName(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_UrlSigningActionParameters populates our UrlSigningActionParameters from the provided source UrlSigningActionParameters
func (parameters *UrlSigningActionParameters) AssignProperties_From_UrlSigningActionParameters(source *storage.UrlSigningActionParameters) error {

	// Algorithm
	if source.Algorithm != nil {
		algorithm := *source.Algorithm
		algorithmTemp := genruntime.ToEnum(algorithm, urlSigningActionParameters_Algorithm_Values)
		parameters.Algorithm = &algorithmTemp
	} else {
		parameters.Algorithm = nil
	}

	// ParameterNameOverride
	if source.ParameterNameOverride != nil {
		parameterNameOverrideList := make([]UrlSigningParamIdentifier, len(source.ParameterNameOverride))
		for parameterNameOverrideIndex, parameterNameOverrideItem := range source.ParameterNameOverride {
			// Shadow the loop variable to avoid aliasing
			parameterNameOverrideItem := parameterNameOverrideItem
			var parameterNameOverride UrlSigningParamIdentifier
			err := parameterNameOverride.AssignProperties_From_UrlSigningParamIdentifier(&parameterNameOverrideItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_UrlSigningParamIdentifier() to populate field ParameterNameOverride")
			}
			parameterNameOverrideList[parameterNameOverrideIndex] = parameterNameOverride
		}
		parameters.ParameterNameOverride = parameterNameOverrideList
	} else {
		parameters.ParameterNameOverride = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, urlSigningActionParameters_TypeName_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlSigningActionParameters populates the provided destination UrlSigningActionParameters from our UrlSigningActionParameters
func (parameters *UrlSigningActionParameters) AssignProperties_To_UrlSigningActionParameters(destination *storage.UrlSigningActionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Algorithm
	if parameters.Algorithm != nil {
		algorithm := string(*parameters.Algorithm)
		destination.Algorithm = &algorithm
	} else {
		destination.Algorithm = nil
	}

	// ParameterNameOverride
	if parameters.ParameterNameOverride != nil {
		parameterNameOverrideList := make([]storage.UrlSigningParamIdentifier, len(parameters.ParameterNameOverride))
		for parameterNameOverrideIndex, parameterNameOverrideItem := range parameters.ParameterNameOverride {
			// Shadow the loop variable to avoid aliasing
			parameterNameOverrideItem := parameterNameOverrideItem
			var parameterNameOverride storage.UrlSigningParamIdentifier
			err := parameterNameOverrideItem.AssignProperties_To_UrlSigningParamIdentifier(&parameterNameOverride)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_UrlSigningParamIdentifier() to populate field ParameterNameOverride")
			}
			parameterNameOverrideList[parameterNameOverrideIndex] = parameterNameOverride
		}
		destination.ParameterNameOverride = parameterNameOverrideList
	} else {
		destination.ParameterNameOverride = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_UrlSigningActionParameters_STATUS populates our UrlSigningActionParameters from the provided source UrlSigningActionParameters_STATUS
func (parameters *UrlSigningActionParameters) Initialize_From_UrlSigningActionParameters_STATUS(source *UrlSigningActionParameters_STATUS) error {

	// Algorithm
	if source.Algorithm != nil {
		algorithm := genruntime.ToEnum(string(*source.Algorithm), urlSigningActionParameters_Algorithm_Values)
		parameters.Algorithm = &algorithm
	} else {
		parameters.Algorithm = nil
	}

	// ParameterNameOverride
	if source.ParameterNameOverride != nil {
		parameterNameOverrideList := make([]UrlSigningParamIdentifier, len(source.ParameterNameOverride))
		for parameterNameOverrideIndex, parameterNameOverrideItem := range source.ParameterNameOverride {
			// Shadow the loop variable to avoid aliasing
			parameterNameOverrideItem := parameterNameOverrideItem
			var parameterNameOverride UrlSigningParamIdentifier
			err := parameterNameOverride.Initialize_From_UrlSigningParamIdentifier_STATUS(&parameterNameOverrideItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_UrlSigningParamIdentifier_STATUS() to populate field ParameterNameOverride")
			}
			parameterNameOverrideList[parameterNameOverrideIndex] = parameterNameOverride
		}
		parameters.ParameterNameOverride = parameterNameOverrideList
	} else {
		parameters.ParameterNameOverride = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := genruntime.ToEnum(string(*source.TypeName), urlSigningActionParameters_TypeName_Values)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for the Url Signing action.
type UrlSigningActionParameters_STATUS struct {
	// Algorithm: Algorithm to use for URL signing
	Algorithm *UrlSigningActionParameters_Algorithm_STATUS `json:"algorithm,omitempty"`

	// ParameterNameOverride: Defines which query string parameters in the url to be considered for expires, key id etc.
	ParameterNameOverride []UrlSigningParamIdentifier_STATUS          `json:"parameterNameOverride,omitempty"`
	TypeName              *UrlSigningActionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &UrlSigningActionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *UrlSigningActionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UrlSigningActionParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *UrlSigningActionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UrlSigningActionParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UrlSigningActionParameters_STATUS, got %T", armInput)
	}

	// Set property "Algorithm":
	if typedInput.Algorithm != nil {
		var temp string
		temp = string(*typedInput.Algorithm)
		algorithm := UrlSigningActionParameters_Algorithm_STATUS(temp)
		parameters.Algorithm = &algorithm
	}

	// Set property "ParameterNameOverride":
	for _, item := range typedInput.ParameterNameOverride {
		var item1 UrlSigningParamIdentifier_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		parameters.ParameterNameOverride = append(parameters.ParameterNameOverride, item1)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		var temp string
		temp = string(*typedInput.TypeName)
		typeName := UrlSigningActionParameters_TypeName_STATUS(temp)
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_UrlSigningActionParameters_STATUS populates our UrlSigningActionParameters_STATUS from the provided source UrlSigningActionParameters_STATUS
func (parameters *UrlSigningActionParameters_STATUS) AssignProperties_From_UrlSigningActionParameters_STATUS(source *storage.UrlSigningActionParameters_STATUS) error {

	// Algorithm
	if source.Algorithm != nil {
		algorithm := *source.Algorithm
		algorithmTemp := genruntime.ToEnum(algorithm, urlSigningActionParameters_Algorithm_STATUS_Values)
		parameters.Algorithm = &algorithmTemp
	} else {
		parameters.Algorithm = nil
	}

	// ParameterNameOverride
	if source.ParameterNameOverride != nil {
		parameterNameOverrideList := make([]UrlSigningParamIdentifier_STATUS, len(source.ParameterNameOverride))
		for parameterNameOverrideIndex, parameterNameOverrideItem := range source.ParameterNameOverride {
			// Shadow the loop variable to avoid aliasing
			parameterNameOverrideItem := parameterNameOverrideItem
			var parameterNameOverride UrlSigningParamIdentifier_STATUS
			err := parameterNameOverride.AssignProperties_From_UrlSigningParamIdentifier_STATUS(&parameterNameOverrideItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_UrlSigningParamIdentifier_STATUS() to populate field ParameterNameOverride")
			}
			parameterNameOverrideList[parameterNameOverrideIndex] = parameterNameOverride
		}
		parameters.ParameterNameOverride = parameterNameOverrideList
	} else {
		parameters.ParameterNameOverride = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := *source.TypeName
		typeNameTemp := genruntime.ToEnum(typeName, urlSigningActionParameters_TypeName_STATUS_Values)
		parameters.TypeName = &typeNameTemp
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlSigningActionParameters_STATUS populates the provided destination UrlSigningActionParameters_STATUS from our UrlSigningActionParameters_STATUS
func (parameters *UrlSigningActionParameters_STATUS) AssignProperties_To_UrlSigningActionParameters_STATUS(destination *storage.UrlSigningActionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Algorithm
	if parameters.Algorithm != nil {
		algorithm := string(*parameters.Algorithm)
		destination.Algorithm = &algorithm
	} else {
		destination.Algorithm = nil
	}

	// ParameterNameOverride
	if parameters.ParameterNameOverride != nil {
		parameterNameOverrideList := make([]storage.UrlSigningParamIdentifier_STATUS, len(parameters.ParameterNameOverride))
		for parameterNameOverrideIndex, parameterNameOverrideItem := range parameters.ParameterNameOverride {
			// Shadow the loop variable to avoid aliasing
			parameterNameOverrideItem := parameterNameOverrideItem
			var parameterNameOverride storage.UrlSigningParamIdentifier_STATUS
			err := parameterNameOverrideItem.AssignProperties_To_UrlSigningParamIdentifier_STATUS(&parameterNameOverride)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_UrlSigningParamIdentifier_STATUS() to populate field ParameterNameOverride")
			}
			parameterNameOverrideList[parameterNameOverrideIndex] = parameterNameOverride
		}
		destination.ParameterNameOverride = parameterNameOverrideList
	} else {
		destination.ParameterNameOverride = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Caching settings for a caching-type route. To disable caching, do not provide a cacheConfiguration object.
type CacheConfiguration struct {
	// CacheBehavior: Caching behavior for the requests
	CacheBehavior *CacheConfiguration_CacheBehavior `json:"cacheBehavior,omitempty"`

	// CacheDuration: The duration for which the content needs to be cached. Allowed format is [d.]hh:mm:ss
	CacheDuration *string `json:"cacheDuration,omitempty"`

	// IsCompressionEnabled: Indicates whether content compression is enabled. If compression is enabled, content will be
	// served as compressed if user requests for a compressed version. Content won't be compressed on AzureFrontDoor when
	// requested content is smaller than 1 byte or larger than 1 MB.
	IsCompressionEnabled *CacheConfiguration_IsCompressionEnabled `json:"isCompressionEnabled,omitempty"`

	// QueryParameters: query parameters to include or exclude (comma separated).
	QueryParameters *string `json:"queryParameters,omitempty"`

	// QueryStringCachingBehavior: Defines how Frontdoor caches requests that include query strings. You can ignore any query
	// strings when caching, ignore specific query strings, cache every request with a unique URL, or cache specific query
	// strings.
	QueryStringCachingBehavior *CacheConfiguration_QueryStringCachingBehavior `json:"queryStringCachingBehavior,omitempty"`
}

var _ genruntime.ARMTransformer = &CacheConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *CacheConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.CacheConfiguration{}

	// Set property "CacheBehavior":
	if configuration.CacheBehavior != nil {
		var temp string
		temp = string(*configuration.CacheBehavior)
		cacheBehavior := arm.CacheConfiguration_CacheBehavior(temp)
		result.CacheBehavior = &cacheBehavior
	}

	// Set property "CacheDuration":
	if configuration.CacheDuration != nil {
		cacheDuration := *configuration.CacheDuration
		result.CacheDuration = &cacheDuration
	}

	// Set property "IsCompressionEnabled":
	if configuration.IsCompressionEnabled != nil {
		var temp string
		temp = string(*configuration.IsCompressionEnabled)
		isCompressionEnabled := arm.CacheConfiguration_IsCompressionEnabled(temp)
		result.IsCompressionEnabled = &isCompressionEnabled
	}

	// Set property "QueryParameters":
	if configuration.QueryParameters != nil {
		queryParameters := *configuration.QueryParameters
		result.QueryParameters = &queryParameters
	}

	// Set property "QueryStringCachingBehavior":
	if configuration.QueryStringCachingBehavior != nil {
		var temp string
		temp = string(*configuration.QueryStringCachingBehavior)
		queryStringCachingBehavior := arm.CacheConfiguration_QueryStringCachingBehavior(temp)
		result.QueryStringCachingBehavior = &queryStringCachingBehavior
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *CacheConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CacheConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *CacheConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CacheConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CacheConfiguration, got %T", armInput)
	}

	// Set property "CacheBehavior":
	if typedInput.CacheBehavior != nil {
		var temp string
		temp = string(*typedInput.CacheBehavior)
		cacheBehavior := CacheConfiguration_CacheBehavior(temp)
		configuration.CacheBehavior = &cacheBehavior
	}

	// Set property "CacheDuration":
	if typedInput.CacheDuration != nil {
		cacheDuration := *typedInput.CacheDuration
		configuration.CacheDuration = &cacheDuration
	}

	// Set property "IsCompressionEnabled":
	if typedInput.IsCompressionEnabled != nil {
		var temp string
		temp = string(*typedInput.IsCompressionEnabled)
		isCompressionEnabled := CacheConfiguration_IsCompressionEnabled(temp)
		configuration.IsCompressionEnabled = &isCompressionEnabled
	}

	// Set property "QueryParameters":
	if typedInput.QueryParameters != nil {
		queryParameters := *typedInput.QueryParameters
		configuration.QueryParameters = &queryParameters
	}

	// Set property "QueryStringCachingBehavior":
	if typedInput.QueryStringCachingBehavior != nil {
		var temp string
		temp = string(*typedInput.QueryStringCachingBehavior)
		queryStringCachingBehavior := CacheConfiguration_QueryStringCachingBehavior(temp)
		configuration.QueryStringCachingBehavior = &queryStringCachingBehavior
	}

	// No error
	return nil
}

// AssignProperties_From_CacheConfiguration populates our CacheConfiguration from the provided source CacheConfiguration
func (configuration *CacheConfiguration) AssignProperties_From_CacheConfiguration(source *storage.CacheConfiguration) error {

	// CacheBehavior
	if source.CacheBehavior != nil {
		cacheBehavior := *source.CacheBehavior
		cacheBehaviorTemp := genruntime.ToEnum(cacheBehavior, cacheConfiguration_CacheBehavior_Values)
		configuration.CacheBehavior = &cacheBehaviorTemp
	} else {
		configuration.CacheBehavior = nil
	}

	// CacheDuration
	configuration.CacheDuration = genruntime.ClonePointerToString(source.CacheDuration)

	// IsCompressionEnabled
	if source.IsCompressionEnabled != nil {
		isCompressionEnabled := *source.IsCompressionEnabled
		isCompressionEnabledTemp := genruntime.ToEnum(isCompressionEnabled, cacheConfiguration_IsCompressionEnabled_Values)
		configuration.IsCompressionEnabled = &isCompressionEnabledTemp
	} else {
		configuration.IsCompressionEnabled = nil
	}

	// QueryParameters
	configuration.QueryParameters = genruntime.ClonePointerToString(source.QueryParameters)

	// QueryStringCachingBehavior
	if source.QueryStringCachingBehavior != nil {
		queryStringCachingBehavior := *source.QueryStringCachingBehavior
		queryStringCachingBehaviorTemp := genruntime.ToEnum(queryStringCachingBehavior, cacheConfiguration_QueryStringCachingBehavior_Values)
		configuration.QueryStringCachingBehavior = &queryStringCachingBehaviorTemp
	} else {
		configuration.QueryStringCachingBehavior = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CacheConfiguration populates the provided destination CacheConfiguration from our CacheConfiguration
func (configuration *CacheConfiguration) AssignProperties_To_CacheConfiguration(destination *storage.CacheConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CacheBehavior
	if configuration.CacheBehavior != nil {
		cacheBehavior := string(*configuration.CacheBehavior)
		destination.CacheBehavior = &cacheBehavior
	} else {
		destination.CacheBehavior = nil
	}

	// CacheDuration
	destination.CacheDuration = genruntime.ClonePointerToString(configuration.CacheDuration)

	// IsCompressionEnabled
	if configuration.IsCompressionEnabled != nil {
		isCompressionEnabled := string(*configuration.IsCompressionEnabled)
		destination.IsCompressionEnabled = &isCompressionEnabled
	} else {
		destination.IsCompressionEnabled = nil
	}

	// QueryParameters
	destination.QueryParameters = genruntime.ClonePointerToString(configuration.QueryParameters)

	// QueryStringCachingBehavior
	if configuration.QueryStringCachingBehavior != nil {
		queryStringCachingBehavior := string(*configuration.QueryStringCachingBehavior)
		destination.QueryStringCachingBehavior = &queryStringCachingBehavior
	} else {
		destination.QueryStringCachingBehavior = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_CacheConfiguration_STATUS populates our CacheConfiguration from the provided source CacheConfiguration_STATUS
func (configuration *CacheConfiguration) Initialize_From_CacheConfiguration_STATUS(source *CacheConfiguration_STATUS) error {

	// CacheBehavior
	if source.CacheBehavior != nil {
		cacheBehavior := genruntime.ToEnum(string(*source.CacheBehavior), cacheConfiguration_CacheBehavior_Values)
		configuration.CacheBehavior = &cacheBehavior
	} else {
		configuration.CacheBehavior = nil
	}

	// CacheDuration
	configuration.CacheDuration = genruntime.ClonePointerToString(source.CacheDuration)

	// IsCompressionEnabled
	if source.IsCompressionEnabled != nil {
		isCompressionEnabled := genruntime.ToEnum(string(*source.IsCompressionEnabled), cacheConfiguration_IsCompressionEnabled_Values)
		configuration.IsCompressionEnabled = &isCompressionEnabled
	} else {
		configuration.IsCompressionEnabled = nil
	}

	// QueryParameters
	configuration.QueryParameters = genruntime.ClonePointerToString(source.QueryParameters)

	// QueryStringCachingBehavior
	if source.QueryStringCachingBehavior != nil {
		queryStringCachingBehavior := genruntime.ToEnum(string(*source.QueryStringCachingBehavior), cacheConfiguration_QueryStringCachingBehavior_Values)
		configuration.QueryStringCachingBehavior = &queryStringCachingBehavior
	} else {
		configuration.QueryStringCachingBehavior = nil
	}

	// No error
	return nil
}

// Caching settings for a caching-type route. To disable caching, do not provide a cacheConfiguration object.
type CacheConfiguration_STATUS struct {
	// CacheBehavior: Caching behavior for the requests
	CacheBehavior *CacheConfiguration_CacheBehavior_STATUS `json:"cacheBehavior,omitempty"`

	// CacheDuration: The duration for which the content needs to be cached. Allowed format is [d.]hh:mm:ss
	CacheDuration *string `json:"cacheDuration,omitempty"`

	// IsCompressionEnabled: Indicates whether content compression is enabled. If compression is enabled, content will be
	// served as compressed if user requests for a compressed version. Content won't be compressed on AzureFrontDoor when
	// requested content is smaller than 1 byte or larger than 1 MB.
	IsCompressionEnabled *CacheConfiguration_IsCompressionEnabled_STATUS `json:"isCompressionEnabled,omitempty"`

	// QueryParameters: query parameters to include or exclude (comma separated).
	QueryParameters *string `json:"queryParameters,omitempty"`

	// QueryStringCachingBehavior: Defines how Frontdoor caches requests that include query strings. You can ignore any query
	// strings when caching, ignore specific query strings, cache every request with a unique URL, or cache specific query
	// strings.
	QueryStringCachingBehavior *CacheConfiguration_QueryStringCachingBehavior_STATUS `json:"queryStringCachingBehavior,omitempty"`
}

var _ genruntime.FromARMConverter = &CacheConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *CacheConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CacheConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *CacheConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CacheConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CacheConfiguration_STATUS, got %T", armInput)
	}

	// Set property "CacheBehavior":
	if typedInput.CacheBehavior != nil {
		var temp string
		temp = string(*typedInput.CacheBehavior)
		cacheBehavior := CacheConfiguration_CacheBehavior_STATUS(temp)
		configuration.CacheBehavior = &cacheBehavior
	}

	// Set property "CacheDuration":
	if typedInput.CacheDuration != nil {
		cacheDuration := *typedInput.CacheDuration
		configuration.CacheDuration = &cacheDuration
	}

	// Set property "IsCompressionEnabled":
	if typedInput.IsCompressionEnabled != nil {
		var temp string
		temp = string(*typedInput.IsCompressionEnabled)
		isCompressionEnabled := CacheConfiguration_IsCompressionEnabled_STATUS(temp)
		configuration.IsCompressionEnabled = &isCompressionEnabled
	}

	// Set property "QueryParameters":
	if typedInput.QueryParameters != nil {
		queryParameters := *typedInput.QueryParameters
		configuration.QueryParameters = &queryParameters
	}

	// Set property "QueryStringCachingBehavior":
	if typedInput.QueryStringCachingBehavior != nil {
		var temp string
		temp = string(*typedInput.QueryStringCachingBehavior)
		queryStringCachingBehavior := CacheConfiguration_QueryStringCachingBehavior_STATUS(temp)
		configuration.QueryStringCachingBehavior = &queryStringCachingBehavior
	}

	// No error
	return nil
}

// AssignProperties_From_CacheConfiguration_STATUS populates our CacheConfiguration_STATUS from the provided source CacheConfiguration_STATUS
func (configuration *CacheConfiguration_STATUS) AssignProperties_From_CacheConfiguration_STATUS(source *storage.CacheConfiguration_STATUS) error {

	// CacheBehavior
	if source.CacheBehavior != nil {
		cacheBehavior := *source.CacheBehavior
		cacheBehaviorTemp := genruntime.ToEnum(cacheBehavior, cacheConfiguration_CacheBehavior_STATUS_Values)
		configuration.CacheBehavior = &cacheBehaviorTemp
	} else {
		configuration.CacheBehavior = nil
	}

	// CacheDuration
	configuration.CacheDuration = genruntime.ClonePointerToString(source.CacheDuration)

	// IsCompressionEnabled
	if source.IsCompressionEnabled != nil {
		isCompressionEnabled := *source.IsCompressionEnabled
		isCompressionEnabledTemp := genruntime.ToEnum(isCompressionEnabled, cacheConfiguration_IsCompressionEnabled_STATUS_Values)
		configuration.IsCompressionEnabled = &isCompressionEnabledTemp
	} else {
		configuration.IsCompressionEnabled = nil
	}

	// QueryParameters
	configuration.QueryParameters = genruntime.ClonePointerToString(source.QueryParameters)

	// QueryStringCachingBehavior
	if source.QueryStringCachingBehavior != nil {
		queryStringCachingBehavior := *source.QueryStringCachingBehavior
		queryStringCachingBehaviorTemp := genruntime.ToEnum(queryStringCachingBehavior, cacheConfiguration_QueryStringCachingBehavior_STATUS_Values)
		configuration.QueryStringCachingBehavior = &queryStringCachingBehaviorTemp
	} else {
		configuration.QueryStringCachingBehavior = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CacheConfiguration_STATUS populates the provided destination CacheConfiguration_STATUS from our CacheConfiguration_STATUS
func (configuration *CacheConfiguration_STATUS) AssignProperties_To_CacheConfiguration_STATUS(destination *storage.CacheConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CacheBehavior
	if configuration.CacheBehavior != nil {
		cacheBehavior := string(*configuration.CacheBehavior)
		destination.CacheBehavior = &cacheBehavior
	} else {
		destination.CacheBehavior = nil
	}

	// CacheDuration
	destination.CacheDuration = genruntime.ClonePointerToString(configuration.CacheDuration)

	// IsCompressionEnabled
	if configuration.IsCompressionEnabled != nil {
		isCompressionEnabled := string(*configuration.IsCompressionEnabled)
		destination.IsCompressionEnabled = &isCompressionEnabled
	} else {
		destination.IsCompressionEnabled = nil
	}

	// QueryParameters
	destination.QueryParameters = genruntime.ClonePointerToString(configuration.QueryParameters)

	// QueryStringCachingBehavior
	if configuration.QueryStringCachingBehavior != nil {
		queryStringCachingBehavior := string(*configuration.QueryStringCachingBehavior)
		destination.QueryStringCachingBehavior = &queryStringCachingBehavior
	} else {
		destination.QueryStringCachingBehavior = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"BypassCache","Override","SetIfMissing"}
type CacheExpirationActionParameters_CacheBehavior string

const (
	CacheExpirationActionParameters_CacheBehavior_BypassCache  = CacheExpirationActionParameters_CacheBehavior("BypassCache")
	CacheExpirationActionParameters_CacheBehavior_Override     = CacheExpirationActionParameters_CacheBehavior("Override")
	CacheExpirationActionParameters_CacheBehavior_SetIfMissing = CacheExpirationActionParameters_CacheBehavior("SetIfMissing")
)

// Mapping from string to CacheExpirationActionParameters_CacheBehavior
var cacheExpirationActionParameters_CacheBehavior_Values = map[string]CacheExpirationActionParameters_CacheBehavior{
	"bypasscache":  CacheExpirationActionParameters_CacheBehavior_BypassCache,
	"override":     CacheExpirationActionParameters_CacheBehavior_Override,
	"setifmissing": CacheExpirationActionParameters_CacheBehavior_SetIfMissing,
}

type CacheExpirationActionParameters_CacheBehavior_STATUS string

const (
	CacheExpirationActionParameters_CacheBehavior_STATUS_BypassCache  = CacheExpirationActionParameters_CacheBehavior_STATUS("BypassCache")
	CacheExpirationActionParameters_CacheBehavior_STATUS_Override     = CacheExpirationActionParameters_CacheBehavior_STATUS("Override")
	CacheExpirationActionParameters_CacheBehavior_STATUS_SetIfMissing = CacheExpirationActionParameters_CacheBehavior_STATUS("SetIfMissing")
)

// Mapping from string to CacheExpirationActionParameters_CacheBehavior_STATUS
var cacheExpirationActionParameters_CacheBehavior_STATUS_Values = map[string]CacheExpirationActionParameters_CacheBehavior_STATUS{
	"bypasscache":  CacheExpirationActionParameters_CacheBehavior_STATUS_BypassCache,
	"override":     CacheExpirationActionParameters_CacheBehavior_STATUS_Override,
	"setifmissing": CacheExpirationActionParameters_CacheBehavior_STATUS_SetIfMissing,
}

// +kubebuilder:validation:Enum={"All"}
type CacheExpirationActionParameters_CacheType string

const CacheExpirationActionParameters_CacheType_All = CacheExpirationActionParameters_CacheType("All")

// Mapping from string to CacheExpirationActionParameters_CacheType
var cacheExpirationActionParameters_CacheType_Values = map[string]CacheExpirationActionParameters_CacheType{
	"all": CacheExpirationActionParameters_CacheType_All,
}

type CacheExpirationActionParameters_CacheType_STATUS string

const CacheExpirationActionParameters_CacheType_STATUS_All = CacheExpirationActionParameters_CacheType_STATUS("All")

// Mapping from string to CacheExpirationActionParameters_CacheType_STATUS
var cacheExpirationActionParameters_CacheType_STATUS_Values = map[string]CacheExpirationActionParameters_CacheType_STATUS{
	"all": CacheExpirationActionParameters_CacheType_STATUS_All,
}

// +kubebuilder:validation:Enum={"DeliveryRuleCacheExpirationActionParameters"}
type CacheExpirationActionParameters_TypeName string

const CacheExpirationActionParameters_TypeName_DeliveryRuleCacheExpirationActionParameters = CacheExpirationActionParameters_TypeName("DeliveryRuleCacheExpirationActionParameters")

// Mapping from string to CacheExpirationActionParameters_TypeName
var cacheExpirationActionParameters_TypeName_Values = map[string]CacheExpirationActionParameters_TypeName{
	"deliveryrulecacheexpirationactionparameters": CacheExpirationActionParameters_TypeName_DeliveryRuleCacheExpirationActionParameters,
}

type CacheExpirationActionParameters_TypeName_STATUS string

const CacheExpirationActionParameters_TypeName_STATUS_DeliveryRuleCacheExpirationActionParameters = CacheExpirationActionParameters_TypeName_STATUS("DeliveryRuleCacheExpirationActionParameters")

// Mapping from string to CacheExpirationActionParameters_TypeName_STATUS
var cacheExpirationActionParameters_TypeName_STATUS_Values = map[string]CacheExpirationActionParameters_TypeName_STATUS{
	"deliveryrulecacheexpirationactionparameters": CacheExpirationActionParameters_TypeName_STATUS_DeliveryRuleCacheExpirationActionParameters,
}

// +kubebuilder:validation:Enum={"Exclude","ExcludeAll","Include","IncludeAll"}
type CacheKeyQueryStringActionParameters_QueryStringBehavior string

const (
	CacheKeyQueryStringActionParameters_QueryStringBehavior_Exclude    = CacheKeyQueryStringActionParameters_QueryStringBehavior("Exclude")
	CacheKeyQueryStringActionParameters_QueryStringBehavior_ExcludeAll = CacheKeyQueryStringActionParameters_QueryStringBehavior("ExcludeAll")
	CacheKeyQueryStringActionParameters_QueryStringBehavior_Include    = CacheKeyQueryStringActionParameters_QueryStringBehavior("Include")
	CacheKeyQueryStringActionParameters_QueryStringBehavior_IncludeAll = CacheKeyQueryStringActionParameters_QueryStringBehavior("IncludeAll")
)

// Mapping from string to CacheKeyQueryStringActionParameters_QueryStringBehavior
var cacheKeyQueryStringActionParameters_QueryStringBehavior_Values = map[string]CacheKeyQueryStringActionParameters_QueryStringBehavior{
	"exclude":    CacheKeyQueryStringActionParameters_QueryStringBehavior_Exclude,
	"excludeall": CacheKeyQueryStringActionParameters_QueryStringBehavior_ExcludeAll,
	"include":    CacheKeyQueryStringActionParameters_QueryStringBehavior_Include,
	"includeall": CacheKeyQueryStringActionParameters_QueryStringBehavior_IncludeAll,
}

type CacheKeyQueryStringActionParameters_QueryStringBehavior_STATUS string

const (
	CacheKeyQueryStringActionParameters_QueryStringBehavior_STATUS_Exclude    = CacheKeyQueryStringActionParameters_QueryStringBehavior_STATUS("Exclude")
	CacheKeyQueryStringActionParameters_QueryStringBehavior_STATUS_ExcludeAll = CacheKeyQueryStringActionParameters_QueryStringBehavior_STATUS("ExcludeAll")
	CacheKeyQueryStringActionParameters_QueryStringBehavior_STATUS_Include    = CacheKeyQueryStringActionParameters_QueryStringBehavior_STATUS("Include")
	CacheKeyQueryStringActionParameters_QueryStringBehavior_STATUS_IncludeAll = CacheKeyQueryStringActionParameters_QueryStringBehavior_STATUS("IncludeAll")
)

// Mapping from string to CacheKeyQueryStringActionParameters_QueryStringBehavior_STATUS
var cacheKeyQueryStringActionParameters_QueryStringBehavior_STATUS_Values = map[string]CacheKeyQueryStringActionParameters_QueryStringBehavior_STATUS{
	"exclude":    CacheKeyQueryStringActionParameters_QueryStringBehavior_STATUS_Exclude,
	"excludeall": CacheKeyQueryStringActionParameters_QueryStringBehavior_STATUS_ExcludeAll,
	"include":    CacheKeyQueryStringActionParameters_QueryStringBehavior_STATUS_Include,
	"includeall": CacheKeyQueryStringActionParameters_QueryStringBehavior_STATUS_IncludeAll,
}

// +kubebuilder:validation:Enum={"DeliveryRuleCacheKeyQueryStringBehaviorActionParameters"}
type CacheKeyQueryStringActionParameters_TypeName string

const CacheKeyQueryStringActionParameters_TypeName_DeliveryRuleCacheKeyQueryStringBehaviorActionParameters = CacheKeyQueryStringActionParameters_TypeName("DeliveryRuleCacheKeyQueryStringBehaviorActionParameters")

// Mapping from string to CacheKeyQueryStringActionParameters_TypeName
var cacheKeyQueryStringActionParameters_TypeName_Values = map[string]CacheKeyQueryStringActionParameters_TypeName{
	"deliveryrulecachekeyquerystringbehavioractionparameters": CacheKeyQueryStringActionParameters_TypeName_DeliveryRuleCacheKeyQueryStringBehaviorActionParameters,
}

type CacheKeyQueryStringActionParameters_TypeName_STATUS string

const CacheKeyQueryStringActionParameters_TypeName_STATUS_DeliveryRuleCacheKeyQueryStringBehaviorActionParameters = CacheKeyQueryStringActionParameters_TypeName_STATUS("DeliveryRuleCacheKeyQueryStringBehaviorActionParameters")

// Mapping from string to CacheKeyQueryStringActionParameters_TypeName_STATUS
var cacheKeyQueryStringActionParameters_TypeName_STATUS_Values = map[string]CacheKeyQueryStringActionParameters_TypeName_STATUS{
	"deliveryrulecachekeyquerystringbehavioractionparameters": CacheKeyQueryStringActionParameters_TypeName_STATUS_DeliveryRuleCacheKeyQueryStringBehaviorActionParameters,
}

// +kubebuilder:validation:Enum={"Any","BeginsWith","Contains","EndsWith","Equal","GreaterThan","GreaterThanOrEqual","LessThan","LessThanOrEqual","RegEx"}
type ClientPortMatchConditionParameters_Operator string

const (
	ClientPortMatchConditionParameters_Operator_Any                = ClientPortMatchConditionParameters_Operator("Any")
	ClientPortMatchConditionParameters_Operator_BeginsWith         = ClientPortMatchConditionParameters_Operator("BeginsWith")
	ClientPortMatchConditionParameters_Operator_Contains           = ClientPortMatchConditionParameters_Operator("Contains")
	ClientPortMatchConditionParameters_Operator_EndsWith           = ClientPortMatchConditionParameters_Operator("EndsWith")
	ClientPortMatchConditionParameters_Operator_Equal              = ClientPortMatchConditionParameters_Operator("Equal")
	ClientPortMatchConditionParameters_Operator_GreaterThan        = ClientPortMatchConditionParameters_Operator("GreaterThan")
	ClientPortMatchConditionParameters_Operator_GreaterThanOrEqual = ClientPortMatchConditionParameters_Operator("GreaterThanOrEqual")
	ClientPortMatchConditionParameters_Operator_LessThan           = ClientPortMatchConditionParameters_Operator("LessThan")
	ClientPortMatchConditionParameters_Operator_LessThanOrEqual    = ClientPortMatchConditionParameters_Operator("LessThanOrEqual")
	ClientPortMatchConditionParameters_Operator_RegEx              = ClientPortMatchConditionParameters_Operator("RegEx")
)

// Mapping from string to ClientPortMatchConditionParameters_Operator
var clientPortMatchConditionParameters_Operator_Values = map[string]ClientPortMatchConditionParameters_Operator{
	"any":                ClientPortMatchConditionParameters_Operator_Any,
	"beginswith":         ClientPortMatchConditionParameters_Operator_BeginsWith,
	"contains":           ClientPortMatchConditionParameters_Operator_Contains,
	"endswith":           ClientPortMatchConditionParameters_Operator_EndsWith,
	"equal":              ClientPortMatchConditionParameters_Operator_Equal,
	"greaterthan":        ClientPortMatchConditionParameters_Operator_GreaterThan,
	"greaterthanorequal": ClientPortMatchConditionParameters_Operator_GreaterThanOrEqual,
	"lessthan":           ClientPortMatchConditionParameters_Operator_LessThan,
	"lessthanorequal":    ClientPortMatchConditionParameters_Operator_LessThanOrEqual,
	"regex":              ClientPortMatchConditionParameters_Operator_RegEx,
}

type ClientPortMatchConditionParameters_Operator_STATUS string

const (
	ClientPortMatchConditionParameters_Operator_STATUS_Any                = ClientPortMatchConditionParameters_Operator_STATUS("Any")
	ClientPortMatchConditionParameters_Operator_STATUS_BeginsWith         = ClientPortMatchConditionParameters_Operator_STATUS("BeginsWith")
	ClientPortMatchConditionParameters_Operator_STATUS_Contains           = ClientPortMatchConditionParameters_Operator_STATUS("Contains")
	ClientPortMatchConditionParameters_Operator_STATUS_EndsWith           = ClientPortMatchConditionParameters_Operator_STATUS("EndsWith")
	ClientPortMatchConditionParameters_Operator_STATUS_Equal              = ClientPortMatchConditionParameters_Operator_STATUS("Equal")
	ClientPortMatchConditionParameters_Operator_STATUS_GreaterThan        = ClientPortMatchConditionParameters_Operator_STATUS("GreaterThan")
	ClientPortMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual = ClientPortMatchConditionParameters_Operator_STATUS("GreaterThanOrEqual")
	ClientPortMatchConditionParameters_Operator_STATUS_LessThan           = ClientPortMatchConditionParameters_Operator_STATUS("LessThan")
	ClientPortMatchConditionParameters_Operator_STATUS_LessThanOrEqual    = ClientPortMatchConditionParameters_Operator_STATUS("LessThanOrEqual")
	ClientPortMatchConditionParameters_Operator_STATUS_RegEx              = ClientPortMatchConditionParameters_Operator_STATUS("RegEx")
)

// Mapping from string to ClientPortMatchConditionParameters_Operator_STATUS
var clientPortMatchConditionParameters_Operator_STATUS_Values = map[string]ClientPortMatchConditionParameters_Operator_STATUS{
	"any":                ClientPortMatchConditionParameters_Operator_STATUS_Any,
	"beginswith":         ClientPortMatchConditionParameters_Operator_STATUS_BeginsWith,
	"contains":           ClientPortMatchConditionParameters_Operator_STATUS_Contains,
	"endswith":           ClientPortMatchConditionParameters_Operator_STATUS_EndsWith,
	"equal":              ClientPortMatchConditionParameters_Operator_STATUS_Equal,
	"greaterthan":        ClientPortMatchConditionParameters_Operator_STATUS_GreaterThan,
	"greaterthanorequal": ClientPortMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual,
	"lessthan":           ClientPortMatchConditionParameters_Operator_STATUS_LessThan,
	"lessthanorequal":    ClientPortMatchConditionParameters_Operator_STATUS_LessThanOrEqual,
	"regex":              ClientPortMatchConditionParameters_Operator_STATUS_RegEx,
}

// +kubebuilder:validation:Enum={"DeliveryRuleClientPortConditionParameters"}
type ClientPortMatchConditionParameters_TypeName string

const ClientPortMatchConditionParameters_TypeName_DeliveryRuleClientPortConditionParameters = ClientPortMatchConditionParameters_TypeName("DeliveryRuleClientPortConditionParameters")

// Mapping from string to ClientPortMatchConditionParameters_TypeName
var clientPortMatchConditionParameters_TypeName_Values = map[string]ClientPortMatchConditionParameters_TypeName{
	"deliveryruleclientportconditionparameters": ClientPortMatchConditionParameters_TypeName_DeliveryRuleClientPortConditionParameters,
}

type ClientPortMatchConditionParameters_TypeName_STATUS string

const ClientPortMatchConditionParameters_TypeName_STATUS_DeliveryRuleClientPortConditionParameters = ClientPortMatchConditionParameters_TypeName_STATUS("DeliveryRuleClientPortConditionParameters")

// Mapping from string to ClientPortMatchConditionParameters_TypeName_STATUS
var clientPortMatchConditionParameters_TypeName_STATUS_Values = map[string]ClientPortMatchConditionParameters_TypeName_STATUS{
	"deliveryruleclientportconditionparameters": ClientPortMatchConditionParameters_TypeName_STATUS_DeliveryRuleClientPortConditionParameters,
}

// +kubebuilder:validation:Enum={"Any","BeginsWith","Contains","EndsWith","Equal","GreaterThan","GreaterThanOrEqual","LessThan","LessThanOrEqual","RegEx"}
type CookiesMatchConditionParameters_Operator string

const (
	CookiesMatchConditionParameters_Operator_Any                = CookiesMatchConditionParameters_Operator("Any")
	CookiesMatchConditionParameters_Operator_BeginsWith         = CookiesMatchConditionParameters_Operator("BeginsWith")
	CookiesMatchConditionParameters_Operator_Contains           = CookiesMatchConditionParameters_Operator("Contains")
	CookiesMatchConditionParameters_Operator_EndsWith           = CookiesMatchConditionParameters_Operator("EndsWith")
	CookiesMatchConditionParameters_Operator_Equal              = CookiesMatchConditionParameters_Operator("Equal")
	CookiesMatchConditionParameters_Operator_GreaterThan        = CookiesMatchConditionParameters_Operator("GreaterThan")
	CookiesMatchConditionParameters_Operator_GreaterThanOrEqual = CookiesMatchConditionParameters_Operator("GreaterThanOrEqual")
	CookiesMatchConditionParameters_Operator_LessThan           = CookiesMatchConditionParameters_Operator("LessThan")
	CookiesMatchConditionParameters_Operator_LessThanOrEqual    = CookiesMatchConditionParameters_Operator("LessThanOrEqual")
	CookiesMatchConditionParameters_Operator_RegEx              = CookiesMatchConditionParameters_Operator("RegEx")
)

// Mapping from string to CookiesMatchConditionParameters_Operator
var cookiesMatchConditionParameters_Operator_Values = map[string]CookiesMatchConditionParameters_Operator{
	"any":                CookiesMatchConditionParameters_Operator_Any,
	"beginswith":         CookiesMatchConditionParameters_Operator_BeginsWith,
	"contains":           CookiesMatchConditionParameters_Operator_Contains,
	"endswith":           CookiesMatchConditionParameters_Operator_EndsWith,
	"equal":              CookiesMatchConditionParameters_Operator_Equal,
	"greaterthan":        CookiesMatchConditionParameters_Operator_GreaterThan,
	"greaterthanorequal": CookiesMatchConditionParameters_Operator_GreaterThanOrEqual,
	"lessthan":           CookiesMatchConditionParameters_Operator_LessThan,
	"lessthanorequal":    CookiesMatchConditionParameters_Operator_LessThanOrEqual,
	"regex":              CookiesMatchConditionParameters_Operator_RegEx,
}

type CookiesMatchConditionParameters_Operator_STATUS string

const (
	CookiesMatchConditionParameters_Operator_STATUS_Any                = CookiesMatchConditionParameters_Operator_STATUS("Any")
	CookiesMatchConditionParameters_Operator_STATUS_BeginsWith         = CookiesMatchConditionParameters_Operator_STATUS("BeginsWith")
	CookiesMatchConditionParameters_Operator_STATUS_Contains           = CookiesMatchConditionParameters_Operator_STATUS("Contains")
	CookiesMatchConditionParameters_Operator_STATUS_EndsWith           = CookiesMatchConditionParameters_Operator_STATUS("EndsWith")
	CookiesMatchConditionParameters_Operator_STATUS_Equal              = CookiesMatchConditionParameters_Operator_STATUS("Equal")
	CookiesMatchConditionParameters_Operator_STATUS_GreaterThan        = CookiesMatchConditionParameters_Operator_STATUS("GreaterThan")
	CookiesMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual = CookiesMatchConditionParameters_Operator_STATUS("GreaterThanOrEqual")
	CookiesMatchConditionParameters_Operator_STATUS_LessThan           = CookiesMatchConditionParameters_Operator_STATUS("LessThan")
	CookiesMatchConditionParameters_Operator_STATUS_LessThanOrEqual    = CookiesMatchConditionParameters_Operator_STATUS("LessThanOrEqual")
	CookiesMatchConditionParameters_Operator_STATUS_RegEx              = CookiesMatchConditionParameters_Operator_STATUS("RegEx")
)

// Mapping from string to CookiesMatchConditionParameters_Operator_STATUS
var cookiesMatchConditionParameters_Operator_STATUS_Values = map[string]CookiesMatchConditionParameters_Operator_STATUS{
	"any":                CookiesMatchConditionParameters_Operator_STATUS_Any,
	"beginswith":         CookiesMatchConditionParameters_Operator_STATUS_BeginsWith,
	"contains":           CookiesMatchConditionParameters_Operator_STATUS_Contains,
	"endswith":           CookiesMatchConditionParameters_Operator_STATUS_EndsWith,
	"equal":              CookiesMatchConditionParameters_Operator_STATUS_Equal,
	"greaterthan":        CookiesMatchConditionParameters_Operator_STATUS_GreaterThan,
	"greaterthanorequal": CookiesMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual,
	"lessthan":           CookiesMatchConditionParameters_Operator_STATUS_LessThan,
	"lessthanorequal":    CookiesMatchConditionParameters_Operator_STATUS_LessThanOrEqual,
	"regex":              CookiesMatchConditionParameters_Operator_STATUS_RegEx,
}

// +kubebuilder:validation:Enum={"DeliveryRuleCookiesConditionParameters"}
type CookiesMatchConditionParameters_TypeName string

const CookiesMatchConditionParameters_TypeName_DeliveryRuleCookiesConditionParameters = CookiesMatchConditionParameters_TypeName("DeliveryRuleCookiesConditionParameters")

// Mapping from string to CookiesMatchConditionParameters_TypeName
var cookiesMatchConditionParameters_TypeName_Values = map[string]CookiesMatchConditionParameters_TypeName{
	"deliveryrulecookiesconditionparameters": CookiesMatchConditionParameters_TypeName_DeliveryRuleCookiesConditionParameters,
}

type CookiesMatchConditionParameters_TypeName_STATUS string

const CookiesMatchConditionParameters_TypeName_STATUS_DeliveryRuleCookiesConditionParameters = CookiesMatchConditionParameters_TypeName_STATUS("DeliveryRuleCookiesConditionParameters")

// Mapping from string to CookiesMatchConditionParameters_TypeName_STATUS
var cookiesMatchConditionParameters_TypeName_STATUS_Values = map[string]CookiesMatchConditionParameters_TypeName_STATUS{
	"deliveryrulecookiesconditionparameters": CookiesMatchConditionParameters_TypeName_STATUS_DeliveryRuleCookiesConditionParameters,
}

// +kubebuilder:validation:Enum={"Append","Delete","Overwrite"}
type HeaderActionParameters_HeaderAction string

const (
	HeaderActionParameters_HeaderAction_Append    = HeaderActionParameters_HeaderAction("Append")
	HeaderActionParameters_HeaderAction_Delete    = HeaderActionParameters_HeaderAction("Delete")
	HeaderActionParameters_HeaderAction_Overwrite = HeaderActionParameters_HeaderAction("Overwrite")
)

// Mapping from string to HeaderActionParameters_HeaderAction
var headerActionParameters_HeaderAction_Values = map[string]HeaderActionParameters_HeaderAction{
	"append":    HeaderActionParameters_HeaderAction_Append,
	"delete":    HeaderActionParameters_HeaderAction_Delete,
	"overwrite": HeaderActionParameters_HeaderAction_Overwrite,
}

type HeaderActionParameters_HeaderAction_STATUS string

const (
	HeaderActionParameters_HeaderAction_STATUS_Append    = HeaderActionParameters_HeaderAction_STATUS("Append")
	HeaderActionParameters_HeaderAction_STATUS_Delete    = HeaderActionParameters_HeaderAction_STATUS("Delete")
	HeaderActionParameters_HeaderAction_STATUS_Overwrite = HeaderActionParameters_HeaderAction_STATUS("Overwrite")
)

// Mapping from string to HeaderActionParameters_HeaderAction_STATUS
var headerActionParameters_HeaderAction_STATUS_Values = map[string]HeaderActionParameters_HeaderAction_STATUS{
	"append":    HeaderActionParameters_HeaderAction_STATUS_Append,
	"delete":    HeaderActionParameters_HeaderAction_STATUS_Delete,
	"overwrite": HeaderActionParameters_HeaderAction_STATUS_Overwrite,
}

// +kubebuilder:validation:Enum={"DeliveryRuleHeaderActionParameters"}
type HeaderActionParameters_TypeName string

const HeaderActionParameters_TypeName_DeliveryRuleHeaderActionParameters = HeaderActionParameters_TypeName("DeliveryRuleHeaderActionParameters")

// Mapping from string to HeaderActionParameters_TypeName
var headerActionParameters_TypeName_Values = map[string]HeaderActionParameters_TypeName{
	"deliveryruleheaderactionparameters": HeaderActionParameters_TypeName_DeliveryRuleHeaderActionParameters,
}

type HeaderActionParameters_TypeName_STATUS string

const HeaderActionParameters_TypeName_STATUS_DeliveryRuleHeaderActionParameters = HeaderActionParameters_TypeName_STATUS("DeliveryRuleHeaderActionParameters")

// Mapping from string to HeaderActionParameters_TypeName_STATUS
var headerActionParameters_TypeName_STATUS_Values = map[string]HeaderActionParameters_TypeName_STATUS{
	"deliveryruleheaderactionparameters": HeaderActionParameters_TypeName_STATUS_DeliveryRuleHeaderActionParameters,
}

// +kubebuilder:validation:Enum={"Any","BeginsWith","Contains","EndsWith","Equal","GreaterThan","GreaterThanOrEqual","LessThan","LessThanOrEqual","RegEx"}
type HostNameMatchConditionParameters_Operator string

const (
	HostNameMatchConditionParameters_Operator_Any                = HostNameMatchConditionParameters_Operator("Any")
	HostNameMatchConditionParameters_Operator_BeginsWith         = HostNameMatchConditionParameters_Operator("BeginsWith")
	HostNameMatchConditionParameters_Operator_Contains           = HostNameMatchConditionParameters_Operator("Contains")
	HostNameMatchConditionParameters_Operator_EndsWith           = HostNameMatchConditionParameters_Operator("EndsWith")
	HostNameMatchConditionParameters_Operator_Equal              = HostNameMatchConditionParameters_Operator("Equal")
	HostNameMatchConditionParameters_Operator_GreaterThan        = HostNameMatchConditionParameters_Operator("GreaterThan")
	HostNameMatchConditionParameters_Operator_GreaterThanOrEqual = HostNameMatchConditionParameters_Operator("GreaterThanOrEqual")
	HostNameMatchConditionParameters_Operator_LessThan           = HostNameMatchConditionParameters_Operator("LessThan")
	HostNameMatchConditionParameters_Operator_LessThanOrEqual    = HostNameMatchConditionParameters_Operator("LessThanOrEqual")
	HostNameMatchConditionParameters_Operator_RegEx              = HostNameMatchConditionParameters_Operator("RegEx")
)

// Mapping from string to HostNameMatchConditionParameters_Operator
var hostNameMatchConditionParameters_Operator_Values = map[string]HostNameMatchConditionParameters_Operator{
	"any":                HostNameMatchConditionParameters_Operator_Any,
	"beginswith":         HostNameMatchConditionParameters_Operator_BeginsWith,
	"contains":           HostNameMatchConditionParameters_Operator_Contains,
	"endswith":           HostNameMatchConditionParameters_Operator_EndsWith,
	"equal":              HostNameMatchConditionParameters_Operator_Equal,
	"greaterthan":        HostNameMatchConditionParameters_Operator_GreaterThan,
	"greaterthanorequal": HostNameMatchConditionParameters_Operator_GreaterThanOrEqual,
	"lessthan":           HostNameMatchConditionParameters_Operator_LessThan,
	"lessthanorequal":    HostNameMatchConditionParameters_Operator_LessThanOrEqual,
	"regex":              HostNameMatchConditionParameters_Operator_RegEx,
}

type HostNameMatchConditionParameters_Operator_STATUS string

const (
	HostNameMatchConditionParameters_Operator_STATUS_Any                = HostNameMatchConditionParameters_Operator_STATUS("Any")
	HostNameMatchConditionParameters_Operator_STATUS_BeginsWith         = HostNameMatchConditionParameters_Operator_STATUS("BeginsWith")
	HostNameMatchConditionParameters_Operator_STATUS_Contains           = HostNameMatchConditionParameters_Operator_STATUS("Contains")
	HostNameMatchConditionParameters_Operator_STATUS_EndsWith           = HostNameMatchConditionParameters_Operator_STATUS("EndsWith")
	HostNameMatchConditionParameters_Operator_STATUS_Equal              = HostNameMatchConditionParameters_Operator_STATUS("Equal")
	HostNameMatchConditionParameters_Operator_STATUS_GreaterThan        = HostNameMatchConditionParameters_Operator_STATUS("GreaterThan")
	HostNameMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual = HostNameMatchConditionParameters_Operator_STATUS("GreaterThanOrEqual")
	HostNameMatchConditionParameters_Operator_STATUS_LessThan           = HostNameMatchConditionParameters_Operator_STATUS("LessThan")
	HostNameMatchConditionParameters_Operator_STATUS_LessThanOrEqual    = HostNameMatchConditionParameters_Operator_STATUS("LessThanOrEqual")
	HostNameMatchConditionParameters_Operator_STATUS_RegEx              = HostNameMatchConditionParameters_Operator_STATUS("RegEx")
)

// Mapping from string to HostNameMatchConditionParameters_Operator_STATUS
var hostNameMatchConditionParameters_Operator_STATUS_Values = map[string]HostNameMatchConditionParameters_Operator_STATUS{
	"any":                HostNameMatchConditionParameters_Operator_STATUS_Any,
	"beginswith":         HostNameMatchConditionParameters_Operator_STATUS_BeginsWith,
	"contains":           HostNameMatchConditionParameters_Operator_STATUS_Contains,
	"endswith":           HostNameMatchConditionParameters_Operator_STATUS_EndsWith,
	"equal":              HostNameMatchConditionParameters_Operator_STATUS_Equal,
	"greaterthan":        HostNameMatchConditionParameters_Operator_STATUS_GreaterThan,
	"greaterthanorequal": HostNameMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual,
	"lessthan":           HostNameMatchConditionParameters_Operator_STATUS_LessThan,
	"lessthanorequal":    HostNameMatchConditionParameters_Operator_STATUS_LessThanOrEqual,
	"regex":              HostNameMatchConditionParameters_Operator_STATUS_RegEx,
}

// +kubebuilder:validation:Enum={"DeliveryRuleHostNameConditionParameters"}
type HostNameMatchConditionParameters_TypeName string

const HostNameMatchConditionParameters_TypeName_DeliveryRuleHostNameConditionParameters = HostNameMatchConditionParameters_TypeName("DeliveryRuleHostNameConditionParameters")

// Mapping from string to HostNameMatchConditionParameters_TypeName
var hostNameMatchConditionParameters_TypeName_Values = map[string]HostNameMatchConditionParameters_TypeName{
	"deliveryrulehostnameconditionparameters": HostNameMatchConditionParameters_TypeName_DeliveryRuleHostNameConditionParameters,
}

type HostNameMatchConditionParameters_TypeName_STATUS string

const HostNameMatchConditionParameters_TypeName_STATUS_DeliveryRuleHostNameConditionParameters = HostNameMatchConditionParameters_TypeName_STATUS("DeliveryRuleHostNameConditionParameters")

// Mapping from string to HostNameMatchConditionParameters_TypeName_STATUS
var hostNameMatchConditionParameters_TypeName_STATUS_Values = map[string]HostNameMatchConditionParameters_TypeName_STATUS{
	"deliveryrulehostnameconditionparameters": HostNameMatchConditionParameters_TypeName_STATUS_DeliveryRuleHostNameConditionParameters,
}

// +kubebuilder:validation:Enum={"Equal"}
type HttpVersionMatchConditionParameters_Operator string

const HttpVersionMatchConditionParameters_Operator_Equal = HttpVersionMatchConditionParameters_Operator("Equal")

// Mapping from string to HttpVersionMatchConditionParameters_Operator
var httpVersionMatchConditionParameters_Operator_Values = map[string]HttpVersionMatchConditionParameters_Operator{
	"equal": HttpVersionMatchConditionParameters_Operator_Equal,
}

type HttpVersionMatchConditionParameters_Operator_STATUS string

const HttpVersionMatchConditionParameters_Operator_STATUS_Equal = HttpVersionMatchConditionParameters_Operator_STATUS("Equal")

// Mapping from string to HttpVersionMatchConditionParameters_Operator_STATUS
var httpVersionMatchConditionParameters_Operator_STATUS_Values = map[string]HttpVersionMatchConditionParameters_Operator_STATUS{
	"equal": HttpVersionMatchConditionParameters_Operator_STATUS_Equal,
}

// +kubebuilder:validation:Enum={"DeliveryRuleHttpVersionConditionParameters"}
type HttpVersionMatchConditionParameters_TypeName string

const HttpVersionMatchConditionParameters_TypeName_DeliveryRuleHttpVersionConditionParameters = HttpVersionMatchConditionParameters_TypeName("DeliveryRuleHttpVersionConditionParameters")

// Mapping from string to HttpVersionMatchConditionParameters_TypeName
var httpVersionMatchConditionParameters_TypeName_Values = map[string]HttpVersionMatchConditionParameters_TypeName{
	"deliveryrulehttpversionconditionparameters": HttpVersionMatchConditionParameters_TypeName_DeliveryRuleHttpVersionConditionParameters,
}

type HttpVersionMatchConditionParameters_TypeName_STATUS string

const HttpVersionMatchConditionParameters_TypeName_STATUS_DeliveryRuleHttpVersionConditionParameters = HttpVersionMatchConditionParameters_TypeName_STATUS("DeliveryRuleHttpVersionConditionParameters")

// Mapping from string to HttpVersionMatchConditionParameters_TypeName_STATUS
var httpVersionMatchConditionParameters_TypeName_STATUS_Values = map[string]HttpVersionMatchConditionParameters_TypeName_STATUS{
	"deliveryrulehttpversionconditionparameters": HttpVersionMatchConditionParameters_TypeName_STATUS_DeliveryRuleHttpVersionConditionParameters,
}

// +kubebuilder:validation:Enum={"Desktop","Mobile"}
type IsDeviceMatchConditionParameters_MatchValues string

const (
	IsDeviceMatchConditionParameters_MatchValues_Desktop = IsDeviceMatchConditionParameters_MatchValues("Desktop")
	IsDeviceMatchConditionParameters_MatchValues_Mobile  = IsDeviceMatchConditionParameters_MatchValues("Mobile")
)

// Mapping from string to IsDeviceMatchConditionParameters_MatchValues
var isDeviceMatchConditionParameters_MatchValues_Values = map[string]IsDeviceMatchConditionParameters_MatchValues{
	"desktop": IsDeviceMatchConditionParameters_MatchValues_Desktop,
	"mobile":  IsDeviceMatchConditionParameters_MatchValues_Mobile,
}

type IsDeviceMatchConditionParameters_MatchValues_STATUS string

const (
	IsDeviceMatchConditionParameters_MatchValues_STATUS_Desktop = IsDeviceMatchConditionParameters_MatchValues_STATUS("Desktop")
	IsDeviceMatchConditionParameters_MatchValues_STATUS_Mobile  = IsDeviceMatchConditionParameters_MatchValues_STATUS("Mobile")
)

// Mapping from string to IsDeviceMatchConditionParameters_MatchValues_STATUS
var isDeviceMatchConditionParameters_MatchValues_STATUS_Values = map[string]IsDeviceMatchConditionParameters_MatchValues_STATUS{
	"desktop": IsDeviceMatchConditionParameters_MatchValues_STATUS_Desktop,
	"mobile":  IsDeviceMatchConditionParameters_MatchValues_STATUS_Mobile,
}

// +kubebuilder:validation:Enum={"Equal"}
type IsDeviceMatchConditionParameters_Operator string

const IsDeviceMatchConditionParameters_Operator_Equal = IsDeviceMatchConditionParameters_Operator("Equal")

// Mapping from string to IsDeviceMatchConditionParameters_Operator
var isDeviceMatchConditionParameters_Operator_Values = map[string]IsDeviceMatchConditionParameters_Operator{
	"equal": IsDeviceMatchConditionParameters_Operator_Equal,
}

type IsDeviceMatchConditionParameters_Operator_STATUS string

const IsDeviceMatchConditionParameters_Operator_STATUS_Equal = IsDeviceMatchConditionParameters_Operator_STATUS("Equal")

// Mapping from string to IsDeviceMatchConditionParameters_Operator_STATUS
var isDeviceMatchConditionParameters_Operator_STATUS_Values = map[string]IsDeviceMatchConditionParameters_Operator_STATUS{
	"equal": IsDeviceMatchConditionParameters_Operator_STATUS_Equal,
}

// +kubebuilder:validation:Enum={"DeliveryRuleIsDeviceConditionParameters"}
type IsDeviceMatchConditionParameters_TypeName string

const IsDeviceMatchConditionParameters_TypeName_DeliveryRuleIsDeviceConditionParameters = IsDeviceMatchConditionParameters_TypeName("DeliveryRuleIsDeviceConditionParameters")

// Mapping from string to IsDeviceMatchConditionParameters_TypeName
var isDeviceMatchConditionParameters_TypeName_Values = map[string]IsDeviceMatchConditionParameters_TypeName{
	"deliveryruleisdeviceconditionparameters": IsDeviceMatchConditionParameters_TypeName_DeliveryRuleIsDeviceConditionParameters,
}

type IsDeviceMatchConditionParameters_TypeName_STATUS string

const IsDeviceMatchConditionParameters_TypeName_STATUS_DeliveryRuleIsDeviceConditionParameters = IsDeviceMatchConditionParameters_TypeName_STATUS("DeliveryRuleIsDeviceConditionParameters")

// Mapping from string to IsDeviceMatchConditionParameters_TypeName_STATUS
var isDeviceMatchConditionParameters_TypeName_STATUS_Values = map[string]IsDeviceMatchConditionParameters_TypeName_STATUS{
	"deliveryruleisdeviceconditionparameters": IsDeviceMatchConditionParameters_TypeName_STATUS_DeliveryRuleIsDeviceConditionParameters,
}

// Defines the parameters for the origin group override configuration.
type OriginGroupOverride struct {
	// ForwardingProtocol: Protocol this rule will use when forwarding traffic to backends.
	ForwardingProtocol *OriginGroupOverride_ForwardingProtocol `json:"forwardingProtocol,omitempty"`

	// OriginGroup: defines the OriginGroup that would override the DefaultOriginGroup on route.
	OriginGroup *ResourceReference `json:"originGroup,omitempty"`
}

var _ genruntime.ARMTransformer = &OriginGroupOverride{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (override *OriginGroupOverride) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if override == nil {
		return nil, nil
	}
	result := &arm.OriginGroupOverride{}

	// Set property "ForwardingProtocol":
	if override.ForwardingProtocol != nil {
		var temp string
		temp = string(*override.ForwardingProtocol)
		forwardingProtocol := arm.OriginGroupOverride_ForwardingProtocol(temp)
		result.ForwardingProtocol = &forwardingProtocol
	}

	// Set property "OriginGroup":
	if override.OriginGroup != nil {
		originGroup_ARM, err := (*override.OriginGroup).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		originGroup := *originGroup_ARM.(*arm.ResourceReference)
		result.OriginGroup = &originGroup
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (override *OriginGroupOverride) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.OriginGroupOverride{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (override *OriginGroupOverride) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.OriginGroupOverride)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.OriginGroupOverride, got %T", armInput)
	}

	// Set property "ForwardingProtocol":
	if typedInput.ForwardingProtocol != nil {
		var temp string
		temp = string(*typedInput.ForwardingProtocol)
		forwardingProtocol := OriginGroupOverride_ForwardingProtocol(temp)
		override.ForwardingProtocol = &forwardingProtocol
	}

	// Set property "OriginGroup":
	if typedInput.OriginGroup != nil {
		var originGroup1 ResourceReference
		err := originGroup1.PopulateFromARM(owner, *typedInput.OriginGroup)
		if err != nil {
			return err
		}
		originGroup := originGroup1
		override.OriginGroup = &originGroup
	}

	// No error
	return nil
}

// AssignProperties_From_OriginGroupOverride populates our OriginGroupOverride from the provided source OriginGroupOverride
func (override *OriginGroupOverride) AssignProperties_From_OriginGroupOverride(source *storage.OriginGroupOverride) error {

	// ForwardingProtocol
	if source.ForwardingProtocol != nil {
		forwardingProtocol := *source.ForwardingProtocol
		forwardingProtocolTemp := genruntime.ToEnum(forwardingProtocol, originGroupOverride_ForwardingProtocol_Values)
		override.ForwardingProtocol = &forwardingProtocolTemp
	} else {
		override.ForwardingProtocol = nil
	}

	// OriginGroup
	if source.OriginGroup != nil {
		var originGroup ResourceReference
		err := originGroup.AssignProperties_From_ResourceReference(source.OriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceReference() to populate field OriginGroup")
		}
		override.OriginGroup = &originGroup
	} else {
		override.OriginGroup = nil
	}

	// No error
	return nil
}

// AssignProperties_To_OriginGroupOverride populates the provided destination OriginGroupOverride from our OriginGroupOverride
func (override *OriginGroupOverride) AssignProperties_To_OriginGroupOverride(destination *storage.OriginGroupOverride) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ForwardingProtocol
	if override.ForwardingProtocol != nil {
		forwardingProtocol := string(*override.ForwardingProtocol)
		destination.ForwardingProtocol = &forwardingProtocol
	} else {
		destination.ForwardingProtocol = nil
	}

	// OriginGroup
	if override.OriginGroup != nil {
		var originGroup storage.ResourceReference
		err := override.OriginGroup.AssignProperties_To_ResourceReference(&originGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceReference() to populate field OriginGroup")
		}
		destination.OriginGroup = &originGroup
	} else {
		destination.OriginGroup = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_OriginGroupOverride_STATUS populates our OriginGroupOverride from the provided source OriginGroupOverride_STATUS
func (override *OriginGroupOverride) Initialize_From_OriginGroupOverride_STATUS(source *OriginGroupOverride_STATUS) error {

	// ForwardingProtocol
	if source.ForwardingProtocol != nil {
		forwardingProtocol := genruntime.ToEnum(string(*source.ForwardingProtocol), originGroupOverride_ForwardingProtocol_Values)
		override.ForwardingProtocol = &forwardingProtocol
	} else {
		override.ForwardingProtocol = nil
	}

	// OriginGroup
	if source.OriginGroup != nil {
		var originGroup ResourceReference
		err := originGroup.Initialize_From_ResourceReference_STATUS(source.OriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ResourceReference_STATUS() to populate field OriginGroup")
		}
		override.OriginGroup = &originGroup
	} else {
		override.OriginGroup = nil
	}

	// No error
	return nil
}

// Defines the parameters for the origin group override configuration.
type OriginGroupOverride_STATUS struct {
	// ForwardingProtocol: Protocol this rule will use when forwarding traffic to backends.
	ForwardingProtocol *OriginGroupOverride_ForwardingProtocol_STATUS `json:"forwardingProtocol,omitempty"`

	// OriginGroup: defines the OriginGroup that would override the DefaultOriginGroup on route.
	OriginGroup *ResourceReference_STATUS `json:"originGroup,omitempty"`
}

var _ genruntime.FromARMConverter = &OriginGroupOverride_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (override *OriginGroupOverride_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.OriginGroupOverride_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (override *OriginGroupOverride_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.OriginGroupOverride_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.OriginGroupOverride_STATUS, got %T", armInput)
	}

	// Set property "ForwardingProtocol":
	if typedInput.ForwardingProtocol != nil {
		var temp string
		temp = string(*typedInput.ForwardingProtocol)
		forwardingProtocol := OriginGroupOverride_ForwardingProtocol_STATUS(temp)
		override.ForwardingProtocol = &forwardingProtocol
	}

	// Set property "OriginGroup":
	if typedInput.OriginGroup != nil {
		var originGroup1 ResourceReference_STATUS
		err := originGroup1.PopulateFromARM(owner, *typedInput.OriginGroup)
		if err != nil {
			return err
		}
		originGroup := originGroup1
		override.OriginGroup = &originGroup
	}

	// No error
	return nil
}

// AssignProperties_From_OriginGroupOverride_STATUS populates our OriginGroupOverride_STATUS from the provided source OriginGroupOverride_STATUS
func (override *OriginGroupOverride_STATUS) AssignProperties_From_OriginGroupOverride_STATUS(source *storage.OriginGroupOverride_STATUS) error {

	// ForwardingProtocol
	if source.ForwardingProtocol != nil {
		forwardingProtocol := *source.ForwardingProtocol
		forwardingProtocolTemp := genruntime.ToEnum(forwardingProtocol, originGroupOverride_ForwardingProtocol_STATUS_Values)
		override.ForwardingProtocol = &forwardingProtocolTemp
	} else {
		override.ForwardingProtocol = nil
	}

	// OriginGroup
	if source.OriginGroup != nil {
		var originGroup ResourceReference_STATUS
		err := originGroup.AssignProperties_From_ResourceReference_STATUS(source.OriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceReference_STATUS() to populate field OriginGroup")
		}
		override.OriginGroup = &originGroup
	} else {
		override.OriginGroup = nil
	}

	// No error
	return nil
}

// AssignProperties_To_OriginGroupOverride_STATUS populates the provided destination OriginGroupOverride_STATUS from our OriginGroupOverride_STATUS
func (override *OriginGroupOverride_STATUS) AssignProperties_To_OriginGroupOverride_STATUS(destination *storage.OriginGroupOverride_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ForwardingProtocol
	if override.ForwardingProtocol != nil {
		forwardingProtocol := string(*override.ForwardingProtocol)
		destination.ForwardingProtocol = &forwardingProtocol
	} else {
		destination.ForwardingProtocol = nil
	}

	// OriginGroup
	if override.OriginGroup != nil {
		var originGroup storage.ResourceReference_STATUS
		err := override.OriginGroup.AssignProperties_To_ResourceReference_STATUS(&originGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceReference_STATUS() to populate field OriginGroup")
		}
		destination.OriginGroup = &originGroup
	} else {
		destination.OriginGroup = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"DeliveryRuleOriginGroupOverrideActionParameters"}
type OriginGroupOverrideActionParameters_TypeName string

const OriginGroupOverrideActionParameters_TypeName_DeliveryRuleOriginGroupOverrideActionParameters = OriginGroupOverrideActionParameters_TypeName("DeliveryRuleOriginGroupOverrideActionParameters")

// Mapping from string to OriginGroupOverrideActionParameters_TypeName
var originGroupOverrideActionParameters_TypeName_Values = map[string]OriginGroupOverrideActionParameters_TypeName{
	"deliveryruleorigingroupoverrideactionparameters": OriginGroupOverrideActionParameters_TypeName_DeliveryRuleOriginGroupOverrideActionParameters,
}

type OriginGroupOverrideActionParameters_TypeName_STATUS string

const OriginGroupOverrideActionParameters_TypeName_STATUS_DeliveryRuleOriginGroupOverrideActionParameters = OriginGroupOverrideActionParameters_TypeName_STATUS("DeliveryRuleOriginGroupOverrideActionParameters")

// Mapping from string to OriginGroupOverrideActionParameters_TypeName_STATUS
var originGroupOverrideActionParameters_TypeName_STATUS_Values = map[string]OriginGroupOverrideActionParameters_TypeName_STATUS{
	"deliveryruleorigingroupoverrideactionparameters": OriginGroupOverrideActionParameters_TypeName_STATUS_DeliveryRuleOriginGroupOverrideActionParameters,
}

// +kubebuilder:validation:Enum={"Any","BeginsWith","Contains","EndsWith","Equal","GreaterThan","GreaterThanOrEqual","LessThan","LessThanOrEqual","RegEx"}
type PostArgsMatchConditionParameters_Operator string

const (
	PostArgsMatchConditionParameters_Operator_Any                = PostArgsMatchConditionParameters_Operator("Any")
	PostArgsMatchConditionParameters_Operator_BeginsWith         = PostArgsMatchConditionParameters_Operator("BeginsWith")
	PostArgsMatchConditionParameters_Operator_Contains           = PostArgsMatchConditionParameters_Operator("Contains")
	PostArgsMatchConditionParameters_Operator_EndsWith           = PostArgsMatchConditionParameters_Operator("EndsWith")
	PostArgsMatchConditionParameters_Operator_Equal              = PostArgsMatchConditionParameters_Operator("Equal")
	PostArgsMatchConditionParameters_Operator_GreaterThan        = PostArgsMatchConditionParameters_Operator("GreaterThan")
	PostArgsMatchConditionParameters_Operator_GreaterThanOrEqual = PostArgsMatchConditionParameters_Operator("GreaterThanOrEqual")
	PostArgsMatchConditionParameters_Operator_LessThan           = PostArgsMatchConditionParameters_Operator("LessThan")
	PostArgsMatchConditionParameters_Operator_LessThanOrEqual    = PostArgsMatchConditionParameters_Operator("LessThanOrEqual")
	PostArgsMatchConditionParameters_Operator_RegEx              = PostArgsMatchConditionParameters_Operator("RegEx")
)

// Mapping from string to PostArgsMatchConditionParameters_Operator
var postArgsMatchConditionParameters_Operator_Values = map[string]PostArgsMatchConditionParameters_Operator{
	"any":                PostArgsMatchConditionParameters_Operator_Any,
	"beginswith":         PostArgsMatchConditionParameters_Operator_BeginsWith,
	"contains":           PostArgsMatchConditionParameters_Operator_Contains,
	"endswith":           PostArgsMatchConditionParameters_Operator_EndsWith,
	"equal":              PostArgsMatchConditionParameters_Operator_Equal,
	"greaterthan":        PostArgsMatchConditionParameters_Operator_GreaterThan,
	"greaterthanorequal": PostArgsMatchConditionParameters_Operator_GreaterThanOrEqual,
	"lessthan":           PostArgsMatchConditionParameters_Operator_LessThan,
	"lessthanorequal":    PostArgsMatchConditionParameters_Operator_LessThanOrEqual,
	"regex":              PostArgsMatchConditionParameters_Operator_RegEx,
}

type PostArgsMatchConditionParameters_Operator_STATUS string

const (
	PostArgsMatchConditionParameters_Operator_STATUS_Any                = PostArgsMatchConditionParameters_Operator_STATUS("Any")
	PostArgsMatchConditionParameters_Operator_STATUS_BeginsWith         = PostArgsMatchConditionParameters_Operator_STATUS("BeginsWith")
	PostArgsMatchConditionParameters_Operator_STATUS_Contains           = PostArgsMatchConditionParameters_Operator_STATUS("Contains")
	PostArgsMatchConditionParameters_Operator_STATUS_EndsWith           = PostArgsMatchConditionParameters_Operator_STATUS("EndsWith")
	PostArgsMatchConditionParameters_Operator_STATUS_Equal              = PostArgsMatchConditionParameters_Operator_STATUS("Equal")
	PostArgsMatchConditionParameters_Operator_STATUS_GreaterThan        = PostArgsMatchConditionParameters_Operator_STATUS("GreaterThan")
	PostArgsMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual = PostArgsMatchConditionParameters_Operator_STATUS("GreaterThanOrEqual")
	PostArgsMatchConditionParameters_Operator_STATUS_LessThan           = PostArgsMatchConditionParameters_Operator_STATUS("LessThan")
	PostArgsMatchConditionParameters_Operator_STATUS_LessThanOrEqual    = PostArgsMatchConditionParameters_Operator_STATUS("LessThanOrEqual")
	PostArgsMatchConditionParameters_Operator_STATUS_RegEx              = PostArgsMatchConditionParameters_Operator_STATUS("RegEx")
)

// Mapping from string to PostArgsMatchConditionParameters_Operator_STATUS
var postArgsMatchConditionParameters_Operator_STATUS_Values = map[string]PostArgsMatchConditionParameters_Operator_STATUS{
	"any":                PostArgsMatchConditionParameters_Operator_STATUS_Any,
	"beginswith":         PostArgsMatchConditionParameters_Operator_STATUS_BeginsWith,
	"contains":           PostArgsMatchConditionParameters_Operator_STATUS_Contains,
	"endswith":           PostArgsMatchConditionParameters_Operator_STATUS_EndsWith,
	"equal":              PostArgsMatchConditionParameters_Operator_STATUS_Equal,
	"greaterthan":        PostArgsMatchConditionParameters_Operator_STATUS_GreaterThan,
	"greaterthanorequal": PostArgsMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual,
	"lessthan":           PostArgsMatchConditionParameters_Operator_STATUS_LessThan,
	"lessthanorequal":    PostArgsMatchConditionParameters_Operator_STATUS_LessThanOrEqual,
	"regex":              PostArgsMatchConditionParameters_Operator_STATUS_RegEx,
}

// +kubebuilder:validation:Enum={"DeliveryRulePostArgsConditionParameters"}
type PostArgsMatchConditionParameters_TypeName string

const PostArgsMatchConditionParameters_TypeName_DeliveryRulePostArgsConditionParameters = PostArgsMatchConditionParameters_TypeName("DeliveryRulePostArgsConditionParameters")

// Mapping from string to PostArgsMatchConditionParameters_TypeName
var postArgsMatchConditionParameters_TypeName_Values = map[string]PostArgsMatchConditionParameters_TypeName{
	"deliveryrulepostargsconditionparameters": PostArgsMatchConditionParameters_TypeName_DeliveryRulePostArgsConditionParameters,
}

type PostArgsMatchConditionParameters_TypeName_STATUS string

const PostArgsMatchConditionParameters_TypeName_STATUS_DeliveryRulePostArgsConditionParameters = PostArgsMatchConditionParameters_TypeName_STATUS("DeliveryRulePostArgsConditionParameters")

// Mapping from string to PostArgsMatchConditionParameters_TypeName_STATUS
var postArgsMatchConditionParameters_TypeName_STATUS_Values = map[string]PostArgsMatchConditionParameters_TypeName_STATUS{
	"deliveryrulepostargsconditionparameters": PostArgsMatchConditionParameters_TypeName_STATUS_DeliveryRulePostArgsConditionParameters,
}

// +kubebuilder:validation:Enum={"Any","BeginsWith","Contains","EndsWith","Equal","GreaterThan","GreaterThanOrEqual","LessThan","LessThanOrEqual","RegEx"}
type QueryStringMatchConditionParameters_Operator string

const (
	QueryStringMatchConditionParameters_Operator_Any                = QueryStringMatchConditionParameters_Operator("Any")
	QueryStringMatchConditionParameters_Operator_BeginsWith         = QueryStringMatchConditionParameters_Operator("BeginsWith")
	QueryStringMatchConditionParameters_Operator_Contains           = QueryStringMatchConditionParameters_Operator("Contains")
	QueryStringMatchConditionParameters_Operator_EndsWith           = QueryStringMatchConditionParameters_Operator("EndsWith")
	QueryStringMatchConditionParameters_Operator_Equal              = QueryStringMatchConditionParameters_Operator("Equal")
	QueryStringMatchConditionParameters_Operator_GreaterThan        = QueryStringMatchConditionParameters_Operator("GreaterThan")
	QueryStringMatchConditionParameters_Operator_GreaterThanOrEqual = QueryStringMatchConditionParameters_Operator("GreaterThanOrEqual")
	QueryStringMatchConditionParameters_Operator_LessThan           = QueryStringMatchConditionParameters_Operator("LessThan")
	QueryStringMatchConditionParameters_Operator_LessThanOrEqual    = QueryStringMatchConditionParameters_Operator("LessThanOrEqual")
	QueryStringMatchConditionParameters_Operator_RegEx              = QueryStringMatchConditionParameters_Operator("RegEx")
)

// Mapping from string to QueryStringMatchConditionParameters_Operator
var queryStringMatchConditionParameters_Operator_Values = map[string]QueryStringMatchConditionParameters_Operator{
	"any":                QueryStringMatchConditionParameters_Operator_Any,
	"beginswith":         QueryStringMatchConditionParameters_Operator_BeginsWith,
	"contains":           QueryStringMatchConditionParameters_Operator_Contains,
	"endswith":           QueryStringMatchConditionParameters_Operator_EndsWith,
	"equal":              QueryStringMatchConditionParameters_Operator_Equal,
	"greaterthan":        QueryStringMatchConditionParameters_Operator_GreaterThan,
	"greaterthanorequal": QueryStringMatchConditionParameters_Operator_GreaterThanOrEqual,
	"lessthan":           QueryStringMatchConditionParameters_Operator_LessThan,
	"lessthanorequal":    QueryStringMatchConditionParameters_Operator_LessThanOrEqual,
	"regex":              QueryStringMatchConditionParameters_Operator_RegEx,
}

type QueryStringMatchConditionParameters_Operator_STATUS string

const (
	QueryStringMatchConditionParameters_Operator_STATUS_Any                = QueryStringMatchConditionParameters_Operator_STATUS("Any")
	QueryStringMatchConditionParameters_Operator_STATUS_BeginsWith         = QueryStringMatchConditionParameters_Operator_STATUS("BeginsWith")
	QueryStringMatchConditionParameters_Operator_STATUS_Contains           = QueryStringMatchConditionParameters_Operator_STATUS("Contains")
	QueryStringMatchConditionParameters_Operator_STATUS_EndsWith           = QueryStringMatchConditionParameters_Operator_STATUS("EndsWith")
	QueryStringMatchConditionParameters_Operator_STATUS_Equal              = QueryStringMatchConditionParameters_Operator_STATUS("Equal")
	QueryStringMatchConditionParameters_Operator_STATUS_GreaterThan        = QueryStringMatchConditionParameters_Operator_STATUS("GreaterThan")
	QueryStringMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual = QueryStringMatchConditionParameters_Operator_STATUS("GreaterThanOrEqual")
	QueryStringMatchConditionParameters_Operator_STATUS_LessThan           = QueryStringMatchConditionParameters_Operator_STATUS("LessThan")
	QueryStringMatchConditionParameters_Operator_STATUS_LessThanOrEqual    = QueryStringMatchConditionParameters_Operator_STATUS("LessThanOrEqual")
	QueryStringMatchConditionParameters_Operator_STATUS_RegEx              = QueryStringMatchConditionParameters_Operator_STATUS("RegEx")
)

// Mapping from string to QueryStringMatchConditionParameters_Operator_STATUS
var queryStringMatchConditionParameters_Operator_STATUS_Values = map[string]QueryStringMatchConditionParameters_Operator_STATUS{
	"any":                QueryStringMatchConditionParameters_Operator_STATUS_Any,
	"beginswith":         QueryStringMatchConditionParameters_Operator_STATUS_BeginsWith,
	"contains":           QueryStringMatchConditionParameters_Operator_STATUS_Contains,
	"endswith":           QueryStringMatchConditionParameters_Operator_STATUS_EndsWith,
	"equal":              QueryStringMatchConditionParameters_Operator_STATUS_Equal,
	"greaterthan":        QueryStringMatchConditionParameters_Operator_STATUS_GreaterThan,
	"greaterthanorequal": QueryStringMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual,
	"lessthan":           QueryStringMatchConditionParameters_Operator_STATUS_LessThan,
	"lessthanorequal":    QueryStringMatchConditionParameters_Operator_STATUS_LessThanOrEqual,
	"regex":              QueryStringMatchConditionParameters_Operator_STATUS_RegEx,
}

// +kubebuilder:validation:Enum={"DeliveryRuleQueryStringConditionParameters"}
type QueryStringMatchConditionParameters_TypeName string

const QueryStringMatchConditionParameters_TypeName_DeliveryRuleQueryStringConditionParameters = QueryStringMatchConditionParameters_TypeName("DeliveryRuleQueryStringConditionParameters")

// Mapping from string to QueryStringMatchConditionParameters_TypeName
var queryStringMatchConditionParameters_TypeName_Values = map[string]QueryStringMatchConditionParameters_TypeName{
	"deliveryrulequerystringconditionparameters": QueryStringMatchConditionParameters_TypeName_DeliveryRuleQueryStringConditionParameters,
}

type QueryStringMatchConditionParameters_TypeName_STATUS string

const QueryStringMatchConditionParameters_TypeName_STATUS_DeliveryRuleQueryStringConditionParameters = QueryStringMatchConditionParameters_TypeName_STATUS("DeliveryRuleQueryStringConditionParameters")

// Mapping from string to QueryStringMatchConditionParameters_TypeName_STATUS
var queryStringMatchConditionParameters_TypeName_STATUS_Values = map[string]QueryStringMatchConditionParameters_TypeName_STATUS{
	"deliveryrulequerystringconditionparameters": QueryStringMatchConditionParameters_TypeName_STATUS_DeliveryRuleQueryStringConditionParameters,
}

// +kubebuilder:validation:Enum={"Any","GeoMatch","IPMatch"}
type RemoteAddressMatchConditionParameters_Operator string

const (
	RemoteAddressMatchConditionParameters_Operator_Any      = RemoteAddressMatchConditionParameters_Operator("Any")
	RemoteAddressMatchConditionParameters_Operator_GeoMatch = RemoteAddressMatchConditionParameters_Operator("GeoMatch")
	RemoteAddressMatchConditionParameters_Operator_IPMatch  = RemoteAddressMatchConditionParameters_Operator("IPMatch")
)

// Mapping from string to RemoteAddressMatchConditionParameters_Operator
var remoteAddressMatchConditionParameters_Operator_Values = map[string]RemoteAddressMatchConditionParameters_Operator{
	"any":      RemoteAddressMatchConditionParameters_Operator_Any,
	"geomatch": RemoteAddressMatchConditionParameters_Operator_GeoMatch,
	"ipmatch":  RemoteAddressMatchConditionParameters_Operator_IPMatch,
}

type RemoteAddressMatchConditionParameters_Operator_STATUS string

const (
	RemoteAddressMatchConditionParameters_Operator_STATUS_Any      = RemoteAddressMatchConditionParameters_Operator_STATUS("Any")
	RemoteAddressMatchConditionParameters_Operator_STATUS_GeoMatch = RemoteAddressMatchConditionParameters_Operator_STATUS("GeoMatch")
	RemoteAddressMatchConditionParameters_Operator_STATUS_IPMatch  = RemoteAddressMatchConditionParameters_Operator_STATUS("IPMatch")
)

// Mapping from string to RemoteAddressMatchConditionParameters_Operator_STATUS
var remoteAddressMatchConditionParameters_Operator_STATUS_Values = map[string]RemoteAddressMatchConditionParameters_Operator_STATUS{
	"any":      RemoteAddressMatchConditionParameters_Operator_STATUS_Any,
	"geomatch": RemoteAddressMatchConditionParameters_Operator_STATUS_GeoMatch,
	"ipmatch":  RemoteAddressMatchConditionParameters_Operator_STATUS_IPMatch,
}

// +kubebuilder:validation:Enum={"DeliveryRuleRemoteAddressConditionParameters"}
type RemoteAddressMatchConditionParameters_TypeName string

const RemoteAddressMatchConditionParameters_TypeName_DeliveryRuleRemoteAddressConditionParameters = RemoteAddressMatchConditionParameters_TypeName("DeliveryRuleRemoteAddressConditionParameters")

// Mapping from string to RemoteAddressMatchConditionParameters_TypeName
var remoteAddressMatchConditionParameters_TypeName_Values = map[string]RemoteAddressMatchConditionParameters_TypeName{
	"deliveryruleremoteaddressconditionparameters": RemoteAddressMatchConditionParameters_TypeName_DeliveryRuleRemoteAddressConditionParameters,
}

type RemoteAddressMatchConditionParameters_TypeName_STATUS string

const RemoteAddressMatchConditionParameters_TypeName_STATUS_DeliveryRuleRemoteAddressConditionParameters = RemoteAddressMatchConditionParameters_TypeName_STATUS("DeliveryRuleRemoteAddressConditionParameters")

// Mapping from string to RemoteAddressMatchConditionParameters_TypeName_STATUS
var remoteAddressMatchConditionParameters_TypeName_STATUS_Values = map[string]RemoteAddressMatchConditionParameters_TypeName_STATUS{
	"deliveryruleremoteaddressconditionparameters": RemoteAddressMatchConditionParameters_TypeName_STATUS_DeliveryRuleRemoteAddressConditionParameters,
}

// +kubebuilder:validation:Enum={"Any","BeginsWith","Contains","EndsWith","Equal","GreaterThan","GreaterThanOrEqual","LessThan","LessThanOrEqual","RegEx"}
type RequestBodyMatchConditionParameters_Operator string

const (
	RequestBodyMatchConditionParameters_Operator_Any                = RequestBodyMatchConditionParameters_Operator("Any")
	RequestBodyMatchConditionParameters_Operator_BeginsWith         = RequestBodyMatchConditionParameters_Operator("BeginsWith")
	RequestBodyMatchConditionParameters_Operator_Contains           = RequestBodyMatchConditionParameters_Operator("Contains")
	RequestBodyMatchConditionParameters_Operator_EndsWith           = RequestBodyMatchConditionParameters_Operator("EndsWith")
	RequestBodyMatchConditionParameters_Operator_Equal              = RequestBodyMatchConditionParameters_Operator("Equal")
	RequestBodyMatchConditionParameters_Operator_GreaterThan        = RequestBodyMatchConditionParameters_Operator("GreaterThan")
	RequestBodyMatchConditionParameters_Operator_GreaterThanOrEqual = RequestBodyMatchConditionParameters_Operator("GreaterThanOrEqual")
	RequestBodyMatchConditionParameters_Operator_LessThan           = RequestBodyMatchConditionParameters_Operator("LessThan")
	RequestBodyMatchConditionParameters_Operator_LessThanOrEqual    = RequestBodyMatchConditionParameters_Operator("LessThanOrEqual")
	RequestBodyMatchConditionParameters_Operator_RegEx              = RequestBodyMatchConditionParameters_Operator("RegEx")
)

// Mapping from string to RequestBodyMatchConditionParameters_Operator
var requestBodyMatchConditionParameters_Operator_Values = map[string]RequestBodyMatchConditionParameters_Operator{
	"any":                RequestBodyMatchConditionParameters_Operator_Any,
	"beginswith":         RequestBodyMatchConditionParameters_Operator_BeginsWith,
	"contains":           RequestBodyMatchConditionParameters_Operator_Contains,
	"endswith":           RequestBodyMatchConditionParameters_Operator_EndsWith,
	"equal":              RequestBodyMatchConditionParameters_Operator_Equal,
	"greaterthan":        RequestBodyMatchConditionParameters_Operator_GreaterThan,
	"greaterthanorequal": RequestBodyMatchConditionParameters_Operator_GreaterThanOrEqual,
	"lessthan":           RequestBodyMatchConditionParameters_Operator_LessThan,
	"lessthanorequal":    RequestBodyMatchConditionParameters_Operator_LessThanOrEqual,
	"regex":              RequestBodyMatchConditionParameters_Operator_RegEx,
}

type RequestBodyMatchConditionParameters_Operator_STATUS string

const (
	RequestBodyMatchConditionParameters_Operator_STATUS_Any                = RequestBodyMatchConditionParameters_Operator_STATUS("Any")
	RequestBodyMatchConditionParameters_Operator_STATUS_BeginsWith         = RequestBodyMatchConditionParameters_Operator_STATUS("BeginsWith")
	RequestBodyMatchConditionParameters_Operator_STATUS_Contains           = RequestBodyMatchConditionParameters_Operator_STATUS("Contains")
	RequestBodyMatchConditionParameters_Operator_STATUS_EndsWith           = RequestBodyMatchConditionParameters_Operator_STATUS("EndsWith")
	RequestBodyMatchConditionParameters_Operator_STATUS_Equal              = RequestBodyMatchConditionParameters_Operator_STATUS("Equal")
	RequestBodyMatchConditionParameters_Operator_STATUS_GreaterThan        = RequestBodyMatchConditionParameters_Operator_STATUS("GreaterThan")
	RequestBodyMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual = RequestBodyMatchConditionParameters_Operator_STATUS("GreaterThanOrEqual")
	RequestBodyMatchConditionParameters_Operator_STATUS_LessThan           = RequestBodyMatchConditionParameters_Operator_STATUS("LessThan")
	RequestBodyMatchConditionParameters_Operator_STATUS_LessThanOrEqual    = RequestBodyMatchConditionParameters_Operator_STATUS("LessThanOrEqual")
	RequestBodyMatchConditionParameters_Operator_STATUS_RegEx              = RequestBodyMatchConditionParameters_Operator_STATUS("RegEx")
)

// Mapping from string to RequestBodyMatchConditionParameters_Operator_STATUS
var requestBodyMatchConditionParameters_Operator_STATUS_Values = map[string]RequestBodyMatchConditionParameters_Operator_STATUS{
	"any":                RequestBodyMatchConditionParameters_Operator_STATUS_Any,
	"beginswith":         RequestBodyMatchConditionParameters_Operator_STATUS_BeginsWith,
	"contains":           RequestBodyMatchConditionParameters_Operator_STATUS_Contains,
	"endswith":           RequestBodyMatchConditionParameters_Operator_STATUS_EndsWith,
	"equal":              RequestBodyMatchConditionParameters_Operator_STATUS_Equal,
	"greaterthan":        RequestBodyMatchConditionParameters_Operator_STATUS_GreaterThan,
	"greaterthanorequal": RequestBodyMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual,
	"lessthan":           RequestBodyMatchConditionParameters_Operator_STATUS_LessThan,
	"lessthanorequal":    RequestBodyMatchConditionParameters_Operator_STATUS_LessThanOrEqual,
	"regex":              RequestBodyMatchConditionParameters_Operator_STATUS_RegEx,
}

// +kubebuilder:validation:Enum={"DeliveryRuleRequestBodyConditionParameters"}
type RequestBodyMatchConditionParameters_TypeName string

const RequestBodyMatchConditionParameters_TypeName_DeliveryRuleRequestBodyConditionParameters = RequestBodyMatchConditionParameters_TypeName("DeliveryRuleRequestBodyConditionParameters")

// Mapping from string to RequestBodyMatchConditionParameters_TypeName
var requestBodyMatchConditionParameters_TypeName_Values = map[string]RequestBodyMatchConditionParameters_TypeName{
	"deliveryrulerequestbodyconditionparameters": RequestBodyMatchConditionParameters_TypeName_DeliveryRuleRequestBodyConditionParameters,
}

type RequestBodyMatchConditionParameters_TypeName_STATUS string

const RequestBodyMatchConditionParameters_TypeName_STATUS_DeliveryRuleRequestBodyConditionParameters = RequestBodyMatchConditionParameters_TypeName_STATUS("DeliveryRuleRequestBodyConditionParameters")

// Mapping from string to RequestBodyMatchConditionParameters_TypeName_STATUS
var requestBodyMatchConditionParameters_TypeName_STATUS_Values = map[string]RequestBodyMatchConditionParameters_TypeName_STATUS{
	"deliveryrulerequestbodyconditionparameters": RequestBodyMatchConditionParameters_TypeName_STATUS_DeliveryRuleRequestBodyConditionParameters,
}

// +kubebuilder:validation:Enum={"Any","BeginsWith","Contains","EndsWith","Equal","GreaterThan","GreaterThanOrEqual","LessThan","LessThanOrEqual","RegEx"}
type RequestHeaderMatchConditionParameters_Operator string

const (
	RequestHeaderMatchConditionParameters_Operator_Any                = RequestHeaderMatchConditionParameters_Operator("Any")
	RequestHeaderMatchConditionParameters_Operator_BeginsWith         = RequestHeaderMatchConditionParameters_Operator("BeginsWith")
	RequestHeaderMatchConditionParameters_Operator_Contains           = RequestHeaderMatchConditionParameters_Operator("Contains")
	RequestHeaderMatchConditionParameters_Operator_EndsWith           = RequestHeaderMatchConditionParameters_Operator("EndsWith")
	RequestHeaderMatchConditionParameters_Operator_Equal              = RequestHeaderMatchConditionParameters_Operator("Equal")
	RequestHeaderMatchConditionParameters_Operator_GreaterThan        = RequestHeaderMatchConditionParameters_Operator("GreaterThan")
	RequestHeaderMatchConditionParameters_Operator_GreaterThanOrEqual = RequestHeaderMatchConditionParameters_Operator("GreaterThanOrEqual")
	RequestHeaderMatchConditionParameters_Operator_LessThan           = RequestHeaderMatchConditionParameters_Operator("LessThan")
	RequestHeaderMatchConditionParameters_Operator_LessThanOrEqual    = RequestHeaderMatchConditionParameters_Operator("LessThanOrEqual")
	RequestHeaderMatchConditionParameters_Operator_RegEx              = RequestHeaderMatchConditionParameters_Operator("RegEx")
)

// Mapping from string to RequestHeaderMatchConditionParameters_Operator
var requestHeaderMatchConditionParameters_Operator_Values = map[string]RequestHeaderMatchConditionParameters_Operator{
	"any":                RequestHeaderMatchConditionParameters_Operator_Any,
	"beginswith":         RequestHeaderMatchConditionParameters_Operator_BeginsWith,
	"contains":           RequestHeaderMatchConditionParameters_Operator_Contains,
	"endswith":           RequestHeaderMatchConditionParameters_Operator_EndsWith,
	"equal":              RequestHeaderMatchConditionParameters_Operator_Equal,
	"greaterthan":        RequestHeaderMatchConditionParameters_Operator_GreaterThan,
	"greaterthanorequal": RequestHeaderMatchConditionParameters_Operator_GreaterThanOrEqual,
	"lessthan":           RequestHeaderMatchConditionParameters_Operator_LessThan,
	"lessthanorequal":    RequestHeaderMatchConditionParameters_Operator_LessThanOrEqual,
	"regex":              RequestHeaderMatchConditionParameters_Operator_RegEx,
}

type RequestHeaderMatchConditionParameters_Operator_STATUS string

const (
	RequestHeaderMatchConditionParameters_Operator_STATUS_Any                = RequestHeaderMatchConditionParameters_Operator_STATUS("Any")
	RequestHeaderMatchConditionParameters_Operator_STATUS_BeginsWith         = RequestHeaderMatchConditionParameters_Operator_STATUS("BeginsWith")
	RequestHeaderMatchConditionParameters_Operator_STATUS_Contains           = RequestHeaderMatchConditionParameters_Operator_STATUS("Contains")
	RequestHeaderMatchConditionParameters_Operator_STATUS_EndsWith           = RequestHeaderMatchConditionParameters_Operator_STATUS("EndsWith")
	RequestHeaderMatchConditionParameters_Operator_STATUS_Equal              = RequestHeaderMatchConditionParameters_Operator_STATUS("Equal")
	RequestHeaderMatchConditionParameters_Operator_STATUS_GreaterThan        = RequestHeaderMatchConditionParameters_Operator_STATUS("GreaterThan")
	RequestHeaderMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual = RequestHeaderMatchConditionParameters_Operator_STATUS("GreaterThanOrEqual")
	RequestHeaderMatchConditionParameters_Operator_STATUS_LessThan           = RequestHeaderMatchConditionParameters_Operator_STATUS("LessThan")
	RequestHeaderMatchConditionParameters_Operator_STATUS_LessThanOrEqual    = RequestHeaderMatchConditionParameters_Operator_STATUS("LessThanOrEqual")
	RequestHeaderMatchConditionParameters_Operator_STATUS_RegEx              = RequestHeaderMatchConditionParameters_Operator_STATUS("RegEx")
)

// Mapping from string to RequestHeaderMatchConditionParameters_Operator_STATUS
var requestHeaderMatchConditionParameters_Operator_STATUS_Values = map[string]RequestHeaderMatchConditionParameters_Operator_STATUS{
	"any":                RequestHeaderMatchConditionParameters_Operator_STATUS_Any,
	"beginswith":         RequestHeaderMatchConditionParameters_Operator_STATUS_BeginsWith,
	"contains":           RequestHeaderMatchConditionParameters_Operator_STATUS_Contains,
	"endswith":           RequestHeaderMatchConditionParameters_Operator_STATUS_EndsWith,
	"equal":              RequestHeaderMatchConditionParameters_Operator_STATUS_Equal,
	"greaterthan":        RequestHeaderMatchConditionParameters_Operator_STATUS_GreaterThan,
	"greaterthanorequal": RequestHeaderMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual,
	"lessthan":           RequestHeaderMatchConditionParameters_Operator_STATUS_LessThan,
	"lessthanorequal":    RequestHeaderMatchConditionParameters_Operator_STATUS_LessThanOrEqual,
	"regex":              RequestHeaderMatchConditionParameters_Operator_STATUS_RegEx,
}

// +kubebuilder:validation:Enum={"DeliveryRuleRequestHeaderConditionParameters"}
type RequestHeaderMatchConditionParameters_TypeName string

const RequestHeaderMatchConditionParameters_TypeName_DeliveryRuleRequestHeaderConditionParameters = RequestHeaderMatchConditionParameters_TypeName("DeliveryRuleRequestHeaderConditionParameters")

// Mapping from string to RequestHeaderMatchConditionParameters_TypeName
var requestHeaderMatchConditionParameters_TypeName_Values = map[string]RequestHeaderMatchConditionParameters_TypeName{
	"deliveryrulerequestheaderconditionparameters": RequestHeaderMatchConditionParameters_TypeName_DeliveryRuleRequestHeaderConditionParameters,
}

type RequestHeaderMatchConditionParameters_TypeName_STATUS string

const RequestHeaderMatchConditionParameters_TypeName_STATUS_DeliveryRuleRequestHeaderConditionParameters = RequestHeaderMatchConditionParameters_TypeName_STATUS("DeliveryRuleRequestHeaderConditionParameters")

// Mapping from string to RequestHeaderMatchConditionParameters_TypeName_STATUS
var requestHeaderMatchConditionParameters_TypeName_STATUS_Values = map[string]RequestHeaderMatchConditionParameters_TypeName_STATUS{
	"deliveryrulerequestheaderconditionparameters": RequestHeaderMatchConditionParameters_TypeName_STATUS_DeliveryRuleRequestHeaderConditionParameters,
}

// +kubebuilder:validation:Enum={"DELETE","GET","HEAD","OPTIONS","POST","PUT","TRACE"}
type RequestMethodMatchConditionParameters_MatchValues string

const (
	RequestMethodMatchConditionParameters_MatchValues_DELETE  = RequestMethodMatchConditionParameters_MatchValues("DELETE")
	RequestMethodMatchConditionParameters_MatchValues_GET     = RequestMethodMatchConditionParameters_MatchValues("GET")
	RequestMethodMatchConditionParameters_MatchValues_HEAD    = RequestMethodMatchConditionParameters_MatchValues("HEAD")
	RequestMethodMatchConditionParameters_MatchValues_OPTIONS = RequestMethodMatchConditionParameters_MatchValues("OPTIONS")
	RequestMethodMatchConditionParameters_MatchValues_POST    = RequestMethodMatchConditionParameters_MatchValues("POST")
	RequestMethodMatchConditionParameters_MatchValues_PUT     = RequestMethodMatchConditionParameters_MatchValues("PUT")
	RequestMethodMatchConditionParameters_MatchValues_TRACE   = RequestMethodMatchConditionParameters_MatchValues("TRACE")
)

// Mapping from string to RequestMethodMatchConditionParameters_MatchValues
var requestMethodMatchConditionParameters_MatchValues_Values = map[string]RequestMethodMatchConditionParameters_MatchValues{
	"delete":  RequestMethodMatchConditionParameters_MatchValues_DELETE,
	"get":     RequestMethodMatchConditionParameters_MatchValues_GET,
	"head":    RequestMethodMatchConditionParameters_MatchValues_HEAD,
	"options": RequestMethodMatchConditionParameters_MatchValues_OPTIONS,
	"post":    RequestMethodMatchConditionParameters_MatchValues_POST,
	"put":     RequestMethodMatchConditionParameters_MatchValues_PUT,
	"trace":   RequestMethodMatchConditionParameters_MatchValues_TRACE,
}

type RequestMethodMatchConditionParameters_MatchValues_STATUS string

const (
	RequestMethodMatchConditionParameters_MatchValues_STATUS_DELETE  = RequestMethodMatchConditionParameters_MatchValues_STATUS("DELETE")
	RequestMethodMatchConditionParameters_MatchValues_STATUS_GET     = RequestMethodMatchConditionParameters_MatchValues_STATUS("GET")
	RequestMethodMatchConditionParameters_MatchValues_STATUS_HEAD    = RequestMethodMatchConditionParameters_MatchValues_STATUS("HEAD")
	RequestMethodMatchConditionParameters_MatchValues_STATUS_OPTIONS = RequestMethodMatchConditionParameters_MatchValues_STATUS("OPTIONS")
	RequestMethodMatchConditionParameters_MatchValues_STATUS_POST    = RequestMethodMatchConditionParameters_MatchValues_STATUS("POST")
	RequestMethodMatchConditionParameters_MatchValues_STATUS_PUT     = RequestMethodMatchConditionParameters_MatchValues_STATUS("PUT")
	RequestMethodMatchConditionParameters_MatchValues_STATUS_TRACE   = RequestMethodMatchConditionParameters_MatchValues_STATUS("TRACE")
)

// Mapping from string to RequestMethodMatchConditionParameters_MatchValues_STATUS
var requestMethodMatchConditionParameters_MatchValues_STATUS_Values = map[string]RequestMethodMatchConditionParameters_MatchValues_STATUS{
	"delete":  RequestMethodMatchConditionParameters_MatchValues_STATUS_DELETE,
	"get":     RequestMethodMatchConditionParameters_MatchValues_STATUS_GET,
	"head":    RequestMethodMatchConditionParameters_MatchValues_STATUS_HEAD,
	"options": RequestMethodMatchConditionParameters_MatchValues_STATUS_OPTIONS,
	"post":    RequestMethodMatchConditionParameters_MatchValues_STATUS_POST,
	"put":     RequestMethodMatchConditionParameters_MatchValues_STATUS_PUT,
	"trace":   RequestMethodMatchConditionParameters_MatchValues_STATUS_TRACE,
}

// +kubebuilder:validation:Enum={"Equal"}
type RequestMethodMatchConditionParameters_Operator string

const RequestMethodMatchConditionParameters_Operator_Equal = RequestMethodMatchConditionParameters_Operator("Equal")

// Mapping from string to RequestMethodMatchConditionParameters_Operator
var requestMethodMatchConditionParameters_Operator_Values = map[string]RequestMethodMatchConditionParameters_Operator{
	"equal": RequestMethodMatchConditionParameters_Operator_Equal,
}

type RequestMethodMatchConditionParameters_Operator_STATUS string

const RequestMethodMatchConditionParameters_Operator_STATUS_Equal = RequestMethodMatchConditionParameters_Operator_STATUS("Equal")

// Mapping from string to RequestMethodMatchConditionParameters_Operator_STATUS
var requestMethodMatchConditionParameters_Operator_STATUS_Values = map[string]RequestMethodMatchConditionParameters_Operator_STATUS{
	"equal": RequestMethodMatchConditionParameters_Operator_STATUS_Equal,
}

// +kubebuilder:validation:Enum={"DeliveryRuleRequestMethodConditionParameters"}
type RequestMethodMatchConditionParameters_TypeName string

const RequestMethodMatchConditionParameters_TypeName_DeliveryRuleRequestMethodConditionParameters = RequestMethodMatchConditionParameters_TypeName("DeliveryRuleRequestMethodConditionParameters")

// Mapping from string to RequestMethodMatchConditionParameters_TypeName
var requestMethodMatchConditionParameters_TypeName_Values = map[string]RequestMethodMatchConditionParameters_TypeName{
	"deliveryrulerequestmethodconditionparameters": RequestMethodMatchConditionParameters_TypeName_DeliveryRuleRequestMethodConditionParameters,
}

type RequestMethodMatchConditionParameters_TypeName_STATUS string

const RequestMethodMatchConditionParameters_TypeName_STATUS_DeliveryRuleRequestMethodConditionParameters = RequestMethodMatchConditionParameters_TypeName_STATUS("DeliveryRuleRequestMethodConditionParameters")

// Mapping from string to RequestMethodMatchConditionParameters_TypeName_STATUS
var requestMethodMatchConditionParameters_TypeName_STATUS_Values = map[string]RequestMethodMatchConditionParameters_TypeName_STATUS{
	"deliveryrulerequestmethodconditionparameters": RequestMethodMatchConditionParameters_TypeName_STATUS_DeliveryRuleRequestMethodConditionParameters,
}

// +kubebuilder:validation:Enum={"HTTP","HTTPS"}
type RequestSchemeMatchConditionParameters_MatchValues string

const (
	RequestSchemeMatchConditionParameters_MatchValues_HTTP  = RequestSchemeMatchConditionParameters_MatchValues("HTTP")
	RequestSchemeMatchConditionParameters_MatchValues_HTTPS = RequestSchemeMatchConditionParameters_MatchValues("HTTPS")
)

// Mapping from string to RequestSchemeMatchConditionParameters_MatchValues
var requestSchemeMatchConditionParameters_MatchValues_Values = map[string]RequestSchemeMatchConditionParameters_MatchValues{
	"http":  RequestSchemeMatchConditionParameters_MatchValues_HTTP,
	"https": RequestSchemeMatchConditionParameters_MatchValues_HTTPS,
}

type RequestSchemeMatchConditionParameters_MatchValues_STATUS string

const (
	RequestSchemeMatchConditionParameters_MatchValues_STATUS_HTTP  = RequestSchemeMatchConditionParameters_MatchValues_STATUS("HTTP")
	RequestSchemeMatchConditionParameters_MatchValues_STATUS_HTTPS = RequestSchemeMatchConditionParameters_MatchValues_STATUS("HTTPS")
)

// Mapping from string to RequestSchemeMatchConditionParameters_MatchValues_STATUS
var requestSchemeMatchConditionParameters_MatchValues_STATUS_Values = map[string]RequestSchemeMatchConditionParameters_MatchValues_STATUS{
	"http":  RequestSchemeMatchConditionParameters_MatchValues_STATUS_HTTP,
	"https": RequestSchemeMatchConditionParameters_MatchValues_STATUS_HTTPS,
}

// +kubebuilder:validation:Enum={"Equal"}
type RequestSchemeMatchConditionParameters_Operator string

const RequestSchemeMatchConditionParameters_Operator_Equal = RequestSchemeMatchConditionParameters_Operator("Equal")

// Mapping from string to RequestSchemeMatchConditionParameters_Operator
var requestSchemeMatchConditionParameters_Operator_Values = map[string]RequestSchemeMatchConditionParameters_Operator{
	"equal": RequestSchemeMatchConditionParameters_Operator_Equal,
}

type RequestSchemeMatchConditionParameters_Operator_STATUS string

const RequestSchemeMatchConditionParameters_Operator_STATUS_Equal = RequestSchemeMatchConditionParameters_Operator_STATUS("Equal")

// Mapping from string to RequestSchemeMatchConditionParameters_Operator_STATUS
var requestSchemeMatchConditionParameters_Operator_STATUS_Values = map[string]RequestSchemeMatchConditionParameters_Operator_STATUS{
	"equal": RequestSchemeMatchConditionParameters_Operator_STATUS_Equal,
}

// +kubebuilder:validation:Enum={"DeliveryRuleRequestSchemeConditionParameters"}
type RequestSchemeMatchConditionParameters_TypeName string

const RequestSchemeMatchConditionParameters_TypeName_DeliveryRuleRequestSchemeConditionParameters = RequestSchemeMatchConditionParameters_TypeName("DeliveryRuleRequestSchemeConditionParameters")

// Mapping from string to RequestSchemeMatchConditionParameters_TypeName
var requestSchemeMatchConditionParameters_TypeName_Values = map[string]RequestSchemeMatchConditionParameters_TypeName{
	"deliveryrulerequestschemeconditionparameters": RequestSchemeMatchConditionParameters_TypeName_DeliveryRuleRequestSchemeConditionParameters,
}

type RequestSchemeMatchConditionParameters_TypeName_STATUS string

const RequestSchemeMatchConditionParameters_TypeName_STATUS_DeliveryRuleRequestSchemeConditionParameters = RequestSchemeMatchConditionParameters_TypeName_STATUS("DeliveryRuleRequestSchemeConditionParameters")

// Mapping from string to RequestSchemeMatchConditionParameters_TypeName_STATUS
var requestSchemeMatchConditionParameters_TypeName_STATUS_Values = map[string]RequestSchemeMatchConditionParameters_TypeName_STATUS{
	"deliveryrulerequestschemeconditionparameters": RequestSchemeMatchConditionParameters_TypeName_STATUS_DeliveryRuleRequestSchemeConditionParameters,
}

// +kubebuilder:validation:Enum={"Any","BeginsWith","Contains","EndsWith","Equal","GreaterThan","GreaterThanOrEqual","LessThan","LessThanOrEqual","RegEx"}
type RequestUriMatchConditionParameters_Operator string

const (
	RequestUriMatchConditionParameters_Operator_Any                = RequestUriMatchConditionParameters_Operator("Any")
	RequestUriMatchConditionParameters_Operator_BeginsWith         = RequestUriMatchConditionParameters_Operator("BeginsWith")
	RequestUriMatchConditionParameters_Operator_Contains           = RequestUriMatchConditionParameters_Operator("Contains")
	RequestUriMatchConditionParameters_Operator_EndsWith           = RequestUriMatchConditionParameters_Operator("EndsWith")
	RequestUriMatchConditionParameters_Operator_Equal              = RequestUriMatchConditionParameters_Operator("Equal")
	RequestUriMatchConditionParameters_Operator_GreaterThan        = RequestUriMatchConditionParameters_Operator("GreaterThan")
	RequestUriMatchConditionParameters_Operator_GreaterThanOrEqual = RequestUriMatchConditionParameters_Operator("GreaterThanOrEqual")
	RequestUriMatchConditionParameters_Operator_LessThan           = RequestUriMatchConditionParameters_Operator("LessThan")
	RequestUriMatchConditionParameters_Operator_LessThanOrEqual    = RequestUriMatchConditionParameters_Operator("LessThanOrEqual")
	RequestUriMatchConditionParameters_Operator_RegEx              = RequestUriMatchConditionParameters_Operator("RegEx")
)

// Mapping from string to RequestUriMatchConditionParameters_Operator
var requestUriMatchConditionParameters_Operator_Values = map[string]RequestUriMatchConditionParameters_Operator{
	"any":                RequestUriMatchConditionParameters_Operator_Any,
	"beginswith":         RequestUriMatchConditionParameters_Operator_BeginsWith,
	"contains":           RequestUriMatchConditionParameters_Operator_Contains,
	"endswith":           RequestUriMatchConditionParameters_Operator_EndsWith,
	"equal":              RequestUriMatchConditionParameters_Operator_Equal,
	"greaterthan":        RequestUriMatchConditionParameters_Operator_GreaterThan,
	"greaterthanorequal": RequestUriMatchConditionParameters_Operator_GreaterThanOrEqual,
	"lessthan":           RequestUriMatchConditionParameters_Operator_LessThan,
	"lessthanorequal":    RequestUriMatchConditionParameters_Operator_LessThanOrEqual,
	"regex":              RequestUriMatchConditionParameters_Operator_RegEx,
}

type RequestUriMatchConditionParameters_Operator_STATUS string

const (
	RequestUriMatchConditionParameters_Operator_STATUS_Any                = RequestUriMatchConditionParameters_Operator_STATUS("Any")
	RequestUriMatchConditionParameters_Operator_STATUS_BeginsWith         = RequestUriMatchConditionParameters_Operator_STATUS("BeginsWith")
	RequestUriMatchConditionParameters_Operator_STATUS_Contains           = RequestUriMatchConditionParameters_Operator_STATUS("Contains")
	RequestUriMatchConditionParameters_Operator_STATUS_EndsWith           = RequestUriMatchConditionParameters_Operator_STATUS("EndsWith")
	RequestUriMatchConditionParameters_Operator_STATUS_Equal              = RequestUriMatchConditionParameters_Operator_STATUS("Equal")
	RequestUriMatchConditionParameters_Operator_STATUS_GreaterThan        = RequestUriMatchConditionParameters_Operator_STATUS("GreaterThan")
	RequestUriMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual = RequestUriMatchConditionParameters_Operator_STATUS("GreaterThanOrEqual")
	RequestUriMatchConditionParameters_Operator_STATUS_LessThan           = RequestUriMatchConditionParameters_Operator_STATUS("LessThan")
	RequestUriMatchConditionParameters_Operator_STATUS_LessThanOrEqual    = RequestUriMatchConditionParameters_Operator_STATUS("LessThanOrEqual")
	RequestUriMatchConditionParameters_Operator_STATUS_RegEx              = RequestUriMatchConditionParameters_Operator_STATUS("RegEx")
)

// Mapping from string to RequestUriMatchConditionParameters_Operator_STATUS
var requestUriMatchConditionParameters_Operator_STATUS_Values = map[string]RequestUriMatchConditionParameters_Operator_STATUS{
	"any":                RequestUriMatchConditionParameters_Operator_STATUS_Any,
	"beginswith":         RequestUriMatchConditionParameters_Operator_STATUS_BeginsWith,
	"contains":           RequestUriMatchConditionParameters_Operator_STATUS_Contains,
	"endswith":           RequestUriMatchConditionParameters_Operator_STATUS_EndsWith,
	"equal":              RequestUriMatchConditionParameters_Operator_STATUS_Equal,
	"greaterthan":        RequestUriMatchConditionParameters_Operator_STATUS_GreaterThan,
	"greaterthanorequal": RequestUriMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual,
	"lessthan":           RequestUriMatchConditionParameters_Operator_STATUS_LessThan,
	"lessthanorequal":    RequestUriMatchConditionParameters_Operator_STATUS_LessThanOrEqual,
	"regex":              RequestUriMatchConditionParameters_Operator_STATUS_RegEx,
}

// +kubebuilder:validation:Enum={"DeliveryRuleRequestUriConditionParameters"}
type RequestUriMatchConditionParameters_TypeName string

const RequestUriMatchConditionParameters_TypeName_DeliveryRuleRequestUriConditionParameters = RequestUriMatchConditionParameters_TypeName("DeliveryRuleRequestUriConditionParameters")

// Mapping from string to RequestUriMatchConditionParameters_TypeName
var requestUriMatchConditionParameters_TypeName_Values = map[string]RequestUriMatchConditionParameters_TypeName{
	"deliveryrulerequesturiconditionparameters": RequestUriMatchConditionParameters_TypeName_DeliveryRuleRequestUriConditionParameters,
}

type RequestUriMatchConditionParameters_TypeName_STATUS string

const RequestUriMatchConditionParameters_TypeName_STATUS_DeliveryRuleRequestUriConditionParameters = RequestUriMatchConditionParameters_TypeName_STATUS("DeliveryRuleRequestUriConditionParameters")

// Mapping from string to RequestUriMatchConditionParameters_TypeName_STATUS
var requestUriMatchConditionParameters_TypeName_STATUS_Values = map[string]RequestUriMatchConditionParameters_TypeName_STATUS{
	"deliveryrulerequesturiconditionparameters": RequestUriMatchConditionParameters_TypeName_STATUS_DeliveryRuleRequestUriConditionParameters,
}

// +kubebuilder:validation:Enum={"DeliveryRuleRouteConfigurationOverrideActionParameters"}
type RouteConfigurationOverrideActionParameters_TypeName string

const RouteConfigurationOverrideActionParameters_TypeName_DeliveryRuleRouteConfigurationOverrideActionParameters = RouteConfigurationOverrideActionParameters_TypeName("DeliveryRuleRouteConfigurationOverrideActionParameters")

// Mapping from string to RouteConfigurationOverrideActionParameters_TypeName
var routeConfigurationOverrideActionParameters_TypeName_Values = map[string]RouteConfigurationOverrideActionParameters_TypeName{
	"deliveryrulerouteconfigurationoverrideactionparameters": RouteConfigurationOverrideActionParameters_TypeName_DeliveryRuleRouteConfigurationOverrideActionParameters,
}

type RouteConfigurationOverrideActionParameters_TypeName_STATUS string

const RouteConfigurationOverrideActionParameters_TypeName_STATUS_DeliveryRuleRouteConfigurationOverrideActionParameters = RouteConfigurationOverrideActionParameters_TypeName_STATUS("DeliveryRuleRouteConfigurationOverrideActionParameters")

// Mapping from string to RouteConfigurationOverrideActionParameters_TypeName_STATUS
var routeConfigurationOverrideActionParameters_TypeName_STATUS_Values = map[string]RouteConfigurationOverrideActionParameters_TypeName_STATUS{
	"deliveryrulerouteconfigurationoverrideactionparameters": RouteConfigurationOverrideActionParameters_TypeName_STATUS_DeliveryRuleRouteConfigurationOverrideActionParameters,
}

// +kubebuilder:validation:Enum={"Any","BeginsWith","Contains","EndsWith","Equal","GreaterThan","GreaterThanOrEqual","LessThan","LessThanOrEqual","RegEx"}
type ServerPortMatchConditionParameters_Operator string

const (
	ServerPortMatchConditionParameters_Operator_Any                = ServerPortMatchConditionParameters_Operator("Any")
	ServerPortMatchConditionParameters_Operator_BeginsWith         = ServerPortMatchConditionParameters_Operator("BeginsWith")
	ServerPortMatchConditionParameters_Operator_Contains           = ServerPortMatchConditionParameters_Operator("Contains")
	ServerPortMatchConditionParameters_Operator_EndsWith           = ServerPortMatchConditionParameters_Operator("EndsWith")
	ServerPortMatchConditionParameters_Operator_Equal              = ServerPortMatchConditionParameters_Operator("Equal")
	ServerPortMatchConditionParameters_Operator_GreaterThan        = ServerPortMatchConditionParameters_Operator("GreaterThan")
	ServerPortMatchConditionParameters_Operator_GreaterThanOrEqual = ServerPortMatchConditionParameters_Operator("GreaterThanOrEqual")
	ServerPortMatchConditionParameters_Operator_LessThan           = ServerPortMatchConditionParameters_Operator("LessThan")
	ServerPortMatchConditionParameters_Operator_LessThanOrEqual    = ServerPortMatchConditionParameters_Operator("LessThanOrEqual")
	ServerPortMatchConditionParameters_Operator_RegEx              = ServerPortMatchConditionParameters_Operator("RegEx")
)

// Mapping from string to ServerPortMatchConditionParameters_Operator
var serverPortMatchConditionParameters_Operator_Values = map[string]ServerPortMatchConditionParameters_Operator{
	"any":                ServerPortMatchConditionParameters_Operator_Any,
	"beginswith":         ServerPortMatchConditionParameters_Operator_BeginsWith,
	"contains":           ServerPortMatchConditionParameters_Operator_Contains,
	"endswith":           ServerPortMatchConditionParameters_Operator_EndsWith,
	"equal":              ServerPortMatchConditionParameters_Operator_Equal,
	"greaterthan":        ServerPortMatchConditionParameters_Operator_GreaterThan,
	"greaterthanorequal": ServerPortMatchConditionParameters_Operator_GreaterThanOrEqual,
	"lessthan":           ServerPortMatchConditionParameters_Operator_LessThan,
	"lessthanorequal":    ServerPortMatchConditionParameters_Operator_LessThanOrEqual,
	"regex":              ServerPortMatchConditionParameters_Operator_RegEx,
}

type ServerPortMatchConditionParameters_Operator_STATUS string

const (
	ServerPortMatchConditionParameters_Operator_STATUS_Any                = ServerPortMatchConditionParameters_Operator_STATUS("Any")
	ServerPortMatchConditionParameters_Operator_STATUS_BeginsWith         = ServerPortMatchConditionParameters_Operator_STATUS("BeginsWith")
	ServerPortMatchConditionParameters_Operator_STATUS_Contains           = ServerPortMatchConditionParameters_Operator_STATUS("Contains")
	ServerPortMatchConditionParameters_Operator_STATUS_EndsWith           = ServerPortMatchConditionParameters_Operator_STATUS("EndsWith")
	ServerPortMatchConditionParameters_Operator_STATUS_Equal              = ServerPortMatchConditionParameters_Operator_STATUS("Equal")
	ServerPortMatchConditionParameters_Operator_STATUS_GreaterThan        = ServerPortMatchConditionParameters_Operator_STATUS("GreaterThan")
	ServerPortMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual = ServerPortMatchConditionParameters_Operator_STATUS("GreaterThanOrEqual")
	ServerPortMatchConditionParameters_Operator_STATUS_LessThan           = ServerPortMatchConditionParameters_Operator_STATUS("LessThan")
	ServerPortMatchConditionParameters_Operator_STATUS_LessThanOrEqual    = ServerPortMatchConditionParameters_Operator_STATUS("LessThanOrEqual")
	ServerPortMatchConditionParameters_Operator_STATUS_RegEx              = ServerPortMatchConditionParameters_Operator_STATUS("RegEx")
)

// Mapping from string to ServerPortMatchConditionParameters_Operator_STATUS
var serverPortMatchConditionParameters_Operator_STATUS_Values = map[string]ServerPortMatchConditionParameters_Operator_STATUS{
	"any":                ServerPortMatchConditionParameters_Operator_STATUS_Any,
	"beginswith":         ServerPortMatchConditionParameters_Operator_STATUS_BeginsWith,
	"contains":           ServerPortMatchConditionParameters_Operator_STATUS_Contains,
	"endswith":           ServerPortMatchConditionParameters_Operator_STATUS_EndsWith,
	"equal":              ServerPortMatchConditionParameters_Operator_STATUS_Equal,
	"greaterthan":        ServerPortMatchConditionParameters_Operator_STATUS_GreaterThan,
	"greaterthanorequal": ServerPortMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual,
	"lessthan":           ServerPortMatchConditionParameters_Operator_STATUS_LessThan,
	"lessthanorequal":    ServerPortMatchConditionParameters_Operator_STATUS_LessThanOrEqual,
	"regex":              ServerPortMatchConditionParameters_Operator_STATUS_RegEx,
}

// +kubebuilder:validation:Enum={"DeliveryRuleServerPortConditionParameters"}
type ServerPortMatchConditionParameters_TypeName string

const ServerPortMatchConditionParameters_TypeName_DeliveryRuleServerPortConditionParameters = ServerPortMatchConditionParameters_TypeName("DeliveryRuleServerPortConditionParameters")

// Mapping from string to ServerPortMatchConditionParameters_TypeName
var serverPortMatchConditionParameters_TypeName_Values = map[string]ServerPortMatchConditionParameters_TypeName{
	"deliveryruleserverportconditionparameters": ServerPortMatchConditionParameters_TypeName_DeliveryRuleServerPortConditionParameters,
}

type ServerPortMatchConditionParameters_TypeName_STATUS string

const ServerPortMatchConditionParameters_TypeName_STATUS_DeliveryRuleServerPortConditionParameters = ServerPortMatchConditionParameters_TypeName_STATUS("DeliveryRuleServerPortConditionParameters")

// Mapping from string to ServerPortMatchConditionParameters_TypeName_STATUS
var serverPortMatchConditionParameters_TypeName_STATUS_Values = map[string]ServerPortMatchConditionParameters_TypeName_STATUS{
	"deliveryruleserverportconditionparameters": ServerPortMatchConditionParameters_TypeName_STATUS_DeliveryRuleServerPortConditionParameters,
}

// +kubebuilder:validation:Enum={"Any","IPMatch"}
type SocketAddrMatchConditionParameters_Operator string

const (
	SocketAddrMatchConditionParameters_Operator_Any     = SocketAddrMatchConditionParameters_Operator("Any")
	SocketAddrMatchConditionParameters_Operator_IPMatch = SocketAddrMatchConditionParameters_Operator("IPMatch")
)

// Mapping from string to SocketAddrMatchConditionParameters_Operator
var socketAddrMatchConditionParameters_Operator_Values = map[string]SocketAddrMatchConditionParameters_Operator{
	"any":     SocketAddrMatchConditionParameters_Operator_Any,
	"ipmatch": SocketAddrMatchConditionParameters_Operator_IPMatch,
}

type SocketAddrMatchConditionParameters_Operator_STATUS string

const (
	SocketAddrMatchConditionParameters_Operator_STATUS_Any     = SocketAddrMatchConditionParameters_Operator_STATUS("Any")
	SocketAddrMatchConditionParameters_Operator_STATUS_IPMatch = SocketAddrMatchConditionParameters_Operator_STATUS("IPMatch")
)

// Mapping from string to SocketAddrMatchConditionParameters_Operator_STATUS
var socketAddrMatchConditionParameters_Operator_STATUS_Values = map[string]SocketAddrMatchConditionParameters_Operator_STATUS{
	"any":     SocketAddrMatchConditionParameters_Operator_STATUS_Any,
	"ipmatch": SocketAddrMatchConditionParameters_Operator_STATUS_IPMatch,
}

// +kubebuilder:validation:Enum={"DeliveryRuleSocketAddrConditionParameters"}
type SocketAddrMatchConditionParameters_TypeName string

const SocketAddrMatchConditionParameters_TypeName_DeliveryRuleSocketAddrConditionParameters = SocketAddrMatchConditionParameters_TypeName("DeliveryRuleSocketAddrConditionParameters")

// Mapping from string to SocketAddrMatchConditionParameters_TypeName
var socketAddrMatchConditionParameters_TypeName_Values = map[string]SocketAddrMatchConditionParameters_TypeName{
	"deliveryrulesocketaddrconditionparameters": SocketAddrMatchConditionParameters_TypeName_DeliveryRuleSocketAddrConditionParameters,
}

type SocketAddrMatchConditionParameters_TypeName_STATUS string

const SocketAddrMatchConditionParameters_TypeName_STATUS_DeliveryRuleSocketAddrConditionParameters = SocketAddrMatchConditionParameters_TypeName_STATUS("DeliveryRuleSocketAddrConditionParameters")

// Mapping from string to SocketAddrMatchConditionParameters_TypeName_STATUS
var socketAddrMatchConditionParameters_TypeName_STATUS_Values = map[string]SocketAddrMatchConditionParameters_TypeName_STATUS{
	"deliveryrulesocketaddrconditionparameters": SocketAddrMatchConditionParameters_TypeName_STATUS_DeliveryRuleSocketAddrConditionParameters,
}

// The protocol of an established TLS connection.
// +kubebuilder:validation:Enum={"TLSv1","TLSv1.1","TLSv1.2"}
type SslProtocol string

const (
	SslProtocol_TLSv1  = SslProtocol("TLSv1")
	SslProtocol_TLSv11 = SslProtocol("TLSv1.1")
	SslProtocol_TLSv12 = SslProtocol("TLSv1.2")
)

// Mapping from string to SslProtocol
var sslProtocol_Values = map[string]SslProtocol{
	"tlsv1":   SslProtocol_TLSv1,
	"tlsv1.1": SslProtocol_TLSv11,
	"tlsv1.2": SslProtocol_TLSv12,
}

// The protocol of an established TLS connection.
type SslProtocol_STATUS string

const (
	SslProtocol_STATUS_TLSv1  = SslProtocol_STATUS("TLSv1")
	SslProtocol_STATUS_TLSv11 = SslProtocol_STATUS("TLSv1.1")
	SslProtocol_STATUS_TLSv12 = SslProtocol_STATUS("TLSv1.2")
)

// Mapping from string to SslProtocol_STATUS
var sslProtocol_STATUS_Values = map[string]SslProtocol_STATUS{
	"tlsv1":   SslProtocol_STATUS_TLSv1,
	"tlsv1.1": SslProtocol_STATUS_TLSv11,
	"tlsv1.2": SslProtocol_STATUS_TLSv12,
}

// +kubebuilder:validation:Enum={"Equal"}
type SslProtocolMatchConditionParameters_Operator string

const SslProtocolMatchConditionParameters_Operator_Equal = SslProtocolMatchConditionParameters_Operator("Equal")

// Mapping from string to SslProtocolMatchConditionParameters_Operator
var sslProtocolMatchConditionParameters_Operator_Values = map[string]SslProtocolMatchConditionParameters_Operator{
	"equal": SslProtocolMatchConditionParameters_Operator_Equal,
}

type SslProtocolMatchConditionParameters_Operator_STATUS string

const SslProtocolMatchConditionParameters_Operator_STATUS_Equal = SslProtocolMatchConditionParameters_Operator_STATUS("Equal")

// Mapping from string to SslProtocolMatchConditionParameters_Operator_STATUS
var sslProtocolMatchConditionParameters_Operator_STATUS_Values = map[string]SslProtocolMatchConditionParameters_Operator_STATUS{
	"equal": SslProtocolMatchConditionParameters_Operator_STATUS_Equal,
}

// +kubebuilder:validation:Enum={"DeliveryRuleSslProtocolConditionParameters"}
type SslProtocolMatchConditionParameters_TypeName string

const SslProtocolMatchConditionParameters_TypeName_DeliveryRuleSslProtocolConditionParameters = SslProtocolMatchConditionParameters_TypeName("DeliveryRuleSslProtocolConditionParameters")

// Mapping from string to SslProtocolMatchConditionParameters_TypeName
var sslProtocolMatchConditionParameters_TypeName_Values = map[string]SslProtocolMatchConditionParameters_TypeName{
	"deliveryrulesslprotocolconditionparameters": SslProtocolMatchConditionParameters_TypeName_DeliveryRuleSslProtocolConditionParameters,
}

type SslProtocolMatchConditionParameters_TypeName_STATUS string

const SslProtocolMatchConditionParameters_TypeName_STATUS_DeliveryRuleSslProtocolConditionParameters = SslProtocolMatchConditionParameters_TypeName_STATUS("DeliveryRuleSslProtocolConditionParameters")

// Mapping from string to SslProtocolMatchConditionParameters_TypeName_STATUS
var sslProtocolMatchConditionParameters_TypeName_STATUS_Values = map[string]SslProtocolMatchConditionParameters_TypeName_STATUS{
	"deliveryrulesslprotocolconditionparameters": SslProtocolMatchConditionParameters_TypeName_STATUS_DeliveryRuleSslProtocolConditionParameters,
}

// Describes what transforms are applied before matching
// +kubebuilder:validation:Enum={"Lowercase","RemoveNulls","Trim","Uppercase","UrlDecode","UrlEncode"}
type Transform string

const (
	Transform_Lowercase   = Transform("Lowercase")
	Transform_RemoveNulls = Transform("RemoveNulls")
	Transform_Trim        = Transform("Trim")
	Transform_Uppercase   = Transform("Uppercase")
	Transform_UrlDecode   = Transform("UrlDecode")
	Transform_UrlEncode   = Transform("UrlEncode")
)

// Mapping from string to Transform
var transform_Values = map[string]Transform{
	"lowercase":   Transform_Lowercase,
	"removenulls": Transform_RemoveNulls,
	"trim":        Transform_Trim,
	"uppercase":   Transform_Uppercase,
	"urldecode":   Transform_UrlDecode,
	"urlencode":   Transform_UrlEncode,
}

// Describes what transforms are applied before matching
type Transform_STATUS string

const (
	Transform_STATUS_Lowercase   = Transform_STATUS("Lowercase")
	Transform_STATUS_RemoveNulls = Transform_STATUS("RemoveNulls")
	Transform_STATUS_Trim        = Transform_STATUS("Trim")
	Transform_STATUS_Uppercase   = Transform_STATUS("Uppercase")
	Transform_STATUS_UrlDecode   = Transform_STATUS("UrlDecode")
	Transform_STATUS_UrlEncode   = Transform_STATUS("UrlEncode")
)

// Mapping from string to Transform_STATUS
var transform_STATUS_Values = map[string]Transform_STATUS{
	"lowercase":   Transform_STATUS_Lowercase,
	"removenulls": Transform_STATUS_RemoveNulls,
	"trim":        Transform_STATUS_Trim,
	"uppercase":   Transform_STATUS_Uppercase,
	"urldecode":   Transform_STATUS_UrlDecode,
	"urlencode":   Transform_STATUS_UrlEncode,
}

// +kubebuilder:validation:Enum={"Any","BeginsWith","Contains","EndsWith","Equal","GreaterThan","GreaterThanOrEqual","LessThan","LessThanOrEqual","RegEx"}
type UrlFileExtensionMatchConditionParameters_Operator string

const (
	UrlFileExtensionMatchConditionParameters_Operator_Any                = UrlFileExtensionMatchConditionParameters_Operator("Any")
	UrlFileExtensionMatchConditionParameters_Operator_BeginsWith         = UrlFileExtensionMatchConditionParameters_Operator("BeginsWith")
	UrlFileExtensionMatchConditionParameters_Operator_Contains           = UrlFileExtensionMatchConditionParameters_Operator("Contains")
	UrlFileExtensionMatchConditionParameters_Operator_EndsWith           = UrlFileExtensionMatchConditionParameters_Operator("EndsWith")
	UrlFileExtensionMatchConditionParameters_Operator_Equal              = UrlFileExtensionMatchConditionParameters_Operator("Equal")
	UrlFileExtensionMatchConditionParameters_Operator_GreaterThan        = UrlFileExtensionMatchConditionParameters_Operator("GreaterThan")
	UrlFileExtensionMatchConditionParameters_Operator_GreaterThanOrEqual = UrlFileExtensionMatchConditionParameters_Operator("GreaterThanOrEqual")
	UrlFileExtensionMatchConditionParameters_Operator_LessThan           = UrlFileExtensionMatchConditionParameters_Operator("LessThan")
	UrlFileExtensionMatchConditionParameters_Operator_LessThanOrEqual    = UrlFileExtensionMatchConditionParameters_Operator("LessThanOrEqual")
	UrlFileExtensionMatchConditionParameters_Operator_RegEx              = UrlFileExtensionMatchConditionParameters_Operator("RegEx")
)

// Mapping from string to UrlFileExtensionMatchConditionParameters_Operator
var urlFileExtensionMatchConditionParameters_Operator_Values = map[string]UrlFileExtensionMatchConditionParameters_Operator{
	"any":                UrlFileExtensionMatchConditionParameters_Operator_Any,
	"beginswith":         UrlFileExtensionMatchConditionParameters_Operator_BeginsWith,
	"contains":           UrlFileExtensionMatchConditionParameters_Operator_Contains,
	"endswith":           UrlFileExtensionMatchConditionParameters_Operator_EndsWith,
	"equal":              UrlFileExtensionMatchConditionParameters_Operator_Equal,
	"greaterthan":        UrlFileExtensionMatchConditionParameters_Operator_GreaterThan,
	"greaterthanorequal": UrlFileExtensionMatchConditionParameters_Operator_GreaterThanOrEqual,
	"lessthan":           UrlFileExtensionMatchConditionParameters_Operator_LessThan,
	"lessthanorequal":    UrlFileExtensionMatchConditionParameters_Operator_LessThanOrEqual,
	"regex":              UrlFileExtensionMatchConditionParameters_Operator_RegEx,
}

type UrlFileExtensionMatchConditionParameters_Operator_STATUS string

const (
	UrlFileExtensionMatchConditionParameters_Operator_STATUS_Any                = UrlFileExtensionMatchConditionParameters_Operator_STATUS("Any")
	UrlFileExtensionMatchConditionParameters_Operator_STATUS_BeginsWith         = UrlFileExtensionMatchConditionParameters_Operator_STATUS("BeginsWith")
	UrlFileExtensionMatchConditionParameters_Operator_STATUS_Contains           = UrlFileExtensionMatchConditionParameters_Operator_STATUS("Contains")
	UrlFileExtensionMatchConditionParameters_Operator_STATUS_EndsWith           = UrlFileExtensionMatchConditionParameters_Operator_STATUS("EndsWith")
	UrlFileExtensionMatchConditionParameters_Operator_STATUS_Equal              = UrlFileExtensionMatchConditionParameters_Operator_STATUS("Equal")
	UrlFileExtensionMatchConditionParameters_Operator_STATUS_GreaterThan        = UrlFileExtensionMatchConditionParameters_Operator_STATUS("GreaterThan")
	UrlFileExtensionMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual = UrlFileExtensionMatchConditionParameters_Operator_STATUS("GreaterThanOrEqual")
	UrlFileExtensionMatchConditionParameters_Operator_STATUS_LessThan           = UrlFileExtensionMatchConditionParameters_Operator_STATUS("LessThan")
	UrlFileExtensionMatchConditionParameters_Operator_STATUS_LessThanOrEqual    = UrlFileExtensionMatchConditionParameters_Operator_STATUS("LessThanOrEqual")
	UrlFileExtensionMatchConditionParameters_Operator_STATUS_RegEx              = UrlFileExtensionMatchConditionParameters_Operator_STATUS("RegEx")
)

// Mapping from string to UrlFileExtensionMatchConditionParameters_Operator_STATUS
var urlFileExtensionMatchConditionParameters_Operator_STATUS_Values = map[string]UrlFileExtensionMatchConditionParameters_Operator_STATUS{
	"any":                UrlFileExtensionMatchConditionParameters_Operator_STATUS_Any,
	"beginswith":         UrlFileExtensionMatchConditionParameters_Operator_STATUS_BeginsWith,
	"contains":           UrlFileExtensionMatchConditionParameters_Operator_STATUS_Contains,
	"endswith":           UrlFileExtensionMatchConditionParameters_Operator_STATUS_EndsWith,
	"equal":              UrlFileExtensionMatchConditionParameters_Operator_STATUS_Equal,
	"greaterthan":        UrlFileExtensionMatchConditionParameters_Operator_STATUS_GreaterThan,
	"greaterthanorequal": UrlFileExtensionMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual,
	"lessthan":           UrlFileExtensionMatchConditionParameters_Operator_STATUS_LessThan,
	"lessthanorequal":    UrlFileExtensionMatchConditionParameters_Operator_STATUS_LessThanOrEqual,
	"regex":              UrlFileExtensionMatchConditionParameters_Operator_STATUS_RegEx,
}

// +kubebuilder:validation:Enum={"DeliveryRuleUrlFileExtensionMatchConditionParameters"}
type UrlFileExtensionMatchConditionParameters_TypeName string

const UrlFileExtensionMatchConditionParameters_TypeName_DeliveryRuleUrlFileExtensionMatchConditionParameters = UrlFileExtensionMatchConditionParameters_TypeName("DeliveryRuleUrlFileExtensionMatchConditionParameters")

// Mapping from string to UrlFileExtensionMatchConditionParameters_TypeName
var urlFileExtensionMatchConditionParameters_TypeName_Values = map[string]UrlFileExtensionMatchConditionParameters_TypeName{
	"deliveryruleurlfileextensionmatchconditionparameters": UrlFileExtensionMatchConditionParameters_TypeName_DeliveryRuleUrlFileExtensionMatchConditionParameters,
}

type UrlFileExtensionMatchConditionParameters_TypeName_STATUS string

const UrlFileExtensionMatchConditionParameters_TypeName_STATUS_DeliveryRuleUrlFileExtensionMatchConditionParameters = UrlFileExtensionMatchConditionParameters_TypeName_STATUS("DeliveryRuleUrlFileExtensionMatchConditionParameters")

// Mapping from string to UrlFileExtensionMatchConditionParameters_TypeName_STATUS
var urlFileExtensionMatchConditionParameters_TypeName_STATUS_Values = map[string]UrlFileExtensionMatchConditionParameters_TypeName_STATUS{
	"deliveryruleurlfileextensionmatchconditionparameters": UrlFileExtensionMatchConditionParameters_TypeName_STATUS_DeliveryRuleUrlFileExtensionMatchConditionParameters,
}

// +kubebuilder:validation:Enum={"Any","BeginsWith","Contains","EndsWith","Equal","GreaterThan","GreaterThanOrEqual","LessThan","LessThanOrEqual","RegEx"}
type UrlFileNameMatchConditionParameters_Operator string

const (
	UrlFileNameMatchConditionParameters_Operator_Any                = UrlFileNameMatchConditionParameters_Operator("Any")
	UrlFileNameMatchConditionParameters_Operator_BeginsWith         = UrlFileNameMatchConditionParameters_Operator("BeginsWith")
	UrlFileNameMatchConditionParameters_Operator_Contains           = UrlFileNameMatchConditionParameters_Operator("Contains")
	UrlFileNameMatchConditionParameters_Operator_EndsWith           = UrlFileNameMatchConditionParameters_Operator("EndsWith")
	UrlFileNameMatchConditionParameters_Operator_Equal              = UrlFileNameMatchConditionParameters_Operator("Equal")
	UrlFileNameMatchConditionParameters_Operator_GreaterThan        = UrlFileNameMatchConditionParameters_Operator("GreaterThan")
	UrlFileNameMatchConditionParameters_Operator_GreaterThanOrEqual = UrlFileNameMatchConditionParameters_Operator("GreaterThanOrEqual")
	UrlFileNameMatchConditionParameters_Operator_LessThan           = UrlFileNameMatchConditionParameters_Operator("LessThan")
	UrlFileNameMatchConditionParameters_Operator_LessThanOrEqual    = UrlFileNameMatchConditionParameters_Operator("LessThanOrEqual")
	UrlFileNameMatchConditionParameters_Operator_RegEx              = UrlFileNameMatchConditionParameters_Operator("RegEx")
)

// Mapping from string to UrlFileNameMatchConditionParameters_Operator
var urlFileNameMatchConditionParameters_Operator_Values = map[string]UrlFileNameMatchConditionParameters_Operator{
	"any":                UrlFileNameMatchConditionParameters_Operator_Any,
	"beginswith":         UrlFileNameMatchConditionParameters_Operator_BeginsWith,
	"contains":           UrlFileNameMatchConditionParameters_Operator_Contains,
	"endswith":           UrlFileNameMatchConditionParameters_Operator_EndsWith,
	"equal":              UrlFileNameMatchConditionParameters_Operator_Equal,
	"greaterthan":        UrlFileNameMatchConditionParameters_Operator_GreaterThan,
	"greaterthanorequal": UrlFileNameMatchConditionParameters_Operator_GreaterThanOrEqual,
	"lessthan":           UrlFileNameMatchConditionParameters_Operator_LessThan,
	"lessthanorequal":    UrlFileNameMatchConditionParameters_Operator_LessThanOrEqual,
	"regex":              UrlFileNameMatchConditionParameters_Operator_RegEx,
}

type UrlFileNameMatchConditionParameters_Operator_STATUS string

const (
	UrlFileNameMatchConditionParameters_Operator_STATUS_Any                = UrlFileNameMatchConditionParameters_Operator_STATUS("Any")
	UrlFileNameMatchConditionParameters_Operator_STATUS_BeginsWith         = UrlFileNameMatchConditionParameters_Operator_STATUS("BeginsWith")
	UrlFileNameMatchConditionParameters_Operator_STATUS_Contains           = UrlFileNameMatchConditionParameters_Operator_STATUS("Contains")
	UrlFileNameMatchConditionParameters_Operator_STATUS_EndsWith           = UrlFileNameMatchConditionParameters_Operator_STATUS("EndsWith")
	UrlFileNameMatchConditionParameters_Operator_STATUS_Equal              = UrlFileNameMatchConditionParameters_Operator_STATUS("Equal")
	UrlFileNameMatchConditionParameters_Operator_STATUS_GreaterThan        = UrlFileNameMatchConditionParameters_Operator_STATUS("GreaterThan")
	UrlFileNameMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual = UrlFileNameMatchConditionParameters_Operator_STATUS("GreaterThanOrEqual")
	UrlFileNameMatchConditionParameters_Operator_STATUS_LessThan           = UrlFileNameMatchConditionParameters_Operator_STATUS("LessThan")
	UrlFileNameMatchConditionParameters_Operator_STATUS_LessThanOrEqual    = UrlFileNameMatchConditionParameters_Operator_STATUS("LessThanOrEqual")
	UrlFileNameMatchConditionParameters_Operator_STATUS_RegEx              = UrlFileNameMatchConditionParameters_Operator_STATUS("RegEx")
)

// Mapping from string to UrlFileNameMatchConditionParameters_Operator_STATUS
var urlFileNameMatchConditionParameters_Operator_STATUS_Values = map[string]UrlFileNameMatchConditionParameters_Operator_STATUS{
	"any":                UrlFileNameMatchConditionParameters_Operator_STATUS_Any,
	"beginswith":         UrlFileNameMatchConditionParameters_Operator_STATUS_BeginsWith,
	"contains":           UrlFileNameMatchConditionParameters_Operator_STATUS_Contains,
	"endswith":           UrlFileNameMatchConditionParameters_Operator_STATUS_EndsWith,
	"equal":              UrlFileNameMatchConditionParameters_Operator_STATUS_Equal,
	"greaterthan":        UrlFileNameMatchConditionParameters_Operator_STATUS_GreaterThan,
	"greaterthanorequal": UrlFileNameMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual,
	"lessthan":           UrlFileNameMatchConditionParameters_Operator_STATUS_LessThan,
	"lessthanorequal":    UrlFileNameMatchConditionParameters_Operator_STATUS_LessThanOrEqual,
	"regex":              UrlFileNameMatchConditionParameters_Operator_STATUS_RegEx,
}

// +kubebuilder:validation:Enum={"DeliveryRuleUrlFilenameConditionParameters"}
type UrlFileNameMatchConditionParameters_TypeName string

const UrlFileNameMatchConditionParameters_TypeName_DeliveryRuleUrlFilenameConditionParameters = UrlFileNameMatchConditionParameters_TypeName("DeliveryRuleUrlFilenameConditionParameters")

// Mapping from string to UrlFileNameMatchConditionParameters_TypeName
var urlFileNameMatchConditionParameters_TypeName_Values = map[string]UrlFileNameMatchConditionParameters_TypeName{
	"deliveryruleurlfilenameconditionparameters": UrlFileNameMatchConditionParameters_TypeName_DeliveryRuleUrlFilenameConditionParameters,
}

type UrlFileNameMatchConditionParameters_TypeName_STATUS string

const UrlFileNameMatchConditionParameters_TypeName_STATUS_DeliveryRuleUrlFilenameConditionParameters = UrlFileNameMatchConditionParameters_TypeName_STATUS("DeliveryRuleUrlFilenameConditionParameters")

// Mapping from string to UrlFileNameMatchConditionParameters_TypeName_STATUS
var urlFileNameMatchConditionParameters_TypeName_STATUS_Values = map[string]UrlFileNameMatchConditionParameters_TypeName_STATUS{
	"deliveryruleurlfilenameconditionparameters": UrlFileNameMatchConditionParameters_TypeName_STATUS_DeliveryRuleUrlFilenameConditionParameters,
}

// +kubebuilder:validation:Enum={"Any","BeginsWith","Contains","EndsWith","Equal","GreaterThan","GreaterThanOrEqual","LessThan","LessThanOrEqual","RegEx","Wildcard"}
type UrlPathMatchConditionParameters_Operator string

const (
	UrlPathMatchConditionParameters_Operator_Any                = UrlPathMatchConditionParameters_Operator("Any")
	UrlPathMatchConditionParameters_Operator_BeginsWith         = UrlPathMatchConditionParameters_Operator("BeginsWith")
	UrlPathMatchConditionParameters_Operator_Contains           = UrlPathMatchConditionParameters_Operator("Contains")
	UrlPathMatchConditionParameters_Operator_EndsWith           = UrlPathMatchConditionParameters_Operator("EndsWith")
	UrlPathMatchConditionParameters_Operator_Equal              = UrlPathMatchConditionParameters_Operator("Equal")
	UrlPathMatchConditionParameters_Operator_GreaterThan        = UrlPathMatchConditionParameters_Operator("GreaterThan")
	UrlPathMatchConditionParameters_Operator_GreaterThanOrEqual = UrlPathMatchConditionParameters_Operator("GreaterThanOrEqual")
	UrlPathMatchConditionParameters_Operator_LessThan           = UrlPathMatchConditionParameters_Operator("LessThan")
	UrlPathMatchConditionParameters_Operator_LessThanOrEqual    = UrlPathMatchConditionParameters_Operator("LessThanOrEqual")
	UrlPathMatchConditionParameters_Operator_RegEx              = UrlPathMatchConditionParameters_Operator("RegEx")
	UrlPathMatchConditionParameters_Operator_Wildcard           = UrlPathMatchConditionParameters_Operator("Wildcard")
)

// Mapping from string to UrlPathMatchConditionParameters_Operator
var urlPathMatchConditionParameters_Operator_Values = map[string]UrlPathMatchConditionParameters_Operator{
	"any":                UrlPathMatchConditionParameters_Operator_Any,
	"beginswith":         UrlPathMatchConditionParameters_Operator_BeginsWith,
	"contains":           UrlPathMatchConditionParameters_Operator_Contains,
	"endswith":           UrlPathMatchConditionParameters_Operator_EndsWith,
	"equal":              UrlPathMatchConditionParameters_Operator_Equal,
	"greaterthan":        UrlPathMatchConditionParameters_Operator_GreaterThan,
	"greaterthanorequal": UrlPathMatchConditionParameters_Operator_GreaterThanOrEqual,
	"lessthan":           UrlPathMatchConditionParameters_Operator_LessThan,
	"lessthanorequal":    UrlPathMatchConditionParameters_Operator_LessThanOrEqual,
	"regex":              UrlPathMatchConditionParameters_Operator_RegEx,
	"wildcard":           UrlPathMatchConditionParameters_Operator_Wildcard,
}

type UrlPathMatchConditionParameters_Operator_STATUS string

const (
	UrlPathMatchConditionParameters_Operator_STATUS_Any                = UrlPathMatchConditionParameters_Operator_STATUS("Any")
	UrlPathMatchConditionParameters_Operator_STATUS_BeginsWith         = UrlPathMatchConditionParameters_Operator_STATUS("BeginsWith")
	UrlPathMatchConditionParameters_Operator_STATUS_Contains           = UrlPathMatchConditionParameters_Operator_STATUS("Contains")
	UrlPathMatchConditionParameters_Operator_STATUS_EndsWith           = UrlPathMatchConditionParameters_Operator_STATUS("EndsWith")
	UrlPathMatchConditionParameters_Operator_STATUS_Equal              = UrlPathMatchConditionParameters_Operator_STATUS("Equal")
	UrlPathMatchConditionParameters_Operator_STATUS_GreaterThan        = UrlPathMatchConditionParameters_Operator_STATUS("GreaterThan")
	UrlPathMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual = UrlPathMatchConditionParameters_Operator_STATUS("GreaterThanOrEqual")
	UrlPathMatchConditionParameters_Operator_STATUS_LessThan           = UrlPathMatchConditionParameters_Operator_STATUS("LessThan")
	UrlPathMatchConditionParameters_Operator_STATUS_LessThanOrEqual    = UrlPathMatchConditionParameters_Operator_STATUS("LessThanOrEqual")
	UrlPathMatchConditionParameters_Operator_STATUS_RegEx              = UrlPathMatchConditionParameters_Operator_STATUS("RegEx")
	UrlPathMatchConditionParameters_Operator_STATUS_Wildcard           = UrlPathMatchConditionParameters_Operator_STATUS("Wildcard")
)

// Mapping from string to UrlPathMatchConditionParameters_Operator_STATUS
var urlPathMatchConditionParameters_Operator_STATUS_Values = map[string]UrlPathMatchConditionParameters_Operator_STATUS{
	"any":                UrlPathMatchConditionParameters_Operator_STATUS_Any,
	"beginswith":         UrlPathMatchConditionParameters_Operator_STATUS_BeginsWith,
	"contains":           UrlPathMatchConditionParameters_Operator_STATUS_Contains,
	"endswith":           UrlPathMatchConditionParameters_Operator_STATUS_EndsWith,
	"equal":              UrlPathMatchConditionParameters_Operator_STATUS_Equal,
	"greaterthan":        UrlPathMatchConditionParameters_Operator_STATUS_GreaterThan,
	"greaterthanorequal": UrlPathMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual,
	"lessthan":           UrlPathMatchConditionParameters_Operator_STATUS_LessThan,
	"lessthanorequal":    UrlPathMatchConditionParameters_Operator_STATUS_LessThanOrEqual,
	"regex":              UrlPathMatchConditionParameters_Operator_STATUS_RegEx,
	"wildcard":           UrlPathMatchConditionParameters_Operator_STATUS_Wildcard,
}

// +kubebuilder:validation:Enum={"DeliveryRuleUrlPathMatchConditionParameters"}
type UrlPathMatchConditionParameters_TypeName string

const UrlPathMatchConditionParameters_TypeName_DeliveryRuleUrlPathMatchConditionParameters = UrlPathMatchConditionParameters_TypeName("DeliveryRuleUrlPathMatchConditionParameters")

// Mapping from string to UrlPathMatchConditionParameters_TypeName
var urlPathMatchConditionParameters_TypeName_Values = map[string]UrlPathMatchConditionParameters_TypeName{
	"deliveryruleurlpathmatchconditionparameters": UrlPathMatchConditionParameters_TypeName_DeliveryRuleUrlPathMatchConditionParameters,
}

type UrlPathMatchConditionParameters_TypeName_STATUS string

const UrlPathMatchConditionParameters_TypeName_STATUS_DeliveryRuleUrlPathMatchConditionParameters = UrlPathMatchConditionParameters_TypeName_STATUS("DeliveryRuleUrlPathMatchConditionParameters")

// Mapping from string to UrlPathMatchConditionParameters_TypeName_STATUS
var urlPathMatchConditionParameters_TypeName_STATUS_Values = map[string]UrlPathMatchConditionParameters_TypeName_STATUS{
	"deliveryruleurlpathmatchconditionparameters": UrlPathMatchConditionParameters_TypeName_STATUS_DeliveryRuleUrlPathMatchConditionParameters,
}

// +kubebuilder:validation:Enum={"Http","Https","MatchRequest"}
type UrlRedirectActionParameters_DestinationProtocol string

const (
	UrlRedirectActionParameters_DestinationProtocol_Http         = UrlRedirectActionParameters_DestinationProtocol("Http")
	UrlRedirectActionParameters_DestinationProtocol_Https        = UrlRedirectActionParameters_DestinationProtocol("Https")
	UrlRedirectActionParameters_DestinationProtocol_MatchRequest = UrlRedirectActionParameters_DestinationProtocol("MatchRequest")
)

// Mapping from string to UrlRedirectActionParameters_DestinationProtocol
var urlRedirectActionParameters_DestinationProtocol_Values = map[string]UrlRedirectActionParameters_DestinationProtocol{
	"http":         UrlRedirectActionParameters_DestinationProtocol_Http,
	"https":        UrlRedirectActionParameters_DestinationProtocol_Https,
	"matchrequest": UrlRedirectActionParameters_DestinationProtocol_MatchRequest,
}

type UrlRedirectActionParameters_DestinationProtocol_STATUS string

const (
	UrlRedirectActionParameters_DestinationProtocol_STATUS_Http         = UrlRedirectActionParameters_DestinationProtocol_STATUS("Http")
	UrlRedirectActionParameters_DestinationProtocol_STATUS_Https        = UrlRedirectActionParameters_DestinationProtocol_STATUS("Https")
	UrlRedirectActionParameters_DestinationProtocol_STATUS_MatchRequest = UrlRedirectActionParameters_DestinationProtocol_STATUS("MatchRequest")
)

// Mapping from string to UrlRedirectActionParameters_DestinationProtocol_STATUS
var urlRedirectActionParameters_DestinationProtocol_STATUS_Values = map[string]UrlRedirectActionParameters_DestinationProtocol_STATUS{
	"http":         UrlRedirectActionParameters_DestinationProtocol_STATUS_Http,
	"https":        UrlRedirectActionParameters_DestinationProtocol_STATUS_Https,
	"matchrequest": UrlRedirectActionParameters_DestinationProtocol_STATUS_MatchRequest,
}

// +kubebuilder:validation:Enum={"Found","Moved","PermanentRedirect","TemporaryRedirect"}
type UrlRedirectActionParameters_RedirectType string

const (
	UrlRedirectActionParameters_RedirectType_Found             = UrlRedirectActionParameters_RedirectType("Found")
	UrlRedirectActionParameters_RedirectType_Moved             = UrlRedirectActionParameters_RedirectType("Moved")
	UrlRedirectActionParameters_RedirectType_PermanentRedirect = UrlRedirectActionParameters_RedirectType("PermanentRedirect")
	UrlRedirectActionParameters_RedirectType_TemporaryRedirect = UrlRedirectActionParameters_RedirectType("TemporaryRedirect")
)

// Mapping from string to UrlRedirectActionParameters_RedirectType
var urlRedirectActionParameters_RedirectType_Values = map[string]UrlRedirectActionParameters_RedirectType{
	"found":             UrlRedirectActionParameters_RedirectType_Found,
	"moved":             UrlRedirectActionParameters_RedirectType_Moved,
	"permanentredirect": UrlRedirectActionParameters_RedirectType_PermanentRedirect,
	"temporaryredirect": UrlRedirectActionParameters_RedirectType_TemporaryRedirect,
}

type UrlRedirectActionParameters_RedirectType_STATUS string

const (
	UrlRedirectActionParameters_RedirectType_STATUS_Found             = UrlRedirectActionParameters_RedirectType_STATUS("Found")
	UrlRedirectActionParameters_RedirectType_STATUS_Moved             = UrlRedirectActionParameters_RedirectType_STATUS("Moved")
	UrlRedirectActionParameters_RedirectType_STATUS_PermanentRedirect = UrlRedirectActionParameters_RedirectType_STATUS("PermanentRedirect")
	UrlRedirectActionParameters_RedirectType_STATUS_TemporaryRedirect = UrlRedirectActionParameters_RedirectType_STATUS("TemporaryRedirect")
)

// Mapping from string to UrlRedirectActionParameters_RedirectType_STATUS
var urlRedirectActionParameters_RedirectType_STATUS_Values = map[string]UrlRedirectActionParameters_RedirectType_STATUS{
	"found":             UrlRedirectActionParameters_RedirectType_STATUS_Found,
	"moved":             UrlRedirectActionParameters_RedirectType_STATUS_Moved,
	"permanentredirect": UrlRedirectActionParameters_RedirectType_STATUS_PermanentRedirect,
	"temporaryredirect": UrlRedirectActionParameters_RedirectType_STATUS_TemporaryRedirect,
}

// +kubebuilder:validation:Enum={"DeliveryRuleUrlRedirectActionParameters"}
type UrlRedirectActionParameters_TypeName string

const UrlRedirectActionParameters_TypeName_DeliveryRuleUrlRedirectActionParameters = UrlRedirectActionParameters_TypeName("DeliveryRuleUrlRedirectActionParameters")

// Mapping from string to UrlRedirectActionParameters_TypeName
var urlRedirectActionParameters_TypeName_Values = map[string]UrlRedirectActionParameters_TypeName{
	"deliveryruleurlredirectactionparameters": UrlRedirectActionParameters_TypeName_DeliveryRuleUrlRedirectActionParameters,
}

type UrlRedirectActionParameters_TypeName_STATUS string

const UrlRedirectActionParameters_TypeName_STATUS_DeliveryRuleUrlRedirectActionParameters = UrlRedirectActionParameters_TypeName_STATUS("DeliveryRuleUrlRedirectActionParameters")

// Mapping from string to UrlRedirectActionParameters_TypeName_STATUS
var urlRedirectActionParameters_TypeName_STATUS_Values = map[string]UrlRedirectActionParameters_TypeName_STATUS{
	"deliveryruleurlredirectactionparameters": UrlRedirectActionParameters_TypeName_STATUS_DeliveryRuleUrlRedirectActionParameters,
}

// +kubebuilder:validation:Enum={"DeliveryRuleUrlRewriteActionParameters"}
type UrlRewriteActionParameters_TypeName string

const UrlRewriteActionParameters_TypeName_DeliveryRuleUrlRewriteActionParameters = UrlRewriteActionParameters_TypeName("DeliveryRuleUrlRewriteActionParameters")

// Mapping from string to UrlRewriteActionParameters_TypeName
var urlRewriteActionParameters_TypeName_Values = map[string]UrlRewriteActionParameters_TypeName{
	"deliveryruleurlrewriteactionparameters": UrlRewriteActionParameters_TypeName_DeliveryRuleUrlRewriteActionParameters,
}

type UrlRewriteActionParameters_TypeName_STATUS string

const UrlRewriteActionParameters_TypeName_STATUS_DeliveryRuleUrlRewriteActionParameters = UrlRewriteActionParameters_TypeName_STATUS("DeliveryRuleUrlRewriteActionParameters")

// Mapping from string to UrlRewriteActionParameters_TypeName_STATUS
var urlRewriteActionParameters_TypeName_STATUS_Values = map[string]UrlRewriteActionParameters_TypeName_STATUS{
	"deliveryruleurlrewriteactionparameters": UrlRewriteActionParameters_TypeName_STATUS_DeliveryRuleUrlRewriteActionParameters,
}

// +kubebuilder:validation:Enum={"SHA256"}
type UrlSigningActionParameters_Algorithm string

const UrlSigningActionParameters_Algorithm_SHA256 = UrlSigningActionParameters_Algorithm("SHA256")

// Mapping from string to UrlSigningActionParameters_Algorithm
var urlSigningActionParameters_Algorithm_Values = map[string]UrlSigningActionParameters_Algorithm{
	"sha256": UrlSigningActionParameters_Algorithm_SHA256,
}

type UrlSigningActionParameters_Algorithm_STATUS string

const UrlSigningActionParameters_Algorithm_STATUS_SHA256 = UrlSigningActionParameters_Algorithm_STATUS("SHA256")

// Mapping from string to UrlSigningActionParameters_Algorithm_STATUS
var urlSigningActionParameters_Algorithm_STATUS_Values = map[string]UrlSigningActionParameters_Algorithm_STATUS{
	"sha256": UrlSigningActionParameters_Algorithm_STATUS_SHA256,
}

// +kubebuilder:validation:Enum={"DeliveryRuleUrlSigningActionParameters"}
type UrlSigningActionParameters_TypeName string

const UrlSigningActionParameters_TypeName_DeliveryRuleUrlSigningActionParameters = UrlSigningActionParameters_TypeName("DeliveryRuleUrlSigningActionParameters")

// Mapping from string to UrlSigningActionParameters_TypeName
var urlSigningActionParameters_TypeName_Values = map[string]UrlSigningActionParameters_TypeName{
	"deliveryruleurlsigningactionparameters": UrlSigningActionParameters_TypeName_DeliveryRuleUrlSigningActionParameters,
}

type UrlSigningActionParameters_TypeName_STATUS string

const UrlSigningActionParameters_TypeName_STATUS_DeliveryRuleUrlSigningActionParameters = UrlSigningActionParameters_TypeName_STATUS("DeliveryRuleUrlSigningActionParameters")

// Mapping from string to UrlSigningActionParameters_TypeName_STATUS
var urlSigningActionParameters_TypeName_STATUS_Values = map[string]UrlSigningActionParameters_TypeName_STATUS{
	"deliveryruleurlsigningactionparameters": UrlSigningActionParameters_TypeName_STATUS_DeliveryRuleUrlSigningActionParameters,
}

// Defines how to identify a parameter for a specific purpose e.g. expires
type UrlSigningParamIdentifier struct {
	// +kubebuilder:validation:Required
	// ParamIndicator: Indicates the purpose of the parameter
	ParamIndicator *UrlSigningParamIdentifier_ParamIndicator `json:"paramIndicator,omitempty"`

	// +kubebuilder:validation:Required
	// ParamName: Parameter name
	ParamName *string `json:"paramName,omitempty"`
}

var _ genruntime.ARMTransformer = &UrlSigningParamIdentifier{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identifier *UrlSigningParamIdentifier) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identifier == nil {
		return nil, nil
	}
	result := &arm.UrlSigningParamIdentifier{}

	// Set property "ParamIndicator":
	if identifier.ParamIndicator != nil {
		var temp string
		temp = string(*identifier.ParamIndicator)
		paramIndicator := arm.UrlSigningParamIdentifier_ParamIndicator(temp)
		result.ParamIndicator = &paramIndicator
	}

	// Set property "ParamName":
	if identifier.ParamName != nil {
		paramName := *identifier.ParamName
		result.ParamName = &paramName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identifier *UrlSigningParamIdentifier) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UrlSigningParamIdentifier{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identifier *UrlSigningParamIdentifier) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UrlSigningParamIdentifier)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UrlSigningParamIdentifier, got %T", armInput)
	}

	// Set property "ParamIndicator":
	if typedInput.ParamIndicator != nil {
		var temp string
		temp = string(*typedInput.ParamIndicator)
		paramIndicator := UrlSigningParamIdentifier_ParamIndicator(temp)
		identifier.ParamIndicator = &paramIndicator
	}

	// Set property "ParamName":
	if typedInput.ParamName != nil {
		paramName := *typedInput.ParamName
		identifier.ParamName = &paramName
	}

	// No error
	return nil
}

// AssignProperties_From_UrlSigningParamIdentifier populates our UrlSigningParamIdentifier from the provided source UrlSigningParamIdentifier
func (identifier *UrlSigningParamIdentifier) AssignProperties_From_UrlSigningParamIdentifier(source *storage.UrlSigningParamIdentifier) error {

	// ParamIndicator
	if source.ParamIndicator != nil {
		paramIndicator := *source.ParamIndicator
		paramIndicatorTemp := genruntime.ToEnum(paramIndicator, urlSigningParamIdentifier_ParamIndicator_Values)
		identifier.ParamIndicator = &paramIndicatorTemp
	} else {
		identifier.ParamIndicator = nil
	}

	// ParamName
	identifier.ParamName = genruntime.ClonePointerToString(source.ParamName)

	// No error
	return nil
}

// AssignProperties_To_UrlSigningParamIdentifier populates the provided destination UrlSigningParamIdentifier from our UrlSigningParamIdentifier
func (identifier *UrlSigningParamIdentifier) AssignProperties_To_UrlSigningParamIdentifier(destination *storage.UrlSigningParamIdentifier) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ParamIndicator
	if identifier.ParamIndicator != nil {
		paramIndicator := string(*identifier.ParamIndicator)
		destination.ParamIndicator = &paramIndicator
	} else {
		destination.ParamIndicator = nil
	}

	// ParamName
	destination.ParamName = genruntime.ClonePointerToString(identifier.ParamName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_UrlSigningParamIdentifier_STATUS populates our UrlSigningParamIdentifier from the provided source UrlSigningParamIdentifier_STATUS
func (identifier *UrlSigningParamIdentifier) Initialize_From_UrlSigningParamIdentifier_STATUS(source *UrlSigningParamIdentifier_STATUS) error {

	// ParamIndicator
	if source.ParamIndicator != nil {
		paramIndicator := genruntime.ToEnum(string(*source.ParamIndicator), urlSigningParamIdentifier_ParamIndicator_Values)
		identifier.ParamIndicator = &paramIndicator
	} else {
		identifier.ParamIndicator = nil
	}

	// ParamName
	identifier.ParamName = genruntime.ClonePointerToString(source.ParamName)

	// No error
	return nil
}

// Defines how to identify a parameter for a specific purpose e.g. expires
type UrlSigningParamIdentifier_STATUS struct {
	// ParamIndicator: Indicates the purpose of the parameter
	ParamIndicator *UrlSigningParamIdentifier_ParamIndicator_STATUS `json:"paramIndicator,omitempty"`

	// ParamName: Parameter name
	ParamName *string `json:"paramName,omitempty"`
}

var _ genruntime.FromARMConverter = &UrlSigningParamIdentifier_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identifier *UrlSigningParamIdentifier_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UrlSigningParamIdentifier_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identifier *UrlSigningParamIdentifier_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UrlSigningParamIdentifier_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UrlSigningParamIdentifier_STATUS, got %T", armInput)
	}

	// Set property "ParamIndicator":
	if typedInput.ParamIndicator != nil {
		var temp string
		temp = string(*typedInput.ParamIndicator)
		paramIndicator := UrlSigningParamIdentifier_ParamIndicator_STATUS(temp)
		identifier.ParamIndicator = &paramIndicator
	}

	// Set property "ParamName":
	if typedInput.ParamName != nil {
		paramName := *typedInput.ParamName
		identifier.ParamName = &paramName
	}

	// No error
	return nil
}

// AssignProperties_From_UrlSigningParamIdentifier_STATUS populates our UrlSigningParamIdentifier_STATUS from the provided source UrlSigningParamIdentifier_STATUS
func (identifier *UrlSigningParamIdentifier_STATUS) AssignProperties_From_UrlSigningParamIdentifier_STATUS(source *storage.UrlSigningParamIdentifier_STATUS) error {

	// ParamIndicator
	if source.ParamIndicator != nil {
		paramIndicator := *source.ParamIndicator
		paramIndicatorTemp := genruntime.ToEnum(paramIndicator, urlSigningParamIdentifier_ParamIndicator_STATUS_Values)
		identifier.ParamIndicator = &paramIndicatorTemp
	} else {
		identifier.ParamIndicator = nil
	}

	// ParamName
	identifier.ParamName = genruntime.ClonePointerToString(source.ParamName)

	// No error
	return nil
}

// AssignProperties_To_UrlSigningParamIdentifier_STATUS populates the provided destination UrlSigningParamIdentifier_STATUS from our UrlSigningParamIdentifier_STATUS
func (identifier *UrlSigningParamIdentifier_STATUS) AssignProperties_To_UrlSigningParamIdentifier_STATUS(destination *storage.UrlSigningParamIdentifier_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ParamIndicator
	if identifier.ParamIndicator != nil {
		paramIndicator := string(*identifier.ParamIndicator)
		destination.ParamIndicator = &paramIndicator
	} else {
		destination.ParamIndicator = nil
	}

	// ParamName
	destination.ParamName = genruntime.ClonePointerToString(identifier.ParamName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"HonorOrigin","OverrideAlways","OverrideIfOriginMissing"}
type CacheConfiguration_CacheBehavior string

const (
	CacheConfiguration_CacheBehavior_HonorOrigin             = CacheConfiguration_CacheBehavior("HonorOrigin")
	CacheConfiguration_CacheBehavior_OverrideAlways          = CacheConfiguration_CacheBehavior("OverrideAlways")
	CacheConfiguration_CacheBehavior_OverrideIfOriginMissing = CacheConfiguration_CacheBehavior("OverrideIfOriginMissing")
)

// Mapping from string to CacheConfiguration_CacheBehavior
var cacheConfiguration_CacheBehavior_Values = map[string]CacheConfiguration_CacheBehavior{
	"honororigin":             CacheConfiguration_CacheBehavior_HonorOrigin,
	"overridealways":          CacheConfiguration_CacheBehavior_OverrideAlways,
	"overrideiforiginmissing": CacheConfiguration_CacheBehavior_OverrideIfOriginMissing,
}

type CacheConfiguration_CacheBehavior_STATUS string

const (
	CacheConfiguration_CacheBehavior_STATUS_HonorOrigin             = CacheConfiguration_CacheBehavior_STATUS("HonorOrigin")
	CacheConfiguration_CacheBehavior_STATUS_OverrideAlways          = CacheConfiguration_CacheBehavior_STATUS("OverrideAlways")
	CacheConfiguration_CacheBehavior_STATUS_OverrideIfOriginMissing = CacheConfiguration_CacheBehavior_STATUS("OverrideIfOriginMissing")
)

// Mapping from string to CacheConfiguration_CacheBehavior_STATUS
var cacheConfiguration_CacheBehavior_STATUS_Values = map[string]CacheConfiguration_CacheBehavior_STATUS{
	"honororigin":             CacheConfiguration_CacheBehavior_STATUS_HonorOrigin,
	"overridealways":          CacheConfiguration_CacheBehavior_STATUS_OverrideAlways,
	"overrideiforiginmissing": CacheConfiguration_CacheBehavior_STATUS_OverrideIfOriginMissing,
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type CacheConfiguration_IsCompressionEnabled string

const (
	CacheConfiguration_IsCompressionEnabled_Disabled = CacheConfiguration_IsCompressionEnabled("Disabled")
	CacheConfiguration_IsCompressionEnabled_Enabled  = CacheConfiguration_IsCompressionEnabled("Enabled")
)

// Mapping from string to CacheConfiguration_IsCompressionEnabled
var cacheConfiguration_IsCompressionEnabled_Values = map[string]CacheConfiguration_IsCompressionEnabled{
	"disabled": CacheConfiguration_IsCompressionEnabled_Disabled,
	"enabled":  CacheConfiguration_IsCompressionEnabled_Enabled,
}

type CacheConfiguration_IsCompressionEnabled_STATUS string

const (
	CacheConfiguration_IsCompressionEnabled_STATUS_Disabled = CacheConfiguration_IsCompressionEnabled_STATUS("Disabled")
	CacheConfiguration_IsCompressionEnabled_STATUS_Enabled  = CacheConfiguration_IsCompressionEnabled_STATUS("Enabled")
)

// Mapping from string to CacheConfiguration_IsCompressionEnabled_STATUS
var cacheConfiguration_IsCompressionEnabled_STATUS_Values = map[string]CacheConfiguration_IsCompressionEnabled_STATUS{
	"disabled": CacheConfiguration_IsCompressionEnabled_STATUS_Disabled,
	"enabled":  CacheConfiguration_IsCompressionEnabled_STATUS_Enabled,
}

// +kubebuilder:validation:Enum={"IgnoreQueryString","IgnoreSpecifiedQueryStrings","IncludeSpecifiedQueryStrings","UseQueryString"}
type CacheConfiguration_QueryStringCachingBehavior string

const (
	CacheConfiguration_QueryStringCachingBehavior_IgnoreQueryString            = CacheConfiguration_QueryStringCachingBehavior("IgnoreQueryString")
	CacheConfiguration_QueryStringCachingBehavior_IgnoreSpecifiedQueryStrings  = CacheConfiguration_QueryStringCachingBehavior("IgnoreSpecifiedQueryStrings")
	CacheConfiguration_QueryStringCachingBehavior_IncludeSpecifiedQueryStrings = CacheConfiguration_QueryStringCachingBehavior("IncludeSpecifiedQueryStrings")
	CacheConfiguration_QueryStringCachingBehavior_UseQueryString               = CacheConfiguration_QueryStringCachingBehavior("UseQueryString")
)

// Mapping from string to CacheConfiguration_QueryStringCachingBehavior
var cacheConfiguration_QueryStringCachingBehavior_Values = map[string]CacheConfiguration_QueryStringCachingBehavior{
	"ignorequerystring":            CacheConfiguration_QueryStringCachingBehavior_IgnoreQueryString,
	"ignorespecifiedquerystrings":  CacheConfiguration_QueryStringCachingBehavior_IgnoreSpecifiedQueryStrings,
	"includespecifiedquerystrings": CacheConfiguration_QueryStringCachingBehavior_IncludeSpecifiedQueryStrings,
	"usequerystring":               CacheConfiguration_QueryStringCachingBehavior_UseQueryString,
}

type CacheConfiguration_QueryStringCachingBehavior_STATUS string

const (
	CacheConfiguration_QueryStringCachingBehavior_STATUS_IgnoreQueryString            = CacheConfiguration_QueryStringCachingBehavior_STATUS("IgnoreQueryString")
	CacheConfiguration_QueryStringCachingBehavior_STATUS_IgnoreSpecifiedQueryStrings  = CacheConfiguration_QueryStringCachingBehavior_STATUS("IgnoreSpecifiedQueryStrings")
	CacheConfiguration_QueryStringCachingBehavior_STATUS_IncludeSpecifiedQueryStrings = CacheConfiguration_QueryStringCachingBehavior_STATUS("IncludeSpecifiedQueryStrings")
	CacheConfiguration_QueryStringCachingBehavior_STATUS_UseQueryString               = CacheConfiguration_QueryStringCachingBehavior_STATUS("UseQueryString")
)

// Mapping from string to CacheConfiguration_QueryStringCachingBehavior_STATUS
var cacheConfiguration_QueryStringCachingBehavior_STATUS_Values = map[string]CacheConfiguration_QueryStringCachingBehavior_STATUS{
	"ignorequerystring":            CacheConfiguration_QueryStringCachingBehavior_STATUS_IgnoreQueryString,
	"ignorespecifiedquerystrings":  CacheConfiguration_QueryStringCachingBehavior_STATUS_IgnoreSpecifiedQueryStrings,
	"includespecifiedquerystrings": CacheConfiguration_QueryStringCachingBehavior_STATUS_IncludeSpecifiedQueryStrings,
	"usequerystring":               CacheConfiguration_QueryStringCachingBehavior_STATUS_UseQueryString,
}

// +kubebuilder:validation:Enum={"HttpOnly","HttpsOnly","MatchRequest"}
type OriginGroupOverride_ForwardingProtocol string

const (
	OriginGroupOverride_ForwardingProtocol_HttpOnly     = OriginGroupOverride_ForwardingProtocol("HttpOnly")
	OriginGroupOverride_ForwardingProtocol_HttpsOnly    = OriginGroupOverride_ForwardingProtocol("HttpsOnly")
	OriginGroupOverride_ForwardingProtocol_MatchRequest = OriginGroupOverride_ForwardingProtocol("MatchRequest")
)

// Mapping from string to OriginGroupOverride_ForwardingProtocol
var originGroupOverride_ForwardingProtocol_Values = map[string]OriginGroupOverride_ForwardingProtocol{
	"httponly":     OriginGroupOverride_ForwardingProtocol_HttpOnly,
	"httpsonly":    OriginGroupOverride_ForwardingProtocol_HttpsOnly,
	"matchrequest": OriginGroupOverride_ForwardingProtocol_MatchRequest,
}

type OriginGroupOverride_ForwardingProtocol_STATUS string

const (
	OriginGroupOverride_ForwardingProtocol_STATUS_HttpOnly     = OriginGroupOverride_ForwardingProtocol_STATUS("HttpOnly")
	OriginGroupOverride_ForwardingProtocol_STATUS_HttpsOnly    = OriginGroupOverride_ForwardingProtocol_STATUS("HttpsOnly")
	OriginGroupOverride_ForwardingProtocol_STATUS_MatchRequest = OriginGroupOverride_ForwardingProtocol_STATUS("MatchRequest")
)

// Mapping from string to OriginGroupOverride_ForwardingProtocol_STATUS
var originGroupOverride_ForwardingProtocol_STATUS_Values = map[string]OriginGroupOverride_ForwardingProtocol_STATUS{
	"httponly":     OriginGroupOverride_ForwardingProtocol_STATUS_HttpOnly,
	"httpsonly":    OriginGroupOverride_ForwardingProtocol_STATUS_HttpsOnly,
	"matchrequest": OriginGroupOverride_ForwardingProtocol_STATUS_MatchRequest,
}

// +kubebuilder:validation:Enum={"Expires","KeyId","Signature"}
type UrlSigningParamIdentifier_ParamIndicator string

const (
	UrlSigningParamIdentifier_ParamIndicator_Expires   = UrlSigningParamIdentifier_ParamIndicator("Expires")
	UrlSigningParamIdentifier_ParamIndicator_KeyId     = UrlSigningParamIdentifier_ParamIndicator("KeyId")
	UrlSigningParamIdentifier_ParamIndicator_Signature = UrlSigningParamIdentifier_ParamIndicator("Signature")
)

// Mapping from string to UrlSigningParamIdentifier_ParamIndicator
var urlSigningParamIdentifier_ParamIndicator_Values = map[string]UrlSigningParamIdentifier_ParamIndicator{
	"expires":   UrlSigningParamIdentifier_ParamIndicator_Expires,
	"keyid":     UrlSigningParamIdentifier_ParamIndicator_KeyId,
	"signature": UrlSigningParamIdentifier_ParamIndicator_Signature,
}

type UrlSigningParamIdentifier_ParamIndicator_STATUS string

const (
	UrlSigningParamIdentifier_ParamIndicator_STATUS_Expires   = UrlSigningParamIdentifier_ParamIndicator_STATUS("Expires")
	UrlSigningParamIdentifier_ParamIndicator_STATUS_KeyId     = UrlSigningParamIdentifier_ParamIndicator_STATUS("KeyId")
	UrlSigningParamIdentifier_ParamIndicator_STATUS_Signature = UrlSigningParamIdentifier_ParamIndicator_STATUS("Signature")
)

// Mapping from string to UrlSigningParamIdentifier_ParamIndicator_STATUS
var urlSigningParamIdentifier_ParamIndicator_STATUS_Values = map[string]UrlSigningParamIdentifier_ParamIndicator_STATUS{
	"expires":   UrlSigningParamIdentifier_ParamIndicator_STATUS_Expires,
	"keyid":     UrlSigningParamIdentifier_ParamIndicator_STATUS_KeyId,
	"signature": UrlSigningParamIdentifier_ParamIndicator_STATUS_Signature,
}

func init() {
	SchemeBuilder.Register(&ProfilesEndpoint{}, &ProfilesEndpointList{})
}
