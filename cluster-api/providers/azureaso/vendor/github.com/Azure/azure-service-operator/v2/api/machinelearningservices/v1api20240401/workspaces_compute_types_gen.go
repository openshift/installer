// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20240401

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/machinelearningservices/v1api20240401/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/machinelearningservices/v1api20240401/storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/pkg/errors"
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /machinelearningservices/resource-manager/Microsoft.MachineLearningServices/stable/2024-04-01/machineLearningServices.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/computes/{computeName}
type WorkspacesCompute struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              WorkspacesCompute_Spec   `json:"spec,omitempty"`
	Status            WorkspacesCompute_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &WorkspacesCompute{}

// GetConditions returns the conditions of the resource
func (compute *WorkspacesCompute) GetConditions() conditions.Conditions {
	return compute.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (compute *WorkspacesCompute) SetConditions(conditions conditions.Conditions) {
	compute.Status.Conditions = conditions
}

var _ conversion.Convertible = &WorkspacesCompute{}

// ConvertFrom populates our WorkspacesCompute from the provided hub WorkspacesCompute
func (compute *WorkspacesCompute) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.WorkspacesCompute)
	if !ok {
		return fmt.Errorf("expected machinelearningservices/v1api20240401/storage/WorkspacesCompute but received %T instead", hub)
	}

	return compute.AssignProperties_From_WorkspacesCompute(source)
}

// ConvertTo populates the provided hub WorkspacesCompute from our WorkspacesCompute
func (compute *WorkspacesCompute) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.WorkspacesCompute)
	if !ok {
		return fmt.Errorf("expected machinelearningservices/v1api20240401/storage/WorkspacesCompute but received %T instead", hub)
	}

	return compute.AssignProperties_To_WorkspacesCompute(destination)
}

// +kubebuilder:webhook:path=/mutate-machinelearningservices-azure-com-v1api20240401-workspacescompute,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=machinelearningservices.azure.com,resources=workspacescomputes,verbs=create;update,versions=v1api20240401,name=default.v1api20240401.workspacescomputes.machinelearningservices.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &WorkspacesCompute{}

// Default applies defaults to the WorkspacesCompute resource
func (compute *WorkspacesCompute) Default() {
	compute.defaultImpl()
	var temp any = compute
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (compute *WorkspacesCompute) defaultAzureName() {
	if compute.Spec.AzureName == "" {
		compute.Spec.AzureName = compute.Name
	}
}

// defaultImpl applies the code generated defaults to the WorkspacesCompute resource
func (compute *WorkspacesCompute) defaultImpl() { compute.defaultAzureName() }

var _ configmaps.Exporter = &WorkspacesCompute{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (compute *WorkspacesCompute) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if compute.Spec.OperatorSpec == nil {
		return nil
	}
	return compute.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &WorkspacesCompute{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (compute *WorkspacesCompute) SecretDestinationExpressions() []*core.DestinationExpression {
	if compute.Spec.OperatorSpec == nil {
		return nil
	}
	return compute.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &WorkspacesCompute{}

// InitializeSpec initializes the spec for this resource from the given status
func (compute *WorkspacesCompute) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*WorkspacesCompute_STATUS); ok {
		return compute.Spec.Initialize_From_WorkspacesCompute_STATUS(s)
	}

	return fmt.Errorf("expected Status of type WorkspacesCompute_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &WorkspacesCompute{}

// AzureName returns the Azure name of the resource
func (compute *WorkspacesCompute) AzureName() string {
	return compute.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2024-04-01"
func (compute WorkspacesCompute) GetAPIVersion() string {
	return "2024-04-01"
}

// GetResourceScope returns the scope of the resource
func (compute *WorkspacesCompute) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (compute *WorkspacesCompute) GetSpec() genruntime.ConvertibleSpec {
	return &compute.Spec
}

// GetStatus returns the status of this resource
func (compute *WorkspacesCompute) GetStatus() genruntime.ConvertibleStatus {
	return &compute.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (compute *WorkspacesCompute) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.MachineLearningServices/workspaces/computes"
func (compute *WorkspacesCompute) GetType() string {
	return "Microsoft.MachineLearningServices/workspaces/computes"
}

// NewEmptyStatus returns a new empty (blank) status
func (compute *WorkspacesCompute) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &WorkspacesCompute_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (compute *WorkspacesCompute) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(compute.Spec)
	return compute.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (compute *WorkspacesCompute) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*WorkspacesCompute_STATUS); ok {
		compute.Status = *st
		return nil
	}

	// Convert status to required version
	var st WorkspacesCompute_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	compute.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-machinelearningservices-azure-com-v1api20240401-workspacescompute,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=machinelearningservices.azure.com,resources=workspacescomputes,verbs=create;update,versions=v1api20240401,name=validate.v1api20240401.workspacescomputes.machinelearningservices.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &WorkspacesCompute{}

// ValidateCreate validates the creation of the resource
func (compute *WorkspacesCompute) ValidateCreate() (admission.Warnings, error) {
	validations := compute.createValidations()
	var temp any = compute
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	return genruntime.ValidateCreate(validations)
}

// ValidateDelete validates the deletion of the resource
func (compute *WorkspacesCompute) ValidateDelete() (admission.Warnings, error) {
	validations := compute.deleteValidations()
	var temp any = compute
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	return genruntime.ValidateDelete(validations)
}

// ValidateUpdate validates an update of the resource
func (compute *WorkspacesCompute) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	validations := compute.updateValidations()
	var temp any = compute
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	return genruntime.ValidateUpdate(old, validations)
}

// createValidations validates the creation of the resource
func (compute *WorkspacesCompute) createValidations() []func() (admission.Warnings, error) {
	return []func() (admission.Warnings, error){compute.validateResourceReferences, compute.validateOwnerReference, compute.validateSecretDestinations, compute.validateConfigMapDestinations, compute.validateOptionalConfigMapReferences}
}

// deleteValidations validates the deletion of the resource
func (compute *WorkspacesCompute) deleteValidations() []func() (admission.Warnings, error) {
	return nil
}

// updateValidations validates the update of the resource
func (compute *WorkspacesCompute) updateValidations() []func(old runtime.Object) (admission.Warnings, error) {
	return []func(old runtime.Object) (admission.Warnings, error){
		func(old runtime.Object) (admission.Warnings, error) {
			return compute.validateResourceReferences()
		},
		compute.validateWriteOnceProperties,
		func(old runtime.Object) (admission.Warnings, error) {
			return compute.validateOwnerReference()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return compute.validateSecretDestinations()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return compute.validateConfigMapDestinations()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return compute.validateOptionalConfigMapReferences()
		},
	}
}

// validateConfigMapDestinations validates there are no colliding genruntime.ConfigMapDestinations
func (compute *WorkspacesCompute) validateConfigMapDestinations() (admission.Warnings, error) {
	if compute.Spec.OperatorSpec == nil {
		return nil, nil
	}
	return configmaps.ValidateDestinations(compute, nil, compute.Spec.OperatorSpec.ConfigMapExpressions)
}

// validateOptionalConfigMapReferences validates all optional configmap reference pairs to ensure that at most 1 is set
func (compute *WorkspacesCompute) validateOptionalConfigMapReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindOptionalConfigMapReferences(&compute.Spec)
	if err != nil {
		return nil, err
	}
	return configmaps.ValidateOptionalReferences(refs)
}

// validateOwnerReference validates the owner field
func (compute *WorkspacesCompute) validateOwnerReference() (admission.Warnings, error) {
	return genruntime.ValidateOwner(compute)
}

// validateResourceReferences validates all resource references
func (compute *WorkspacesCompute) validateResourceReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindResourceReferences(&compute.Spec)
	if err != nil {
		return nil, err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateSecretDestinations validates there are no colliding genruntime.SecretDestination's
func (compute *WorkspacesCompute) validateSecretDestinations() (admission.Warnings, error) {
	if compute.Spec.OperatorSpec == nil {
		return nil, nil
	}
	return secrets.ValidateDestinations(compute, nil, compute.Spec.OperatorSpec.SecretExpressions)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (compute *WorkspacesCompute) validateWriteOnceProperties(old runtime.Object) (admission.Warnings, error) {
	oldObj, ok := old.(*WorkspacesCompute)
	if !ok {
		return nil, nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, compute)
}

// AssignProperties_From_WorkspacesCompute populates our WorkspacesCompute from the provided source WorkspacesCompute
func (compute *WorkspacesCompute) AssignProperties_From_WorkspacesCompute(source *storage.WorkspacesCompute) error {

	// ObjectMeta
	compute.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec WorkspacesCompute_Spec
	err := spec.AssignProperties_From_WorkspacesCompute_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_WorkspacesCompute_Spec() to populate field Spec")
	}
	compute.Spec = spec

	// Status
	var status WorkspacesCompute_STATUS
	err = status.AssignProperties_From_WorkspacesCompute_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_WorkspacesCompute_STATUS() to populate field Status")
	}
	compute.Status = status

	// No error
	return nil
}

// AssignProperties_To_WorkspacesCompute populates the provided destination WorkspacesCompute from our WorkspacesCompute
func (compute *WorkspacesCompute) AssignProperties_To_WorkspacesCompute(destination *storage.WorkspacesCompute) error {

	// ObjectMeta
	destination.ObjectMeta = *compute.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.WorkspacesCompute_Spec
	err := compute.Spec.AssignProperties_To_WorkspacesCompute_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_WorkspacesCompute_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.WorkspacesCompute_STATUS
	err = compute.Status.AssignProperties_To_WorkspacesCompute_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_WorkspacesCompute_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (compute *WorkspacesCompute) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: compute.Spec.OriginalVersion(),
		Kind:    "WorkspacesCompute",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /machinelearningservices/resource-manager/Microsoft.MachineLearningServices/stable/2024-04-01/machineLearningServices.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/computes/{computeName}
type WorkspacesComputeList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []WorkspacesCompute `json:"items"`
}

type WorkspacesCompute_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// Identity: The identity of the resource.
	Identity *ManagedServiceIdentity `json:"identity,omitempty"`

	// Location: Specifies the location of the resource.
	Location *string `json:"location,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *WorkspacesComputeOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a machinelearningservices.azure.com/Workspace resource
	Owner *genruntime.KnownResourceReference `group:"machinelearningservices.azure.com" json:"owner,omitempty" kind:"Workspace"`

	// Properties: Compute properties
	Properties *Compute `json:"properties,omitempty"`

	// Sku: The sku of the workspace.
	Sku *Sku `json:"sku,omitempty"`

	// Tags: Contains resource tags defined as key/value pairs.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &WorkspacesCompute_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (compute *WorkspacesCompute_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if compute == nil {
		return nil, nil
	}
	result := &arm.WorkspacesCompute_Spec{}

	// Set property "Identity":
	if compute.Identity != nil {
		identity_ARM, err := (*compute.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*arm.ManagedServiceIdentity)
		result.Identity = &identity
	}

	// Set property "Location":
	if compute.Location != nil {
		location := *compute.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if compute.Properties != nil {
		properties_ARM, err := (*compute.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*arm.Compute)
		result.Properties = &properties
	}

	// Set property "Sku":
	if compute.Sku != nil {
		sku_ARM, err := (*compute.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := *sku_ARM.(*arm.Sku)
		result.Sku = &sku
	}

	// Set property "Tags":
	if compute.Tags != nil {
		result.Tags = make(map[string]string, len(compute.Tags))
		for key, value := range compute.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (compute *WorkspacesCompute_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspacesCompute_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (compute *WorkspacesCompute_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspacesCompute_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspacesCompute_Spec, got %T", armInput)
	}

	// Set property "AzureName":
	compute.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedServiceIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		compute.Identity = &identity
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		compute.Location = &location
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	compute.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 Compute
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		compute.Properties = &properties
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 Sku
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		compute.Sku = &sku
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		compute.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			compute.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &WorkspacesCompute_Spec{}

// ConvertSpecFrom populates our WorkspacesCompute_Spec from the provided source
func (compute *WorkspacesCompute_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.WorkspacesCompute_Spec)
	if ok {
		// Populate our instance from source
		return compute.AssignProperties_From_WorkspacesCompute_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.WorkspacesCompute_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = compute.AssignProperties_From_WorkspacesCompute_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our WorkspacesCompute_Spec
func (compute *WorkspacesCompute_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.WorkspacesCompute_Spec)
	if ok {
		// Populate destination from our instance
		return compute.AssignProperties_To_WorkspacesCompute_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.WorkspacesCompute_Spec{}
	err := compute.AssignProperties_To_WorkspacesCompute_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_WorkspacesCompute_Spec populates our WorkspacesCompute_Spec from the provided source WorkspacesCompute_Spec
func (compute *WorkspacesCompute_Spec) AssignProperties_From_WorkspacesCompute_Spec(source *storage.WorkspacesCompute_Spec) error {

	// AzureName
	compute.AzureName = source.AzureName

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity
		err := identity.AssignProperties_From_ManagedServiceIdentity(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity() to populate field Identity")
		}
		compute.Identity = &identity
	} else {
		compute.Identity = nil
	}

	// Location
	compute.Location = genruntime.ClonePointerToString(source.Location)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec WorkspacesComputeOperatorSpec
		err := operatorSpec.AssignProperties_From_WorkspacesComputeOperatorSpec(source.OperatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WorkspacesComputeOperatorSpec() to populate field OperatorSpec")
		}
		compute.OperatorSpec = &operatorSpec
	} else {
		compute.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		compute.Owner = &owner
	} else {
		compute.Owner = nil
	}

	// Properties
	if source.Properties != nil {
		var property Compute
		err := property.AssignProperties_From_Compute(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Compute() to populate field Properties")
		}
		compute.Properties = &property
	} else {
		compute.Properties = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.AssignProperties_From_Sku(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Sku() to populate field Sku")
		}
		compute.Sku = &sku
	} else {
		compute.Sku = nil
	}

	// Tags
	compute.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// AssignProperties_To_WorkspacesCompute_Spec populates the provided destination WorkspacesCompute_Spec from our WorkspacesCompute_Spec
func (compute *WorkspacesCompute_Spec) AssignProperties_To_WorkspacesCompute_Spec(destination *storage.WorkspacesCompute_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = compute.AzureName

	// Identity
	if compute.Identity != nil {
		var identity storage.ManagedServiceIdentity
		err := compute.Identity.AssignProperties_To_ManagedServiceIdentity(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(compute.Location)

	// OperatorSpec
	if compute.OperatorSpec != nil {
		var operatorSpec storage.WorkspacesComputeOperatorSpec
		err := compute.OperatorSpec.AssignProperties_To_WorkspacesComputeOperatorSpec(&operatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WorkspacesComputeOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = compute.OriginalVersion()

	// Owner
	if compute.Owner != nil {
		owner := compute.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Properties
	if compute.Properties != nil {
		var property storage.Compute
		err := compute.Properties.AssignProperties_To_Compute(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Compute() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// Sku
	if compute.Sku != nil {
		var sku storage.Sku
		err := compute.Sku.AssignProperties_To_Sku(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Sku() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(compute.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_WorkspacesCompute_STATUS populates our WorkspacesCompute_Spec from the provided source WorkspacesCompute_STATUS
func (compute *WorkspacesCompute_Spec) Initialize_From_WorkspacesCompute_STATUS(source *WorkspacesCompute_STATUS) error {

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity
		err := identity.Initialize_From_ManagedServiceIdentity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		compute.Identity = &identity
	} else {
		compute.Identity = nil
	}

	// Location
	compute.Location = genruntime.ClonePointerToString(source.Location)

	// Properties
	if source.Properties != nil {
		var property Compute
		err := property.Initialize_From_Compute_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_Compute_STATUS() to populate field Properties")
		}
		compute.Properties = &property
	} else {
		compute.Properties = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.Initialize_From_Sku_STATUS(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_Sku_STATUS() to populate field Sku")
		}
		compute.Sku = &sku
	} else {
		compute.Sku = nil
	}

	// Tags
	compute.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (compute *WorkspacesCompute_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (compute *WorkspacesCompute_Spec) SetAzureName(azureName string) { compute.AzureName = azureName }

type WorkspacesCompute_STATUS struct {
	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// Id: Fully qualified resource ID for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`

	// Identity: The identity of the resource.
	Identity *ManagedServiceIdentity_STATUS `json:"identity,omitempty"`

	// Location: Specifies the location of the resource.
	Location *string `json:"location,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// Properties: Compute properties
	Properties *Compute_STATUS `json:"properties,omitempty"`

	// Sku: The sku of the workspace.
	Sku *Sku_STATUS `json:"sku,omitempty"`

	// SystemData: Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData_STATUS `json:"systemData,omitempty"`

	// Tags: Contains resource tags defined as key/value pairs.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &WorkspacesCompute_STATUS{}

// ConvertStatusFrom populates our WorkspacesCompute_STATUS from the provided source
func (compute *WorkspacesCompute_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.WorkspacesCompute_STATUS)
	if ok {
		// Populate our instance from source
		return compute.AssignProperties_From_WorkspacesCompute_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.WorkspacesCompute_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = compute.AssignProperties_From_WorkspacesCompute_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our WorkspacesCompute_STATUS
func (compute *WorkspacesCompute_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.WorkspacesCompute_STATUS)
	if ok {
		// Populate destination from our instance
		return compute.AssignProperties_To_WorkspacesCompute_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.WorkspacesCompute_STATUS{}
	err := compute.AssignProperties_To_WorkspacesCompute_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &WorkspacesCompute_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (compute *WorkspacesCompute_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspacesCompute_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (compute *WorkspacesCompute_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspacesCompute_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspacesCompute_STATUS, got %T", armInput)
	}

	// no assignment for property "Conditions"

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		compute.Id = &id
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedServiceIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		compute.Identity = &identity
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		compute.Location = &location
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		compute.Name = &name
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 Compute_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		compute.Properties = &properties
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 Sku_STATUS
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		compute.Sku = &sku
	}

	// Set property "SystemData":
	if typedInput.SystemData != nil {
		var systemData1 SystemData_STATUS
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		compute.SystemData = &systemData
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		compute.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			compute.Tags[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		compute.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_WorkspacesCompute_STATUS populates our WorkspacesCompute_STATUS from the provided source WorkspacesCompute_STATUS
func (compute *WorkspacesCompute_STATUS) AssignProperties_From_WorkspacesCompute_STATUS(source *storage.WorkspacesCompute_STATUS) error {

	// Conditions
	compute.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// Id
	compute.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity_STATUS
		err := identity.AssignProperties_From_ManagedServiceIdentity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		compute.Identity = &identity
	} else {
		compute.Identity = nil
	}

	// Location
	compute.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	compute.Name = genruntime.ClonePointerToString(source.Name)

	// Properties
	if source.Properties != nil {
		var property Compute_STATUS
		err := property.AssignProperties_From_Compute_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Compute_STATUS() to populate field Properties")
		}
		compute.Properties = &property
	} else {
		compute.Properties = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku_STATUS
		err := sku.AssignProperties_From_Sku_STATUS(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Sku_STATUS() to populate field Sku")
		}
		compute.Sku = &sku
	} else {
		compute.Sku = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		compute.SystemData = &systemDatum
	} else {
		compute.SystemData = nil
	}

	// Tags
	compute.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	compute.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_WorkspacesCompute_STATUS populates the provided destination WorkspacesCompute_STATUS from our WorkspacesCompute_STATUS
func (compute *WorkspacesCompute_STATUS) AssignProperties_To_WorkspacesCompute_STATUS(destination *storage.WorkspacesCompute_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(compute.Conditions)

	// Id
	destination.Id = genruntime.ClonePointerToString(compute.Id)

	// Identity
	if compute.Identity != nil {
		var identity storage.ManagedServiceIdentity_STATUS
		err := compute.Identity.AssignProperties_To_ManagedServiceIdentity_STATUS(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(compute.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(compute.Name)

	// Properties
	if compute.Properties != nil {
		var property storage.Compute_STATUS
		err := compute.Properties.AssignProperties_To_Compute_STATUS(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Compute_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// Sku
	if compute.Sku != nil {
		var sku storage.Sku_STATUS
		err := compute.Sku.AssignProperties_To_Sku_STATUS(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Sku_STATUS() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// SystemData
	if compute.SystemData != nil {
		var systemDatum storage.SystemData_STATUS
		err := compute.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(compute.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(compute.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Compute struct {
	// AKS: Mutually exclusive with all other properties
	AKS *AKS `json:"aks,omitempty"`

	// AmlCompute: Mutually exclusive with all other properties
	AmlCompute *AmlCompute `json:"amlCompute,omitempty"`

	// ComputeInstance: Mutually exclusive with all other properties
	ComputeInstance *ComputeInstance `json:"computeInstance,omitempty"`

	// DataFactory: Mutually exclusive with all other properties
	DataFactory *DataFactory `json:"dataFactory,omitempty"`

	// DataLakeAnalytics: Mutually exclusive with all other properties
	DataLakeAnalytics *DataLakeAnalytics `json:"dataLakeAnalytics,omitempty"`

	// Databricks: Mutually exclusive with all other properties
	Databricks *Databricks `json:"databricks,omitempty"`

	// HDInsight: Mutually exclusive with all other properties
	HDInsight *HDInsight `json:"hdInsight,omitempty"`

	// Kubernetes: Mutually exclusive with all other properties
	Kubernetes *Kubernetes `json:"kubernetes,omitempty"`

	// SynapseSpark: Mutually exclusive with all other properties
	SynapseSpark *SynapseSpark `json:"synapseSpark,omitempty"`

	// VirtualMachine: Mutually exclusive with all other properties
	VirtualMachine *VirtualMachine `json:"virtualMachine,omitempty"`
}

var _ genruntime.ARMTransformer = &Compute{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (compute *Compute) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if compute == nil {
		return nil, nil
	}
	result := &arm.Compute{}

	// Set property "AKS":
	if compute.AKS != nil {
		aks_ARM, err := (*compute.AKS).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		aks := *aks_ARM.(*arm.AKS)
		result.AKS = &aks
	}

	// Set property "AmlCompute":
	if compute.AmlCompute != nil {
		amlCompute_ARM, err := (*compute.AmlCompute).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		amlCompute := *amlCompute_ARM.(*arm.AmlCompute)
		result.AmlCompute = &amlCompute
	}

	// Set property "ComputeInstance":
	if compute.ComputeInstance != nil {
		computeInstance_ARM, err := (*compute.ComputeInstance).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		computeInstance := *computeInstance_ARM.(*arm.ComputeInstance)
		result.ComputeInstance = &computeInstance
	}

	// Set property "DataFactory":
	if compute.DataFactory != nil {
		dataFactory_ARM, err := (*compute.DataFactory).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dataFactory := *dataFactory_ARM.(*arm.DataFactory)
		result.DataFactory = &dataFactory
	}

	// Set property "DataLakeAnalytics":
	if compute.DataLakeAnalytics != nil {
		dataLakeAnalytics_ARM, err := (*compute.DataLakeAnalytics).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dataLakeAnalytics := *dataLakeAnalytics_ARM.(*arm.DataLakeAnalytics)
		result.DataLakeAnalytics = &dataLakeAnalytics
	}

	// Set property "Databricks":
	if compute.Databricks != nil {
		databricks_ARM, err := (*compute.Databricks).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		databricks := *databricks_ARM.(*arm.Databricks)
		result.Databricks = &databricks
	}

	// Set property "HDInsight":
	if compute.HDInsight != nil {
		hdInsight_ARM, err := (*compute.HDInsight).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		hdInsight := *hdInsight_ARM.(*arm.HDInsight)
		result.HDInsight = &hdInsight
	}

	// Set property "Kubernetes":
	if compute.Kubernetes != nil {
		kubernetes_ARM, err := (*compute.Kubernetes).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		kubernetes := *kubernetes_ARM.(*arm.Kubernetes)
		result.Kubernetes = &kubernetes
	}

	// Set property "SynapseSpark":
	if compute.SynapseSpark != nil {
		synapseSpark_ARM, err := (*compute.SynapseSpark).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		synapseSpark := *synapseSpark_ARM.(*arm.SynapseSpark)
		result.SynapseSpark = &synapseSpark
	}

	// Set property "VirtualMachine":
	if compute.VirtualMachine != nil {
		virtualMachine_ARM, err := (*compute.VirtualMachine).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		virtualMachine := *virtualMachine_ARM.(*arm.VirtualMachine)
		result.VirtualMachine = &virtualMachine
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (compute *Compute) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Compute{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (compute *Compute) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Compute)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Compute, got %T", armInput)
	}

	// Set property "AKS":
	if typedInput.AKS != nil {
		var aks1 AKS
		err := aks1.PopulateFromARM(owner, *typedInput.AKS)
		if err != nil {
			return err
		}
		aks := aks1
		compute.AKS = &aks
	}

	// Set property "AmlCompute":
	if typedInput.AmlCompute != nil {
		var amlCompute1 AmlCompute
		err := amlCompute1.PopulateFromARM(owner, *typedInput.AmlCompute)
		if err != nil {
			return err
		}
		amlCompute := amlCompute1
		compute.AmlCompute = &amlCompute
	}

	// Set property "ComputeInstance":
	if typedInput.ComputeInstance != nil {
		var computeInstance1 ComputeInstance
		err := computeInstance1.PopulateFromARM(owner, *typedInput.ComputeInstance)
		if err != nil {
			return err
		}
		computeInstance := computeInstance1
		compute.ComputeInstance = &computeInstance
	}

	// Set property "DataFactory":
	if typedInput.DataFactory != nil {
		var dataFactory1 DataFactory
		err := dataFactory1.PopulateFromARM(owner, *typedInput.DataFactory)
		if err != nil {
			return err
		}
		dataFactory := dataFactory1
		compute.DataFactory = &dataFactory
	}

	// Set property "DataLakeAnalytics":
	if typedInput.DataLakeAnalytics != nil {
		var dataLakeAnalytics1 DataLakeAnalytics
		err := dataLakeAnalytics1.PopulateFromARM(owner, *typedInput.DataLakeAnalytics)
		if err != nil {
			return err
		}
		dataLakeAnalytics := dataLakeAnalytics1
		compute.DataLakeAnalytics = &dataLakeAnalytics
	}

	// Set property "Databricks":
	if typedInput.Databricks != nil {
		var databricks1 Databricks
		err := databricks1.PopulateFromARM(owner, *typedInput.Databricks)
		if err != nil {
			return err
		}
		databricks := databricks1
		compute.Databricks = &databricks
	}

	// Set property "HDInsight":
	if typedInput.HDInsight != nil {
		var hdInsight1 HDInsight
		err := hdInsight1.PopulateFromARM(owner, *typedInput.HDInsight)
		if err != nil {
			return err
		}
		hdInsight := hdInsight1
		compute.HDInsight = &hdInsight
	}

	// Set property "Kubernetes":
	if typedInput.Kubernetes != nil {
		var kubernetes1 Kubernetes
		err := kubernetes1.PopulateFromARM(owner, *typedInput.Kubernetes)
		if err != nil {
			return err
		}
		kubernetes := kubernetes1
		compute.Kubernetes = &kubernetes
	}

	// Set property "SynapseSpark":
	if typedInput.SynapseSpark != nil {
		var synapseSpark1 SynapseSpark
		err := synapseSpark1.PopulateFromARM(owner, *typedInput.SynapseSpark)
		if err != nil {
			return err
		}
		synapseSpark := synapseSpark1
		compute.SynapseSpark = &synapseSpark
	}

	// Set property "VirtualMachine":
	if typedInput.VirtualMachine != nil {
		var virtualMachine1 VirtualMachine
		err := virtualMachine1.PopulateFromARM(owner, *typedInput.VirtualMachine)
		if err != nil {
			return err
		}
		virtualMachine := virtualMachine1
		compute.VirtualMachine = &virtualMachine
	}

	// No error
	return nil
}

// AssignProperties_From_Compute populates our Compute from the provided source Compute
func (compute *Compute) AssignProperties_From_Compute(source *storage.Compute) error {

	// AKS
	if source.AKS != nil {
		var aks AKS
		err := aks.AssignProperties_From_AKS(source.AKS)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AKS() to populate field AKS")
		}
		compute.AKS = &aks
	} else {
		compute.AKS = nil
	}

	// AmlCompute
	if source.AmlCompute != nil {
		var amlCompute AmlCompute
		err := amlCompute.AssignProperties_From_AmlCompute(source.AmlCompute)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AmlCompute() to populate field AmlCompute")
		}
		compute.AmlCompute = &amlCompute
	} else {
		compute.AmlCompute = nil
	}

	// ComputeInstance
	if source.ComputeInstance != nil {
		var computeInstance ComputeInstance
		err := computeInstance.AssignProperties_From_ComputeInstance(source.ComputeInstance)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ComputeInstance() to populate field ComputeInstance")
		}
		compute.ComputeInstance = &computeInstance
	} else {
		compute.ComputeInstance = nil
	}

	// DataFactory
	if source.DataFactory != nil {
		var dataFactory DataFactory
		err := dataFactory.AssignProperties_From_DataFactory(source.DataFactory)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DataFactory() to populate field DataFactory")
		}
		compute.DataFactory = &dataFactory
	} else {
		compute.DataFactory = nil
	}

	// DataLakeAnalytics
	if source.DataLakeAnalytics != nil {
		var dataLakeAnalytic DataLakeAnalytics
		err := dataLakeAnalytic.AssignProperties_From_DataLakeAnalytics(source.DataLakeAnalytics)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DataLakeAnalytics() to populate field DataLakeAnalytics")
		}
		compute.DataLakeAnalytics = &dataLakeAnalytic
	} else {
		compute.DataLakeAnalytics = nil
	}

	// Databricks
	if source.Databricks != nil {
		var databrick Databricks
		err := databrick.AssignProperties_From_Databricks(source.Databricks)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Databricks() to populate field Databricks")
		}
		compute.Databricks = &databrick
	} else {
		compute.Databricks = nil
	}

	// HDInsight
	if source.HDInsight != nil {
		var hdInsight HDInsight
		err := hdInsight.AssignProperties_From_HDInsight(source.HDInsight)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HDInsight() to populate field HDInsight")
		}
		compute.HDInsight = &hdInsight
	} else {
		compute.HDInsight = nil
	}

	// Kubernetes
	if source.Kubernetes != nil {
		var kubernete Kubernetes
		err := kubernete.AssignProperties_From_Kubernetes(source.Kubernetes)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Kubernetes() to populate field Kubernetes")
		}
		compute.Kubernetes = &kubernete
	} else {
		compute.Kubernetes = nil
	}

	// SynapseSpark
	if source.SynapseSpark != nil {
		var synapseSpark SynapseSpark
		err := synapseSpark.AssignProperties_From_SynapseSpark(source.SynapseSpark)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SynapseSpark() to populate field SynapseSpark")
		}
		compute.SynapseSpark = &synapseSpark
	} else {
		compute.SynapseSpark = nil
	}

	// VirtualMachine
	if source.VirtualMachine != nil {
		var virtualMachine VirtualMachine
		err := virtualMachine.AssignProperties_From_VirtualMachine(source.VirtualMachine)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachine() to populate field VirtualMachine")
		}
		compute.VirtualMachine = &virtualMachine
	} else {
		compute.VirtualMachine = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Compute populates the provided destination Compute from our Compute
func (compute *Compute) AssignProperties_To_Compute(destination *storage.Compute) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AKS
	if compute.AKS != nil {
		var aks storage.AKS
		err := compute.AKS.AssignProperties_To_AKS(&aks)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AKS() to populate field AKS")
		}
		destination.AKS = &aks
	} else {
		destination.AKS = nil
	}

	// AmlCompute
	if compute.AmlCompute != nil {
		var amlCompute storage.AmlCompute
		err := compute.AmlCompute.AssignProperties_To_AmlCompute(&amlCompute)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AmlCompute() to populate field AmlCompute")
		}
		destination.AmlCompute = &amlCompute
	} else {
		destination.AmlCompute = nil
	}

	// ComputeInstance
	if compute.ComputeInstance != nil {
		var computeInstance storage.ComputeInstance
		err := compute.ComputeInstance.AssignProperties_To_ComputeInstance(&computeInstance)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ComputeInstance() to populate field ComputeInstance")
		}
		destination.ComputeInstance = &computeInstance
	} else {
		destination.ComputeInstance = nil
	}

	// DataFactory
	if compute.DataFactory != nil {
		var dataFactory storage.DataFactory
		err := compute.DataFactory.AssignProperties_To_DataFactory(&dataFactory)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DataFactory() to populate field DataFactory")
		}
		destination.DataFactory = &dataFactory
	} else {
		destination.DataFactory = nil
	}

	// DataLakeAnalytics
	if compute.DataLakeAnalytics != nil {
		var dataLakeAnalytic storage.DataLakeAnalytics
		err := compute.DataLakeAnalytics.AssignProperties_To_DataLakeAnalytics(&dataLakeAnalytic)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DataLakeAnalytics() to populate field DataLakeAnalytics")
		}
		destination.DataLakeAnalytics = &dataLakeAnalytic
	} else {
		destination.DataLakeAnalytics = nil
	}

	// Databricks
	if compute.Databricks != nil {
		var databrick storage.Databricks
		err := compute.Databricks.AssignProperties_To_Databricks(&databrick)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Databricks() to populate field Databricks")
		}
		destination.Databricks = &databrick
	} else {
		destination.Databricks = nil
	}

	// HDInsight
	if compute.HDInsight != nil {
		var hdInsight storage.HDInsight
		err := compute.HDInsight.AssignProperties_To_HDInsight(&hdInsight)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HDInsight() to populate field HDInsight")
		}
		destination.HDInsight = &hdInsight
	} else {
		destination.HDInsight = nil
	}

	// Kubernetes
	if compute.Kubernetes != nil {
		var kubernete storage.Kubernetes
		err := compute.Kubernetes.AssignProperties_To_Kubernetes(&kubernete)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Kubernetes() to populate field Kubernetes")
		}
		destination.Kubernetes = &kubernete
	} else {
		destination.Kubernetes = nil
	}

	// SynapseSpark
	if compute.SynapseSpark != nil {
		var synapseSpark storage.SynapseSpark
		err := compute.SynapseSpark.AssignProperties_To_SynapseSpark(&synapseSpark)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SynapseSpark() to populate field SynapseSpark")
		}
		destination.SynapseSpark = &synapseSpark
	} else {
		destination.SynapseSpark = nil
	}

	// VirtualMachine
	if compute.VirtualMachine != nil {
		var virtualMachine storage.VirtualMachine
		err := compute.VirtualMachine.AssignProperties_To_VirtualMachine(&virtualMachine)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachine() to populate field VirtualMachine")
		}
		destination.VirtualMachine = &virtualMachine
	} else {
		destination.VirtualMachine = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Compute_STATUS populates our Compute from the provided source Compute_STATUS
func (compute *Compute) Initialize_From_Compute_STATUS(source *Compute_STATUS) error {

	// AKS
	if source.AKS != nil {
		var aks AKS
		err := aks.Initialize_From_AKS_STATUS(source.AKS)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_AKS_STATUS() to populate field AKS")
		}
		compute.AKS = &aks
	} else {
		compute.AKS = nil
	}

	// AmlCompute
	if source.AmlCompute != nil {
		var amlCompute AmlCompute
		err := amlCompute.Initialize_From_AmlCompute_STATUS(source.AmlCompute)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_AmlCompute_STATUS() to populate field AmlCompute")
		}
		compute.AmlCompute = &amlCompute
	} else {
		compute.AmlCompute = nil
	}

	// ComputeInstance
	if source.ComputeInstance != nil {
		var computeInstance ComputeInstance
		err := computeInstance.Initialize_From_ComputeInstance_STATUS(source.ComputeInstance)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ComputeInstance_STATUS() to populate field ComputeInstance")
		}
		compute.ComputeInstance = &computeInstance
	} else {
		compute.ComputeInstance = nil
	}

	// DataFactory
	if source.DataFactory != nil {
		var dataFactory DataFactory
		err := dataFactory.Initialize_From_DataFactory_STATUS(source.DataFactory)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DataFactory_STATUS() to populate field DataFactory")
		}
		compute.DataFactory = &dataFactory
	} else {
		compute.DataFactory = nil
	}

	// DataLakeAnalytics
	if source.DataLakeAnalytics != nil {
		var dataLakeAnalytic DataLakeAnalytics
		err := dataLakeAnalytic.Initialize_From_DataLakeAnalytics_STATUS(source.DataLakeAnalytics)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DataLakeAnalytics_STATUS() to populate field DataLakeAnalytics")
		}
		compute.DataLakeAnalytics = &dataLakeAnalytic
	} else {
		compute.DataLakeAnalytics = nil
	}

	// Databricks
	if source.Databricks != nil {
		var databrick Databricks
		err := databrick.Initialize_From_Databricks_STATUS(source.Databricks)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_Databricks_STATUS() to populate field Databricks")
		}
		compute.Databricks = &databrick
	} else {
		compute.Databricks = nil
	}

	// HDInsight
	if source.HDInsight != nil {
		var hdInsight HDInsight
		err := hdInsight.Initialize_From_HDInsight_STATUS(source.HDInsight)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_HDInsight_STATUS() to populate field HDInsight")
		}
		compute.HDInsight = &hdInsight
	} else {
		compute.HDInsight = nil
	}

	// Kubernetes
	if source.Kubernetes != nil {
		var kubernete Kubernetes
		err := kubernete.Initialize_From_Kubernetes_STATUS(source.Kubernetes)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_Kubernetes_STATUS() to populate field Kubernetes")
		}
		compute.Kubernetes = &kubernete
	} else {
		compute.Kubernetes = nil
	}

	// SynapseSpark
	if source.SynapseSpark != nil {
		var synapseSpark SynapseSpark
		err := synapseSpark.Initialize_From_SynapseSpark_STATUS(source.SynapseSpark)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SynapseSpark_STATUS() to populate field SynapseSpark")
		}
		compute.SynapseSpark = &synapseSpark
	} else {
		compute.SynapseSpark = nil
	}

	// VirtualMachine
	if source.VirtualMachine != nil {
		var virtualMachine VirtualMachine
		err := virtualMachine.Initialize_From_VirtualMachine_STATUS(source.VirtualMachine)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_VirtualMachine_STATUS() to populate field VirtualMachine")
		}
		compute.VirtualMachine = &virtualMachine
	} else {
		compute.VirtualMachine = nil
	}

	// No error
	return nil
}

type Compute_STATUS struct {
	// AKS: Mutually exclusive with all other properties
	AKS *AKS_STATUS `json:"aks,omitempty"`

	// AmlCompute: Mutually exclusive with all other properties
	AmlCompute *AmlCompute_STATUS `json:"amlCompute,omitempty"`

	// ComputeInstance: Mutually exclusive with all other properties
	ComputeInstance *ComputeInstance_STATUS `json:"computeInstance,omitempty"`

	// DataFactory: Mutually exclusive with all other properties
	DataFactory *DataFactory_STATUS `json:"dataFactory,omitempty"`

	// DataLakeAnalytics: Mutually exclusive with all other properties
	DataLakeAnalytics *DataLakeAnalytics_STATUS `json:"dataLakeAnalytics,omitempty"`

	// Databricks: Mutually exclusive with all other properties
	Databricks *Databricks_STATUS `json:"databricks,omitempty"`

	// HDInsight: Mutually exclusive with all other properties
	HDInsight *HDInsight_STATUS `json:"hdInsight,omitempty"`

	// Kubernetes: Mutually exclusive with all other properties
	Kubernetes *Kubernetes_STATUS `json:"kubernetes,omitempty"`

	// SynapseSpark: Mutually exclusive with all other properties
	SynapseSpark *SynapseSpark_STATUS `json:"synapseSpark,omitempty"`

	// VirtualMachine: Mutually exclusive with all other properties
	VirtualMachine *VirtualMachine_STATUS `json:"virtualMachine,omitempty"`
}

var _ genruntime.FromARMConverter = &Compute_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (compute *Compute_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Compute_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (compute *Compute_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Compute_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Compute_STATUS, got %T", armInput)
	}

	// Set property "AKS":
	if typedInput.AKS != nil {
		var aks1 AKS_STATUS
		err := aks1.PopulateFromARM(owner, *typedInput.AKS)
		if err != nil {
			return err
		}
		aks := aks1
		compute.AKS = &aks
	}

	// Set property "AmlCompute":
	if typedInput.AmlCompute != nil {
		var amlCompute1 AmlCompute_STATUS
		err := amlCompute1.PopulateFromARM(owner, *typedInput.AmlCompute)
		if err != nil {
			return err
		}
		amlCompute := amlCompute1
		compute.AmlCompute = &amlCompute
	}

	// Set property "ComputeInstance":
	if typedInput.ComputeInstance != nil {
		var computeInstance1 ComputeInstance_STATUS
		err := computeInstance1.PopulateFromARM(owner, *typedInput.ComputeInstance)
		if err != nil {
			return err
		}
		computeInstance := computeInstance1
		compute.ComputeInstance = &computeInstance
	}

	// Set property "DataFactory":
	if typedInput.DataFactory != nil {
		var dataFactory1 DataFactory_STATUS
		err := dataFactory1.PopulateFromARM(owner, *typedInput.DataFactory)
		if err != nil {
			return err
		}
		dataFactory := dataFactory1
		compute.DataFactory = &dataFactory
	}

	// Set property "DataLakeAnalytics":
	if typedInput.DataLakeAnalytics != nil {
		var dataLakeAnalytics1 DataLakeAnalytics_STATUS
		err := dataLakeAnalytics1.PopulateFromARM(owner, *typedInput.DataLakeAnalytics)
		if err != nil {
			return err
		}
		dataLakeAnalytics := dataLakeAnalytics1
		compute.DataLakeAnalytics = &dataLakeAnalytics
	}

	// Set property "Databricks":
	if typedInput.Databricks != nil {
		var databricks1 Databricks_STATUS
		err := databricks1.PopulateFromARM(owner, *typedInput.Databricks)
		if err != nil {
			return err
		}
		databricks := databricks1
		compute.Databricks = &databricks
	}

	// Set property "HDInsight":
	if typedInput.HDInsight != nil {
		var hdInsight1 HDInsight_STATUS
		err := hdInsight1.PopulateFromARM(owner, *typedInput.HDInsight)
		if err != nil {
			return err
		}
		hdInsight := hdInsight1
		compute.HDInsight = &hdInsight
	}

	// Set property "Kubernetes":
	if typedInput.Kubernetes != nil {
		var kubernetes1 Kubernetes_STATUS
		err := kubernetes1.PopulateFromARM(owner, *typedInput.Kubernetes)
		if err != nil {
			return err
		}
		kubernetes := kubernetes1
		compute.Kubernetes = &kubernetes
	}

	// Set property "SynapseSpark":
	if typedInput.SynapseSpark != nil {
		var synapseSpark1 SynapseSpark_STATUS
		err := synapseSpark1.PopulateFromARM(owner, *typedInput.SynapseSpark)
		if err != nil {
			return err
		}
		synapseSpark := synapseSpark1
		compute.SynapseSpark = &synapseSpark
	}

	// Set property "VirtualMachine":
	if typedInput.VirtualMachine != nil {
		var virtualMachine1 VirtualMachine_STATUS
		err := virtualMachine1.PopulateFromARM(owner, *typedInput.VirtualMachine)
		if err != nil {
			return err
		}
		virtualMachine := virtualMachine1
		compute.VirtualMachine = &virtualMachine
	}

	// No error
	return nil
}

// AssignProperties_From_Compute_STATUS populates our Compute_STATUS from the provided source Compute_STATUS
func (compute *Compute_STATUS) AssignProperties_From_Compute_STATUS(source *storage.Compute_STATUS) error {

	// AKS
	if source.AKS != nil {
		var aks AKS_STATUS
		err := aks.AssignProperties_From_AKS_STATUS(source.AKS)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AKS_STATUS() to populate field AKS")
		}
		compute.AKS = &aks
	} else {
		compute.AKS = nil
	}

	// AmlCompute
	if source.AmlCompute != nil {
		var amlCompute AmlCompute_STATUS
		err := amlCompute.AssignProperties_From_AmlCompute_STATUS(source.AmlCompute)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AmlCompute_STATUS() to populate field AmlCompute")
		}
		compute.AmlCompute = &amlCompute
	} else {
		compute.AmlCompute = nil
	}

	// ComputeInstance
	if source.ComputeInstance != nil {
		var computeInstance ComputeInstance_STATUS
		err := computeInstance.AssignProperties_From_ComputeInstance_STATUS(source.ComputeInstance)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ComputeInstance_STATUS() to populate field ComputeInstance")
		}
		compute.ComputeInstance = &computeInstance
	} else {
		compute.ComputeInstance = nil
	}

	// DataFactory
	if source.DataFactory != nil {
		var dataFactory DataFactory_STATUS
		err := dataFactory.AssignProperties_From_DataFactory_STATUS(source.DataFactory)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DataFactory_STATUS() to populate field DataFactory")
		}
		compute.DataFactory = &dataFactory
	} else {
		compute.DataFactory = nil
	}

	// DataLakeAnalytics
	if source.DataLakeAnalytics != nil {
		var dataLakeAnalytic DataLakeAnalytics_STATUS
		err := dataLakeAnalytic.AssignProperties_From_DataLakeAnalytics_STATUS(source.DataLakeAnalytics)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DataLakeAnalytics_STATUS() to populate field DataLakeAnalytics")
		}
		compute.DataLakeAnalytics = &dataLakeAnalytic
	} else {
		compute.DataLakeAnalytics = nil
	}

	// Databricks
	if source.Databricks != nil {
		var databrick Databricks_STATUS
		err := databrick.AssignProperties_From_Databricks_STATUS(source.Databricks)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Databricks_STATUS() to populate field Databricks")
		}
		compute.Databricks = &databrick
	} else {
		compute.Databricks = nil
	}

	// HDInsight
	if source.HDInsight != nil {
		var hdInsight HDInsight_STATUS
		err := hdInsight.AssignProperties_From_HDInsight_STATUS(source.HDInsight)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HDInsight_STATUS() to populate field HDInsight")
		}
		compute.HDInsight = &hdInsight
	} else {
		compute.HDInsight = nil
	}

	// Kubernetes
	if source.Kubernetes != nil {
		var kubernete Kubernetes_STATUS
		err := kubernete.AssignProperties_From_Kubernetes_STATUS(source.Kubernetes)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Kubernetes_STATUS() to populate field Kubernetes")
		}
		compute.Kubernetes = &kubernete
	} else {
		compute.Kubernetes = nil
	}

	// SynapseSpark
	if source.SynapseSpark != nil {
		var synapseSpark SynapseSpark_STATUS
		err := synapseSpark.AssignProperties_From_SynapseSpark_STATUS(source.SynapseSpark)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SynapseSpark_STATUS() to populate field SynapseSpark")
		}
		compute.SynapseSpark = &synapseSpark
	} else {
		compute.SynapseSpark = nil
	}

	// VirtualMachine
	if source.VirtualMachine != nil {
		var virtualMachine VirtualMachine_STATUS
		err := virtualMachine.AssignProperties_From_VirtualMachine_STATUS(source.VirtualMachine)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachine_STATUS() to populate field VirtualMachine")
		}
		compute.VirtualMachine = &virtualMachine
	} else {
		compute.VirtualMachine = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Compute_STATUS populates the provided destination Compute_STATUS from our Compute_STATUS
func (compute *Compute_STATUS) AssignProperties_To_Compute_STATUS(destination *storage.Compute_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AKS
	if compute.AKS != nil {
		var aks storage.AKS_STATUS
		err := compute.AKS.AssignProperties_To_AKS_STATUS(&aks)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AKS_STATUS() to populate field AKS")
		}
		destination.AKS = &aks
	} else {
		destination.AKS = nil
	}

	// AmlCompute
	if compute.AmlCompute != nil {
		var amlCompute storage.AmlCompute_STATUS
		err := compute.AmlCompute.AssignProperties_To_AmlCompute_STATUS(&amlCompute)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AmlCompute_STATUS() to populate field AmlCompute")
		}
		destination.AmlCompute = &amlCompute
	} else {
		destination.AmlCompute = nil
	}

	// ComputeInstance
	if compute.ComputeInstance != nil {
		var computeInstance storage.ComputeInstance_STATUS
		err := compute.ComputeInstance.AssignProperties_To_ComputeInstance_STATUS(&computeInstance)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ComputeInstance_STATUS() to populate field ComputeInstance")
		}
		destination.ComputeInstance = &computeInstance
	} else {
		destination.ComputeInstance = nil
	}

	// DataFactory
	if compute.DataFactory != nil {
		var dataFactory storage.DataFactory_STATUS
		err := compute.DataFactory.AssignProperties_To_DataFactory_STATUS(&dataFactory)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DataFactory_STATUS() to populate field DataFactory")
		}
		destination.DataFactory = &dataFactory
	} else {
		destination.DataFactory = nil
	}

	// DataLakeAnalytics
	if compute.DataLakeAnalytics != nil {
		var dataLakeAnalytic storage.DataLakeAnalytics_STATUS
		err := compute.DataLakeAnalytics.AssignProperties_To_DataLakeAnalytics_STATUS(&dataLakeAnalytic)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DataLakeAnalytics_STATUS() to populate field DataLakeAnalytics")
		}
		destination.DataLakeAnalytics = &dataLakeAnalytic
	} else {
		destination.DataLakeAnalytics = nil
	}

	// Databricks
	if compute.Databricks != nil {
		var databrick storage.Databricks_STATUS
		err := compute.Databricks.AssignProperties_To_Databricks_STATUS(&databrick)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Databricks_STATUS() to populate field Databricks")
		}
		destination.Databricks = &databrick
	} else {
		destination.Databricks = nil
	}

	// HDInsight
	if compute.HDInsight != nil {
		var hdInsight storage.HDInsight_STATUS
		err := compute.HDInsight.AssignProperties_To_HDInsight_STATUS(&hdInsight)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HDInsight_STATUS() to populate field HDInsight")
		}
		destination.HDInsight = &hdInsight
	} else {
		destination.HDInsight = nil
	}

	// Kubernetes
	if compute.Kubernetes != nil {
		var kubernete storage.Kubernetes_STATUS
		err := compute.Kubernetes.AssignProperties_To_Kubernetes_STATUS(&kubernete)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Kubernetes_STATUS() to populate field Kubernetes")
		}
		destination.Kubernetes = &kubernete
	} else {
		destination.Kubernetes = nil
	}

	// SynapseSpark
	if compute.SynapseSpark != nil {
		var synapseSpark storage.SynapseSpark_STATUS
		err := compute.SynapseSpark.AssignProperties_To_SynapseSpark_STATUS(&synapseSpark)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SynapseSpark_STATUS() to populate field SynapseSpark")
		}
		destination.SynapseSpark = &synapseSpark
	} else {
		destination.SynapseSpark = nil
	}

	// VirtualMachine
	if compute.VirtualMachine != nil {
		var virtualMachine storage.VirtualMachine_STATUS
		err := compute.VirtualMachine.AssignProperties_To_VirtualMachine_STATUS(&virtualMachine)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachine_STATUS() to populate field VirtualMachine")
		}
		destination.VirtualMachine = &virtualMachine
	} else {
		destination.VirtualMachine = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type WorkspacesComputeOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_WorkspacesComputeOperatorSpec populates our WorkspacesComputeOperatorSpec from the provided source WorkspacesComputeOperatorSpec
func (operator *WorkspacesComputeOperatorSpec) AssignProperties_From_WorkspacesComputeOperatorSpec(source *storage.WorkspacesComputeOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WorkspacesComputeOperatorSpec populates the provided destination WorkspacesComputeOperatorSpec from our WorkspacesComputeOperatorSpec
func (operator *WorkspacesComputeOperatorSpec) AssignProperties_To_WorkspacesComputeOperatorSpec(destination *storage.WorkspacesComputeOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AKS struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// +kubebuilder:validation:Required
	// ComputeType: The type of compute
	ComputeType *AKS_ComputeType `json:"computeType,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// Properties: AKS properties
	Properties *AKS_Properties `json:"properties,omitempty"`

	// ResourceReference: ARM resource id of the underlying compute
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &AKS{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (aks *AKS) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if aks == nil {
		return nil, nil
	}
	result := &arm.AKS{}

	// Set property "ComputeLocation":
	if aks.ComputeLocation != nil {
		computeLocation := *aks.ComputeLocation
		result.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	if aks.ComputeType != nil {
		var temp arm.AKS_ComputeType
		var temp1 string
		temp1 = string(*aks.ComputeType)
		temp = arm.AKS_ComputeType(temp1)
		result.ComputeType = temp
	}

	// Set property "Description":
	if aks.Description != nil {
		description := *aks.Description
		result.Description = &description
	}

	// Set property "DisableLocalAuth":
	if aks.DisableLocalAuth != nil {
		disableLocalAuth := *aks.DisableLocalAuth
		result.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if aks.Properties != nil {
		properties_ARM, err := (*aks.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*arm.AKS_Properties)
		result.Properties = &properties
	}

	// Set property "ResourceId":
	if aks.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*aks.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (aks *AKS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AKS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (aks *AKS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AKS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AKS, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		aks.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp AKS_ComputeType
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = AKS_ComputeType(temp1)
	aks.ComputeType = &temp

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		aks.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		aks.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 AKS_Properties
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		aks.Properties = &properties
	}

	// no assignment for property "ResourceReference"

	// No error
	return nil
}

// AssignProperties_From_AKS populates our AKS from the provided source AKS
func (aks *AKS) AssignProperties_From_AKS(source *storage.AKS) error {

	// ComputeLocation
	aks.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, aKS_ComputeType_Values)
		aks.ComputeType = &computeTypeTemp
	} else {
		aks.ComputeType = nil
	}

	// Description
	aks.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		aks.DisableLocalAuth = &disableLocalAuth
	} else {
		aks.DisableLocalAuth = nil
	}

	// Properties
	if source.Properties != nil {
		var property AKS_Properties
		err := property.AssignProperties_From_AKS_Properties(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AKS_Properties() to populate field Properties")
		}
		aks.Properties = &property
	} else {
		aks.Properties = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		aks.ResourceReference = &resourceReference
	} else {
		aks.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AKS populates the provided destination AKS from our AKS
func (aks *AKS) AssignProperties_To_AKS(destination *storage.AKS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(aks.ComputeLocation)

	// ComputeType
	if aks.ComputeType != nil {
		computeType := string(*aks.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(aks.Description)

	// DisableLocalAuth
	if aks.DisableLocalAuth != nil {
		disableLocalAuth := *aks.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// Properties
	if aks.Properties != nil {
		var property storage.AKS_Properties
		err := aks.Properties.AssignProperties_To_AKS_Properties(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AKS_Properties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ResourceReference
	if aks.ResourceReference != nil {
		resourceReference := aks.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AKS_STATUS populates our AKS from the provided source AKS_STATUS
func (aks *AKS) Initialize_From_AKS_STATUS(source *AKS_STATUS) error {

	// ComputeLocation
	aks.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := genruntime.ToEnum(string(*source.ComputeType), aKS_ComputeType_Values)
		aks.ComputeType = &computeType
	} else {
		aks.ComputeType = nil
	}

	// Description
	aks.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		aks.DisableLocalAuth = &disableLocalAuth
	} else {
		aks.DisableLocalAuth = nil
	}

	// Properties
	if source.Properties != nil {
		var property AKS_Properties
		err := property.Initialize_From_AKS_Properties_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_AKS_Properties_STATUS() to populate field Properties")
		}
		aks.Properties = &property
	} else {
		aks.Properties = nil
	}

	// ResourceReference
	if source.ResourceId != nil {
		resourceReference := genruntime.CreateResourceReferenceFromARMID(*source.ResourceId)
		aks.ResourceReference = &resourceReference
	} else {
		aks.ResourceReference = nil
	}

	// No error
	return nil
}

type AKS_STATUS struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// ComputeType: The type of compute
	ComputeType *AKS_ComputeType_STATUS `json:"computeType,omitempty"`

	// CreatedOn: The time at which the compute was created.
	CreatedOn *string `json:"createdOn,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// IsAttachedCompute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine
	// learning service provisioned it if false.
	IsAttachedCompute *bool `json:"isAttachedCompute,omitempty"`

	// ModifiedOn: The time at which the compute was last modified.
	ModifiedOn *string `json:"modifiedOn,omitempty"`

	// Properties: AKS properties
	Properties *AKS_Properties_STATUS `json:"properties,omitempty"`

	// ProvisioningErrors: Errors during provisioning
	ProvisioningErrors []ErrorResponse_STATUS `json:"provisioningErrors,omitempty"`

	// ProvisioningState: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and
	// Failed.
	ProvisioningState *AKS_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// ResourceId: ARM resource id of the underlying compute
	ResourceId *string `json:"resourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &AKS_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (aks *AKS_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AKS_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (aks *AKS_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AKS_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AKS_STATUS, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		aks.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp AKS_ComputeType_STATUS
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = AKS_ComputeType_STATUS(temp1)
	aks.ComputeType = &temp

	// Set property "CreatedOn":
	if typedInput.CreatedOn != nil {
		createdOn := *typedInput.CreatedOn
		aks.CreatedOn = &createdOn
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		aks.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		aks.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "IsAttachedCompute":
	if typedInput.IsAttachedCompute != nil {
		isAttachedCompute := *typedInput.IsAttachedCompute
		aks.IsAttachedCompute = &isAttachedCompute
	}

	// Set property "ModifiedOn":
	if typedInput.ModifiedOn != nil {
		modifiedOn := *typedInput.ModifiedOn
		aks.ModifiedOn = &modifiedOn
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 AKS_Properties_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		aks.Properties = &properties
	}

	// Set property "ProvisioningErrors":
	for _, item := range typedInput.ProvisioningErrors {
		var item1 ErrorResponse_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		aks.ProvisioningErrors = append(aks.ProvisioningErrors, item1)
	}

	// Set property "ProvisioningState":
	if typedInput.ProvisioningState != nil {
		var provisioningStateTemp string
		provisioningStateTemp = string(*typedInput.ProvisioningState)
		provisioningState := AKS_ProvisioningState_STATUS(provisioningStateTemp)
		aks.ProvisioningState = &provisioningState
	}

	// Set property "ResourceId":
	if typedInput.ResourceId != nil {
		resourceId := *typedInput.ResourceId
		aks.ResourceId = &resourceId
	}

	// No error
	return nil
}

// AssignProperties_From_AKS_STATUS populates our AKS_STATUS from the provided source AKS_STATUS
func (aks *AKS_STATUS) AssignProperties_From_AKS_STATUS(source *storage.AKS_STATUS) error {

	// ComputeLocation
	aks.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, aKS_ComputeType_STATUS_Values)
		aks.ComputeType = &computeTypeTemp
	} else {
		aks.ComputeType = nil
	}

	// CreatedOn
	aks.CreatedOn = genruntime.ClonePointerToString(source.CreatedOn)

	// Description
	aks.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		aks.DisableLocalAuth = &disableLocalAuth
	} else {
		aks.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if source.IsAttachedCompute != nil {
		isAttachedCompute := *source.IsAttachedCompute
		aks.IsAttachedCompute = &isAttachedCompute
	} else {
		aks.IsAttachedCompute = nil
	}

	// ModifiedOn
	aks.ModifiedOn = genruntime.ClonePointerToString(source.ModifiedOn)

	// Properties
	if source.Properties != nil {
		var property AKS_Properties_STATUS
		err := property.AssignProperties_From_AKS_Properties_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AKS_Properties_STATUS() to populate field Properties")
		}
		aks.Properties = &property
	} else {
		aks.Properties = nil
	}

	// ProvisioningErrors
	if source.ProvisioningErrors != nil {
		provisioningErrorList := make([]ErrorResponse_STATUS, len(source.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range source.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError ErrorResponse_STATUS
			err := provisioningError.AssignProperties_From_ErrorResponse_STATUS(&provisioningErrorItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		aks.ProvisioningErrors = provisioningErrorList
	} else {
		aks.ProvisioningErrors = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, aKS_ProvisioningState_STATUS_Values)
		aks.ProvisioningState = &provisioningStateTemp
	} else {
		aks.ProvisioningState = nil
	}

	// ResourceId
	aks.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// No error
	return nil
}

// AssignProperties_To_AKS_STATUS populates the provided destination AKS_STATUS from our AKS_STATUS
func (aks *AKS_STATUS) AssignProperties_To_AKS_STATUS(destination *storage.AKS_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(aks.ComputeLocation)

	// ComputeType
	if aks.ComputeType != nil {
		computeType := string(*aks.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// CreatedOn
	destination.CreatedOn = genruntime.ClonePointerToString(aks.CreatedOn)

	// Description
	destination.Description = genruntime.ClonePointerToString(aks.Description)

	// DisableLocalAuth
	if aks.DisableLocalAuth != nil {
		disableLocalAuth := *aks.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if aks.IsAttachedCompute != nil {
		isAttachedCompute := *aks.IsAttachedCompute
		destination.IsAttachedCompute = &isAttachedCompute
	} else {
		destination.IsAttachedCompute = nil
	}

	// ModifiedOn
	destination.ModifiedOn = genruntime.ClonePointerToString(aks.ModifiedOn)

	// Properties
	if aks.Properties != nil {
		var property storage.AKS_Properties_STATUS
		err := aks.Properties.AssignProperties_To_AKS_Properties_STATUS(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AKS_Properties_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ProvisioningErrors
	if aks.ProvisioningErrors != nil {
		provisioningErrorList := make([]storage.ErrorResponse_STATUS, len(aks.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range aks.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError storage.ErrorResponse_STATUS
			err := provisioningErrorItem.AssignProperties_To_ErrorResponse_STATUS(&provisioningError)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		destination.ProvisioningErrors = provisioningErrorList
	} else {
		destination.ProvisioningErrors = nil
	}

	// ProvisioningState
	if aks.ProvisioningState != nil {
		provisioningState := string(*aks.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(aks.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AmlCompute struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// +kubebuilder:validation:Required
	// ComputeType: The type of compute
	ComputeType *AmlCompute_ComputeType `json:"computeType,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// Properties: Properties of AmlCompute
	Properties *AmlComputeProperties `json:"properties,omitempty"`

	// ResourceReference: ARM resource id of the underlying compute
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &AmlCompute{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (compute *AmlCompute) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if compute == nil {
		return nil, nil
	}
	result := &arm.AmlCompute{}

	// Set property "ComputeLocation":
	if compute.ComputeLocation != nil {
		computeLocation := *compute.ComputeLocation
		result.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	if compute.ComputeType != nil {
		var temp arm.AmlCompute_ComputeType
		var temp1 string
		temp1 = string(*compute.ComputeType)
		temp = arm.AmlCompute_ComputeType(temp1)
		result.ComputeType = temp
	}

	// Set property "Description":
	if compute.Description != nil {
		description := *compute.Description
		result.Description = &description
	}

	// Set property "DisableLocalAuth":
	if compute.DisableLocalAuth != nil {
		disableLocalAuth := *compute.DisableLocalAuth
		result.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if compute.Properties != nil {
		properties_ARM, err := (*compute.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*arm.AmlComputeProperties)
		result.Properties = &properties
	}

	// Set property "ResourceId":
	if compute.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*compute.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (compute *AmlCompute) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AmlCompute{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (compute *AmlCompute) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AmlCompute)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AmlCompute, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		compute.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp AmlCompute_ComputeType
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = AmlCompute_ComputeType(temp1)
	compute.ComputeType = &temp

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		compute.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		compute.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 AmlComputeProperties
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		compute.Properties = &properties
	}

	// no assignment for property "ResourceReference"

	// No error
	return nil
}

// AssignProperties_From_AmlCompute populates our AmlCompute from the provided source AmlCompute
func (compute *AmlCompute) AssignProperties_From_AmlCompute(source *storage.AmlCompute) error {

	// ComputeLocation
	compute.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, amlCompute_ComputeType_Values)
		compute.ComputeType = &computeTypeTemp
	} else {
		compute.ComputeType = nil
	}

	// Description
	compute.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		compute.DisableLocalAuth = &disableLocalAuth
	} else {
		compute.DisableLocalAuth = nil
	}

	// Properties
	if source.Properties != nil {
		var property AmlComputeProperties
		err := property.AssignProperties_From_AmlComputeProperties(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AmlComputeProperties() to populate field Properties")
		}
		compute.Properties = &property
	} else {
		compute.Properties = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		compute.ResourceReference = &resourceReference
	} else {
		compute.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AmlCompute populates the provided destination AmlCompute from our AmlCompute
func (compute *AmlCompute) AssignProperties_To_AmlCompute(destination *storage.AmlCompute) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(compute.ComputeLocation)

	// ComputeType
	if compute.ComputeType != nil {
		computeType := string(*compute.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(compute.Description)

	// DisableLocalAuth
	if compute.DisableLocalAuth != nil {
		disableLocalAuth := *compute.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// Properties
	if compute.Properties != nil {
		var property storage.AmlComputeProperties
		err := compute.Properties.AssignProperties_To_AmlComputeProperties(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AmlComputeProperties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ResourceReference
	if compute.ResourceReference != nil {
		resourceReference := compute.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AmlCompute_STATUS populates our AmlCompute from the provided source AmlCompute_STATUS
func (compute *AmlCompute) Initialize_From_AmlCompute_STATUS(source *AmlCompute_STATUS) error {

	// ComputeLocation
	compute.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := genruntime.ToEnum(string(*source.ComputeType), amlCompute_ComputeType_Values)
		compute.ComputeType = &computeType
	} else {
		compute.ComputeType = nil
	}

	// Description
	compute.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		compute.DisableLocalAuth = &disableLocalAuth
	} else {
		compute.DisableLocalAuth = nil
	}

	// Properties
	if source.Properties != nil {
		var property AmlComputeProperties
		err := property.Initialize_From_AmlComputeProperties_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_AmlComputeProperties_STATUS() to populate field Properties")
		}
		compute.Properties = &property
	} else {
		compute.Properties = nil
	}

	// ResourceReference
	if source.ResourceId != nil {
		resourceReference := genruntime.CreateResourceReferenceFromARMID(*source.ResourceId)
		compute.ResourceReference = &resourceReference
	} else {
		compute.ResourceReference = nil
	}

	// No error
	return nil
}

type AmlCompute_STATUS struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// ComputeType: The type of compute
	ComputeType *AmlCompute_ComputeType_STATUS `json:"computeType,omitempty"`

	// CreatedOn: The time at which the compute was created.
	CreatedOn *string `json:"createdOn,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// IsAttachedCompute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine
	// learning service provisioned it if false.
	IsAttachedCompute *bool `json:"isAttachedCompute,omitempty"`

	// ModifiedOn: The time at which the compute was last modified.
	ModifiedOn *string `json:"modifiedOn,omitempty"`

	// Properties: Properties of AmlCompute
	Properties *AmlComputeProperties_STATUS `json:"properties,omitempty"`

	// ProvisioningErrors: Errors during provisioning
	ProvisioningErrors []ErrorResponse_STATUS `json:"provisioningErrors,omitempty"`

	// ProvisioningState: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and
	// Failed.
	ProvisioningState *AmlCompute_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// ResourceId: ARM resource id of the underlying compute
	ResourceId *string `json:"resourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &AmlCompute_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (compute *AmlCompute_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AmlCompute_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (compute *AmlCompute_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AmlCompute_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AmlCompute_STATUS, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		compute.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp AmlCompute_ComputeType_STATUS
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = AmlCompute_ComputeType_STATUS(temp1)
	compute.ComputeType = &temp

	// Set property "CreatedOn":
	if typedInput.CreatedOn != nil {
		createdOn := *typedInput.CreatedOn
		compute.CreatedOn = &createdOn
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		compute.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		compute.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "IsAttachedCompute":
	if typedInput.IsAttachedCompute != nil {
		isAttachedCompute := *typedInput.IsAttachedCompute
		compute.IsAttachedCompute = &isAttachedCompute
	}

	// Set property "ModifiedOn":
	if typedInput.ModifiedOn != nil {
		modifiedOn := *typedInput.ModifiedOn
		compute.ModifiedOn = &modifiedOn
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 AmlComputeProperties_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		compute.Properties = &properties
	}

	// Set property "ProvisioningErrors":
	for _, item := range typedInput.ProvisioningErrors {
		var item1 ErrorResponse_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		compute.ProvisioningErrors = append(compute.ProvisioningErrors, item1)
	}

	// Set property "ProvisioningState":
	if typedInput.ProvisioningState != nil {
		var provisioningStateTemp string
		provisioningStateTemp = string(*typedInput.ProvisioningState)
		provisioningState := AmlCompute_ProvisioningState_STATUS(provisioningStateTemp)
		compute.ProvisioningState = &provisioningState
	}

	// Set property "ResourceId":
	if typedInput.ResourceId != nil {
		resourceId := *typedInput.ResourceId
		compute.ResourceId = &resourceId
	}

	// No error
	return nil
}

// AssignProperties_From_AmlCompute_STATUS populates our AmlCompute_STATUS from the provided source AmlCompute_STATUS
func (compute *AmlCompute_STATUS) AssignProperties_From_AmlCompute_STATUS(source *storage.AmlCompute_STATUS) error {

	// ComputeLocation
	compute.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, amlCompute_ComputeType_STATUS_Values)
		compute.ComputeType = &computeTypeTemp
	} else {
		compute.ComputeType = nil
	}

	// CreatedOn
	compute.CreatedOn = genruntime.ClonePointerToString(source.CreatedOn)

	// Description
	compute.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		compute.DisableLocalAuth = &disableLocalAuth
	} else {
		compute.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if source.IsAttachedCompute != nil {
		isAttachedCompute := *source.IsAttachedCompute
		compute.IsAttachedCompute = &isAttachedCompute
	} else {
		compute.IsAttachedCompute = nil
	}

	// ModifiedOn
	compute.ModifiedOn = genruntime.ClonePointerToString(source.ModifiedOn)

	// Properties
	if source.Properties != nil {
		var property AmlComputeProperties_STATUS
		err := property.AssignProperties_From_AmlComputeProperties_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AmlComputeProperties_STATUS() to populate field Properties")
		}
		compute.Properties = &property
	} else {
		compute.Properties = nil
	}

	// ProvisioningErrors
	if source.ProvisioningErrors != nil {
		provisioningErrorList := make([]ErrorResponse_STATUS, len(source.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range source.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError ErrorResponse_STATUS
			err := provisioningError.AssignProperties_From_ErrorResponse_STATUS(&provisioningErrorItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		compute.ProvisioningErrors = provisioningErrorList
	} else {
		compute.ProvisioningErrors = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, amlCompute_ProvisioningState_STATUS_Values)
		compute.ProvisioningState = &provisioningStateTemp
	} else {
		compute.ProvisioningState = nil
	}

	// ResourceId
	compute.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// No error
	return nil
}

// AssignProperties_To_AmlCompute_STATUS populates the provided destination AmlCompute_STATUS from our AmlCompute_STATUS
func (compute *AmlCompute_STATUS) AssignProperties_To_AmlCompute_STATUS(destination *storage.AmlCompute_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(compute.ComputeLocation)

	// ComputeType
	if compute.ComputeType != nil {
		computeType := string(*compute.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// CreatedOn
	destination.CreatedOn = genruntime.ClonePointerToString(compute.CreatedOn)

	// Description
	destination.Description = genruntime.ClonePointerToString(compute.Description)

	// DisableLocalAuth
	if compute.DisableLocalAuth != nil {
		disableLocalAuth := *compute.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if compute.IsAttachedCompute != nil {
		isAttachedCompute := *compute.IsAttachedCompute
		destination.IsAttachedCompute = &isAttachedCompute
	} else {
		destination.IsAttachedCompute = nil
	}

	// ModifiedOn
	destination.ModifiedOn = genruntime.ClonePointerToString(compute.ModifiedOn)

	// Properties
	if compute.Properties != nil {
		var property storage.AmlComputeProperties_STATUS
		err := compute.Properties.AssignProperties_To_AmlComputeProperties_STATUS(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AmlComputeProperties_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ProvisioningErrors
	if compute.ProvisioningErrors != nil {
		provisioningErrorList := make([]storage.ErrorResponse_STATUS, len(compute.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range compute.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError storage.ErrorResponse_STATUS
			err := provisioningErrorItem.AssignProperties_To_ErrorResponse_STATUS(&provisioningError)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		destination.ProvisioningErrors = provisioningErrorList
	} else {
		destination.ProvisioningErrors = nil
	}

	// ProvisioningState
	if compute.ProvisioningState != nil {
		provisioningState := string(*compute.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(compute.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ComputeInstance struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// +kubebuilder:validation:Required
	// ComputeType: The type of compute
	ComputeType *ComputeInstance_ComputeType `json:"computeType,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// Properties: Properties of ComputeInstance
	Properties *ComputeInstanceProperties `json:"properties,omitempty"`

	// ResourceReference: ARM resource id of the underlying compute
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &ComputeInstance{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (instance *ComputeInstance) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if instance == nil {
		return nil, nil
	}
	result := &arm.ComputeInstance{}

	// Set property "ComputeLocation":
	if instance.ComputeLocation != nil {
		computeLocation := *instance.ComputeLocation
		result.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	if instance.ComputeType != nil {
		var temp arm.ComputeInstance_ComputeType
		var temp1 string
		temp1 = string(*instance.ComputeType)
		temp = arm.ComputeInstance_ComputeType(temp1)
		result.ComputeType = temp
	}

	// Set property "Description":
	if instance.Description != nil {
		description := *instance.Description
		result.Description = &description
	}

	// Set property "DisableLocalAuth":
	if instance.DisableLocalAuth != nil {
		disableLocalAuth := *instance.DisableLocalAuth
		result.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if instance.Properties != nil {
		properties_ARM, err := (*instance.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*arm.ComputeInstanceProperties)
		result.Properties = &properties
	}

	// Set property "ResourceId":
	if instance.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*instance.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (instance *ComputeInstance) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComputeInstance{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (instance *ComputeInstance) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComputeInstance)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComputeInstance, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		instance.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp ComputeInstance_ComputeType
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = ComputeInstance_ComputeType(temp1)
	instance.ComputeType = &temp

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		instance.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		instance.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 ComputeInstanceProperties
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		instance.Properties = &properties
	}

	// no assignment for property "ResourceReference"

	// No error
	return nil
}

// AssignProperties_From_ComputeInstance populates our ComputeInstance from the provided source ComputeInstance
func (instance *ComputeInstance) AssignProperties_From_ComputeInstance(source *storage.ComputeInstance) error {

	// ComputeLocation
	instance.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, computeInstance_ComputeType_Values)
		instance.ComputeType = &computeTypeTemp
	} else {
		instance.ComputeType = nil
	}

	// Description
	instance.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		instance.DisableLocalAuth = &disableLocalAuth
	} else {
		instance.DisableLocalAuth = nil
	}

	// Properties
	if source.Properties != nil {
		var property ComputeInstanceProperties
		err := property.AssignProperties_From_ComputeInstanceProperties(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ComputeInstanceProperties() to populate field Properties")
		}
		instance.Properties = &property
	} else {
		instance.Properties = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		instance.ResourceReference = &resourceReference
	} else {
		instance.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ComputeInstance populates the provided destination ComputeInstance from our ComputeInstance
func (instance *ComputeInstance) AssignProperties_To_ComputeInstance(destination *storage.ComputeInstance) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(instance.ComputeLocation)

	// ComputeType
	if instance.ComputeType != nil {
		computeType := string(*instance.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(instance.Description)

	// DisableLocalAuth
	if instance.DisableLocalAuth != nil {
		disableLocalAuth := *instance.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// Properties
	if instance.Properties != nil {
		var property storage.ComputeInstanceProperties
		err := instance.Properties.AssignProperties_To_ComputeInstanceProperties(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ComputeInstanceProperties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ResourceReference
	if instance.ResourceReference != nil {
		resourceReference := instance.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ComputeInstance_STATUS populates our ComputeInstance from the provided source ComputeInstance_STATUS
func (instance *ComputeInstance) Initialize_From_ComputeInstance_STATUS(source *ComputeInstance_STATUS) error {

	// ComputeLocation
	instance.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := genruntime.ToEnum(string(*source.ComputeType), computeInstance_ComputeType_Values)
		instance.ComputeType = &computeType
	} else {
		instance.ComputeType = nil
	}

	// Description
	instance.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		instance.DisableLocalAuth = &disableLocalAuth
	} else {
		instance.DisableLocalAuth = nil
	}

	// Properties
	if source.Properties != nil {
		var property ComputeInstanceProperties
		err := property.Initialize_From_ComputeInstanceProperties_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ComputeInstanceProperties_STATUS() to populate field Properties")
		}
		instance.Properties = &property
	} else {
		instance.Properties = nil
	}

	// ResourceReference
	if source.ResourceId != nil {
		resourceReference := genruntime.CreateResourceReferenceFromARMID(*source.ResourceId)
		instance.ResourceReference = &resourceReference
	} else {
		instance.ResourceReference = nil
	}

	// No error
	return nil
}

type ComputeInstance_STATUS struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// ComputeType: The type of compute
	ComputeType *ComputeInstance_ComputeType_STATUS `json:"computeType,omitempty"`

	// CreatedOn: The time at which the compute was created.
	CreatedOn *string `json:"createdOn,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// IsAttachedCompute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine
	// learning service provisioned it if false.
	IsAttachedCompute *bool `json:"isAttachedCompute,omitempty"`

	// ModifiedOn: The time at which the compute was last modified.
	ModifiedOn *string `json:"modifiedOn,omitempty"`

	// Properties: Properties of ComputeInstance
	Properties *ComputeInstanceProperties_STATUS `json:"properties,omitempty"`

	// ProvisioningErrors: Errors during provisioning
	ProvisioningErrors []ErrorResponse_STATUS `json:"provisioningErrors,omitempty"`

	// ProvisioningState: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and
	// Failed.
	ProvisioningState *ComputeInstance_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// ResourceId: ARM resource id of the underlying compute
	ResourceId *string `json:"resourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &ComputeInstance_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (instance *ComputeInstance_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComputeInstance_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (instance *ComputeInstance_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComputeInstance_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComputeInstance_STATUS, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		instance.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp ComputeInstance_ComputeType_STATUS
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = ComputeInstance_ComputeType_STATUS(temp1)
	instance.ComputeType = &temp

	// Set property "CreatedOn":
	if typedInput.CreatedOn != nil {
		createdOn := *typedInput.CreatedOn
		instance.CreatedOn = &createdOn
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		instance.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		instance.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "IsAttachedCompute":
	if typedInput.IsAttachedCompute != nil {
		isAttachedCompute := *typedInput.IsAttachedCompute
		instance.IsAttachedCompute = &isAttachedCompute
	}

	// Set property "ModifiedOn":
	if typedInput.ModifiedOn != nil {
		modifiedOn := *typedInput.ModifiedOn
		instance.ModifiedOn = &modifiedOn
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 ComputeInstanceProperties_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		instance.Properties = &properties
	}

	// Set property "ProvisioningErrors":
	for _, item := range typedInput.ProvisioningErrors {
		var item1 ErrorResponse_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		instance.ProvisioningErrors = append(instance.ProvisioningErrors, item1)
	}

	// Set property "ProvisioningState":
	if typedInput.ProvisioningState != nil {
		var provisioningStateTemp string
		provisioningStateTemp = string(*typedInput.ProvisioningState)
		provisioningState := ComputeInstance_ProvisioningState_STATUS(provisioningStateTemp)
		instance.ProvisioningState = &provisioningState
	}

	// Set property "ResourceId":
	if typedInput.ResourceId != nil {
		resourceId := *typedInput.ResourceId
		instance.ResourceId = &resourceId
	}

	// No error
	return nil
}

// AssignProperties_From_ComputeInstance_STATUS populates our ComputeInstance_STATUS from the provided source ComputeInstance_STATUS
func (instance *ComputeInstance_STATUS) AssignProperties_From_ComputeInstance_STATUS(source *storage.ComputeInstance_STATUS) error {

	// ComputeLocation
	instance.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, computeInstance_ComputeType_STATUS_Values)
		instance.ComputeType = &computeTypeTemp
	} else {
		instance.ComputeType = nil
	}

	// CreatedOn
	instance.CreatedOn = genruntime.ClonePointerToString(source.CreatedOn)

	// Description
	instance.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		instance.DisableLocalAuth = &disableLocalAuth
	} else {
		instance.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if source.IsAttachedCompute != nil {
		isAttachedCompute := *source.IsAttachedCompute
		instance.IsAttachedCompute = &isAttachedCompute
	} else {
		instance.IsAttachedCompute = nil
	}

	// ModifiedOn
	instance.ModifiedOn = genruntime.ClonePointerToString(source.ModifiedOn)

	// Properties
	if source.Properties != nil {
		var property ComputeInstanceProperties_STATUS
		err := property.AssignProperties_From_ComputeInstanceProperties_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ComputeInstanceProperties_STATUS() to populate field Properties")
		}
		instance.Properties = &property
	} else {
		instance.Properties = nil
	}

	// ProvisioningErrors
	if source.ProvisioningErrors != nil {
		provisioningErrorList := make([]ErrorResponse_STATUS, len(source.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range source.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError ErrorResponse_STATUS
			err := provisioningError.AssignProperties_From_ErrorResponse_STATUS(&provisioningErrorItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		instance.ProvisioningErrors = provisioningErrorList
	} else {
		instance.ProvisioningErrors = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, computeInstance_ProvisioningState_STATUS_Values)
		instance.ProvisioningState = &provisioningStateTemp
	} else {
		instance.ProvisioningState = nil
	}

	// ResourceId
	instance.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// No error
	return nil
}

// AssignProperties_To_ComputeInstance_STATUS populates the provided destination ComputeInstance_STATUS from our ComputeInstance_STATUS
func (instance *ComputeInstance_STATUS) AssignProperties_To_ComputeInstance_STATUS(destination *storage.ComputeInstance_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(instance.ComputeLocation)

	// ComputeType
	if instance.ComputeType != nil {
		computeType := string(*instance.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// CreatedOn
	destination.CreatedOn = genruntime.ClonePointerToString(instance.CreatedOn)

	// Description
	destination.Description = genruntime.ClonePointerToString(instance.Description)

	// DisableLocalAuth
	if instance.DisableLocalAuth != nil {
		disableLocalAuth := *instance.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if instance.IsAttachedCompute != nil {
		isAttachedCompute := *instance.IsAttachedCompute
		destination.IsAttachedCompute = &isAttachedCompute
	} else {
		destination.IsAttachedCompute = nil
	}

	// ModifiedOn
	destination.ModifiedOn = genruntime.ClonePointerToString(instance.ModifiedOn)

	// Properties
	if instance.Properties != nil {
		var property storage.ComputeInstanceProperties_STATUS
		err := instance.Properties.AssignProperties_To_ComputeInstanceProperties_STATUS(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ComputeInstanceProperties_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ProvisioningErrors
	if instance.ProvisioningErrors != nil {
		provisioningErrorList := make([]storage.ErrorResponse_STATUS, len(instance.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range instance.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError storage.ErrorResponse_STATUS
			err := provisioningErrorItem.AssignProperties_To_ErrorResponse_STATUS(&provisioningError)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		destination.ProvisioningErrors = provisioningErrorList
	} else {
		destination.ProvisioningErrors = nil
	}

	// ProvisioningState
	if instance.ProvisioningState != nil {
		provisioningState := string(*instance.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(instance.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Databricks struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// +kubebuilder:validation:Required
	// ComputeType: The type of compute
	ComputeType *Databricks_ComputeType `json:"computeType,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// Properties: Properties of Databricks
	Properties *DatabricksProperties `json:"properties,omitempty"`

	// ResourceReference: ARM resource id of the underlying compute
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &Databricks{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (databricks *Databricks) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if databricks == nil {
		return nil, nil
	}
	result := &arm.Databricks{}

	// Set property "ComputeLocation":
	if databricks.ComputeLocation != nil {
		computeLocation := *databricks.ComputeLocation
		result.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	if databricks.ComputeType != nil {
		var temp arm.Databricks_ComputeType
		var temp1 string
		temp1 = string(*databricks.ComputeType)
		temp = arm.Databricks_ComputeType(temp1)
		result.ComputeType = temp
	}

	// Set property "Description":
	if databricks.Description != nil {
		description := *databricks.Description
		result.Description = &description
	}

	// Set property "DisableLocalAuth":
	if databricks.DisableLocalAuth != nil {
		disableLocalAuth := *databricks.DisableLocalAuth
		result.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if databricks.Properties != nil {
		properties_ARM, err := (*databricks.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*arm.DatabricksProperties)
		result.Properties = &properties
	}

	// Set property "ResourceId":
	if databricks.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*databricks.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (databricks *Databricks) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Databricks{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (databricks *Databricks) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Databricks)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Databricks, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		databricks.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp Databricks_ComputeType
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = Databricks_ComputeType(temp1)
	databricks.ComputeType = &temp

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		databricks.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		databricks.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 DatabricksProperties
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		databricks.Properties = &properties
	}

	// no assignment for property "ResourceReference"

	// No error
	return nil
}

// AssignProperties_From_Databricks populates our Databricks from the provided source Databricks
func (databricks *Databricks) AssignProperties_From_Databricks(source *storage.Databricks) error {

	// ComputeLocation
	databricks.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, databricks_ComputeType_Values)
		databricks.ComputeType = &computeTypeTemp
	} else {
		databricks.ComputeType = nil
	}

	// Description
	databricks.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		databricks.DisableLocalAuth = &disableLocalAuth
	} else {
		databricks.DisableLocalAuth = nil
	}

	// Properties
	if source.Properties != nil {
		var property DatabricksProperties
		err := property.AssignProperties_From_DatabricksProperties(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DatabricksProperties() to populate field Properties")
		}
		databricks.Properties = &property
	} else {
		databricks.Properties = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		databricks.ResourceReference = &resourceReference
	} else {
		databricks.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Databricks populates the provided destination Databricks from our Databricks
func (databricks *Databricks) AssignProperties_To_Databricks(destination *storage.Databricks) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(databricks.ComputeLocation)

	// ComputeType
	if databricks.ComputeType != nil {
		computeType := string(*databricks.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(databricks.Description)

	// DisableLocalAuth
	if databricks.DisableLocalAuth != nil {
		disableLocalAuth := *databricks.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// Properties
	if databricks.Properties != nil {
		var property storage.DatabricksProperties
		err := databricks.Properties.AssignProperties_To_DatabricksProperties(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DatabricksProperties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ResourceReference
	if databricks.ResourceReference != nil {
		resourceReference := databricks.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Databricks_STATUS populates our Databricks from the provided source Databricks_STATUS
func (databricks *Databricks) Initialize_From_Databricks_STATUS(source *Databricks_STATUS) error {

	// ComputeLocation
	databricks.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := genruntime.ToEnum(string(*source.ComputeType), databricks_ComputeType_Values)
		databricks.ComputeType = &computeType
	} else {
		databricks.ComputeType = nil
	}

	// Description
	databricks.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		databricks.DisableLocalAuth = &disableLocalAuth
	} else {
		databricks.DisableLocalAuth = nil
	}

	// Properties
	if source.Properties != nil {
		var property DatabricksProperties
		err := property.Initialize_From_DatabricksProperties_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DatabricksProperties_STATUS() to populate field Properties")
		}
		databricks.Properties = &property
	} else {
		databricks.Properties = nil
	}

	// ResourceReference
	if source.ResourceId != nil {
		resourceReference := genruntime.CreateResourceReferenceFromARMID(*source.ResourceId)
		databricks.ResourceReference = &resourceReference
	} else {
		databricks.ResourceReference = nil
	}

	// No error
	return nil
}

type Databricks_STATUS struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// ComputeType: The type of compute
	ComputeType *Databricks_ComputeType_STATUS `json:"computeType,omitempty"`

	// CreatedOn: The time at which the compute was created.
	CreatedOn *string `json:"createdOn,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// IsAttachedCompute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine
	// learning service provisioned it if false.
	IsAttachedCompute *bool `json:"isAttachedCompute,omitempty"`

	// ModifiedOn: The time at which the compute was last modified.
	ModifiedOn *string `json:"modifiedOn,omitempty"`

	// Properties: Properties of Databricks
	Properties *DatabricksProperties_STATUS `json:"properties,omitempty"`

	// ProvisioningErrors: Errors during provisioning
	ProvisioningErrors []ErrorResponse_STATUS `json:"provisioningErrors,omitempty"`

	// ProvisioningState: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and
	// Failed.
	ProvisioningState *Databricks_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// ResourceId: ARM resource id of the underlying compute
	ResourceId *string `json:"resourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &Databricks_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (databricks *Databricks_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Databricks_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (databricks *Databricks_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Databricks_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Databricks_STATUS, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		databricks.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp Databricks_ComputeType_STATUS
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = Databricks_ComputeType_STATUS(temp1)
	databricks.ComputeType = &temp

	// Set property "CreatedOn":
	if typedInput.CreatedOn != nil {
		createdOn := *typedInput.CreatedOn
		databricks.CreatedOn = &createdOn
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		databricks.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		databricks.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "IsAttachedCompute":
	if typedInput.IsAttachedCompute != nil {
		isAttachedCompute := *typedInput.IsAttachedCompute
		databricks.IsAttachedCompute = &isAttachedCompute
	}

	// Set property "ModifiedOn":
	if typedInput.ModifiedOn != nil {
		modifiedOn := *typedInput.ModifiedOn
		databricks.ModifiedOn = &modifiedOn
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 DatabricksProperties_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		databricks.Properties = &properties
	}

	// Set property "ProvisioningErrors":
	for _, item := range typedInput.ProvisioningErrors {
		var item1 ErrorResponse_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		databricks.ProvisioningErrors = append(databricks.ProvisioningErrors, item1)
	}

	// Set property "ProvisioningState":
	if typedInput.ProvisioningState != nil {
		var provisioningStateTemp string
		provisioningStateTemp = string(*typedInput.ProvisioningState)
		provisioningState := Databricks_ProvisioningState_STATUS(provisioningStateTemp)
		databricks.ProvisioningState = &provisioningState
	}

	// Set property "ResourceId":
	if typedInput.ResourceId != nil {
		resourceId := *typedInput.ResourceId
		databricks.ResourceId = &resourceId
	}

	// No error
	return nil
}

// AssignProperties_From_Databricks_STATUS populates our Databricks_STATUS from the provided source Databricks_STATUS
func (databricks *Databricks_STATUS) AssignProperties_From_Databricks_STATUS(source *storage.Databricks_STATUS) error {

	// ComputeLocation
	databricks.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, databricks_ComputeType_STATUS_Values)
		databricks.ComputeType = &computeTypeTemp
	} else {
		databricks.ComputeType = nil
	}

	// CreatedOn
	databricks.CreatedOn = genruntime.ClonePointerToString(source.CreatedOn)

	// Description
	databricks.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		databricks.DisableLocalAuth = &disableLocalAuth
	} else {
		databricks.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if source.IsAttachedCompute != nil {
		isAttachedCompute := *source.IsAttachedCompute
		databricks.IsAttachedCompute = &isAttachedCompute
	} else {
		databricks.IsAttachedCompute = nil
	}

	// ModifiedOn
	databricks.ModifiedOn = genruntime.ClonePointerToString(source.ModifiedOn)

	// Properties
	if source.Properties != nil {
		var property DatabricksProperties_STATUS
		err := property.AssignProperties_From_DatabricksProperties_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DatabricksProperties_STATUS() to populate field Properties")
		}
		databricks.Properties = &property
	} else {
		databricks.Properties = nil
	}

	// ProvisioningErrors
	if source.ProvisioningErrors != nil {
		provisioningErrorList := make([]ErrorResponse_STATUS, len(source.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range source.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError ErrorResponse_STATUS
			err := provisioningError.AssignProperties_From_ErrorResponse_STATUS(&provisioningErrorItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		databricks.ProvisioningErrors = provisioningErrorList
	} else {
		databricks.ProvisioningErrors = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, databricks_ProvisioningState_STATUS_Values)
		databricks.ProvisioningState = &provisioningStateTemp
	} else {
		databricks.ProvisioningState = nil
	}

	// ResourceId
	databricks.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// No error
	return nil
}

// AssignProperties_To_Databricks_STATUS populates the provided destination Databricks_STATUS from our Databricks_STATUS
func (databricks *Databricks_STATUS) AssignProperties_To_Databricks_STATUS(destination *storage.Databricks_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(databricks.ComputeLocation)

	// ComputeType
	if databricks.ComputeType != nil {
		computeType := string(*databricks.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// CreatedOn
	destination.CreatedOn = genruntime.ClonePointerToString(databricks.CreatedOn)

	// Description
	destination.Description = genruntime.ClonePointerToString(databricks.Description)

	// DisableLocalAuth
	if databricks.DisableLocalAuth != nil {
		disableLocalAuth := *databricks.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if databricks.IsAttachedCompute != nil {
		isAttachedCompute := *databricks.IsAttachedCompute
		destination.IsAttachedCompute = &isAttachedCompute
	} else {
		destination.IsAttachedCompute = nil
	}

	// ModifiedOn
	destination.ModifiedOn = genruntime.ClonePointerToString(databricks.ModifiedOn)

	// Properties
	if databricks.Properties != nil {
		var property storage.DatabricksProperties_STATUS
		err := databricks.Properties.AssignProperties_To_DatabricksProperties_STATUS(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DatabricksProperties_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ProvisioningErrors
	if databricks.ProvisioningErrors != nil {
		provisioningErrorList := make([]storage.ErrorResponse_STATUS, len(databricks.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range databricks.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError storage.ErrorResponse_STATUS
			err := provisioningErrorItem.AssignProperties_To_ErrorResponse_STATUS(&provisioningError)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		destination.ProvisioningErrors = provisioningErrorList
	} else {
		destination.ProvisioningErrors = nil
	}

	// ProvisioningState
	if databricks.ProvisioningState != nil {
		provisioningState := string(*databricks.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(databricks.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DataFactory struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// +kubebuilder:validation:Required
	// ComputeType: The type of compute
	ComputeType *DataFactory_ComputeType `json:"computeType,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// ResourceReference: ARM resource id of the underlying compute
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &DataFactory{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (factory *DataFactory) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if factory == nil {
		return nil, nil
	}
	result := &arm.DataFactory{}

	// Set property "ComputeLocation":
	if factory.ComputeLocation != nil {
		computeLocation := *factory.ComputeLocation
		result.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	if factory.ComputeType != nil {
		var temp arm.DataFactory_ComputeType
		var temp1 string
		temp1 = string(*factory.ComputeType)
		temp = arm.DataFactory_ComputeType(temp1)
		result.ComputeType = temp
	}

	// Set property "Description":
	if factory.Description != nil {
		description := *factory.Description
		result.Description = &description
	}

	// Set property "DisableLocalAuth":
	if factory.DisableLocalAuth != nil {
		disableLocalAuth := *factory.DisableLocalAuth
		result.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "ResourceId":
	if factory.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*factory.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (factory *DataFactory) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DataFactory{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (factory *DataFactory) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DataFactory)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DataFactory, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		factory.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp DataFactory_ComputeType
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = DataFactory_ComputeType(temp1)
	factory.ComputeType = &temp

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		factory.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		factory.DisableLocalAuth = &disableLocalAuth
	}

	// no assignment for property "ResourceReference"

	// No error
	return nil
}

// AssignProperties_From_DataFactory populates our DataFactory from the provided source DataFactory
func (factory *DataFactory) AssignProperties_From_DataFactory(source *storage.DataFactory) error {

	// ComputeLocation
	factory.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, dataFactory_ComputeType_Values)
		factory.ComputeType = &computeTypeTemp
	} else {
		factory.ComputeType = nil
	}

	// Description
	factory.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		factory.DisableLocalAuth = &disableLocalAuth
	} else {
		factory.DisableLocalAuth = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		factory.ResourceReference = &resourceReference
	} else {
		factory.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DataFactory populates the provided destination DataFactory from our DataFactory
func (factory *DataFactory) AssignProperties_To_DataFactory(destination *storage.DataFactory) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(factory.ComputeLocation)

	// ComputeType
	if factory.ComputeType != nil {
		computeType := string(*factory.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(factory.Description)

	// DisableLocalAuth
	if factory.DisableLocalAuth != nil {
		disableLocalAuth := *factory.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// ResourceReference
	if factory.ResourceReference != nil {
		resourceReference := factory.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DataFactory_STATUS populates our DataFactory from the provided source DataFactory_STATUS
func (factory *DataFactory) Initialize_From_DataFactory_STATUS(source *DataFactory_STATUS) error {

	// ComputeLocation
	factory.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := genruntime.ToEnum(string(*source.ComputeType), dataFactory_ComputeType_Values)
		factory.ComputeType = &computeType
	} else {
		factory.ComputeType = nil
	}

	// Description
	factory.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		factory.DisableLocalAuth = &disableLocalAuth
	} else {
		factory.DisableLocalAuth = nil
	}

	// ResourceReference
	if source.ResourceId != nil {
		resourceReference := genruntime.CreateResourceReferenceFromARMID(*source.ResourceId)
		factory.ResourceReference = &resourceReference
	} else {
		factory.ResourceReference = nil
	}

	// No error
	return nil
}

type DataFactory_STATUS struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// ComputeType: The type of compute
	ComputeType *DataFactory_ComputeType_STATUS `json:"computeType,omitempty"`

	// CreatedOn: The time at which the compute was created.
	CreatedOn *string `json:"createdOn,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// IsAttachedCompute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine
	// learning service provisioned it if false.
	IsAttachedCompute *bool `json:"isAttachedCompute,omitempty"`

	// ModifiedOn: The time at which the compute was last modified.
	ModifiedOn *string `json:"modifiedOn,omitempty"`

	// ProvisioningErrors: Errors during provisioning
	ProvisioningErrors []ErrorResponse_STATUS `json:"provisioningErrors,omitempty"`

	// ProvisioningState: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and
	// Failed.
	ProvisioningState *DataFactory_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// ResourceId: ARM resource id of the underlying compute
	ResourceId *string `json:"resourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &DataFactory_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (factory *DataFactory_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DataFactory_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (factory *DataFactory_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DataFactory_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DataFactory_STATUS, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		factory.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp DataFactory_ComputeType_STATUS
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = DataFactory_ComputeType_STATUS(temp1)
	factory.ComputeType = &temp

	// Set property "CreatedOn":
	if typedInput.CreatedOn != nil {
		createdOn := *typedInput.CreatedOn
		factory.CreatedOn = &createdOn
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		factory.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		factory.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "IsAttachedCompute":
	if typedInput.IsAttachedCompute != nil {
		isAttachedCompute := *typedInput.IsAttachedCompute
		factory.IsAttachedCompute = &isAttachedCompute
	}

	// Set property "ModifiedOn":
	if typedInput.ModifiedOn != nil {
		modifiedOn := *typedInput.ModifiedOn
		factory.ModifiedOn = &modifiedOn
	}

	// Set property "ProvisioningErrors":
	for _, item := range typedInput.ProvisioningErrors {
		var item1 ErrorResponse_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		factory.ProvisioningErrors = append(factory.ProvisioningErrors, item1)
	}

	// Set property "ProvisioningState":
	if typedInput.ProvisioningState != nil {
		var provisioningStateTemp string
		provisioningStateTemp = string(*typedInput.ProvisioningState)
		provisioningState := DataFactory_ProvisioningState_STATUS(provisioningStateTemp)
		factory.ProvisioningState = &provisioningState
	}

	// Set property "ResourceId":
	if typedInput.ResourceId != nil {
		resourceId := *typedInput.ResourceId
		factory.ResourceId = &resourceId
	}

	// No error
	return nil
}

// AssignProperties_From_DataFactory_STATUS populates our DataFactory_STATUS from the provided source DataFactory_STATUS
func (factory *DataFactory_STATUS) AssignProperties_From_DataFactory_STATUS(source *storage.DataFactory_STATUS) error {

	// ComputeLocation
	factory.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, dataFactory_ComputeType_STATUS_Values)
		factory.ComputeType = &computeTypeTemp
	} else {
		factory.ComputeType = nil
	}

	// CreatedOn
	factory.CreatedOn = genruntime.ClonePointerToString(source.CreatedOn)

	// Description
	factory.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		factory.DisableLocalAuth = &disableLocalAuth
	} else {
		factory.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if source.IsAttachedCompute != nil {
		isAttachedCompute := *source.IsAttachedCompute
		factory.IsAttachedCompute = &isAttachedCompute
	} else {
		factory.IsAttachedCompute = nil
	}

	// ModifiedOn
	factory.ModifiedOn = genruntime.ClonePointerToString(source.ModifiedOn)

	// ProvisioningErrors
	if source.ProvisioningErrors != nil {
		provisioningErrorList := make([]ErrorResponse_STATUS, len(source.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range source.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError ErrorResponse_STATUS
			err := provisioningError.AssignProperties_From_ErrorResponse_STATUS(&provisioningErrorItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		factory.ProvisioningErrors = provisioningErrorList
	} else {
		factory.ProvisioningErrors = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, dataFactory_ProvisioningState_STATUS_Values)
		factory.ProvisioningState = &provisioningStateTemp
	} else {
		factory.ProvisioningState = nil
	}

	// ResourceId
	factory.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// No error
	return nil
}

// AssignProperties_To_DataFactory_STATUS populates the provided destination DataFactory_STATUS from our DataFactory_STATUS
func (factory *DataFactory_STATUS) AssignProperties_To_DataFactory_STATUS(destination *storage.DataFactory_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(factory.ComputeLocation)

	// ComputeType
	if factory.ComputeType != nil {
		computeType := string(*factory.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// CreatedOn
	destination.CreatedOn = genruntime.ClonePointerToString(factory.CreatedOn)

	// Description
	destination.Description = genruntime.ClonePointerToString(factory.Description)

	// DisableLocalAuth
	if factory.DisableLocalAuth != nil {
		disableLocalAuth := *factory.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if factory.IsAttachedCompute != nil {
		isAttachedCompute := *factory.IsAttachedCompute
		destination.IsAttachedCompute = &isAttachedCompute
	} else {
		destination.IsAttachedCompute = nil
	}

	// ModifiedOn
	destination.ModifiedOn = genruntime.ClonePointerToString(factory.ModifiedOn)

	// ProvisioningErrors
	if factory.ProvisioningErrors != nil {
		provisioningErrorList := make([]storage.ErrorResponse_STATUS, len(factory.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range factory.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError storage.ErrorResponse_STATUS
			err := provisioningErrorItem.AssignProperties_To_ErrorResponse_STATUS(&provisioningError)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		destination.ProvisioningErrors = provisioningErrorList
	} else {
		destination.ProvisioningErrors = nil
	}

	// ProvisioningState
	if factory.ProvisioningState != nil {
		provisioningState := string(*factory.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(factory.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DataLakeAnalytics struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// +kubebuilder:validation:Required
	// ComputeType: The type of compute
	ComputeType *DataLakeAnalytics_ComputeType `json:"computeType,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool                         `json:"disableLocalAuth,omitempty"`
	Properties       *DataLakeAnalytics_Properties `json:"properties,omitempty"`

	// ResourceReference: ARM resource id of the underlying compute
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &DataLakeAnalytics{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (analytics *DataLakeAnalytics) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if analytics == nil {
		return nil, nil
	}
	result := &arm.DataLakeAnalytics{}

	// Set property "ComputeLocation":
	if analytics.ComputeLocation != nil {
		computeLocation := *analytics.ComputeLocation
		result.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	if analytics.ComputeType != nil {
		var temp arm.DataLakeAnalytics_ComputeType
		var temp1 string
		temp1 = string(*analytics.ComputeType)
		temp = arm.DataLakeAnalytics_ComputeType(temp1)
		result.ComputeType = temp
	}

	// Set property "Description":
	if analytics.Description != nil {
		description := *analytics.Description
		result.Description = &description
	}

	// Set property "DisableLocalAuth":
	if analytics.DisableLocalAuth != nil {
		disableLocalAuth := *analytics.DisableLocalAuth
		result.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if analytics.Properties != nil {
		properties_ARM, err := (*analytics.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*arm.DataLakeAnalytics_Properties)
		result.Properties = &properties
	}

	// Set property "ResourceId":
	if analytics.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*analytics.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (analytics *DataLakeAnalytics) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DataLakeAnalytics{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (analytics *DataLakeAnalytics) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DataLakeAnalytics)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DataLakeAnalytics, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		analytics.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp DataLakeAnalytics_ComputeType
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = DataLakeAnalytics_ComputeType(temp1)
	analytics.ComputeType = &temp

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		analytics.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		analytics.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 DataLakeAnalytics_Properties
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		analytics.Properties = &properties
	}

	// no assignment for property "ResourceReference"

	// No error
	return nil
}

// AssignProperties_From_DataLakeAnalytics populates our DataLakeAnalytics from the provided source DataLakeAnalytics
func (analytics *DataLakeAnalytics) AssignProperties_From_DataLakeAnalytics(source *storage.DataLakeAnalytics) error {

	// ComputeLocation
	analytics.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, dataLakeAnalytics_ComputeType_Values)
		analytics.ComputeType = &computeTypeTemp
	} else {
		analytics.ComputeType = nil
	}

	// Description
	analytics.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		analytics.DisableLocalAuth = &disableLocalAuth
	} else {
		analytics.DisableLocalAuth = nil
	}

	// Properties
	if source.Properties != nil {
		var property DataLakeAnalytics_Properties
		err := property.AssignProperties_From_DataLakeAnalytics_Properties(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DataLakeAnalytics_Properties() to populate field Properties")
		}
		analytics.Properties = &property
	} else {
		analytics.Properties = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		analytics.ResourceReference = &resourceReference
	} else {
		analytics.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DataLakeAnalytics populates the provided destination DataLakeAnalytics from our DataLakeAnalytics
func (analytics *DataLakeAnalytics) AssignProperties_To_DataLakeAnalytics(destination *storage.DataLakeAnalytics) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(analytics.ComputeLocation)

	// ComputeType
	if analytics.ComputeType != nil {
		computeType := string(*analytics.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(analytics.Description)

	// DisableLocalAuth
	if analytics.DisableLocalAuth != nil {
		disableLocalAuth := *analytics.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// Properties
	if analytics.Properties != nil {
		var property storage.DataLakeAnalytics_Properties
		err := analytics.Properties.AssignProperties_To_DataLakeAnalytics_Properties(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DataLakeAnalytics_Properties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ResourceReference
	if analytics.ResourceReference != nil {
		resourceReference := analytics.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DataLakeAnalytics_STATUS populates our DataLakeAnalytics from the provided source DataLakeAnalytics_STATUS
func (analytics *DataLakeAnalytics) Initialize_From_DataLakeAnalytics_STATUS(source *DataLakeAnalytics_STATUS) error {

	// ComputeLocation
	analytics.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := genruntime.ToEnum(string(*source.ComputeType), dataLakeAnalytics_ComputeType_Values)
		analytics.ComputeType = &computeType
	} else {
		analytics.ComputeType = nil
	}

	// Description
	analytics.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		analytics.DisableLocalAuth = &disableLocalAuth
	} else {
		analytics.DisableLocalAuth = nil
	}

	// Properties
	if source.Properties != nil {
		var property DataLakeAnalytics_Properties
		err := property.Initialize_From_DataLakeAnalytics_Properties_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DataLakeAnalytics_Properties_STATUS() to populate field Properties")
		}
		analytics.Properties = &property
	} else {
		analytics.Properties = nil
	}

	// ResourceReference
	if source.ResourceId != nil {
		resourceReference := genruntime.CreateResourceReferenceFromARMID(*source.ResourceId)
		analytics.ResourceReference = &resourceReference
	} else {
		analytics.ResourceReference = nil
	}

	// No error
	return nil
}

type DataLakeAnalytics_STATUS struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// ComputeType: The type of compute
	ComputeType *DataLakeAnalytics_ComputeType_STATUS `json:"computeType,omitempty"`

	// CreatedOn: The time at which the compute was created.
	CreatedOn *string `json:"createdOn,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// IsAttachedCompute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine
	// learning service provisioned it if false.
	IsAttachedCompute *bool `json:"isAttachedCompute,omitempty"`

	// ModifiedOn: The time at which the compute was last modified.
	ModifiedOn *string                              `json:"modifiedOn,omitempty"`
	Properties *DataLakeAnalytics_Properties_STATUS `json:"properties,omitempty"`

	// ProvisioningErrors: Errors during provisioning
	ProvisioningErrors []ErrorResponse_STATUS `json:"provisioningErrors,omitempty"`

	// ProvisioningState: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and
	// Failed.
	ProvisioningState *DataLakeAnalytics_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// ResourceId: ARM resource id of the underlying compute
	ResourceId *string `json:"resourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &DataLakeAnalytics_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (analytics *DataLakeAnalytics_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DataLakeAnalytics_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (analytics *DataLakeAnalytics_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DataLakeAnalytics_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DataLakeAnalytics_STATUS, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		analytics.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp DataLakeAnalytics_ComputeType_STATUS
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = DataLakeAnalytics_ComputeType_STATUS(temp1)
	analytics.ComputeType = &temp

	// Set property "CreatedOn":
	if typedInput.CreatedOn != nil {
		createdOn := *typedInput.CreatedOn
		analytics.CreatedOn = &createdOn
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		analytics.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		analytics.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "IsAttachedCompute":
	if typedInput.IsAttachedCompute != nil {
		isAttachedCompute := *typedInput.IsAttachedCompute
		analytics.IsAttachedCompute = &isAttachedCompute
	}

	// Set property "ModifiedOn":
	if typedInput.ModifiedOn != nil {
		modifiedOn := *typedInput.ModifiedOn
		analytics.ModifiedOn = &modifiedOn
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 DataLakeAnalytics_Properties_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		analytics.Properties = &properties
	}

	// Set property "ProvisioningErrors":
	for _, item := range typedInput.ProvisioningErrors {
		var item1 ErrorResponse_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		analytics.ProvisioningErrors = append(analytics.ProvisioningErrors, item1)
	}

	// Set property "ProvisioningState":
	if typedInput.ProvisioningState != nil {
		var provisioningStateTemp string
		provisioningStateTemp = string(*typedInput.ProvisioningState)
		provisioningState := DataLakeAnalytics_ProvisioningState_STATUS(provisioningStateTemp)
		analytics.ProvisioningState = &provisioningState
	}

	// Set property "ResourceId":
	if typedInput.ResourceId != nil {
		resourceId := *typedInput.ResourceId
		analytics.ResourceId = &resourceId
	}

	// No error
	return nil
}

// AssignProperties_From_DataLakeAnalytics_STATUS populates our DataLakeAnalytics_STATUS from the provided source DataLakeAnalytics_STATUS
func (analytics *DataLakeAnalytics_STATUS) AssignProperties_From_DataLakeAnalytics_STATUS(source *storage.DataLakeAnalytics_STATUS) error {

	// ComputeLocation
	analytics.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, dataLakeAnalytics_ComputeType_STATUS_Values)
		analytics.ComputeType = &computeTypeTemp
	} else {
		analytics.ComputeType = nil
	}

	// CreatedOn
	analytics.CreatedOn = genruntime.ClonePointerToString(source.CreatedOn)

	// Description
	analytics.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		analytics.DisableLocalAuth = &disableLocalAuth
	} else {
		analytics.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if source.IsAttachedCompute != nil {
		isAttachedCompute := *source.IsAttachedCompute
		analytics.IsAttachedCompute = &isAttachedCompute
	} else {
		analytics.IsAttachedCompute = nil
	}

	// ModifiedOn
	analytics.ModifiedOn = genruntime.ClonePointerToString(source.ModifiedOn)

	// Properties
	if source.Properties != nil {
		var property DataLakeAnalytics_Properties_STATUS
		err := property.AssignProperties_From_DataLakeAnalytics_Properties_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DataLakeAnalytics_Properties_STATUS() to populate field Properties")
		}
		analytics.Properties = &property
	} else {
		analytics.Properties = nil
	}

	// ProvisioningErrors
	if source.ProvisioningErrors != nil {
		provisioningErrorList := make([]ErrorResponse_STATUS, len(source.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range source.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError ErrorResponse_STATUS
			err := provisioningError.AssignProperties_From_ErrorResponse_STATUS(&provisioningErrorItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		analytics.ProvisioningErrors = provisioningErrorList
	} else {
		analytics.ProvisioningErrors = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, dataLakeAnalytics_ProvisioningState_STATUS_Values)
		analytics.ProvisioningState = &provisioningStateTemp
	} else {
		analytics.ProvisioningState = nil
	}

	// ResourceId
	analytics.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// No error
	return nil
}

// AssignProperties_To_DataLakeAnalytics_STATUS populates the provided destination DataLakeAnalytics_STATUS from our DataLakeAnalytics_STATUS
func (analytics *DataLakeAnalytics_STATUS) AssignProperties_To_DataLakeAnalytics_STATUS(destination *storage.DataLakeAnalytics_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(analytics.ComputeLocation)

	// ComputeType
	if analytics.ComputeType != nil {
		computeType := string(*analytics.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// CreatedOn
	destination.CreatedOn = genruntime.ClonePointerToString(analytics.CreatedOn)

	// Description
	destination.Description = genruntime.ClonePointerToString(analytics.Description)

	// DisableLocalAuth
	if analytics.DisableLocalAuth != nil {
		disableLocalAuth := *analytics.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if analytics.IsAttachedCompute != nil {
		isAttachedCompute := *analytics.IsAttachedCompute
		destination.IsAttachedCompute = &isAttachedCompute
	} else {
		destination.IsAttachedCompute = nil
	}

	// ModifiedOn
	destination.ModifiedOn = genruntime.ClonePointerToString(analytics.ModifiedOn)

	// Properties
	if analytics.Properties != nil {
		var property storage.DataLakeAnalytics_Properties_STATUS
		err := analytics.Properties.AssignProperties_To_DataLakeAnalytics_Properties_STATUS(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DataLakeAnalytics_Properties_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ProvisioningErrors
	if analytics.ProvisioningErrors != nil {
		provisioningErrorList := make([]storage.ErrorResponse_STATUS, len(analytics.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range analytics.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError storage.ErrorResponse_STATUS
			err := provisioningErrorItem.AssignProperties_To_ErrorResponse_STATUS(&provisioningError)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		destination.ProvisioningErrors = provisioningErrorList
	} else {
		destination.ProvisioningErrors = nil
	}

	// ProvisioningState
	if analytics.ProvisioningState != nil {
		provisioningState := string(*analytics.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(analytics.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type HDInsight struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// +kubebuilder:validation:Required
	// ComputeType: The type of compute
	ComputeType *HDInsight_ComputeType `json:"computeType,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// Properties: HDInsight compute properties
	Properties *HDInsightProperties `json:"properties,omitempty"`

	// ResourceReference: ARM resource id of the underlying compute
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &HDInsight{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (insight *HDInsight) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if insight == nil {
		return nil, nil
	}
	result := &arm.HDInsight{}

	// Set property "ComputeLocation":
	if insight.ComputeLocation != nil {
		computeLocation := *insight.ComputeLocation
		result.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	if insight.ComputeType != nil {
		var temp arm.HDInsight_ComputeType
		var temp1 string
		temp1 = string(*insight.ComputeType)
		temp = arm.HDInsight_ComputeType(temp1)
		result.ComputeType = temp
	}

	// Set property "Description":
	if insight.Description != nil {
		description := *insight.Description
		result.Description = &description
	}

	// Set property "DisableLocalAuth":
	if insight.DisableLocalAuth != nil {
		disableLocalAuth := *insight.DisableLocalAuth
		result.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if insight.Properties != nil {
		properties_ARM, err := (*insight.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*arm.HDInsightProperties)
		result.Properties = &properties
	}

	// Set property "ResourceId":
	if insight.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*insight.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (insight *HDInsight) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HDInsight{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (insight *HDInsight) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HDInsight)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HDInsight, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		insight.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp HDInsight_ComputeType
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = HDInsight_ComputeType(temp1)
	insight.ComputeType = &temp

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		insight.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		insight.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 HDInsightProperties
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		insight.Properties = &properties
	}

	// no assignment for property "ResourceReference"

	// No error
	return nil
}

// AssignProperties_From_HDInsight populates our HDInsight from the provided source HDInsight
func (insight *HDInsight) AssignProperties_From_HDInsight(source *storage.HDInsight) error {

	// ComputeLocation
	insight.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, hDInsight_ComputeType_Values)
		insight.ComputeType = &computeTypeTemp
	} else {
		insight.ComputeType = nil
	}

	// Description
	insight.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		insight.DisableLocalAuth = &disableLocalAuth
	} else {
		insight.DisableLocalAuth = nil
	}

	// Properties
	if source.Properties != nil {
		var property HDInsightProperties
		err := property.AssignProperties_From_HDInsightProperties(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HDInsightProperties() to populate field Properties")
		}
		insight.Properties = &property
	} else {
		insight.Properties = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		insight.ResourceReference = &resourceReference
	} else {
		insight.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_HDInsight populates the provided destination HDInsight from our HDInsight
func (insight *HDInsight) AssignProperties_To_HDInsight(destination *storage.HDInsight) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(insight.ComputeLocation)

	// ComputeType
	if insight.ComputeType != nil {
		computeType := string(*insight.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(insight.Description)

	// DisableLocalAuth
	if insight.DisableLocalAuth != nil {
		disableLocalAuth := *insight.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// Properties
	if insight.Properties != nil {
		var property storage.HDInsightProperties
		err := insight.Properties.AssignProperties_To_HDInsightProperties(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HDInsightProperties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ResourceReference
	if insight.ResourceReference != nil {
		resourceReference := insight.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_HDInsight_STATUS populates our HDInsight from the provided source HDInsight_STATUS
func (insight *HDInsight) Initialize_From_HDInsight_STATUS(source *HDInsight_STATUS) error {

	// ComputeLocation
	insight.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := genruntime.ToEnum(string(*source.ComputeType), hDInsight_ComputeType_Values)
		insight.ComputeType = &computeType
	} else {
		insight.ComputeType = nil
	}

	// Description
	insight.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		insight.DisableLocalAuth = &disableLocalAuth
	} else {
		insight.DisableLocalAuth = nil
	}

	// Properties
	if source.Properties != nil {
		var property HDInsightProperties
		err := property.Initialize_From_HDInsightProperties_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_HDInsightProperties_STATUS() to populate field Properties")
		}
		insight.Properties = &property
	} else {
		insight.Properties = nil
	}

	// ResourceReference
	if source.ResourceId != nil {
		resourceReference := genruntime.CreateResourceReferenceFromARMID(*source.ResourceId)
		insight.ResourceReference = &resourceReference
	} else {
		insight.ResourceReference = nil
	}

	// No error
	return nil
}

type HDInsight_STATUS struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// ComputeType: The type of compute
	ComputeType *HDInsight_ComputeType_STATUS `json:"computeType,omitempty"`

	// CreatedOn: The time at which the compute was created.
	CreatedOn *string `json:"createdOn,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// IsAttachedCompute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine
	// learning service provisioned it if false.
	IsAttachedCompute *bool `json:"isAttachedCompute,omitempty"`

	// ModifiedOn: The time at which the compute was last modified.
	ModifiedOn *string `json:"modifiedOn,omitempty"`

	// Properties: HDInsight compute properties
	Properties *HDInsightProperties_STATUS `json:"properties,omitempty"`

	// ProvisioningErrors: Errors during provisioning
	ProvisioningErrors []ErrorResponse_STATUS `json:"provisioningErrors,omitempty"`

	// ProvisioningState: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and
	// Failed.
	ProvisioningState *HDInsight_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// ResourceId: ARM resource id of the underlying compute
	ResourceId *string `json:"resourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &HDInsight_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (insight *HDInsight_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HDInsight_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (insight *HDInsight_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HDInsight_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HDInsight_STATUS, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		insight.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp HDInsight_ComputeType_STATUS
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = HDInsight_ComputeType_STATUS(temp1)
	insight.ComputeType = &temp

	// Set property "CreatedOn":
	if typedInput.CreatedOn != nil {
		createdOn := *typedInput.CreatedOn
		insight.CreatedOn = &createdOn
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		insight.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		insight.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "IsAttachedCompute":
	if typedInput.IsAttachedCompute != nil {
		isAttachedCompute := *typedInput.IsAttachedCompute
		insight.IsAttachedCompute = &isAttachedCompute
	}

	// Set property "ModifiedOn":
	if typedInput.ModifiedOn != nil {
		modifiedOn := *typedInput.ModifiedOn
		insight.ModifiedOn = &modifiedOn
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 HDInsightProperties_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		insight.Properties = &properties
	}

	// Set property "ProvisioningErrors":
	for _, item := range typedInput.ProvisioningErrors {
		var item1 ErrorResponse_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		insight.ProvisioningErrors = append(insight.ProvisioningErrors, item1)
	}

	// Set property "ProvisioningState":
	if typedInput.ProvisioningState != nil {
		var provisioningStateTemp string
		provisioningStateTemp = string(*typedInput.ProvisioningState)
		provisioningState := HDInsight_ProvisioningState_STATUS(provisioningStateTemp)
		insight.ProvisioningState = &provisioningState
	}

	// Set property "ResourceId":
	if typedInput.ResourceId != nil {
		resourceId := *typedInput.ResourceId
		insight.ResourceId = &resourceId
	}

	// No error
	return nil
}

// AssignProperties_From_HDInsight_STATUS populates our HDInsight_STATUS from the provided source HDInsight_STATUS
func (insight *HDInsight_STATUS) AssignProperties_From_HDInsight_STATUS(source *storage.HDInsight_STATUS) error {

	// ComputeLocation
	insight.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, hDInsight_ComputeType_STATUS_Values)
		insight.ComputeType = &computeTypeTemp
	} else {
		insight.ComputeType = nil
	}

	// CreatedOn
	insight.CreatedOn = genruntime.ClonePointerToString(source.CreatedOn)

	// Description
	insight.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		insight.DisableLocalAuth = &disableLocalAuth
	} else {
		insight.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if source.IsAttachedCompute != nil {
		isAttachedCompute := *source.IsAttachedCompute
		insight.IsAttachedCompute = &isAttachedCompute
	} else {
		insight.IsAttachedCompute = nil
	}

	// ModifiedOn
	insight.ModifiedOn = genruntime.ClonePointerToString(source.ModifiedOn)

	// Properties
	if source.Properties != nil {
		var property HDInsightProperties_STATUS
		err := property.AssignProperties_From_HDInsightProperties_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HDInsightProperties_STATUS() to populate field Properties")
		}
		insight.Properties = &property
	} else {
		insight.Properties = nil
	}

	// ProvisioningErrors
	if source.ProvisioningErrors != nil {
		provisioningErrorList := make([]ErrorResponse_STATUS, len(source.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range source.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError ErrorResponse_STATUS
			err := provisioningError.AssignProperties_From_ErrorResponse_STATUS(&provisioningErrorItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		insight.ProvisioningErrors = provisioningErrorList
	} else {
		insight.ProvisioningErrors = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, hDInsight_ProvisioningState_STATUS_Values)
		insight.ProvisioningState = &provisioningStateTemp
	} else {
		insight.ProvisioningState = nil
	}

	// ResourceId
	insight.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// No error
	return nil
}

// AssignProperties_To_HDInsight_STATUS populates the provided destination HDInsight_STATUS from our HDInsight_STATUS
func (insight *HDInsight_STATUS) AssignProperties_To_HDInsight_STATUS(destination *storage.HDInsight_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(insight.ComputeLocation)

	// ComputeType
	if insight.ComputeType != nil {
		computeType := string(*insight.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// CreatedOn
	destination.CreatedOn = genruntime.ClonePointerToString(insight.CreatedOn)

	// Description
	destination.Description = genruntime.ClonePointerToString(insight.Description)

	// DisableLocalAuth
	if insight.DisableLocalAuth != nil {
		disableLocalAuth := *insight.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if insight.IsAttachedCompute != nil {
		isAttachedCompute := *insight.IsAttachedCompute
		destination.IsAttachedCompute = &isAttachedCompute
	} else {
		destination.IsAttachedCompute = nil
	}

	// ModifiedOn
	destination.ModifiedOn = genruntime.ClonePointerToString(insight.ModifiedOn)

	// Properties
	if insight.Properties != nil {
		var property storage.HDInsightProperties_STATUS
		err := insight.Properties.AssignProperties_To_HDInsightProperties_STATUS(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HDInsightProperties_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ProvisioningErrors
	if insight.ProvisioningErrors != nil {
		provisioningErrorList := make([]storage.ErrorResponse_STATUS, len(insight.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range insight.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError storage.ErrorResponse_STATUS
			err := provisioningErrorItem.AssignProperties_To_ErrorResponse_STATUS(&provisioningError)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		destination.ProvisioningErrors = provisioningErrorList
	} else {
		destination.ProvisioningErrors = nil
	}

	// ProvisioningState
	if insight.ProvisioningState != nil {
		provisioningState := string(*insight.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(insight.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Kubernetes struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// +kubebuilder:validation:Required
	// ComputeType: The type of compute
	ComputeType *Kubernetes_ComputeType `json:"computeType,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// Properties: Properties of Kubernetes
	Properties *KubernetesProperties `json:"properties,omitempty"`

	// ResourceReference: ARM resource id of the underlying compute
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &Kubernetes{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (kubernetes *Kubernetes) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if kubernetes == nil {
		return nil, nil
	}
	result := &arm.Kubernetes{}

	// Set property "ComputeLocation":
	if kubernetes.ComputeLocation != nil {
		computeLocation := *kubernetes.ComputeLocation
		result.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	if kubernetes.ComputeType != nil {
		var temp arm.Kubernetes_ComputeType
		var temp1 string
		temp1 = string(*kubernetes.ComputeType)
		temp = arm.Kubernetes_ComputeType(temp1)
		result.ComputeType = temp
	}

	// Set property "Description":
	if kubernetes.Description != nil {
		description := *kubernetes.Description
		result.Description = &description
	}

	// Set property "DisableLocalAuth":
	if kubernetes.DisableLocalAuth != nil {
		disableLocalAuth := *kubernetes.DisableLocalAuth
		result.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if kubernetes.Properties != nil {
		properties_ARM, err := (*kubernetes.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*arm.KubernetesProperties)
		result.Properties = &properties
	}

	// Set property "ResourceId":
	if kubernetes.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*kubernetes.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (kubernetes *Kubernetes) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Kubernetes{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (kubernetes *Kubernetes) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Kubernetes)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Kubernetes, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		kubernetes.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp Kubernetes_ComputeType
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = Kubernetes_ComputeType(temp1)
	kubernetes.ComputeType = &temp

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		kubernetes.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		kubernetes.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 KubernetesProperties
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		kubernetes.Properties = &properties
	}

	// no assignment for property "ResourceReference"

	// No error
	return nil
}

// AssignProperties_From_Kubernetes populates our Kubernetes from the provided source Kubernetes
func (kubernetes *Kubernetes) AssignProperties_From_Kubernetes(source *storage.Kubernetes) error {

	// ComputeLocation
	kubernetes.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, kubernetes_ComputeType_Values)
		kubernetes.ComputeType = &computeTypeTemp
	} else {
		kubernetes.ComputeType = nil
	}

	// Description
	kubernetes.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		kubernetes.DisableLocalAuth = &disableLocalAuth
	} else {
		kubernetes.DisableLocalAuth = nil
	}

	// Properties
	if source.Properties != nil {
		var property KubernetesProperties
		err := property.AssignProperties_From_KubernetesProperties(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_KubernetesProperties() to populate field Properties")
		}
		kubernetes.Properties = &property
	} else {
		kubernetes.Properties = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		kubernetes.ResourceReference = &resourceReference
	} else {
		kubernetes.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Kubernetes populates the provided destination Kubernetes from our Kubernetes
func (kubernetes *Kubernetes) AssignProperties_To_Kubernetes(destination *storage.Kubernetes) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(kubernetes.ComputeLocation)

	// ComputeType
	if kubernetes.ComputeType != nil {
		computeType := string(*kubernetes.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(kubernetes.Description)

	// DisableLocalAuth
	if kubernetes.DisableLocalAuth != nil {
		disableLocalAuth := *kubernetes.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// Properties
	if kubernetes.Properties != nil {
		var property storage.KubernetesProperties
		err := kubernetes.Properties.AssignProperties_To_KubernetesProperties(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_KubernetesProperties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ResourceReference
	if kubernetes.ResourceReference != nil {
		resourceReference := kubernetes.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Kubernetes_STATUS populates our Kubernetes from the provided source Kubernetes_STATUS
func (kubernetes *Kubernetes) Initialize_From_Kubernetes_STATUS(source *Kubernetes_STATUS) error {

	// ComputeLocation
	kubernetes.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := genruntime.ToEnum(string(*source.ComputeType), kubernetes_ComputeType_Values)
		kubernetes.ComputeType = &computeType
	} else {
		kubernetes.ComputeType = nil
	}

	// Description
	kubernetes.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		kubernetes.DisableLocalAuth = &disableLocalAuth
	} else {
		kubernetes.DisableLocalAuth = nil
	}

	// Properties
	if source.Properties != nil {
		var property KubernetesProperties
		err := property.Initialize_From_KubernetesProperties_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_KubernetesProperties_STATUS() to populate field Properties")
		}
		kubernetes.Properties = &property
	} else {
		kubernetes.Properties = nil
	}

	// ResourceReference
	if source.ResourceId != nil {
		resourceReference := genruntime.CreateResourceReferenceFromARMID(*source.ResourceId)
		kubernetes.ResourceReference = &resourceReference
	} else {
		kubernetes.ResourceReference = nil
	}

	// No error
	return nil
}

type Kubernetes_STATUS struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// ComputeType: The type of compute
	ComputeType *Kubernetes_ComputeType_STATUS `json:"computeType,omitempty"`

	// CreatedOn: The time at which the compute was created.
	CreatedOn *string `json:"createdOn,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// IsAttachedCompute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine
	// learning service provisioned it if false.
	IsAttachedCompute *bool `json:"isAttachedCompute,omitempty"`

	// ModifiedOn: The time at which the compute was last modified.
	ModifiedOn *string `json:"modifiedOn,omitempty"`

	// Properties: Properties of Kubernetes
	Properties *KubernetesProperties_STATUS `json:"properties,omitempty"`

	// ProvisioningErrors: Errors during provisioning
	ProvisioningErrors []ErrorResponse_STATUS `json:"provisioningErrors,omitempty"`

	// ProvisioningState: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and
	// Failed.
	ProvisioningState *Kubernetes_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// ResourceId: ARM resource id of the underlying compute
	ResourceId *string `json:"resourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &Kubernetes_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (kubernetes *Kubernetes_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Kubernetes_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (kubernetes *Kubernetes_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Kubernetes_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Kubernetes_STATUS, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		kubernetes.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp Kubernetes_ComputeType_STATUS
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = Kubernetes_ComputeType_STATUS(temp1)
	kubernetes.ComputeType = &temp

	// Set property "CreatedOn":
	if typedInput.CreatedOn != nil {
		createdOn := *typedInput.CreatedOn
		kubernetes.CreatedOn = &createdOn
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		kubernetes.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		kubernetes.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "IsAttachedCompute":
	if typedInput.IsAttachedCompute != nil {
		isAttachedCompute := *typedInput.IsAttachedCompute
		kubernetes.IsAttachedCompute = &isAttachedCompute
	}

	// Set property "ModifiedOn":
	if typedInput.ModifiedOn != nil {
		modifiedOn := *typedInput.ModifiedOn
		kubernetes.ModifiedOn = &modifiedOn
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 KubernetesProperties_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		kubernetes.Properties = &properties
	}

	// Set property "ProvisioningErrors":
	for _, item := range typedInput.ProvisioningErrors {
		var item1 ErrorResponse_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		kubernetes.ProvisioningErrors = append(kubernetes.ProvisioningErrors, item1)
	}

	// Set property "ProvisioningState":
	if typedInput.ProvisioningState != nil {
		var provisioningStateTemp string
		provisioningStateTemp = string(*typedInput.ProvisioningState)
		provisioningState := Kubernetes_ProvisioningState_STATUS(provisioningStateTemp)
		kubernetes.ProvisioningState = &provisioningState
	}

	// Set property "ResourceId":
	if typedInput.ResourceId != nil {
		resourceId := *typedInput.ResourceId
		kubernetes.ResourceId = &resourceId
	}

	// No error
	return nil
}

// AssignProperties_From_Kubernetes_STATUS populates our Kubernetes_STATUS from the provided source Kubernetes_STATUS
func (kubernetes *Kubernetes_STATUS) AssignProperties_From_Kubernetes_STATUS(source *storage.Kubernetes_STATUS) error {

	// ComputeLocation
	kubernetes.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, kubernetes_ComputeType_STATUS_Values)
		kubernetes.ComputeType = &computeTypeTemp
	} else {
		kubernetes.ComputeType = nil
	}

	// CreatedOn
	kubernetes.CreatedOn = genruntime.ClonePointerToString(source.CreatedOn)

	// Description
	kubernetes.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		kubernetes.DisableLocalAuth = &disableLocalAuth
	} else {
		kubernetes.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if source.IsAttachedCompute != nil {
		isAttachedCompute := *source.IsAttachedCompute
		kubernetes.IsAttachedCompute = &isAttachedCompute
	} else {
		kubernetes.IsAttachedCompute = nil
	}

	// ModifiedOn
	kubernetes.ModifiedOn = genruntime.ClonePointerToString(source.ModifiedOn)

	// Properties
	if source.Properties != nil {
		var property KubernetesProperties_STATUS
		err := property.AssignProperties_From_KubernetesProperties_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_KubernetesProperties_STATUS() to populate field Properties")
		}
		kubernetes.Properties = &property
	} else {
		kubernetes.Properties = nil
	}

	// ProvisioningErrors
	if source.ProvisioningErrors != nil {
		provisioningErrorList := make([]ErrorResponse_STATUS, len(source.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range source.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError ErrorResponse_STATUS
			err := provisioningError.AssignProperties_From_ErrorResponse_STATUS(&provisioningErrorItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		kubernetes.ProvisioningErrors = provisioningErrorList
	} else {
		kubernetes.ProvisioningErrors = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, kubernetes_ProvisioningState_STATUS_Values)
		kubernetes.ProvisioningState = &provisioningStateTemp
	} else {
		kubernetes.ProvisioningState = nil
	}

	// ResourceId
	kubernetes.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// No error
	return nil
}

// AssignProperties_To_Kubernetes_STATUS populates the provided destination Kubernetes_STATUS from our Kubernetes_STATUS
func (kubernetes *Kubernetes_STATUS) AssignProperties_To_Kubernetes_STATUS(destination *storage.Kubernetes_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(kubernetes.ComputeLocation)

	// ComputeType
	if kubernetes.ComputeType != nil {
		computeType := string(*kubernetes.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// CreatedOn
	destination.CreatedOn = genruntime.ClonePointerToString(kubernetes.CreatedOn)

	// Description
	destination.Description = genruntime.ClonePointerToString(kubernetes.Description)

	// DisableLocalAuth
	if kubernetes.DisableLocalAuth != nil {
		disableLocalAuth := *kubernetes.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if kubernetes.IsAttachedCompute != nil {
		isAttachedCompute := *kubernetes.IsAttachedCompute
		destination.IsAttachedCompute = &isAttachedCompute
	} else {
		destination.IsAttachedCompute = nil
	}

	// ModifiedOn
	destination.ModifiedOn = genruntime.ClonePointerToString(kubernetes.ModifiedOn)

	// Properties
	if kubernetes.Properties != nil {
		var property storage.KubernetesProperties_STATUS
		err := kubernetes.Properties.AssignProperties_To_KubernetesProperties_STATUS(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_KubernetesProperties_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ProvisioningErrors
	if kubernetes.ProvisioningErrors != nil {
		provisioningErrorList := make([]storage.ErrorResponse_STATUS, len(kubernetes.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range kubernetes.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError storage.ErrorResponse_STATUS
			err := provisioningErrorItem.AssignProperties_To_ErrorResponse_STATUS(&provisioningError)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		destination.ProvisioningErrors = provisioningErrorList
	} else {
		destination.ProvisioningErrors = nil
	}

	// ProvisioningState
	if kubernetes.ProvisioningState != nil {
		provisioningState := string(*kubernetes.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(kubernetes.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type SynapseSpark struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// +kubebuilder:validation:Required
	// ComputeType: The type of compute
	ComputeType *SynapseSpark_ComputeType `json:"computeType,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool                    `json:"disableLocalAuth,omitempty"`
	Properties       *SynapseSpark_Properties `json:"properties,omitempty"`

	// ResourceReference: ARM resource id of the underlying compute
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &SynapseSpark{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (spark *SynapseSpark) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if spark == nil {
		return nil, nil
	}
	result := &arm.SynapseSpark{}

	// Set property "ComputeLocation":
	if spark.ComputeLocation != nil {
		computeLocation := *spark.ComputeLocation
		result.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	if spark.ComputeType != nil {
		var temp arm.SynapseSpark_ComputeType
		var temp1 string
		temp1 = string(*spark.ComputeType)
		temp = arm.SynapseSpark_ComputeType(temp1)
		result.ComputeType = temp
	}

	// Set property "Description":
	if spark.Description != nil {
		description := *spark.Description
		result.Description = &description
	}

	// Set property "DisableLocalAuth":
	if spark.DisableLocalAuth != nil {
		disableLocalAuth := *spark.DisableLocalAuth
		result.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if spark.Properties != nil {
		properties_ARM, err := (*spark.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*arm.SynapseSpark_Properties)
		result.Properties = &properties
	}

	// Set property "ResourceId":
	if spark.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*spark.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (spark *SynapseSpark) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SynapseSpark{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (spark *SynapseSpark) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SynapseSpark)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SynapseSpark, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		spark.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp SynapseSpark_ComputeType
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = SynapseSpark_ComputeType(temp1)
	spark.ComputeType = &temp

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		spark.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		spark.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 SynapseSpark_Properties
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		spark.Properties = &properties
	}

	// no assignment for property "ResourceReference"

	// No error
	return nil
}

// AssignProperties_From_SynapseSpark populates our SynapseSpark from the provided source SynapseSpark
func (spark *SynapseSpark) AssignProperties_From_SynapseSpark(source *storage.SynapseSpark) error {

	// ComputeLocation
	spark.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, synapseSpark_ComputeType_Values)
		spark.ComputeType = &computeTypeTemp
	} else {
		spark.ComputeType = nil
	}

	// Description
	spark.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		spark.DisableLocalAuth = &disableLocalAuth
	} else {
		spark.DisableLocalAuth = nil
	}

	// Properties
	if source.Properties != nil {
		var property SynapseSpark_Properties
		err := property.AssignProperties_From_SynapseSpark_Properties(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SynapseSpark_Properties() to populate field Properties")
		}
		spark.Properties = &property
	} else {
		spark.Properties = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		spark.ResourceReference = &resourceReference
	} else {
		spark.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SynapseSpark populates the provided destination SynapseSpark from our SynapseSpark
func (spark *SynapseSpark) AssignProperties_To_SynapseSpark(destination *storage.SynapseSpark) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(spark.ComputeLocation)

	// ComputeType
	if spark.ComputeType != nil {
		computeType := string(*spark.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(spark.Description)

	// DisableLocalAuth
	if spark.DisableLocalAuth != nil {
		disableLocalAuth := *spark.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// Properties
	if spark.Properties != nil {
		var property storage.SynapseSpark_Properties
		err := spark.Properties.AssignProperties_To_SynapseSpark_Properties(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SynapseSpark_Properties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ResourceReference
	if spark.ResourceReference != nil {
		resourceReference := spark.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_SynapseSpark_STATUS populates our SynapseSpark from the provided source SynapseSpark_STATUS
func (spark *SynapseSpark) Initialize_From_SynapseSpark_STATUS(source *SynapseSpark_STATUS) error {

	// ComputeLocation
	spark.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := genruntime.ToEnum(string(*source.ComputeType), synapseSpark_ComputeType_Values)
		spark.ComputeType = &computeType
	} else {
		spark.ComputeType = nil
	}

	// Description
	spark.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		spark.DisableLocalAuth = &disableLocalAuth
	} else {
		spark.DisableLocalAuth = nil
	}

	// Properties
	if source.Properties != nil {
		var property SynapseSpark_Properties
		err := property.Initialize_From_SynapseSpark_Properties_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SynapseSpark_Properties_STATUS() to populate field Properties")
		}
		spark.Properties = &property
	} else {
		spark.Properties = nil
	}

	// ResourceReference
	if source.ResourceId != nil {
		resourceReference := genruntime.CreateResourceReferenceFromARMID(*source.ResourceId)
		spark.ResourceReference = &resourceReference
	} else {
		spark.ResourceReference = nil
	}

	// No error
	return nil
}

type SynapseSpark_STATUS struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// ComputeType: The type of compute
	ComputeType *SynapseSpark_ComputeType_STATUS `json:"computeType,omitempty"`

	// CreatedOn: The time at which the compute was created.
	CreatedOn *string `json:"createdOn,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// IsAttachedCompute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine
	// learning service provisioned it if false.
	IsAttachedCompute *bool `json:"isAttachedCompute,omitempty"`

	// ModifiedOn: The time at which the compute was last modified.
	ModifiedOn *string                         `json:"modifiedOn,omitempty"`
	Properties *SynapseSpark_Properties_STATUS `json:"properties,omitempty"`

	// ProvisioningErrors: Errors during provisioning
	ProvisioningErrors []ErrorResponse_STATUS `json:"provisioningErrors,omitempty"`

	// ProvisioningState: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and
	// Failed.
	ProvisioningState *SynapseSpark_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// ResourceId: ARM resource id of the underlying compute
	ResourceId *string `json:"resourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &SynapseSpark_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (spark *SynapseSpark_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SynapseSpark_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (spark *SynapseSpark_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SynapseSpark_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SynapseSpark_STATUS, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		spark.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp SynapseSpark_ComputeType_STATUS
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = SynapseSpark_ComputeType_STATUS(temp1)
	spark.ComputeType = &temp

	// Set property "CreatedOn":
	if typedInput.CreatedOn != nil {
		createdOn := *typedInput.CreatedOn
		spark.CreatedOn = &createdOn
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		spark.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		spark.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "IsAttachedCompute":
	if typedInput.IsAttachedCompute != nil {
		isAttachedCompute := *typedInput.IsAttachedCompute
		spark.IsAttachedCompute = &isAttachedCompute
	}

	// Set property "ModifiedOn":
	if typedInput.ModifiedOn != nil {
		modifiedOn := *typedInput.ModifiedOn
		spark.ModifiedOn = &modifiedOn
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 SynapseSpark_Properties_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		spark.Properties = &properties
	}

	// Set property "ProvisioningErrors":
	for _, item := range typedInput.ProvisioningErrors {
		var item1 ErrorResponse_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		spark.ProvisioningErrors = append(spark.ProvisioningErrors, item1)
	}

	// Set property "ProvisioningState":
	if typedInput.ProvisioningState != nil {
		var provisioningStateTemp string
		provisioningStateTemp = string(*typedInput.ProvisioningState)
		provisioningState := SynapseSpark_ProvisioningState_STATUS(provisioningStateTemp)
		spark.ProvisioningState = &provisioningState
	}

	// Set property "ResourceId":
	if typedInput.ResourceId != nil {
		resourceId := *typedInput.ResourceId
		spark.ResourceId = &resourceId
	}

	// No error
	return nil
}

// AssignProperties_From_SynapseSpark_STATUS populates our SynapseSpark_STATUS from the provided source SynapseSpark_STATUS
func (spark *SynapseSpark_STATUS) AssignProperties_From_SynapseSpark_STATUS(source *storage.SynapseSpark_STATUS) error {

	// ComputeLocation
	spark.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, synapseSpark_ComputeType_STATUS_Values)
		spark.ComputeType = &computeTypeTemp
	} else {
		spark.ComputeType = nil
	}

	// CreatedOn
	spark.CreatedOn = genruntime.ClonePointerToString(source.CreatedOn)

	// Description
	spark.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		spark.DisableLocalAuth = &disableLocalAuth
	} else {
		spark.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if source.IsAttachedCompute != nil {
		isAttachedCompute := *source.IsAttachedCompute
		spark.IsAttachedCompute = &isAttachedCompute
	} else {
		spark.IsAttachedCompute = nil
	}

	// ModifiedOn
	spark.ModifiedOn = genruntime.ClonePointerToString(source.ModifiedOn)

	// Properties
	if source.Properties != nil {
		var property SynapseSpark_Properties_STATUS
		err := property.AssignProperties_From_SynapseSpark_Properties_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SynapseSpark_Properties_STATUS() to populate field Properties")
		}
		spark.Properties = &property
	} else {
		spark.Properties = nil
	}

	// ProvisioningErrors
	if source.ProvisioningErrors != nil {
		provisioningErrorList := make([]ErrorResponse_STATUS, len(source.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range source.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError ErrorResponse_STATUS
			err := provisioningError.AssignProperties_From_ErrorResponse_STATUS(&provisioningErrorItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		spark.ProvisioningErrors = provisioningErrorList
	} else {
		spark.ProvisioningErrors = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, synapseSpark_ProvisioningState_STATUS_Values)
		spark.ProvisioningState = &provisioningStateTemp
	} else {
		spark.ProvisioningState = nil
	}

	// ResourceId
	spark.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// No error
	return nil
}

// AssignProperties_To_SynapseSpark_STATUS populates the provided destination SynapseSpark_STATUS from our SynapseSpark_STATUS
func (spark *SynapseSpark_STATUS) AssignProperties_To_SynapseSpark_STATUS(destination *storage.SynapseSpark_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(spark.ComputeLocation)

	// ComputeType
	if spark.ComputeType != nil {
		computeType := string(*spark.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// CreatedOn
	destination.CreatedOn = genruntime.ClonePointerToString(spark.CreatedOn)

	// Description
	destination.Description = genruntime.ClonePointerToString(spark.Description)

	// DisableLocalAuth
	if spark.DisableLocalAuth != nil {
		disableLocalAuth := *spark.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if spark.IsAttachedCompute != nil {
		isAttachedCompute := *spark.IsAttachedCompute
		destination.IsAttachedCompute = &isAttachedCompute
	} else {
		destination.IsAttachedCompute = nil
	}

	// ModifiedOn
	destination.ModifiedOn = genruntime.ClonePointerToString(spark.ModifiedOn)

	// Properties
	if spark.Properties != nil {
		var property storage.SynapseSpark_Properties_STATUS
		err := spark.Properties.AssignProperties_To_SynapseSpark_Properties_STATUS(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SynapseSpark_Properties_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ProvisioningErrors
	if spark.ProvisioningErrors != nil {
		provisioningErrorList := make([]storage.ErrorResponse_STATUS, len(spark.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range spark.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError storage.ErrorResponse_STATUS
			err := provisioningErrorItem.AssignProperties_To_ErrorResponse_STATUS(&provisioningError)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		destination.ProvisioningErrors = provisioningErrorList
	} else {
		destination.ProvisioningErrors = nil
	}

	// ProvisioningState
	if spark.ProvisioningState != nil {
		provisioningState := string(*spark.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(spark.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachine struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// +kubebuilder:validation:Required
	// ComputeType: The type of compute
	ComputeType *VirtualMachine_ComputeType `json:"computeType,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool                      `json:"disableLocalAuth,omitempty"`
	Properties       *VirtualMachine_Properties `json:"properties,omitempty"`

	// ResourceReference: ARM resource id of the underlying compute
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachine{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (machine *VirtualMachine) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if machine == nil {
		return nil, nil
	}
	result := &arm.VirtualMachine{}

	// Set property "ComputeLocation":
	if machine.ComputeLocation != nil {
		computeLocation := *machine.ComputeLocation
		result.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	if machine.ComputeType != nil {
		var temp arm.VirtualMachine_ComputeType
		var temp1 string
		temp1 = string(*machine.ComputeType)
		temp = arm.VirtualMachine_ComputeType(temp1)
		result.ComputeType = temp
	}

	// Set property "Description":
	if machine.Description != nil {
		description := *machine.Description
		result.Description = &description
	}

	// Set property "DisableLocalAuth":
	if machine.DisableLocalAuth != nil {
		disableLocalAuth := *machine.DisableLocalAuth
		result.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if machine.Properties != nil {
		properties_ARM, err := (*machine.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*arm.VirtualMachine_Properties)
		result.Properties = &properties
	}

	// Set property "ResourceId":
	if machine.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*machine.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (machine *VirtualMachine) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachine{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (machine *VirtualMachine) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachine)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachine, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		machine.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp VirtualMachine_ComputeType
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = VirtualMachine_ComputeType(temp1)
	machine.ComputeType = &temp

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		machine.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		machine.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 VirtualMachine_Properties
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		machine.Properties = &properties
	}

	// no assignment for property "ResourceReference"

	// No error
	return nil
}

// AssignProperties_From_VirtualMachine populates our VirtualMachine from the provided source VirtualMachine
func (machine *VirtualMachine) AssignProperties_From_VirtualMachine(source *storage.VirtualMachine) error {

	// ComputeLocation
	machine.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, virtualMachine_ComputeType_Values)
		machine.ComputeType = &computeTypeTemp
	} else {
		machine.ComputeType = nil
	}

	// Description
	machine.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		machine.DisableLocalAuth = &disableLocalAuth
	} else {
		machine.DisableLocalAuth = nil
	}

	// Properties
	if source.Properties != nil {
		var property VirtualMachine_Properties
		err := property.AssignProperties_From_VirtualMachine_Properties(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachine_Properties() to populate field Properties")
		}
		machine.Properties = &property
	} else {
		machine.Properties = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		machine.ResourceReference = &resourceReference
	} else {
		machine.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachine populates the provided destination VirtualMachine from our VirtualMachine
func (machine *VirtualMachine) AssignProperties_To_VirtualMachine(destination *storage.VirtualMachine) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(machine.ComputeLocation)

	// ComputeType
	if machine.ComputeType != nil {
		computeType := string(*machine.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(machine.Description)

	// DisableLocalAuth
	if machine.DisableLocalAuth != nil {
		disableLocalAuth := *machine.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// Properties
	if machine.Properties != nil {
		var property storage.VirtualMachine_Properties
		err := machine.Properties.AssignProperties_To_VirtualMachine_Properties(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachine_Properties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ResourceReference
	if machine.ResourceReference != nil {
		resourceReference := machine.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualMachine_STATUS populates our VirtualMachine from the provided source VirtualMachine_STATUS
func (machine *VirtualMachine) Initialize_From_VirtualMachine_STATUS(source *VirtualMachine_STATUS) error {

	// ComputeLocation
	machine.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := genruntime.ToEnum(string(*source.ComputeType), virtualMachine_ComputeType_Values)
		machine.ComputeType = &computeType
	} else {
		machine.ComputeType = nil
	}

	// Description
	machine.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		machine.DisableLocalAuth = &disableLocalAuth
	} else {
		machine.DisableLocalAuth = nil
	}

	// Properties
	if source.Properties != nil {
		var property VirtualMachine_Properties
		err := property.Initialize_From_VirtualMachine_Properties_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_VirtualMachine_Properties_STATUS() to populate field Properties")
		}
		machine.Properties = &property
	} else {
		machine.Properties = nil
	}

	// ResourceReference
	if source.ResourceId != nil {
		resourceReference := genruntime.CreateResourceReferenceFromARMID(*source.ResourceId)
		machine.ResourceReference = &resourceReference
	} else {
		machine.ResourceReference = nil
	}

	// No error
	return nil
}

type VirtualMachine_STATUS struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// ComputeType: The type of compute
	ComputeType *VirtualMachine_ComputeType_STATUS `json:"computeType,omitempty"`

	// CreatedOn: The time at which the compute was created.
	CreatedOn *string `json:"createdOn,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// IsAttachedCompute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine
	// learning service provisioned it if false.
	IsAttachedCompute *bool `json:"isAttachedCompute,omitempty"`

	// ModifiedOn: The time at which the compute was last modified.
	ModifiedOn *string                           `json:"modifiedOn,omitempty"`
	Properties *VirtualMachine_Properties_STATUS `json:"properties,omitempty"`

	// ProvisioningErrors: Errors during provisioning
	ProvisioningErrors []ErrorResponse_STATUS `json:"provisioningErrors,omitempty"`

	// ProvisioningState: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and
	// Failed.
	ProvisioningState *VirtualMachine_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// ResourceId: ARM resource id of the underlying compute
	ResourceId *string `json:"resourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachine_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (machine *VirtualMachine_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachine_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (machine *VirtualMachine_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachine_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachine_STATUS, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		machine.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp VirtualMachine_ComputeType_STATUS
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = VirtualMachine_ComputeType_STATUS(temp1)
	machine.ComputeType = &temp

	// Set property "CreatedOn":
	if typedInput.CreatedOn != nil {
		createdOn := *typedInput.CreatedOn
		machine.CreatedOn = &createdOn
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		machine.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		machine.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "IsAttachedCompute":
	if typedInput.IsAttachedCompute != nil {
		isAttachedCompute := *typedInput.IsAttachedCompute
		machine.IsAttachedCompute = &isAttachedCompute
	}

	// Set property "ModifiedOn":
	if typedInput.ModifiedOn != nil {
		modifiedOn := *typedInput.ModifiedOn
		machine.ModifiedOn = &modifiedOn
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 VirtualMachine_Properties_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		machine.Properties = &properties
	}

	// Set property "ProvisioningErrors":
	for _, item := range typedInput.ProvisioningErrors {
		var item1 ErrorResponse_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		machine.ProvisioningErrors = append(machine.ProvisioningErrors, item1)
	}

	// Set property "ProvisioningState":
	if typedInput.ProvisioningState != nil {
		var provisioningStateTemp string
		provisioningStateTemp = string(*typedInput.ProvisioningState)
		provisioningState := VirtualMachine_ProvisioningState_STATUS(provisioningStateTemp)
		machine.ProvisioningState = &provisioningState
	}

	// Set property "ResourceId":
	if typedInput.ResourceId != nil {
		resourceId := *typedInput.ResourceId
		machine.ResourceId = &resourceId
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachine_STATUS populates our VirtualMachine_STATUS from the provided source VirtualMachine_STATUS
func (machine *VirtualMachine_STATUS) AssignProperties_From_VirtualMachine_STATUS(source *storage.VirtualMachine_STATUS) error {

	// ComputeLocation
	machine.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, virtualMachine_ComputeType_STATUS_Values)
		machine.ComputeType = &computeTypeTemp
	} else {
		machine.ComputeType = nil
	}

	// CreatedOn
	machine.CreatedOn = genruntime.ClonePointerToString(source.CreatedOn)

	// Description
	machine.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		machine.DisableLocalAuth = &disableLocalAuth
	} else {
		machine.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if source.IsAttachedCompute != nil {
		isAttachedCompute := *source.IsAttachedCompute
		machine.IsAttachedCompute = &isAttachedCompute
	} else {
		machine.IsAttachedCompute = nil
	}

	// ModifiedOn
	machine.ModifiedOn = genruntime.ClonePointerToString(source.ModifiedOn)

	// Properties
	if source.Properties != nil {
		var property VirtualMachine_Properties_STATUS
		err := property.AssignProperties_From_VirtualMachine_Properties_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachine_Properties_STATUS() to populate field Properties")
		}
		machine.Properties = &property
	} else {
		machine.Properties = nil
	}

	// ProvisioningErrors
	if source.ProvisioningErrors != nil {
		provisioningErrorList := make([]ErrorResponse_STATUS, len(source.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range source.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError ErrorResponse_STATUS
			err := provisioningError.AssignProperties_From_ErrorResponse_STATUS(&provisioningErrorItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		machine.ProvisioningErrors = provisioningErrorList
	} else {
		machine.ProvisioningErrors = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, virtualMachine_ProvisioningState_STATUS_Values)
		machine.ProvisioningState = &provisioningStateTemp
	} else {
		machine.ProvisioningState = nil
	}

	// ResourceId
	machine.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachine_STATUS populates the provided destination VirtualMachine_STATUS from our VirtualMachine_STATUS
func (machine *VirtualMachine_STATUS) AssignProperties_To_VirtualMachine_STATUS(destination *storage.VirtualMachine_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(machine.ComputeLocation)

	// ComputeType
	if machine.ComputeType != nil {
		computeType := string(*machine.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// CreatedOn
	destination.CreatedOn = genruntime.ClonePointerToString(machine.CreatedOn)

	// Description
	destination.Description = genruntime.ClonePointerToString(machine.Description)

	// DisableLocalAuth
	if machine.DisableLocalAuth != nil {
		disableLocalAuth := *machine.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if machine.IsAttachedCompute != nil {
		isAttachedCompute := *machine.IsAttachedCompute
		destination.IsAttachedCompute = &isAttachedCompute
	} else {
		destination.IsAttachedCompute = nil
	}

	// ModifiedOn
	destination.ModifiedOn = genruntime.ClonePointerToString(machine.ModifiedOn)

	// Properties
	if machine.Properties != nil {
		var property storage.VirtualMachine_Properties_STATUS
		err := machine.Properties.AssignProperties_To_VirtualMachine_Properties_STATUS(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachine_Properties_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ProvisioningErrors
	if machine.ProvisioningErrors != nil {
		provisioningErrorList := make([]storage.ErrorResponse_STATUS, len(machine.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range machine.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError storage.ErrorResponse_STATUS
			err := provisioningErrorItem.AssignProperties_To_ErrorResponse_STATUS(&provisioningError)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		destination.ProvisioningErrors = provisioningErrorList
	} else {
		destination.ProvisioningErrors = nil
	}

	// ProvisioningState
	if machine.ProvisioningState != nil {
		provisioningState := string(*machine.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(machine.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"AKS"}
type AKS_ComputeType string

const AKS_ComputeType_AKS = AKS_ComputeType("AKS")

// Mapping from string to AKS_ComputeType
var aKS_ComputeType_Values = map[string]AKS_ComputeType{
	"aks": AKS_ComputeType_AKS,
}

type AKS_ComputeType_STATUS string

const AKS_ComputeType_STATUS_AKS = AKS_ComputeType_STATUS("AKS")

// Mapping from string to AKS_ComputeType_STATUS
var aKS_ComputeType_STATUS_Values = map[string]AKS_ComputeType_STATUS{
	"aks": AKS_ComputeType_STATUS_AKS,
}

type AKS_Properties struct {
	// +kubebuilder:validation:Minimum=0
	// AgentCount: Number of agents
	AgentCount *int `json:"agentCount,omitempty"`

	// AgentVmSize: Agent virtual machine size
	AgentVmSize *string `json:"agentVmSize,omitempty"`

	// AksNetworkingConfiguration: AKS networking configuration for vnet
	AksNetworkingConfiguration *AksNetworkingConfiguration `json:"aksNetworkingConfiguration,omitempty"`

	// ClusterFqdn: Cluster full qualified domain name
	ClusterFqdn *string `json:"clusterFqdn,omitempty"`

	// ClusterPurpose: Intended usage of the cluster
	ClusterPurpose *AKS_Properties_ClusterPurpose `json:"clusterPurpose,omitempty"`

	// LoadBalancerSubnetReference: Load Balancer Subnet
	LoadBalancerSubnetReference *genruntime.ResourceReference `armReference:"LoadBalancerSubnet" json:"loadBalancerSubnetReference,omitempty"`

	// LoadBalancerType: Load Balancer Type
	LoadBalancerType *AKS_Properties_LoadBalancerType `json:"loadBalancerType,omitempty"`

	// SslConfiguration: SSL configuration
	SslConfiguration *SslConfiguration `json:"sslConfiguration,omitempty"`
}

var _ genruntime.ARMTransformer = &AKS_Properties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *AKS_Properties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.AKS_Properties{}

	// Set property "AgentCount":
	if properties.AgentCount != nil {
		agentCount := *properties.AgentCount
		result.AgentCount = &agentCount
	}

	// Set property "AgentVmSize":
	if properties.AgentVmSize != nil {
		agentVmSize := *properties.AgentVmSize
		result.AgentVmSize = &agentVmSize
	}

	// Set property "AksNetworkingConfiguration":
	if properties.AksNetworkingConfiguration != nil {
		aksNetworkingConfiguration_ARM, err := (*properties.AksNetworkingConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		aksNetworkingConfiguration := *aksNetworkingConfiguration_ARM.(*arm.AksNetworkingConfiguration)
		result.AksNetworkingConfiguration = &aksNetworkingConfiguration
	}

	// Set property "ClusterFqdn":
	if properties.ClusterFqdn != nil {
		clusterFqdn := *properties.ClusterFqdn
		result.ClusterFqdn = &clusterFqdn
	}

	// Set property "ClusterPurpose":
	if properties.ClusterPurpose != nil {
		var temp string
		temp = string(*properties.ClusterPurpose)
		clusterPurpose := arm.AKS_Properties_ClusterPurpose(temp)
		result.ClusterPurpose = &clusterPurpose
	}

	// Set property "LoadBalancerSubnet":
	if properties.LoadBalancerSubnetReference != nil {
		loadBalancerSubnetReferenceARMID, err := resolved.ResolvedReferences.Lookup(*properties.LoadBalancerSubnetReference)
		if err != nil {
			return nil, err
		}
		loadBalancerSubnetReference := loadBalancerSubnetReferenceARMID
		result.LoadBalancerSubnet = &loadBalancerSubnetReference
	}

	// Set property "LoadBalancerType":
	if properties.LoadBalancerType != nil {
		var temp string
		temp = string(*properties.LoadBalancerType)
		loadBalancerType := arm.AKS_Properties_LoadBalancerType(temp)
		result.LoadBalancerType = &loadBalancerType
	}

	// Set property "SslConfiguration":
	if properties.SslConfiguration != nil {
		sslConfiguration_ARM, err := (*properties.SslConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sslConfiguration := *sslConfiguration_ARM.(*arm.SslConfiguration)
		result.SslConfiguration = &sslConfiguration
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *AKS_Properties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AKS_Properties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *AKS_Properties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AKS_Properties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AKS_Properties, got %T", armInput)
	}

	// Set property "AgentCount":
	if typedInput.AgentCount != nil {
		agentCount := *typedInput.AgentCount
		properties.AgentCount = &agentCount
	}

	// Set property "AgentVmSize":
	if typedInput.AgentVmSize != nil {
		agentVmSize := *typedInput.AgentVmSize
		properties.AgentVmSize = &agentVmSize
	}

	// Set property "AksNetworkingConfiguration":
	if typedInput.AksNetworkingConfiguration != nil {
		var aksNetworkingConfiguration1 AksNetworkingConfiguration
		err := aksNetworkingConfiguration1.PopulateFromARM(owner, *typedInput.AksNetworkingConfiguration)
		if err != nil {
			return err
		}
		aksNetworkingConfiguration := aksNetworkingConfiguration1
		properties.AksNetworkingConfiguration = &aksNetworkingConfiguration
	}

	// Set property "ClusterFqdn":
	if typedInput.ClusterFqdn != nil {
		clusterFqdn := *typedInput.ClusterFqdn
		properties.ClusterFqdn = &clusterFqdn
	}

	// Set property "ClusterPurpose":
	if typedInput.ClusterPurpose != nil {
		var temp string
		temp = string(*typedInput.ClusterPurpose)
		clusterPurpose := AKS_Properties_ClusterPurpose(temp)
		properties.ClusterPurpose = &clusterPurpose
	}

	// no assignment for property "LoadBalancerSubnetReference"

	// Set property "LoadBalancerType":
	if typedInput.LoadBalancerType != nil {
		var temp string
		temp = string(*typedInput.LoadBalancerType)
		loadBalancerType := AKS_Properties_LoadBalancerType(temp)
		properties.LoadBalancerType = &loadBalancerType
	}

	// Set property "SslConfiguration":
	if typedInput.SslConfiguration != nil {
		var sslConfiguration1 SslConfiguration
		err := sslConfiguration1.PopulateFromARM(owner, *typedInput.SslConfiguration)
		if err != nil {
			return err
		}
		sslConfiguration := sslConfiguration1
		properties.SslConfiguration = &sslConfiguration
	}

	// No error
	return nil
}

// AssignProperties_From_AKS_Properties populates our AKS_Properties from the provided source AKS_Properties
func (properties *AKS_Properties) AssignProperties_From_AKS_Properties(source *storage.AKS_Properties) error {

	// AgentCount
	if source.AgentCount != nil {
		agentCount := *source.AgentCount
		properties.AgentCount = &agentCount
	} else {
		properties.AgentCount = nil
	}

	// AgentVmSize
	properties.AgentVmSize = genruntime.ClonePointerToString(source.AgentVmSize)

	// AksNetworkingConfiguration
	if source.AksNetworkingConfiguration != nil {
		var aksNetworkingConfiguration AksNetworkingConfiguration
		err := aksNetworkingConfiguration.AssignProperties_From_AksNetworkingConfiguration(source.AksNetworkingConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AksNetworkingConfiguration() to populate field AksNetworkingConfiguration")
		}
		properties.AksNetworkingConfiguration = &aksNetworkingConfiguration
	} else {
		properties.AksNetworkingConfiguration = nil
	}

	// ClusterFqdn
	properties.ClusterFqdn = genruntime.ClonePointerToString(source.ClusterFqdn)

	// ClusterPurpose
	if source.ClusterPurpose != nil {
		clusterPurpose := *source.ClusterPurpose
		clusterPurposeTemp := genruntime.ToEnum(clusterPurpose, aKS_Properties_ClusterPurpose_Values)
		properties.ClusterPurpose = &clusterPurposeTemp
	} else {
		properties.ClusterPurpose = nil
	}

	// LoadBalancerSubnetReference
	if source.LoadBalancerSubnetReference != nil {
		loadBalancerSubnetReference := source.LoadBalancerSubnetReference.Copy()
		properties.LoadBalancerSubnetReference = &loadBalancerSubnetReference
	} else {
		properties.LoadBalancerSubnetReference = nil
	}

	// LoadBalancerType
	if source.LoadBalancerType != nil {
		loadBalancerType := *source.LoadBalancerType
		loadBalancerTypeTemp := genruntime.ToEnum(loadBalancerType, aKS_Properties_LoadBalancerType_Values)
		properties.LoadBalancerType = &loadBalancerTypeTemp
	} else {
		properties.LoadBalancerType = nil
	}

	// SslConfiguration
	if source.SslConfiguration != nil {
		var sslConfiguration SslConfiguration
		err := sslConfiguration.AssignProperties_From_SslConfiguration(source.SslConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SslConfiguration() to populate field SslConfiguration")
		}
		properties.SslConfiguration = &sslConfiguration
	} else {
		properties.SslConfiguration = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AKS_Properties populates the provided destination AKS_Properties from our AKS_Properties
func (properties *AKS_Properties) AssignProperties_To_AKS_Properties(destination *storage.AKS_Properties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AgentCount
	if properties.AgentCount != nil {
		agentCount := *properties.AgentCount
		destination.AgentCount = &agentCount
	} else {
		destination.AgentCount = nil
	}

	// AgentVmSize
	destination.AgentVmSize = genruntime.ClonePointerToString(properties.AgentVmSize)

	// AksNetworkingConfiguration
	if properties.AksNetworkingConfiguration != nil {
		var aksNetworkingConfiguration storage.AksNetworkingConfiguration
		err := properties.AksNetworkingConfiguration.AssignProperties_To_AksNetworkingConfiguration(&aksNetworkingConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AksNetworkingConfiguration() to populate field AksNetworkingConfiguration")
		}
		destination.AksNetworkingConfiguration = &aksNetworkingConfiguration
	} else {
		destination.AksNetworkingConfiguration = nil
	}

	// ClusterFqdn
	destination.ClusterFqdn = genruntime.ClonePointerToString(properties.ClusterFqdn)

	// ClusterPurpose
	if properties.ClusterPurpose != nil {
		clusterPurpose := string(*properties.ClusterPurpose)
		destination.ClusterPurpose = &clusterPurpose
	} else {
		destination.ClusterPurpose = nil
	}

	// LoadBalancerSubnetReference
	if properties.LoadBalancerSubnetReference != nil {
		loadBalancerSubnetReference := properties.LoadBalancerSubnetReference.Copy()
		destination.LoadBalancerSubnetReference = &loadBalancerSubnetReference
	} else {
		destination.LoadBalancerSubnetReference = nil
	}

	// LoadBalancerType
	if properties.LoadBalancerType != nil {
		loadBalancerType := string(*properties.LoadBalancerType)
		destination.LoadBalancerType = &loadBalancerType
	} else {
		destination.LoadBalancerType = nil
	}

	// SslConfiguration
	if properties.SslConfiguration != nil {
		var sslConfiguration storage.SslConfiguration
		err := properties.SslConfiguration.AssignProperties_To_SslConfiguration(&sslConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SslConfiguration() to populate field SslConfiguration")
		}
		destination.SslConfiguration = &sslConfiguration
	} else {
		destination.SslConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AKS_Properties_STATUS populates our AKS_Properties from the provided source AKS_Properties_STATUS
func (properties *AKS_Properties) Initialize_From_AKS_Properties_STATUS(source *AKS_Properties_STATUS) error {

	// AgentCount
	if source.AgentCount != nil {
		agentCount := *source.AgentCount
		properties.AgentCount = &agentCount
	} else {
		properties.AgentCount = nil
	}

	// AgentVmSize
	properties.AgentVmSize = genruntime.ClonePointerToString(source.AgentVmSize)

	// AksNetworkingConfiguration
	if source.AksNetworkingConfiguration != nil {
		var aksNetworkingConfiguration AksNetworkingConfiguration
		err := aksNetworkingConfiguration.Initialize_From_AksNetworkingConfiguration_STATUS(source.AksNetworkingConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_AksNetworkingConfiguration_STATUS() to populate field AksNetworkingConfiguration")
		}
		properties.AksNetworkingConfiguration = &aksNetworkingConfiguration
	} else {
		properties.AksNetworkingConfiguration = nil
	}

	// ClusterFqdn
	properties.ClusterFqdn = genruntime.ClonePointerToString(source.ClusterFqdn)

	// ClusterPurpose
	if source.ClusterPurpose != nil {
		clusterPurpose := genruntime.ToEnum(string(*source.ClusterPurpose), aKS_Properties_ClusterPurpose_Values)
		properties.ClusterPurpose = &clusterPurpose
	} else {
		properties.ClusterPurpose = nil
	}

	// LoadBalancerType
	if source.LoadBalancerType != nil {
		loadBalancerType := genruntime.ToEnum(string(*source.LoadBalancerType), aKS_Properties_LoadBalancerType_Values)
		properties.LoadBalancerType = &loadBalancerType
	} else {
		properties.LoadBalancerType = nil
	}

	// SslConfiguration
	if source.SslConfiguration != nil {
		var sslConfiguration SslConfiguration
		err := sslConfiguration.Initialize_From_SslConfiguration_STATUS(source.SslConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SslConfiguration_STATUS() to populate field SslConfiguration")
		}
		properties.SslConfiguration = &sslConfiguration
	} else {
		properties.SslConfiguration = nil
	}

	// No error
	return nil
}

type AKS_Properties_STATUS struct {
	// AgentCount: Number of agents
	AgentCount *int `json:"agentCount,omitempty"`

	// AgentVmSize: Agent virtual machine size
	AgentVmSize *string `json:"agentVmSize,omitempty"`

	// AksNetworkingConfiguration: AKS networking configuration for vnet
	AksNetworkingConfiguration *AksNetworkingConfiguration_STATUS `json:"aksNetworkingConfiguration,omitempty"`

	// ClusterFqdn: Cluster full qualified domain name
	ClusterFqdn *string `json:"clusterFqdn,omitempty"`

	// ClusterPurpose: Intended usage of the cluster
	ClusterPurpose *AKS_Properties_ClusterPurpose_STATUS `json:"clusterPurpose,omitempty"`

	// LoadBalancerSubnet: Load Balancer Subnet
	LoadBalancerSubnet *string `json:"loadBalancerSubnet,omitempty"`

	// LoadBalancerType: Load Balancer Type
	LoadBalancerType *AKS_Properties_LoadBalancerType_STATUS `json:"loadBalancerType,omitempty"`

	// SslConfiguration: SSL configuration
	SslConfiguration *SslConfiguration_STATUS `json:"sslConfiguration,omitempty"`

	// SystemServices: System services
	SystemServices []SystemService_STATUS `json:"systemServices,omitempty"`
}

var _ genruntime.FromARMConverter = &AKS_Properties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *AKS_Properties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AKS_Properties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *AKS_Properties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AKS_Properties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AKS_Properties_STATUS, got %T", armInput)
	}

	// Set property "AgentCount":
	if typedInput.AgentCount != nil {
		agentCount := *typedInput.AgentCount
		properties.AgentCount = &agentCount
	}

	// Set property "AgentVmSize":
	if typedInput.AgentVmSize != nil {
		agentVmSize := *typedInput.AgentVmSize
		properties.AgentVmSize = &agentVmSize
	}

	// Set property "AksNetworkingConfiguration":
	if typedInput.AksNetworkingConfiguration != nil {
		var aksNetworkingConfiguration1 AksNetworkingConfiguration_STATUS
		err := aksNetworkingConfiguration1.PopulateFromARM(owner, *typedInput.AksNetworkingConfiguration)
		if err != nil {
			return err
		}
		aksNetworkingConfiguration := aksNetworkingConfiguration1
		properties.AksNetworkingConfiguration = &aksNetworkingConfiguration
	}

	// Set property "ClusterFqdn":
	if typedInput.ClusterFqdn != nil {
		clusterFqdn := *typedInput.ClusterFqdn
		properties.ClusterFqdn = &clusterFqdn
	}

	// Set property "ClusterPurpose":
	if typedInput.ClusterPurpose != nil {
		var temp string
		temp = string(*typedInput.ClusterPurpose)
		clusterPurpose := AKS_Properties_ClusterPurpose_STATUS(temp)
		properties.ClusterPurpose = &clusterPurpose
	}

	// Set property "LoadBalancerSubnet":
	if typedInput.LoadBalancerSubnet != nil {
		loadBalancerSubnet := *typedInput.LoadBalancerSubnet
		properties.LoadBalancerSubnet = &loadBalancerSubnet
	}

	// Set property "LoadBalancerType":
	if typedInput.LoadBalancerType != nil {
		var temp string
		temp = string(*typedInput.LoadBalancerType)
		loadBalancerType := AKS_Properties_LoadBalancerType_STATUS(temp)
		properties.LoadBalancerType = &loadBalancerType
	}

	// Set property "SslConfiguration":
	if typedInput.SslConfiguration != nil {
		var sslConfiguration1 SslConfiguration_STATUS
		err := sslConfiguration1.PopulateFromARM(owner, *typedInput.SslConfiguration)
		if err != nil {
			return err
		}
		sslConfiguration := sslConfiguration1
		properties.SslConfiguration = &sslConfiguration
	}

	// Set property "SystemServices":
	for _, item := range typedInput.SystemServices {
		var item1 SystemService_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.SystemServices = append(properties.SystemServices, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_AKS_Properties_STATUS populates our AKS_Properties_STATUS from the provided source AKS_Properties_STATUS
func (properties *AKS_Properties_STATUS) AssignProperties_From_AKS_Properties_STATUS(source *storage.AKS_Properties_STATUS) error {

	// AgentCount
	properties.AgentCount = genruntime.ClonePointerToInt(source.AgentCount)

	// AgentVmSize
	properties.AgentVmSize = genruntime.ClonePointerToString(source.AgentVmSize)

	// AksNetworkingConfiguration
	if source.AksNetworkingConfiguration != nil {
		var aksNetworkingConfiguration AksNetworkingConfiguration_STATUS
		err := aksNetworkingConfiguration.AssignProperties_From_AksNetworkingConfiguration_STATUS(source.AksNetworkingConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AksNetworkingConfiguration_STATUS() to populate field AksNetworkingConfiguration")
		}
		properties.AksNetworkingConfiguration = &aksNetworkingConfiguration
	} else {
		properties.AksNetworkingConfiguration = nil
	}

	// ClusterFqdn
	properties.ClusterFqdn = genruntime.ClonePointerToString(source.ClusterFqdn)

	// ClusterPurpose
	if source.ClusterPurpose != nil {
		clusterPurpose := *source.ClusterPurpose
		clusterPurposeTemp := genruntime.ToEnum(clusterPurpose, aKS_Properties_ClusterPurpose_STATUS_Values)
		properties.ClusterPurpose = &clusterPurposeTemp
	} else {
		properties.ClusterPurpose = nil
	}

	// LoadBalancerSubnet
	properties.LoadBalancerSubnet = genruntime.ClonePointerToString(source.LoadBalancerSubnet)

	// LoadBalancerType
	if source.LoadBalancerType != nil {
		loadBalancerType := *source.LoadBalancerType
		loadBalancerTypeTemp := genruntime.ToEnum(loadBalancerType, aKS_Properties_LoadBalancerType_STATUS_Values)
		properties.LoadBalancerType = &loadBalancerTypeTemp
	} else {
		properties.LoadBalancerType = nil
	}

	// SslConfiguration
	if source.SslConfiguration != nil {
		var sslConfiguration SslConfiguration_STATUS
		err := sslConfiguration.AssignProperties_From_SslConfiguration_STATUS(source.SslConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SslConfiguration_STATUS() to populate field SslConfiguration")
		}
		properties.SslConfiguration = &sslConfiguration
	} else {
		properties.SslConfiguration = nil
	}

	// SystemServices
	if source.SystemServices != nil {
		systemServiceList := make([]SystemService_STATUS, len(source.SystemServices))
		for systemServiceIndex, systemServiceItem := range source.SystemServices {
			// Shadow the loop variable to avoid aliasing
			systemServiceItem := systemServiceItem
			var systemService SystemService_STATUS
			err := systemService.AssignProperties_From_SystemService_STATUS(&systemServiceItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SystemService_STATUS() to populate field SystemServices")
			}
			systemServiceList[systemServiceIndex] = systemService
		}
		properties.SystemServices = systemServiceList
	} else {
		properties.SystemServices = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AKS_Properties_STATUS populates the provided destination AKS_Properties_STATUS from our AKS_Properties_STATUS
func (properties *AKS_Properties_STATUS) AssignProperties_To_AKS_Properties_STATUS(destination *storage.AKS_Properties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AgentCount
	destination.AgentCount = genruntime.ClonePointerToInt(properties.AgentCount)

	// AgentVmSize
	destination.AgentVmSize = genruntime.ClonePointerToString(properties.AgentVmSize)

	// AksNetworkingConfiguration
	if properties.AksNetworkingConfiguration != nil {
		var aksNetworkingConfiguration storage.AksNetworkingConfiguration_STATUS
		err := properties.AksNetworkingConfiguration.AssignProperties_To_AksNetworkingConfiguration_STATUS(&aksNetworkingConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AksNetworkingConfiguration_STATUS() to populate field AksNetworkingConfiguration")
		}
		destination.AksNetworkingConfiguration = &aksNetworkingConfiguration
	} else {
		destination.AksNetworkingConfiguration = nil
	}

	// ClusterFqdn
	destination.ClusterFqdn = genruntime.ClonePointerToString(properties.ClusterFqdn)

	// ClusterPurpose
	if properties.ClusterPurpose != nil {
		clusterPurpose := string(*properties.ClusterPurpose)
		destination.ClusterPurpose = &clusterPurpose
	} else {
		destination.ClusterPurpose = nil
	}

	// LoadBalancerSubnet
	destination.LoadBalancerSubnet = genruntime.ClonePointerToString(properties.LoadBalancerSubnet)

	// LoadBalancerType
	if properties.LoadBalancerType != nil {
		loadBalancerType := string(*properties.LoadBalancerType)
		destination.LoadBalancerType = &loadBalancerType
	} else {
		destination.LoadBalancerType = nil
	}

	// SslConfiguration
	if properties.SslConfiguration != nil {
		var sslConfiguration storage.SslConfiguration_STATUS
		err := properties.SslConfiguration.AssignProperties_To_SslConfiguration_STATUS(&sslConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SslConfiguration_STATUS() to populate field SslConfiguration")
		}
		destination.SslConfiguration = &sslConfiguration
	} else {
		destination.SslConfiguration = nil
	}

	// SystemServices
	if properties.SystemServices != nil {
		systemServiceList := make([]storage.SystemService_STATUS, len(properties.SystemServices))
		for systemServiceIndex, systemServiceItem := range properties.SystemServices {
			// Shadow the loop variable to avoid aliasing
			systemServiceItem := systemServiceItem
			var systemService storage.SystemService_STATUS
			err := systemServiceItem.AssignProperties_To_SystemService_STATUS(&systemService)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SystemService_STATUS() to populate field SystemServices")
			}
			systemServiceList[systemServiceIndex] = systemService
		}
		destination.SystemServices = systemServiceList
	} else {
		destination.SystemServices = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AKS_ProvisioningState_STATUS string

const (
	AKS_ProvisioningState_STATUS_Canceled  = AKS_ProvisioningState_STATUS("Canceled")
	AKS_ProvisioningState_STATUS_Creating  = AKS_ProvisioningState_STATUS("Creating")
	AKS_ProvisioningState_STATUS_Deleting  = AKS_ProvisioningState_STATUS("Deleting")
	AKS_ProvisioningState_STATUS_Failed    = AKS_ProvisioningState_STATUS("Failed")
	AKS_ProvisioningState_STATUS_Succeeded = AKS_ProvisioningState_STATUS("Succeeded")
	AKS_ProvisioningState_STATUS_Unknown   = AKS_ProvisioningState_STATUS("Unknown")
	AKS_ProvisioningState_STATUS_Updating  = AKS_ProvisioningState_STATUS("Updating")
)

// Mapping from string to AKS_ProvisioningState_STATUS
var aKS_ProvisioningState_STATUS_Values = map[string]AKS_ProvisioningState_STATUS{
	"canceled":  AKS_ProvisioningState_STATUS_Canceled,
	"creating":  AKS_ProvisioningState_STATUS_Creating,
	"deleting":  AKS_ProvisioningState_STATUS_Deleting,
	"failed":    AKS_ProvisioningState_STATUS_Failed,
	"succeeded": AKS_ProvisioningState_STATUS_Succeeded,
	"unknown":   AKS_ProvisioningState_STATUS_Unknown,
	"updating":  AKS_ProvisioningState_STATUS_Updating,
}

// +kubebuilder:validation:Enum={"AmlCompute"}
type AmlCompute_ComputeType string

const AmlCompute_ComputeType_AmlCompute = AmlCompute_ComputeType("AmlCompute")

// Mapping from string to AmlCompute_ComputeType
var amlCompute_ComputeType_Values = map[string]AmlCompute_ComputeType{
	"amlcompute": AmlCompute_ComputeType_AmlCompute,
}

type AmlCompute_ComputeType_STATUS string

const AmlCompute_ComputeType_STATUS_AmlCompute = AmlCompute_ComputeType_STATUS("AmlCompute")

// Mapping from string to AmlCompute_ComputeType_STATUS
var amlCompute_ComputeType_STATUS_Values = map[string]AmlCompute_ComputeType_STATUS{
	"amlcompute": AmlCompute_ComputeType_STATUS_AmlCompute,
}

type AmlCompute_ProvisioningState_STATUS string

const (
	AmlCompute_ProvisioningState_STATUS_Canceled  = AmlCompute_ProvisioningState_STATUS("Canceled")
	AmlCompute_ProvisioningState_STATUS_Creating  = AmlCompute_ProvisioningState_STATUS("Creating")
	AmlCompute_ProvisioningState_STATUS_Deleting  = AmlCompute_ProvisioningState_STATUS("Deleting")
	AmlCompute_ProvisioningState_STATUS_Failed    = AmlCompute_ProvisioningState_STATUS("Failed")
	AmlCompute_ProvisioningState_STATUS_Succeeded = AmlCompute_ProvisioningState_STATUS("Succeeded")
	AmlCompute_ProvisioningState_STATUS_Unknown   = AmlCompute_ProvisioningState_STATUS("Unknown")
	AmlCompute_ProvisioningState_STATUS_Updating  = AmlCompute_ProvisioningState_STATUS("Updating")
)

// Mapping from string to AmlCompute_ProvisioningState_STATUS
var amlCompute_ProvisioningState_STATUS_Values = map[string]AmlCompute_ProvisioningState_STATUS{
	"canceled":  AmlCompute_ProvisioningState_STATUS_Canceled,
	"creating":  AmlCompute_ProvisioningState_STATUS_Creating,
	"deleting":  AmlCompute_ProvisioningState_STATUS_Deleting,
	"failed":    AmlCompute_ProvisioningState_STATUS_Failed,
	"succeeded": AmlCompute_ProvisioningState_STATUS_Succeeded,
	"unknown":   AmlCompute_ProvisioningState_STATUS_Unknown,
	"updating":  AmlCompute_ProvisioningState_STATUS_Updating,
}

// AML Compute properties
type AmlComputeProperties struct {
	// EnableNodePublicIp: Enable or disable node public IP address provisioning. Possible values are: Possible values are:
	// true - Indicates that the compute nodes will have public IPs provisioned. false - Indicates that the compute nodes will
	// have a private endpoint and no public IPs.
	EnableNodePublicIp *bool `json:"enableNodePublicIp,omitempty"`

	// IsolatedNetwork: Network is isolated or not
	IsolatedNetwork *bool `json:"isolatedNetwork,omitempty"`

	// OsType: Compute OS Type
	OsType *AmlComputeProperties_OsType `json:"osType,omitempty"`

	// PropertyBag: A property bag containing additional properties.
	PropertyBag map[string]v1.JSON `json:"propertyBag,omitempty"`

	// RemoteLoginPortPublicAccess: State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh
	// port is closed on all nodes of the cluster. Enabled - Indicates that the public ssh port is open on all nodes of the
	// cluster. NotSpecified - Indicates that the public ssh port is closed on all nodes of the cluster if VNet is defined,
	// else is open all public nodes. It can be default only during cluster creation time, after creation it will be either
	// enabled or disabled.
	RemoteLoginPortPublicAccess *AmlComputeProperties_RemoteLoginPortPublicAccess `json:"remoteLoginPortPublicAccess,omitempty"`

	// ScaleSettings: Scale settings for AML Compute
	ScaleSettings *ScaleSettings `json:"scaleSettings,omitempty"`

	// Subnet: Virtual network subnet resource ID the compute nodes belong to.
	Subnet *ResourceId `json:"subnet,omitempty"`

	// UserAccountCredentials: Credentials for an administrator user account that will be created on each compute node.
	UserAccountCredentials *UserAccountCredentials `json:"userAccountCredentials,omitempty"`

	// VirtualMachineImage: Virtual Machine image for AML Compute - windows only
	VirtualMachineImage *VirtualMachineImage `json:"virtualMachineImage,omitempty"`

	// VmPriority: Virtual Machine priority
	VmPriority *AmlComputeProperties_VmPriority `json:"vmPriority,omitempty"`

	// VmSize: Virtual Machine Size
	VmSize *string `json:"vmSize,omitempty"`
}

var _ genruntime.ARMTransformer = &AmlComputeProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *AmlComputeProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.AmlComputeProperties{}

	// Set property "EnableNodePublicIp":
	if properties.EnableNodePublicIp != nil {
		enableNodePublicIp := *properties.EnableNodePublicIp
		result.EnableNodePublicIp = &enableNodePublicIp
	}

	// Set property "IsolatedNetwork":
	if properties.IsolatedNetwork != nil {
		isolatedNetwork := *properties.IsolatedNetwork
		result.IsolatedNetwork = &isolatedNetwork
	}

	// Set property "OsType":
	if properties.OsType != nil {
		var temp string
		temp = string(*properties.OsType)
		osType := arm.AmlComputeProperties_OsType(temp)
		result.OsType = &osType
	}

	// Set property "PropertyBag":
	if properties.PropertyBag != nil {
		result.PropertyBag = make(map[string]v1.JSON, len(properties.PropertyBag))
		for key, value := range properties.PropertyBag {
			result.PropertyBag[key] = *value.DeepCopy()
		}
	}

	// Set property "RemoteLoginPortPublicAccess":
	if properties.RemoteLoginPortPublicAccess != nil {
		var temp string
		temp = string(*properties.RemoteLoginPortPublicAccess)
		remoteLoginPortPublicAccess := arm.AmlComputeProperties_RemoteLoginPortPublicAccess(temp)
		result.RemoteLoginPortPublicAccess = &remoteLoginPortPublicAccess
	}

	// Set property "ScaleSettings":
	if properties.ScaleSettings != nil {
		scaleSettings_ARM, err := (*properties.ScaleSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		scaleSettings := *scaleSettings_ARM.(*arm.ScaleSettings)
		result.ScaleSettings = &scaleSettings
	}

	// Set property "Subnet":
	if properties.Subnet != nil {
		subnet_ARM, err := (*properties.Subnet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		subnet := *subnet_ARM.(*arm.ResourceId)
		result.Subnet = &subnet
	}

	// Set property "UserAccountCredentials":
	if properties.UserAccountCredentials != nil {
		userAccountCredentials_ARM, err := (*properties.UserAccountCredentials).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		userAccountCredentials := *userAccountCredentials_ARM.(*arm.UserAccountCredentials)
		result.UserAccountCredentials = &userAccountCredentials
	}

	// Set property "VirtualMachineImage":
	if properties.VirtualMachineImage != nil {
		virtualMachineImage_ARM, err := (*properties.VirtualMachineImage).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		virtualMachineImage := *virtualMachineImage_ARM.(*arm.VirtualMachineImage)
		result.VirtualMachineImage = &virtualMachineImage
	}

	// Set property "VmPriority":
	if properties.VmPriority != nil {
		var temp string
		temp = string(*properties.VmPriority)
		vmPriority := arm.AmlComputeProperties_VmPriority(temp)
		result.VmPriority = &vmPriority
	}

	// Set property "VmSize":
	if properties.VmSize != nil {
		vmSize := *properties.VmSize
		result.VmSize = &vmSize
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *AmlComputeProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AmlComputeProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *AmlComputeProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AmlComputeProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AmlComputeProperties, got %T", armInput)
	}

	// Set property "EnableNodePublicIp":
	if typedInput.EnableNodePublicIp != nil {
		enableNodePublicIp := *typedInput.EnableNodePublicIp
		properties.EnableNodePublicIp = &enableNodePublicIp
	}

	// Set property "IsolatedNetwork":
	if typedInput.IsolatedNetwork != nil {
		isolatedNetwork := *typedInput.IsolatedNetwork
		properties.IsolatedNetwork = &isolatedNetwork
	}

	// Set property "OsType":
	if typedInput.OsType != nil {
		var temp string
		temp = string(*typedInput.OsType)
		osType := AmlComputeProperties_OsType(temp)
		properties.OsType = &osType
	}

	// Set property "PropertyBag":
	if typedInput.PropertyBag != nil {
		properties.PropertyBag = make(map[string]v1.JSON, len(typedInput.PropertyBag))
		for key, value := range typedInput.PropertyBag {
			properties.PropertyBag[key] = *value.DeepCopy()
		}
	}

	// Set property "RemoteLoginPortPublicAccess":
	if typedInput.RemoteLoginPortPublicAccess != nil {
		var temp string
		temp = string(*typedInput.RemoteLoginPortPublicAccess)
		remoteLoginPortPublicAccess := AmlComputeProperties_RemoteLoginPortPublicAccess(temp)
		properties.RemoteLoginPortPublicAccess = &remoteLoginPortPublicAccess
	}

	// Set property "ScaleSettings":
	if typedInput.ScaleSettings != nil {
		var scaleSettings1 ScaleSettings
		err := scaleSettings1.PopulateFromARM(owner, *typedInput.ScaleSettings)
		if err != nil {
			return err
		}
		scaleSettings := scaleSettings1
		properties.ScaleSettings = &scaleSettings
	}

	// Set property "Subnet":
	if typedInput.Subnet != nil {
		var subnet1 ResourceId
		err := subnet1.PopulateFromARM(owner, *typedInput.Subnet)
		if err != nil {
			return err
		}
		subnet := subnet1
		properties.Subnet = &subnet
	}

	// Set property "UserAccountCredentials":
	if typedInput.UserAccountCredentials != nil {
		var userAccountCredentials1 UserAccountCredentials
		err := userAccountCredentials1.PopulateFromARM(owner, *typedInput.UserAccountCredentials)
		if err != nil {
			return err
		}
		userAccountCredentials := userAccountCredentials1
		properties.UserAccountCredentials = &userAccountCredentials
	}

	// Set property "VirtualMachineImage":
	if typedInput.VirtualMachineImage != nil {
		var virtualMachineImage1 VirtualMachineImage
		err := virtualMachineImage1.PopulateFromARM(owner, *typedInput.VirtualMachineImage)
		if err != nil {
			return err
		}
		virtualMachineImage := virtualMachineImage1
		properties.VirtualMachineImage = &virtualMachineImage
	}

	// Set property "VmPriority":
	if typedInput.VmPriority != nil {
		var temp string
		temp = string(*typedInput.VmPriority)
		vmPriority := AmlComputeProperties_VmPriority(temp)
		properties.VmPriority = &vmPriority
	}

	// Set property "VmSize":
	if typedInput.VmSize != nil {
		vmSize := *typedInput.VmSize
		properties.VmSize = &vmSize
	}

	// No error
	return nil
}

// AssignProperties_From_AmlComputeProperties populates our AmlComputeProperties from the provided source AmlComputeProperties
func (properties *AmlComputeProperties) AssignProperties_From_AmlComputeProperties(source *storage.AmlComputeProperties) error {

	// EnableNodePublicIp
	if source.EnableNodePublicIp != nil {
		enableNodePublicIp := *source.EnableNodePublicIp
		properties.EnableNodePublicIp = &enableNodePublicIp
	} else {
		properties.EnableNodePublicIp = nil
	}

	// IsolatedNetwork
	if source.IsolatedNetwork != nil {
		isolatedNetwork := *source.IsolatedNetwork
		properties.IsolatedNetwork = &isolatedNetwork
	} else {
		properties.IsolatedNetwork = nil
	}

	// OsType
	if source.OsType != nil {
		osType := *source.OsType
		osTypeTemp := genruntime.ToEnum(osType, amlComputeProperties_OsType_Values)
		properties.OsType = &osTypeTemp
	} else {
		properties.OsType = nil
	}

	// PropertyBag
	if source.PropertyBag != nil {
		propertyBagMap := make(map[string]v1.JSON, len(source.PropertyBag))
		for propertyBagKey, propertyBagValue := range source.PropertyBag {
			// Shadow the loop variable to avoid aliasing
			propertyBagValue := propertyBagValue
			propertyBagMap[propertyBagKey] = *propertyBagValue.DeepCopy()
		}
		properties.PropertyBag = propertyBagMap
	} else {
		properties.PropertyBag = nil
	}

	// RemoteLoginPortPublicAccess
	if source.RemoteLoginPortPublicAccess != nil {
		remoteLoginPortPublicAccess := *source.RemoteLoginPortPublicAccess
		remoteLoginPortPublicAccessTemp := genruntime.ToEnum(remoteLoginPortPublicAccess, amlComputeProperties_RemoteLoginPortPublicAccess_Values)
		properties.RemoteLoginPortPublicAccess = &remoteLoginPortPublicAccessTemp
	} else {
		properties.RemoteLoginPortPublicAccess = nil
	}

	// ScaleSettings
	if source.ScaleSettings != nil {
		var scaleSetting ScaleSettings
		err := scaleSetting.AssignProperties_From_ScaleSettings(source.ScaleSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ScaleSettings() to populate field ScaleSettings")
		}
		properties.ScaleSettings = &scaleSetting
	} else {
		properties.ScaleSettings = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet ResourceId
		err := subnet.AssignProperties_From_ResourceId(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceId() to populate field Subnet")
		}
		properties.Subnet = &subnet
	} else {
		properties.Subnet = nil
	}

	// UserAccountCredentials
	if source.UserAccountCredentials != nil {
		var userAccountCredential UserAccountCredentials
		err := userAccountCredential.AssignProperties_From_UserAccountCredentials(source.UserAccountCredentials)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UserAccountCredentials() to populate field UserAccountCredentials")
		}
		properties.UserAccountCredentials = &userAccountCredential
	} else {
		properties.UserAccountCredentials = nil
	}

	// VirtualMachineImage
	if source.VirtualMachineImage != nil {
		var virtualMachineImage VirtualMachineImage
		err := virtualMachineImage.AssignProperties_From_VirtualMachineImage(source.VirtualMachineImage)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineImage() to populate field VirtualMachineImage")
		}
		properties.VirtualMachineImage = &virtualMachineImage
	} else {
		properties.VirtualMachineImage = nil
	}

	// VmPriority
	if source.VmPriority != nil {
		vmPriority := *source.VmPriority
		vmPriorityTemp := genruntime.ToEnum(vmPriority, amlComputeProperties_VmPriority_Values)
		properties.VmPriority = &vmPriorityTemp
	} else {
		properties.VmPriority = nil
	}

	// VmSize
	properties.VmSize = genruntime.ClonePointerToString(source.VmSize)

	// No error
	return nil
}

// AssignProperties_To_AmlComputeProperties populates the provided destination AmlComputeProperties from our AmlComputeProperties
func (properties *AmlComputeProperties) AssignProperties_To_AmlComputeProperties(destination *storage.AmlComputeProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EnableNodePublicIp
	if properties.EnableNodePublicIp != nil {
		enableNodePublicIp := *properties.EnableNodePublicIp
		destination.EnableNodePublicIp = &enableNodePublicIp
	} else {
		destination.EnableNodePublicIp = nil
	}

	// IsolatedNetwork
	if properties.IsolatedNetwork != nil {
		isolatedNetwork := *properties.IsolatedNetwork
		destination.IsolatedNetwork = &isolatedNetwork
	} else {
		destination.IsolatedNetwork = nil
	}

	// OsType
	if properties.OsType != nil {
		osType := string(*properties.OsType)
		destination.OsType = &osType
	} else {
		destination.OsType = nil
	}

	// PropertyBag
	if properties.PropertyBag != nil {
		propertyBagMap := make(map[string]v1.JSON, len(properties.PropertyBag))
		for propertyBagKey, propertyBagValue := range properties.PropertyBag {
			// Shadow the loop variable to avoid aliasing
			propertyBagValue := propertyBagValue
			propertyBagMap[propertyBagKey] = *propertyBagValue.DeepCopy()
		}
		destination.PropertyBag = propertyBagMap
	} else {
		destination.PropertyBag = nil
	}

	// RemoteLoginPortPublicAccess
	if properties.RemoteLoginPortPublicAccess != nil {
		remoteLoginPortPublicAccess := string(*properties.RemoteLoginPortPublicAccess)
		destination.RemoteLoginPortPublicAccess = &remoteLoginPortPublicAccess
	} else {
		destination.RemoteLoginPortPublicAccess = nil
	}

	// ScaleSettings
	if properties.ScaleSettings != nil {
		var scaleSetting storage.ScaleSettings
		err := properties.ScaleSettings.AssignProperties_To_ScaleSettings(&scaleSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ScaleSettings() to populate field ScaleSettings")
		}
		destination.ScaleSettings = &scaleSetting
	} else {
		destination.ScaleSettings = nil
	}

	// Subnet
	if properties.Subnet != nil {
		var subnet storage.ResourceId
		err := properties.Subnet.AssignProperties_To_ResourceId(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceId() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// UserAccountCredentials
	if properties.UserAccountCredentials != nil {
		var userAccountCredential storage.UserAccountCredentials
		err := properties.UserAccountCredentials.AssignProperties_To_UserAccountCredentials(&userAccountCredential)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UserAccountCredentials() to populate field UserAccountCredentials")
		}
		destination.UserAccountCredentials = &userAccountCredential
	} else {
		destination.UserAccountCredentials = nil
	}

	// VirtualMachineImage
	if properties.VirtualMachineImage != nil {
		var virtualMachineImage storage.VirtualMachineImage
		err := properties.VirtualMachineImage.AssignProperties_To_VirtualMachineImage(&virtualMachineImage)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineImage() to populate field VirtualMachineImage")
		}
		destination.VirtualMachineImage = &virtualMachineImage
	} else {
		destination.VirtualMachineImage = nil
	}

	// VmPriority
	if properties.VmPriority != nil {
		vmPriority := string(*properties.VmPriority)
		destination.VmPriority = &vmPriority
	} else {
		destination.VmPriority = nil
	}

	// VmSize
	destination.VmSize = genruntime.ClonePointerToString(properties.VmSize)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyStash = propertyBag
	} else {
		destination.PropertyStash = nil
	}

	// No error
	return nil
}

// Initialize_From_AmlComputeProperties_STATUS populates our AmlComputeProperties from the provided source AmlComputeProperties_STATUS
func (properties *AmlComputeProperties) Initialize_From_AmlComputeProperties_STATUS(source *AmlComputeProperties_STATUS) error {

	// EnableNodePublicIp
	if source.EnableNodePublicIp != nil {
		enableNodePublicIp := *source.EnableNodePublicIp
		properties.EnableNodePublicIp = &enableNodePublicIp
	} else {
		properties.EnableNodePublicIp = nil
	}

	// IsolatedNetwork
	if source.IsolatedNetwork != nil {
		isolatedNetwork := *source.IsolatedNetwork
		properties.IsolatedNetwork = &isolatedNetwork
	} else {
		properties.IsolatedNetwork = nil
	}

	// OsType
	if source.OsType != nil {
		osType := genruntime.ToEnum(string(*source.OsType), amlComputeProperties_OsType_Values)
		properties.OsType = &osType
	} else {
		properties.OsType = nil
	}

	// PropertyBag
	if source.PropertyBag != nil {
		propertyBagMap := make(map[string]v1.JSON, len(source.PropertyBag))
		for propertyBagKey, propertyBagValue := range source.PropertyBag {
			// Shadow the loop variable to avoid aliasing
			propertyBagValue := propertyBagValue
			propertyBagMap[propertyBagKey] = *propertyBagValue.DeepCopy()
		}
		properties.PropertyBag = propertyBagMap
	} else {
		properties.PropertyBag = nil
	}

	// RemoteLoginPortPublicAccess
	if source.RemoteLoginPortPublicAccess != nil {
		remoteLoginPortPublicAccess := genruntime.ToEnum(string(*source.RemoteLoginPortPublicAccess), amlComputeProperties_RemoteLoginPortPublicAccess_Values)
		properties.RemoteLoginPortPublicAccess = &remoteLoginPortPublicAccess
	} else {
		properties.RemoteLoginPortPublicAccess = nil
	}

	// ScaleSettings
	if source.ScaleSettings != nil {
		var scaleSetting ScaleSettings
		err := scaleSetting.Initialize_From_ScaleSettings_STATUS(source.ScaleSettings)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ScaleSettings_STATUS() to populate field ScaleSettings")
		}
		properties.ScaleSettings = &scaleSetting
	} else {
		properties.ScaleSettings = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet ResourceId
		err := subnet.Initialize_From_ResourceId_STATUS(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ResourceId_STATUS() to populate field Subnet")
		}
		properties.Subnet = &subnet
	} else {
		properties.Subnet = nil
	}

	// UserAccountCredentials
	if source.UserAccountCredentials != nil {
		var userAccountCredential UserAccountCredentials
		err := userAccountCredential.Initialize_From_UserAccountCredentials_STATUS(source.UserAccountCredentials)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_UserAccountCredentials_STATUS() to populate field UserAccountCredentials")
		}
		properties.UserAccountCredentials = &userAccountCredential
	} else {
		properties.UserAccountCredentials = nil
	}

	// VirtualMachineImage
	if source.VirtualMachineImage != nil {
		var virtualMachineImage VirtualMachineImage
		err := virtualMachineImage.Initialize_From_VirtualMachineImage_STATUS(source.VirtualMachineImage)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_VirtualMachineImage_STATUS() to populate field VirtualMachineImage")
		}
		properties.VirtualMachineImage = &virtualMachineImage
	} else {
		properties.VirtualMachineImage = nil
	}

	// VmPriority
	if source.VmPriority != nil {
		vmPriority := genruntime.ToEnum(string(*source.VmPriority), amlComputeProperties_VmPriority_Values)
		properties.VmPriority = &vmPriority
	} else {
		properties.VmPriority = nil
	}

	// VmSize
	properties.VmSize = genruntime.ClonePointerToString(source.VmSize)

	// No error
	return nil
}

// AML Compute properties
type AmlComputeProperties_STATUS struct {
	// AllocationState: Allocation state of the compute. Possible values are: steady - Indicates that the compute is not
	// resizing. There are no changes to the number of compute nodes in the compute in progress. A compute enters this state
	// when it is created and when no operations are being performed on the compute to change the number of compute nodes.
	// resizing - Indicates that the compute is resizing; that is, compute nodes are being added to or removed from the compute.
	AllocationState *AmlComputeProperties_AllocationState_STATUS `json:"allocationState,omitempty"`

	// AllocationStateTransitionTime: The time at which the compute entered its current allocation state.
	AllocationStateTransitionTime *string `json:"allocationStateTransitionTime,omitempty"`

	// CurrentNodeCount: The number of compute nodes currently assigned to the compute.
	CurrentNodeCount *int `json:"currentNodeCount,omitempty"`

	// EnableNodePublicIp: Enable or disable node public IP address provisioning. Possible values are: Possible values are:
	// true - Indicates that the compute nodes will have public IPs provisioned. false - Indicates that the compute nodes will
	// have a private endpoint and no public IPs.
	EnableNodePublicIp *bool `json:"enableNodePublicIp,omitempty"`

	// Errors: Collection of errors encountered by various compute nodes during node setup.
	Errors []ErrorResponse_STATUS `json:"errors,omitempty"`

	// IsolatedNetwork: Network is isolated or not
	IsolatedNetwork *bool `json:"isolatedNetwork,omitempty"`

	// NodeStateCounts: Counts of various node states on the compute.
	NodeStateCounts *NodeStateCounts_STATUS `json:"nodeStateCounts,omitempty"`

	// OsType: Compute OS Type
	OsType *AmlComputeProperties_OsType_STATUS `json:"osType,omitempty"`

	// PropertyBag: A property bag containing additional properties.
	PropertyBag map[string]v1.JSON `json:"propertyBag,omitempty"`

	// RemoteLoginPortPublicAccess: State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh
	// port is closed on all nodes of the cluster. Enabled - Indicates that the public ssh port is open on all nodes of the
	// cluster. NotSpecified - Indicates that the public ssh port is closed on all nodes of the cluster if VNet is defined,
	// else is open all public nodes. It can be default only during cluster creation time, after creation it will be either
	// enabled or disabled.
	RemoteLoginPortPublicAccess *AmlComputeProperties_RemoteLoginPortPublicAccess_STATUS `json:"remoteLoginPortPublicAccess,omitempty"`

	// ScaleSettings: Scale settings for AML Compute
	ScaleSettings *ScaleSettings_STATUS `json:"scaleSettings,omitempty"`

	// Subnet: Virtual network subnet resource ID the compute nodes belong to.
	Subnet *ResourceId_STATUS `json:"subnet,omitempty"`

	// TargetNodeCount: The target number of compute nodes for the compute. If the allocationState is resizing, this property
	// denotes the target node count for the ongoing resize operation. If the allocationState is steady, this property denotes
	// the target node count for the previous resize operation.
	TargetNodeCount *int `json:"targetNodeCount,omitempty"`

	// UserAccountCredentials: Credentials for an administrator user account that will be created on each compute node.
	UserAccountCredentials *UserAccountCredentials_STATUS `json:"userAccountCredentials,omitempty"`

	// VirtualMachineImage: Virtual Machine image for AML Compute - windows only
	VirtualMachineImage *VirtualMachineImage_STATUS `json:"virtualMachineImage,omitempty"`

	// VmPriority: Virtual Machine priority
	VmPriority *AmlComputeProperties_VmPriority_STATUS `json:"vmPriority,omitempty"`

	// VmSize: Virtual Machine Size
	VmSize *string `json:"vmSize,omitempty"`
}

var _ genruntime.FromARMConverter = &AmlComputeProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *AmlComputeProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AmlComputeProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *AmlComputeProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AmlComputeProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AmlComputeProperties_STATUS, got %T", armInput)
	}

	// Set property "AllocationState":
	if typedInput.AllocationState != nil {
		var temp string
		temp = string(*typedInput.AllocationState)
		allocationState := AmlComputeProperties_AllocationState_STATUS(temp)
		properties.AllocationState = &allocationState
	}

	// Set property "AllocationStateTransitionTime":
	if typedInput.AllocationStateTransitionTime != nil {
		allocationStateTransitionTime := *typedInput.AllocationStateTransitionTime
		properties.AllocationStateTransitionTime = &allocationStateTransitionTime
	}

	// Set property "CurrentNodeCount":
	if typedInput.CurrentNodeCount != nil {
		currentNodeCount := *typedInput.CurrentNodeCount
		properties.CurrentNodeCount = &currentNodeCount
	}

	// Set property "EnableNodePublicIp":
	if typedInput.EnableNodePublicIp != nil {
		enableNodePublicIp := *typedInput.EnableNodePublicIp
		properties.EnableNodePublicIp = &enableNodePublicIp
	}

	// Set property "Errors":
	for _, item := range typedInput.Errors {
		var item1 ErrorResponse_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.Errors = append(properties.Errors, item1)
	}

	// Set property "IsolatedNetwork":
	if typedInput.IsolatedNetwork != nil {
		isolatedNetwork := *typedInput.IsolatedNetwork
		properties.IsolatedNetwork = &isolatedNetwork
	}

	// Set property "NodeStateCounts":
	if typedInput.NodeStateCounts != nil {
		var nodeStateCounts1 NodeStateCounts_STATUS
		err := nodeStateCounts1.PopulateFromARM(owner, *typedInput.NodeStateCounts)
		if err != nil {
			return err
		}
		nodeStateCounts := nodeStateCounts1
		properties.NodeStateCounts = &nodeStateCounts
	}

	// Set property "OsType":
	if typedInput.OsType != nil {
		var temp string
		temp = string(*typedInput.OsType)
		osType := AmlComputeProperties_OsType_STATUS(temp)
		properties.OsType = &osType
	}

	// Set property "PropertyBag":
	if typedInput.PropertyBag != nil {
		properties.PropertyBag = make(map[string]v1.JSON, len(typedInput.PropertyBag))
		for key, value := range typedInput.PropertyBag {
			properties.PropertyBag[key] = *value.DeepCopy()
		}
	}

	// Set property "RemoteLoginPortPublicAccess":
	if typedInput.RemoteLoginPortPublicAccess != nil {
		var temp string
		temp = string(*typedInput.RemoteLoginPortPublicAccess)
		remoteLoginPortPublicAccess := AmlComputeProperties_RemoteLoginPortPublicAccess_STATUS(temp)
		properties.RemoteLoginPortPublicAccess = &remoteLoginPortPublicAccess
	}

	// Set property "ScaleSettings":
	if typedInput.ScaleSettings != nil {
		var scaleSettings1 ScaleSettings_STATUS
		err := scaleSettings1.PopulateFromARM(owner, *typedInput.ScaleSettings)
		if err != nil {
			return err
		}
		scaleSettings := scaleSettings1
		properties.ScaleSettings = &scaleSettings
	}

	// Set property "Subnet":
	if typedInput.Subnet != nil {
		var subnet1 ResourceId_STATUS
		err := subnet1.PopulateFromARM(owner, *typedInput.Subnet)
		if err != nil {
			return err
		}
		subnet := subnet1
		properties.Subnet = &subnet
	}

	// Set property "TargetNodeCount":
	if typedInput.TargetNodeCount != nil {
		targetNodeCount := *typedInput.TargetNodeCount
		properties.TargetNodeCount = &targetNodeCount
	}

	// Set property "UserAccountCredentials":
	if typedInput.UserAccountCredentials != nil {
		var userAccountCredentials1 UserAccountCredentials_STATUS
		err := userAccountCredentials1.PopulateFromARM(owner, *typedInput.UserAccountCredentials)
		if err != nil {
			return err
		}
		userAccountCredentials := userAccountCredentials1
		properties.UserAccountCredentials = &userAccountCredentials
	}

	// Set property "VirtualMachineImage":
	if typedInput.VirtualMachineImage != nil {
		var virtualMachineImage1 VirtualMachineImage_STATUS
		err := virtualMachineImage1.PopulateFromARM(owner, *typedInput.VirtualMachineImage)
		if err != nil {
			return err
		}
		virtualMachineImage := virtualMachineImage1
		properties.VirtualMachineImage = &virtualMachineImage
	}

	// Set property "VmPriority":
	if typedInput.VmPriority != nil {
		var temp string
		temp = string(*typedInput.VmPriority)
		vmPriority := AmlComputeProperties_VmPriority_STATUS(temp)
		properties.VmPriority = &vmPriority
	}

	// Set property "VmSize":
	if typedInput.VmSize != nil {
		vmSize := *typedInput.VmSize
		properties.VmSize = &vmSize
	}

	// No error
	return nil
}

// AssignProperties_From_AmlComputeProperties_STATUS populates our AmlComputeProperties_STATUS from the provided source AmlComputeProperties_STATUS
func (properties *AmlComputeProperties_STATUS) AssignProperties_From_AmlComputeProperties_STATUS(source *storage.AmlComputeProperties_STATUS) error {

	// AllocationState
	if source.AllocationState != nil {
		allocationState := *source.AllocationState
		allocationStateTemp := genruntime.ToEnum(allocationState, amlComputeProperties_AllocationState_STATUS_Values)
		properties.AllocationState = &allocationStateTemp
	} else {
		properties.AllocationState = nil
	}

	// AllocationStateTransitionTime
	properties.AllocationStateTransitionTime = genruntime.ClonePointerToString(source.AllocationStateTransitionTime)

	// CurrentNodeCount
	properties.CurrentNodeCount = genruntime.ClonePointerToInt(source.CurrentNodeCount)

	// EnableNodePublicIp
	if source.EnableNodePublicIp != nil {
		enableNodePublicIp := *source.EnableNodePublicIp
		properties.EnableNodePublicIp = &enableNodePublicIp
	} else {
		properties.EnableNodePublicIp = nil
	}

	// Errors
	if source.Errors != nil {
		errorList := make([]ErrorResponse_STATUS, len(source.Errors))
		for errorIndex, errorItem := range source.Errors {
			// Shadow the loop variable to avoid aliasing
			errorItem := errorItem
			var error ErrorResponse_STATUS
			err := error.AssignProperties_From_ErrorResponse_STATUS(&errorItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ErrorResponse_STATUS() to populate field Errors")
			}
			errorList[errorIndex] = error
		}
		properties.Errors = errorList
	} else {
		properties.Errors = nil
	}

	// IsolatedNetwork
	if source.IsolatedNetwork != nil {
		isolatedNetwork := *source.IsolatedNetwork
		properties.IsolatedNetwork = &isolatedNetwork
	} else {
		properties.IsolatedNetwork = nil
	}

	// NodeStateCounts
	if source.NodeStateCounts != nil {
		var nodeStateCount NodeStateCounts_STATUS
		err := nodeStateCount.AssignProperties_From_NodeStateCounts_STATUS(source.NodeStateCounts)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_NodeStateCounts_STATUS() to populate field NodeStateCounts")
		}
		properties.NodeStateCounts = &nodeStateCount
	} else {
		properties.NodeStateCounts = nil
	}

	// OsType
	if source.OsType != nil {
		osType := *source.OsType
		osTypeTemp := genruntime.ToEnum(osType, amlComputeProperties_OsType_STATUS_Values)
		properties.OsType = &osTypeTemp
	} else {
		properties.OsType = nil
	}

	// PropertyBag
	if source.PropertyBag != nil {
		propertyBagMap := make(map[string]v1.JSON, len(source.PropertyBag))
		for propertyBagKey, propertyBagValue := range source.PropertyBag {
			// Shadow the loop variable to avoid aliasing
			propertyBagValue := propertyBagValue
			propertyBagMap[propertyBagKey] = *propertyBagValue.DeepCopy()
		}
		properties.PropertyBag = propertyBagMap
	} else {
		properties.PropertyBag = nil
	}

	// RemoteLoginPortPublicAccess
	if source.RemoteLoginPortPublicAccess != nil {
		remoteLoginPortPublicAccess := *source.RemoteLoginPortPublicAccess
		remoteLoginPortPublicAccessTemp := genruntime.ToEnum(remoteLoginPortPublicAccess, amlComputeProperties_RemoteLoginPortPublicAccess_STATUS_Values)
		properties.RemoteLoginPortPublicAccess = &remoteLoginPortPublicAccessTemp
	} else {
		properties.RemoteLoginPortPublicAccess = nil
	}

	// ScaleSettings
	if source.ScaleSettings != nil {
		var scaleSetting ScaleSettings_STATUS
		err := scaleSetting.AssignProperties_From_ScaleSettings_STATUS(source.ScaleSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ScaleSettings_STATUS() to populate field ScaleSettings")
		}
		properties.ScaleSettings = &scaleSetting
	} else {
		properties.ScaleSettings = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet ResourceId_STATUS
		err := subnet.AssignProperties_From_ResourceId_STATUS(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceId_STATUS() to populate field Subnet")
		}
		properties.Subnet = &subnet
	} else {
		properties.Subnet = nil
	}

	// TargetNodeCount
	properties.TargetNodeCount = genruntime.ClonePointerToInt(source.TargetNodeCount)

	// UserAccountCredentials
	if source.UserAccountCredentials != nil {
		var userAccountCredential UserAccountCredentials_STATUS
		err := userAccountCredential.AssignProperties_From_UserAccountCredentials_STATUS(source.UserAccountCredentials)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UserAccountCredentials_STATUS() to populate field UserAccountCredentials")
		}
		properties.UserAccountCredentials = &userAccountCredential
	} else {
		properties.UserAccountCredentials = nil
	}

	// VirtualMachineImage
	if source.VirtualMachineImage != nil {
		var virtualMachineImage VirtualMachineImage_STATUS
		err := virtualMachineImage.AssignProperties_From_VirtualMachineImage_STATUS(source.VirtualMachineImage)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineImage_STATUS() to populate field VirtualMachineImage")
		}
		properties.VirtualMachineImage = &virtualMachineImage
	} else {
		properties.VirtualMachineImage = nil
	}

	// VmPriority
	if source.VmPriority != nil {
		vmPriority := *source.VmPriority
		vmPriorityTemp := genruntime.ToEnum(vmPriority, amlComputeProperties_VmPriority_STATUS_Values)
		properties.VmPriority = &vmPriorityTemp
	} else {
		properties.VmPriority = nil
	}

	// VmSize
	properties.VmSize = genruntime.ClonePointerToString(source.VmSize)

	// No error
	return nil
}

// AssignProperties_To_AmlComputeProperties_STATUS populates the provided destination AmlComputeProperties_STATUS from our AmlComputeProperties_STATUS
func (properties *AmlComputeProperties_STATUS) AssignProperties_To_AmlComputeProperties_STATUS(destination *storage.AmlComputeProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllocationState
	if properties.AllocationState != nil {
		allocationState := string(*properties.AllocationState)
		destination.AllocationState = &allocationState
	} else {
		destination.AllocationState = nil
	}

	// AllocationStateTransitionTime
	destination.AllocationStateTransitionTime = genruntime.ClonePointerToString(properties.AllocationStateTransitionTime)

	// CurrentNodeCount
	destination.CurrentNodeCount = genruntime.ClonePointerToInt(properties.CurrentNodeCount)

	// EnableNodePublicIp
	if properties.EnableNodePublicIp != nil {
		enableNodePublicIp := *properties.EnableNodePublicIp
		destination.EnableNodePublicIp = &enableNodePublicIp
	} else {
		destination.EnableNodePublicIp = nil
	}

	// Errors
	if properties.Errors != nil {
		errorList := make([]storage.ErrorResponse_STATUS, len(properties.Errors))
		for errorIndex, errorItem := range properties.Errors {
			// Shadow the loop variable to avoid aliasing
			errorItem := errorItem
			var error storage.ErrorResponse_STATUS
			err := errorItem.AssignProperties_To_ErrorResponse_STATUS(&error)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ErrorResponse_STATUS() to populate field Errors")
			}
			errorList[errorIndex] = error
		}
		destination.Errors = errorList
	} else {
		destination.Errors = nil
	}

	// IsolatedNetwork
	if properties.IsolatedNetwork != nil {
		isolatedNetwork := *properties.IsolatedNetwork
		destination.IsolatedNetwork = &isolatedNetwork
	} else {
		destination.IsolatedNetwork = nil
	}

	// NodeStateCounts
	if properties.NodeStateCounts != nil {
		var nodeStateCount storage.NodeStateCounts_STATUS
		err := properties.NodeStateCounts.AssignProperties_To_NodeStateCounts_STATUS(&nodeStateCount)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_NodeStateCounts_STATUS() to populate field NodeStateCounts")
		}
		destination.NodeStateCounts = &nodeStateCount
	} else {
		destination.NodeStateCounts = nil
	}

	// OsType
	if properties.OsType != nil {
		osType := string(*properties.OsType)
		destination.OsType = &osType
	} else {
		destination.OsType = nil
	}

	// PropertyBag
	if properties.PropertyBag != nil {
		propertyBagMap := make(map[string]v1.JSON, len(properties.PropertyBag))
		for propertyBagKey, propertyBagValue := range properties.PropertyBag {
			// Shadow the loop variable to avoid aliasing
			propertyBagValue := propertyBagValue
			propertyBagMap[propertyBagKey] = *propertyBagValue.DeepCopy()
		}
		destination.PropertyBag = propertyBagMap
	} else {
		destination.PropertyBag = nil
	}

	// RemoteLoginPortPublicAccess
	if properties.RemoteLoginPortPublicAccess != nil {
		remoteLoginPortPublicAccess := string(*properties.RemoteLoginPortPublicAccess)
		destination.RemoteLoginPortPublicAccess = &remoteLoginPortPublicAccess
	} else {
		destination.RemoteLoginPortPublicAccess = nil
	}

	// ScaleSettings
	if properties.ScaleSettings != nil {
		var scaleSetting storage.ScaleSettings_STATUS
		err := properties.ScaleSettings.AssignProperties_To_ScaleSettings_STATUS(&scaleSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ScaleSettings_STATUS() to populate field ScaleSettings")
		}
		destination.ScaleSettings = &scaleSetting
	} else {
		destination.ScaleSettings = nil
	}

	// Subnet
	if properties.Subnet != nil {
		var subnet storage.ResourceId_STATUS
		err := properties.Subnet.AssignProperties_To_ResourceId_STATUS(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceId_STATUS() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// TargetNodeCount
	destination.TargetNodeCount = genruntime.ClonePointerToInt(properties.TargetNodeCount)

	// UserAccountCredentials
	if properties.UserAccountCredentials != nil {
		var userAccountCredential storage.UserAccountCredentials_STATUS
		err := properties.UserAccountCredentials.AssignProperties_To_UserAccountCredentials_STATUS(&userAccountCredential)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UserAccountCredentials_STATUS() to populate field UserAccountCredentials")
		}
		destination.UserAccountCredentials = &userAccountCredential
	} else {
		destination.UserAccountCredentials = nil
	}

	// VirtualMachineImage
	if properties.VirtualMachineImage != nil {
		var virtualMachineImage storage.VirtualMachineImage_STATUS
		err := properties.VirtualMachineImage.AssignProperties_To_VirtualMachineImage_STATUS(&virtualMachineImage)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineImage_STATUS() to populate field VirtualMachineImage")
		}
		destination.VirtualMachineImage = &virtualMachineImage
	} else {
		destination.VirtualMachineImage = nil
	}

	// VmPriority
	if properties.VmPriority != nil {
		vmPriority := string(*properties.VmPriority)
		destination.VmPriority = &vmPriority
	} else {
		destination.VmPriority = nil
	}

	// VmSize
	destination.VmSize = genruntime.ClonePointerToString(properties.VmSize)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyStash = propertyBag
	} else {
		destination.PropertyStash = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"ComputeInstance"}
type ComputeInstance_ComputeType string

const ComputeInstance_ComputeType_ComputeInstance = ComputeInstance_ComputeType("ComputeInstance")

// Mapping from string to ComputeInstance_ComputeType
var computeInstance_ComputeType_Values = map[string]ComputeInstance_ComputeType{
	"computeinstance": ComputeInstance_ComputeType_ComputeInstance,
}

type ComputeInstance_ComputeType_STATUS string

const ComputeInstance_ComputeType_STATUS_ComputeInstance = ComputeInstance_ComputeType_STATUS("ComputeInstance")

// Mapping from string to ComputeInstance_ComputeType_STATUS
var computeInstance_ComputeType_STATUS_Values = map[string]ComputeInstance_ComputeType_STATUS{
	"computeinstance": ComputeInstance_ComputeType_STATUS_ComputeInstance,
}

type ComputeInstance_ProvisioningState_STATUS string

const (
	ComputeInstance_ProvisioningState_STATUS_Canceled  = ComputeInstance_ProvisioningState_STATUS("Canceled")
	ComputeInstance_ProvisioningState_STATUS_Creating  = ComputeInstance_ProvisioningState_STATUS("Creating")
	ComputeInstance_ProvisioningState_STATUS_Deleting  = ComputeInstance_ProvisioningState_STATUS("Deleting")
	ComputeInstance_ProvisioningState_STATUS_Failed    = ComputeInstance_ProvisioningState_STATUS("Failed")
	ComputeInstance_ProvisioningState_STATUS_Succeeded = ComputeInstance_ProvisioningState_STATUS("Succeeded")
	ComputeInstance_ProvisioningState_STATUS_Unknown   = ComputeInstance_ProvisioningState_STATUS("Unknown")
	ComputeInstance_ProvisioningState_STATUS_Updating  = ComputeInstance_ProvisioningState_STATUS("Updating")
)

// Mapping from string to ComputeInstance_ProvisioningState_STATUS
var computeInstance_ProvisioningState_STATUS_Values = map[string]ComputeInstance_ProvisioningState_STATUS{
	"canceled":  ComputeInstance_ProvisioningState_STATUS_Canceled,
	"creating":  ComputeInstance_ProvisioningState_STATUS_Creating,
	"deleting":  ComputeInstance_ProvisioningState_STATUS_Deleting,
	"failed":    ComputeInstance_ProvisioningState_STATUS_Failed,
	"succeeded": ComputeInstance_ProvisioningState_STATUS_Succeeded,
	"unknown":   ComputeInstance_ProvisioningState_STATUS_Unknown,
	"updating":  ComputeInstance_ProvisioningState_STATUS_Updating,
}

// Compute Instance properties
type ComputeInstanceProperties struct {
	// ApplicationSharingPolicy: Policy for sharing applications on this compute instance among users of parent workspace. If
	// Personal, only the creator can access applications on this compute instance. When Shared, any workspace user can access
	// applications on this instance depending on his/her assigned role.
	ApplicationSharingPolicy *ComputeInstanceProperties_ApplicationSharingPolicy `json:"applicationSharingPolicy,omitempty"`

	// ComputeInstanceAuthorizationType: The Compute Instance Authorization type. Available values are personal (default).
	ComputeInstanceAuthorizationType *ComputeInstanceProperties_ComputeInstanceAuthorizationType `json:"computeInstanceAuthorizationType,omitempty"`

	// CustomServices: List of Custom Services added to the compute.
	CustomServices []CustomService `json:"customServices,omitempty"`

	// EnableNodePublicIp: Enable or disable node public IP address provisioning. Possible values are: Possible values are:
	// true - Indicates that the compute nodes will have public IPs provisioned. false - Indicates that the compute nodes will
	// have a private endpoint and no public IPs.
	EnableNodePublicIp *bool `json:"enableNodePublicIp,omitempty"`

	// PersonalComputeInstanceSettings: Settings for a personal compute instance.
	PersonalComputeInstanceSettings *PersonalComputeInstanceSettings `json:"personalComputeInstanceSettings,omitempty"`

	// Schedules: The list of schedules to be applied on the computes.
	Schedules *ComputeSchedules `json:"schedules,omitempty"`

	// SetupScripts: Details of customized scripts to execute for setting up the cluster.
	SetupScripts *SetupScripts `json:"setupScripts,omitempty"`

	// SshSettings: Specifies policy and settings for SSH access.
	SshSettings *ComputeInstanceSshSettings `json:"sshSettings,omitempty"`

	// Subnet: Virtual network subnet resource ID the compute nodes belong to.
	Subnet *ResourceId `json:"subnet,omitempty"`

	// VmSize: Virtual Machine Size
	VmSize *string `json:"vmSize,omitempty"`
}

var _ genruntime.ARMTransformer = &ComputeInstanceProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *ComputeInstanceProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.ComputeInstanceProperties{}

	// Set property "ApplicationSharingPolicy":
	if properties.ApplicationSharingPolicy != nil {
		var temp string
		temp = string(*properties.ApplicationSharingPolicy)
		applicationSharingPolicy := arm.ComputeInstanceProperties_ApplicationSharingPolicy(temp)
		result.ApplicationSharingPolicy = &applicationSharingPolicy
	}

	// Set property "ComputeInstanceAuthorizationType":
	if properties.ComputeInstanceAuthorizationType != nil {
		var temp string
		temp = string(*properties.ComputeInstanceAuthorizationType)
		computeInstanceAuthorizationType := arm.ComputeInstanceProperties_ComputeInstanceAuthorizationType(temp)
		result.ComputeInstanceAuthorizationType = &computeInstanceAuthorizationType
	}

	// Set property "CustomServices":
	for _, item := range properties.CustomServices {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.CustomServices = append(result.CustomServices, *item_ARM.(*arm.CustomService))
	}

	// Set property "EnableNodePublicIp":
	if properties.EnableNodePublicIp != nil {
		enableNodePublicIp := *properties.EnableNodePublicIp
		result.EnableNodePublicIp = &enableNodePublicIp
	}

	// Set property "PersonalComputeInstanceSettings":
	if properties.PersonalComputeInstanceSettings != nil {
		personalComputeInstanceSettings_ARM, err := (*properties.PersonalComputeInstanceSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		personalComputeInstanceSettings := *personalComputeInstanceSettings_ARM.(*arm.PersonalComputeInstanceSettings)
		result.PersonalComputeInstanceSettings = &personalComputeInstanceSettings
	}

	// Set property "Schedules":
	if properties.Schedules != nil {
		schedules_ARM, err := (*properties.Schedules).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		schedules := *schedules_ARM.(*arm.ComputeSchedules)
		result.Schedules = &schedules
	}

	// Set property "SetupScripts":
	if properties.SetupScripts != nil {
		setupScripts_ARM, err := (*properties.SetupScripts).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		setupScripts := *setupScripts_ARM.(*arm.SetupScripts)
		result.SetupScripts = &setupScripts
	}

	// Set property "SshSettings":
	if properties.SshSettings != nil {
		sshSettings_ARM, err := (*properties.SshSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sshSettings := *sshSettings_ARM.(*arm.ComputeInstanceSshSettings)
		result.SshSettings = &sshSettings
	}

	// Set property "Subnet":
	if properties.Subnet != nil {
		subnet_ARM, err := (*properties.Subnet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		subnet := *subnet_ARM.(*arm.ResourceId)
		result.Subnet = &subnet
	}

	// Set property "VmSize":
	if properties.VmSize != nil {
		vmSize := *properties.VmSize
		result.VmSize = &vmSize
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *ComputeInstanceProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComputeInstanceProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *ComputeInstanceProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComputeInstanceProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComputeInstanceProperties, got %T", armInput)
	}

	// Set property "ApplicationSharingPolicy":
	if typedInput.ApplicationSharingPolicy != nil {
		var temp string
		temp = string(*typedInput.ApplicationSharingPolicy)
		applicationSharingPolicy := ComputeInstanceProperties_ApplicationSharingPolicy(temp)
		properties.ApplicationSharingPolicy = &applicationSharingPolicy
	}

	// Set property "ComputeInstanceAuthorizationType":
	if typedInput.ComputeInstanceAuthorizationType != nil {
		var temp string
		temp = string(*typedInput.ComputeInstanceAuthorizationType)
		computeInstanceAuthorizationType := ComputeInstanceProperties_ComputeInstanceAuthorizationType(temp)
		properties.ComputeInstanceAuthorizationType = &computeInstanceAuthorizationType
	}

	// Set property "CustomServices":
	for _, item := range typedInput.CustomServices {
		var item1 CustomService
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.CustomServices = append(properties.CustomServices, item1)
	}

	// Set property "EnableNodePublicIp":
	if typedInput.EnableNodePublicIp != nil {
		enableNodePublicIp := *typedInput.EnableNodePublicIp
		properties.EnableNodePublicIp = &enableNodePublicIp
	}

	// Set property "PersonalComputeInstanceSettings":
	if typedInput.PersonalComputeInstanceSettings != nil {
		var personalComputeInstanceSettings1 PersonalComputeInstanceSettings
		err := personalComputeInstanceSettings1.PopulateFromARM(owner, *typedInput.PersonalComputeInstanceSettings)
		if err != nil {
			return err
		}
		personalComputeInstanceSettings := personalComputeInstanceSettings1
		properties.PersonalComputeInstanceSettings = &personalComputeInstanceSettings
	}

	// Set property "Schedules":
	if typedInput.Schedules != nil {
		var schedules1 ComputeSchedules
		err := schedules1.PopulateFromARM(owner, *typedInput.Schedules)
		if err != nil {
			return err
		}
		schedules := schedules1
		properties.Schedules = &schedules
	}

	// Set property "SetupScripts":
	if typedInput.SetupScripts != nil {
		var setupScripts1 SetupScripts
		err := setupScripts1.PopulateFromARM(owner, *typedInput.SetupScripts)
		if err != nil {
			return err
		}
		setupScripts := setupScripts1
		properties.SetupScripts = &setupScripts
	}

	// Set property "SshSettings":
	if typedInput.SshSettings != nil {
		var sshSettings1 ComputeInstanceSshSettings
		err := sshSettings1.PopulateFromARM(owner, *typedInput.SshSettings)
		if err != nil {
			return err
		}
		sshSettings := sshSettings1
		properties.SshSettings = &sshSettings
	}

	// Set property "Subnet":
	if typedInput.Subnet != nil {
		var subnet1 ResourceId
		err := subnet1.PopulateFromARM(owner, *typedInput.Subnet)
		if err != nil {
			return err
		}
		subnet := subnet1
		properties.Subnet = &subnet
	}

	// Set property "VmSize":
	if typedInput.VmSize != nil {
		vmSize := *typedInput.VmSize
		properties.VmSize = &vmSize
	}

	// No error
	return nil
}

// AssignProperties_From_ComputeInstanceProperties populates our ComputeInstanceProperties from the provided source ComputeInstanceProperties
func (properties *ComputeInstanceProperties) AssignProperties_From_ComputeInstanceProperties(source *storage.ComputeInstanceProperties) error {

	// ApplicationSharingPolicy
	if source.ApplicationSharingPolicy != nil {
		applicationSharingPolicy := *source.ApplicationSharingPolicy
		applicationSharingPolicyTemp := genruntime.ToEnum(applicationSharingPolicy, computeInstanceProperties_ApplicationSharingPolicy_Values)
		properties.ApplicationSharingPolicy = &applicationSharingPolicyTemp
	} else {
		properties.ApplicationSharingPolicy = nil
	}

	// ComputeInstanceAuthorizationType
	if source.ComputeInstanceAuthorizationType != nil {
		computeInstanceAuthorizationType := *source.ComputeInstanceAuthorizationType
		computeInstanceAuthorizationTypeTemp := genruntime.ToEnum(computeInstanceAuthorizationType, computeInstanceProperties_ComputeInstanceAuthorizationType_Values)
		properties.ComputeInstanceAuthorizationType = &computeInstanceAuthorizationTypeTemp
	} else {
		properties.ComputeInstanceAuthorizationType = nil
	}

	// CustomServices
	if source.CustomServices != nil {
		customServiceList := make([]CustomService, len(source.CustomServices))
		for customServiceIndex, customServiceItem := range source.CustomServices {
			// Shadow the loop variable to avoid aliasing
			customServiceItem := customServiceItem
			var customService CustomService
			err := customService.AssignProperties_From_CustomService(&customServiceItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_CustomService() to populate field CustomServices")
			}
			customServiceList[customServiceIndex] = customService
		}
		properties.CustomServices = customServiceList
	} else {
		properties.CustomServices = nil
	}

	// EnableNodePublicIp
	if source.EnableNodePublicIp != nil {
		enableNodePublicIp := *source.EnableNodePublicIp
		properties.EnableNodePublicIp = &enableNodePublicIp
	} else {
		properties.EnableNodePublicIp = nil
	}

	// PersonalComputeInstanceSettings
	if source.PersonalComputeInstanceSettings != nil {
		var personalComputeInstanceSetting PersonalComputeInstanceSettings
		err := personalComputeInstanceSetting.AssignProperties_From_PersonalComputeInstanceSettings(source.PersonalComputeInstanceSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PersonalComputeInstanceSettings() to populate field PersonalComputeInstanceSettings")
		}
		properties.PersonalComputeInstanceSettings = &personalComputeInstanceSetting
	} else {
		properties.PersonalComputeInstanceSettings = nil
	}

	// Schedules
	if source.Schedules != nil {
		var schedule ComputeSchedules
		err := schedule.AssignProperties_From_ComputeSchedules(source.Schedules)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ComputeSchedules() to populate field Schedules")
		}
		properties.Schedules = &schedule
	} else {
		properties.Schedules = nil
	}

	// SetupScripts
	if source.SetupScripts != nil {
		var setupScript SetupScripts
		err := setupScript.AssignProperties_From_SetupScripts(source.SetupScripts)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SetupScripts() to populate field SetupScripts")
		}
		properties.SetupScripts = &setupScript
	} else {
		properties.SetupScripts = nil
	}

	// SshSettings
	if source.SshSettings != nil {
		var sshSetting ComputeInstanceSshSettings
		err := sshSetting.AssignProperties_From_ComputeInstanceSshSettings(source.SshSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ComputeInstanceSshSettings() to populate field SshSettings")
		}
		properties.SshSettings = &sshSetting
	} else {
		properties.SshSettings = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet ResourceId
		err := subnet.AssignProperties_From_ResourceId(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceId() to populate field Subnet")
		}
		properties.Subnet = &subnet
	} else {
		properties.Subnet = nil
	}

	// VmSize
	properties.VmSize = genruntime.ClonePointerToString(source.VmSize)

	// No error
	return nil
}

// AssignProperties_To_ComputeInstanceProperties populates the provided destination ComputeInstanceProperties from our ComputeInstanceProperties
func (properties *ComputeInstanceProperties) AssignProperties_To_ComputeInstanceProperties(destination *storage.ComputeInstanceProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ApplicationSharingPolicy
	if properties.ApplicationSharingPolicy != nil {
		applicationSharingPolicy := string(*properties.ApplicationSharingPolicy)
		destination.ApplicationSharingPolicy = &applicationSharingPolicy
	} else {
		destination.ApplicationSharingPolicy = nil
	}

	// ComputeInstanceAuthorizationType
	if properties.ComputeInstanceAuthorizationType != nil {
		computeInstanceAuthorizationType := string(*properties.ComputeInstanceAuthorizationType)
		destination.ComputeInstanceAuthorizationType = &computeInstanceAuthorizationType
	} else {
		destination.ComputeInstanceAuthorizationType = nil
	}

	// CustomServices
	if properties.CustomServices != nil {
		customServiceList := make([]storage.CustomService, len(properties.CustomServices))
		for customServiceIndex, customServiceItem := range properties.CustomServices {
			// Shadow the loop variable to avoid aliasing
			customServiceItem := customServiceItem
			var customService storage.CustomService
			err := customServiceItem.AssignProperties_To_CustomService(&customService)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_CustomService() to populate field CustomServices")
			}
			customServiceList[customServiceIndex] = customService
		}
		destination.CustomServices = customServiceList
	} else {
		destination.CustomServices = nil
	}

	// EnableNodePublicIp
	if properties.EnableNodePublicIp != nil {
		enableNodePublicIp := *properties.EnableNodePublicIp
		destination.EnableNodePublicIp = &enableNodePublicIp
	} else {
		destination.EnableNodePublicIp = nil
	}

	// PersonalComputeInstanceSettings
	if properties.PersonalComputeInstanceSettings != nil {
		var personalComputeInstanceSetting storage.PersonalComputeInstanceSettings
		err := properties.PersonalComputeInstanceSettings.AssignProperties_To_PersonalComputeInstanceSettings(&personalComputeInstanceSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PersonalComputeInstanceSettings() to populate field PersonalComputeInstanceSettings")
		}
		destination.PersonalComputeInstanceSettings = &personalComputeInstanceSetting
	} else {
		destination.PersonalComputeInstanceSettings = nil
	}

	// Schedules
	if properties.Schedules != nil {
		var schedule storage.ComputeSchedules
		err := properties.Schedules.AssignProperties_To_ComputeSchedules(&schedule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ComputeSchedules() to populate field Schedules")
		}
		destination.Schedules = &schedule
	} else {
		destination.Schedules = nil
	}

	// SetupScripts
	if properties.SetupScripts != nil {
		var setupScript storage.SetupScripts
		err := properties.SetupScripts.AssignProperties_To_SetupScripts(&setupScript)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SetupScripts() to populate field SetupScripts")
		}
		destination.SetupScripts = &setupScript
	} else {
		destination.SetupScripts = nil
	}

	// SshSettings
	if properties.SshSettings != nil {
		var sshSetting storage.ComputeInstanceSshSettings
		err := properties.SshSettings.AssignProperties_To_ComputeInstanceSshSettings(&sshSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ComputeInstanceSshSettings() to populate field SshSettings")
		}
		destination.SshSettings = &sshSetting
	} else {
		destination.SshSettings = nil
	}

	// Subnet
	if properties.Subnet != nil {
		var subnet storage.ResourceId
		err := properties.Subnet.AssignProperties_To_ResourceId(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceId() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// VmSize
	destination.VmSize = genruntime.ClonePointerToString(properties.VmSize)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ComputeInstanceProperties_STATUS populates our ComputeInstanceProperties from the provided source ComputeInstanceProperties_STATUS
func (properties *ComputeInstanceProperties) Initialize_From_ComputeInstanceProperties_STATUS(source *ComputeInstanceProperties_STATUS) error {

	// ApplicationSharingPolicy
	if source.ApplicationSharingPolicy != nil {
		applicationSharingPolicy := genruntime.ToEnum(string(*source.ApplicationSharingPolicy), computeInstanceProperties_ApplicationSharingPolicy_Values)
		properties.ApplicationSharingPolicy = &applicationSharingPolicy
	} else {
		properties.ApplicationSharingPolicy = nil
	}

	// ComputeInstanceAuthorizationType
	if source.ComputeInstanceAuthorizationType != nil {
		computeInstanceAuthorizationType := genruntime.ToEnum(string(*source.ComputeInstanceAuthorizationType), computeInstanceProperties_ComputeInstanceAuthorizationType_Values)
		properties.ComputeInstanceAuthorizationType = &computeInstanceAuthorizationType
	} else {
		properties.ComputeInstanceAuthorizationType = nil
	}

	// CustomServices
	if source.CustomServices != nil {
		customServiceList := make([]CustomService, len(source.CustomServices))
		for customServiceIndex, customServiceItem := range source.CustomServices {
			// Shadow the loop variable to avoid aliasing
			customServiceItem := customServiceItem
			var customService CustomService
			err := customService.Initialize_From_CustomService_STATUS(&customServiceItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_CustomService_STATUS() to populate field CustomServices")
			}
			customServiceList[customServiceIndex] = customService
		}
		properties.CustomServices = customServiceList
	} else {
		properties.CustomServices = nil
	}

	// EnableNodePublicIp
	if source.EnableNodePublicIp != nil {
		enableNodePublicIp := *source.EnableNodePublicIp
		properties.EnableNodePublicIp = &enableNodePublicIp
	} else {
		properties.EnableNodePublicIp = nil
	}

	// PersonalComputeInstanceSettings
	if source.PersonalComputeInstanceSettings != nil {
		var personalComputeInstanceSetting PersonalComputeInstanceSettings
		err := personalComputeInstanceSetting.Initialize_From_PersonalComputeInstanceSettings_STATUS(source.PersonalComputeInstanceSettings)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_PersonalComputeInstanceSettings_STATUS() to populate field PersonalComputeInstanceSettings")
		}
		properties.PersonalComputeInstanceSettings = &personalComputeInstanceSetting
	} else {
		properties.PersonalComputeInstanceSettings = nil
	}

	// Schedules
	if source.Schedules != nil {
		var schedule ComputeSchedules
		err := schedule.Initialize_From_ComputeSchedules_STATUS(source.Schedules)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ComputeSchedules_STATUS() to populate field Schedules")
		}
		properties.Schedules = &schedule
	} else {
		properties.Schedules = nil
	}

	// SetupScripts
	if source.SetupScripts != nil {
		var setupScript SetupScripts
		err := setupScript.Initialize_From_SetupScripts_STATUS(source.SetupScripts)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SetupScripts_STATUS() to populate field SetupScripts")
		}
		properties.SetupScripts = &setupScript
	} else {
		properties.SetupScripts = nil
	}

	// SshSettings
	if source.SshSettings != nil {
		var sshSetting ComputeInstanceSshSettings
		err := sshSetting.Initialize_From_ComputeInstanceSshSettings_STATUS(source.SshSettings)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ComputeInstanceSshSettings_STATUS() to populate field SshSettings")
		}
		properties.SshSettings = &sshSetting
	} else {
		properties.SshSettings = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet ResourceId
		err := subnet.Initialize_From_ResourceId_STATUS(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ResourceId_STATUS() to populate field Subnet")
		}
		properties.Subnet = &subnet
	} else {
		properties.Subnet = nil
	}

	// VmSize
	properties.VmSize = genruntime.ClonePointerToString(source.VmSize)

	// No error
	return nil
}

// Compute Instance properties
type ComputeInstanceProperties_STATUS struct {
	// ApplicationSharingPolicy: Policy for sharing applications on this compute instance among users of parent workspace. If
	// Personal, only the creator can access applications on this compute instance. When Shared, any workspace user can access
	// applications on this instance depending on his/her assigned role.
	ApplicationSharingPolicy *ComputeInstanceProperties_ApplicationSharingPolicy_STATUS `json:"applicationSharingPolicy,omitempty"`

	// Applications: Describes available applications and their endpoints on this ComputeInstance.
	Applications []ComputeInstanceApplication_STATUS `json:"applications,omitempty"`

	// ComputeInstanceAuthorizationType: The Compute Instance Authorization type. Available values are personal (default).
	ComputeInstanceAuthorizationType *ComputeInstanceProperties_ComputeInstanceAuthorizationType_STATUS `json:"computeInstanceAuthorizationType,omitempty"`

	// ConnectivityEndpoints: Describes all connectivity endpoints available for this ComputeInstance.
	ConnectivityEndpoints *ComputeInstanceConnectivityEndpoints_STATUS `json:"connectivityEndpoints,omitempty"`

	// Containers: Describes informations of containers on this ComputeInstance.
	Containers []ComputeInstanceContainer_STATUS `json:"containers,omitempty"`

	// CreatedBy: Describes information on user who created this ComputeInstance.
	CreatedBy *ComputeInstanceCreatedBy_STATUS `json:"createdBy,omitempty"`

	// CustomServices: List of Custom Services added to the compute.
	CustomServices []CustomService_STATUS `json:"customServices,omitempty"`

	// DataDisks: Describes informations of dataDisks on this ComputeInstance.
	DataDisks []ComputeInstanceDataDisk_STATUS `json:"dataDisks,omitempty"`

	// DataMounts: Describes informations of dataMounts on this ComputeInstance.
	DataMounts []ComputeInstanceDataMount_STATUS `json:"dataMounts,omitempty"`

	// EnableNodePublicIp: Enable or disable node public IP address provisioning. Possible values are: Possible values are:
	// true - Indicates that the compute nodes will have public IPs provisioned. false - Indicates that the compute nodes will
	// have a private endpoint and no public IPs.
	EnableNodePublicIp *bool `json:"enableNodePublicIp,omitempty"`

	// Errors: Collection of errors encountered on this ComputeInstance.
	Errors []ErrorResponse_STATUS `json:"errors,omitempty"`

	// LastOperation: The last operation on ComputeInstance.
	LastOperation *ComputeInstanceLastOperation_STATUS `json:"lastOperation,omitempty"`

	// OsImageMetadata: Returns metadata about the operating system image for this compute instance.
	OsImageMetadata *ImageMetadata_STATUS `json:"osImageMetadata,omitempty"`

	// PersonalComputeInstanceSettings: Settings for a personal compute instance.
	PersonalComputeInstanceSettings *PersonalComputeInstanceSettings_STATUS `json:"personalComputeInstanceSettings,omitempty"`

	// Schedules: The list of schedules to be applied on the computes.
	Schedules *ComputeSchedules_STATUS `json:"schedules,omitempty"`

	// SetupScripts: Details of customized scripts to execute for setting up the cluster.
	SetupScripts *SetupScripts_STATUS `json:"setupScripts,omitempty"`

	// SshSettings: Specifies policy and settings for SSH access.
	SshSettings *ComputeInstanceSshSettings_STATUS `json:"sshSettings,omitempty"`

	// State: The current state of this ComputeInstance.
	State *ComputeInstanceState_STATUS `json:"state,omitempty"`

	// Subnet: Virtual network subnet resource ID the compute nodes belong to.
	Subnet *ResourceId_STATUS `json:"subnet,omitempty"`

	// Versions: ComputeInstance version.
	Versions *ComputeInstanceVersion_STATUS `json:"versions,omitempty"`

	// VmSize: Virtual Machine Size
	VmSize *string `json:"vmSize,omitempty"`
}

var _ genruntime.FromARMConverter = &ComputeInstanceProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *ComputeInstanceProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComputeInstanceProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *ComputeInstanceProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComputeInstanceProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComputeInstanceProperties_STATUS, got %T", armInput)
	}

	// Set property "ApplicationSharingPolicy":
	if typedInput.ApplicationSharingPolicy != nil {
		var temp string
		temp = string(*typedInput.ApplicationSharingPolicy)
		applicationSharingPolicy := ComputeInstanceProperties_ApplicationSharingPolicy_STATUS(temp)
		properties.ApplicationSharingPolicy = &applicationSharingPolicy
	}

	// Set property "Applications":
	for _, item := range typedInput.Applications {
		var item1 ComputeInstanceApplication_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.Applications = append(properties.Applications, item1)
	}

	// Set property "ComputeInstanceAuthorizationType":
	if typedInput.ComputeInstanceAuthorizationType != nil {
		var temp string
		temp = string(*typedInput.ComputeInstanceAuthorizationType)
		computeInstanceAuthorizationType := ComputeInstanceProperties_ComputeInstanceAuthorizationType_STATUS(temp)
		properties.ComputeInstanceAuthorizationType = &computeInstanceAuthorizationType
	}

	// Set property "ConnectivityEndpoints":
	if typedInput.ConnectivityEndpoints != nil {
		var connectivityEndpoints1 ComputeInstanceConnectivityEndpoints_STATUS
		err := connectivityEndpoints1.PopulateFromARM(owner, *typedInput.ConnectivityEndpoints)
		if err != nil {
			return err
		}
		connectivityEndpoints := connectivityEndpoints1
		properties.ConnectivityEndpoints = &connectivityEndpoints
	}

	// Set property "Containers":
	for _, item := range typedInput.Containers {
		var item1 ComputeInstanceContainer_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.Containers = append(properties.Containers, item1)
	}

	// Set property "CreatedBy":
	if typedInput.CreatedBy != nil {
		var createdBy1 ComputeInstanceCreatedBy_STATUS
		err := createdBy1.PopulateFromARM(owner, *typedInput.CreatedBy)
		if err != nil {
			return err
		}
		createdBy := createdBy1
		properties.CreatedBy = &createdBy
	}

	// Set property "CustomServices":
	for _, item := range typedInput.CustomServices {
		var item1 CustomService_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.CustomServices = append(properties.CustomServices, item1)
	}

	// Set property "DataDisks":
	for _, item := range typedInput.DataDisks {
		var item1 ComputeInstanceDataDisk_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.DataDisks = append(properties.DataDisks, item1)
	}

	// Set property "DataMounts":
	for _, item := range typedInput.DataMounts {
		var item1 ComputeInstanceDataMount_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.DataMounts = append(properties.DataMounts, item1)
	}

	// Set property "EnableNodePublicIp":
	if typedInput.EnableNodePublicIp != nil {
		enableNodePublicIp := *typedInput.EnableNodePublicIp
		properties.EnableNodePublicIp = &enableNodePublicIp
	}

	// Set property "Errors":
	for _, item := range typedInput.Errors {
		var item1 ErrorResponse_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.Errors = append(properties.Errors, item1)
	}

	// Set property "LastOperation":
	if typedInput.LastOperation != nil {
		var lastOperation1 ComputeInstanceLastOperation_STATUS
		err := lastOperation1.PopulateFromARM(owner, *typedInput.LastOperation)
		if err != nil {
			return err
		}
		lastOperation := lastOperation1
		properties.LastOperation = &lastOperation
	}

	// Set property "OsImageMetadata":
	if typedInput.OsImageMetadata != nil {
		var osImageMetadata1 ImageMetadata_STATUS
		err := osImageMetadata1.PopulateFromARM(owner, *typedInput.OsImageMetadata)
		if err != nil {
			return err
		}
		osImageMetadata := osImageMetadata1
		properties.OsImageMetadata = &osImageMetadata
	}

	// Set property "PersonalComputeInstanceSettings":
	if typedInput.PersonalComputeInstanceSettings != nil {
		var personalComputeInstanceSettings1 PersonalComputeInstanceSettings_STATUS
		err := personalComputeInstanceSettings1.PopulateFromARM(owner, *typedInput.PersonalComputeInstanceSettings)
		if err != nil {
			return err
		}
		personalComputeInstanceSettings := personalComputeInstanceSettings1
		properties.PersonalComputeInstanceSettings = &personalComputeInstanceSettings
	}

	// Set property "Schedules":
	if typedInput.Schedules != nil {
		var schedules1 ComputeSchedules_STATUS
		err := schedules1.PopulateFromARM(owner, *typedInput.Schedules)
		if err != nil {
			return err
		}
		schedules := schedules1
		properties.Schedules = &schedules
	}

	// Set property "SetupScripts":
	if typedInput.SetupScripts != nil {
		var setupScripts1 SetupScripts_STATUS
		err := setupScripts1.PopulateFromARM(owner, *typedInput.SetupScripts)
		if err != nil {
			return err
		}
		setupScripts := setupScripts1
		properties.SetupScripts = &setupScripts
	}

	// Set property "SshSettings":
	if typedInput.SshSettings != nil {
		var sshSettings1 ComputeInstanceSshSettings_STATUS
		err := sshSettings1.PopulateFromARM(owner, *typedInput.SshSettings)
		if err != nil {
			return err
		}
		sshSettings := sshSettings1
		properties.SshSettings = &sshSettings
	}

	// Set property "State":
	if typedInput.State != nil {
		var temp string
		temp = string(*typedInput.State)
		state := ComputeInstanceState_STATUS(temp)
		properties.State = &state
	}

	// Set property "Subnet":
	if typedInput.Subnet != nil {
		var subnet1 ResourceId_STATUS
		err := subnet1.PopulateFromARM(owner, *typedInput.Subnet)
		if err != nil {
			return err
		}
		subnet := subnet1
		properties.Subnet = &subnet
	}

	// Set property "Versions":
	if typedInput.Versions != nil {
		var versions1 ComputeInstanceVersion_STATUS
		err := versions1.PopulateFromARM(owner, *typedInput.Versions)
		if err != nil {
			return err
		}
		versions := versions1
		properties.Versions = &versions
	}

	// Set property "VmSize":
	if typedInput.VmSize != nil {
		vmSize := *typedInput.VmSize
		properties.VmSize = &vmSize
	}

	// No error
	return nil
}

// AssignProperties_From_ComputeInstanceProperties_STATUS populates our ComputeInstanceProperties_STATUS from the provided source ComputeInstanceProperties_STATUS
func (properties *ComputeInstanceProperties_STATUS) AssignProperties_From_ComputeInstanceProperties_STATUS(source *storage.ComputeInstanceProperties_STATUS) error {

	// ApplicationSharingPolicy
	if source.ApplicationSharingPolicy != nil {
		applicationSharingPolicy := *source.ApplicationSharingPolicy
		applicationSharingPolicyTemp := genruntime.ToEnum(applicationSharingPolicy, computeInstanceProperties_ApplicationSharingPolicy_STATUS_Values)
		properties.ApplicationSharingPolicy = &applicationSharingPolicyTemp
	} else {
		properties.ApplicationSharingPolicy = nil
	}

	// Applications
	if source.Applications != nil {
		applicationList := make([]ComputeInstanceApplication_STATUS, len(source.Applications))
		for applicationIndex, applicationItem := range source.Applications {
			// Shadow the loop variable to avoid aliasing
			applicationItem := applicationItem
			var application ComputeInstanceApplication_STATUS
			err := application.AssignProperties_From_ComputeInstanceApplication_STATUS(&applicationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ComputeInstanceApplication_STATUS() to populate field Applications")
			}
			applicationList[applicationIndex] = application
		}
		properties.Applications = applicationList
	} else {
		properties.Applications = nil
	}

	// ComputeInstanceAuthorizationType
	if source.ComputeInstanceAuthorizationType != nil {
		computeInstanceAuthorizationType := *source.ComputeInstanceAuthorizationType
		computeInstanceAuthorizationTypeTemp := genruntime.ToEnum(computeInstanceAuthorizationType, computeInstanceProperties_ComputeInstanceAuthorizationType_STATUS_Values)
		properties.ComputeInstanceAuthorizationType = &computeInstanceAuthorizationTypeTemp
	} else {
		properties.ComputeInstanceAuthorizationType = nil
	}

	// ConnectivityEndpoints
	if source.ConnectivityEndpoints != nil {
		var connectivityEndpoint ComputeInstanceConnectivityEndpoints_STATUS
		err := connectivityEndpoint.AssignProperties_From_ComputeInstanceConnectivityEndpoints_STATUS(source.ConnectivityEndpoints)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ComputeInstanceConnectivityEndpoints_STATUS() to populate field ConnectivityEndpoints")
		}
		properties.ConnectivityEndpoints = &connectivityEndpoint
	} else {
		properties.ConnectivityEndpoints = nil
	}

	// Containers
	if source.Containers != nil {
		containerList := make([]ComputeInstanceContainer_STATUS, len(source.Containers))
		for containerIndex, containerItem := range source.Containers {
			// Shadow the loop variable to avoid aliasing
			containerItem := containerItem
			var container ComputeInstanceContainer_STATUS
			err := container.AssignProperties_From_ComputeInstanceContainer_STATUS(&containerItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ComputeInstanceContainer_STATUS() to populate field Containers")
			}
			containerList[containerIndex] = container
		}
		properties.Containers = containerList
	} else {
		properties.Containers = nil
	}

	// CreatedBy
	if source.CreatedBy != nil {
		var createdBy ComputeInstanceCreatedBy_STATUS
		err := createdBy.AssignProperties_From_ComputeInstanceCreatedBy_STATUS(source.CreatedBy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ComputeInstanceCreatedBy_STATUS() to populate field CreatedBy")
		}
		properties.CreatedBy = &createdBy
	} else {
		properties.CreatedBy = nil
	}

	// CustomServices
	if source.CustomServices != nil {
		customServiceList := make([]CustomService_STATUS, len(source.CustomServices))
		for customServiceIndex, customServiceItem := range source.CustomServices {
			// Shadow the loop variable to avoid aliasing
			customServiceItem := customServiceItem
			var customService CustomService_STATUS
			err := customService.AssignProperties_From_CustomService_STATUS(&customServiceItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_CustomService_STATUS() to populate field CustomServices")
			}
			customServiceList[customServiceIndex] = customService
		}
		properties.CustomServices = customServiceList
	} else {
		properties.CustomServices = nil
	}

	// DataDisks
	if source.DataDisks != nil {
		dataDiskList := make([]ComputeInstanceDataDisk_STATUS, len(source.DataDisks))
		for dataDiskIndex, dataDiskItem := range source.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk ComputeInstanceDataDisk_STATUS
			err := dataDisk.AssignProperties_From_ComputeInstanceDataDisk_STATUS(&dataDiskItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ComputeInstanceDataDisk_STATUS() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		properties.DataDisks = dataDiskList
	} else {
		properties.DataDisks = nil
	}

	// DataMounts
	if source.DataMounts != nil {
		dataMountList := make([]ComputeInstanceDataMount_STATUS, len(source.DataMounts))
		for dataMountIndex, dataMountItem := range source.DataMounts {
			// Shadow the loop variable to avoid aliasing
			dataMountItem := dataMountItem
			var dataMount ComputeInstanceDataMount_STATUS
			err := dataMount.AssignProperties_From_ComputeInstanceDataMount_STATUS(&dataMountItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ComputeInstanceDataMount_STATUS() to populate field DataMounts")
			}
			dataMountList[dataMountIndex] = dataMount
		}
		properties.DataMounts = dataMountList
	} else {
		properties.DataMounts = nil
	}

	// EnableNodePublicIp
	if source.EnableNodePublicIp != nil {
		enableNodePublicIp := *source.EnableNodePublicIp
		properties.EnableNodePublicIp = &enableNodePublicIp
	} else {
		properties.EnableNodePublicIp = nil
	}

	// Errors
	if source.Errors != nil {
		errorList := make([]ErrorResponse_STATUS, len(source.Errors))
		for errorIndex, errorItem := range source.Errors {
			// Shadow the loop variable to avoid aliasing
			errorItem := errorItem
			var error ErrorResponse_STATUS
			err := error.AssignProperties_From_ErrorResponse_STATUS(&errorItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ErrorResponse_STATUS() to populate field Errors")
			}
			errorList[errorIndex] = error
		}
		properties.Errors = errorList
	} else {
		properties.Errors = nil
	}

	// LastOperation
	if source.LastOperation != nil {
		var lastOperation ComputeInstanceLastOperation_STATUS
		err := lastOperation.AssignProperties_From_ComputeInstanceLastOperation_STATUS(source.LastOperation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ComputeInstanceLastOperation_STATUS() to populate field LastOperation")
		}
		properties.LastOperation = &lastOperation
	} else {
		properties.LastOperation = nil
	}

	// OsImageMetadata
	if source.OsImageMetadata != nil {
		var osImageMetadatum ImageMetadata_STATUS
		err := osImageMetadatum.AssignProperties_From_ImageMetadata_STATUS(source.OsImageMetadata)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ImageMetadata_STATUS() to populate field OsImageMetadata")
		}
		properties.OsImageMetadata = &osImageMetadatum
	} else {
		properties.OsImageMetadata = nil
	}

	// PersonalComputeInstanceSettings
	if source.PersonalComputeInstanceSettings != nil {
		var personalComputeInstanceSetting PersonalComputeInstanceSettings_STATUS
		err := personalComputeInstanceSetting.AssignProperties_From_PersonalComputeInstanceSettings_STATUS(source.PersonalComputeInstanceSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PersonalComputeInstanceSettings_STATUS() to populate field PersonalComputeInstanceSettings")
		}
		properties.PersonalComputeInstanceSettings = &personalComputeInstanceSetting
	} else {
		properties.PersonalComputeInstanceSettings = nil
	}

	// Schedules
	if source.Schedules != nil {
		var schedule ComputeSchedules_STATUS
		err := schedule.AssignProperties_From_ComputeSchedules_STATUS(source.Schedules)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ComputeSchedules_STATUS() to populate field Schedules")
		}
		properties.Schedules = &schedule
	} else {
		properties.Schedules = nil
	}

	// SetupScripts
	if source.SetupScripts != nil {
		var setupScript SetupScripts_STATUS
		err := setupScript.AssignProperties_From_SetupScripts_STATUS(source.SetupScripts)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SetupScripts_STATUS() to populate field SetupScripts")
		}
		properties.SetupScripts = &setupScript
	} else {
		properties.SetupScripts = nil
	}

	// SshSettings
	if source.SshSettings != nil {
		var sshSetting ComputeInstanceSshSettings_STATUS
		err := sshSetting.AssignProperties_From_ComputeInstanceSshSettings_STATUS(source.SshSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ComputeInstanceSshSettings_STATUS() to populate field SshSettings")
		}
		properties.SshSettings = &sshSetting
	} else {
		properties.SshSettings = nil
	}

	// State
	if source.State != nil {
		state := *source.State
		stateTemp := genruntime.ToEnum(state, computeInstanceState_STATUS_Values)
		properties.State = &stateTemp
	} else {
		properties.State = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet ResourceId_STATUS
		err := subnet.AssignProperties_From_ResourceId_STATUS(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceId_STATUS() to populate field Subnet")
		}
		properties.Subnet = &subnet
	} else {
		properties.Subnet = nil
	}

	// Versions
	if source.Versions != nil {
		var version ComputeInstanceVersion_STATUS
		err := version.AssignProperties_From_ComputeInstanceVersion_STATUS(source.Versions)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ComputeInstanceVersion_STATUS() to populate field Versions")
		}
		properties.Versions = &version
	} else {
		properties.Versions = nil
	}

	// VmSize
	properties.VmSize = genruntime.ClonePointerToString(source.VmSize)

	// No error
	return nil
}

// AssignProperties_To_ComputeInstanceProperties_STATUS populates the provided destination ComputeInstanceProperties_STATUS from our ComputeInstanceProperties_STATUS
func (properties *ComputeInstanceProperties_STATUS) AssignProperties_To_ComputeInstanceProperties_STATUS(destination *storage.ComputeInstanceProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ApplicationSharingPolicy
	if properties.ApplicationSharingPolicy != nil {
		applicationSharingPolicy := string(*properties.ApplicationSharingPolicy)
		destination.ApplicationSharingPolicy = &applicationSharingPolicy
	} else {
		destination.ApplicationSharingPolicy = nil
	}

	// Applications
	if properties.Applications != nil {
		applicationList := make([]storage.ComputeInstanceApplication_STATUS, len(properties.Applications))
		for applicationIndex, applicationItem := range properties.Applications {
			// Shadow the loop variable to avoid aliasing
			applicationItem := applicationItem
			var application storage.ComputeInstanceApplication_STATUS
			err := applicationItem.AssignProperties_To_ComputeInstanceApplication_STATUS(&application)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ComputeInstanceApplication_STATUS() to populate field Applications")
			}
			applicationList[applicationIndex] = application
		}
		destination.Applications = applicationList
	} else {
		destination.Applications = nil
	}

	// ComputeInstanceAuthorizationType
	if properties.ComputeInstanceAuthorizationType != nil {
		computeInstanceAuthorizationType := string(*properties.ComputeInstanceAuthorizationType)
		destination.ComputeInstanceAuthorizationType = &computeInstanceAuthorizationType
	} else {
		destination.ComputeInstanceAuthorizationType = nil
	}

	// ConnectivityEndpoints
	if properties.ConnectivityEndpoints != nil {
		var connectivityEndpoint storage.ComputeInstanceConnectivityEndpoints_STATUS
		err := properties.ConnectivityEndpoints.AssignProperties_To_ComputeInstanceConnectivityEndpoints_STATUS(&connectivityEndpoint)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ComputeInstanceConnectivityEndpoints_STATUS() to populate field ConnectivityEndpoints")
		}
		destination.ConnectivityEndpoints = &connectivityEndpoint
	} else {
		destination.ConnectivityEndpoints = nil
	}

	// Containers
	if properties.Containers != nil {
		containerList := make([]storage.ComputeInstanceContainer_STATUS, len(properties.Containers))
		for containerIndex, containerItem := range properties.Containers {
			// Shadow the loop variable to avoid aliasing
			containerItem := containerItem
			var container storage.ComputeInstanceContainer_STATUS
			err := containerItem.AssignProperties_To_ComputeInstanceContainer_STATUS(&container)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ComputeInstanceContainer_STATUS() to populate field Containers")
			}
			containerList[containerIndex] = container
		}
		destination.Containers = containerList
	} else {
		destination.Containers = nil
	}

	// CreatedBy
	if properties.CreatedBy != nil {
		var createdBy storage.ComputeInstanceCreatedBy_STATUS
		err := properties.CreatedBy.AssignProperties_To_ComputeInstanceCreatedBy_STATUS(&createdBy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ComputeInstanceCreatedBy_STATUS() to populate field CreatedBy")
		}
		destination.CreatedBy = &createdBy
	} else {
		destination.CreatedBy = nil
	}

	// CustomServices
	if properties.CustomServices != nil {
		customServiceList := make([]storage.CustomService_STATUS, len(properties.CustomServices))
		for customServiceIndex, customServiceItem := range properties.CustomServices {
			// Shadow the loop variable to avoid aliasing
			customServiceItem := customServiceItem
			var customService storage.CustomService_STATUS
			err := customServiceItem.AssignProperties_To_CustomService_STATUS(&customService)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_CustomService_STATUS() to populate field CustomServices")
			}
			customServiceList[customServiceIndex] = customService
		}
		destination.CustomServices = customServiceList
	} else {
		destination.CustomServices = nil
	}

	// DataDisks
	if properties.DataDisks != nil {
		dataDiskList := make([]storage.ComputeInstanceDataDisk_STATUS, len(properties.DataDisks))
		for dataDiskIndex, dataDiskItem := range properties.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk storage.ComputeInstanceDataDisk_STATUS
			err := dataDiskItem.AssignProperties_To_ComputeInstanceDataDisk_STATUS(&dataDisk)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ComputeInstanceDataDisk_STATUS() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		destination.DataDisks = dataDiskList
	} else {
		destination.DataDisks = nil
	}

	// DataMounts
	if properties.DataMounts != nil {
		dataMountList := make([]storage.ComputeInstanceDataMount_STATUS, len(properties.DataMounts))
		for dataMountIndex, dataMountItem := range properties.DataMounts {
			// Shadow the loop variable to avoid aliasing
			dataMountItem := dataMountItem
			var dataMount storage.ComputeInstanceDataMount_STATUS
			err := dataMountItem.AssignProperties_To_ComputeInstanceDataMount_STATUS(&dataMount)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ComputeInstanceDataMount_STATUS() to populate field DataMounts")
			}
			dataMountList[dataMountIndex] = dataMount
		}
		destination.DataMounts = dataMountList
	} else {
		destination.DataMounts = nil
	}

	// EnableNodePublicIp
	if properties.EnableNodePublicIp != nil {
		enableNodePublicIp := *properties.EnableNodePublicIp
		destination.EnableNodePublicIp = &enableNodePublicIp
	} else {
		destination.EnableNodePublicIp = nil
	}

	// Errors
	if properties.Errors != nil {
		errorList := make([]storage.ErrorResponse_STATUS, len(properties.Errors))
		for errorIndex, errorItem := range properties.Errors {
			// Shadow the loop variable to avoid aliasing
			errorItem := errorItem
			var error storage.ErrorResponse_STATUS
			err := errorItem.AssignProperties_To_ErrorResponse_STATUS(&error)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ErrorResponse_STATUS() to populate field Errors")
			}
			errorList[errorIndex] = error
		}
		destination.Errors = errorList
	} else {
		destination.Errors = nil
	}

	// LastOperation
	if properties.LastOperation != nil {
		var lastOperation storage.ComputeInstanceLastOperation_STATUS
		err := properties.LastOperation.AssignProperties_To_ComputeInstanceLastOperation_STATUS(&lastOperation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ComputeInstanceLastOperation_STATUS() to populate field LastOperation")
		}
		destination.LastOperation = &lastOperation
	} else {
		destination.LastOperation = nil
	}

	// OsImageMetadata
	if properties.OsImageMetadata != nil {
		var osImageMetadatum storage.ImageMetadata_STATUS
		err := properties.OsImageMetadata.AssignProperties_To_ImageMetadata_STATUS(&osImageMetadatum)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ImageMetadata_STATUS() to populate field OsImageMetadata")
		}
		destination.OsImageMetadata = &osImageMetadatum
	} else {
		destination.OsImageMetadata = nil
	}

	// PersonalComputeInstanceSettings
	if properties.PersonalComputeInstanceSettings != nil {
		var personalComputeInstanceSetting storage.PersonalComputeInstanceSettings_STATUS
		err := properties.PersonalComputeInstanceSettings.AssignProperties_To_PersonalComputeInstanceSettings_STATUS(&personalComputeInstanceSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PersonalComputeInstanceSettings_STATUS() to populate field PersonalComputeInstanceSettings")
		}
		destination.PersonalComputeInstanceSettings = &personalComputeInstanceSetting
	} else {
		destination.PersonalComputeInstanceSettings = nil
	}

	// Schedules
	if properties.Schedules != nil {
		var schedule storage.ComputeSchedules_STATUS
		err := properties.Schedules.AssignProperties_To_ComputeSchedules_STATUS(&schedule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ComputeSchedules_STATUS() to populate field Schedules")
		}
		destination.Schedules = &schedule
	} else {
		destination.Schedules = nil
	}

	// SetupScripts
	if properties.SetupScripts != nil {
		var setupScript storage.SetupScripts_STATUS
		err := properties.SetupScripts.AssignProperties_To_SetupScripts_STATUS(&setupScript)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SetupScripts_STATUS() to populate field SetupScripts")
		}
		destination.SetupScripts = &setupScript
	} else {
		destination.SetupScripts = nil
	}

	// SshSettings
	if properties.SshSettings != nil {
		var sshSetting storage.ComputeInstanceSshSettings_STATUS
		err := properties.SshSettings.AssignProperties_To_ComputeInstanceSshSettings_STATUS(&sshSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ComputeInstanceSshSettings_STATUS() to populate field SshSettings")
		}
		destination.SshSettings = &sshSetting
	} else {
		destination.SshSettings = nil
	}

	// State
	if properties.State != nil {
		state := string(*properties.State)
		destination.State = &state
	} else {
		destination.State = nil
	}

	// Subnet
	if properties.Subnet != nil {
		var subnet storage.ResourceId_STATUS
		err := properties.Subnet.AssignProperties_To_ResourceId_STATUS(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceId_STATUS() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Versions
	if properties.Versions != nil {
		var version storage.ComputeInstanceVersion_STATUS
		err := properties.Versions.AssignProperties_To_ComputeInstanceVersion_STATUS(&version)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ComputeInstanceVersion_STATUS() to populate field Versions")
		}
		destination.Versions = &version
	} else {
		destination.Versions = nil
	}

	// VmSize
	destination.VmSize = genruntime.ClonePointerToString(properties.VmSize)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Databricks"}
type Databricks_ComputeType string

const Databricks_ComputeType_Databricks = Databricks_ComputeType("Databricks")

// Mapping from string to Databricks_ComputeType
var databricks_ComputeType_Values = map[string]Databricks_ComputeType{
	"databricks": Databricks_ComputeType_Databricks,
}

type Databricks_ComputeType_STATUS string

const Databricks_ComputeType_STATUS_Databricks = Databricks_ComputeType_STATUS("Databricks")

// Mapping from string to Databricks_ComputeType_STATUS
var databricks_ComputeType_STATUS_Values = map[string]Databricks_ComputeType_STATUS{
	"databricks": Databricks_ComputeType_STATUS_Databricks,
}

type Databricks_ProvisioningState_STATUS string

const (
	Databricks_ProvisioningState_STATUS_Canceled  = Databricks_ProvisioningState_STATUS("Canceled")
	Databricks_ProvisioningState_STATUS_Creating  = Databricks_ProvisioningState_STATUS("Creating")
	Databricks_ProvisioningState_STATUS_Deleting  = Databricks_ProvisioningState_STATUS("Deleting")
	Databricks_ProvisioningState_STATUS_Failed    = Databricks_ProvisioningState_STATUS("Failed")
	Databricks_ProvisioningState_STATUS_Succeeded = Databricks_ProvisioningState_STATUS("Succeeded")
	Databricks_ProvisioningState_STATUS_Unknown   = Databricks_ProvisioningState_STATUS("Unknown")
	Databricks_ProvisioningState_STATUS_Updating  = Databricks_ProvisioningState_STATUS("Updating")
)

// Mapping from string to Databricks_ProvisioningState_STATUS
var databricks_ProvisioningState_STATUS_Values = map[string]Databricks_ProvisioningState_STATUS{
	"canceled":  Databricks_ProvisioningState_STATUS_Canceled,
	"creating":  Databricks_ProvisioningState_STATUS_Creating,
	"deleting":  Databricks_ProvisioningState_STATUS_Deleting,
	"failed":    Databricks_ProvisioningState_STATUS_Failed,
	"succeeded": Databricks_ProvisioningState_STATUS_Succeeded,
	"unknown":   Databricks_ProvisioningState_STATUS_Unknown,
	"updating":  Databricks_ProvisioningState_STATUS_Updating,
}

// Properties of Databricks
type DatabricksProperties struct {
	// DatabricksAccessToken: Databricks access token
	DatabricksAccessToken *genruntime.SecretReference `json:"databricksAccessToken,omitempty"`

	// WorkspaceUrl: Workspace Url
	WorkspaceUrl *string `json:"workspaceUrl,omitempty"`
}

var _ genruntime.ARMTransformer = &DatabricksProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *DatabricksProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.DatabricksProperties{}

	// Set property "DatabricksAccessToken":
	if properties.DatabricksAccessToken != nil {
		databricksAccessTokenSecret, err := resolved.ResolvedSecrets.Lookup(*properties.DatabricksAccessToken)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property DatabricksAccessToken")
		}
		databricksAccessToken := databricksAccessTokenSecret
		result.DatabricksAccessToken = &databricksAccessToken
	}

	// Set property "WorkspaceUrl":
	if properties.WorkspaceUrl != nil {
		workspaceUrl := *properties.WorkspaceUrl
		result.WorkspaceUrl = &workspaceUrl
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *DatabricksProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DatabricksProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *DatabricksProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DatabricksProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DatabricksProperties, got %T", armInput)
	}

	// no assignment for property "DatabricksAccessToken"

	// Set property "WorkspaceUrl":
	if typedInput.WorkspaceUrl != nil {
		workspaceUrl := *typedInput.WorkspaceUrl
		properties.WorkspaceUrl = &workspaceUrl
	}

	// No error
	return nil
}

// AssignProperties_From_DatabricksProperties populates our DatabricksProperties from the provided source DatabricksProperties
func (properties *DatabricksProperties) AssignProperties_From_DatabricksProperties(source *storage.DatabricksProperties) error {

	// DatabricksAccessToken
	if source.DatabricksAccessToken != nil {
		databricksAccessToken := source.DatabricksAccessToken.Copy()
		properties.DatabricksAccessToken = &databricksAccessToken
	} else {
		properties.DatabricksAccessToken = nil
	}

	// WorkspaceUrl
	properties.WorkspaceUrl = genruntime.ClonePointerToString(source.WorkspaceUrl)

	// No error
	return nil
}

// AssignProperties_To_DatabricksProperties populates the provided destination DatabricksProperties from our DatabricksProperties
func (properties *DatabricksProperties) AssignProperties_To_DatabricksProperties(destination *storage.DatabricksProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DatabricksAccessToken
	if properties.DatabricksAccessToken != nil {
		databricksAccessToken := properties.DatabricksAccessToken.Copy()
		destination.DatabricksAccessToken = &databricksAccessToken
	} else {
		destination.DatabricksAccessToken = nil
	}

	// WorkspaceUrl
	destination.WorkspaceUrl = genruntime.ClonePointerToString(properties.WorkspaceUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DatabricksProperties_STATUS populates our DatabricksProperties from the provided source DatabricksProperties_STATUS
func (properties *DatabricksProperties) Initialize_From_DatabricksProperties_STATUS(source *DatabricksProperties_STATUS) error {

	// WorkspaceUrl
	properties.WorkspaceUrl = genruntime.ClonePointerToString(source.WorkspaceUrl)

	// No error
	return nil
}

// Properties of Databricks
type DatabricksProperties_STATUS struct {
	// WorkspaceUrl: Workspace Url
	WorkspaceUrl *string `json:"workspaceUrl,omitempty"`
}

var _ genruntime.FromARMConverter = &DatabricksProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *DatabricksProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DatabricksProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *DatabricksProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DatabricksProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DatabricksProperties_STATUS, got %T", armInput)
	}

	// Set property "WorkspaceUrl":
	if typedInput.WorkspaceUrl != nil {
		workspaceUrl := *typedInput.WorkspaceUrl
		properties.WorkspaceUrl = &workspaceUrl
	}

	// No error
	return nil
}

// AssignProperties_From_DatabricksProperties_STATUS populates our DatabricksProperties_STATUS from the provided source DatabricksProperties_STATUS
func (properties *DatabricksProperties_STATUS) AssignProperties_From_DatabricksProperties_STATUS(source *storage.DatabricksProperties_STATUS) error {

	// WorkspaceUrl
	properties.WorkspaceUrl = genruntime.ClonePointerToString(source.WorkspaceUrl)

	// No error
	return nil
}

// AssignProperties_To_DatabricksProperties_STATUS populates the provided destination DatabricksProperties_STATUS from our DatabricksProperties_STATUS
func (properties *DatabricksProperties_STATUS) AssignProperties_To_DatabricksProperties_STATUS(destination *storage.DatabricksProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// WorkspaceUrl
	destination.WorkspaceUrl = genruntime.ClonePointerToString(properties.WorkspaceUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"DataFactory"}
type DataFactory_ComputeType string

const DataFactory_ComputeType_DataFactory = DataFactory_ComputeType("DataFactory")

// Mapping from string to DataFactory_ComputeType
var dataFactory_ComputeType_Values = map[string]DataFactory_ComputeType{
	"datafactory": DataFactory_ComputeType_DataFactory,
}

type DataFactory_ComputeType_STATUS string

const DataFactory_ComputeType_STATUS_DataFactory = DataFactory_ComputeType_STATUS("DataFactory")

// Mapping from string to DataFactory_ComputeType_STATUS
var dataFactory_ComputeType_STATUS_Values = map[string]DataFactory_ComputeType_STATUS{
	"datafactory": DataFactory_ComputeType_STATUS_DataFactory,
}

type DataFactory_ProvisioningState_STATUS string

const (
	DataFactory_ProvisioningState_STATUS_Canceled  = DataFactory_ProvisioningState_STATUS("Canceled")
	DataFactory_ProvisioningState_STATUS_Creating  = DataFactory_ProvisioningState_STATUS("Creating")
	DataFactory_ProvisioningState_STATUS_Deleting  = DataFactory_ProvisioningState_STATUS("Deleting")
	DataFactory_ProvisioningState_STATUS_Failed    = DataFactory_ProvisioningState_STATUS("Failed")
	DataFactory_ProvisioningState_STATUS_Succeeded = DataFactory_ProvisioningState_STATUS("Succeeded")
	DataFactory_ProvisioningState_STATUS_Unknown   = DataFactory_ProvisioningState_STATUS("Unknown")
	DataFactory_ProvisioningState_STATUS_Updating  = DataFactory_ProvisioningState_STATUS("Updating")
)

// Mapping from string to DataFactory_ProvisioningState_STATUS
var dataFactory_ProvisioningState_STATUS_Values = map[string]DataFactory_ProvisioningState_STATUS{
	"canceled":  DataFactory_ProvisioningState_STATUS_Canceled,
	"creating":  DataFactory_ProvisioningState_STATUS_Creating,
	"deleting":  DataFactory_ProvisioningState_STATUS_Deleting,
	"failed":    DataFactory_ProvisioningState_STATUS_Failed,
	"succeeded": DataFactory_ProvisioningState_STATUS_Succeeded,
	"unknown":   DataFactory_ProvisioningState_STATUS_Unknown,
	"updating":  DataFactory_ProvisioningState_STATUS_Updating,
}

// +kubebuilder:validation:Enum={"DataLakeAnalytics"}
type DataLakeAnalytics_ComputeType string

const DataLakeAnalytics_ComputeType_DataLakeAnalytics = DataLakeAnalytics_ComputeType("DataLakeAnalytics")

// Mapping from string to DataLakeAnalytics_ComputeType
var dataLakeAnalytics_ComputeType_Values = map[string]DataLakeAnalytics_ComputeType{
	"datalakeanalytics": DataLakeAnalytics_ComputeType_DataLakeAnalytics,
}

type DataLakeAnalytics_ComputeType_STATUS string

const DataLakeAnalytics_ComputeType_STATUS_DataLakeAnalytics = DataLakeAnalytics_ComputeType_STATUS("DataLakeAnalytics")

// Mapping from string to DataLakeAnalytics_ComputeType_STATUS
var dataLakeAnalytics_ComputeType_STATUS_Values = map[string]DataLakeAnalytics_ComputeType_STATUS{
	"datalakeanalytics": DataLakeAnalytics_ComputeType_STATUS_DataLakeAnalytics,
}

type DataLakeAnalytics_Properties struct {
	// DataLakeStoreAccountName: DataLake Store Account Name
	DataLakeStoreAccountName *string `json:"dataLakeStoreAccountName,omitempty"`
}

var _ genruntime.ARMTransformer = &DataLakeAnalytics_Properties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *DataLakeAnalytics_Properties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.DataLakeAnalytics_Properties{}

	// Set property "DataLakeStoreAccountName":
	if properties.DataLakeStoreAccountName != nil {
		dataLakeStoreAccountName := *properties.DataLakeStoreAccountName
		result.DataLakeStoreAccountName = &dataLakeStoreAccountName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *DataLakeAnalytics_Properties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DataLakeAnalytics_Properties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *DataLakeAnalytics_Properties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DataLakeAnalytics_Properties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DataLakeAnalytics_Properties, got %T", armInput)
	}

	// Set property "DataLakeStoreAccountName":
	if typedInput.DataLakeStoreAccountName != nil {
		dataLakeStoreAccountName := *typedInput.DataLakeStoreAccountName
		properties.DataLakeStoreAccountName = &dataLakeStoreAccountName
	}

	// No error
	return nil
}

// AssignProperties_From_DataLakeAnalytics_Properties populates our DataLakeAnalytics_Properties from the provided source DataLakeAnalytics_Properties
func (properties *DataLakeAnalytics_Properties) AssignProperties_From_DataLakeAnalytics_Properties(source *storage.DataLakeAnalytics_Properties) error {

	// DataLakeStoreAccountName
	properties.DataLakeStoreAccountName = genruntime.ClonePointerToString(source.DataLakeStoreAccountName)

	// No error
	return nil
}

// AssignProperties_To_DataLakeAnalytics_Properties populates the provided destination DataLakeAnalytics_Properties from our DataLakeAnalytics_Properties
func (properties *DataLakeAnalytics_Properties) AssignProperties_To_DataLakeAnalytics_Properties(destination *storage.DataLakeAnalytics_Properties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataLakeStoreAccountName
	destination.DataLakeStoreAccountName = genruntime.ClonePointerToString(properties.DataLakeStoreAccountName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DataLakeAnalytics_Properties_STATUS populates our DataLakeAnalytics_Properties from the provided source DataLakeAnalytics_Properties_STATUS
func (properties *DataLakeAnalytics_Properties) Initialize_From_DataLakeAnalytics_Properties_STATUS(source *DataLakeAnalytics_Properties_STATUS) error {

	// DataLakeStoreAccountName
	properties.DataLakeStoreAccountName = genruntime.ClonePointerToString(source.DataLakeStoreAccountName)

	// No error
	return nil
}

type DataLakeAnalytics_Properties_STATUS struct {
	// DataLakeStoreAccountName: DataLake Store Account Name
	DataLakeStoreAccountName *string `json:"dataLakeStoreAccountName,omitempty"`
}

var _ genruntime.FromARMConverter = &DataLakeAnalytics_Properties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *DataLakeAnalytics_Properties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DataLakeAnalytics_Properties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *DataLakeAnalytics_Properties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DataLakeAnalytics_Properties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DataLakeAnalytics_Properties_STATUS, got %T", armInput)
	}

	// Set property "DataLakeStoreAccountName":
	if typedInput.DataLakeStoreAccountName != nil {
		dataLakeStoreAccountName := *typedInput.DataLakeStoreAccountName
		properties.DataLakeStoreAccountName = &dataLakeStoreAccountName
	}

	// No error
	return nil
}

// AssignProperties_From_DataLakeAnalytics_Properties_STATUS populates our DataLakeAnalytics_Properties_STATUS from the provided source DataLakeAnalytics_Properties_STATUS
func (properties *DataLakeAnalytics_Properties_STATUS) AssignProperties_From_DataLakeAnalytics_Properties_STATUS(source *storage.DataLakeAnalytics_Properties_STATUS) error {

	// DataLakeStoreAccountName
	properties.DataLakeStoreAccountName = genruntime.ClonePointerToString(source.DataLakeStoreAccountName)

	// No error
	return nil
}

// AssignProperties_To_DataLakeAnalytics_Properties_STATUS populates the provided destination DataLakeAnalytics_Properties_STATUS from our DataLakeAnalytics_Properties_STATUS
func (properties *DataLakeAnalytics_Properties_STATUS) AssignProperties_To_DataLakeAnalytics_Properties_STATUS(destination *storage.DataLakeAnalytics_Properties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataLakeStoreAccountName
	destination.DataLakeStoreAccountName = genruntime.ClonePointerToString(properties.DataLakeStoreAccountName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DataLakeAnalytics_ProvisioningState_STATUS string

const (
	DataLakeAnalytics_ProvisioningState_STATUS_Canceled  = DataLakeAnalytics_ProvisioningState_STATUS("Canceled")
	DataLakeAnalytics_ProvisioningState_STATUS_Creating  = DataLakeAnalytics_ProvisioningState_STATUS("Creating")
	DataLakeAnalytics_ProvisioningState_STATUS_Deleting  = DataLakeAnalytics_ProvisioningState_STATUS("Deleting")
	DataLakeAnalytics_ProvisioningState_STATUS_Failed    = DataLakeAnalytics_ProvisioningState_STATUS("Failed")
	DataLakeAnalytics_ProvisioningState_STATUS_Succeeded = DataLakeAnalytics_ProvisioningState_STATUS("Succeeded")
	DataLakeAnalytics_ProvisioningState_STATUS_Unknown   = DataLakeAnalytics_ProvisioningState_STATUS("Unknown")
	DataLakeAnalytics_ProvisioningState_STATUS_Updating  = DataLakeAnalytics_ProvisioningState_STATUS("Updating")
)

// Mapping from string to DataLakeAnalytics_ProvisioningState_STATUS
var dataLakeAnalytics_ProvisioningState_STATUS_Values = map[string]DataLakeAnalytics_ProvisioningState_STATUS{
	"canceled":  DataLakeAnalytics_ProvisioningState_STATUS_Canceled,
	"creating":  DataLakeAnalytics_ProvisioningState_STATUS_Creating,
	"deleting":  DataLakeAnalytics_ProvisioningState_STATUS_Deleting,
	"failed":    DataLakeAnalytics_ProvisioningState_STATUS_Failed,
	"succeeded": DataLakeAnalytics_ProvisioningState_STATUS_Succeeded,
	"unknown":   DataLakeAnalytics_ProvisioningState_STATUS_Unknown,
	"updating":  DataLakeAnalytics_ProvisioningState_STATUS_Updating,
}

// Common error response for all Azure Resource Manager APIs to return error details for failed operations. (This also
// follows the OData error response format.).
type ErrorResponse_STATUS struct {
	// Error: The error object.
	Error *ErrorDetail_STATUS `json:"error,omitempty"`
}

var _ genruntime.FromARMConverter = &ErrorResponse_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (response *ErrorResponse_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ErrorResponse_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (response *ErrorResponse_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ErrorResponse_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ErrorResponse_STATUS, got %T", armInput)
	}

	// Set property "Error":
	if typedInput.Error != nil {
		var error1 ErrorDetail_STATUS
		err := error1.PopulateFromARM(owner, *typedInput.Error)
		if err != nil {
			return err
		}
		error := error1
		response.Error = &error
	}

	// No error
	return nil
}

// AssignProperties_From_ErrorResponse_STATUS populates our ErrorResponse_STATUS from the provided source ErrorResponse_STATUS
func (response *ErrorResponse_STATUS) AssignProperties_From_ErrorResponse_STATUS(source *storage.ErrorResponse_STATUS) error {

	// Error
	if source.Error != nil {
		var error ErrorDetail_STATUS
		err := error.AssignProperties_From_ErrorDetail_STATUS(source.Error)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ErrorDetail_STATUS() to populate field Error")
		}
		response.Error = &error
	} else {
		response.Error = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ErrorResponse_STATUS populates the provided destination ErrorResponse_STATUS from our ErrorResponse_STATUS
func (response *ErrorResponse_STATUS) AssignProperties_To_ErrorResponse_STATUS(destination *storage.ErrorResponse_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Error
	if response.Error != nil {
		var error storage.ErrorDetail_STATUS
		err := response.Error.AssignProperties_To_ErrorDetail_STATUS(&error)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ErrorDetail_STATUS() to populate field Error")
		}
		destination.Error = &error
	} else {
		destination.Error = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"HDInsight"}
type HDInsight_ComputeType string

const HDInsight_ComputeType_HDInsight = HDInsight_ComputeType("HDInsight")

// Mapping from string to HDInsight_ComputeType
var hDInsight_ComputeType_Values = map[string]HDInsight_ComputeType{
	"hdinsight": HDInsight_ComputeType_HDInsight,
}

type HDInsight_ComputeType_STATUS string

const HDInsight_ComputeType_STATUS_HDInsight = HDInsight_ComputeType_STATUS("HDInsight")

// Mapping from string to HDInsight_ComputeType_STATUS
var hDInsight_ComputeType_STATUS_Values = map[string]HDInsight_ComputeType_STATUS{
	"hdinsight": HDInsight_ComputeType_STATUS_HDInsight,
}

type HDInsight_ProvisioningState_STATUS string

const (
	HDInsight_ProvisioningState_STATUS_Canceled  = HDInsight_ProvisioningState_STATUS("Canceled")
	HDInsight_ProvisioningState_STATUS_Creating  = HDInsight_ProvisioningState_STATUS("Creating")
	HDInsight_ProvisioningState_STATUS_Deleting  = HDInsight_ProvisioningState_STATUS("Deleting")
	HDInsight_ProvisioningState_STATUS_Failed    = HDInsight_ProvisioningState_STATUS("Failed")
	HDInsight_ProvisioningState_STATUS_Succeeded = HDInsight_ProvisioningState_STATUS("Succeeded")
	HDInsight_ProvisioningState_STATUS_Unknown   = HDInsight_ProvisioningState_STATUS("Unknown")
	HDInsight_ProvisioningState_STATUS_Updating  = HDInsight_ProvisioningState_STATUS("Updating")
)

// Mapping from string to HDInsight_ProvisioningState_STATUS
var hDInsight_ProvisioningState_STATUS_Values = map[string]HDInsight_ProvisioningState_STATUS{
	"canceled":  HDInsight_ProvisioningState_STATUS_Canceled,
	"creating":  HDInsight_ProvisioningState_STATUS_Creating,
	"deleting":  HDInsight_ProvisioningState_STATUS_Deleting,
	"failed":    HDInsight_ProvisioningState_STATUS_Failed,
	"succeeded": HDInsight_ProvisioningState_STATUS_Succeeded,
	"unknown":   HDInsight_ProvisioningState_STATUS_Unknown,
	"updating":  HDInsight_ProvisioningState_STATUS_Updating,
}

// HDInsight compute properties
type HDInsightProperties struct {
	// Address: Public IP address of the master node of the cluster.
	Address *string `json:"address,omitempty"`

	// AdministratorAccount: Admin credentials for master node of the cluster
	AdministratorAccount *VirtualMachineSshCredentials `json:"administratorAccount,omitempty"`

	// SshPort: Port open for ssh connections on the master node of the cluster.
	SshPort *int `json:"sshPort,omitempty"`
}

var _ genruntime.ARMTransformer = &HDInsightProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *HDInsightProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.HDInsightProperties{}

	// Set property "Address":
	if properties.Address != nil {
		address := *properties.Address
		result.Address = &address
	}

	// Set property "AdministratorAccount":
	if properties.AdministratorAccount != nil {
		administratorAccount_ARM, err := (*properties.AdministratorAccount).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		administratorAccount := *administratorAccount_ARM.(*arm.VirtualMachineSshCredentials)
		result.AdministratorAccount = &administratorAccount
	}

	// Set property "SshPort":
	if properties.SshPort != nil {
		sshPort := *properties.SshPort
		result.SshPort = &sshPort
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *HDInsightProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HDInsightProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *HDInsightProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HDInsightProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HDInsightProperties, got %T", armInput)
	}

	// Set property "Address":
	if typedInput.Address != nil {
		address := *typedInput.Address
		properties.Address = &address
	}

	// Set property "AdministratorAccount":
	if typedInput.AdministratorAccount != nil {
		var administratorAccount1 VirtualMachineSshCredentials
		err := administratorAccount1.PopulateFromARM(owner, *typedInput.AdministratorAccount)
		if err != nil {
			return err
		}
		administratorAccount := administratorAccount1
		properties.AdministratorAccount = &administratorAccount
	}

	// Set property "SshPort":
	if typedInput.SshPort != nil {
		sshPort := *typedInput.SshPort
		properties.SshPort = &sshPort
	}

	// No error
	return nil
}

// AssignProperties_From_HDInsightProperties populates our HDInsightProperties from the provided source HDInsightProperties
func (properties *HDInsightProperties) AssignProperties_From_HDInsightProperties(source *storage.HDInsightProperties) error {

	// Address
	properties.Address = genruntime.ClonePointerToString(source.Address)

	// AdministratorAccount
	if source.AdministratorAccount != nil {
		var administratorAccount VirtualMachineSshCredentials
		err := administratorAccount.AssignProperties_From_VirtualMachineSshCredentials(source.AdministratorAccount)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineSshCredentials() to populate field AdministratorAccount")
		}
		properties.AdministratorAccount = &administratorAccount
	} else {
		properties.AdministratorAccount = nil
	}

	// SshPort
	properties.SshPort = genruntime.ClonePointerToInt(source.SshPort)

	// No error
	return nil
}

// AssignProperties_To_HDInsightProperties populates the provided destination HDInsightProperties from our HDInsightProperties
func (properties *HDInsightProperties) AssignProperties_To_HDInsightProperties(destination *storage.HDInsightProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Address
	destination.Address = genruntime.ClonePointerToString(properties.Address)

	// AdministratorAccount
	if properties.AdministratorAccount != nil {
		var administratorAccount storage.VirtualMachineSshCredentials
		err := properties.AdministratorAccount.AssignProperties_To_VirtualMachineSshCredentials(&administratorAccount)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineSshCredentials() to populate field AdministratorAccount")
		}
		destination.AdministratorAccount = &administratorAccount
	} else {
		destination.AdministratorAccount = nil
	}

	// SshPort
	destination.SshPort = genruntime.ClonePointerToInt(properties.SshPort)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_HDInsightProperties_STATUS populates our HDInsightProperties from the provided source HDInsightProperties_STATUS
func (properties *HDInsightProperties) Initialize_From_HDInsightProperties_STATUS(source *HDInsightProperties_STATUS) error {

	// Address
	properties.Address = genruntime.ClonePointerToString(source.Address)

	// AdministratorAccount
	if source.AdministratorAccount != nil {
		var administratorAccount VirtualMachineSshCredentials
		err := administratorAccount.Initialize_From_VirtualMachineSshCredentials_STATUS(source.AdministratorAccount)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_VirtualMachineSshCredentials_STATUS() to populate field AdministratorAccount")
		}
		properties.AdministratorAccount = &administratorAccount
	} else {
		properties.AdministratorAccount = nil
	}

	// SshPort
	properties.SshPort = genruntime.ClonePointerToInt(source.SshPort)

	// No error
	return nil
}

// HDInsight compute properties
type HDInsightProperties_STATUS struct {
	// Address: Public IP address of the master node of the cluster.
	Address *string `json:"address,omitempty"`

	// AdministratorAccount: Admin credentials for master node of the cluster
	AdministratorAccount *VirtualMachineSshCredentials_STATUS `json:"administratorAccount,omitempty"`

	// SshPort: Port open for ssh connections on the master node of the cluster.
	SshPort *int `json:"sshPort,omitempty"`
}

var _ genruntime.FromARMConverter = &HDInsightProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *HDInsightProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HDInsightProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *HDInsightProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HDInsightProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HDInsightProperties_STATUS, got %T", armInput)
	}

	// Set property "Address":
	if typedInput.Address != nil {
		address := *typedInput.Address
		properties.Address = &address
	}

	// Set property "AdministratorAccount":
	if typedInput.AdministratorAccount != nil {
		var administratorAccount1 VirtualMachineSshCredentials_STATUS
		err := administratorAccount1.PopulateFromARM(owner, *typedInput.AdministratorAccount)
		if err != nil {
			return err
		}
		administratorAccount := administratorAccount1
		properties.AdministratorAccount = &administratorAccount
	}

	// Set property "SshPort":
	if typedInput.SshPort != nil {
		sshPort := *typedInput.SshPort
		properties.SshPort = &sshPort
	}

	// No error
	return nil
}

// AssignProperties_From_HDInsightProperties_STATUS populates our HDInsightProperties_STATUS from the provided source HDInsightProperties_STATUS
func (properties *HDInsightProperties_STATUS) AssignProperties_From_HDInsightProperties_STATUS(source *storage.HDInsightProperties_STATUS) error {

	// Address
	properties.Address = genruntime.ClonePointerToString(source.Address)

	// AdministratorAccount
	if source.AdministratorAccount != nil {
		var administratorAccount VirtualMachineSshCredentials_STATUS
		err := administratorAccount.AssignProperties_From_VirtualMachineSshCredentials_STATUS(source.AdministratorAccount)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineSshCredentials_STATUS() to populate field AdministratorAccount")
		}
		properties.AdministratorAccount = &administratorAccount
	} else {
		properties.AdministratorAccount = nil
	}

	// SshPort
	properties.SshPort = genruntime.ClonePointerToInt(source.SshPort)

	// No error
	return nil
}

// AssignProperties_To_HDInsightProperties_STATUS populates the provided destination HDInsightProperties_STATUS from our HDInsightProperties_STATUS
func (properties *HDInsightProperties_STATUS) AssignProperties_To_HDInsightProperties_STATUS(destination *storage.HDInsightProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Address
	destination.Address = genruntime.ClonePointerToString(properties.Address)

	// AdministratorAccount
	if properties.AdministratorAccount != nil {
		var administratorAccount storage.VirtualMachineSshCredentials_STATUS
		err := properties.AdministratorAccount.AssignProperties_To_VirtualMachineSshCredentials_STATUS(&administratorAccount)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineSshCredentials_STATUS() to populate field AdministratorAccount")
		}
		destination.AdministratorAccount = &administratorAccount
	} else {
		destination.AdministratorAccount = nil
	}

	// SshPort
	destination.SshPort = genruntime.ClonePointerToInt(properties.SshPort)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Kubernetes"}
type Kubernetes_ComputeType string

const Kubernetes_ComputeType_Kubernetes = Kubernetes_ComputeType("Kubernetes")

// Mapping from string to Kubernetes_ComputeType
var kubernetes_ComputeType_Values = map[string]Kubernetes_ComputeType{
	"kubernetes": Kubernetes_ComputeType_Kubernetes,
}

type Kubernetes_ComputeType_STATUS string

const Kubernetes_ComputeType_STATUS_Kubernetes = Kubernetes_ComputeType_STATUS("Kubernetes")

// Mapping from string to Kubernetes_ComputeType_STATUS
var kubernetes_ComputeType_STATUS_Values = map[string]Kubernetes_ComputeType_STATUS{
	"kubernetes": Kubernetes_ComputeType_STATUS_Kubernetes,
}

type Kubernetes_ProvisioningState_STATUS string

const (
	Kubernetes_ProvisioningState_STATUS_Canceled  = Kubernetes_ProvisioningState_STATUS("Canceled")
	Kubernetes_ProvisioningState_STATUS_Creating  = Kubernetes_ProvisioningState_STATUS("Creating")
	Kubernetes_ProvisioningState_STATUS_Deleting  = Kubernetes_ProvisioningState_STATUS("Deleting")
	Kubernetes_ProvisioningState_STATUS_Failed    = Kubernetes_ProvisioningState_STATUS("Failed")
	Kubernetes_ProvisioningState_STATUS_Succeeded = Kubernetes_ProvisioningState_STATUS("Succeeded")
	Kubernetes_ProvisioningState_STATUS_Unknown   = Kubernetes_ProvisioningState_STATUS("Unknown")
	Kubernetes_ProvisioningState_STATUS_Updating  = Kubernetes_ProvisioningState_STATUS("Updating")
)

// Mapping from string to Kubernetes_ProvisioningState_STATUS
var kubernetes_ProvisioningState_STATUS_Values = map[string]Kubernetes_ProvisioningState_STATUS{
	"canceled":  Kubernetes_ProvisioningState_STATUS_Canceled,
	"creating":  Kubernetes_ProvisioningState_STATUS_Creating,
	"deleting":  Kubernetes_ProvisioningState_STATUS_Deleting,
	"failed":    Kubernetes_ProvisioningState_STATUS_Failed,
	"succeeded": Kubernetes_ProvisioningState_STATUS_Succeeded,
	"unknown":   Kubernetes_ProvisioningState_STATUS_Unknown,
	"updating":  Kubernetes_ProvisioningState_STATUS_Updating,
}

// Kubernetes properties
type KubernetesProperties struct {
	// DefaultInstanceType: Default instance type
	DefaultInstanceType *string `json:"defaultInstanceType,omitempty"`

	// ExtensionInstanceReleaseTrain: Extension instance release train.
	ExtensionInstanceReleaseTrain *string `json:"extensionInstanceReleaseTrain,omitempty"`

	// ExtensionPrincipalId: Extension principal-id.
	ExtensionPrincipalId *string `json:"extensionPrincipalId,omitempty" optionalConfigMapPair:"ExtensionPrincipalId"`

	// ExtensionPrincipalIdFromConfig: Extension principal-id.
	ExtensionPrincipalIdFromConfig *genruntime.ConfigMapReference `json:"extensionPrincipalIdFromConfig,omitempty" optionalConfigMapPair:"ExtensionPrincipalId"`

	// InstanceTypes: Instance Type Schema
	InstanceTypes map[string]InstanceTypeSchema `json:"instanceTypes,omitempty"`

	// Namespace: Compute namespace
	Namespace *string `json:"namespace,omitempty"`

	// RelayConnectionString: Relay connection string.
	RelayConnectionString *genruntime.SecretReference `json:"relayConnectionString,omitempty"`

	// ServiceBusConnectionString: ServiceBus connection string.
	ServiceBusConnectionString *genruntime.SecretReference `json:"serviceBusConnectionString,omitempty"`

	// VcName: VC name.
	VcName *string `json:"vcName,omitempty"`
}

var _ genruntime.ARMTransformer = &KubernetesProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *KubernetesProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.KubernetesProperties{}

	// Set property "DefaultInstanceType":
	if properties.DefaultInstanceType != nil {
		defaultInstanceType := *properties.DefaultInstanceType
		result.DefaultInstanceType = &defaultInstanceType
	}

	// Set property "ExtensionInstanceReleaseTrain":
	if properties.ExtensionInstanceReleaseTrain != nil {
		extensionInstanceReleaseTrain := *properties.ExtensionInstanceReleaseTrain
		result.ExtensionInstanceReleaseTrain = &extensionInstanceReleaseTrain
	}

	// Set property "ExtensionPrincipalId":
	if properties.ExtensionPrincipalId != nil {
		extensionPrincipalId := *properties.ExtensionPrincipalId
		result.ExtensionPrincipalId = &extensionPrincipalId
	}
	if properties.ExtensionPrincipalIdFromConfig != nil {
		extensionPrincipalIdValue, err := resolved.ResolvedConfigMaps.Lookup(*properties.ExtensionPrincipalIdFromConfig)
		if err != nil {
			return nil, errors.Wrap(err, "looking up configmap for property ExtensionPrincipalId")
		}
		extensionPrincipalId := extensionPrincipalIdValue
		result.ExtensionPrincipalId = &extensionPrincipalId
	}

	// Set property "InstanceTypes":
	if properties.InstanceTypes != nil {
		result.InstanceTypes = make(map[string]arm.InstanceTypeSchema, len(properties.InstanceTypes))
		for key, value := range properties.InstanceTypes {
			value_ARM, err := value.ConvertToARM(resolved)
			if err != nil {
				return nil, err
			}
			result.InstanceTypes[key] = *value_ARM.(*arm.InstanceTypeSchema)
		}
	}

	// Set property "Namespace":
	if properties.Namespace != nil {
		namespace := *properties.Namespace
		result.Namespace = &namespace
	}

	// Set property "RelayConnectionString":
	if properties.RelayConnectionString != nil {
		relayConnectionStringSecret, err := resolved.ResolvedSecrets.Lookup(*properties.RelayConnectionString)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property RelayConnectionString")
		}
		relayConnectionString := relayConnectionStringSecret
		result.RelayConnectionString = &relayConnectionString
	}

	// Set property "ServiceBusConnectionString":
	if properties.ServiceBusConnectionString != nil {
		serviceBusConnectionStringSecret, err := resolved.ResolvedSecrets.Lookup(*properties.ServiceBusConnectionString)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property ServiceBusConnectionString")
		}
		serviceBusConnectionString := serviceBusConnectionStringSecret
		result.ServiceBusConnectionString = &serviceBusConnectionString
	}

	// Set property "VcName":
	if properties.VcName != nil {
		vcName := *properties.VcName
		result.VcName = &vcName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *KubernetesProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KubernetesProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *KubernetesProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KubernetesProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KubernetesProperties, got %T", armInput)
	}

	// Set property "DefaultInstanceType":
	if typedInput.DefaultInstanceType != nil {
		defaultInstanceType := *typedInput.DefaultInstanceType
		properties.DefaultInstanceType = &defaultInstanceType
	}

	// Set property "ExtensionInstanceReleaseTrain":
	if typedInput.ExtensionInstanceReleaseTrain != nil {
		extensionInstanceReleaseTrain := *typedInput.ExtensionInstanceReleaseTrain
		properties.ExtensionInstanceReleaseTrain = &extensionInstanceReleaseTrain
	}

	// Set property "ExtensionPrincipalId":
	if typedInput.ExtensionPrincipalId != nil {
		extensionPrincipalId := *typedInput.ExtensionPrincipalId
		properties.ExtensionPrincipalId = &extensionPrincipalId
	}

	// no assignment for property "ExtensionPrincipalIdFromConfig"

	// Set property "InstanceTypes":
	if typedInput.InstanceTypes != nil {
		properties.InstanceTypes = make(map[string]InstanceTypeSchema, len(typedInput.InstanceTypes))
		for key, value := range typedInput.InstanceTypes {
			var value1 InstanceTypeSchema
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			properties.InstanceTypes[key] = value1
		}
	}

	// Set property "Namespace":
	if typedInput.Namespace != nil {
		namespace := *typedInput.Namespace
		properties.Namespace = &namespace
	}

	// no assignment for property "RelayConnectionString"

	// no assignment for property "ServiceBusConnectionString"

	// Set property "VcName":
	if typedInput.VcName != nil {
		vcName := *typedInput.VcName
		properties.VcName = &vcName
	}

	// No error
	return nil
}

// AssignProperties_From_KubernetesProperties populates our KubernetesProperties from the provided source KubernetesProperties
func (properties *KubernetesProperties) AssignProperties_From_KubernetesProperties(source *storage.KubernetesProperties) error {

	// DefaultInstanceType
	properties.DefaultInstanceType = genruntime.ClonePointerToString(source.DefaultInstanceType)

	// ExtensionInstanceReleaseTrain
	properties.ExtensionInstanceReleaseTrain = genruntime.ClonePointerToString(source.ExtensionInstanceReleaseTrain)

	// ExtensionPrincipalId
	properties.ExtensionPrincipalId = genruntime.ClonePointerToString(source.ExtensionPrincipalId)

	// ExtensionPrincipalIdFromConfig
	if source.ExtensionPrincipalIdFromConfig != nil {
		extensionPrincipalIdFromConfig := source.ExtensionPrincipalIdFromConfig.Copy()
		properties.ExtensionPrincipalIdFromConfig = &extensionPrincipalIdFromConfig
	} else {
		properties.ExtensionPrincipalIdFromConfig = nil
	}

	// InstanceTypes
	if source.InstanceTypes != nil {
		instanceTypeMap := make(map[string]InstanceTypeSchema, len(source.InstanceTypes))
		for instanceTypeKey, instanceTypeValue := range source.InstanceTypes {
			// Shadow the loop variable to avoid aliasing
			instanceTypeValue := instanceTypeValue
			var instanceType InstanceTypeSchema
			err := instanceType.AssignProperties_From_InstanceTypeSchema(&instanceTypeValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_InstanceTypeSchema() to populate field InstanceTypes")
			}
			instanceTypeMap[instanceTypeKey] = instanceType
		}
		properties.InstanceTypes = instanceTypeMap
	} else {
		properties.InstanceTypes = nil
	}

	// Namespace
	properties.Namespace = genruntime.ClonePointerToString(source.Namespace)

	// RelayConnectionString
	if source.RelayConnectionString != nil {
		relayConnectionString := source.RelayConnectionString.Copy()
		properties.RelayConnectionString = &relayConnectionString
	} else {
		properties.RelayConnectionString = nil
	}

	// ServiceBusConnectionString
	if source.ServiceBusConnectionString != nil {
		serviceBusConnectionString := source.ServiceBusConnectionString.Copy()
		properties.ServiceBusConnectionString = &serviceBusConnectionString
	} else {
		properties.ServiceBusConnectionString = nil
	}

	// VcName
	properties.VcName = genruntime.ClonePointerToString(source.VcName)

	// No error
	return nil
}

// AssignProperties_To_KubernetesProperties populates the provided destination KubernetesProperties from our KubernetesProperties
func (properties *KubernetesProperties) AssignProperties_To_KubernetesProperties(destination *storage.KubernetesProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DefaultInstanceType
	destination.DefaultInstanceType = genruntime.ClonePointerToString(properties.DefaultInstanceType)

	// ExtensionInstanceReleaseTrain
	destination.ExtensionInstanceReleaseTrain = genruntime.ClonePointerToString(properties.ExtensionInstanceReleaseTrain)

	// ExtensionPrincipalId
	destination.ExtensionPrincipalId = genruntime.ClonePointerToString(properties.ExtensionPrincipalId)

	// ExtensionPrincipalIdFromConfig
	if properties.ExtensionPrincipalIdFromConfig != nil {
		extensionPrincipalIdFromConfig := properties.ExtensionPrincipalIdFromConfig.Copy()
		destination.ExtensionPrincipalIdFromConfig = &extensionPrincipalIdFromConfig
	} else {
		destination.ExtensionPrincipalIdFromConfig = nil
	}

	// InstanceTypes
	if properties.InstanceTypes != nil {
		instanceTypeMap := make(map[string]storage.InstanceTypeSchema, len(properties.InstanceTypes))
		for instanceTypeKey, instanceTypeValue := range properties.InstanceTypes {
			// Shadow the loop variable to avoid aliasing
			instanceTypeValue := instanceTypeValue
			var instanceType storage.InstanceTypeSchema
			err := instanceTypeValue.AssignProperties_To_InstanceTypeSchema(&instanceType)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_InstanceTypeSchema() to populate field InstanceTypes")
			}
			instanceTypeMap[instanceTypeKey] = instanceType
		}
		destination.InstanceTypes = instanceTypeMap
	} else {
		destination.InstanceTypes = nil
	}

	// Namespace
	destination.Namespace = genruntime.ClonePointerToString(properties.Namespace)

	// RelayConnectionString
	if properties.RelayConnectionString != nil {
		relayConnectionString := properties.RelayConnectionString.Copy()
		destination.RelayConnectionString = &relayConnectionString
	} else {
		destination.RelayConnectionString = nil
	}

	// ServiceBusConnectionString
	if properties.ServiceBusConnectionString != nil {
		serviceBusConnectionString := properties.ServiceBusConnectionString.Copy()
		destination.ServiceBusConnectionString = &serviceBusConnectionString
	} else {
		destination.ServiceBusConnectionString = nil
	}

	// VcName
	destination.VcName = genruntime.ClonePointerToString(properties.VcName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_KubernetesProperties_STATUS populates our KubernetesProperties from the provided source KubernetesProperties_STATUS
func (properties *KubernetesProperties) Initialize_From_KubernetesProperties_STATUS(source *KubernetesProperties_STATUS) error {

	// DefaultInstanceType
	properties.DefaultInstanceType = genruntime.ClonePointerToString(source.DefaultInstanceType)

	// ExtensionInstanceReleaseTrain
	properties.ExtensionInstanceReleaseTrain = genruntime.ClonePointerToString(source.ExtensionInstanceReleaseTrain)

	// ExtensionPrincipalId
	properties.ExtensionPrincipalId = genruntime.ClonePointerToString(source.ExtensionPrincipalId)

	// InstanceTypes
	if source.InstanceTypes != nil {
		instanceTypeMap := make(map[string]InstanceTypeSchema, len(source.InstanceTypes))
		for instanceTypeKey, instanceTypeValue := range source.InstanceTypes {
			// Shadow the loop variable to avoid aliasing
			instanceTypeValue := instanceTypeValue
			var instanceType InstanceTypeSchema
			err := instanceType.Initialize_From_InstanceTypeSchema_STATUS(&instanceTypeValue)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_InstanceTypeSchema_STATUS() to populate field InstanceTypes")
			}
			instanceTypeMap[instanceTypeKey] = instanceType
		}
		properties.InstanceTypes = instanceTypeMap
	} else {
		properties.InstanceTypes = nil
	}

	// Namespace
	properties.Namespace = genruntime.ClonePointerToString(source.Namespace)

	// VcName
	properties.VcName = genruntime.ClonePointerToString(source.VcName)

	// No error
	return nil
}

// Kubernetes properties
type KubernetesProperties_STATUS struct {
	// DefaultInstanceType: Default instance type
	DefaultInstanceType *string `json:"defaultInstanceType,omitempty"`

	// ExtensionInstanceReleaseTrain: Extension instance release train.
	ExtensionInstanceReleaseTrain *string `json:"extensionInstanceReleaseTrain,omitempty"`

	// ExtensionPrincipalId: Extension principal-id.
	ExtensionPrincipalId *string `json:"extensionPrincipalId,omitempty"`

	// InstanceTypes: Instance Type Schema
	InstanceTypes map[string]InstanceTypeSchema_STATUS `json:"instanceTypes,omitempty"`

	// Namespace: Compute namespace
	Namespace *string `json:"namespace,omitempty"`

	// VcName: VC name.
	VcName *string `json:"vcName,omitempty"`
}

var _ genruntime.FromARMConverter = &KubernetesProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *KubernetesProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KubernetesProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *KubernetesProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KubernetesProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KubernetesProperties_STATUS, got %T", armInput)
	}

	// Set property "DefaultInstanceType":
	if typedInput.DefaultInstanceType != nil {
		defaultInstanceType := *typedInput.DefaultInstanceType
		properties.DefaultInstanceType = &defaultInstanceType
	}

	// Set property "ExtensionInstanceReleaseTrain":
	if typedInput.ExtensionInstanceReleaseTrain != nil {
		extensionInstanceReleaseTrain := *typedInput.ExtensionInstanceReleaseTrain
		properties.ExtensionInstanceReleaseTrain = &extensionInstanceReleaseTrain
	}

	// Set property "ExtensionPrincipalId":
	if typedInput.ExtensionPrincipalId != nil {
		extensionPrincipalId := *typedInput.ExtensionPrincipalId
		properties.ExtensionPrincipalId = &extensionPrincipalId
	}

	// Set property "InstanceTypes":
	if typedInput.InstanceTypes != nil {
		properties.InstanceTypes = make(map[string]InstanceTypeSchema_STATUS, len(typedInput.InstanceTypes))
		for key, value := range typedInput.InstanceTypes {
			var value1 InstanceTypeSchema_STATUS
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			properties.InstanceTypes[key] = value1
		}
	}

	// Set property "Namespace":
	if typedInput.Namespace != nil {
		namespace := *typedInput.Namespace
		properties.Namespace = &namespace
	}

	// Set property "VcName":
	if typedInput.VcName != nil {
		vcName := *typedInput.VcName
		properties.VcName = &vcName
	}

	// No error
	return nil
}

// AssignProperties_From_KubernetesProperties_STATUS populates our KubernetesProperties_STATUS from the provided source KubernetesProperties_STATUS
func (properties *KubernetesProperties_STATUS) AssignProperties_From_KubernetesProperties_STATUS(source *storage.KubernetesProperties_STATUS) error {

	// DefaultInstanceType
	properties.DefaultInstanceType = genruntime.ClonePointerToString(source.DefaultInstanceType)

	// ExtensionInstanceReleaseTrain
	properties.ExtensionInstanceReleaseTrain = genruntime.ClonePointerToString(source.ExtensionInstanceReleaseTrain)

	// ExtensionPrincipalId
	properties.ExtensionPrincipalId = genruntime.ClonePointerToString(source.ExtensionPrincipalId)

	// InstanceTypes
	if source.InstanceTypes != nil {
		instanceTypeMap := make(map[string]InstanceTypeSchema_STATUS, len(source.InstanceTypes))
		for instanceTypeKey, instanceTypeValue := range source.InstanceTypes {
			// Shadow the loop variable to avoid aliasing
			instanceTypeValue := instanceTypeValue
			var instanceType InstanceTypeSchema_STATUS
			err := instanceType.AssignProperties_From_InstanceTypeSchema_STATUS(&instanceTypeValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_InstanceTypeSchema_STATUS() to populate field InstanceTypes")
			}
			instanceTypeMap[instanceTypeKey] = instanceType
		}
		properties.InstanceTypes = instanceTypeMap
	} else {
		properties.InstanceTypes = nil
	}

	// Namespace
	properties.Namespace = genruntime.ClonePointerToString(source.Namespace)

	// VcName
	properties.VcName = genruntime.ClonePointerToString(source.VcName)

	// No error
	return nil
}

// AssignProperties_To_KubernetesProperties_STATUS populates the provided destination KubernetesProperties_STATUS from our KubernetesProperties_STATUS
func (properties *KubernetesProperties_STATUS) AssignProperties_To_KubernetesProperties_STATUS(destination *storage.KubernetesProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DefaultInstanceType
	destination.DefaultInstanceType = genruntime.ClonePointerToString(properties.DefaultInstanceType)

	// ExtensionInstanceReleaseTrain
	destination.ExtensionInstanceReleaseTrain = genruntime.ClonePointerToString(properties.ExtensionInstanceReleaseTrain)

	// ExtensionPrincipalId
	destination.ExtensionPrincipalId = genruntime.ClonePointerToString(properties.ExtensionPrincipalId)

	// InstanceTypes
	if properties.InstanceTypes != nil {
		instanceTypeMap := make(map[string]storage.InstanceTypeSchema_STATUS, len(properties.InstanceTypes))
		for instanceTypeKey, instanceTypeValue := range properties.InstanceTypes {
			// Shadow the loop variable to avoid aliasing
			instanceTypeValue := instanceTypeValue
			var instanceType storage.InstanceTypeSchema_STATUS
			err := instanceTypeValue.AssignProperties_To_InstanceTypeSchema_STATUS(&instanceType)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_InstanceTypeSchema_STATUS() to populate field InstanceTypes")
			}
			instanceTypeMap[instanceTypeKey] = instanceType
		}
		destination.InstanceTypes = instanceTypeMap
	} else {
		destination.InstanceTypes = nil
	}

	// Namespace
	destination.Namespace = genruntime.ClonePointerToString(properties.Namespace)

	// VcName
	destination.VcName = genruntime.ClonePointerToString(properties.VcName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"SynapseSpark"}
type SynapseSpark_ComputeType string

const SynapseSpark_ComputeType_SynapseSpark = SynapseSpark_ComputeType("SynapseSpark")

// Mapping from string to SynapseSpark_ComputeType
var synapseSpark_ComputeType_Values = map[string]SynapseSpark_ComputeType{
	"synapsespark": SynapseSpark_ComputeType_SynapseSpark,
}

type SynapseSpark_ComputeType_STATUS string

const SynapseSpark_ComputeType_STATUS_SynapseSpark = SynapseSpark_ComputeType_STATUS("SynapseSpark")

// Mapping from string to SynapseSpark_ComputeType_STATUS
var synapseSpark_ComputeType_STATUS_Values = map[string]SynapseSpark_ComputeType_STATUS{
	"synapsespark": SynapseSpark_ComputeType_STATUS_SynapseSpark,
}

type SynapseSpark_Properties struct {
	// AutoPauseProperties: Auto pause properties.
	AutoPauseProperties *AutoPauseProperties `json:"autoPauseProperties,omitempty"`

	// AutoScaleProperties: Auto scale properties.
	AutoScaleProperties *AutoScaleProperties `json:"autoScaleProperties,omitempty"`

	// NodeCount: The number of compute nodes currently assigned to the compute.
	NodeCount *int `json:"nodeCount,omitempty"`

	// NodeSize: Node size.
	NodeSize *string `json:"nodeSize,omitempty"`

	// NodeSizeFamily: Node size family.
	NodeSizeFamily *string `json:"nodeSizeFamily,omitempty"`

	// PoolName: Pool name.
	PoolName *string `json:"poolName,omitempty"`

	// ResourceGroup: Name of the resource group in which workspace is located.
	ResourceGroup *string `json:"resourceGroup,omitempty"`

	// SparkVersion: Spark version.
	SparkVersion *string `json:"sparkVersion,omitempty"`

	// SubscriptionId: Azure subscription identifier.
	SubscriptionId *string `json:"subscriptionId,omitempty"`

	// WorkspaceName: Name of Azure Machine Learning workspace.
	WorkspaceName *string `json:"workspaceName,omitempty"`
}

var _ genruntime.ARMTransformer = &SynapseSpark_Properties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *SynapseSpark_Properties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.SynapseSpark_Properties{}

	// Set property "AutoPauseProperties":
	if properties.AutoPauseProperties != nil {
		autoPauseProperties_ARM, err := (*properties.AutoPauseProperties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		autoPauseProperties := *autoPauseProperties_ARM.(*arm.AutoPauseProperties)
		result.AutoPauseProperties = &autoPauseProperties
	}

	// Set property "AutoScaleProperties":
	if properties.AutoScaleProperties != nil {
		autoScaleProperties_ARM, err := (*properties.AutoScaleProperties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		autoScaleProperties := *autoScaleProperties_ARM.(*arm.AutoScaleProperties)
		result.AutoScaleProperties = &autoScaleProperties
	}

	// Set property "NodeCount":
	if properties.NodeCount != nil {
		nodeCount := *properties.NodeCount
		result.NodeCount = &nodeCount
	}

	// Set property "NodeSize":
	if properties.NodeSize != nil {
		nodeSize := *properties.NodeSize
		result.NodeSize = &nodeSize
	}

	// Set property "NodeSizeFamily":
	if properties.NodeSizeFamily != nil {
		nodeSizeFamily := *properties.NodeSizeFamily
		result.NodeSizeFamily = &nodeSizeFamily
	}

	// Set property "PoolName":
	if properties.PoolName != nil {
		poolName := *properties.PoolName
		result.PoolName = &poolName
	}

	// Set property "ResourceGroup":
	if properties.ResourceGroup != nil {
		resourceGroup := *properties.ResourceGroup
		result.ResourceGroup = &resourceGroup
	}

	// Set property "SparkVersion":
	if properties.SparkVersion != nil {
		sparkVersion := *properties.SparkVersion
		result.SparkVersion = &sparkVersion
	}

	// Set property "SubscriptionId":
	if properties.SubscriptionId != nil {
		subscriptionId := *properties.SubscriptionId
		result.SubscriptionId = &subscriptionId
	}

	// Set property "WorkspaceName":
	if properties.WorkspaceName != nil {
		workspaceName := *properties.WorkspaceName
		result.WorkspaceName = &workspaceName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *SynapseSpark_Properties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SynapseSpark_Properties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *SynapseSpark_Properties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SynapseSpark_Properties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SynapseSpark_Properties, got %T", armInput)
	}

	// Set property "AutoPauseProperties":
	if typedInput.AutoPauseProperties != nil {
		var autoPauseProperties1 AutoPauseProperties
		err := autoPauseProperties1.PopulateFromARM(owner, *typedInput.AutoPauseProperties)
		if err != nil {
			return err
		}
		autoPauseProperties := autoPauseProperties1
		properties.AutoPauseProperties = &autoPauseProperties
	}

	// Set property "AutoScaleProperties":
	if typedInput.AutoScaleProperties != nil {
		var autoScaleProperties1 AutoScaleProperties
		err := autoScaleProperties1.PopulateFromARM(owner, *typedInput.AutoScaleProperties)
		if err != nil {
			return err
		}
		autoScaleProperties := autoScaleProperties1
		properties.AutoScaleProperties = &autoScaleProperties
	}

	// Set property "NodeCount":
	if typedInput.NodeCount != nil {
		nodeCount := *typedInput.NodeCount
		properties.NodeCount = &nodeCount
	}

	// Set property "NodeSize":
	if typedInput.NodeSize != nil {
		nodeSize := *typedInput.NodeSize
		properties.NodeSize = &nodeSize
	}

	// Set property "NodeSizeFamily":
	if typedInput.NodeSizeFamily != nil {
		nodeSizeFamily := *typedInput.NodeSizeFamily
		properties.NodeSizeFamily = &nodeSizeFamily
	}

	// Set property "PoolName":
	if typedInput.PoolName != nil {
		poolName := *typedInput.PoolName
		properties.PoolName = &poolName
	}

	// Set property "ResourceGroup":
	if typedInput.ResourceGroup != nil {
		resourceGroup := *typedInput.ResourceGroup
		properties.ResourceGroup = &resourceGroup
	}

	// Set property "SparkVersion":
	if typedInput.SparkVersion != nil {
		sparkVersion := *typedInput.SparkVersion
		properties.SparkVersion = &sparkVersion
	}

	// Set property "SubscriptionId":
	if typedInput.SubscriptionId != nil {
		subscriptionId := *typedInput.SubscriptionId
		properties.SubscriptionId = &subscriptionId
	}

	// Set property "WorkspaceName":
	if typedInput.WorkspaceName != nil {
		workspaceName := *typedInput.WorkspaceName
		properties.WorkspaceName = &workspaceName
	}

	// No error
	return nil
}

// AssignProperties_From_SynapseSpark_Properties populates our SynapseSpark_Properties from the provided source SynapseSpark_Properties
func (properties *SynapseSpark_Properties) AssignProperties_From_SynapseSpark_Properties(source *storage.SynapseSpark_Properties) error {

	// AutoPauseProperties
	if source.AutoPauseProperties != nil {
		var autoPauseProperty AutoPauseProperties
		err := autoPauseProperty.AssignProperties_From_AutoPauseProperties(source.AutoPauseProperties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AutoPauseProperties() to populate field AutoPauseProperties")
		}
		properties.AutoPauseProperties = &autoPauseProperty
	} else {
		properties.AutoPauseProperties = nil
	}

	// AutoScaleProperties
	if source.AutoScaleProperties != nil {
		var autoScaleProperty AutoScaleProperties
		err := autoScaleProperty.AssignProperties_From_AutoScaleProperties(source.AutoScaleProperties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AutoScaleProperties() to populate field AutoScaleProperties")
		}
		properties.AutoScaleProperties = &autoScaleProperty
	} else {
		properties.AutoScaleProperties = nil
	}

	// NodeCount
	properties.NodeCount = genruntime.ClonePointerToInt(source.NodeCount)

	// NodeSize
	properties.NodeSize = genruntime.ClonePointerToString(source.NodeSize)

	// NodeSizeFamily
	properties.NodeSizeFamily = genruntime.ClonePointerToString(source.NodeSizeFamily)

	// PoolName
	properties.PoolName = genruntime.ClonePointerToString(source.PoolName)

	// ResourceGroup
	properties.ResourceGroup = genruntime.ClonePointerToString(source.ResourceGroup)

	// SparkVersion
	properties.SparkVersion = genruntime.ClonePointerToString(source.SparkVersion)

	// SubscriptionId
	properties.SubscriptionId = genruntime.ClonePointerToString(source.SubscriptionId)

	// WorkspaceName
	properties.WorkspaceName = genruntime.ClonePointerToString(source.WorkspaceName)

	// No error
	return nil
}

// AssignProperties_To_SynapseSpark_Properties populates the provided destination SynapseSpark_Properties from our SynapseSpark_Properties
func (properties *SynapseSpark_Properties) AssignProperties_To_SynapseSpark_Properties(destination *storage.SynapseSpark_Properties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AutoPauseProperties
	if properties.AutoPauseProperties != nil {
		var autoPauseProperty storage.AutoPauseProperties
		err := properties.AutoPauseProperties.AssignProperties_To_AutoPauseProperties(&autoPauseProperty)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AutoPauseProperties() to populate field AutoPauseProperties")
		}
		destination.AutoPauseProperties = &autoPauseProperty
	} else {
		destination.AutoPauseProperties = nil
	}

	// AutoScaleProperties
	if properties.AutoScaleProperties != nil {
		var autoScaleProperty storage.AutoScaleProperties
		err := properties.AutoScaleProperties.AssignProperties_To_AutoScaleProperties(&autoScaleProperty)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AutoScaleProperties() to populate field AutoScaleProperties")
		}
		destination.AutoScaleProperties = &autoScaleProperty
	} else {
		destination.AutoScaleProperties = nil
	}

	// NodeCount
	destination.NodeCount = genruntime.ClonePointerToInt(properties.NodeCount)

	// NodeSize
	destination.NodeSize = genruntime.ClonePointerToString(properties.NodeSize)

	// NodeSizeFamily
	destination.NodeSizeFamily = genruntime.ClonePointerToString(properties.NodeSizeFamily)

	// PoolName
	destination.PoolName = genruntime.ClonePointerToString(properties.PoolName)

	// ResourceGroup
	destination.ResourceGroup = genruntime.ClonePointerToString(properties.ResourceGroup)

	// SparkVersion
	destination.SparkVersion = genruntime.ClonePointerToString(properties.SparkVersion)

	// SubscriptionId
	destination.SubscriptionId = genruntime.ClonePointerToString(properties.SubscriptionId)

	// WorkspaceName
	destination.WorkspaceName = genruntime.ClonePointerToString(properties.WorkspaceName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_SynapseSpark_Properties_STATUS populates our SynapseSpark_Properties from the provided source SynapseSpark_Properties_STATUS
func (properties *SynapseSpark_Properties) Initialize_From_SynapseSpark_Properties_STATUS(source *SynapseSpark_Properties_STATUS) error {

	// AutoPauseProperties
	if source.AutoPauseProperties != nil {
		var autoPauseProperty AutoPauseProperties
		err := autoPauseProperty.Initialize_From_AutoPauseProperties_STATUS(source.AutoPauseProperties)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_AutoPauseProperties_STATUS() to populate field AutoPauseProperties")
		}
		properties.AutoPauseProperties = &autoPauseProperty
	} else {
		properties.AutoPauseProperties = nil
	}

	// AutoScaleProperties
	if source.AutoScaleProperties != nil {
		var autoScaleProperty AutoScaleProperties
		err := autoScaleProperty.Initialize_From_AutoScaleProperties_STATUS(source.AutoScaleProperties)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_AutoScaleProperties_STATUS() to populate field AutoScaleProperties")
		}
		properties.AutoScaleProperties = &autoScaleProperty
	} else {
		properties.AutoScaleProperties = nil
	}

	// NodeCount
	properties.NodeCount = genruntime.ClonePointerToInt(source.NodeCount)

	// NodeSize
	properties.NodeSize = genruntime.ClonePointerToString(source.NodeSize)

	// NodeSizeFamily
	properties.NodeSizeFamily = genruntime.ClonePointerToString(source.NodeSizeFamily)

	// PoolName
	properties.PoolName = genruntime.ClonePointerToString(source.PoolName)

	// ResourceGroup
	properties.ResourceGroup = genruntime.ClonePointerToString(source.ResourceGroup)

	// SparkVersion
	properties.SparkVersion = genruntime.ClonePointerToString(source.SparkVersion)

	// SubscriptionId
	properties.SubscriptionId = genruntime.ClonePointerToString(source.SubscriptionId)

	// WorkspaceName
	properties.WorkspaceName = genruntime.ClonePointerToString(source.WorkspaceName)

	// No error
	return nil
}

type SynapseSpark_Properties_STATUS struct {
	// AutoPauseProperties: Auto pause properties.
	AutoPauseProperties *AutoPauseProperties_STATUS `json:"autoPauseProperties,omitempty"`

	// AutoScaleProperties: Auto scale properties.
	AutoScaleProperties *AutoScaleProperties_STATUS `json:"autoScaleProperties,omitempty"`

	// NodeCount: The number of compute nodes currently assigned to the compute.
	NodeCount *int `json:"nodeCount,omitempty"`

	// NodeSize: Node size.
	NodeSize *string `json:"nodeSize,omitempty"`

	// NodeSizeFamily: Node size family.
	NodeSizeFamily *string `json:"nodeSizeFamily,omitempty"`

	// PoolName: Pool name.
	PoolName *string `json:"poolName,omitempty"`

	// ResourceGroup: Name of the resource group in which workspace is located.
	ResourceGroup *string `json:"resourceGroup,omitempty"`

	// SparkVersion: Spark version.
	SparkVersion *string `json:"sparkVersion,omitempty"`

	// SubscriptionId: Azure subscription identifier.
	SubscriptionId *string `json:"subscriptionId,omitempty"`

	// WorkspaceName: Name of Azure Machine Learning workspace.
	WorkspaceName *string `json:"workspaceName,omitempty"`
}

var _ genruntime.FromARMConverter = &SynapseSpark_Properties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *SynapseSpark_Properties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SynapseSpark_Properties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *SynapseSpark_Properties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SynapseSpark_Properties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SynapseSpark_Properties_STATUS, got %T", armInput)
	}

	// Set property "AutoPauseProperties":
	if typedInput.AutoPauseProperties != nil {
		var autoPauseProperties1 AutoPauseProperties_STATUS
		err := autoPauseProperties1.PopulateFromARM(owner, *typedInput.AutoPauseProperties)
		if err != nil {
			return err
		}
		autoPauseProperties := autoPauseProperties1
		properties.AutoPauseProperties = &autoPauseProperties
	}

	// Set property "AutoScaleProperties":
	if typedInput.AutoScaleProperties != nil {
		var autoScaleProperties1 AutoScaleProperties_STATUS
		err := autoScaleProperties1.PopulateFromARM(owner, *typedInput.AutoScaleProperties)
		if err != nil {
			return err
		}
		autoScaleProperties := autoScaleProperties1
		properties.AutoScaleProperties = &autoScaleProperties
	}

	// Set property "NodeCount":
	if typedInput.NodeCount != nil {
		nodeCount := *typedInput.NodeCount
		properties.NodeCount = &nodeCount
	}

	// Set property "NodeSize":
	if typedInput.NodeSize != nil {
		nodeSize := *typedInput.NodeSize
		properties.NodeSize = &nodeSize
	}

	// Set property "NodeSizeFamily":
	if typedInput.NodeSizeFamily != nil {
		nodeSizeFamily := *typedInput.NodeSizeFamily
		properties.NodeSizeFamily = &nodeSizeFamily
	}

	// Set property "PoolName":
	if typedInput.PoolName != nil {
		poolName := *typedInput.PoolName
		properties.PoolName = &poolName
	}

	// Set property "ResourceGroup":
	if typedInput.ResourceGroup != nil {
		resourceGroup := *typedInput.ResourceGroup
		properties.ResourceGroup = &resourceGroup
	}

	// Set property "SparkVersion":
	if typedInput.SparkVersion != nil {
		sparkVersion := *typedInput.SparkVersion
		properties.SparkVersion = &sparkVersion
	}

	// Set property "SubscriptionId":
	if typedInput.SubscriptionId != nil {
		subscriptionId := *typedInput.SubscriptionId
		properties.SubscriptionId = &subscriptionId
	}

	// Set property "WorkspaceName":
	if typedInput.WorkspaceName != nil {
		workspaceName := *typedInput.WorkspaceName
		properties.WorkspaceName = &workspaceName
	}

	// No error
	return nil
}

// AssignProperties_From_SynapseSpark_Properties_STATUS populates our SynapseSpark_Properties_STATUS from the provided source SynapseSpark_Properties_STATUS
func (properties *SynapseSpark_Properties_STATUS) AssignProperties_From_SynapseSpark_Properties_STATUS(source *storage.SynapseSpark_Properties_STATUS) error {

	// AutoPauseProperties
	if source.AutoPauseProperties != nil {
		var autoPauseProperty AutoPauseProperties_STATUS
		err := autoPauseProperty.AssignProperties_From_AutoPauseProperties_STATUS(source.AutoPauseProperties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AutoPauseProperties_STATUS() to populate field AutoPauseProperties")
		}
		properties.AutoPauseProperties = &autoPauseProperty
	} else {
		properties.AutoPauseProperties = nil
	}

	// AutoScaleProperties
	if source.AutoScaleProperties != nil {
		var autoScaleProperty AutoScaleProperties_STATUS
		err := autoScaleProperty.AssignProperties_From_AutoScaleProperties_STATUS(source.AutoScaleProperties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AutoScaleProperties_STATUS() to populate field AutoScaleProperties")
		}
		properties.AutoScaleProperties = &autoScaleProperty
	} else {
		properties.AutoScaleProperties = nil
	}

	// NodeCount
	properties.NodeCount = genruntime.ClonePointerToInt(source.NodeCount)

	// NodeSize
	properties.NodeSize = genruntime.ClonePointerToString(source.NodeSize)

	// NodeSizeFamily
	properties.NodeSizeFamily = genruntime.ClonePointerToString(source.NodeSizeFamily)

	// PoolName
	properties.PoolName = genruntime.ClonePointerToString(source.PoolName)

	// ResourceGroup
	properties.ResourceGroup = genruntime.ClonePointerToString(source.ResourceGroup)

	// SparkVersion
	properties.SparkVersion = genruntime.ClonePointerToString(source.SparkVersion)

	// SubscriptionId
	properties.SubscriptionId = genruntime.ClonePointerToString(source.SubscriptionId)

	// WorkspaceName
	properties.WorkspaceName = genruntime.ClonePointerToString(source.WorkspaceName)

	// No error
	return nil
}

// AssignProperties_To_SynapseSpark_Properties_STATUS populates the provided destination SynapseSpark_Properties_STATUS from our SynapseSpark_Properties_STATUS
func (properties *SynapseSpark_Properties_STATUS) AssignProperties_To_SynapseSpark_Properties_STATUS(destination *storage.SynapseSpark_Properties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AutoPauseProperties
	if properties.AutoPauseProperties != nil {
		var autoPauseProperty storage.AutoPauseProperties_STATUS
		err := properties.AutoPauseProperties.AssignProperties_To_AutoPauseProperties_STATUS(&autoPauseProperty)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AutoPauseProperties_STATUS() to populate field AutoPauseProperties")
		}
		destination.AutoPauseProperties = &autoPauseProperty
	} else {
		destination.AutoPauseProperties = nil
	}

	// AutoScaleProperties
	if properties.AutoScaleProperties != nil {
		var autoScaleProperty storage.AutoScaleProperties_STATUS
		err := properties.AutoScaleProperties.AssignProperties_To_AutoScaleProperties_STATUS(&autoScaleProperty)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AutoScaleProperties_STATUS() to populate field AutoScaleProperties")
		}
		destination.AutoScaleProperties = &autoScaleProperty
	} else {
		destination.AutoScaleProperties = nil
	}

	// NodeCount
	destination.NodeCount = genruntime.ClonePointerToInt(properties.NodeCount)

	// NodeSize
	destination.NodeSize = genruntime.ClonePointerToString(properties.NodeSize)

	// NodeSizeFamily
	destination.NodeSizeFamily = genruntime.ClonePointerToString(properties.NodeSizeFamily)

	// PoolName
	destination.PoolName = genruntime.ClonePointerToString(properties.PoolName)

	// ResourceGroup
	destination.ResourceGroup = genruntime.ClonePointerToString(properties.ResourceGroup)

	// SparkVersion
	destination.SparkVersion = genruntime.ClonePointerToString(properties.SparkVersion)

	// SubscriptionId
	destination.SubscriptionId = genruntime.ClonePointerToString(properties.SubscriptionId)

	// WorkspaceName
	destination.WorkspaceName = genruntime.ClonePointerToString(properties.WorkspaceName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type SynapseSpark_ProvisioningState_STATUS string

const (
	SynapseSpark_ProvisioningState_STATUS_Canceled  = SynapseSpark_ProvisioningState_STATUS("Canceled")
	SynapseSpark_ProvisioningState_STATUS_Creating  = SynapseSpark_ProvisioningState_STATUS("Creating")
	SynapseSpark_ProvisioningState_STATUS_Deleting  = SynapseSpark_ProvisioningState_STATUS("Deleting")
	SynapseSpark_ProvisioningState_STATUS_Failed    = SynapseSpark_ProvisioningState_STATUS("Failed")
	SynapseSpark_ProvisioningState_STATUS_Succeeded = SynapseSpark_ProvisioningState_STATUS("Succeeded")
	SynapseSpark_ProvisioningState_STATUS_Unknown   = SynapseSpark_ProvisioningState_STATUS("Unknown")
	SynapseSpark_ProvisioningState_STATUS_Updating  = SynapseSpark_ProvisioningState_STATUS("Updating")
)

// Mapping from string to SynapseSpark_ProvisioningState_STATUS
var synapseSpark_ProvisioningState_STATUS_Values = map[string]SynapseSpark_ProvisioningState_STATUS{
	"canceled":  SynapseSpark_ProvisioningState_STATUS_Canceled,
	"creating":  SynapseSpark_ProvisioningState_STATUS_Creating,
	"deleting":  SynapseSpark_ProvisioningState_STATUS_Deleting,
	"failed":    SynapseSpark_ProvisioningState_STATUS_Failed,
	"succeeded": SynapseSpark_ProvisioningState_STATUS_Succeeded,
	"unknown":   SynapseSpark_ProvisioningState_STATUS_Unknown,
	"updating":  SynapseSpark_ProvisioningState_STATUS_Updating,
}

// +kubebuilder:validation:Enum={"VirtualMachine"}
type VirtualMachine_ComputeType string

const VirtualMachine_ComputeType_VirtualMachine = VirtualMachine_ComputeType("VirtualMachine")

// Mapping from string to VirtualMachine_ComputeType
var virtualMachine_ComputeType_Values = map[string]VirtualMachine_ComputeType{
	"virtualmachine": VirtualMachine_ComputeType_VirtualMachine,
}

type VirtualMachine_ComputeType_STATUS string

const VirtualMachine_ComputeType_STATUS_VirtualMachine = VirtualMachine_ComputeType_STATUS("VirtualMachine")

// Mapping from string to VirtualMachine_ComputeType_STATUS
var virtualMachine_ComputeType_STATUS_Values = map[string]VirtualMachine_ComputeType_STATUS{
	"virtualmachine": VirtualMachine_ComputeType_STATUS_VirtualMachine,
}

type VirtualMachine_Properties struct {
	// Address: Public IP address of the virtual machine.
	Address *string `json:"address,omitempty"`

	// AdministratorAccount: Admin credentials for virtual machine
	AdministratorAccount *VirtualMachineSshCredentials `json:"administratorAccount,omitempty"`

	// IsNotebookInstanceCompute: Indicates whether this compute will be used for running notebooks.
	IsNotebookInstanceCompute *bool `json:"isNotebookInstanceCompute,omitempty"`

	// NotebookServerPort: Notebook server port open for ssh connections.
	NotebookServerPort *int `json:"notebookServerPort,omitempty"`

	// SshPort: Port open for ssh connections.
	SshPort *int `json:"sshPort,omitempty"`

	// VirtualMachineSize: Virtual Machine size
	VirtualMachineSize *string `json:"virtualMachineSize,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachine_Properties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *VirtualMachine_Properties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.VirtualMachine_Properties{}

	// Set property "Address":
	if properties.Address != nil {
		address := *properties.Address
		result.Address = &address
	}

	// Set property "AdministratorAccount":
	if properties.AdministratorAccount != nil {
		administratorAccount_ARM, err := (*properties.AdministratorAccount).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		administratorAccount := *administratorAccount_ARM.(*arm.VirtualMachineSshCredentials)
		result.AdministratorAccount = &administratorAccount
	}

	// Set property "IsNotebookInstanceCompute":
	if properties.IsNotebookInstanceCompute != nil {
		isNotebookInstanceCompute := *properties.IsNotebookInstanceCompute
		result.IsNotebookInstanceCompute = &isNotebookInstanceCompute
	}

	// Set property "NotebookServerPort":
	if properties.NotebookServerPort != nil {
		notebookServerPort := *properties.NotebookServerPort
		result.NotebookServerPort = &notebookServerPort
	}

	// Set property "SshPort":
	if properties.SshPort != nil {
		sshPort := *properties.SshPort
		result.SshPort = &sshPort
	}

	// Set property "VirtualMachineSize":
	if properties.VirtualMachineSize != nil {
		virtualMachineSize := *properties.VirtualMachineSize
		result.VirtualMachineSize = &virtualMachineSize
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *VirtualMachine_Properties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachine_Properties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *VirtualMachine_Properties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachine_Properties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachine_Properties, got %T", armInput)
	}

	// Set property "Address":
	if typedInput.Address != nil {
		address := *typedInput.Address
		properties.Address = &address
	}

	// Set property "AdministratorAccount":
	if typedInput.AdministratorAccount != nil {
		var administratorAccount1 VirtualMachineSshCredentials
		err := administratorAccount1.PopulateFromARM(owner, *typedInput.AdministratorAccount)
		if err != nil {
			return err
		}
		administratorAccount := administratorAccount1
		properties.AdministratorAccount = &administratorAccount
	}

	// Set property "IsNotebookInstanceCompute":
	if typedInput.IsNotebookInstanceCompute != nil {
		isNotebookInstanceCompute := *typedInput.IsNotebookInstanceCompute
		properties.IsNotebookInstanceCompute = &isNotebookInstanceCompute
	}

	// Set property "NotebookServerPort":
	if typedInput.NotebookServerPort != nil {
		notebookServerPort := *typedInput.NotebookServerPort
		properties.NotebookServerPort = &notebookServerPort
	}

	// Set property "SshPort":
	if typedInput.SshPort != nil {
		sshPort := *typedInput.SshPort
		properties.SshPort = &sshPort
	}

	// Set property "VirtualMachineSize":
	if typedInput.VirtualMachineSize != nil {
		virtualMachineSize := *typedInput.VirtualMachineSize
		properties.VirtualMachineSize = &virtualMachineSize
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachine_Properties populates our VirtualMachine_Properties from the provided source VirtualMachine_Properties
func (properties *VirtualMachine_Properties) AssignProperties_From_VirtualMachine_Properties(source *storage.VirtualMachine_Properties) error {

	// Address
	properties.Address = genruntime.ClonePointerToString(source.Address)

	// AdministratorAccount
	if source.AdministratorAccount != nil {
		var administratorAccount VirtualMachineSshCredentials
		err := administratorAccount.AssignProperties_From_VirtualMachineSshCredentials(source.AdministratorAccount)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineSshCredentials() to populate field AdministratorAccount")
		}
		properties.AdministratorAccount = &administratorAccount
	} else {
		properties.AdministratorAccount = nil
	}

	// IsNotebookInstanceCompute
	if source.IsNotebookInstanceCompute != nil {
		isNotebookInstanceCompute := *source.IsNotebookInstanceCompute
		properties.IsNotebookInstanceCompute = &isNotebookInstanceCompute
	} else {
		properties.IsNotebookInstanceCompute = nil
	}

	// NotebookServerPort
	properties.NotebookServerPort = genruntime.ClonePointerToInt(source.NotebookServerPort)

	// SshPort
	properties.SshPort = genruntime.ClonePointerToInt(source.SshPort)

	// VirtualMachineSize
	properties.VirtualMachineSize = genruntime.ClonePointerToString(source.VirtualMachineSize)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachine_Properties populates the provided destination VirtualMachine_Properties from our VirtualMachine_Properties
func (properties *VirtualMachine_Properties) AssignProperties_To_VirtualMachine_Properties(destination *storage.VirtualMachine_Properties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Address
	destination.Address = genruntime.ClonePointerToString(properties.Address)

	// AdministratorAccount
	if properties.AdministratorAccount != nil {
		var administratorAccount storage.VirtualMachineSshCredentials
		err := properties.AdministratorAccount.AssignProperties_To_VirtualMachineSshCredentials(&administratorAccount)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineSshCredentials() to populate field AdministratorAccount")
		}
		destination.AdministratorAccount = &administratorAccount
	} else {
		destination.AdministratorAccount = nil
	}

	// IsNotebookInstanceCompute
	if properties.IsNotebookInstanceCompute != nil {
		isNotebookInstanceCompute := *properties.IsNotebookInstanceCompute
		destination.IsNotebookInstanceCompute = &isNotebookInstanceCompute
	} else {
		destination.IsNotebookInstanceCompute = nil
	}

	// NotebookServerPort
	destination.NotebookServerPort = genruntime.ClonePointerToInt(properties.NotebookServerPort)

	// SshPort
	destination.SshPort = genruntime.ClonePointerToInt(properties.SshPort)

	// VirtualMachineSize
	destination.VirtualMachineSize = genruntime.ClonePointerToString(properties.VirtualMachineSize)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualMachine_Properties_STATUS populates our VirtualMachine_Properties from the provided source VirtualMachine_Properties_STATUS
func (properties *VirtualMachine_Properties) Initialize_From_VirtualMachine_Properties_STATUS(source *VirtualMachine_Properties_STATUS) error {

	// Address
	properties.Address = genruntime.ClonePointerToString(source.Address)

	// AdministratorAccount
	if source.AdministratorAccount != nil {
		var administratorAccount VirtualMachineSshCredentials
		err := administratorAccount.Initialize_From_VirtualMachineSshCredentials_STATUS(source.AdministratorAccount)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_VirtualMachineSshCredentials_STATUS() to populate field AdministratorAccount")
		}
		properties.AdministratorAccount = &administratorAccount
	} else {
		properties.AdministratorAccount = nil
	}

	// IsNotebookInstanceCompute
	if source.IsNotebookInstanceCompute != nil {
		isNotebookInstanceCompute := *source.IsNotebookInstanceCompute
		properties.IsNotebookInstanceCompute = &isNotebookInstanceCompute
	} else {
		properties.IsNotebookInstanceCompute = nil
	}

	// NotebookServerPort
	properties.NotebookServerPort = genruntime.ClonePointerToInt(source.NotebookServerPort)

	// SshPort
	properties.SshPort = genruntime.ClonePointerToInt(source.SshPort)

	// VirtualMachineSize
	properties.VirtualMachineSize = genruntime.ClonePointerToString(source.VirtualMachineSize)

	// No error
	return nil
}

type VirtualMachine_Properties_STATUS struct {
	// Address: Public IP address of the virtual machine.
	Address *string `json:"address,omitempty"`

	// AdministratorAccount: Admin credentials for virtual machine
	AdministratorAccount *VirtualMachineSshCredentials_STATUS `json:"administratorAccount,omitempty"`

	// IsNotebookInstanceCompute: Indicates whether this compute will be used for running notebooks.
	IsNotebookInstanceCompute *bool `json:"isNotebookInstanceCompute,omitempty"`

	// NotebookServerPort: Notebook server port open for ssh connections.
	NotebookServerPort *int `json:"notebookServerPort,omitempty"`

	// SshPort: Port open for ssh connections.
	SshPort *int `json:"sshPort,omitempty"`

	// VirtualMachineSize: Virtual Machine size
	VirtualMachineSize *string `json:"virtualMachineSize,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachine_Properties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *VirtualMachine_Properties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachine_Properties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *VirtualMachine_Properties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachine_Properties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachine_Properties_STATUS, got %T", armInput)
	}

	// Set property "Address":
	if typedInput.Address != nil {
		address := *typedInput.Address
		properties.Address = &address
	}

	// Set property "AdministratorAccount":
	if typedInput.AdministratorAccount != nil {
		var administratorAccount1 VirtualMachineSshCredentials_STATUS
		err := administratorAccount1.PopulateFromARM(owner, *typedInput.AdministratorAccount)
		if err != nil {
			return err
		}
		administratorAccount := administratorAccount1
		properties.AdministratorAccount = &administratorAccount
	}

	// Set property "IsNotebookInstanceCompute":
	if typedInput.IsNotebookInstanceCompute != nil {
		isNotebookInstanceCompute := *typedInput.IsNotebookInstanceCompute
		properties.IsNotebookInstanceCompute = &isNotebookInstanceCompute
	}

	// Set property "NotebookServerPort":
	if typedInput.NotebookServerPort != nil {
		notebookServerPort := *typedInput.NotebookServerPort
		properties.NotebookServerPort = &notebookServerPort
	}

	// Set property "SshPort":
	if typedInput.SshPort != nil {
		sshPort := *typedInput.SshPort
		properties.SshPort = &sshPort
	}

	// Set property "VirtualMachineSize":
	if typedInput.VirtualMachineSize != nil {
		virtualMachineSize := *typedInput.VirtualMachineSize
		properties.VirtualMachineSize = &virtualMachineSize
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachine_Properties_STATUS populates our VirtualMachine_Properties_STATUS from the provided source VirtualMachine_Properties_STATUS
func (properties *VirtualMachine_Properties_STATUS) AssignProperties_From_VirtualMachine_Properties_STATUS(source *storage.VirtualMachine_Properties_STATUS) error {

	// Address
	properties.Address = genruntime.ClonePointerToString(source.Address)

	// AdministratorAccount
	if source.AdministratorAccount != nil {
		var administratorAccount VirtualMachineSshCredentials_STATUS
		err := administratorAccount.AssignProperties_From_VirtualMachineSshCredentials_STATUS(source.AdministratorAccount)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineSshCredentials_STATUS() to populate field AdministratorAccount")
		}
		properties.AdministratorAccount = &administratorAccount
	} else {
		properties.AdministratorAccount = nil
	}

	// IsNotebookInstanceCompute
	if source.IsNotebookInstanceCompute != nil {
		isNotebookInstanceCompute := *source.IsNotebookInstanceCompute
		properties.IsNotebookInstanceCompute = &isNotebookInstanceCompute
	} else {
		properties.IsNotebookInstanceCompute = nil
	}

	// NotebookServerPort
	properties.NotebookServerPort = genruntime.ClonePointerToInt(source.NotebookServerPort)

	// SshPort
	properties.SshPort = genruntime.ClonePointerToInt(source.SshPort)

	// VirtualMachineSize
	properties.VirtualMachineSize = genruntime.ClonePointerToString(source.VirtualMachineSize)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachine_Properties_STATUS populates the provided destination VirtualMachine_Properties_STATUS from our VirtualMachine_Properties_STATUS
func (properties *VirtualMachine_Properties_STATUS) AssignProperties_To_VirtualMachine_Properties_STATUS(destination *storage.VirtualMachine_Properties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Address
	destination.Address = genruntime.ClonePointerToString(properties.Address)

	// AdministratorAccount
	if properties.AdministratorAccount != nil {
		var administratorAccount storage.VirtualMachineSshCredentials_STATUS
		err := properties.AdministratorAccount.AssignProperties_To_VirtualMachineSshCredentials_STATUS(&administratorAccount)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineSshCredentials_STATUS() to populate field AdministratorAccount")
		}
		destination.AdministratorAccount = &administratorAccount
	} else {
		destination.AdministratorAccount = nil
	}

	// IsNotebookInstanceCompute
	if properties.IsNotebookInstanceCompute != nil {
		isNotebookInstanceCompute := *properties.IsNotebookInstanceCompute
		destination.IsNotebookInstanceCompute = &isNotebookInstanceCompute
	} else {
		destination.IsNotebookInstanceCompute = nil
	}

	// NotebookServerPort
	destination.NotebookServerPort = genruntime.ClonePointerToInt(properties.NotebookServerPort)

	// SshPort
	destination.SshPort = genruntime.ClonePointerToInt(properties.SshPort)

	// VirtualMachineSize
	destination.VirtualMachineSize = genruntime.ClonePointerToString(properties.VirtualMachineSize)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachine_ProvisioningState_STATUS string

const (
	VirtualMachine_ProvisioningState_STATUS_Canceled  = VirtualMachine_ProvisioningState_STATUS("Canceled")
	VirtualMachine_ProvisioningState_STATUS_Creating  = VirtualMachine_ProvisioningState_STATUS("Creating")
	VirtualMachine_ProvisioningState_STATUS_Deleting  = VirtualMachine_ProvisioningState_STATUS("Deleting")
	VirtualMachine_ProvisioningState_STATUS_Failed    = VirtualMachine_ProvisioningState_STATUS("Failed")
	VirtualMachine_ProvisioningState_STATUS_Succeeded = VirtualMachine_ProvisioningState_STATUS("Succeeded")
	VirtualMachine_ProvisioningState_STATUS_Unknown   = VirtualMachine_ProvisioningState_STATUS("Unknown")
	VirtualMachine_ProvisioningState_STATUS_Updating  = VirtualMachine_ProvisioningState_STATUS("Updating")
)

// Mapping from string to VirtualMachine_ProvisioningState_STATUS
var virtualMachine_ProvisioningState_STATUS_Values = map[string]VirtualMachine_ProvisioningState_STATUS{
	"canceled":  VirtualMachine_ProvisioningState_STATUS_Canceled,
	"creating":  VirtualMachine_ProvisioningState_STATUS_Creating,
	"deleting":  VirtualMachine_ProvisioningState_STATUS_Deleting,
	"failed":    VirtualMachine_ProvisioningState_STATUS_Failed,
	"succeeded": VirtualMachine_ProvisioningState_STATUS_Succeeded,
	"unknown":   VirtualMachine_ProvisioningState_STATUS_Unknown,
	"updating":  VirtualMachine_ProvisioningState_STATUS_Updating,
}

// +kubebuilder:validation:Enum={"DenseProd","DevTest","FastProd"}
type AKS_Properties_ClusterPurpose string

const (
	AKS_Properties_ClusterPurpose_DenseProd = AKS_Properties_ClusterPurpose("DenseProd")
	AKS_Properties_ClusterPurpose_DevTest   = AKS_Properties_ClusterPurpose("DevTest")
	AKS_Properties_ClusterPurpose_FastProd  = AKS_Properties_ClusterPurpose("FastProd")
)

// Mapping from string to AKS_Properties_ClusterPurpose
var aKS_Properties_ClusterPurpose_Values = map[string]AKS_Properties_ClusterPurpose{
	"denseprod": AKS_Properties_ClusterPurpose_DenseProd,
	"devtest":   AKS_Properties_ClusterPurpose_DevTest,
	"fastprod":  AKS_Properties_ClusterPurpose_FastProd,
}

type AKS_Properties_ClusterPurpose_STATUS string

const (
	AKS_Properties_ClusterPurpose_STATUS_DenseProd = AKS_Properties_ClusterPurpose_STATUS("DenseProd")
	AKS_Properties_ClusterPurpose_STATUS_DevTest   = AKS_Properties_ClusterPurpose_STATUS("DevTest")
	AKS_Properties_ClusterPurpose_STATUS_FastProd  = AKS_Properties_ClusterPurpose_STATUS("FastProd")
)

// Mapping from string to AKS_Properties_ClusterPurpose_STATUS
var aKS_Properties_ClusterPurpose_STATUS_Values = map[string]AKS_Properties_ClusterPurpose_STATUS{
	"denseprod": AKS_Properties_ClusterPurpose_STATUS_DenseProd,
	"devtest":   AKS_Properties_ClusterPurpose_STATUS_DevTest,
	"fastprod":  AKS_Properties_ClusterPurpose_STATUS_FastProd,
}

// +kubebuilder:validation:Enum={"InternalLoadBalancer","PublicIp"}
type AKS_Properties_LoadBalancerType string

const (
	AKS_Properties_LoadBalancerType_InternalLoadBalancer = AKS_Properties_LoadBalancerType("InternalLoadBalancer")
	AKS_Properties_LoadBalancerType_PublicIp             = AKS_Properties_LoadBalancerType("PublicIp")
)

// Mapping from string to AKS_Properties_LoadBalancerType
var aKS_Properties_LoadBalancerType_Values = map[string]AKS_Properties_LoadBalancerType{
	"internalloadbalancer": AKS_Properties_LoadBalancerType_InternalLoadBalancer,
	"publicip":             AKS_Properties_LoadBalancerType_PublicIp,
}

type AKS_Properties_LoadBalancerType_STATUS string

const (
	AKS_Properties_LoadBalancerType_STATUS_InternalLoadBalancer = AKS_Properties_LoadBalancerType_STATUS("InternalLoadBalancer")
	AKS_Properties_LoadBalancerType_STATUS_PublicIp             = AKS_Properties_LoadBalancerType_STATUS("PublicIp")
)

// Mapping from string to AKS_Properties_LoadBalancerType_STATUS
var aKS_Properties_LoadBalancerType_STATUS_Values = map[string]AKS_Properties_LoadBalancerType_STATUS{
	"internalloadbalancer": AKS_Properties_LoadBalancerType_STATUS_InternalLoadBalancer,
	"publicip":             AKS_Properties_LoadBalancerType_STATUS_PublicIp,
}

// Advance configuration for AKS networking
type AksNetworkingConfiguration struct {
	// +kubebuilder:validation:Pattern="^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$"
	// DnsServiceIP: An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes service address
	// range specified in serviceCidr.
	DnsServiceIP *string `json:"dnsServiceIP,omitempty"`

	// +kubebuilder:validation:Pattern="^([0-9]{1,3}\\.){3}[0-9]{1,3}(\\/([0-9]|[1-2][0-9]|3[0-2]))?$"
	// DockerBridgeCidr: A CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP
	// ranges or the Kubernetes service address range.
	DockerBridgeCidr *string `json:"dockerBridgeCidr,omitempty"`

	// +kubebuilder:validation:Pattern="^([0-9]{1,3}\\.){3}[0-9]{1,3}(\\/([0-9]|[1-2][0-9]|3[0-2]))?$"
	// ServiceCidr: A CIDR notation IP range from which to assign service cluster IPs. It must not overlap with any Subnet IP
	// ranges.
	ServiceCidr *string `json:"serviceCidr,omitempty"`

	// SubnetReference: Virtual network subnet resource ID the compute nodes belong to
	SubnetReference *genruntime.ResourceReference `armReference:"SubnetId" json:"subnetReference,omitempty"`
}

var _ genruntime.ARMTransformer = &AksNetworkingConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *AksNetworkingConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.AksNetworkingConfiguration{}

	// Set property "DnsServiceIP":
	if configuration.DnsServiceIP != nil {
		dnsServiceIP := *configuration.DnsServiceIP
		result.DnsServiceIP = &dnsServiceIP
	}

	// Set property "DockerBridgeCidr":
	if configuration.DockerBridgeCidr != nil {
		dockerBridgeCidr := *configuration.DockerBridgeCidr
		result.DockerBridgeCidr = &dockerBridgeCidr
	}

	// Set property "ServiceCidr":
	if configuration.ServiceCidr != nil {
		serviceCidr := *configuration.ServiceCidr
		result.ServiceCidr = &serviceCidr
	}

	// Set property "SubnetId":
	if configuration.SubnetReference != nil {
		subnetReferenceARMID, err := resolved.ResolvedReferences.Lookup(*configuration.SubnetReference)
		if err != nil {
			return nil, err
		}
		subnetReference := subnetReferenceARMID
		result.SubnetId = &subnetReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *AksNetworkingConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AksNetworkingConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *AksNetworkingConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AksNetworkingConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AksNetworkingConfiguration, got %T", armInput)
	}

	// Set property "DnsServiceIP":
	if typedInput.DnsServiceIP != nil {
		dnsServiceIP := *typedInput.DnsServiceIP
		configuration.DnsServiceIP = &dnsServiceIP
	}

	// Set property "DockerBridgeCidr":
	if typedInput.DockerBridgeCidr != nil {
		dockerBridgeCidr := *typedInput.DockerBridgeCidr
		configuration.DockerBridgeCidr = &dockerBridgeCidr
	}

	// Set property "ServiceCidr":
	if typedInput.ServiceCidr != nil {
		serviceCidr := *typedInput.ServiceCidr
		configuration.ServiceCidr = &serviceCidr
	}

	// no assignment for property "SubnetReference"

	// No error
	return nil
}

// AssignProperties_From_AksNetworkingConfiguration populates our AksNetworkingConfiguration from the provided source AksNetworkingConfiguration
func (configuration *AksNetworkingConfiguration) AssignProperties_From_AksNetworkingConfiguration(source *storage.AksNetworkingConfiguration) error {

	// DnsServiceIP
	if source.DnsServiceIP != nil {
		dnsServiceIP := *source.DnsServiceIP
		configuration.DnsServiceIP = &dnsServiceIP
	} else {
		configuration.DnsServiceIP = nil
	}

	// DockerBridgeCidr
	if source.DockerBridgeCidr != nil {
		dockerBridgeCidr := *source.DockerBridgeCidr
		configuration.DockerBridgeCidr = &dockerBridgeCidr
	} else {
		configuration.DockerBridgeCidr = nil
	}

	// ServiceCidr
	if source.ServiceCidr != nil {
		serviceCidr := *source.ServiceCidr
		configuration.ServiceCidr = &serviceCidr
	} else {
		configuration.ServiceCidr = nil
	}

	// SubnetReference
	if source.SubnetReference != nil {
		subnetReference := source.SubnetReference.Copy()
		configuration.SubnetReference = &subnetReference
	} else {
		configuration.SubnetReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AksNetworkingConfiguration populates the provided destination AksNetworkingConfiguration from our AksNetworkingConfiguration
func (configuration *AksNetworkingConfiguration) AssignProperties_To_AksNetworkingConfiguration(destination *storage.AksNetworkingConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsServiceIP
	if configuration.DnsServiceIP != nil {
		dnsServiceIP := *configuration.DnsServiceIP
		destination.DnsServiceIP = &dnsServiceIP
	} else {
		destination.DnsServiceIP = nil
	}

	// DockerBridgeCidr
	if configuration.DockerBridgeCidr != nil {
		dockerBridgeCidr := *configuration.DockerBridgeCidr
		destination.DockerBridgeCidr = &dockerBridgeCidr
	} else {
		destination.DockerBridgeCidr = nil
	}

	// ServiceCidr
	if configuration.ServiceCidr != nil {
		serviceCidr := *configuration.ServiceCidr
		destination.ServiceCidr = &serviceCidr
	} else {
		destination.ServiceCidr = nil
	}

	// SubnetReference
	if configuration.SubnetReference != nil {
		subnetReference := configuration.SubnetReference.Copy()
		destination.SubnetReference = &subnetReference
	} else {
		destination.SubnetReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AksNetworkingConfiguration_STATUS populates our AksNetworkingConfiguration from the provided source AksNetworkingConfiguration_STATUS
func (configuration *AksNetworkingConfiguration) Initialize_From_AksNetworkingConfiguration_STATUS(source *AksNetworkingConfiguration_STATUS) error {

	// DnsServiceIP
	if source.DnsServiceIP != nil {
		dnsServiceIP := *source.DnsServiceIP
		configuration.DnsServiceIP = &dnsServiceIP
	} else {
		configuration.DnsServiceIP = nil
	}

	// DockerBridgeCidr
	if source.DockerBridgeCidr != nil {
		dockerBridgeCidr := *source.DockerBridgeCidr
		configuration.DockerBridgeCidr = &dockerBridgeCidr
	} else {
		configuration.DockerBridgeCidr = nil
	}

	// ServiceCidr
	if source.ServiceCidr != nil {
		serviceCidr := *source.ServiceCidr
		configuration.ServiceCidr = &serviceCidr
	} else {
		configuration.ServiceCidr = nil
	}

	// SubnetReference
	if source.SubnetId != nil {
		subnetReference := genruntime.CreateResourceReferenceFromARMID(*source.SubnetId)
		configuration.SubnetReference = &subnetReference
	} else {
		configuration.SubnetReference = nil
	}

	// No error
	return nil
}

// Advance configuration for AKS networking
type AksNetworkingConfiguration_STATUS struct {
	// DnsServiceIP: An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes service address
	// range specified in serviceCidr.
	DnsServiceIP *string `json:"dnsServiceIP,omitempty"`

	// DockerBridgeCidr: A CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP
	// ranges or the Kubernetes service address range.
	DockerBridgeCidr *string `json:"dockerBridgeCidr,omitempty"`

	// ServiceCidr: A CIDR notation IP range from which to assign service cluster IPs. It must not overlap with any Subnet IP
	// ranges.
	ServiceCidr *string `json:"serviceCidr,omitempty"`

	// SubnetId: Virtual network subnet resource ID the compute nodes belong to
	SubnetId *string `json:"subnetId,omitempty"`
}

var _ genruntime.FromARMConverter = &AksNetworkingConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *AksNetworkingConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AksNetworkingConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *AksNetworkingConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AksNetworkingConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AksNetworkingConfiguration_STATUS, got %T", armInput)
	}

	// Set property "DnsServiceIP":
	if typedInput.DnsServiceIP != nil {
		dnsServiceIP := *typedInput.DnsServiceIP
		configuration.DnsServiceIP = &dnsServiceIP
	}

	// Set property "DockerBridgeCidr":
	if typedInput.DockerBridgeCidr != nil {
		dockerBridgeCidr := *typedInput.DockerBridgeCidr
		configuration.DockerBridgeCidr = &dockerBridgeCidr
	}

	// Set property "ServiceCidr":
	if typedInput.ServiceCidr != nil {
		serviceCidr := *typedInput.ServiceCidr
		configuration.ServiceCidr = &serviceCidr
	}

	// Set property "SubnetId":
	if typedInput.SubnetId != nil {
		subnetId := *typedInput.SubnetId
		configuration.SubnetId = &subnetId
	}

	// No error
	return nil
}

// AssignProperties_From_AksNetworkingConfiguration_STATUS populates our AksNetworkingConfiguration_STATUS from the provided source AksNetworkingConfiguration_STATUS
func (configuration *AksNetworkingConfiguration_STATUS) AssignProperties_From_AksNetworkingConfiguration_STATUS(source *storage.AksNetworkingConfiguration_STATUS) error {

	// DnsServiceIP
	configuration.DnsServiceIP = genruntime.ClonePointerToString(source.DnsServiceIP)

	// DockerBridgeCidr
	configuration.DockerBridgeCidr = genruntime.ClonePointerToString(source.DockerBridgeCidr)

	// ServiceCidr
	configuration.ServiceCidr = genruntime.ClonePointerToString(source.ServiceCidr)

	// SubnetId
	configuration.SubnetId = genruntime.ClonePointerToString(source.SubnetId)

	// No error
	return nil
}

// AssignProperties_To_AksNetworkingConfiguration_STATUS populates the provided destination AksNetworkingConfiguration_STATUS from our AksNetworkingConfiguration_STATUS
func (configuration *AksNetworkingConfiguration_STATUS) AssignProperties_To_AksNetworkingConfiguration_STATUS(destination *storage.AksNetworkingConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsServiceIP
	destination.DnsServiceIP = genruntime.ClonePointerToString(configuration.DnsServiceIP)

	// DockerBridgeCidr
	destination.DockerBridgeCidr = genruntime.ClonePointerToString(configuration.DockerBridgeCidr)

	// ServiceCidr
	destination.ServiceCidr = genruntime.ClonePointerToString(configuration.ServiceCidr)

	// SubnetId
	destination.SubnetId = genruntime.ClonePointerToString(configuration.SubnetId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AmlComputeProperties_AllocationState_STATUS string

const (
	AmlComputeProperties_AllocationState_STATUS_Resizing = AmlComputeProperties_AllocationState_STATUS("Resizing")
	AmlComputeProperties_AllocationState_STATUS_Steady   = AmlComputeProperties_AllocationState_STATUS("Steady")
)

// Mapping from string to AmlComputeProperties_AllocationState_STATUS
var amlComputeProperties_AllocationState_STATUS_Values = map[string]AmlComputeProperties_AllocationState_STATUS{
	"resizing": AmlComputeProperties_AllocationState_STATUS_Resizing,
	"steady":   AmlComputeProperties_AllocationState_STATUS_Steady,
}

// +kubebuilder:validation:Enum={"Linux","Windows"}
type AmlComputeProperties_OsType string

const (
	AmlComputeProperties_OsType_Linux   = AmlComputeProperties_OsType("Linux")
	AmlComputeProperties_OsType_Windows = AmlComputeProperties_OsType("Windows")
)

// Mapping from string to AmlComputeProperties_OsType
var amlComputeProperties_OsType_Values = map[string]AmlComputeProperties_OsType{
	"linux":   AmlComputeProperties_OsType_Linux,
	"windows": AmlComputeProperties_OsType_Windows,
}

type AmlComputeProperties_OsType_STATUS string

const (
	AmlComputeProperties_OsType_STATUS_Linux   = AmlComputeProperties_OsType_STATUS("Linux")
	AmlComputeProperties_OsType_STATUS_Windows = AmlComputeProperties_OsType_STATUS("Windows")
)

// Mapping from string to AmlComputeProperties_OsType_STATUS
var amlComputeProperties_OsType_STATUS_Values = map[string]AmlComputeProperties_OsType_STATUS{
	"linux":   AmlComputeProperties_OsType_STATUS_Linux,
	"windows": AmlComputeProperties_OsType_STATUS_Windows,
}

// +kubebuilder:validation:Enum={"Disabled","Enabled","NotSpecified"}
type AmlComputeProperties_RemoteLoginPortPublicAccess string

const (
	AmlComputeProperties_RemoteLoginPortPublicAccess_Disabled     = AmlComputeProperties_RemoteLoginPortPublicAccess("Disabled")
	AmlComputeProperties_RemoteLoginPortPublicAccess_Enabled      = AmlComputeProperties_RemoteLoginPortPublicAccess("Enabled")
	AmlComputeProperties_RemoteLoginPortPublicAccess_NotSpecified = AmlComputeProperties_RemoteLoginPortPublicAccess("NotSpecified")
)

// Mapping from string to AmlComputeProperties_RemoteLoginPortPublicAccess
var amlComputeProperties_RemoteLoginPortPublicAccess_Values = map[string]AmlComputeProperties_RemoteLoginPortPublicAccess{
	"disabled":     AmlComputeProperties_RemoteLoginPortPublicAccess_Disabled,
	"enabled":      AmlComputeProperties_RemoteLoginPortPublicAccess_Enabled,
	"notspecified": AmlComputeProperties_RemoteLoginPortPublicAccess_NotSpecified,
}

type AmlComputeProperties_RemoteLoginPortPublicAccess_STATUS string

const (
	AmlComputeProperties_RemoteLoginPortPublicAccess_STATUS_Disabled     = AmlComputeProperties_RemoteLoginPortPublicAccess_STATUS("Disabled")
	AmlComputeProperties_RemoteLoginPortPublicAccess_STATUS_Enabled      = AmlComputeProperties_RemoteLoginPortPublicAccess_STATUS("Enabled")
	AmlComputeProperties_RemoteLoginPortPublicAccess_STATUS_NotSpecified = AmlComputeProperties_RemoteLoginPortPublicAccess_STATUS("NotSpecified")
)

// Mapping from string to AmlComputeProperties_RemoteLoginPortPublicAccess_STATUS
var amlComputeProperties_RemoteLoginPortPublicAccess_STATUS_Values = map[string]AmlComputeProperties_RemoteLoginPortPublicAccess_STATUS{
	"disabled":     AmlComputeProperties_RemoteLoginPortPublicAccess_STATUS_Disabled,
	"enabled":      AmlComputeProperties_RemoteLoginPortPublicAccess_STATUS_Enabled,
	"notspecified": AmlComputeProperties_RemoteLoginPortPublicAccess_STATUS_NotSpecified,
}

// +kubebuilder:validation:Enum={"Dedicated","LowPriority"}
type AmlComputeProperties_VmPriority string

const (
	AmlComputeProperties_VmPriority_Dedicated   = AmlComputeProperties_VmPriority("Dedicated")
	AmlComputeProperties_VmPriority_LowPriority = AmlComputeProperties_VmPriority("LowPriority")
)

// Mapping from string to AmlComputeProperties_VmPriority
var amlComputeProperties_VmPriority_Values = map[string]AmlComputeProperties_VmPriority{
	"dedicated":   AmlComputeProperties_VmPriority_Dedicated,
	"lowpriority": AmlComputeProperties_VmPriority_LowPriority,
}

type AmlComputeProperties_VmPriority_STATUS string

const (
	AmlComputeProperties_VmPriority_STATUS_Dedicated   = AmlComputeProperties_VmPriority_STATUS("Dedicated")
	AmlComputeProperties_VmPriority_STATUS_LowPriority = AmlComputeProperties_VmPriority_STATUS("LowPriority")
)

// Mapping from string to AmlComputeProperties_VmPriority_STATUS
var amlComputeProperties_VmPriority_STATUS_Values = map[string]AmlComputeProperties_VmPriority_STATUS{
	"dedicated":   AmlComputeProperties_VmPriority_STATUS_Dedicated,
	"lowpriority": AmlComputeProperties_VmPriority_STATUS_LowPriority,
}

// Auto pause properties
type AutoPauseProperties struct {
	DelayInMinutes *int  `json:"delayInMinutes,omitempty"`
	Enabled        *bool `json:"enabled,omitempty"`
}

var _ genruntime.ARMTransformer = &AutoPauseProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *AutoPauseProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.AutoPauseProperties{}

	// Set property "DelayInMinutes":
	if properties.DelayInMinutes != nil {
		delayInMinutes := *properties.DelayInMinutes
		result.DelayInMinutes = &delayInMinutes
	}

	// Set property "Enabled":
	if properties.Enabled != nil {
		enabled := *properties.Enabled
		result.Enabled = &enabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *AutoPauseProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AutoPauseProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *AutoPauseProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AutoPauseProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AutoPauseProperties, got %T", armInput)
	}

	// Set property "DelayInMinutes":
	if typedInput.DelayInMinutes != nil {
		delayInMinutes := *typedInput.DelayInMinutes
		properties.DelayInMinutes = &delayInMinutes
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		properties.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_AutoPauseProperties populates our AutoPauseProperties from the provided source AutoPauseProperties
func (properties *AutoPauseProperties) AssignProperties_From_AutoPauseProperties(source *storage.AutoPauseProperties) error {

	// DelayInMinutes
	properties.DelayInMinutes = genruntime.ClonePointerToInt(source.DelayInMinutes)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		properties.Enabled = &enabled
	} else {
		properties.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AutoPauseProperties populates the provided destination AutoPauseProperties from our AutoPauseProperties
func (properties *AutoPauseProperties) AssignProperties_To_AutoPauseProperties(destination *storage.AutoPauseProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DelayInMinutes
	destination.DelayInMinutes = genruntime.ClonePointerToInt(properties.DelayInMinutes)

	// Enabled
	if properties.Enabled != nil {
		enabled := *properties.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AutoPauseProperties_STATUS populates our AutoPauseProperties from the provided source AutoPauseProperties_STATUS
func (properties *AutoPauseProperties) Initialize_From_AutoPauseProperties_STATUS(source *AutoPauseProperties_STATUS) error {

	// DelayInMinutes
	properties.DelayInMinutes = genruntime.ClonePointerToInt(source.DelayInMinutes)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		properties.Enabled = &enabled
	} else {
		properties.Enabled = nil
	}

	// No error
	return nil
}

// Auto pause properties
type AutoPauseProperties_STATUS struct {
	DelayInMinutes *int  `json:"delayInMinutes,omitempty"`
	Enabled        *bool `json:"enabled,omitempty"`
}

var _ genruntime.FromARMConverter = &AutoPauseProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *AutoPauseProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AutoPauseProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *AutoPauseProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AutoPauseProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AutoPauseProperties_STATUS, got %T", armInput)
	}

	// Set property "DelayInMinutes":
	if typedInput.DelayInMinutes != nil {
		delayInMinutes := *typedInput.DelayInMinutes
		properties.DelayInMinutes = &delayInMinutes
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		properties.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_AutoPauseProperties_STATUS populates our AutoPauseProperties_STATUS from the provided source AutoPauseProperties_STATUS
func (properties *AutoPauseProperties_STATUS) AssignProperties_From_AutoPauseProperties_STATUS(source *storage.AutoPauseProperties_STATUS) error {

	// DelayInMinutes
	properties.DelayInMinutes = genruntime.ClonePointerToInt(source.DelayInMinutes)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		properties.Enabled = &enabled
	} else {
		properties.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AutoPauseProperties_STATUS populates the provided destination AutoPauseProperties_STATUS from our AutoPauseProperties_STATUS
func (properties *AutoPauseProperties_STATUS) AssignProperties_To_AutoPauseProperties_STATUS(destination *storage.AutoPauseProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DelayInMinutes
	destination.DelayInMinutes = genruntime.ClonePointerToInt(properties.DelayInMinutes)

	// Enabled
	if properties.Enabled != nil {
		enabled := *properties.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Auto scale properties
type AutoScaleProperties struct {
	Enabled      *bool `json:"enabled,omitempty"`
	MaxNodeCount *int  `json:"maxNodeCount,omitempty"`
	MinNodeCount *int  `json:"minNodeCount,omitempty"`
}

var _ genruntime.ARMTransformer = &AutoScaleProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *AutoScaleProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.AutoScaleProperties{}

	// Set property "Enabled":
	if properties.Enabled != nil {
		enabled := *properties.Enabled
		result.Enabled = &enabled
	}

	// Set property "MaxNodeCount":
	if properties.MaxNodeCount != nil {
		maxNodeCount := *properties.MaxNodeCount
		result.MaxNodeCount = &maxNodeCount
	}

	// Set property "MinNodeCount":
	if properties.MinNodeCount != nil {
		minNodeCount := *properties.MinNodeCount
		result.MinNodeCount = &minNodeCount
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *AutoScaleProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AutoScaleProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *AutoScaleProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AutoScaleProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AutoScaleProperties, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		properties.Enabled = &enabled
	}

	// Set property "MaxNodeCount":
	if typedInput.MaxNodeCount != nil {
		maxNodeCount := *typedInput.MaxNodeCount
		properties.MaxNodeCount = &maxNodeCount
	}

	// Set property "MinNodeCount":
	if typedInput.MinNodeCount != nil {
		minNodeCount := *typedInput.MinNodeCount
		properties.MinNodeCount = &minNodeCount
	}

	// No error
	return nil
}

// AssignProperties_From_AutoScaleProperties populates our AutoScaleProperties from the provided source AutoScaleProperties
func (properties *AutoScaleProperties) AssignProperties_From_AutoScaleProperties(source *storage.AutoScaleProperties) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		properties.Enabled = &enabled
	} else {
		properties.Enabled = nil
	}

	// MaxNodeCount
	properties.MaxNodeCount = genruntime.ClonePointerToInt(source.MaxNodeCount)

	// MinNodeCount
	properties.MinNodeCount = genruntime.ClonePointerToInt(source.MinNodeCount)

	// No error
	return nil
}

// AssignProperties_To_AutoScaleProperties populates the provided destination AutoScaleProperties from our AutoScaleProperties
func (properties *AutoScaleProperties) AssignProperties_To_AutoScaleProperties(destination *storage.AutoScaleProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if properties.Enabled != nil {
		enabled := *properties.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// MaxNodeCount
	destination.MaxNodeCount = genruntime.ClonePointerToInt(properties.MaxNodeCount)

	// MinNodeCount
	destination.MinNodeCount = genruntime.ClonePointerToInt(properties.MinNodeCount)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AutoScaleProperties_STATUS populates our AutoScaleProperties from the provided source AutoScaleProperties_STATUS
func (properties *AutoScaleProperties) Initialize_From_AutoScaleProperties_STATUS(source *AutoScaleProperties_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		properties.Enabled = &enabled
	} else {
		properties.Enabled = nil
	}

	// MaxNodeCount
	properties.MaxNodeCount = genruntime.ClonePointerToInt(source.MaxNodeCount)

	// MinNodeCount
	properties.MinNodeCount = genruntime.ClonePointerToInt(source.MinNodeCount)

	// No error
	return nil
}

// Auto scale properties
type AutoScaleProperties_STATUS struct {
	Enabled      *bool `json:"enabled,omitempty"`
	MaxNodeCount *int  `json:"maxNodeCount,omitempty"`
	MinNodeCount *int  `json:"minNodeCount,omitempty"`
}

var _ genruntime.FromARMConverter = &AutoScaleProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *AutoScaleProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AutoScaleProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *AutoScaleProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AutoScaleProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AutoScaleProperties_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		properties.Enabled = &enabled
	}

	// Set property "MaxNodeCount":
	if typedInput.MaxNodeCount != nil {
		maxNodeCount := *typedInput.MaxNodeCount
		properties.MaxNodeCount = &maxNodeCount
	}

	// Set property "MinNodeCount":
	if typedInput.MinNodeCount != nil {
		minNodeCount := *typedInput.MinNodeCount
		properties.MinNodeCount = &minNodeCount
	}

	// No error
	return nil
}

// AssignProperties_From_AutoScaleProperties_STATUS populates our AutoScaleProperties_STATUS from the provided source AutoScaleProperties_STATUS
func (properties *AutoScaleProperties_STATUS) AssignProperties_From_AutoScaleProperties_STATUS(source *storage.AutoScaleProperties_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		properties.Enabled = &enabled
	} else {
		properties.Enabled = nil
	}

	// MaxNodeCount
	properties.MaxNodeCount = genruntime.ClonePointerToInt(source.MaxNodeCount)

	// MinNodeCount
	properties.MinNodeCount = genruntime.ClonePointerToInt(source.MinNodeCount)

	// No error
	return nil
}

// AssignProperties_To_AutoScaleProperties_STATUS populates the provided destination AutoScaleProperties_STATUS from our AutoScaleProperties_STATUS
func (properties *AutoScaleProperties_STATUS) AssignProperties_To_AutoScaleProperties_STATUS(destination *storage.AutoScaleProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if properties.Enabled != nil {
		enabled := *properties.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// MaxNodeCount
	destination.MaxNodeCount = genruntime.ClonePointerToInt(properties.MaxNodeCount)

	// MinNodeCount
	destination.MinNodeCount = genruntime.ClonePointerToInt(properties.MinNodeCount)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines an Aml Instance application and its connectivity endpoint URI.
type ComputeInstanceApplication_STATUS struct {
	// DisplayName: Name of the ComputeInstance application.
	DisplayName *string `json:"displayName,omitempty"`

	// EndpointUri: Application' endpoint URI.
	EndpointUri *string `json:"endpointUri,omitempty"`
}

var _ genruntime.FromARMConverter = &ComputeInstanceApplication_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (application *ComputeInstanceApplication_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComputeInstanceApplication_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (application *ComputeInstanceApplication_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComputeInstanceApplication_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComputeInstanceApplication_STATUS, got %T", armInput)
	}

	// Set property "DisplayName":
	if typedInput.DisplayName != nil {
		displayName := *typedInput.DisplayName
		application.DisplayName = &displayName
	}

	// Set property "EndpointUri":
	if typedInput.EndpointUri != nil {
		endpointUri := *typedInput.EndpointUri
		application.EndpointUri = &endpointUri
	}

	// No error
	return nil
}

// AssignProperties_From_ComputeInstanceApplication_STATUS populates our ComputeInstanceApplication_STATUS from the provided source ComputeInstanceApplication_STATUS
func (application *ComputeInstanceApplication_STATUS) AssignProperties_From_ComputeInstanceApplication_STATUS(source *storage.ComputeInstanceApplication_STATUS) error {

	// DisplayName
	application.DisplayName = genruntime.ClonePointerToString(source.DisplayName)

	// EndpointUri
	application.EndpointUri = genruntime.ClonePointerToString(source.EndpointUri)

	// No error
	return nil
}

// AssignProperties_To_ComputeInstanceApplication_STATUS populates the provided destination ComputeInstanceApplication_STATUS from our ComputeInstanceApplication_STATUS
func (application *ComputeInstanceApplication_STATUS) AssignProperties_To_ComputeInstanceApplication_STATUS(destination *storage.ComputeInstanceApplication_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DisplayName
	destination.DisplayName = genruntime.ClonePointerToString(application.DisplayName)

	// EndpointUri
	destination.EndpointUri = genruntime.ClonePointerToString(application.EndpointUri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines all connectivity endpoints and properties for an ComputeInstance.
type ComputeInstanceConnectivityEndpoints_STATUS struct {
	// PrivateIpAddress: Private IP Address of this ComputeInstance (local to the VNET in which the compute instance is
	// deployed).
	PrivateIpAddress *string `json:"privateIpAddress,omitempty"`

	// PublicIpAddress: Public IP Address of this ComputeInstance.
	PublicIpAddress *string `json:"publicIpAddress,omitempty"`
}

var _ genruntime.FromARMConverter = &ComputeInstanceConnectivityEndpoints_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (endpoints *ComputeInstanceConnectivityEndpoints_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComputeInstanceConnectivityEndpoints_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (endpoints *ComputeInstanceConnectivityEndpoints_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComputeInstanceConnectivityEndpoints_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComputeInstanceConnectivityEndpoints_STATUS, got %T", armInput)
	}

	// Set property "PrivateIpAddress":
	if typedInput.PrivateIpAddress != nil {
		privateIpAddress := *typedInput.PrivateIpAddress
		endpoints.PrivateIpAddress = &privateIpAddress
	}

	// Set property "PublicIpAddress":
	if typedInput.PublicIpAddress != nil {
		publicIpAddress := *typedInput.PublicIpAddress
		endpoints.PublicIpAddress = &publicIpAddress
	}

	// No error
	return nil
}

// AssignProperties_From_ComputeInstanceConnectivityEndpoints_STATUS populates our ComputeInstanceConnectivityEndpoints_STATUS from the provided source ComputeInstanceConnectivityEndpoints_STATUS
func (endpoints *ComputeInstanceConnectivityEndpoints_STATUS) AssignProperties_From_ComputeInstanceConnectivityEndpoints_STATUS(source *storage.ComputeInstanceConnectivityEndpoints_STATUS) error {

	// PrivateIpAddress
	endpoints.PrivateIpAddress = genruntime.ClonePointerToString(source.PrivateIpAddress)

	// PublicIpAddress
	endpoints.PublicIpAddress = genruntime.ClonePointerToString(source.PublicIpAddress)

	// No error
	return nil
}

// AssignProperties_To_ComputeInstanceConnectivityEndpoints_STATUS populates the provided destination ComputeInstanceConnectivityEndpoints_STATUS from our ComputeInstanceConnectivityEndpoints_STATUS
func (endpoints *ComputeInstanceConnectivityEndpoints_STATUS) AssignProperties_To_ComputeInstanceConnectivityEndpoints_STATUS(destination *storage.ComputeInstanceConnectivityEndpoints_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrivateIpAddress
	destination.PrivateIpAddress = genruntime.ClonePointerToString(endpoints.PrivateIpAddress)

	// PublicIpAddress
	destination.PublicIpAddress = genruntime.ClonePointerToString(endpoints.PublicIpAddress)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines an Aml Instance container.
type ComputeInstanceContainer_STATUS struct {
	// Autosave: Auto save settings.
	Autosave *ComputeInstanceContainer_Autosave_STATUS `json:"autosave,omitempty"`

	// Environment: Environment information of this container.
	Environment *ComputeInstanceEnvironmentInfo_STATUS `json:"environment,omitempty"`

	// Gpu: Information of GPU.
	Gpu *string `json:"gpu,omitempty"`

	// Name: Name of the ComputeInstance container.
	Name *string `json:"name,omitempty"`

	// Network: network of this container.
	Network *ComputeInstanceContainer_Network_STATUS `json:"network,omitempty"`

	// Services: services of this containers.
	Services []map[string]v1.JSON `json:"services,omitempty"`
}

var _ genruntime.FromARMConverter = &ComputeInstanceContainer_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (container *ComputeInstanceContainer_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComputeInstanceContainer_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (container *ComputeInstanceContainer_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComputeInstanceContainer_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComputeInstanceContainer_STATUS, got %T", armInput)
	}

	// Set property "Autosave":
	if typedInput.Autosave != nil {
		var temp string
		temp = string(*typedInput.Autosave)
		autosave := ComputeInstanceContainer_Autosave_STATUS(temp)
		container.Autosave = &autosave
	}

	// Set property "Environment":
	if typedInput.Environment != nil {
		var environment1 ComputeInstanceEnvironmentInfo_STATUS
		err := environment1.PopulateFromARM(owner, *typedInput.Environment)
		if err != nil {
			return err
		}
		environment := environment1
		container.Environment = &environment
	}

	// Set property "Gpu":
	if typedInput.Gpu != nil {
		gpu := *typedInput.Gpu
		container.Gpu = &gpu
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		container.Name = &name
	}

	// Set property "Network":
	if typedInput.Network != nil {
		var temp string
		temp = string(*typedInput.Network)
		network := ComputeInstanceContainer_Network_STATUS(temp)
		container.Network = &network
	}

	// Set property "Services":
	for _, item := range typedInput.Services {
		if item != nil {
			itemTemp := make(map[string]v1.JSON, len(item))
			for key, value := range item {
				itemTemp[key] = *value.DeepCopy()
			}
			container.Services = append(container.Services, itemTemp)
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ComputeInstanceContainer_STATUS populates our ComputeInstanceContainer_STATUS from the provided source ComputeInstanceContainer_STATUS
func (container *ComputeInstanceContainer_STATUS) AssignProperties_From_ComputeInstanceContainer_STATUS(source *storage.ComputeInstanceContainer_STATUS) error {

	// Autosave
	if source.Autosave != nil {
		autosave := *source.Autosave
		autosaveTemp := genruntime.ToEnum(autosave, computeInstanceContainer_Autosave_STATUS_Values)
		container.Autosave = &autosaveTemp
	} else {
		container.Autosave = nil
	}

	// Environment
	if source.Environment != nil {
		var environment ComputeInstanceEnvironmentInfo_STATUS
		err := environment.AssignProperties_From_ComputeInstanceEnvironmentInfo_STATUS(source.Environment)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ComputeInstanceEnvironmentInfo_STATUS() to populate field Environment")
		}
		container.Environment = &environment
	} else {
		container.Environment = nil
	}

	// Gpu
	container.Gpu = genruntime.ClonePointerToString(source.Gpu)

	// Name
	container.Name = genruntime.ClonePointerToString(source.Name)

	// Network
	if source.Network != nil {
		network := *source.Network
		networkTemp := genruntime.ToEnum(network, computeInstanceContainer_Network_STATUS_Values)
		container.Network = &networkTemp
	} else {
		container.Network = nil
	}

	// Services
	if source.Services != nil {
		serviceList := make([]map[string]v1.JSON, len(source.Services))
		for serviceIndex, serviceItem := range source.Services {
			// Shadow the loop variable to avoid aliasing
			serviceItem := serviceItem
			if serviceItem != nil {
				serviceMap := make(map[string]v1.JSON, len(serviceItem))
				for serviceKey, serviceValue := range serviceItem {
					// Shadow the loop variable to avoid aliasing
					serviceValue := serviceValue
					serviceMap[serviceKey] = *serviceValue.DeepCopy()
				}
				serviceList[serviceIndex] = serviceMap
			} else {
				serviceList[serviceIndex] = nil
			}
		}
		container.Services = serviceList
	} else {
		container.Services = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ComputeInstanceContainer_STATUS populates the provided destination ComputeInstanceContainer_STATUS from our ComputeInstanceContainer_STATUS
func (container *ComputeInstanceContainer_STATUS) AssignProperties_To_ComputeInstanceContainer_STATUS(destination *storage.ComputeInstanceContainer_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Autosave
	if container.Autosave != nil {
		autosave := string(*container.Autosave)
		destination.Autosave = &autosave
	} else {
		destination.Autosave = nil
	}

	// Environment
	if container.Environment != nil {
		var environment storage.ComputeInstanceEnvironmentInfo_STATUS
		err := container.Environment.AssignProperties_To_ComputeInstanceEnvironmentInfo_STATUS(&environment)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ComputeInstanceEnvironmentInfo_STATUS() to populate field Environment")
		}
		destination.Environment = &environment
	} else {
		destination.Environment = nil
	}

	// Gpu
	destination.Gpu = genruntime.ClonePointerToString(container.Gpu)

	// Name
	destination.Name = genruntime.ClonePointerToString(container.Name)

	// Network
	if container.Network != nil {
		network := string(*container.Network)
		destination.Network = &network
	} else {
		destination.Network = nil
	}

	// Services
	if container.Services != nil {
		serviceList := make([]map[string]v1.JSON, len(container.Services))
		for serviceIndex, serviceItem := range container.Services {
			// Shadow the loop variable to avoid aliasing
			serviceItem := serviceItem
			if serviceItem != nil {
				serviceMap := make(map[string]v1.JSON, len(serviceItem))
				for serviceKey, serviceValue := range serviceItem {
					// Shadow the loop variable to avoid aliasing
					serviceValue := serviceValue
					serviceMap[serviceKey] = *serviceValue.DeepCopy()
				}
				serviceList[serviceIndex] = serviceMap
			} else {
				serviceList[serviceIndex] = nil
			}
		}
		destination.Services = serviceList
	} else {
		destination.Services = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes information on user who created this ComputeInstance.
type ComputeInstanceCreatedBy_STATUS struct {
	// UserId: Uniquely identifies the user within his/her organization.
	UserId *string `json:"userId,omitempty"`

	// UserName: Name of the user.
	UserName *string `json:"userName,omitempty"`

	// UserOrgId: Uniquely identifies user' Azure Active Directory organization.
	UserOrgId *string `json:"userOrgId,omitempty"`
}

var _ genruntime.FromARMConverter = &ComputeInstanceCreatedBy_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (createdBy *ComputeInstanceCreatedBy_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComputeInstanceCreatedBy_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (createdBy *ComputeInstanceCreatedBy_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComputeInstanceCreatedBy_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComputeInstanceCreatedBy_STATUS, got %T", armInput)
	}

	// Set property "UserId":
	if typedInput.UserId != nil {
		userId := *typedInput.UserId
		createdBy.UserId = &userId
	}

	// Set property "UserName":
	if typedInput.UserName != nil {
		userName := *typedInput.UserName
		createdBy.UserName = &userName
	}

	// Set property "UserOrgId":
	if typedInput.UserOrgId != nil {
		userOrgId := *typedInput.UserOrgId
		createdBy.UserOrgId = &userOrgId
	}

	// No error
	return nil
}

// AssignProperties_From_ComputeInstanceCreatedBy_STATUS populates our ComputeInstanceCreatedBy_STATUS from the provided source ComputeInstanceCreatedBy_STATUS
func (createdBy *ComputeInstanceCreatedBy_STATUS) AssignProperties_From_ComputeInstanceCreatedBy_STATUS(source *storage.ComputeInstanceCreatedBy_STATUS) error {

	// UserId
	createdBy.UserId = genruntime.ClonePointerToString(source.UserId)

	// UserName
	createdBy.UserName = genruntime.ClonePointerToString(source.UserName)

	// UserOrgId
	createdBy.UserOrgId = genruntime.ClonePointerToString(source.UserOrgId)

	// No error
	return nil
}

// AssignProperties_To_ComputeInstanceCreatedBy_STATUS populates the provided destination ComputeInstanceCreatedBy_STATUS from our ComputeInstanceCreatedBy_STATUS
func (createdBy *ComputeInstanceCreatedBy_STATUS) AssignProperties_To_ComputeInstanceCreatedBy_STATUS(destination *storage.ComputeInstanceCreatedBy_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// UserId
	destination.UserId = genruntime.ClonePointerToString(createdBy.UserId)

	// UserName
	destination.UserName = genruntime.ClonePointerToString(createdBy.UserName)

	// UserOrgId
	destination.UserOrgId = genruntime.ClonePointerToString(createdBy.UserOrgId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines an Aml Instance DataDisk.
type ComputeInstanceDataDisk_STATUS struct {
	// Caching: Caching type of Data Disk.
	Caching *ComputeInstanceDataDisk_Caching_STATUS `json:"caching,omitempty"`

	// DiskSizeGB: The initial disk size in gigabytes.
	DiskSizeGB *int `json:"diskSizeGB,omitempty"`

	// Lun: The lun is used to uniquely identify each data disk. If attaching multiple disks, each should have a distinct lun.
	Lun *int `json:"lun,omitempty"`

	// StorageAccountType: type of this storage account.
	StorageAccountType *ComputeInstanceDataDisk_StorageAccountType_STATUS `json:"storageAccountType,omitempty"`
}

var _ genruntime.FromARMConverter = &ComputeInstanceDataDisk_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (disk *ComputeInstanceDataDisk_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComputeInstanceDataDisk_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (disk *ComputeInstanceDataDisk_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComputeInstanceDataDisk_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComputeInstanceDataDisk_STATUS, got %T", armInput)
	}

	// Set property "Caching":
	if typedInput.Caching != nil {
		var temp string
		temp = string(*typedInput.Caching)
		caching := ComputeInstanceDataDisk_Caching_STATUS(temp)
		disk.Caching = &caching
	}

	// Set property "DiskSizeGB":
	if typedInput.DiskSizeGB != nil {
		diskSizeGB := *typedInput.DiskSizeGB
		disk.DiskSizeGB = &diskSizeGB
	}

	// Set property "Lun":
	if typedInput.Lun != nil {
		lun := *typedInput.Lun
		disk.Lun = &lun
	}

	// Set property "StorageAccountType":
	if typedInput.StorageAccountType != nil {
		var temp string
		temp = string(*typedInput.StorageAccountType)
		storageAccountType := ComputeInstanceDataDisk_StorageAccountType_STATUS(temp)
		disk.StorageAccountType = &storageAccountType
	}

	// No error
	return nil
}

// AssignProperties_From_ComputeInstanceDataDisk_STATUS populates our ComputeInstanceDataDisk_STATUS from the provided source ComputeInstanceDataDisk_STATUS
func (disk *ComputeInstanceDataDisk_STATUS) AssignProperties_From_ComputeInstanceDataDisk_STATUS(source *storage.ComputeInstanceDataDisk_STATUS) error {

	// Caching
	if source.Caching != nil {
		caching := *source.Caching
		cachingTemp := genruntime.ToEnum(caching, computeInstanceDataDisk_Caching_STATUS_Values)
		disk.Caching = &cachingTemp
	} else {
		disk.Caching = nil
	}

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// Lun
	disk.Lun = genruntime.ClonePointerToInt(source.Lun)

	// StorageAccountType
	if source.StorageAccountType != nil {
		storageAccountType := *source.StorageAccountType
		storageAccountTypeTemp := genruntime.ToEnum(storageAccountType, computeInstanceDataDisk_StorageAccountType_STATUS_Values)
		disk.StorageAccountType = &storageAccountTypeTemp
	} else {
		disk.StorageAccountType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ComputeInstanceDataDisk_STATUS populates the provided destination ComputeInstanceDataDisk_STATUS from our ComputeInstanceDataDisk_STATUS
func (disk *ComputeInstanceDataDisk_STATUS) AssignProperties_To_ComputeInstanceDataDisk_STATUS(destination *storage.ComputeInstanceDataDisk_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Caching
	if disk.Caching != nil {
		caching := string(*disk.Caching)
		destination.Caching = &caching
	} else {
		destination.Caching = nil
	}

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// Lun
	destination.Lun = genruntime.ClonePointerToInt(disk.Lun)

	// StorageAccountType
	if disk.StorageAccountType != nil {
		storageAccountType := string(*disk.StorageAccountType)
		destination.StorageAccountType = &storageAccountType
	} else {
		destination.StorageAccountType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines an Aml Instance DataMount.
type ComputeInstanceDataMount_STATUS struct {
	// CreatedBy: who this data mount created by.
	CreatedBy *string `json:"createdBy,omitempty"`

	// Error: Error of this data mount.
	Error *string `json:"error,omitempty"`

	// MountAction: Mount Action.
	MountAction *ComputeInstanceDataMount_MountAction_STATUS `json:"mountAction,omitempty"`

	// MountName: name of the ComputeInstance data mount.
	MountName *string `json:"mountName,omitempty"`

	// MountPath: Path of this data mount.
	MountPath *string `json:"mountPath,omitempty"`

	// MountState: Mount state.
	MountState *ComputeInstanceDataMount_MountState_STATUS `json:"mountState,omitempty"`

	// MountedOn: The time when the disk mounted.
	MountedOn *string `json:"mountedOn,omitempty"`

	// Source: Source of the ComputeInstance data mount.
	Source *string `json:"source,omitempty"`

	// SourceType: Data source type.
	SourceType *ComputeInstanceDataMount_SourceType_STATUS `json:"sourceType,omitempty"`
}

var _ genruntime.FromARMConverter = &ComputeInstanceDataMount_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (mount *ComputeInstanceDataMount_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComputeInstanceDataMount_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (mount *ComputeInstanceDataMount_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComputeInstanceDataMount_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComputeInstanceDataMount_STATUS, got %T", armInput)
	}

	// Set property "CreatedBy":
	if typedInput.CreatedBy != nil {
		createdBy := *typedInput.CreatedBy
		mount.CreatedBy = &createdBy
	}

	// Set property "Error":
	if typedInput.Error != nil {
		error := *typedInput.Error
		mount.Error = &error
	}

	// Set property "MountAction":
	if typedInput.MountAction != nil {
		var temp string
		temp = string(*typedInput.MountAction)
		mountAction := ComputeInstanceDataMount_MountAction_STATUS(temp)
		mount.MountAction = &mountAction
	}

	// Set property "MountName":
	if typedInput.MountName != nil {
		mountName := *typedInput.MountName
		mount.MountName = &mountName
	}

	// Set property "MountPath":
	if typedInput.MountPath != nil {
		mountPath := *typedInput.MountPath
		mount.MountPath = &mountPath
	}

	// Set property "MountState":
	if typedInput.MountState != nil {
		var temp string
		temp = string(*typedInput.MountState)
		mountState := ComputeInstanceDataMount_MountState_STATUS(temp)
		mount.MountState = &mountState
	}

	// Set property "MountedOn":
	if typedInput.MountedOn != nil {
		mountedOn := *typedInput.MountedOn
		mount.MountedOn = &mountedOn
	}

	// Set property "Source":
	if typedInput.Source != nil {
		source := *typedInput.Source
		mount.Source = &source
	}

	// Set property "SourceType":
	if typedInput.SourceType != nil {
		var temp string
		temp = string(*typedInput.SourceType)
		sourceType := ComputeInstanceDataMount_SourceType_STATUS(temp)
		mount.SourceType = &sourceType
	}

	// No error
	return nil
}

// AssignProperties_From_ComputeInstanceDataMount_STATUS populates our ComputeInstanceDataMount_STATUS from the provided source ComputeInstanceDataMount_STATUS
func (mount *ComputeInstanceDataMount_STATUS) AssignProperties_From_ComputeInstanceDataMount_STATUS(source *storage.ComputeInstanceDataMount_STATUS) error {

	// CreatedBy
	mount.CreatedBy = genruntime.ClonePointerToString(source.CreatedBy)

	// Error
	mount.Error = genruntime.ClonePointerToString(source.Error)

	// MountAction
	if source.MountAction != nil {
		mountAction := *source.MountAction
		mountActionTemp := genruntime.ToEnum(mountAction, computeInstanceDataMount_MountAction_STATUS_Values)
		mount.MountAction = &mountActionTemp
	} else {
		mount.MountAction = nil
	}

	// MountName
	mount.MountName = genruntime.ClonePointerToString(source.MountName)

	// MountPath
	mount.MountPath = genruntime.ClonePointerToString(source.MountPath)

	// MountState
	if source.MountState != nil {
		mountState := *source.MountState
		mountStateTemp := genruntime.ToEnum(mountState, computeInstanceDataMount_MountState_STATUS_Values)
		mount.MountState = &mountStateTemp
	} else {
		mount.MountState = nil
	}

	// MountedOn
	mount.MountedOn = genruntime.ClonePointerToString(source.MountedOn)

	// Source
	mount.Source = genruntime.ClonePointerToString(source.Source)

	// SourceType
	if source.SourceType != nil {
		sourceType := *source.SourceType
		sourceTypeTemp := genruntime.ToEnum(sourceType, computeInstanceDataMount_SourceType_STATUS_Values)
		mount.SourceType = &sourceTypeTemp
	} else {
		mount.SourceType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ComputeInstanceDataMount_STATUS populates the provided destination ComputeInstanceDataMount_STATUS from our ComputeInstanceDataMount_STATUS
func (mount *ComputeInstanceDataMount_STATUS) AssignProperties_To_ComputeInstanceDataMount_STATUS(destination *storage.ComputeInstanceDataMount_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CreatedBy
	destination.CreatedBy = genruntime.ClonePointerToString(mount.CreatedBy)

	// Error
	destination.Error = genruntime.ClonePointerToString(mount.Error)

	// MountAction
	if mount.MountAction != nil {
		mountAction := string(*mount.MountAction)
		destination.MountAction = &mountAction
	} else {
		destination.MountAction = nil
	}

	// MountName
	destination.MountName = genruntime.ClonePointerToString(mount.MountName)

	// MountPath
	destination.MountPath = genruntime.ClonePointerToString(mount.MountPath)

	// MountState
	if mount.MountState != nil {
		mountState := string(*mount.MountState)
		destination.MountState = &mountState
	} else {
		destination.MountState = nil
	}

	// MountedOn
	destination.MountedOn = genruntime.ClonePointerToString(mount.MountedOn)

	// Source
	destination.Source = genruntime.ClonePointerToString(mount.Source)

	// SourceType
	if mount.SourceType != nil {
		sourceType := string(*mount.SourceType)
		destination.SourceType = &sourceType
	} else {
		destination.SourceType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The last operation on ComputeInstance.
type ComputeInstanceLastOperation_STATUS struct {
	// OperationName: Name of the last operation.
	OperationName *ComputeInstanceLastOperation_OperationName_STATUS `json:"operationName,omitempty"`

	// OperationStatus: Operation status.
	OperationStatus *ComputeInstanceLastOperation_OperationStatus_STATUS `json:"operationStatus,omitempty"`

	// OperationTime: Time of the last operation.
	OperationTime *string `json:"operationTime,omitempty"`

	// OperationTrigger: Trigger of operation.
	OperationTrigger *ComputeInstanceLastOperation_OperationTrigger_STATUS `json:"operationTrigger,omitempty"`
}

var _ genruntime.FromARMConverter = &ComputeInstanceLastOperation_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (operation *ComputeInstanceLastOperation_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComputeInstanceLastOperation_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (operation *ComputeInstanceLastOperation_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComputeInstanceLastOperation_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComputeInstanceLastOperation_STATUS, got %T", armInput)
	}

	// Set property "OperationName":
	if typedInput.OperationName != nil {
		var temp string
		temp = string(*typedInput.OperationName)
		operationName := ComputeInstanceLastOperation_OperationName_STATUS(temp)
		operation.OperationName = &operationName
	}

	// Set property "OperationStatus":
	if typedInput.OperationStatus != nil {
		var temp string
		temp = string(*typedInput.OperationStatus)
		operationStatus := ComputeInstanceLastOperation_OperationStatus_STATUS(temp)
		operation.OperationStatus = &operationStatus
	}

	// Set property "OperationTime":
	if typedInput.OperationTime != nil {
		operationTime := *typedInput.OperationTime
		operation.OperationTime = &operationTime
	}

	// Set property "OperationTrigger":
	if typedInput.OperationTrigger != nil {
		var temp string
		temp = string(*typedInput.OperationTrigger)
		operationTrigger := ComputeInstanceLastOperation_OperationTrigger_STATUS(temp)
		operation.OperationTrigger = &operationTrigger
	}

	// No error
	return nil
}

// AssignProperties_From_ComputeInstanceLastOperation_STATUS populates our ComputeInstanceLastOperation_STATUS from the provided source ComputeInstanceLastOperation_STATUS
func (operation *ComputeInstanceLastOperation_STATUS) AssignProperties_From_ComputeInstanceLastOperation_STATUS(source *storage.ComputeInstanceLastOperation_STATUS) error {

	// OperationName
	if source.OperationName != nil {
		operationName := *source.OperationName
		operationNameTemp := genruntime.ToEnum(operationName, computeInstanceLastOperation_OperationName_STATUS_Values)
		operation.OperationName = &operationNameTemp
	} else {
		operation.OperationName = nil
	}

	// OperationStatus
	if source.OperationStatus != nil {
		operationStatus := *source.OperationStatus
		operationStatusTemp := genruntime.ToEnum(operationStatus, computeInstanceLastOperation_OperationStatus_STATUS_Values)
		operation.OperationStatus = &operationStatusTemp
	} else {
		operation.OperationStatus = nil
	}

	// OperationTime
	operation.OperationTime = genruntime.ClonePointerToString(source.OperationTime)

	// OperationTrigger
	if source.OperationTrigger != nil {
		operationTrigger := *source.OperationTrigger
		operationTriggerTemp := genruntime.ToEnum(operationTrigger, computeInstanceLastOperation_OperationTrigger_STATUS_Values)
		operation.OperationTrigger = &operationTriggerTemp
	} else {
		operation.OperationTrigger = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ComputeInstanceLastOperation_STATUS populates the provided destination ComputeInstanceLastOperation_STATUS from our ComputeInstanceLastOperation_STATUS
func (operation *ComputeInstanceLastOperation_STATUS) AssignProperties_To_ComputeInstanceLastOperation_STATUS(destination *storage.ComputeInstanceLastOperation_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// OperationName
	if operation.OperationName != nil {
		operationName := string(*operation.OperationName)
		destination.OperationName = &operationName
	} else {
		destination.OperationName = nil
	}

	// OperationStatus
	if operation.OperationStatus != nil {
		operationStatus := string(*operation.OperationStatus)
		destination.OperationStatus = &operationStatus
	} else {
		destination.OperationStatus = nil
	}

	// OperationTime
	destination.OperationTime = genruntime.ClonePointerToString(operation.OperationTime)

	// OperationTrigger
	if operation.OperationTrigger != nil {
		operationTrigger := string(*operation.OperationTrigger)
		destination.OperationTrigger = &operationTrigger
	} else {
		destination.OperationTrigger = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Personal","Shared"}
type ComputeInstanceProperties_ApplicationSharingPolicy string

const (
	ComputeInstanceProperties_ApplicationSharingPolicy_Personal = ComputeInstanceProperties_ApplicationSharingPolicy("Personal")
	ComputeInstanceProperties_ApplicationSharingPolicy_Shared   = ComputeInstanceProperties_ApplicationSharingPolicy("Shared")
)

// Mapping from string to ComputeInstanceProperties_ApplicationSharingPolicy
var computeInstanceProperties_ApplicationSharingPolicy_Values = map[string]ComputeInstanceProperties_ApplicationSharingPolicy{
	"personal": ComputeInstanceProperties_ApplicationSharingPolicy_Personal,
	"shared":   ComputeInstanceProperties_ApplicationSharingPolicy_Shared,
}

type ComputeInstanceProperties_ApplicationSharingPolicy_STATUS string

const (
	ComputeInstanceProperties_ApplicationSharingPolicy_STATUS_Personal = ComputeInstanceProperties_ApplicationSharingPolicy_STATUS("Personal")
	ComputeInstanceProperties_ApplicationSharingPolicy_STATUS_Shared   = ComputeInstanceProperties_ApplicationSharingPolicy_STATUS("Shared")
)

// Mapping from string to ComputeInstanceProperties_ApplicationSharingPolicy_STATUS
var computeInstanceProperties_ApplicationSharingPolicy_STATUS_Values = map[string]ComputeInstanceProperties_ApplicationSharingPolicy_STATUS{
	"personal": ComputeInstanceProperties_ApplicationSharingPolicy_STATUS_Personal,
	"shared":   ComputeInstanceProperties_ApplicationSharingPolicy_STATUS_Shared,
}

// +kubebuilder:validation:Enum={"personal"}
type ComputeInstanceProperties_ComputeInstanceAuthorizationType string

const ComputeInstanceProperties_ComputeInstanceAuthorizationType_Personal = ComputeInstanceProperties_ComputeInstanceAuthorizationType("personal")

// Mapping from string to ComputeInstanceProperties_ComputeInstanceAuthorizationType
var computeInstanceProperties_ComputeInstanceAuthorizationType_Values = map[string]ComputeInstanceProperties_ComputeInstanceAuthorizationType{
	"personal": ComputeInstanceProperties_ComputeInstanceAuthorizationType_Personal,
}

type ComputeInstanceProperties_ComputeInstanceAuthorizationType_STATUS string

const ComputeInstanceProperties_ComputeInstanceAuthorizationType_STATUS_Personal = ComputeInstanceProperties_ComputeInstanceAuthorizationType_STATUS("personal")

// Mapping from string to ComputeInstanceProperties_ComputeInstanceAuthorizationType_STATUS
var computeInstanceProperties_ComputeInstanceAuthorizationType_STATUS_Values = map[string]ComputeInstanceProperties_ComputeInstanceAuthorizationType_STATUS{
	"personal": ComputeInstanceProperties_ComputeInstanceAuthorizationType_STATUS_Personal,
}

// Specifies policy and settings for SSH access.
type ComputeInstanceSshSettings struct {
	// AdminPublicKey: Specifies the SSH rsa public key file as a string. Use "ssh-keygen -t rsa -b 2048" to generate your SSH
	// key pairs.
	AdminPublicKey *string `json:"adminPublicKey,omitempty"`

	// SshPublicAccess: State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is
	// closed on this instance. Enabled - Indicates that the public ssh port is open and accessible according to the
	// VNet/subnet policy if applicable.
	SshPublicAccess *ComputeInstanceSshSettings_SshPublicAccess `json:"sshPublicAccess,omitempty"`
}

var _ genruntime.ARMTransformer = &ComputeInstanceSshSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *ComputeInstanceSshSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.ComputeInstanceSshSettings{}

	// Set property "AdminPublicKey":
	if settings.AdminPublicKey != nil {
		adminPublicKey := *settings.AdminPublicKey
		result.AdminPublicKey = &adminPublicKey
	}

	// Set property "SshPublicAccess":
	if settings.SshPublicAccess != nil {
		var temp string
		temp = string(*settings.SshPublicAccess)
		sshPublicAccess := arm.ComputeInstanceSshSettings_SshPublicAccess(temp)
		result.SshPublicAccess = &sshPublicAccess
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *ComputeInstanceSshSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComputeInstanceSshSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *ComputeInstanceSshSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComputeInstanceSshSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComputeInstanceSshSettings, got %T", armInput)
	}

	// Set property "AdminPublicKey":
	if typedInput.AdminPublicKey != nil {
		adminPublicKey := *typedInput.AdminPublicKey
		settings.AdminPublicKey = &adminPublicKey
	}

	// Set property "SshPublicAccess":
	if typedInput.SshPublicAccess != nil {
		var temp string
		temp = string(*typedInput.SshPublicAccess)
		sshPublicAccess := ComputeInstanceSshSettings_SshPublicAccess(temp)
		settings.SshPublicAccess = &sshPublicAccess
	}

	// No error
	return nil
}

// AssignProperties_From_ComputeInstanceSshSettings populates our ComputeInstanceSshSettings from the provided source ComputeInstanceSshSettings
func (settings *ComputeInstanceSshSettings) AssignProperties_From_ComputeInstanceSshSettings(source *storage.ComputeInstanceSshSettings) error {

	// AdminPublicKey
	settings.AdminPublicKey = genruntime.ClonePointerToString(source.AdminPublicKey)

	// SshPublicAccess
	if source.SshPublicAccess != nil {
		sshPublicAccess := *source.SshPublicAccess
		sshPublicAccessTemp := genruntime.ToEnum(sshPublicAccess, computeInstanceSshSettings_SshPublicAccess_Values)
		settings.SshPublicAccess = &sshPublicAccessTemp
	} else {
		settings.SshPublicAccess = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ComputeInstanceSshSettings populates the provided destination ComputeInstanceSshSettings from our ComputeInstanceSshSettings
func (settings *ComputeInstanceSshSettings) AssignProperties_To_ComputeInstanceSshSettings(destination *storage.ComputeInstanceSshSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminPublicKey
	destination.AdminPublicKey = genruntime.ClonePointerToString(settings.AdminPublicKey)

	// SshPublicAccess
	if settings.SshPublicAccess != nil {
		sshPublicAccess := string(*settings.SshPublicAccess)
		destination.SshPublicAccess = &sshPublicAccess
	} else {
		destination.SshPublicAccess = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ComputeInstanceSshSettings_STATUS populates our ComputeInstanceSshSettings from the provided source ComputeInstanceSshSettings_STATUS
func (settings *ComputeInstanceSshSettings) Initialize_From_ComputeInstanceSshSettings_STATUS(source *ComputeInstanceSshSettings_STATUS) error {

	// AdminPublicKey
	settings.AdminPublicKey = genruntime.ClonePointerToString(source.AdminPublicKey)

	// SshPublicAccess
	if source.SshPublicAccess != nil {
		sshPublicAccess := genruntime.ToEnum(string(*source.SshPublicAccess), computeInstanceSshSettings_SshPublicAccess_Values)
		settings.SshPublicAccess = &sshPublicAccess
	} else {
		settings.SshPublicAccess = nil
	}

	// No error
	return nil
}

// Specifies policy and settings for SSH access.
type ComputeInstanceSshSettings_STATUS struct {
	// AdminPublicKey: Specifies the SSH rsa public key file as a string. Use "ssh-keygen -t rsa -b 2048" to generate your SSH
	// key pairs.
	AdminPublicKey *string `json:"adminPublicKey,omitempty"`

	// AdminUserName: Describes the admin user name.
	AdminUserName *string `json:"adminUserName,omitempty"`

	// SshPort: Describes the port for connecting through SSH.
	SshPort *int `json:"sshPort,omitempty"`

	// SshPublicAccess: State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is
	// closed on this instance. Enabled - Indicates that the public ssh port is open and accessible according to the
	// VNet/subnet policy if applicable.
	SshPublicAccess *ComputeInstanceSshSettings_SshPublicAccess_STATUS `json:"sshPublicAccess,omitempty"`
}

var _ genruntime.FromARMConverter = &ComputeInstanceSshSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *ComputeInstanceSshSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComputeInstanceSshSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *ComputeInstanceSshSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComputeInstanceSshSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComputeInstanceSshSettings_STATUS, got %T", armInput)
	}

	// Set property "AdminPublicKey":
	if typedInput.AdminPublicKey != nil {
		adminPublicKey := *typedInput.AdminPublicKey
		settings.AdminPublicKey = &adminPublicKey
	}

	// Set property "AdminUserName":
	if typedInput.AdminUserName != nil {
		adminUserName := *typedInput.AdminUserName
		settings.AdminUserName = &adminUserName
	}

	// Set property "SshPort":
	if typedInput.SshPort != nil {
		sshPort := *typedInput.SshPort
		settings.SshPort = &sshPort
	}

	// Set property "SshPublicAccess":
	if typedInput.SshPublicAccess != nil {
		var temp string
		temp = string(*typedInput.SshPublicAccess)
		sshPublicAccess := ComputeInstanceSshSettings_SshPublicAccess_STATUS(temp)
		settings.SshPublicAccess = &sshPublicAccess
	}

	// No error
	return nil
}

// AssignProperties_From_ComputeInstanceSshSettings_STATUS populates our ComputeInstanceSshSettings_STATUS from the provided source ComputeInstanceSshSettings_STATUS
func (settings *ComputeInstanceSshSettings_STATUS) AssignProperties_From_ComputeInstanceSshSettings_STATUS(source *storage.ComputeInstanceSshSettings_STATUS) error {

	// AdminPublicKey
	settings.AdminPublicKey = genruntime.ClonePointerToString(source.AdminPublicKey)

	// AdminUserName
	settings.AdminUserName = genruntime.ClonePointerToString(source.AdminUserName)

	// SshPort
	settings.SshPort = genruntime.ClonePointerToInt(source.SshPort)

	// SshPublicAccess
	if source.SshPublicAccess != nil {
		sshPublicAccess := *source.SshPublicAccess
		sshPublicAccessTemp := genruntime.ToEnum(sshPublicAccess, computeInstanceSshSettings_SshPublicAccess_STATUS_Values)
		settings.SshPublicAccess = &sshPublicAccessTemp
	} else {
		settings.SshPublicAccess = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ComputeInstanceSshSettings_STATUS populates the provided destination ComputeInstanceSshSettings_STATUS from our ComputeInstanceSshSettings_STATUS
func (settings *ComputeInstanceSshSettings_STATUS) AssignProperties_To_ComputeInstanceSshSettings_STATUS(destination *storage.ComputeInstanceSshSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminPublicKey
	destination.AdminPublicKey = genruntime.ClonePointerToString(settings.AdminPublicKey)

	// AdminUserName
	destination.AdminUserName = genruntime.ClonePointerToString(settings.AdminUserName)

	// SshPort
	destination.SshPort = genruntime.ClonePointerToInt(settings.SshPort)

	// SshPublicAccess
	if settings.SshPublicAccess != nil {
		sshPublicAccess := string(*settings.SshPublicAccess)
		destination.SshPublicAccess = &sshPublicAccess
	} else {
		destination.SshPublicAccess = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Current state of an ComputeInstance.
type ComputeInstanceState_STATUS string

const (
	ComputeInstanceState_STATUS_CreateFailed    = ComputeInstanceState_STATUS("CreateFailed")
	ComputeInstanceState_STATUS_Creating        = ComputeInstanceState_STATUS("Creating")
	ComputeInstanceState_STATUS_Deleting        = ComputeInstanceState_STATUS("Deleting")
	ComputeInstanceState_STATUS_JobRunning      = ComputeInstanceState_STATUS("JobRunning")
	ComputeInstanceState_STATUS_Restarting      = ComputeInstanceState_STATUS("Restarting")
	ComputeInstanceState_STATUS_Running         = ComputeInstanceState_STATUS("Running")
	ComputeInstanceState_STATUS_SettingUp       = ComputeInstanceState_STATUS("SettingUp")
	ComputeInstanceState_STATUS_SetupFailed     = ComputeInstanceState_STATUS("SetupFailed")
	ComputeInstanceState_STATUS_Starting        = ComputeInstanceState_STATUS("Starting")
	ComputeInstanceState_STATUS_Stopped         = ComputeInstanceState_STATUS("Stopped")
	ComputeInstanceState_STATUS_Stopping        = ComputeInstanceState_STATUS("Stopping")
	ComputeInstanceState_STATUS_Unknown         = ComputeInstanceState_STATUS("Unknown")
	ComputeInstanceState_STATUS_Unusable        = ComputeInstanceState_STATUS("Unusable")
	ComputeInstanceState_STATUS_UserSettingUp   = ComputeInstanceState_STATUS("UserSettingUp")
	ComputeInstanceState_STATUS_UserSetupFailed = ComputeInstanceState_STATUS("UserSetupFailed")
)

// Mapping from string to ComputeInstanceState_STATUS
var computeInstanceState_STATUS_Values = map[string]ComputeInstanceState_STATUS{
	"createfailed":    ComputeInstanceState_STATUS_CreateFailed,
	"creating":        ComputeInstanceState_STATUS_Creating,
	"deleting":        ComputeInstanceState_STATUS_Deleting,
	"jobrunning":      ComputeInstanceState_STATUS_JobRunning,
	"restarting":      ComputeInstanceState_STATUS_Restarting,
	"running":         ComputeInstanceState_STATUS_Running,
	"settingup":       ComputeInstanceState_STATUS_SettingUp,
	"setupfailed":     ComputeInstanceState_STATUS_SetupFailed,
	"starting":        ComputeInstanceState_STATUS_Starting,
	"stopped":         ComputeInstanceState_STATUS_Stopped,
	"stopping":        ComputeInstanceState_STATUS_Stopping,
	"unknown":         ComputeInstanceState_STATUS_Unknown,
	"unusable":        ComputeInstanceState_STATUS_Unusable,
	"usersettingup":   ComputeInstanceState_STATUS_UserSettingUp,
	"usersetupfailed": ComputeInstanceState_STATUS_UserSetupFailed,
}

// Version of computeInstance.
type ComputeInstanceVersion_STATUS struct {
	// Runtime: Runtime of compute instance.
	Runtime *string `json:"runtime,omitempty"`
}

var _ genruntime.FromARMConverter = &ComputeInstanceVersion_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (version *ComputeInstanceVersion_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComputeInstanceVersion_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (version *ComputeInstanceVersion_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComputeInstanceVersion_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComputeInstanceVersion_STATUS, got %T", armInput)
	}

	// Set property "Runtime":
	if typedInput.Runtime != nil {
		runtime := *typedInput.Runtime
		version.Runtime = &runtime
	}

	// No error
	return nil
}

// AssignProperties_From_ComputeInstanceVersion_STATUS populates our ComputeInstanceVersion_STATUS from the provided source ComputeInstanceVersion_STATUS
func (version *ComputeInstanceVersion_STATUS) AssignProperties_From_ComputeInstanceVersion_STATUS(source *storage.ComputeInstanceVersion_STATUS) error {

	// Runtime
	version.Runtime = genruntime.ClonePointerToString(source.Runtime)

	// No error
	return nil
}

// AssignProperties_To_ComputeInstanceVersion_STATUS populates the provided destination ComputeInstanceVersion_STATUS from our ComputeInstanceVersion_STATUS
func (version *ComputeInstanceVersion_STATUS) AssignProperties_To_ComputeInstanceVersion_STATUS(destination *storage.ComputeInstanceVersion_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Runtime
	destination.Runtime = genruntime.ClonePointerToString(version.Runtime)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The list of schedules to be applied on the computes
type ComputeSchedules struct {
	// ComputeStartStop: The list of compute start stop schedules to be applied.
	ComputeStartStop []ComputeStartStopSchedule `json:"computeStartStop,omitempty"`
}

var _ genruntime.ARMTransformer = &ComputeSchedules{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (schedules *ComputeSchedules) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if schedules == nil {
		return nil, nil
	}
	result := &arm.ComputeSchedules{}

	// Set property "ComputeStartStop":
	for _, item := range schedules.ComputeStartStop {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.ComputeStartStop = append(result.ComputeStartStop, *item_ARM.(*arm.ComputeStartStopSchedule))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (schedules *ComputeSchedules) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComputeSchedules{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (schedules *ComputeSchedules) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComputeSchedules)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComputeSchedules, got %T", armInput)
	}

	// Set property "ComputeStartStop":
	for _, item := range typedInput.ComputeStartStop {
		var item1 ComputeStartStopSchedule
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		schedules.ComputeStartStop = append(schedules.ComputeStartStop, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ComputeSchedules populates our ComputeSchedules from the provided source ComputeSchedules
func (schedules *ComputeSchedules) AssignProperties_From_ComputeSchedules(source *storage.ComputeSchedules) error {

	// ComputeStartStop
	if source.ComputeStartStop != nil {
		computeStartStopList := make([]ComputeStartStopSchedule, len(source.ComputeStartStop))
		for computeStartStopIndex, computeStartStopItem := range source.ComputeStartStop {
			// Shadow the loop variable to avoid aliasing
			computeStartStopItem := computeStartStopItem
			var computeStartStop ComputeStartStopSchedule
			err := computeStartStop.AssignProperties_From_ComputeStartStopSchedule(&computeStartStopItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ComputeStartStopSchedule() to populate field ComputeStartStop")
			}
			computeStartStopList[computeStartStopIndex] = computeStartStop
		}
		schedules.ComputeStartStop = computeStartStopList
	} else {
		schedules.ComputeStartStop = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ComputeSchedules populates the provided destination ComputeSchedules from our ComputeSchedules
func (schedules *ComputeSchedules) AssignProperties_To_ComputeSchedules(destination *storage.ComputeSchedules) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeStartStop
	if schedules.ComputeStartStop != nil {
		computeStartStopList := make([]storage.ComputeStartStopSchedule, len(schedules.ComputeStartStop))
		for computeStartStopIndex, computeStartStopItem := range schedules.ComputeStartStop {
			// Shadow the loop variable to avoid aliasing
			computeStartStopItem := computeStartStopItem
			var computeStartStop storage.ComputeStartStopSchedule
			err := computeStartStopItem.AssignProperties_To_ComputeStartStopSchedule(&computeStartStop)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ComputeStartStopSchedule() to populate field ComputeStartStop")
			}
			computeStartStopList[computeStartStopIndex] = computeStartStop
		}
		destination.ComputeStartStop = computeStartStopList
	} else {
		destination.ComputeStartStop = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ComputeSchedules_STATUS populates our ComputeSchedules from the provided source ComputeSchedules_STATUS
func (schedules *ComputeSchedules) Initialize_From_ComputeSchedules_STATUS(source *ComputeSchedules_STATUS) error {

	// ComputeStartStop
	if source.ComputeStartStop != nil {
		computeStartStopList := make([]ComputeStartStopSchedule, len(source.ComputeStartStop))
		for computeStartStopIndex, computeStartStopItem := range source.ComputeStartStop {
			// Shadow the loop variable to avoid aliasing
			computeStartStopItem := computeStartStopItem
			var computeStartStop ComputeStartStopSchedule
			err := computeStartStop.Initialize_From_ComputeStartStopSchedule_STATUS(&computeStartStopItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ComputeStartStopSchedule_STATUS() to populate field ComputeStartStop")
			}
			computeStartStopList[computeStartStopIndex] = computeStartStop
		}
		schedules.ComputeStartStop = computeStartStopList
	} else {
		schedules.ComputeStartStop = nil
	}

	// No error
	return nil
}

// The list of schedules to be applied on the computes
type ComputeSchedules_STATUS struct {
	// ComputeStartStop: The list of compute start stop schedules to be applied.
	ComputeStartStop []ComputeStartStopSchedule_STATUS `json:"computeStartStop,omitempty"`
}

var _ genruntime.FromARMConverter = &ComputeSchedules_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (schedules *ComputeSchedules_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComputeSchedules_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (schedules *ComputeSchedules_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComputeSchedules_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComputeSchedules_STATUS, got %T", armInput)
	}

	// Set property "ComputeStartStop":
	for _, item := range typedInput.ComputeStartStop {
		var item1 ComputeStartStopSchedule_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		schedules.ComputeStartStop = append(schedules.ComputeStartStop, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ComputeSchedules_STATUS populates our ComputeSchedules_STATUS from the provided source ComputeSchedules_STATUS
func (schedules *ComputeSchedules_STATUS) AssignProperties_From_ComputeSchedules_STATUS(source *storage.ComputeSchedules_STATUS) error {

	// ComputeStartStop
	if source.ComputeStartStop != nil {
		computeStartStopList := make([]ComputeStartStopSchedule_STATUS, len(source.ComputeStartStop))
		for computeStartStopIndex, computeStartStopItem := range source.ComputeStartStop {
			// Shadow the loop variable to avoid aliasing
			computeStartStopItem := computeStartStopItem
			var computeStartStop ComputeStartStopSchedule_STATUS
			err := computeStartStop.AssignProperties_From_ComputeStartStopSchedule_STATUS(&computeStartStopItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ComputeStartStopSchedule_STATUS() to populate field ComputeStartStop")
			}
			computeStartStopList[computeStartStopIndex] = computeStartStop
		}
		schedules.ComputeStartStop = computeStartStopList
	} else {
		schedules.ComputeStartStop = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ComputeSchedules_STATUS populates the provided destination ComputeSchedules_STATUS from our ComputeSchedules_STATUS
func (schedules *ComputeSchedules_STATUS) AssignProperties_To_ComputeSchedules_STATUS(destination *storage.ComputeSchedules_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeStartStop
	if schedules.ComputeStartStop != nil {
		computeStartStopList := make([]storage.ComputeStartStopSchedule_STATUS, len(schedules.ComputeStartStop))
		for computeStartStopIndex, computeStartStopItem := range schedules.ComputeStartStop {
			// Shadow the loop variable to avoid aliasing
			computeStartStopItem := computeStartStopItem
			var computeStartStop storage.ComputeStartStopSchedule_STATUS
			err := computeStartStopItem.AssignProperties_To_ComputeStartStopSchedule_STATUS(&computeStartStop)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ComputeStartStopSchedule_STATUS() to populate field ComputeStartStop")
			}
			computeStartStopList[computeStartStopIndex] = computeStartStop
		}
		destination.ComputeStartStop = computeStartStopList
	} else {
		destination.ComputeStartStop = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Specifies the custom service configuration
type CustomService struct {
	// Docker: Describes the docker settings for the image
	Docker *Docker `json:"docker,omitempty"`

	// Endpoints: Configuring the endpoints for the container
	Endpoints []Endpoint `json:"endpoints,omitempty"`

	// EnvironmentVariables: Environment Variable for the container
	EnvironmentVariables map[string]EnvironmentVariable `json:"environmentVariables,omitempty"`

	// Image: Describes the Image Specifications
	Image *Image `json:"image,omitempty"`

	// Name: Name of the Custom Service
	Name *string `json:"name,omitempty"`

	// Volumes: Configuring the volumes for the container
	Volumes []VolumeDefinition `json:"volumes,omitempty"`
}

var _ genruntime.ARMTransformer = &CustomService{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (service *CustomService) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if service == nil {
		return nil, nil
	}
	result := &arm.CustomService{}

	// Set property "Docker":
	if service.Docker != nil {
		docker_ARM, err := (*service.Docker).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		docker := *docker_ARM.(*arm.Docker)
		result.Docker = &docker
	}

	// Set property "Endpoints":
	for _, item := range service.Endpoints {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Endpoints = append(result.Endpoints, *item_ARM.(*arm.Endpoint))
	}

	// Set property "EnvironmentVariables":
	if service.EnvironmentVariables != nil {
		result.EnvironmentVariables = make(map[string]arm.EnvironmentVariable, len(service.EnvironmentVariables))
		for key, value := range service.EnvironmentVariables {
			value_ARM, err := value.ConvertToARM(resolved)
			if err != nil {
				return nil, err
			}
			result.EnvironmentVariables[key] = *value_ARM.(*arm.EnvironmentVariable)
		}
	}

	// Set property "Image":
	if service.Image != nil {
		image_ARM, err := (*service.Image).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		image := *image_ARM.(*arm.Image)
		result.Image = &image
	}

	// Set property "Name":
	if service.Name != nil {
		name := *service.Name
		result.Name = &name
	}

	// Set property "Volumes":
	for _, item := range service.Volumes {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Volumes = append(result.Volumes, *item_ARM.(*arm.VolumeDefinition))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (service *CustomService) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CustomService{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (service *CustomService) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CustomService)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CustomService, got %T", armInput)
	}

	// Set property "Docker":
	if typedInput.Docker != nil {
		var docker1 Docker
		err := docker1.PopulateFromARM(owner, *typedInput.Docker)
		if err != nil {
			return err
		}
		docker := docker1
		service.Docker = &docker
	}

	// Set property "Endpoints":
	for _, item := range typedInput.Endpoints {
		var item1 Endpoint
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		service.Endpoints = append(service.Endpoints, item1)
	}

	// Set property "EnvironmentVariables":
	if typedInput.EnvironmentVariables != nil {
		service.EnvironmentVariables = make(map[string]EnvironmentVariable, len(typedInput.EnvironmentVariables))
		for key, value := range typedInput.EnvironmentVariables {
			var value1 EnvironmentVariable
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			service.EnvironmentVariables[key] = value1
		}
	}

	// Set property "Image":
	if typedInput.Image != nil {
		var image1 Image
		err := image1.PopulateFromARM(owner, *typedInput.Image)
		if err != nil {
			return err
		}
		image := image1
		service.Image = &image
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		service.Name = &name
	}

	// Set property "Volumes":
	for _, item := range typedInput.Volumes {
		var item1 VolumeDefinition
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		service.Volumes = append(service.Volumes, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_CustomService populates our CustomService from the provided source CustomService
func (service *CustomService) AssignProperties_From_CustomService(source *storage.CustomService) error {

	// Docker
	if source.Docker != nil {
		var docker Docker
		err := docker.AssignProperties_From_Docker(source.Docker)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Docker() to populate field Docker")
		}
		service.Docker = &docker
	} else {
		service.Docker = nil
	}

	// Endpoints
	if source.Endpoints != nil {
		endpointList := make([]Endpoint, len(source.Endpoints))
		for endpointIndex, endpointItem := range source.Endpoints {
			// Shadow the loop variable to avoid aliasing
			endpointItem := endpointItem
			var endpoint Endpoint
			err := endpoint.AssignProperties_From_Endpoint(&endpointItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_Endpoint() to populate field Endpoints")
			}
			endpointList[endpointIndex] = endpoint
		}
		service.Endpoints = endpointList
	} else {
		service.Endpoints = nil
	}

	// EnvironmentVariables
	if source.EnvironmentVariables != nil {
		environmentVariableMap := make(map[string]EnvironmentVariable, len(source.EnvironmentVariables))
		for environmentVariableKey, environmentVariableValue := range source.EnvironmentVariables {
			// Shadow the loop variable to avoid aliasing
			environmentVariableValue := environmentVariableValue
			var environmentVariable EnvironmentVariable
			err := environmentVariable.AssignProperties_From_EnvironmentVariable(&environmentVariableValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_EnvironmentVariable() to populate field EnvironmentVariables")
			}
			environmentVariableMap[environmentVariableKey] = environmentVariable
		}
		service.EnvironmentVariables = environmentVariableMap
	} else {
		service.EnvironmentVariables = nil
	}

	// Image
	if source.Image != nil {
		var image Image
		err := image.AssignProperties_From_Image(source.Image)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Image() to populate field Image")
		}
		service.Image = &image
	} else {
		service.Image = nil
	}

	// Name
	service.Name = genruntime.ClonePointerToString(source.Name)

	// Volumes
	if source.Volumes != nil {
		volumeList := make([]VolumeDefinition, len(source.Volumes))
		for volumeIndex, volumeItem := range source.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume VolumeDefinition
			err := volume.AssignProperties_From_VolumeDefinition(&volumeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VolumeDefinition() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		service.Volumes = volumeList
	} else {
		service.Volumes = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CustomService populates the provided destination CustomService from our CustomService
func (service *CustomService) AssignProperties_To_CustomService(destination *storage.CustomService) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Docker
	if service.Docker != nil {
		var docker storage.Docker
		err := service.Docker.AssignProperties_To_Docker(&docker)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Docker() to populate field Docker")
		}
		destination.Docker = &docker
	} else {
		destination.Docker = nil
	}

	// Endpoints
	if service.Endpoints != nil {
		endpointList := make([]storage.Endpoint, len(service.Endpoints))
		for endpointIndex, endpointItem := range service.Endpoints {
			// Shadow the loop variable to avoid aliasing
			endpointItem := endpointItem
			var endpoint storage.Endpoint
			err := endpointItem.AssignProperties_To_Endpoint(&endpoint)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_Endpoint() to populate field Endpoints")
			}
			endpointList[endpointIndex] = endpoint
		}
		destination.Endpoints = endpointList
	} else {
		destination.Endpoints = nil
	}

	// EnvironmentVariables
	if service.EnvironmentVariables != nil {
		environmentVariableMap := make(map[string]storage.EnvironmentVariable, len(service.EnvironmentVariables))
		for environmentVariableKey, environmentVariableValue := range service.EnvironmentVariables {
			// Shadow the loop variable to avoid aliasing
			environmentVariableValue := environmentVariableValue
			var environmentVariable storage.EnvironmentVariable
			err := environmentVariableValue.AssignProperties_To_EnvironmentVariable(&environmentVariable)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_EnvironmentVariable() to populate field EnvironmentVariables")
			}
			environmentVariableMap[environmentVariableKey] = environmentVariable
		}
		destination.EnvironmentVariables = environmentVariableMap
	} else {
		destination.EnvironmentVariables = nil
	}

	// Image
	if service.Image != nil {
		var image storage.Image
		err := service.Image.AssignProperties_To_Image(&image)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Image() to populate field Image")
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(service.Name)

	// Volumes
	if service.Volumes != nil {
		volumeList := make([]storage.VolumeDefinition, len(service.Volumes))
		for volumeIndex, volumeItem := range service.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume storage.VolumeDefinition
			err := volumeItem.AssignProperties_To_VolumeDefinition(&volume)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VolumeDefinition() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		destination.Volumes = volumeList
	} else {
		destination.Volumes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_CustomService_STATUS populates our CustomService from the provided source CustomService_STATUS
func (service *CustomService) Initialize_From_CustomService_STATUS(source *CustomService_STATUS) error {

	// Docker
	if source.Docker != nil {
		var docker Docker
		err := docker.Initialize_From_Docker_STATUS(source.Docker)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_Docker_STATUS() to populate field Docker")
		}
		service.Docker = &docker
	} else {
		service.Docker = nil
	}

	// Endpoints
	if source.Endpoints != nil {
		endpointList := make([]Endpoint, len(source.Endpoints))
		for endpointIndex, endpointItem := range source.Endpoints {
			// Shadow the loop variable to avoid aliasing
			endpointItem := endpointItem
			var endpoint Endpoint
			err := endpoint.Initialize_From_Endpoint_STATUS(&endpointItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_Endpoint_STATUS() to populate field Endpoints")
			}
			endpointList[endpointIndex] = endpoint
		}
		service.Endpoints = endpointList
	} else {
		service.Endpoints = nil
	}

	// EnvironmentVariables
	if source.EnvironmentVariables != nil {
		environmentVariableMap := make(map[string]EnvironmentVariable, len(source.EnvironmentVariables))
		for environmentVariableKey, environmentVariableValue := range source.EnvironmentVariables {
			// Shadow the loop variable to avoid aliasing
			environmentVariableValue := environmentVariableValue
			var environmentVariable EnvironmentVariable
			err := environmentVariable.Initialize_From_EnvironmentVariable_STATUS(&environmentVariableValue)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_EnvironmentVariable_STATUS() to populate field EnvironmentVariables")
			}
			environmentVariableMap[environmentVariableKey] = environmentVariable
		}
		service.EnvironmentVariables = environmentVariableMap
	} else {
		service.EnvironmentVariables = nil
	}

	// Image
	if source.Image != nil {
		var image Image
		err := image.Initialize_From_Image_STATUS(source.Image)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_Image_STATUS() to populate field Image")
		}
		service.Image = &image
	} else {
		service.Image = nil
	}

	// Name
	service.Name = genruntime.ClonePointerToString(source.Name)

	// Volumes
	if source.Volumes != nil {
		volumeList := make([]VolumeDefinition, len(source.Volumes))
		for volumeIndex, volumeItem := range source.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume VolumeDefinition
			err := volume.Initialize_From_VolumeDefinition_STATUS(&volumeItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_VolumeDefinition_STATUS() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		service.Volumes = volumeList
	} else {
		service.Volumes = nil
	}

	// No error
	return nil
}

// Specifies the custom service configuration
type CustomService_STATUS struct {
	// Docker: Describes the docker settings for the image
	Docker *Docker_STATUS `json:"docker,omitempty"`

	// Endpoints: Configuring the endpoints for the container
	Endpoints []Endpoint_STATUS `json:"endpoints,omitempty"`

	// EnvironmentVariables: Environment Variable for the container
	EnvironmentVariables map[string]EnvironmentVariable_STATUS `json:"environmentVariables,omitempty"`

	// Image: Describes the Image Specifications
	Image *Image_STATUS `json:"image,omitempty"`

	// Name: Name of the Custom Service
	Name *string `json:"name,omitempty"`

	// Volumes: Configuring the volumes for the container
	Volumes []VolumeDefinition_STATUS `json:"volumes,omitempty"`
}

var _ genruntime.FromARMConverter = &CustomService_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (service *CustomService_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CustomService_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (service *CustomService_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CustomService_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CustomService_STATUS, got %T", armInput)
	}

	// Set property "Docker":
	if typedInput.Docker != nil {
		var docker1 Docker_STATUS
		err := docker1.PopulateFromARM(owner, *typedInput.Docker)
		if err != nil {
			return err
		}
		docker := docker1
		service.Docker = &docker
	}

	// Set property "Endpoints":
	for _, item := range typedInput.Endpoints {
		var item1 Endpoint_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		service.Endpoints = append(service.Endpoints, item1)
	}

	// Set property "EnvironmentVariables":
	if typedInput.EnvironmentVariables != nil {
		service.EnvironmentVariables = make(map[string]EnvironmentVariable_STATUS, len(typedInput.EnvironmentVariables))
		for key, value := range typedInput.EnvironmentVariables {
			var value1 EnvironmentVariable_STATUS
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			service.EnvironmentVariables[key] = value1
		}
	}

	// Set property "Image":
	if typedInput.Image != nil {
		var image1 Image_STATUS
		err := image1.PopulateFromARM(owner, *typedInput.Image)
		if err != nil {
			return err
		}
		image := image1
		service.Image = &image
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		service.Name = &name
	}

	// Set property "Volumes":
	for _, item := range typedInput.Volumes {
		var item1 VolumeDefinition_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		service.Volumes = append(service.Volumes, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_CustomService_STATUS populates our CustomService_STATUS from the provided source CustomService_STATUS
func (service *CustomService_STATUS) AssignProperties_From_CustomService_STATUS(source *storage.CustomService_STATUS) error {

	// Docker
	if source.Docker != nil {
		var docker Docker_STATUS
		err := docker.AssignProperties_From_Docker_STATUS(source.Docker)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Docker_STATUS() to populate field Docker")
		}
		service.Docker = &docker
	} else {
		service.Docker = nil
	}

	// Endpoints
	if source.Endpoints != nil {
		endpointList := make([]Endpoint_STATUS, len(source.Endpoints))
		for endpointIndex, endpointItem := range source.Endpoints {
			// Shadow the loop variable to avoid aliasing
			endpointItem := endpointItem
			var endpoint Endpoint_STATUS
			err := endpoint.AssignProperties_From_Endpoint_STATUS(&endpointItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_Endpoint_STATUS() to populate field Endpoints")
			}
			endpointList[endpointIndex] = endpoint
		}
		service.Endpoints = endpointList
	} else {
		service.Endpoints = nil
	}

	// EnvironmentVariables
	if source.EnvironmentVariables != nil {
		environmentVariableMap := make(map[string]EnvironmentVariable_STATUS, len(source.EnvironmentVariables))
		for environmentVariableKey, environmentVariableValue := range source.EnvironmentVariables {
			// Shadow the loop variable to avoid aliasing
			environmentVariableValue := environmentVariableValue
			var environmentVariable EnvironmentVariable_STATUS
			err := environmentVariable.AssignProperties_From_EnvironmentVariable_STATUS(&environmentVariableValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_EnvironmentVariable_STATUS() to populate field EnvironmentVariables")
			}
			environmentVariableMap[environmentVariableKey] = environmentVariable
		}
		service.EnvironmentVariables = environmentVariableMap
	} else {
		service.EnvironmentVariables = nil
	}

	// Image
	if source.Image != nil {
		var image Image_STATUS
		err := image.AssignProperties_From_Image_STATUS(source.Image)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Image_STATUS() to populate field Image")
		}
		service.Image = &image
	} else {
		service.Image = nil
	}

	// Name
	service.Name = genruntime.ClonePointerToString(source.Name)

	// Volumes
	if source.Volumes != nil {
		volumeList := make([]VolumeDefinition_STATUS, len(source.Volumes))
		for volumeIndex, volumeItem := range source.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume VolumeDefinition_STATUS
			err := volume.AssignProperties_From_VolumeDefinition_STATUS(&volumeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VolumeDefinition_STATUS() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		service.Volumes = volumeList
	} else {
		service.Volumes = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CustomService_STATUS populates the provided destination CustomService_STATUS from our CustomService_STATUS
func (service *CustomService_STATUS) AssignProperties_To_CustomService_STATUS(destination *storage.CustomService_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Docker
	if service.Docker != nil {
		var docker storage.Docker_STATUS
		err := service.Docker.AssignProperties_To_Docker_STATUS(&docker)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Docker_STATUS() to populate field Docker")
		}
		destination.Docker = &docker
	} else {
		destination.Docker = nil
	}

	// Endpoints
	if service.Endpoints != nil {
		endpointList := make([]storage.Endpoint_STATUS, len(service.Endpoints))
		for endpointIndex, endpointItem := range service.Endpoints {
			// Shadow the loop variable to avoid aliasing
			endpointItem := endpointItem
			var endpoint storage.Endpoint_STATUS
			err := endpointItem.AssignProperties_To_Endpoint_STATUS(&endpoint)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_Endpoint_STATUS() to populate field Endpoints")
			}
			endpointList[endpointIndex] = endpoint
		}
		destination.Endpoints = endpointList
	} else {
		destination.Endpoints = nil
	}

	// EnvironmentVariables
	if service.EnvironmentVariables != nil {
		environmentVariableMap := make(map[string]storage.EnvironmentVariable_STATUS, len(service.EnvironmentVariables))
		for environmentVariableKey, environmentVariableValue := range service.EnvironmentVariables {
			// Shadow the loop variable to avoid aliasing
			environmentVariableValue := environmentVariableValue
			var environmentVariable storage.EnvironmentVariable_STATUS
			err := environmentVariableValue.AssignProperties_To_EnvironmentVariable_STATUS(&environmentVariable)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_EnvironmentVariable_STATUS() to populate field EnvironmentVariables")
			}
			environmentVariableMap[environmentVariableKey] = environmentVariable
		}
		destination.EnvironmentVariables = environmentVariableMap
	} else {
		destination.EnvironmentVariables = nil
	}

	// Image
	if service.Image != nil {
		var image storage.Image_STATUS
		err := service.Image.AssignProperties_To_Image_STATUS(&image)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Image_STATUS() to populate field Image")
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(service.Name)

	// Volumes
	if service.Volumes != nil {
		volumeList := make([]storage.VolumeDefinition_STATUS, len(service.Volumes))
		for volumeIndex, volumeItem := range service.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume storage.VolumeDefinition_STATUS
			err := volumeItem.AssignProperties_To_VolumeDefinition_STATUS(&volume)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VolumeDefinition_STATUS() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		destination.Volumes = volumeList
	} else {
		destination.Volumes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The error detail.
type ErrorDetail_STATUS struct {
	// AdditionalInfo: The error additional info.
	AdditionalInfo []ErrorAdditionalInfo_STATUS `json:"additionalInfo,omitempty"`

	// Code: The error code.
	Code *string `json:"code,omitempty"`

	// Details: The error details.
	Details []ErrorDetail_STATUS_Unrolled `json:"details,omitempty"`

	// Message: The error message.
	Message *string `json:"message,omitempty"`

	// Target: The error target.
	Target *string `json:"target,omitempty"`
}

var _ genruntime.FromARMConverter = &ErrorDetail_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (detail *ErrorDetail_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ErrorDetail_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (detail *ErrorDetail_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ErrorDetail_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ErrorDetail_STATUS, got %T", armInput)
	}

	// Set property "AdditionalInfo":
	for _, item := range typedInput.AdditionalInfo {
		var item1 ErrorAdditionalInfo_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		detail.AdditionalInfo = append(detail.AdditionalInfo, item1)
	}

	// Set property "Code":
	if typedInput.Code != nil {
		code := *typedInput.Code
		detail.Code = &code
	}

	// Set property "Details":
	for _, item := range typedInput.Details {
		var item1 ErrorDetail_STATUS_Unrolled
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		detail.Details = append(detail.Details, item1)
	}

	// Set property "Message":
	if typedInput.Message != nil {
		message := *typedInput.Message
		detail.Message = &message
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		detail.Target = &target
	}

	// No error
	return nil
}

// AssignProperties_From_ErrorDetail_STATUS populates our ErrorDetail_STATUS from the provided source ErrorDetail_STATUS
func (detail *ErrorDetail_STATUS) AssignProperties_From_ErrorDetail_STATUS(source *storage.ErrorDetail_STATUS) error {

	// AdditionalInfo
	if source.AdditionalInfo != nil {
		additionalInfoList := make([]ErrorAdditionalInfo_STATUS, len(source.AdditionalInfo))
		for additionalInfoIndex, additionalInfoItem := range source.AdditionalInfo {
			// Shadow the loop variable to avoid aliasing
			additionalInfoItem := additionalInfoItem
			var additionalInfo ErrorAdditionalInfo_STATUS
			err := additionalInfo.AssignProperties_From_ErrorAdditionalInfo_STATUS(&additionalInfoItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ErrorAdditionalInfo_STATUS() to populate field AdditionalInfo")
			}
			additionalInfoList[additionalInfoIndex] = additionalInfo
		}
		detail.AdditionalInfo = additionalInfoList
	} else {
		detail.AdditionalInfo = nil
	}

	// Code
	detail.Code = genruntime.ClonePointerToString(source.Code)

	// Details
	if source.Details != nil {
		detailList := make([]ErrorDetail_STATUS_Unrolled, len(source.Details))
		for detailIndex, detailItem := range source.Details {
			// Shadow the loop variable to avoid aliasing
			detailItem := detailItem
			var detailLocal ErrorDetail_STATUS_Unrolled
			err := detailLocal.AssignProperties_From_ErrorDetail_STATUS_Unrolled(&detailItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ErrorDetail_STATUS_Unrolled() to populate field Details")
			}
			detailList[detailIndex] = detailLocal
		}
		detail.Details = detailList
	} else {
		detail.Details = nil
	}

	// Message
	detail.Message = genruntime.ClonePointerToString(source.Message)

	// Target
	detail.Target = genruntime.ClonePointerToString(source.Target)

	// No error
	return nil
}

// AssignProperties_To_ErrorDetail_STATUS populates the provided destination ErrorDetail_STATUS from our ErrorDetail_STATUS
func (detail *ErrorDetail_STATUS) AssignProperties_To_ErrorDetail_STATUS(destination *storage.ErrorDetail_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalInfo
	if detail.AdditionalInfo != nil {
		additionalInfoList := make([]storage.ErrorAdditionalInfo_STATUS, len(detail.AdditionalInfo))
		for additionalInfoIndex, additionalInfoItem := range detail.AdditionalInfo {
			// Shadow the loop variable to avoid aliasing
			additionalInfoItem := additionalInfoItem
			var additionalInfo storage.ErrorAdditionalInfo_STATUS
			err := additionalInfoItem.AssignProperties_To_ErrorAdditionalInfo_STATUS(&additionalInfo)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ErrorAdditionalInfo_STATUS() to populate field AdditionalInfo")
			}
			additionalInfoList[additionalInfoIndex] = additionalInfo
		}
		destination.AdditionalInfo = additionalInfoList
	} else {
		destination.AdditionalInfo = nil
	}

	// Code
	destination.Code = genruntime.ClonePointerToString(detail.Code)

	// Details
	if detail.Details != nil {
		detailList := make([]storage.ErrorDetail_STATUS_Unrolled, len(detail.Details))
		for detailIndex, detailItem := range detail.Details {
			// Shadow the loop variable to avoid aliasing
			detailItem := detailItem
			var detailLocal storage.ErrorDetail_STATUS_Unrolled
			err := detailItem.AssignProperties_To_ErrorDetail_STATUS_Unrolled(&detailLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ErrorDetail_STATUS_Unrolled() to populate field Details")
			}
			detailList[detailIndex] = detailLocal
		}
		destination.Details = detailList
	} else {
		destination.Details = nil
	}

	// Message
	destination.Message = genruntime.ClonePointerToString(detail.Message)

	// Target
	destination.Target = genruntime.ClonePointerToString(detail.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Returns metadata about the operating system image for this compute instance.
type ImageMetadata_STATUS struct {
	// CurrentImageVersion: Specifies the current operating system image version this compute instance is running on.
	CurrentImageVersion *string `json:"currentImageVersion,omitempty"`

	// IsLatestOsImageVersion: Specifies whether this compute instance is running on the latest operating system image.
	IsLatestOsImageVersion *bool `json:"isLatestOsImageVersion,omitempty"`

	// LatestImageVersion: Specifies the latest available operating system image version.
	LatestImageVersion *string `json:"latestImageVersion,omitempty"`
}

var _ genruntime.FromARMConverter = &ImageMetadata_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (metadata *ImageMetadata_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ImageMetadata_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (metadata *ImageMetadata_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ImageMetadata_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ImageMetadata_STATUS, got %T", armInput)
	}

	// Set property "CurrentImageVersion":
	if typedInput.CurrentImageVersion != nil {
		currentImageVersion := *typedInput.CurrentImageVersion
		metadata.CurrentImageVersion = &currentImageVersion
	}

	// Set property "IsLatestOsImageVersion":
	if typedInput.IsLatestOsImageVersion != nil {
		isLatestOsImageVersion := *typedInput.IsLatestOsImageVersion
		metadata.IsLatestOsImageVersion = &isLatestOsImageVersion
	}

	// Set property "LatestImageVersion":
	if typedInput.LatestImageVersion != nil {
		latestImageVersion := *typedInput.LatestImageVersion
		metadata.LatestImageVersion = &latestImageVersion
	}

	// No error
	return nil
}

// AssignProperties_From_ImageMetadata_STATUS populates our ImageMetadata_STATUS from the provided source ImageMetadata_STATUS
func (metadata *ImageMetadata_STATUS) AssignProperties_From_ImageMetadata_STATUS(source *storage.ImageMetadata_STATUS) error {

	// CurrentImageVersion
	metadata.CurrentImageVersion = genruntime.ClonePointerToString(source.CurrentImageVersion)

	// IsLatestOsImageVersion
	if source.IsLatestOsImageVersion != nil {
		isLatestOsImageVersion := *source.IsLatestOsImageVersion
		metadata.IsLatestOsImageVersion = &isLatestOsImageVersion
	} else {
		metadata.IsLatestOsImageVersion = nil
	}

	// LatestImageVersion
	metadata.LatestImageVersion = genruntime.ClonePointerToString(source.LatestImageVersion)

	// No error
	return nil
}

// AssignProperties_To_ImageMetadata_STATUS populates the provided destination ImageMetadata_STATUS from our ImageMetadata_STATUS
func (metadata *ImageMetadata_STATUS) AssignProperties_To_ImageMetadata_STATUS(destination *storage.ImageMetadata_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CurrentImageVersion
	destination.CurrentImageVersion = genruntime.ClonePointerToString(metadata.CurrentImageVersion)

	// IsLatestOsImageVersion
	if metadata.IsLatestOsImageVersion != nil {
		isLatestOsImageVersion := *metadata.IsLatestOsImageVersion
		destination.IsLatestOsImageVersion = &isLatestOsImageVersion
	} else {
		destination.IsLatestOsImageVersion = nil
	}

	// LatestImageVersion
	destination.LatestImageVersion = genruntime.ClonePointerToString(metadata.LatestImageVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Instance type schema.
type InstanceTypeSchema struct {
	// NodeSelector: Node Selector
	NodeSelector map[string]string `json:"nodeSelector,omitempty"`

	// Resources: Resource requests/limits for this instance type
	Resources *InstanceTypeSchema_Resources `json:"resources,omitempty"`
}

var _ genruntime.ARMTransformer = &InstanceTypeSchema{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (schema *InstanceTypeSchema) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if schema == nil {
		return nil, nil
	}
	result := &arm.InstanceTypeSchema{}

	// Set property "NodeSelector":
	if schema.NodeSelector != nil {
		result.NodeSelector = make(map[string]string, len(schema.NodeSelector))
		for key, value := range schema.NodeSelector {
			result.NodeSelector[key] = value
		}
	}

	// Set property "Resources":
	if schema.Resources != nil {
		resources_ARM, err := (*schema.Resources).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		resources := *resources_ARM.(*arm.InstanceTypeSchema_Resources)
		result.Resources = &resources
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (schema *InstanceTypeSchema) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.InstanceTypeSchema{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (schema *InstanceTypeSchema) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.InstanceTypeSchema)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.InstanceTypeSchema, got %T", armInput)
	}

	// Set property "NodeSelector":
	if typedInput.NodeSelector != nil {
		schema.NodeSelector = make(map[string]string, len(typedInput.NodeSelector))
		for key, value := range typedInput.NodeSelector {
			schema.NodeSelector[key] = value
		}
	}

	// Set property "Resources":
	if typedInput.Resources != nil {
		var resources1 InstanceTypeSchema_Resources
		err := resources1.PopulateFromARM(owner, *typedInput.Resources)
		if err != nil {
			return err
		}
		resources := resources1
		schema.Resources = &resources
	}

	// No error
	return nil
}

// AssignProperties_From_InstanceTypeSchema populates our InstanceTypeSchema from the provided source InstanceTypeSchema
func (schema *InstanceTypeSchema) AssignProperties_From_InstanceTypeSchema(source *storage.InstanceTypeSchema) error {

	// NodeSelector
	schema.NodeSelector = genruntime.CloneMapOfStringToString(source.NodeSelector)

	// Resources
	if source.Resources != nil {
		var resource InstanceTypeSchema_Resources
		err := resource.AssignProperties_From_InstanceTypeSchema_Resources(source.Resources)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_InstanceTypeSchema_Resources() to populate field Resources")
		}
		schema.Resources = &resource
	} else {
		schema.Resources = nil
	}

	// No error
	return nil
}

// AssignProperties_To_InstanceTypeSchema populates the provided destination InstanceTypeSchema from our InstanceTypeSchema
func (schema *InstanceTypeSchema) AssignProperties_To_InstanceTypeSchema(destination *storage.InstanceTypeSchema) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// NodeSelector
	destination.NodeSelector = genruntime.CloneMapOfStringToString(schema.NodeSelector)

	// Resources
	if schema.Resources != nil {
		var resource storage.InstanceTypeSchema_Resources
		err := schema.Resources.AssignProperties_To_InstanceTypeSchema_Resources(&resource)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_InstanceTypeSchema_Resources() to populate field Resources")
		}
		destination.Resources = &resource
	} else {
		destination.Resources = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_InstanceTypeSchema_STATUS populates our InstanceTypeSchema from the provided source InstanceTypeSchema_STATUS
func (schema *InstanceTypeSchema) Initialize_From_InstanceTypeSchema_STATUS(source *InstanceTypeSchema_STATUS) error {

	// NodeSelector
	schema.NodeSelector = genruntime.CloneMapOfStringToString(source.NodeSelector)

	// Resources
	if source.Resources != nil {
		var resource InstanceTypeSchema_Resources
		err := resource.Initialize_From_InstanceTypeSchema_Resources_STATUS(source.Resources)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_InstanceTypeSchema_Resources_STATUS() to populate field Resources")
		}
		schema.Resources = &resource
	} else {
		schema.Resources = nil
	}

	// No error
	return nil
}

// Instance type schema.
type InstanceTypeSchema_STATUS struct {
	// NodeSelector: Node Selector
	NodeSelector map[string]string `json:"nodeSelector,omitempty"`

	// Resources: Resource requests/limits for this instance type
	Resources *InstanceTypeSchema_Resources_STATUS `json:"resources,omitempty"`
}

var _ genruntime.FromARMConverter = &InstanceTypeSchema_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (schema *InstanceTypeSchema_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.InstanceTypeSchema_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (schema *InstanceTypeSchema_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.InstanceTypeSchema_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.InstanceTypeSchema_STATUS, got %T", armInput)
	}

	// Set property "NodeSelector":
	if typedInput.NodeSelector != nil {
		schema.NodeSelector = make(map[string]string, len(typedInput.NodeSelector))
		for key, value := range typedInput.NodeSelector {
			schema.NodeSelector[key] = value
		}
	}

	// Set property "Resources":
	if typedInput.Resources != nil {
		var resources1 InstanceTypeSchema_Resources_STATUS
		err := resources1.PopulateFromARM(owner, *typedInput.Resources)
		if err != nil {
			return err
		}
		resources := resources1
		schema.Resources = &resources
	}

	// No error
	return nil
}

// AssignProperties_From_InstanceTypeSchema_STATUS populates our InstanceTypeSchema_STATUS from the provided source InstanceTypeSchema_STATUS
func (schema *InstanceTypeSchema_STATUS) AssignProperties_From_InstanceTypeSchema_STATUS(source *storage.InstanceTypeSchema_STATUS) error {

	// NodeSelector
	schema.NodeSelector = genruntime.CloneMapOfStringToString(source.NodeSelector)

	// Resources
	if source.Resources != nil {
		var resource InstanceTypeSchema_Resources_STATUS
		err := resource.AssignProperties_From_InstanceTypeSchema_Resources_STATUS(source.Resources)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_InstanceTypeSchema_Resources_STATUS() to populate field Resources")
		}
		schema.Resources = &resource
	} else {
		schema.Resources = nil
	}

	// No error
	return nil
}

// AssignProperties_To_InstanceTypeSchema_STATUS populates the provided destination InstanceTypeSchema_STATUS from our InstanceTypeSchema_STATUS
func (schema *InstanceTypeSchema_STATUS) AssignProperties_To_InstanceTypeSchema_STATUS(destination *storage.InstanceTypeSchema_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// NodeSelector
	destination.NodeSelector = genruntime.CloneMapOfStringToString(schema.NodeSelector)

	// Resources
	if schema.Resources != nil {
		var resource storage.InstanceTypeSchema_Resources_STATUS
		err := schema.Resources.AssignProperties_To_InstanceTypeSchema_Resources_STATUS(&resource)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_InstanceTypeSchema_Resources_STATUS() to populate field Resources")
		}
		destination.Resources = &resource
	} else {
		destination.Resources = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Counts of various compute node states on the amlCompute.
type NodeStateCounts_STATUS struct {
	// IdleNodeCount: Number of compute nodes in idle state.
	IdleNodeCount *int `json:"idleNodeCount,omitempty"`

	// LeavingNodeCount: Number of compute nodes which are leaving the amlCompute.
	LeavingNodeCount *int `json:"leavingNodeCount,omitempty"`

	// PreemptedNodeCount: Number of compute nodes which are in preempted state.
	PreemptedNodeCount *int `json:"preemptedNodeCount,omitempty"`

	// PreparingNodeCount: Number of compute nodes which are being prepared.
	PreparingNodeCount *int `json:"preparingNodeCount,omitempty"`

	// RunningNodeCount: Number of compute nodes which are running jobs.
	RunningNodeCount *int `json:"runningNodeCount,omitempty"`

	// UnusableNodeCount: Number of compute nodes which are in unusable state.
	UnusableNodeCount *int `json:"unusableNodeCount,omitempty"`
}

var _ genruntime.FromARMConverter = &NodeStateCounts_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (counts *NodeStateCounts_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NodeStateCounts_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (counts *NodeStateCounts_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NodeStateCounts_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NodeStateCounts_STATUS, got %T", armInput)
	}

	// Set property "IdleNodeCount":
	if typedInput.IdleNodeCount != nil {
		idleNodeCount := *typedInput.IdleNodeCount
		counts.IdleNodeCount = &idleNodeCount
	}

	// Set property "LeavingNodeCount":
	if typedInput.LeavingNodeCount != nil {
		leavingNodeCount := *typedInput.LeavingNodeCount
		counts.LeavingNodeCount = &leavingNodeCount
	}

	// Set property "PreemptedNodeCount":
	if typedInput.PreemptedNodeCount != nil {
		preemptedNodeCount := *typedInput.PreemptedNodeCount
		counts.PreemptedNodeCount = &preemptedNodeCount
	}

	// Set property "PreparingNodeCount":
	if typedInput.PreparingNodeCount != nil {
		preparingNodeCount := *typedInput.PreparingNodeCount
		counts.PreparingNodeCount = &preparingNodeCount
	}

	// Set property "RunningNodeCount":
	if typedInput.RunningNodeCount != nil {
		runningNodeCount := *typedInput.RunningNodeCount
		counts.RunningNodeCount = &runningNodeCount
	}

	// Set property "UnusableNodeCount":
	if typedInput.UnusableNodeCount != nil {
		unusableNodeCount := *typedInput.UnusableNodeCount
		counts.UnusableNodeCount = &unusableNodeCount
	}

	// No error
	return nil
}

// AssignProperties_From_NodeStateCounts_STATUS populates our NodeStateCounts_STATUS from the provided source NodeStateCounts_STATUS
func (counts *NodeStateCounts_STATUS) AssignProperties_From_NodeStateCounts_STATUS(source *storage.NodeStateCounts_STATUS) error {

	// IdleNodeCount
	counts.IdleNodeCount = genruntime.ClonePointerToInt(source.IdleNodeCount)

	// LeavingNodeCount
	counts.LeavingNodeCount = genruntime.ClonePointerToInt(source.LeavingNodeCount)

	// PreemptedNodeCount
	counts.PreemptedNodeCount = genruntime.ClonePointerToInt(source.PreemptedNodeCount)

	// PreparingNodeCount
	counts.PreparingNodeCount = genruntime.ClonePointerToInt(source.PreparingNodeCount)

	// RunningNodeCount
	counts.RunningNodeCount = genruntime.ClonePointerToInt(source.RunningNodeCount)

	// UnusableNodeCount
	counts.UnusableNodeCount = genruntime.ClonePointerToInt(source.UnusableNodeCount)

	// No error
	return nil
}

// AssignProperties_To_NodeStateCounts_STATUS populates the provided destination NodeStateCounts_STATUS from our NodeStateCounts_STATUS
func (counts *NodeStateCounts_STATUS) AssignProperties_To_NodeStateCounts_STATUS(destination *storage.NodeStateCounts_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IdleNodeCount
	destination.IdleNodeCount = genruntime.ClonePointerToInt(counts.IdleNodeCount)

	// LeavingNodeCount
	destination.LeavingNodeCount = genruntime.ClonePointerToInt(counts.LeavingNodeCount)

	// PreemptedNodeCount
	destination.PreemptedNodeCount = genruntime.ClonePointerToInt(counts.PreemptedNodeCount)

	// PreparingNodeCount
	destination.PreparingNodeCount = genruntime.ClonePointerToInt(counts.PreparingNodeCount)

	// RunningNodeCount
	destination.RunningNodeCount = genruntime.ClonePointerToInt(counts.RunningNodeCount)

	// UnusableNodeCount
	destination.UnusableNodeCount = genruntime.ClonePointerToInt(counts.UnusableNodeCount)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Settings for a personal compute instance.
type PersonalComputeInstanceSettings struct {
	// AssignedUser: A user explicitly assigned to a personal compute instance.
	AssignedUser *AssignedUser `json:"assignedUser,omitempty"`
}

var _ genruntime.ARMTransformer = &PersonalComputeInstanceSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *PersonalComputeInstanceSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.PersonalComputeInstanceSettings{}

	// Set property "AssignedUser":
	if settings.AssignedUser != nil {
		assignedUser_ARM, err := (*settings.AssignedUser).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		assignedUser := *assignedUser_ARM.(*arm.AssignedUser)
		result.AssignedUser = &assignedUser
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *PersonalComputeInstanceSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PersonalComputeInstanceSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *PersonalComputeInstanceSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PersonalComputeInstanceSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PersonalComputeInstanceSettings, got %T", armInput)
	}

	// Set property "AssignedUser":
	if typedInput.AssignedUser != nil {
		var assignedUser1 AssignedUser
		err := assignedUser1.PopulateFromARM(owner, *typedInput.AssignedUser)
		if err != nil {
			return err
		}
		assignedUser := assignedUser1
		settings.AssignedUser = &assignedUser
	}

	// No error
	return nil
}

// AssignProperties_From_PersonalComputeInstanceSettings populates our PersonalComputeInstanceSettings from the provided source PersonalComputeInstanceSettings
func (settings *PersonalComputeInstanceSettings) AssignProperties_From_PersonalComputeInstanceSettings(source *storage.PersonalComputeInstanceSettings) error {

	// AssignedUser
	if source.AssignedUser != nil {
		var assignedUser AssignedUser
		err := assignedUser.AssignProperties_From_AssignedUser(source.AssignedUser)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AssignedUser() to populate field AssignedUser")
		}
		settings.AssignedUser = &assignedUser
	} else {
		settings.AssignedUser = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PersonalComputeInstanceSettings populates the provided destination PersonalComputeInstanceSettings from our PersonalComputeInstanceSettings
func (settings *PersonalComputeInstanceSettings) AssignProperties_To_PersonalComputeInstanceSettings(destination *storage.PersonalComputeInstanceSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AssignedUser
	if settings.AssignedUser != nil {
		var assignedUser storage.AssignedUser
		err := settings.AssignedUser.AssignProperties_To_AssignedUser(&assignedUser)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AssignedUser() to populate field AssignedUser")
		}
		destination.AssignedUser = &assignedUser
	} else {
		destination.AssignedUser = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_PersonalComputeInstanceSettings_STATUS populates our PersonalComputeInstanceSettings from the provided source PersonalComputeInstanceSettings_STATUS
func (settings *PersonalComputeInstanceSettings) Initialize_From_PersonalComputeInstanceSettings_STATUS(source *PersonalComputeInstanceSettings_STATUS) error {

	// AssignedUser
	if source.AssignedUser != nil {
		var assignedUser AssignedUser
		err := assignedUser.Initialize_From_AssignedUser_STATUS(source.AssignedUser)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_AssignedUser_STATUS() to populate field AssignedUser")
		}
		settings.AssignedUser = &assignedUser
	} else {
		settings.AssignedUser = nil
	}

	// No error
	return nil
}

// Settings for a personal compute instance.
type PersonalComputeInstanceSettings_STATUS struct {
	// AssignedUser: A user explicitly assigned to a personal compute instance.
	AssignedUser *AssignedUser_STATUS `json:"assignedUser,omitempty"`
}

var _ genruntime.FromARMConverter = &PersonalComputeInstanceSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *PersonalComputeInstanceSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PersonalComputeInstanceSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *PersonalComputeInstanceSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PersonalComputeInstanceSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PersonalComputeInstanceSettings_STATUS, got %T", armInput)
	}

	// Set property "AssignedUser":
	if typedInput.AssignedUser != nil {
		var assignedUser1 AssignedUser_STATUS
		err := assignedUser1.PopulateFromARM(owner, *typedInput.AssignedUser)
		if err != nil {
			return err
		}
		assignedUser := assignedUser1
		settings.AssignedUser = &assignedUser
	}

	// No error
	return nil
}

// AssignProperties_From_PersonalComputeInstanceSettings_STATUS populates our PersonalComputeInstanceSettings_STATUS from the provided source PersonalComputeInstanceSettings_STATUS
func (settings *PersonalComputeInstanceSettings_STATUS) AssignProperties_From_PersonalComputeInstanceSettings_STATUS(source *storage.PersonalComputeInstanceSettings_STATUS) error {

	// AssignedUser
	if source.AssignedUser != nil {
		var assignedUser AssignedUser_STATUS
		err := assignedUser.AssignProperties_From_AssignedUser_STATUS(source.AssignedUser)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AssignedUser_STATUS() to populate field AssignedUser")
		}
		settings.AssignedUser = &assignedUser
	} else {
		settings.AssignedUser = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PersonalComputeInstanceSettings_STATUS populates the provided destination PersonalComputeInstanceSettings_STATUS from our PersonalComputeInstanceSettings_STATUS
func (settings *PersonalComputeInstanceSettings_STATUS) AssignProperties_To_PersonalComputeInstanceSettings_STATUS(destination *storage.PersonalComputeInstanceSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AssignedUser
	if settings.AssignedUser != nil {
		var assignedUser storage.AssignedUser_STATUS
		err := settings.AssignedUser.AssignProperties_To_AssignedUser_STATUS(&assignedUser)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AssignedUser_STATUS() to populate field AssignedUser")
		}
		destination.AssignedUser = &assignedUser
	} else {
		destination.AssignedUser = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Represents a resource ID. For example, for a subnet, it is the resource URL for the subnet.
type ResourceId struct {
	// +kubebuilder:validation:Required
	// Reference: The ID of the resource
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &ResourceId{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (resourceId *ResourceId) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if resourceId == nil {
		return nil, nil
	}
	result := &arm.ResourceId{}

	// Set property "Id":
	if resourceId.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*resourceId.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resourceId *ResourceId) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ResourceId{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resourceId *ResourceId) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(arm.ResourceId)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ResourceId, got %T", armInput)
	}

	// no assignment for property "Reference"

	// No error
	return nil
}

// AssignProperties_From_ResourceId populates our ResourceId from the provided source ResourceId
func (resourceId *ResourceId) AssignProperties_From_ResourceId(source *storage.ResourceId) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		resourceId.Reference = &reference
	} else {
		resourceId.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ResourceId populates the provided destination ResourceId from our ResourceId
func (resourceId *ResourceId) AssignProperties_To_ResourceId(destination *storage.ResourceId) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if resourceId.Reference != nil {
		reference := resourceId.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ResourceId_STATUS populates our ResourceId from the provided source ResourceId_STATUS
func (resourceId *ResourceId) Initialize_From_ResourceId_STATUS(source *ResourceId_STATUS) error {

	// Reference
	if source.Id != nil {
		reference := genruntime.CreateResourceReferenceFromARMID(*source.Id)
		resourceId.Reference = &reference
	} else {
		resourceId.Reference = nil
	}

	// No error
	return nil
}

// Represents a resource ID. For example, for a subnet, it is the resource URL for the subnet.
type ResourceId_STATUS struct {
	// Id: The ID of the resource
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ResourceId_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resourceId *ResourceId_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ResourceId_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resourceId *ResourceId_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ResourceId_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ResourceId_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		resourceId.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_ResourceId_STATUS populates our ResourceId_STATUS from the provided source ResourceId_STATUS
func (resourceId *ResourceId_STATUS) AssignProperties_From_ResourceId_STATUS(source *storage.ResourceId_STATUS) error {

	// Id
	resourceId.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_ResourceId_STATUS populates the provided destination ResourceId_STATUS from our ResourceId_STATUS
func (resourceId *ResourceId_STATUS) AssignProperties_To_ResourceId_STATUS(destination *storage.ResourceId_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(resourceId.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// scale settings for AML Compute
type ScaleSettings struct {
	// +kubebuilder:validation:Required
	// MaxNodeCount: Max number of nodes to use
	MaxNodeCount *int `json:"maxNodeCount,omitempty"`

	// MinNodeCount: Min number of nodes to use
	MinNodeCount *int `json:"minNodeCount,omitempty"`

	// NodeIdleTimeBeforeScaleDown: Node Idle Time before scaling down amlCompute. This string needs to be in the RFC Format.
	NodeIdleTimeBeforeScaleDown *string `json:"nodeIdleTimeBeforeScaleDown,omitempty"`
}

var _ genruntime.ARMTransformer = &ScaleSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *ScaleSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.ScaleSettings{}

	// Set property "MaxNodeCount":
	if settings.MaxNodeCount != nil {
		maxNodeCount := *settings.MaxNodeCount
		result.MaxNodeCount = &maxNodeCount
	}

	// Set property "MinNodeCount":
	if settings.MinNodeCount != nil {
		minNodeCount := *settings.MinNodeCount
		result.MinNodeCount = &minNodeCount
	}

	// Set property "NodeIdleTimeBeforeScaleDown":
	if settings.NodeIdleTimeBeforeScaleDown != nil {
		nodeIdleTimeBeforeScaleDown := *settings.NodeIdleTimeBeforeScaleDown
		result.NodeIdleTimeBeforeScaleDown = &nodeIdleTimeBeforeScaleDown
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *ScaleSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ScaleSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *ScaleSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ScaleSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ScaleSettings, got %T", armInput)
	}

	// Set property "MaxNodeCount":
	if typedInput.MaxNodeCount != nil {
		maxNodeCount := *typedInput.MaxNodeCount
		settings.MaxNodeCount = &maxNodeCount
	}

	// Set property "MinNodeCount":
	if typedInput.MinNodeCount != nil {
		minNodeCount := *typedInput.MinNodeCount
		settings.MinNodeCount = &minNodeCount
	}

	// Set property "NodeIdleTimeBeforeScaleDown":
	if typedInput.NodeIdleTimeBeforeScaleDown != nil {
		nodeIdleTimeBeforeScaleDown := *typedInput.NodeIdleTimeBeforeScaleDown
		settings.NodeIdleTimeBeforeScaleDown = &nodeIdleTimeBeforeScaleDown
	}

	// No error
	return nil
}

// AssignProperties_From_ScaleSettings populates our ScaleSettings from the provided source ScaleSettings
func (settings *ScaleSettings) AssignProperties_From_ScaleSettings(source *storage.ScaleSettings) error {

	// MaxNodeCount
	settings.MaxNodeCount = genruntime.ClonePointerToInt(source.MaxNodeCount)

	// MinNodeCount
	settings.MinNodeCount = genruntime.ClonePointerToInt(source.MinNodeCount)

	// NodeIdleTimeBeforeScaleDown
	settings.NodeIdleTimeBeforeScaleDown = genruntime.ClonePointerToString(source.NodeIdleTimeBeforeScaleDown)

	// No error
	return nil
}

// AssignProperties_To_ScaleSettings populates the provided destination ScaleSettings from our ScaleSettings
func (settings *ScaleSettings) AssignProperties_To_ScaleSettings(destination *storage.ScaleSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MaxNodeCount
	destination.MaxNodeCount = genruntime.ClonePointerToInt(settings.MaxNodeCount)

	// MinNodeCount
	destination.MinNodeCount = genruntime.ClonePointerToInt(settings.MinNodeCount)

	// NodeIdleTimeBeforeScaleDown
	destination.NodeIdleTimeBeforeScaleDown = genruntime.ClonePointerToString(settings.NodeIdleTimeBeforeScaleDown)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ScaleSettings_STATUS populates our ScaleSettings from the provided source ScaleSettings_STATUS
func (settings *ScaleSettings) Initialize_From_ScaleSettings_STATUS(source *ScaleSettings_STATUS) error {

	// MaxNodeCount
	settings.MaxNodeCount = genruntime.ClonePointerToInt(source.MaxNodeCount)

	// MinNodeCount
	settings.MinNodeCount = genruntime.ClonePointerToInt(source.MinNodeCount)

	// NodeIdleTimeBeforeScaleDown
	settings.NodeIdleTimeBeforeScaleDown = genruntime.ClonePointerToString(source.NodeIdleTimeBeforeScaleDown)

	// No error
	return nil
}

// scale settings for AML Compute
type ScaleSettings_STATUS struct {
	// MaxNodeCount: Max number of nodes to use
	MaxNodeCount *int `json:"maxNodeCount,omitempty"`

	// MinNodeCount: Min number of nodes to use
	MinNodeCount *int `json:"minNodeCount,omitempty"`

	// NodeIdleTimeBeforeScaleDown: Node Idle Time before scaling down amlCompute. This string needs to be in the RFC Format.
	NodeIdleTimeBeforeScaleDown *string `json:"nodeIdleTimeBeforeScaleDown,omitempty"`
}

var _ genruntime.FromARMConverter = &ScaleSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *ScaleSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ScaleSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *ScaleSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ScaleSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ScaleSettings_STATUS, got %T", armInput)
	}

	// Set property "MaxNodeCount":
	if typedInput.MaxNodeCount != nil {
		maxNodeCount := *typedInput.MaxNodeCount
		settings.MaxNodeCount = &maxNodeCount
	}

	// Set property "MinNodeCount":
	if typedInput.MinNodeCount != nil {
		minNodeCount := *typedInput.MinNodeCount
		settings.MinNodeCount = &minNodeCount
	}

	// Set property "NodeIdleTimeBeforeScaleDown":
	if typedInput.NodeIdleTimeBeforeScaleDown != nil {
		nodeIdleTimeBeforeScaleDown := *typedInput.NodeIdleTimeBeforeScaleDown
		settings.NodeIdleTimeBeforeScaleDown = &nodeIdleTimeBeforeScaleDown
	}

	// No error
	return nil
}

// AssignProperties_From_ScaleSettings_STATUS populates our ScaleSettings_STATUS from the provided source ScaleSettings_STATUS
func (settings *ScaleSettings_STATUS) AssignProperties_From_ScaleSettings_STATUS(source *storage.ScaleSettings_STATUS) error {

	// MaxNodeCount
	settings.MaxNodeCount = genruntime.ClonePointerToInt(source.MaxNodeCount)

	// MinNodeCount
	settings.MinNodeCount = genruntime.ClonePointerToInt(source.MinNodeCount)

	// NodeIdleTimeBeforeScaleDown
	settings.NodeIdleTimeBeforeScaleDown = genruntime.ClonePointerToString(source.NodeIdleTimeBeforeScaleDown)

	// No error
	return nil
}

// AssignProperties_To_ScaleSettings_STATUS populates the provided destination ScaleSettings_STATUS from our ScaleSettings_STATUS
func (settings *ScaleSettings_STATUS) AssignProperties_To_ScaleSettings_STATUS(destination *storage.ScaleSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MaxNodeCount
	destination.MaxNodeCount = genruntime.ClonePointerToInt(settings.MaxNodeCount)

	// MinNodeCount
	destination.MinNodeCount = genruntime.ClonePointerToInt(settings.MinNodeCount)

	// NodeIdleTimeBeforeScaleDown
	destination.NodeIdleTimeBeforeScaleDown = genruntime.ClonePointerToString(settings.NodeIdleTimeBeforeScaleDown)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details of customized scripts to execute for setting up the cluster.
type SetupScripts struct {
	// Scripts: Customized setup scripts
	Scripts *ScriptsToExecute `json:"scripts,omitempty"`
}

var _ genruntime.ARMTransformer = &SetupScripts{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (scripts *SetupScripts) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if scripts == nil {
		return nil, nil
	}
	result := &arm.SetupScripts{}

	// Set property "Scripts":
	if scripts.Scripts != nil {
		scripts_ARM, err := (*scripts.Scripts).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		scripts1 := *scripts_ARM.(*arm.ScriptsToExecute)
		result.Scripts = &scripts1
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (scripts *SetupScripts) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SetupScripts{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (scripts *SetupScripts) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SetupScripts)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SetupScripts, got %T", armInput)
	}

	// Set property "Scripts":
	if typedInput.Scripts != nil {
		var scripts2 ScriptsToExecute
		err := scripts2.PopulateFromARM(owner, *typedInput.Scripts)
		if err != nil {
			return err
		}
		scripts1 := scripts2
		scripts.Scripts = &scripts1
	}

	// No error
	return nil
}

// AssignProperties_From_SetupScripts populates our SetupScripts from the provided source SetupScripts
func (scripts *SetupScripts) AssignProperties_From_SetupScripts(source *storage.SetupScripts) error {

	// Scripts
	if source.Scripts != nil {
		var script ScriptsToExecute
		err := script.AssignProperties_From_ScriptsToExecute(source.Scripts)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ScriptsToExecute() to populate field Scripts")
		}
		scripts.Scripts = &script
	} else {
		scripts.Scripts = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SetupScripts populates the provided destination SetupScripts from our SetupScripts
func (scripts *SetupScripts) AssignProperties_To_SetupScripts(destination *storage.SetupScripts) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Scripts
	if scripts.Scripts != nil {
		var script storage.ScriptsToExecute
		err := scripts.Scripts.AssignProperties_To_ScriptsToExecute(&script)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ScriptsToExecute() to populate field Scripts")
		}
		destination.Scripts = &script
	} else {
		destination.Scripts = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_SetupScripts_STATUS populates our SetupScripts from the provided source SetupScripts_STATUS
func (scripts *SetupScripts) Initialize_From_SetupScripts_STATUS(source *SetupScripts_STATUS) error {

	// Scripts
	if source.Scripts != nil {
		var script ScriptsToExecute
		err := script.Initialize_From_ScriptsToExecute_STATUS(source.Scripts)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ScriptsToExecute_STATUS() to populate field Scripts")
		}
		scripts.Scripts = &script
	} else {
		scripts.Scripts = nil
	}

	// No error
	return nil
}

// Details of customized scripts to execute for setting up the cluster.
type SetupScripts_STATUS struct {
	// Scripts: Customized setup scripts
	Scripts *ScriptsToExecute_STATUS `json:"scripts,omitempty"`
}

var _ genruntime.FromARMConverter = &SetupScripts_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (scripts *SetupScripts_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SetupScripts_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (scripts *SetupScripts_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SetupScripts_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SetupScripts_STATUS, got %T", armInput)
	}

	// Set property "Scripts":
	if typedInput.Scripts != nil {
		var scripts2 ScriptsToExecute_STATUS
		err := scripts2.PopulateFromARM(owner, *typedInput.Scripts)
		if err != nil {
			return err
		}
		scripts1 := scripts2
		scripts.Scripts = &scripts1
	}

	// No error
	return nil
}

// AssignProperties_From_SetupScripts_STATUS populates our SetupScripts_STATUS from the provided source SetupScripts_STATUS
func (scripts *SetupScripts_STATUS) AssignProperties_From_SetupScripts_STATUS(source *storage.SetupScripts_STATUS) error {

	// Scripts
	if source.Scripts != nil {
		var script ScriptsToExecute_STATUS
		err := script.AssignProperties_From_ScriptsToExecute_STATUS(source.Scripts)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ScriptsToExecute_STATUS() to populate field Scripts")
		}
		scripts.Scripts = &script
	} else {
		scripts.Scripts = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SetupScripts_STATUS populates the provided destination SetupScripts_STATUS from our SetupScripts_STATUS
func (scripts *SetupScripts_STATUS) AssignProperties_To_SetupScripts_STATUS(destination *storage.SetupScripts_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Scripts
	if scripts.Scripts != nil {
		var script storage.ScriptsToExecute_STATUS
		err := scripts.Scripts.AssignProperties_To_ScriptsToExecute_STATUS(&script)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ScriptsToExecute_STATUS() to populate field Scripts")
		}
		destination.Scripts = &script
	} else {
		destination.Scripts = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The ssl configuration for scoring
type SslConfiguration struct {
	// Cert: Cert data
	Cert *genruntime.SecretReference `json:"cert,omitempty"`

	// Cname: CNAME of the cert
	Cname *string `json:"cname,omitempty"`

	// Key: Key data
	Key *genruntime.SecretReference `json:"key,omitempty"`

	// LeafDomainLabel: Leaf domain label of public endpoint
	LeafDomainLabel *string `json:"leafDomainLabel,omitempty"`

	// OverwriteExistingDomain: Indicates whether to overwrite existing domain label.
	OverwriteExistingDomain *bool `json:"overwriteExistingDomain,omitempty"`

	// Status: Enable or disable ssl for scoring
	Status *SslConfiguration_Status `json:"status,omitempty"`
}

var _ genruntime.ARMTransformer = &SslConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *SslConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.SslConfiguration{}

	// Set property "Cert":
	if configuration.Cert != nil {
		certSecret, err := resolved.ResolvedSecrets.Lookup(*configuration.Cert)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property Cert")
		}
		cert := certSecret
		result.Cert = &cert
	}

	// Set property "Cname":
	if configuration.Cname != nil {
		cname := *configuration.Cname
		result.Cname = &cname
	}

	// Set property "Key":
	if configuration.Key != nil {
		keySecret, err := resolved.ResolvedSecrets.Lookup(*configuration.Key)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property Key")
		}
		key := keySecret
		result.Key = &key
	}

	// Set property "LeafDomainLabel":
	if configuration.LeafDomainLabel != nil {
		leafDomainLabel := *configuration.LeafDomainLabel
		result.LeafDomainLabel = &leafDomainLabel
	}

	// Set property "OverwriteExistingDomain":
	if configuration.OverwriteExistingDomain != nil {
		overwriteExistingDomain := *configuration.OverwriteExistingDomain
		result.OverwriteExistingDomain = &overwriteExistingDomain
	}

	// Set property "Status":
	if configuration.Status != nil {
		var temp string
		temp = string(*configuration.Status)
		status := arm.SslConfiguration_Status(temp)
		result.Status = &status
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *SslConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SslConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *SslConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SslConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SslConfiguration, got %T", armInput)
	}

	// no assignment for property "Cert"

	// Set property "Cname":
	if typedInput.Cname != nil {
		cname := *typedInput.Cname
		configuration.Cname = &cname
	}

	// no assignment for property "Key"

	// Set property "LeafDomainLabel":
	if typedInput.LeafDomainLabel != nil {
		leafDomainLabel := *typedInput.LeafDomainLabel
		configuration.LeafDomainLabel = &leafDomainLabel
	}

	// Set property "OverwriteExistingDomain":
	if typedInput.OverwriteExistingDomain != nil {
		overwriteExistingDomain := *typedInput.OverwriteExistingDomain
		configuration.OverwriteExistingDomain = &overwriteExistingDomain
	}

	// Set property "Status":
	if typedInput.Status != nil {
		var temp string
		temp = string(*typedInput.Status)
		status := SslConfiguration_Status(temp)
		configuration.Status = &status
	}

	// No error
	return nil
}

// AssignProperties_From_SslConfiguration populates our SslConfiguration from the provided source SslConfiguration
func (configuration *SslConfiguration) AssignProperties_From_SslConfiguration(source *storage.SslConfiguration) error {

	// Cert
	if source.Cert != nil {
		cert := source.Cert.Copy()
		configuration.Cert = &cert
	} else {
		configuration.Cert = nil
	}

	// Cname
	configuration.Cname = genruntime.ClonePointerToString(source.Cname)

	// Key
	if source.Key != nil {
		key := source.Key.Copy()
		configuration.Key = &key
	} else {
		configuration.Key = nil
	}

	// LeafDomainLabel
	configuration.LeafDomainLabel = genruntime.ClonePointerToString(source.LeafDomainLabel)

	// OverwriteExistingDomain
	if source.OverwriteExistingDomain != nil {
		overwriteExistingDomain := *source.OverwriteExistingDomain
		configuration.OverwriteExistingDomain = &overwriteExistingDomain
	} else {
		configuration.OverwriteExistingDomain = nil
	}

	// Status
	if source.Status != nil {
		status := *source.Status
		statusTemp := genruntime.ToEnum(status, sslConfiguration_Status_Values)
		configuration.Status = &statusTemp
	} else {
		configuration.Status = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SslConfiguration populates the provided destination SslConfiguration from our SslConfiguration
func (configuration *SslConfiguration) AssignProperties_To_SslConfiguration(destination *storage.SslConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Cert
	if configuration.Cert != nil {
		cert := configuration.Cert.Copy()
		destination.Cert = &cert
	} else {
		destination.Cert = nil
	}

	// Cname
	destination.Cname = genruntime.ClonePointerToString(configuration.Cname)

	// Key
	if configuration.Key != nil {
		key := configuration.Key.Copy()
		destination.Key = &key
	} else {
		destination.Key = nil
	}

	// LeafDomainLabel
	destination.LeafDomainLabel = genruntime.ClonePointerToString(configuration.LeafDomainLabel)

	// OverwriteExistingDomain
	if configuration.OverwriteExistingDomain != nil {
		overwriteExistingDomain := *configuration.OverwriteExistingDomain
		destination.OverwriteExistingDomain = &overwriteExistingDomain
	} else {
		destination.OverwriteExistingDomain = nil
	}

	// Status
	if configuration.Status != nil {
		status := string(*configuration.Status)
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_SslConfiguration_STATUS populates our SslConfiguration from the provided source SslConfiguration_STATUS
func (configuration *SslConfiguration) Initialize_From_SslConfiguration_STATUS(source *SslConfiguration_STATUS) error {

	// Cname
	configuration.Cname = genruntime.ClonePointerToString(source.Cname)

	// LeafDomainLabel
	configuration.LeafDomainLabel = genruntime.ClonePointerToString(source.LeafDomainLabel)

	// OverwriteExistingDomain
	if source.OverwriteExistingDomain != nil {
		overwriteExistingDomain := *source.OverwriteExistingDomain
		configuration.OverwriteExistingDomain = &overwriteExistingDomain
	} else {
		configuration.OverwriteExistingDomain = nil
	}

	// Status
	if source.Status != nil {
		status := genruntime.ToEnum(string(*source.Status), sslConfiguration_Status_Values)
		configuration.Status = &status
	} else {
		configuration.Status = nil
	}

	// No error
	return nil
}

// The ssl configuration for scoring
type SslConfiguration_STATUS struct {
	// Cname: CNAME of the cert
	Cname *string `json:"cname,omitempty"`

	// LeafDomainLabel: Leaf domain label of public endpoint
	LeafDomainLabel *string `json:"leafDomainLabel,omitempty"`

	// OverwriteExistingDomain: Indicates whether to overwrite existing domain label.
	OverwriteExistingDomain *bool `json:"overwriteExistingDomain,omitempty"`

	// Status: Enable or disable ssl for scoring
	Status *SslConfiguration_Status_STATUS `json:"status,omitempty"`
}

var _ genruntime.FromARMConverter = &SslConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *SslConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SslConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *SslConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SslConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SslConfiguration_STATUS, got %T", armInput)
	}

	// Set property "Cname":
	if typedInput.Cname != nil {
		cname := *typedInput.Cname
		configuration.Cname = &cname
	}

	// Set property "LeafDomainLabel":
	if typedInput.LeafDomainLabel != nil {
		leafDomainLabel := *typedInput.LeafDomainLabel
		configuration.LeafDomainLabel = &leafDomainLabel
	}

	// Set property "OverwriteExistingDomain":
	if typedInput.OverwriteExistingDomain != nil {
		overwriteExistingDomain := *typedInput.OverwriteExistingDomain
		configuration.OverwriteExistingDomain = &overwriteExistingDomain
	}

	// Set property "Status":
	if typedInput.Status != nil {
		var temp string
		temp = string(*typedInput.Status)
		status := SslConfiguration_Status_STATUS(temp)
		configuration.Status = &status
	}

	// No error
	return nil
}

// AssignProperties_From_SslConfiguration_STATUS populates our SslConfiguration_STATUS from the provided source SslConfiguration_STATUS
func (configuration *SslConfiguration_STATUS) AssignProperties_From_SslConfiguration_STATUS(source *storage.SslConfiguration_STATUS) error {

	// Cname
	configuration.Cname = genruntime.ClonePointerToString(source.Cname)

	// LeafDomainLabel
	configuration.LeafDomainLabel = genruntime.ClonePointerToString(source.LeafDomainLabel)

	// OverwriteExistingDomain
	if source.OverwriteExistingDomain != nil {
		overwriteExistingDomain := *source.OverwriteExistingDomain
		configuration.OverwriteExistingDomain = &overwriteExistingDomain
	} else {
		configuration.OverwriteExistingDomain = nil
	}

	// Status
	if source.Status != nil {
		status := *source.Status
		statusTemp := genruntime.ToEnum(status, sslConfiguration_Status_STATUS_Values)
		configuration.Status = &statusTemp
	} else {
		configuration.Status = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SslConfiguration_STATUS populates the provided destination SslConfiguration_STATUS from our SslConfiguration_STATUS
func (configuration *SslConfiguration_STATUS) AssignProperties_To_SslConfiguration_STATUS(destination *storage.SslConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Cname
	destination.Cname = genruntime.ClonePointerToString(configuration.Cname)

	// LeafDomainLabel
	destination.LeafDomainLabel = genruntime.ClonePointerToString(configuration.LeafDomainLabel)

	// OverwriteExistingDomain
	if configuration.OverwriteExistingDomain != nil {
		overwriteExistingDomain := *configuration.OverwriteExistingDomain
		destination.OverwriteExistingDomain = &overwriteExistingDomain
	} else {
		destination.OverwriteExistingDomain = nil
	}

	// Status
	if configuration.Status != nil {
		status := string(*configuration.Status)
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// A system service running on a compute.
type SystemService_STATUS struct {
	// PublicIpAddress: Public IP address
	PublicIpAddress *string `json:"publicIpAddress,omitempty"`

	// SystemServiceType: The type of this system service.
	SystemServiceType *string `json:"systemServiceType,omitempty"`

	// Version: The version for this type.
	Version *string `json:"version,omitempty"`
}

var _ genruntime.FromARMConverter = &SystemService_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (service *SystemService_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SystemService_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (service *SystemService_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SystemService_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SystemService_STATUS, got %T", armInput)
	}

	// Set property "PublicIpAddress":
	if typedInput.PublicIpAddress != nil {
		publicIpAddress := *typedInput.PublicIpAddress
		service.PublicIpAddress = &publicIpAddress
	}

	// Set property "SystemServiceType":
	if typedInput.SystemServiceType != nil {
		systemServiceType := *typedInput.SystemServiceType
		service.SystemServiceType = &systemServiceType
	}

	// Set property "Version":
	if typedInput.Version != nil {
		version := *typedInput.Version
		service.Version = &version
	}

	// No error
	return nil
}

// AssignProperties_From_SystemService_STATUS populates our SystemService_STATUS from the provided source SystemService_STATUS
func (service *SystemService_STATUS) AssignProperties_From_SystemService_STATUS(source *storage.SystemService_STATUS) error {

	// PublicIpAddress
	service.PublicIpAddress = genruntime.ClonePointerToString(source.PublicIpAddress)

	// SystemServiceType
	service.SystemServiceType = genruntime.ClonePointerToString(source.SystemServiceType)

	// Version
	service.Version = genruntime.ClonePointerToString(source.Version)

	// No error
	return nil
}

// AssignProperties_To_SystemService_STATUS populates the provided destination SystemService_STATUS from our SystemService_STATUS
func (service *SystemService_STATUS) AssignProperties_To_SystemService_STATUS(destination *storage.SystemService_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PublicIpAddress
	destination.PublicIpAddress = genruntime.ClonePointerToString(service.PublicIpAddress)

	// SystemServiceType
	destination.SystemServiceType = genruntime.ClonePointerToString(service.SystemServiceType)

	// Version
	destination.Version = genruntime.ClonePointerToString(service.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Settings for user account that gets created on each on the nodes of a compute.
type UserAccountCredentials struct {
	// +kubebuilder:validation:Required
	// AdminUserName: Name of the administrator user account which can be used to SSH to nodes.
	AdminUserName *string `json:"adminUserName,omitempty"`

	// AdminUserPassword: Password of the administrator user account.
	AdminUserPassword *genruntime.SecretReference `json:"adminUserPassword,omitempty"`

	// AdminUserSshPublicKey: SSH public key of the administrator user account.
	AdminUserSshPublicKey *genruntime.SecretReference `json:"adminUserSshPublicKey,omitempty"`
}

var _ genruntime.ARMTransformer = &UserAccountCredentials{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (credentials *UserAccountCredentials) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if credentials == nil {
		return nil, nil
	}
	result := &arm.UserAccountCredentials{}

	// Set property "AdminUserName":
	if credentials.AdminUserName != nil {
		adminUserName := *credentials.AdminUserName
		result.AdminUserName = &adminUserName
	}

	// Set property "AdminUserPassword":
	if credentials.AdminUserPassword != nil {
		adminUserPasswordSecret, err := resolved.ResolvedSecrets.Lookup(*credentials.AdminUserPassword)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property AdminUserPassword")
		}
		adminUserPassword := adminUserPasswordSecret
		result.AdminUserPassword = &adminUserPassword
	}

	// Set property "AdminUserSshPublicKey":
	if credentials.AdminUserSshPublicKey != nil {
		adminUserSshPublicKeySecret, err := resolved.ResolvedSecrets.Lookup(*credentials.AdminUserSshPublicKey)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property AdminUserSshPublicKey")
		}
		adminUserSshPublicKey := adminUserSshPublicKeySecret
		result.AdminUserSshPublicKey = &adminUserSshPublicKey
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (credentials *UserAccountCredentials) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UserAccountCredentials{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (credentials *UserAccountCredentials) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UserAccountCredentials)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UserAccountCredentials, got %T", armInput)
	}

	// Set property "AdminUserName":
	if typedInput.AdminUserName != nil {
		adminUserName := *typedInput.AdminUserName
		credentials.AdminUserName = &adminUserName
	}

	// no assignment for property "AdminUserPassword"

	// no assignment for property "AdminUserSshPublicKey"

	// No error
	return nil
}

// AssignProperties_From_UserAccountCredentials populates our UserAccountCredentials from the provided source UserAccountCredentials
func (credentials *UserAccountCredentials) AssignProperties_From_UserAccountCredentials(source *storage.UserAccountCredentials) error {

	// AdminUserName
	credentials.AdminUserName = genruntime.ClonePointerToString(source.AdminUserName)

	// AdminUserPassword
	if source.AdminUserPassword != nil {
		adminUserPassword := source.AdminUserPassword.Copy()
		credentials.AdminUserPassword = &adminUserPassword
	} else {
		credentials.AdminUserPassword = nil
	}

	// AdminUserSshPublicKey
	if source.AdminUserSshPublicKey != nil {
		adminUserSshPublicKey := source.AdminUserSshPublicKey.Copy()
		credentials.AdminUserSshPublicKey = &adminUserSshPublicKey
	} else {
		credentials.AdminUserSshPublicKey = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UserAccountCredentials populates the provided destination UserAccountCredentials from our UserAccountCredentials
func (credentials *UserAccountCredentials) AssignProperties_To_UserAccountCredentials(destination *storage.UserAccountCredentials) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminUserName
	destination.AdminUserName = genruntime.ClonePointerToString(credentials.AdminUserName)

	// AdminUserPassword
	if credentials.AdminUserPassword != nil {
		adminUserPassword := credentials.AdminUserPassword.Copy()
		destination.AdminUserPassword = &adminUserPassword
	} else {
		destination.AdminUserPassword = nil
	}

	// AdminUserSshPublicKey
	if credentials.AdminUserSshPublicKey != nil {
		adminUserSshPublicKey := credentials.AdminUserSshPublicKey.Copy()
		destination.AdminUserSshPublicKey = &adminUserSshPublicKey
	} else {
		destination.AdminUserSshPublicKey = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_UserAccountCredentials_STATUS populates our UserAccountCredentials from the provided source UserAccountCredentials_STATUS
func (credentials *UserAccountCredentials) Initialize_From_UserAccountCredentials_STATUS(source *UserAccountCredentials_STATUS) error {

	// AdminUserName
	credentials.AdminUserName = genruntime.ClonePointerToString(source.AdminUserName)

	// No error
	return nil
}

// Settings for user account that gets created on each on the nodes of a compute.
type UserAccountCredentials_STATUS struct {
	// AdminUserName: Name of the administrator user account which can be used to SSH to nodes.
	AdminUserName *string `json:"adminUserName,omitempty"`
}

var _ genruntime.FromARMConverter = &UserAccountCredentials_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (credentials *UserAccountCredentials_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UserAccountCredentials_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (credentials *UserAccountCredentials_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UserAccountCredentials_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UserAccountCredentials_STATUS, got %T", armInput)
	}

	// Set property "AdminUserName":
	if typedInput.AdminUserName != nil {
		adminUserName := *typedInput.AdminUserName
		credentials.AdminUserName = &adminUserName
	}

	// No error
	return nil
}

// AssignProperties_From_UserAccountCredentials_STATUS populates our UserAccountCredentials_STATUS from the provided source UserAccountCredentials_STATUS
func (credentials *UserAccountCredentials_STATUS) AssignProperties_From_UserAccountCredentials_STATUS(source *storage.UserAccountCredentials_STATUS) error {

	// AdminUserName
	credentials.AdminUserName = genruntime.ClonePointerToString(source.AdminUserName)

	// No error
	return nil
}

// AssignProperties_To_UserAccountCredentials_STATUS populates the provided destination UserAccountCredentials_STATUS from our UserAccountCredentials_STATUS
func (credentials *UserAccountCredentials_STATUS) AssignProperties_To_UserAccountCredentials_STATUS(destination *storage.UserAccountCredentials_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminUserName
	destination.AdminUserName = genruntime.ClonePointerToString(credentials.AdminUserName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Virtual Machine image for Windows AML Compute
type VirtualMachineImage struct {
	// +kubebuilder:validation:Required
	// Reference: Virtual Machine image path
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineImage{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (image *VirtualMachineImage) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if image == nil {
		return nil, nil
	}
	result := &arm.VirtualMachineImage{}

	// Set property "Id":
	if image.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*image.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (image *VirtualMachineImage) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineImage{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (image *VirtualMachineImage) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(arm.VirtualMachineImage)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineImage, got %T", armInput)
	}

	// no assignment for property "Reference"

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineImage populates our VirtualMachineImage from the provided source VirtualMachineImage
func (image *VirtualMachineImage) AssignProperties_From_VirtualMachineImage(source *storage.VirtualMachineImage) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		image.Reference = &reference
	} else {
		image.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineImage populates the provided destination VirtualMachineImage from our VirtualMachineImage
func (image *VirtualMachineImage) AssignProperties_To_VirtualMachineImage(destination *storage.VirtualMachineImage) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if image.Reference != nil {
		reference := image.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualMachineImage_STATUS populates our VirtualMachineImage from the provided source VirtualMachineImage_STATUS
func (image *VirtualMachineImage) Initialize_From_VirtualMachineImage_STATUS(source *VirtualMachineImage_STATUS) error {

	// Reference
	if source.Id != nil {
		reference := genruntime.CreateResourceReferenceFromARMID(*source.Id)
		image.Reference = &reference
	} else {
		image.Reference = nil
	}

	// No error
	return nil
}

// Virtual Machine image for Windows AML Compute
type VirtualMachineImage_STATUS struct {
	// Id: Virtual Machine image path
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineImage_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (image *VirtualMachineImage_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineImage_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (image *VirtualMachineImage_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineImage_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineImage_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		image.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineImage_STATUS populates our VirtualMachineImage_STATUS from the provided source VirtualMachineImage_STATUS
func (image *VirtualMachineImage_STATUS) AssignProperties_From_VirtualMachineImage_STATUS(source *storage.VirtualMachineImage_STATUS) error {

	// Id
	image.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineImage_STATUS populates the provided destination VirtualMachineImage_STATUS from our VirtualMachineImage_STATUS
func (image *VirtualMachineImage_STATUS) AssignProperties_To_VirtualMachineImage_STATUS(destination *storage.VirtualMachineImage_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(image.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Admin credentials for virtual machine
type VirtualMachineSshCredentials struct {
	// Password: Password of admin account
	Password *genruntime.SecretReference `json:"password,omitempty"`

	// PrivateKeyData: Private key data
	PrivateKeyData *genruntime.SecretReference `json:"privateKeyData,omitempty"`

	// PublicKeyData: Public key data
	PublicKeyData *genruntime.SecretReference `json:"publicKeyData,omitempty"`

	// Username: Username of admin account
	Username *string `json:"username,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineSshCredentials{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (credentials *VirtualMachineSshCredentials) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if credentials == nil {
		return nil, nil
	}
	result := &arm.VirtualMachineSshCredentials{}

	// Set property "Password":
	if credentials.Password != nil {
		passwordSecret, err := resolved.ResolvedSecrets.Lookup(*credentials.Password)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property Password")
		}
		password := passwordSecret
		result.Password = &password
	}

	// Set property "PrivateKeyData":
	if credentials.PrivateKeyData != nil {
		privateKeyDataSecret, err := resolved.ResolvedSecrets.Lookup(*credentials.PrivateKeyData)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property PrivateKeyData")
		}
		privateKeyData := privateKeyDataSecret
		result.PrivateKeyData = &privateKeyData
	}

	// Set property "PublicKeyData":
	if credentials.PublicKeyData != nil {
		publicKeyDataSecret, err := resolved.ResolvedSecrets.Lookup(*credentials.PublicKeyData)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property PublicKeyData")
		}
		publicKeyData := publicKeyDataSecret
		result.PublicKeyData = &publicKeyData
	}

	// Set property "Username":
	if credentials.Username != nil {
		username := *credentials.Username
		result.Username = &username
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (credentials *VirtualMachineSshCredentials) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineSshCredentials{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (credentials *VirtualMachineSshCredentials) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineSshCredentials)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineSshCredentials, got %T", armInput)
	}

	// no assignment for property "Password"

	// no assignment for property "PrivateKeyData"

	// no assignment for property "PublicKeyData"

	// Set property "Username":
	if typedInput.Username != nil {
		username := *typedInput.Username
		credentials.Username = &username
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineSshCredentials populates our VirtualMachineSshCredentials from the provided source VirtualMachineSshCredentials
func (credentials *VirtualMachineSshCredentials) AssignProperties_From_VirtualMachineSshCredentials(source *storage.VirtualMachineSshCredentials) error {

	// Password
	if source.Password != nil {
		password := source.Password.Copy()
		credentials.Password = &password
	} else {
		credentials.Password = nil
	}

	// PrivateKeyData
	if source.PrivateKeyData != nil {
		privateKeyDatum := source.PrivateKeyData.Copy()
		credentials.PrivateKeyData = &privateKeyDatum
	} else {
		credentials.PrivateKeyData = nil
	}

	// PublicKeyData
	if source.PublicKeyData != nil {
		publicKeyDatum := source.PublicKeyData.Copy()
		credentials.PublicKeyData = &publicKeyDatum
	} else {
		credentials.PublicKeyData = nil
	}

	// Username
	credentials.Username = genruntime.ClonePointerToString(source.Username)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineSshCredentials populates the provided destination VirtualMachineSshCredentials from our VirtualMachineSshCredentials
func (credentials *VirtualMachineSshCredentials) AssignProperties_To_VirtualMachineSshCredentials(destination *storage.VirtualMachineSshCredentials) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Password
	if credentials.Password != nil {
		password := credentials.Password.Copy()
		destination.Password = &password
	} else {
		destination.Password = nil
	}

	// PrivateKeyData
	if credentials.PrivateKeyData != nil {
		privateKeyDatum := credentials.PrivateKeyData.Copy()
		destination.PrivateKeyData = &privateKeyDatum
	} else {
		destination.PrivateKeyData = nil
	}

	// PublicKeyData
	if credentials.PublicKeyData != nil {
		publicKeyDatum := credentials.PublicKeyData.Copy()
		destination.PublicKeyData = &publicKeyDatum
	} else {
		destination.PublicKeyData = nil
	}

	// Username
	destination.Username = genruntime.ClonePointerToString(credentials.Username)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualMachineSshCredentials_STATUS populates our VirtualMachineSshCredentials from the provided source VirtualMachineSshCredentials_STATUS
func (credentials *VirtualMachineSshCredentials) Initialize_From_VirtualMachineSshCredentials_STATUS(source *VirtualMachineSshCredentials_STATUS) error {

	// Username
	credentials.Username = genruntime.ClonePointerToString(source.Username)

	// No error
	return nil
}

// Admin credentials for virtual machine
type VirtualMachineSshCredentials_STATUS struct {
	// Username: Username of admin account
	Username *string `json:"username,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineSshCredentials_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (credentials *VirtualMachineSshCredentials_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineSshCredentials_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (credentials *VirtualMachineSshCredentials_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineSshCredentials_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineSshCredentials_STATUS, got %T", armInput)
	}

	// Set property "Username":
	if typedInput.Username != nil {
		username := *typedInput.Username
		credentials.Username = &username
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineSshCredentials_STATUS populates our VirtualMachineSshCredentials_STATUS from the provided source VirtualMachineSshCredentials_STATUS
func (credentials *VirtualMachineSshCredentials_STATUS) AssignProperties_From_VirtualMachineSshCredentials_STATUS(source *storage.VirtualMachineSshCredentials_STATUS) error {

	// Username
	credentials.Username = genruntime.ClonePointerToString(source.Username)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineSshCredentials_STATUS populates the provided destination VirtualMachineSshCredentials_STATUS from our VirtualMachineSshCredentials_STATUS
func (credentials *VirtualMachineSshCredentials_STATUS) AssignProperties_To_VirtualMachineSshCredentials_STATUS(destination *storage.VirtualMachineSshCredentials_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Username
	destination.Username = genruntime.ClonePointerToString(credentials.Username)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// A user that can be assigned to a compute instance.
type AssignedUser struct {
	// ObjectId: Users AAD Object Id.
	ObjectId *string `json:"objectId,omitempty" optionalConfigMapPair:"ObjectId"`

	// ObjectIdFromConfig: Users AAD Object Id.
	ObjectIdFromConfig *genruntime.ConfigMapReference `json:"objectIdFromConfig,omitempty" optionalConfigMapPair:"ObjectId"`

	// TenantId: Users AAD Tenant Id.
	TenantId *string `json:"tenantId,omitempty" optionalConfigMapPair:"TenantId"`

	// TenantIdFromConfig: Users AAD Tenant Id.
	TenantIdFromConfig *genruntime.ConfigMapReference `json:"tenantIdFromConfig,omitempty" optionalConfigMapPair:"TenantId"`
}

var _ genruntime.ARMTransformer = &AssignedUser{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (user *AssignedUser) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if user == nil {
		return nil, nil
	}
	result := &arm.AssignedUser{}

	// Set property "ObjectId":
	if user.ObjectId != nil {
		objectId := *user.ObjectId
		result.ObjectId = &objectId
	}
	if user.ObjectIdFromConfig != nil {
		objectIdValue, err := resolved.ResolvedConfigMaps.Lookup(*user.ObjectIdFromConfig)
		if err != nil {
			return nil, errors.Wrap(err, "looking up configmap for property ObjectId")
		}
		objectId := objectIdValue
		result.ObjectId = &objectId
	}

	// Set property "TenantId":
	if user.TenantId != nil {
		tenantId := *user.TenantId
		result.TenantId = &tenantId
	}
	if user.TenantIdFromConfig != nil {
		tenantIdValue, err := resolved.ResolvedConfigMaps.Lookup(*user.TenantIdFromConfig)
		if err != nil {
			return nil, errors.Wrap(err, "looking up configmap for property TenantId")
		}
		tenantId := tenantIdValue
		result.TenantId = &tenantId
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (user *AssignedUser) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AssignedUser{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (user *AssignedUser) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AssignedUser)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AssignedUser, got %T", armInput)
	}

	// Set property "ObjectId":
	if typedInput.ObjectId != nil {
		objectId := *typedInput.ObjectId
		user.ObjectId = &objectId
	}

	// no assignment for property "ObjectIdFromConfig"

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		user.TenantId = &tenantId
	}

	// no assignment for property "TenantIdFromConfig"

	// No error
	return nil
}

// AssignProperties_From_AssignedUser populates our AssignedUser from the provided source AssignedUser
func (user *AssignedUser) AssignProperties_From_AssignedUser(source *storage.AssignedUser) error {

	// ObjectId
	user.ObjectId = genruntime.ClonePointerToString(source.ObjectId)

	// ObjectIdFromConfig
	if source.ObjectIdFromConfig != nil {
		objectIdFromConfig := source.ObjectIdFromConfig.Copy()
		user.ObjectIdFromConfig = &objectIdFromConfig
	} else {
		user.ObjectIdFromConfig = nil
	}

	// TenantId
	user.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// TenantIdFromConfig
	if source.TenantIdFromConfig != nil {
		tenantIdFromConfig := source.TenantIdFromConfig.Copy()
		user.TenantIdFromConfig = &tenantIdFromConfig
	} else {
		user.TenantIdFromConfig = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AssignedUser populates the provided destination AssignedUser from our AssignedUser
func (user *AssignedUser) AssignProperties_To_AssignedUser(destination *storage.AssignedUser) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ObjectId
	destination.ObjectId = genruntime.ClonePointerToString(user.ObjectId)

	// ObjectIdFromConfig
	if user.ObjectIdFromConfig != nil {
		objectIdFromConfig := user.ObjectIdFromConfig.Copy()
		destination.ObjectIdFromConfig = &objectIdFromConfig
	} else {
		destination.ObjectIdFromConfig = nil
	}

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(user.TenantId)

	// TenantIdFromConfig
	if user.TenantIdFromConfig != nil {
		tenantIdFromConfig := user.TenantIdFromConfig.Copy()
		destination.TenantIdFromConfig = &tenantIdFromConfig
	} else {
		destination.TenantIdFromConfig = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AssignedUser_STATUS populates our AssignedUser from the provided source AssignedUser_STATUS
func (user *AssignedUser) Initialize_From_AssignedUser_STATUS(source *AssignedUser_STATUS) error {

	// ObjectId
	user.ObjectId = genruntime.ClonePointerToString(source.ObjectId)

	// TenantId
	user.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// No error
	return nil
}

// A user that can be assigned to a compute instance.
type AssignedUser_STATUS struct {
	// ObjectId: Users AAD Object Id.
	ObjectId *string `json:"objectId,omitempty"`

	// TenantId: Users AAD Tenant Id.
	TenantId *string `json:"tenantId,omitempty"`
}

var _ genruntime.FromARMConverter = &AssignedUser_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (user *AssignedUser_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AssignedUser_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (user *AssignedUser_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AssignedUser_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AssignedUser_STATUS, got %T", armInput)
	}

	// Set property "ObjectId":
	if typedInput.ObjectId != nil {
		objectId := *typedInput.ObjectId
		user.ObjectId = &objectId
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		user.TenantId = &tenantId
	}

	// No error
	return nil
}

// AssignProperties_From_AssignedUser_STATUS populates our AssignedUser_STATUS from the provided source AssignedUser_STATUS
func (user *AssignedUser_STATUS) AssignProperties_From_AssignedUser_STATUS(source *storage.AssignedUser_STATUS) error {

	// ObjectId
	user.ObjectId = genruntime.ClonePointerToString(source.ObjectId)

	// TenantId
	user.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// No error
	return nil
}

// AssignProperties_To_AssignedUser_STATUS populates the provided destination AssignedUser_STATUS from our AssignedUser_STATUS
func (user *AssignedUser_STATUS) AssignProperties_To_AssignedUser_STATUS(destination *storage.AssignedUser_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ObjectId
	destination.ObjectId = genruntime.ClonePointerToString(user.ObjectId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(user.TenantId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ComputeInstanceContainer_Autosave_STATUS string

const (
	ComputeInstanceContainer_Autosave_STATUS_Local  = ComputeInstanceContainer_Autosave_STATUS("Local")
	ComputeInstanceContainer_Autosave_STATUS_None   = ComputeInstanceContainer_Autosave_STATUS("None")
	ComputeInstanceContainer_Autosave_STATUS_Remote = ComputeInstanceContainer_Autosave_STATUS("Remote")
)

// Mapping from string to ComputeInstanceContainer_Autosave_STATUS
var computeInstanceContainer_Autosave_STATUS_Values = map[string]ComputeInstanceContainer_Autosave_STATUS{
	"local":  ComputeInstanceContainer_Autosave_STATUS_Local,
	"none":   ComputeInstanceContainer_Autosave_STATUS_None,
	"remote": ComputeInstanceContainer_Autosave_STATUS_Remote,
}

type ComputeInstanceContainer_Network_STATUS string

const (
	ComputeInstanceContainer_Network_STATUS_Bridge = ComputeInstanceContainer_Network_STATUS("Bridge")
	ComputeInstanceContainer_Network_STATUS_Host   = ComputeInstanceContainer_Network_STATUS("Host")
)

// Mapping from string to ComputeInstanceContainer_Network_STATUS
var computeInstanceContainer_Network_STATUS_Values = map[string]ComputeInstanceContainer_Network_STATUS{
	"bridge": ComputeInstanceContainer_Network_STATUS_Bridge,
	"host":   ComputeInstanceContainer_Network_STATUS_Host,
}

type ComputeInstanceDataDisk_Caching_STATUS string

const (
	ComputeInstanceDataDisk_Caching_STATUS_None      = ComputeInstanceDataDisk_Caching_STATUS("None")
	ComputeInstanceDataDisk_Caching_STATUS_ReadOnly  = ComputeInstanceDataDisk_Caching_STATUS("ReadOnly")
	ComputeInstanceDataDisk_Caching_STATUS_ReadWrite = ComputeInstanceDataDisk_Caching_STATUS("ReadWrite")
)

// Mapping from string to ComputeInstanceDataDisk_Caching_STATUS
var computeInstanceDataDisk_Caching_STATUS_Values = map[string]ComputeInstanceDataDisk_Caching_STATUS{
	"none":      ComputeInstanceDataDisk_Caching_STATUS_None,
	"readonly":  ComputeInstanceDataDisk_Caching_STATUS_ReadOnly,
	"readwrite": ComputeInstanceDataDisk_Caching_STATUS_ReadWrite,
}

type ComputeInstanceDataDisk_StorageAccountType_STATUS string

const (
	ComputeInstanceDataDisk_StorageAccountType_STATUS_Premium_LRS  = ComputeInstanceDataDisk_StorageAccountType_STATUS("Premium_LRS")
	ComputeInstanceDataDisk_StorageAccountType_STATUS_Standard_LRS = ComputeInstanceDataDisk_StorageAccountType_STATUS("Standard_LRS")
)

// Mapping from string to ComputeInstanceDataDisk_StorageAccountType_STATUS
var computeInstanceDataDisk_StorageAccountType_STATUS_Values = map[string]ComputeInstanceDataDisk_StorageAccountType_STATUS{
	"premium_lrs":  ComputeInstanceDataDisk_StorageAccountType_STATUS_Premium_LRS,
	"standard_lrs": ComputeInstanceDataDisk_StorageAccountType_STATUS_Standard_LRS,
}

type ComputeInstanceDataMount_MountAction_STATUS string

const (
	ComputeInstanceDataMount_MountAction_STATUS_Mount   = ComputeInstanceDataMount_MountAction_STATUS("Mount")
	ComputeInstanceDataMount_MountAction_STATUS_Unmount = ComputeInstanceDataMount_MountAction_STATUS("Unmount")
)

// Mapping from string to ComputeInstanceDataMount_MountAction_STATUS
var computeInstanceDataMount_MountAction_STATUS_Values = map[string]ComputeInstanceDataMount_MountAction_STATUS{
	"mount":   ComputeInstanceDataMount_MountAction_STATUS_Mount,
	"unmount": ComputeInstanceDataMount_MountAction_STATUS_Unmount,
}

type ComputeInstanceDataMount_MountState_STATUS string

const (
	ComputeInstanceDataMount_MountState_STATUS_MountFailed      = ComputeInstanceDataMount_MountState_STATUS("MountFailed")
	ComputeInstanceDataMount_MountState_STATUS_MountRequested   = ComputeInstanceDataMount_MountState_STATUS("MountRequested")
	ComputeInstanceDataMount_MountState_STATUS_Mounted          = ComputeInstanceDataMount_MountState_STATUS("Mounted")
	ComputeInstanceDataMount_MountState_STATUS_UnmountFailed    = ComputeInstanceDataMount_MountState_STATUS("UnmountFailed")
	ComputeInstanceDataMount_MountState_STATUS_UnmountRequested = ComputeInstanceDataMount_MountState_STATUS("UnmountRequested")
	ComputeInstanceDataMount_MountState_STATUS_Unmounted        = ComputeInstanceDataMount_MountState_STATUS("Unmounted")
)

// Mapping from string to ComputeInstanceDataMount_MountState_STATUS
var computeInstanceDataMount_MountState_STATUS_Values = map[string]ComputeInstanceDataMount_MountState_STATUS{
	"mountfailed":      ComputeInstanceDataMount_MountState_STATUS_MountFailed,
	"mountrequested":   ComputeInstanceDataMount_MountState_STATUS_MountRequested,
	"mounted":          ComputeInstanceDataMount_MountState_STATUS_Mounted,
	"unmountfailed":    ComputeInstanceDataMount_MountState_STATUS_UnmountFailed,
	"unmountrequested": ComputeInstanceDataMount_MountState_STATUS_UnmountRequested,
	"unmounted":        ComputeInstanceDataMount_MountState_STATUS_Unmounted,
}

type ComputeInstanceDataMount_SourceType_STATUS string

const (
	ComputeInstanceDataMount_SourceType_STATUS_Dataset   = ComputeInstanceDataMount_SourceType_STATUS("Dataset")
	ComputeInstanceDataMount_SourceType_STATUS_Datastore = ComputeInstanceDataMount_SourceType_STATUS("Datastore")
	ComputeInstanceDataMount_SourceType_STATUS_URI       = ComputeInstanceDataMount_SourceType_STATUS("URI")
)

// Mapping from string to ComputeInstanceDataMount_SourceType_STATUS
var computeInstanceDataMount_SourceType_STATUS_Values = map[string]ComputeInstanceDataMount_SourceType_STATUS{
	"dataset":   ComputeInstanceDataMount_SourceType_STATUS_Dataset,
	"datastore": ComputeInstanceDataMount_SourceType_STATUS_Datastore,
	"uri":       ComputeInstanceDataMount_SourceType_STATUS_URI,
}

// Environment information
type ComputeInstanceEnvironmentInfo_STATUS struct {
	// Name: name of environment.
	Name *string `json:"name,omitempty"`

	// Version: version of environment.
	Version *string `json:"version,omitempty"`
}

var _ genruntime.FromARMConverter = &ComputeInstanceEnvironmentInfo_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (info *ComputeInstanceEnvironmentInfo_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComputeInstanceEnvironmentInfo_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (info *ComputeInstanceEnvironmentInfo_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComputeInstanceEnvironmentInfo_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComputeInstanceEnvironmentInfo_STATUS, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		info.Name = &name
	}

	// Set property "Version":
	if typedInput.Version != nil {
		version := *typedInput.Version
		info.Version = &version
	}

	// No error
	return nil
}

// AssignProperties_From_ComputeInstanceEnvironmentInfo_STATUS populates our ComputeInstanceEnvironmentInfo_STATUS from the provided source ComputeInstanceEnvironmentInfo_STATUS
func (info *ComputeInstanceEnvironmentInfo_STATUS) AssignProperties_From_ComputeInstanceEnvironmentInfo_STATUS(source *storage.ComputeInstanceEnvironmentInfo_STATUS) error {

	// Name
	info.Name = genruntime.ClonePointerToString(source.Name)

	// Version
	info.Version = genruntime.ClonePointerToString(source.Version)

	// No error
	return nil
}

// AssignProperties_To_ComputeInstanceEnvironmentInfo_STATUS populates the provided destination ComputeInstanceEnvironmentInfo_STATUS from our ComputeInstanceEnvironmentInfo_STATUS
func (info *ComputeInstanceEnvironmentInfo_STATUS) AssignProperties_To_ComputeInstanceEnvironmentInfo_STATUS(destination *storage.ComputeInstanceEnvironmentInfo_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(info.Name)

	// Version
	destination.Version = genruntime.ClonePointerToString(info.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ComputeInstanceLastOperation_OperationName_STATUS string

const (
	ComputeInstanceLastOperation_OperationName_STATUS_Create  = ComputeInstanceLastOperation_OperationName_STATUS("Create")
	ComputeInstanceLastOperation_OperationName_STATUS_Delete  = ComputeInstanceLastOperation_OperationName_STATUS("Delete")
	ComputeInstanceLastOperation_OperationName_STATUS_Reimage = ComputeInstanceLastOperation_OperationName_STATUS("Reimage")
	ComputeInstanceLastOperation_OperationName_STATUS_Restart = ComputeInstanceLastOperation_OperationName_STATUS("Restart")
	ComputeInstanceLastOperation_OperationName_STATUS_Start   = ComputeInstanceLastOperation_OperationName_STATUS("Start")
	ComputeInstanceLastOperation_OperationName_STATUS_Stop    = ComputeInstanceLastOperation_OperationName_STATUS("Stop")
)

// Mapping from string to ComputeInstanceLastOperation_OperationName_STATUS
var computeInstanceLastOperation_OperationName_STATUS_Values = map[string]ComputeInstanceLastOperation_OperationName_STATUS{
	"create":  ComputeInstanceLastOperation_OperationName_STATUS_Create,
	"delete":  ComputeInstanceLastOperation_OperationName_STATUS_Delete,
	"reimage": ComputeInstanceLastOperation_OperationName_STATUS_Reimage,
	"restart": ComputeInstanceLastOperation_OperationName_STATUS_Restart,
	"start":   ComputeInstanceLastOperation_OperationName_STATUS_Start,
	"stop":    ComputeInstanceLastOperation_OperationName_STATUS_Stop,
}

type ComputeInstanceLastOperation_OperationStatus_STATUS string

const (
	ComputeInstanceLastOperation_OperationStatus_STATUS_CreateFailed  = ComputeInstanceLastOperation_OperationStatus_STATUS("CreateFailed")
	ComputeInstanceLastOperation_OperationStatus_STATUS_DeleteFailed  = ComputeInstanceLastOperation_OperationStatus_STATUS("DeleteFailed")
	ComputeInstanceLastOperation_OperationStatus_STATUS_InProgress    = ComputeInstanceLastOperation_OperationStatus_STATUS("InProgress")
	ComputeInstanceLastOperation_OperationStatus_STATUS_ReimageFailed = ComputeInstanceLastOperation_OperationStatus_STATUS("ReimageFailed")
	ComputeInstanceLastOperation_OperationStatus_STATUS_RestartFailed = ComputeInstanceLastOperation_OperationStatus_STATUS("RestartFailed")
	ComputeInstanceLastOperation_OperationStatus_STATUS_StartFailed   = ComputeInstanceLastOperation_OperationStatus_STATUS("StartFailed")
	ComputeInstanceLastOperation_OperationStatus_STATUS_StopFailed    = ComputeInstanceLastOperation_OperationStatus_STATUS("StopFailed")
	ComputeInstanceLastOperation_OperationStatus_STATUS_Succeeded     = ComputeInstanceLastOperation_OperationStatus_STATUS("Succeeded")
)

// Mapping from string to ComputeInstanceLastOperation_OperationStatus_STATUS
var computeInstanceLastOperation_OperationStatus_STATUS_Values = map[string]ComputeInstanceLastOperation_OperationStatus_STATUS{
	"createfailed":  ComputeInstanceLastOperation_OperationStatus_STATUS_CreateFailed,
	"deletefailed":  ComputeInstanceLastOperation_OperationStatus_STATUS_DeleteFailed,
	"inprogress":    ComputeInstanceLastOperation_OperationStatus_STATUS_InProgress,
	"reimagefailed": ComputeInstanceLastOperation_OperationStatus_STATUS_ReimageFailed,
	"restartfailed": ComputeInstanceLastOperation_OperationStatus_STATUS_RestartFailed,
	"startfailed":   ComputeInstanceLastOperation_OperationStatus_STATUS_StartFailed,
	"stopfailed":    ComputeInstanceLastOperation_OperationStatus_STATUS_StopFailed,
	"succeeded":     ComputeInstanceLastOperation_OperationStatus_STATUS_Succeeded,
}

type ComputeInstanceLastOperation_OperationTrigger_STATUS string

const (
	ComputeInstanceLastOperation_OperationTrigger_STATUS_IdleShutdown = ComputeInstanceLastOperation_OperationTrigger_STATUS("IdleShutdown")
	ComputeInstanceLastOperation_OperationTrigger_STATUS_Schedule     = ComputeInstanceLastOperation_OperationTrigger_STATUS("Schedule")
	ComputeInstanceLastOperation_OperationTrigger_STATUS_User         = ComputeInstanceLastOperation_OperationTrigger_STATUS("User")
)

// Mapping from string to ComputeInstanceLastOperation_OperationTrigger_STATUS
var computeInstanceLastOperation_OperationTrigger_STATUS_Values = map[string]ComputeInstanceLastOperation_OperationTrigger_STATUS{
	"idleshutdown": ComputeInstanceLastOperation_OperationTrigger_STATUS_IdleShutdown,
	"schedule":     ComputeInstanceLastOperation_OperationTrigger_STATUS_Schedule,
	"user":         ComputeInstanceLastOperation_OperationTrigger_STATUS_User,
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type ComputeInstanceSshSettings_SshPublicAccess string

const (
	ComputeInstanceSshSettings_SshPublicAccess_Disabled = ComputeInstanceSshSettings_SshPublicAccess("Disabled")
	ComputeInstanceSshSettings_SshPublicAccess_Enabled  = ComputeInstanceSshSettings_SshPublicAccess("Enabled")
)

// Mapping from string to ComputeInstanceSshSettings_SshPublicAccess
var computeInstanceSshSettings_SshPublicAccess_Values = map[string]ComputeInstanceSshSettings_SshPublicAccess{
	"disabled": ComputeInstanceSshSettings_SshPublicAccess_Disabled,
	"enabled":  ComputeInstanceSshSettings_SshPublicAccess_Enabled,
}

type ComputeInstanceSshSettings_SshPublicAccess_STATUS string

const (
	ComputeInstanceSshSettings_SshPublicAccess_STATUS_Disabled = ComputeInstanceSshSettings_SshPublicAccess_STATUS("Disabled")
	ComputeInstanceSshSettings_SshPublicAccess_STATUS_Enabled  = ComputeInstanceSshSettings_SshPublicAccess_STATUS("Enabled")
)

// Mapping from string to ComputeInstanceSshSettings_SshPublicAccess_STATUS
var computeInstanceSshSettings_SshPublicAccess_STATUS_Values = map[string]ComputeInstanceSshSettings_SshPublicAccess_STATUS{
	"disabled": ComputeInstanceSshSettings_SshPublicAccess_STATUS_Disabled,
	"enabled":  ComputeInstanceSshSettings_SshPublicAccess_STATUS_Enabled,
}

// Compute start stop schedule properties
type ComputeStartStopSchedule struct {
	// Action: [Required] The compute power action.
	Action *ComputePowerAction `json:"action,omitempty"`

	// Cron: Required if triggerType is Cron.
	Cron *Cron `json:"cron,omitempty"`

	// Recurrence: Required if triggerType is Recurrence.
	Recurrence *Recurrence `json:"recurrence,omitempty"`

	// Schedule: [Deprecated] Not used any more.
	Schedule *ScheduleBase `json:"schedule,omitempty"`

	// Status: Is the schedule enabled or disabled?
	Status *ScheduleStatus `json:"status,omitempty"`

	// TriggerType: [Required] The schedule trigger type.
	TriggerType *ComputeTriggerType `json:"triggerType,omitempty"`
}

var _ genruntime.ARMTransformer = &ComputeStartStopSchedule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (schedule *ComputeStartStopSchedule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if schedule == nil {
		return nil, nil
	}
	result := &arm.ComputeStartStopSchedule{}

	// Set property "Action":
	if schedule.Action != nil {
		var temp string
		temp = string(*schedule.Action)
		action := arm.ComputePowerAction(temp)
		result.Action = &action
	}

	// Set property "Cron":
	if schedule.Cron != nil {
		cron_ARM, err := (*schedule.Cron).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		cron := *cron_ARM.(*arm.Cron)
		result.Cron = &cron
	}

	// Set property "Recurrence":
	if schedule.Recurrence != nil {
		recurrence_ARM, err := (*schedule.Recurrence).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		recurrence := *recurrence_ARM.(*arm.Recurrence)
		result.Recurrence = &recurrence
	}

	// Set property "Schedule":
	if schedule.Schedule != nil {
		schedule_ARM, err := (*schedule.Schedule).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		schedule1 := *schedule_ARM.(*arm.ScheduleBase)
		result.Schedule = &schedule1
	}

	// Set property "Status":
	if schedule.Status != nil {
		var temp string
		temp = string(*schedule.Status)
		status := arm.ScheduleStatus(temp)
		result.Status = &status
	}

	// Set property "TriggerType":
	if schedule.TriggerType != nil {
		var temp string
		temp = string(*schedule.TriggerType)
		triggerType := arm.ComputeTriggerType(temp)
		result.TriggerType = &triggerType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (schedule *ComputeStartStopSchedule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComputeStartStopSchedule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (schedule *ComputeStartStopSchedule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComputeStartStopSchedule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComputeStartStopSchedule, got %T", armInput)
	}

	// Set property "Action":
	if typedInput.Action != nil {
		var temp string
		temp = string(*typedInput.Action)
		action := ComputePowerAction(temp)
		schedule.Action = &action
	}

	// Set property "Cron":
	if typedInput.Cron != nil {
		var cron1 Cron
		err := cron1.PopulateFromARM(owner, *typedInput.Cron)
		if err != nil {
			return err
		}
		cron := cron1
		schedule.Cron = &cron
	}

	// Set property "Recurrence":
	if typedInput.Recurrence != nil {
		var recurrence1 Recurrence
		err := recurrence1.PopulateFromARM(owner, *typedInput.Recurrence)
		if err != nil {
			return err
		}
		recurrence := recurrence1
		schedule.Recurrence = &recurrence
	}

	// Set property "Schedule":
	if typedInput.Schedule != nil {
		var schedule2 ScheduleBase
		err := schedule2.PopulateFromARM(owner, *typedInput.Schedule)
		if err != nil {
			return err
		}
		schedule1 := schedule2
		schedule.Schedule = &schedule1
	}

	// Set property "Status":
	if typedInput.Status != nil {
		var temp string
		temp = string(*typedInput.Status)
		status := ScheduleStatus(temp)
		schedule.Status = &status
	}

	// Set property "TriggerType":
	if typedInput.TriggerType != nil {
		var temp string
		temp = string(*typedInput.TriggerType)
		triggerType := ComputeTriggerType(temp)
		schedule.TriggerType = &triggerType
	}

	// No error
	return nil
}

// AssignProperties_From_ComputeStartStopSchedule populates our ComputeStartStopSchedule from the provided source ComputeStartStopSchedule
func (schedule *ComputeStartStopSchedule) AssignProperties_From_ComputeStartStopSchedule(source *storage.ComputeStartStopSchedule) error {

	// Action
	if source.Action != nil {
		action := *source.Action
		actionTemp := genruntime.ToEnum(action, computePowerAction_Values)
		schedule.Action = &actionTemp
	} else {
		schedule.Action = nil
	}

	// Cron
	if source.Cron != nil {
		var cron Cron
		err := cron.AssignProperties_From_Cron(source.Cron)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Cron() to populate field Cron")
		}
		schedule.Cron = &cron
	} else {
		schedule.Cron = nil
	}

	// Recurrence
	if source.Recurrence != nil {
		var recurrence Recurrence
		err := recurrence.AssignProperties_From_Recurrence(source.Recurrence)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Recurrence() to populate field Recurrence")
		}
		schedule.Recurrence = &recurrence
	} else {
		schedule.Recurrence = nil
	}

	// Schedule
	if source.Schedule != nil {
		var scheduleLocal ScheduleBase
		err := scheduleLocal.AssignProperties_From_ScheduleBase(source.Schedule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ScheduleBase() to populate field Schedule")
		}
		schedule.Schedule = &scheduleLocal
	} else {
		schedule.Schedule = nil
	}

	// Status
	if source.Status != nil {
		status := *source.Status
		statusTemp := genruntime.ToEnum(status, scheduleStatus_Values)
		schedule.Status = &statusTemp
	} else {
		schedule.Status = nil
	}

	// TriggerType
	if source.TriggerType != nil {
		triggerType := *source.TriggerType
		triggerTypeTemp := genruntime.ToEnum(triggerType, computeTriggerType_Values)
		schedule.TriggerType = &triggerTypeTemp
	} else {
		schedule.TriggerType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ComputeStartStopSchedule populates the provided destination ComputeStartStopSchedule from our ComputeStartStopSchedule
func (schedule *ComputeStartStopSchedule) AssignProperties_To_ComputeStartStopSchedule(destination *storage.ComputeStartStopSchedule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	if schedule.Action != nil {
		action := string(*schedule.Action)
		destination.Action = &action
	} else {
		destination.Action = nil
	}

	// Cron
	if schedule.Cron != nil {
		var cron storage.Cron
		err := schedule.Cron.AssignProperties_To_Cron(&cron)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Cron() to populate field Cron")
		}
		destination.Cron = &cron
	} else {
		destination.Cron = nil
	}

	// Recurrence
	if schedule.Recurrence != nil {
		var recurrence storage.Recurrence
		err := schedule.Recurrence.AssignProperties_To_Recurrence(&recurrence)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Recurrence() to populate field Recurrence")
		}
		destination.Recurrence = &recurrence
	} else {
		destination.Recurrence = nil
	}

	// Schedule
	if schedule.Schedule != nil {
		var scheduleLocal storage.ScheduleBase
		err := schedule.Schedule.AssignProperties_To_ScheduleBase(&scheduleLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ScheduleBase() to populate field Schedule")
		}
		destination.Schedule = &scheduleLocal
	} else {
		destination.Schedule = nil
	}

	// Status
	if schedule.Status != nil {
		status := string(*schedule.Status)
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// TriggerType
	if schedule.TriggerType != nil {
		triggerType := string(*schedule.TriggerType)
		destination.TriggerType = &triggerType
	} else {
		destination.TriggerType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ComputeStartStopSchedule_STATUS populates our ComputeStartStopSchedule from the provided source ComputeStartStopSchedule_STATUS
func (schedule *ComputeStartStopSchedule) Initialize_From_ComputeStartStopSchedule_STATUS(source *ComputeStartStopSchedule_STATUS) error {

	// Action
	if source.Action != nil {
		action := genruntime.ToEnum(string(*source.Action), computePowerAction_Values)
		schedule.Action = &action
	} else {
		schedule.Action = nil
	}

	// Cron
	if source.Cron != nil {
		var cron Cron
		err := cron.Initialize_From_Cron_STATUS(source.Cron)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_Cron_STATUS() to populate field Cron")
		}
		schedule.Cron = &cron
	} else {
		schedule.Cron = nil
	}

	// Recurrence
	if source.Recurrence != nil {
		var recurrence Recurrence
		err := recurrence.Initialize_From_Recurrence_STATUS(source.Recurrence)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_Recurrence_STATUS() to populate field Recurrence")
		}
		schedule.Recurrence = &recurrence
	} else {
		schedule.Recurrence = nil
	}

	// Schedule
	if source.Schedule != nil {
		var scheduleLocal ScheduleBase
		err := scheduleLocal.Initialize_From_ScheduleBase_STATUS(source.Schedule)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ScheduleBase_STATUS() to populate field Schedule")
		}
		schedule.Schedule = &scheduleLocal
	} else {
		schedule.Schedule = nil
	}

	// Status
	if source.Status != nil {
		status := genruntime.ToEnum(string(*source.Status), scheduleStatus_Values)
		schedule.Status = &status
	} else {
		schedule.Status = nil
	}

	// TriggerType
	if source.TriggerType != nil {
		triggerType := genruntime.ToEnum(string(*source.TriggerType), computeTriggerType_Values)
		schedule.TriggerType = &triggerType
	} else {
		schedule.TriggerType = nil
	}

	// No error
	return nil
}

// Compute start stop schedule properties
type ComputeStartStopSchedule_STATUS struct {
	// Action: [Required] The compute power action.
	Action *ComputePowerAction_STATUS `json:"action,omitempty"`

	// Cron: Required if triggerType is Cron.
	Cron *Cron_STATUS `json:"cron,omitempty"`

	// Id: A system assigned id for the schedule.
	Id *string `json:"id,omitempty"`

	// ProvisioningStatus: The current deployment state of schedule.
	ProvisioningStatus *ComputeStartStopSchedule_ProvisioningStatus_STATUS `json:"provisioningStatus,omitempty"`

	// Recurrence: Required if triggerType is Recurrence.
	Recurrence *Recurrence_STATUS `json:"recurrence,omitempty"`

	// Schedule: [Deprecated] Not used any more.
	Schedule *ScheduleBase_STATUS `json:"schedule,omitempty"`

	// Status: Is the schedule enabled or disabled?
	Status *ScheduleStatus_STATUS `json:"status,omitempty"`

	// TriggerType: [Required] The schedule trigger type.
	TriggerType *ComputeTriggerType_STATUS `json:"triggerType,omitempty"`
}

var _ genruntime.FromARMConverter = &ComputeStartStopSchedule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (schedule *ComputeStartStopSchedule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComputeStartStopSchedule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (schedule *ComputeStartStopSchedule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComputeStartStopSchedule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComputeStartStopSchedule_STATUS, got %T", armInput)
	}

	// Set property "Action":
	if typedInput.Action != nil {
		var temp string
		temp = string(*typedInput.Action)
		action := ComputePowerAction_STATUS(temp)
		schedule.Action = &action
	}

	// Set property "Cron":
	if typedInput.Cron != nil {
		var cron1 Cron_STATUS
		err := cron1.PopulateFromARM(owner, *typedInput.Cron)
		if err != nil {
			return err
		}
		cron := cron1
		schedule.Cron = &cron
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		schedule.Id = &id
	}

	// Set property "ProvisioningStatus":
	if typedInput.ProvisioningStatus != nil {
		var temp string
		temp = string(*typedInput.ProvisioningStatus)
		provisioningStatus := ComputeStartStopSchedule_ProvisioningStatus_STATUS(temp)
		schedule.ProvisioningStatus = &provisioningStatus
	}

	// Set property "Recurrence":
	if typedInput.Recurrence != nil {
		var recurrence1 Recurrence_STATUS
		err := recurrence1.PopulateFromARM(owner, *typedInput.Recurrence)
		if err != nil {
			return err
		}
		recurrence := recurrence1
		schedule.Recurrence = &recurrence
	}

	// Set property "Schedule":
	if typedInput.Schedule != nil {
		var schedule2 ScheduleBase_STATUS
		err := schedule2.PopulateFromARM(owner, *typedInput.Schedule)
		if err != nil {
			return err
		}
		schedule1 := schedule2
		schedule.Schedule = &schedule1
	}

	// Set property "Status":
	if typedInput.Status != nil {
		var temp string
		temp = string(*typedInput.Status)
		status := ScheduleStatus_STATUS(temp)
		schedule.Status = &status
	}

	// Set property "TriggerType":
	if typedInput.TriggerType != nil {
		var temp string
		temp = string(*typedInput.TriggerType)
		triggerType := ComputeTriggerType_STATUS(temp)
		schedule.TriggerType = &triggerType
	}

	// No error
	return nil
}

// AssignProperties_From_ComputeStartStopSchedule_STATUS populates our ComputeStartStopSchedule_STATUS from the provided source ComputeStartStopSchedule_STATUS
func (schedule *ComputeStartStopSchedule_STATUS) AssignProperties_From_ComputeStartStopSchedule_STATUS(source *storage.ComputeStartStopSchedule_STATUS) error {

	// Action
	if source.Action != nil {
		action := *source.Action
		actionTemp := genruntime.ToEnum(action, computePowerAction_STATUS_Values)
		schedule.Action = &actionTemp
	} else {
		schedule.Action = nil
	}

	// Cron
	if source.Cron != nil {
		var cron Cron_STATUS
		err := cron.AssignProperties_From_Cron_STATUS(source.Cron)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Cron_STATUS() to populate field Cron")
		}
		schedule.Cron = &cron
	} else {
		schedule.Cron = nil
	}

	// Id
	schedule.Id = genruntime.ClonePointerToString(source.Id)

	// ProvisioningStatus
	if source.ProvisioningStatus != nil {
		provisioningStatus := *source.ProvisioningStatus
		provisioningStatusTemp := genruntime.ToEnum(provisioningStatus, computeStartStopSchedule_ProvisioningStatus_STATUS_Values)
		schedule.ProvisioningStatus = &provisioningStatusTemp
	} else {
		schedule.ProvisioningStatus = nil
	}

	// Recurrence
	if source.Recurrence != nil {
		var recurrence Recurrence_STATUS
		err := recurrence.AssignProperties_From_Recurrence_STATUS(source.Recurrence)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Recurrence_STATUS() to populate field Recurrence")
		}
		schedule.Recurrence = &recurrence
	} else {
		schedule.Recurrence = nil
	}

	// Schedule
	if source.Schedule != nil {
		var scheduleLocal ScheduleBase_STATUS
		err := scheduleLocal.AssignProperties_From_ScheduleBase_STATUS(source.Schedule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ScheduleBase_STATUS() to populate field Schedule")
		}
		schedule.Schedule = &scheduleLocal
	} else {
		schedule.Schedule = nil
	}

	// Status
	if source.Status != nil {
		status := *source.Status
		statusTemp := genruntime.ToEnum(status, scheduleStatus_STATUS_Values)
		schedule.Status = &statusTemp
	} else {
		schedule.Status = nil
	}

	// TriggerType
	if source.TriggerType != nil {
		triggerType := *source.TriggerType
		triggerTypeTemp := genruntime.ToEnum(triggerType, computeTriggerType_STATUS_Values)
		schedule.TriggerType = &triggerTypeTemp
	} else {
		schedule.TriggerType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ComputeStartStopSchedule_STATUS populates the provided destination ComputeStartStopSchedule_STATUS from our ComputeStartStopSchedule_STATUS
func (schedule *ComputeStartStopSchedule_STATUS) AssignProperties_To_ComputeStartStopSchedule_STATUS(destination *storage.ComputeStartStopSchedule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	if schedule.Action != nil {
		action := string(*schedule.Action)
		destination.Action = &action
	} else {
		destination.Action = nil
	}

	// Cron
	if schedule.Cron != nil {
		var cron storage.Cron_STATUS
		err := schedule.Cron.AssignProperties_To_Cron_STATUS(&cron)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Cron_STATUS() to populate field Cron")
		}
		destination.Cron = &cron
	} else {
		destination.Cron = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(schedule.Id)

	// ProvisioningStatus
	if schedule.ProvisioningStatus != nil {
		provisioningStatus := string(*schedule.ProvisioningStatus)
		destination.ProvisioningStatus = &provisioningStatus
	} else {
		destination.ProvisioningStatus = nil
	}

	// Recurrence
	if schedule.Recurrence != nil {
		var recurrence storage.Recurrence_STATUS
		err := schedule.Recurrence.AssignProperties_To_Recurrence_STATUS(&recurrence)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Recurrence_STATUS() to populate field Recurrence")
		}
		destination.Recurrence = &recurrence
	} else {
		destination.Recurrence = nil
	}

	// Schedule
	if schedule.Schedule != nil {
		var scheduleLocal storage.ScheduleBase_STATUS
		err := schedule.Schedule.AssignProperties_To_ScheduleBase_STATUS(&scheduleLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ScheduleBase_STATUS() to populate field Schedule")
		}
		destination.Schedule = &scheduleLocal
	} else {
		destination.Schedule = nil
	}

	// Status
	if schedule.Status != nil {
		status := string(*schedule.Status)
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// TriggerType
	if schedule.TriggerType != nil {
		triggerType := string(*schedule.TriggerType)
		destination.TriggerType = &triggerType
	} else {
		destination.TriggerType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Docker container configuration
type Docker struct {
	// Privileged: Indicate whether container shall run in privileged or non-privileged mode.
	Privileged *bool `json:"privileged,omitempty"`
}

var _ genruntime.ARMTransformer = &Docker{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (docker *Docker) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if docker == nil {
		return nil, nil
	}
	result := &arm.Docker{}

	// Set property "Privileged":
	if docker.Privileged != nil {
		privileged := *docker.Privileged
		result.Privileged = &privileged
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (docker *Docker) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Docker{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (docker *Docker) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Docker)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Docker, got %T", armInput)
	}

	// Set property "Privileged":
	if typedInput.Privileged != nil {
		privileged := *typedInput.Privileged
		docker.Privileged = &privileged
	}

	// No error
	return nil
}

// AssignProperties_From_Docker populates our Docker from the provided source Docker
func (docker *Docker) AssignProperties_From_Docker(source *storage.Docker) error {

	// Privileged
	if source.Privileged != nil {
		privileged := *source.Privileged
		docker.Privileged = &privileged
	} else {
		docker.Privileged = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Docker populates the provided destination Docker from our Docker
func (docker *Docker) AssignProperties_To_Docker(destination *storage.Docker) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Privileged
	if docker.Privileged != nil {
		privileged := *docker.Privileged
		destination.Privileged = &privileged
	} else {
		destination.Privileged = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Docker_STATUS populates our Docker from the provided source Docker_STATUS
func (docker *Docker) Initialize_From_Docker_STATUS(source *Docker_STATUS) error {

	// Privileged
	if source.Privileged != nil {
		privileged := *source.Privileged
		docker.Privileged = &privileged
	} else {
		docker.Privileged = nil
	}

	// No error
	return nil
}

// Docker container configuration
type Docker_STATUS struct {
	// Privileged: Indicate whether container shall run in privileged or non-privileged mode.
	Privileged *bool `json:"privileged,omitempty"`
}

var _ genruntime.FromARMConverter = &Docker_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (docker *Docker_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Docker_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (docker *Docker_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Docker_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Docker_STATUS, got %T", armInput)
	}

	// Set property "Privileged":
	if typedInput.Privileged != nil {
		privileged := *typedInput.Privileged
		docker.Privileged = &privileged
	}

	// No error
	return nil
}

// AssignProperties_From_Docker_STATUS populates our Docker_STATUS from the provided source Docker_STATUS
func (docker *Docker_STATUS) AssignProperties_From_Docker_STATUS(source *storage.Docker_STATUS) error {

	// Privileged
	if source.Privileged != nil {
		privileged := *source.Privileged
		docker.Privileged = &privileged
	} else {
		docker.Privileged = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Docker_STATUS populates the provided destination Docker_STATUS from our Docker_STATUS
func (docker *Docker_STATUS) AssignProperties_To_Docker_STATUS(destination *storage.Docker_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Privileged
	if docker.Privileged != nil {
		privileged := *docker.Privileged
		destination.Privileged = &privileged
	} else {
		destination.Privileged = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes the endpoint configuration for the container
type Endpoint struct {
	// HostIp: Host IP over which the application is exposed from the container
	HostIp *string `json:"hostIp,omitempty"`

	// Name: Name of the Endpoint
	Name *string `json:"name,omitempty"`

	// Protocol: Protocol over which communication will happen over this endpoint
	Protocol *Endpoint_Protocol `json:"protocol,omitempty"`

	// Published: Port over which the application is exposed from container.
	Published *int `json:"published,omitempty"`

	// Target: Application port inside the container.
	Target *int `json:"target,omitempty"`
}

var _ genruntime.ARMTransformer = &Endpoint{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (endpoint *Endpoint) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if endpoint == nil {
		return nil, nil
	}
	result := &arm.Endpoint{}

	// Set property "HostIp":
	if endpoint.HostIp != nil {
		hostIp := *endpoint.HostIp
		result.HostIp = &hostIp
	}

	// Set property "Name":
	if endpoint.Name != nil {
		name := *endpoint.Name
		result.Name = &name
	}

	// Set property "Protocol":
	if endpoint.Protocol != nil {
		var temp string
		temp = string(*endpoint.Protocol)
		protocol := arm.Endpoint_Protocol(temp)
		result.Protocol = &protocol
	}

	// Set property "Published":
	if endpoint.Published != nil {
		published := *endpoint.Published
		result.Published = &published
	}

	// Set property "Target":
	if endpoint.Target != nil {
		target := *endpoint.Target
		result.Target = &target
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (endpoint *Endpoint) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Endpoint{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (endpoint *Endpoint) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Endpoint)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Endpoint, got %T", armInput)
	}

	// Set property "HostIp":
	if typedInput.HostIp != nil {
		hostIp := *typedInput.HostIp
		endpoint.HostIp = &hostIp
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		endpoint.Name = &name
	}

	// Set property "Protocol":
	if typedInput.Protocol != nil {
		var temp string
		temp = string(*typedInput.Protocol)
		protocol := Endpoint_Protocol(temp)
		endpoint.Protocol = &protocol
	}

	// Set property "Published":
	if typedInput.Published != nil {
		published := *typedInput.Published
		endpoint.Published = &published
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		endpoint.Target = &target
	}

	// No error
	return nil
}

// AssignProperties_From_Endpoint populates our Endpoint from the provided source Endpoint
func (endpoint *Endpoint) AssignProperties_From_Endpoint(source *storage.Endpoint) error {

	// HostIp
	endpoint.HostIp = genruntime.ClonePointerToString(source.HostIp)

	// Name
	endpoint.Name = genruntime.ClonePointerToString(source.Name)

	// Protocol
	if source.Protocol != nil {
		protocol := *source.Protocol
		protocolTemp := genruntime.ToEnum(protocol, endpoint_Protocol_Values)
		endpoint.Protocol = &protocolTemp
	} else {
		endpoint.Protocol = nil
	}

	// Published
	endpoint.Published = genruntime.ClonePointerToInt(source.Published)

	// Target
	endpoint.Target = genruntime.ClonePointerToInt(source.Target)

	// No error
	return nil
}

// AssignProperties_To_Endpoint populates the provided destination Endpoint from our Endpoint
func (endpoint *Endpoint) AssignProperties_To_Endpoint(destination *storage.Endpoint) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HostIp
	destination.HostIp = genruntime.ClonePointerToString(endpoint.HostIp)

	// Name
	destination.Name = genruntime.ClonePointerToString(endpoint.Name)

	// Protocol
	if endpoint.Protocol != nil {
		protocol := string(*endpoint.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Published
	destination.Published = genruntime.ClonePointerToInt(endpoint.Published)

	// Target
	destination.Target = genruntime.ClonePointerToInt(endpoint.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Endpoint_STATUS populates our Endpoint from the provided source Endpoint_STATUS
func (endpoint *Endpoint) Initialize_From_Endpoint_STATUS(source *Endpoint_STATUS) error {

	// HostIp
	endpoint.HostIp = genruntime.ClonePointerToString(source.HostIp)

	// Name
	endpoint.Name = genruntime.ClonePointerToString(source.Name)

	// Protocol
	if source.Protocol != nil {
		protocol := genruntime.ToEnum(string(*source.Protocol), endpoint_Protocol_Values)
		endpoint.Protocol = &protocol
	} else {
		endpoint.Protocol = nil
	}

	// Published
	endpoint.Published = genruntime.ClonePointerToInt(source.Published)

	// Target
	endpoint.Target = genruntime.ClonePointerToInt(source.Target)

	// No error
	return nil
}

// Describes the endpoint configuration for the container
type Endpoint_STATUS struct {
	// HostIp: Host IP over which the application is exposed from the container
	HostIp *string `json:"hostIp,omitempty"`

	// Name: Name of the Endpoint
	Name *string `json:"name,omitempty"`

	// Protocol: Protocol over which communication will happen over this endpoint
	Protocol *Endpoint_Protocol_STATUS `json:"protocol,omitempty"`

	// Published: Port over which the application is exposed from container.
	Published *int `json:"published,omitempty"`

	// Target: Application port inside the container.
	Target *int `json:"target,omitempty"`
}

var _ genruntime.FromARMConverter = &Endpoint_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (endpoint *Endpoint_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Endpoint_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (endpoint *Endpoint_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Endpoint_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Endpoint_STATUS, got %T", armInput)
	}

	// Set property "HostIp":
	if typedInput.HostIp != nil {
		hostIp := *typedInput.HostIp
		endpoint.HostIp = &hostIp
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		endpoint.Name = &name
	}

	// Set property "Protocol":
	if typedInput.Protocol != nil {
		var temp string
		temp = string(*typedInput.Protocol)
		protocol := Endpoint_Protocol_STATUS(temp)
		endpoint.Protocol = &protocol
	}

	// Set property "Published":
	if typedInput.Published != nil {
		published := *typedInput.Published
		endpoint.Published = &published
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		endpoint.Target = &target
	}

	// No error
	return nil
}

// AssignProperties_From_Endpoint_STATUS populates our Endpoint_STATUS from the provided source Endpoint_STATUS
func (endpoint *Endpoint_STATUS) AssignProperties_From_Endpoint_STATUS(source *storage.Endpoint_STATUS) error {

	// HostIp
	endpoint.HostIp = genruntime.ClonePointerToString(source.HostIp)

	// Name
	endpoint.Name = genruntime.ClonePointerToString(source.Name)

	// Protocol
	if source.Protocol != nil {
		protocol := *source.Protocol
		protocolTemp := genruntime.ToEnum(protocol, endpoint_Protocol_STATUS_Values)
		endpoint.Protocol = &protocolTemp
	} else {
		endpoint.Protocol = nil
	}

	// Published
	endpoint.Published = genruntime.ClonePointerToInt(source.Published)

	// Target
	endpoint.Target = genruntime.ClonePointerToInt(source.Target)

	// No error
	return nil
}

// AssignProperties_To_Endpoint_STATUS populates the provided destination Endpoint_STATUS from our Endpoint_STATUS
func (endpoint *Endpoint_STATUS) AssignProperties_To_Endpoint_STATUS(destination *storage.Endpoint_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HostIp
	destination.HostIp = genruntime.ClonePointerToString(endpoint.HostIp)

	// Name
	destination.Name = genruntime.ClonePointerToString(endpoint.Name)

	// Protocol
	if endpoint.Protocol != nil {
		protocol := string(*endpoint.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Published
	destination.Published = genruntime.ClonePointerToInt(endpoint.Published)

	// Target
	destination.Target = genruntime.ClonePointerToInt(endpoint.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Environment Variables for the container
type EnvironmentVariable struct {
	// Type: Type of the Environment Variable. Possible values are: local - For local variable
	Type *EnvironmentVariable_Type `json:"type,omitempty"`

	// Value: Value of the Environment variable
	Value *string `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &EnvironmentVariable{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (variable *EnvironmentVariable) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if variable == nil {
		return nil, nil
	}
	result := &arm.EnvironmentVariable{}

	// Set property "Type":
	if variable.Type != nil {
		var temp string
		temp = string(*variable.Type)
		typeVar := arm.EnvironmentVariable_Type(temp)
		result.Type = &typeVar
	}

	// Set property "Value":
	if variable.Value != nil {
		value := *variable.Value
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (variable *EnvironmentVariable) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EnvironmentVariable{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (variable *EnvironmentVariable) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EnvironmentVariable)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EnvironmentVariable, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := EnvironmentVariable_Type(temp)
		variable.Type = &typeVar
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		variable.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_EnvironmentVariable populates our EnvironmentVariable from the provided source EnvironmentVariable
func (variable *EnvironmentVariable) AssignProperties_From_EnvironmentVariable(source *storage.EnvironmentVariable) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, environmentVariable_Type_Values)
		variable.Type = &typeTemp
	} else {
		variable.Type = nil
	}

	// Value
	variable.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_EnvironmentVariable populates the provided destination EnvironmentVariable from our EnvironmentVariable
func (variable *EnvironmentVariable) AssignProperties_To_EnvironmentVariable(destination *storage.EnvironmentVariable) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if variable.Type != nil {
		typeVar := string(*variable.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Value
	destination.Value = genruntime.ClonePointerToString(variable.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_EnvironmentVariable_STATUS populates our EnvironmentVariable from the provided source EnvironmentVariable_STATUS
func (variable *EnvironmentVariable) Initialize_From_EnvironmentVariable_STATUS(source *EnvironmentVariable_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := genruntime.ToEnum(string(*source.Type), environmentVariable_Type_Values)
		variable.Type = &typeVar
	} else {
		variable.Type = nil
	}

	// Value
	variable.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// Environment Variables for the container
type EnvironmentVariable_STATUS struct {
	// Type: Type of the Environment Variable. Possible values are: local - For local variable
	Type *EnvironmentVariable_Type_STATUS `json:"type,omitempty"`

	// Value: Value of the Environment variable
	Value *string `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &EnvironmentVariable_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (variable *EnvironmentVariable_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EnvironmentVariable_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (variable *EnvironmentVariable_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EnvironmentVariable_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EnvironmentVariable_STATUS, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := EnvironmentVariable_Type_STATUS(temp)
		variable.Type = &typeVar
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		variable.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_EnvironmentVariable_STATUS populates our EnvironmentVariable_STATUS from the provided source EnvironmentVariable_STATUS
func (variable *EnvironmentVariable_STATUS) AssignProperties_From_EnvironmentVariable_STATUS(source *storage.EnvironmentVariable_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, environmentVariable_Type_STATUS_Values)
		variable.Type = &typeTemp
	} else {
		variable.Type = nil
	}

	// Value
	variable.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_EnvironmentVariable_STATUS populates the provided destination EnvironmentVariable_STATUS from our EnvironmentVariable_STATUS
func (variable *EnvironmentVariable_STATUS) AssignProperties_To_EnvironmentVariable_STATUS(destination *storage.EnvironmentVariable_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if variable.Type != nil {
		typeVar := string(*variable.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Value
	destination.Value = genruntime.ClonePointerToString(variable.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The resource management error additional info.
type ErrorAdditionalInfo_STATUS struct {
	// Info: The additional info.
	Info map[string]v1.JSON `json:"info,omitempty"`

	// Type: The additional info type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &ErrorAdditionalInfo_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (info *ErrorAdditionalInfo_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ErrorAdditionalInfo_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (info *ErrorAdditionalInfo_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ErrorAdditionalInfo_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ErrorAdditionalInfo_STATUS, got %T", armInput)
	}

	// Set property "Info":
	if typedInput.Info != nil {
		info.Info = make(map[string]v1.JSON, len(typedInput.Info))
		for key, value := range typedInput.Info {
			info.Info[key] = *value.DeepCopy()
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		info.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_ErrorAdditionalInfo_STATUS populates our ErrorAdditionalInfo_STATUS from the provided source ErrorAdditionalInfo_STATUS
func (info *ErrorAdditionalInfo_STATUS) AssignProperties_From_ErrorAdditionalInfo_STATUS(source *storage.ErrorAdditionalInfo_STATUS) error {

	// Info
	if source.Info != nil {
		infoMap := make(map[string]v1.JSON, len(source.Info))
		for infoKey, infoValue := range source.Info {
			// Shadow the loop variable to avoid aliasing
			infoValue := infoValue
			infoMap[infoKey] = *infoValue.DeepCopy()
		}
		info.Info = infoMap
	} else {
		info.Info = nil
	}

	// Type
	info.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_ErrorAdditionalInfo_STATUS populates the provided destination ErrorAdditionalInfo_STATUS from our ErrorAdditionalInfo_STATUS
func (info *ErrorAdditionalInfo_STATUS) AssignProperties_To_ErrorAdditionalInfo_STATUS(destination *storage.ErrorAdditionalInfo_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Info
	if info.Info != nil {
		infoMap := make(map[string]v1.JSON, len(info.Info))
		for infoKey, infoValue := range info.Info {
			// Shadow the loop variable to avoid aliasing
			infoValue := infoValue
			infoMap[infoKey] = *infoValue.DeepCopy()
		}
		destination.Info = infoMap
	} else {
		destination.Info = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(info.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ErrorDetail_STATUS_Unrolled struct {
	// AdditionalInfo: The error additional info.
	AdditionalInfo []ErrorAdditionalInfo_STATUS `json:"additionalInfo,omitempty"`

	// Code: The error code.
	Code *string `json:"code,omitempty"`

	// Message: The error message.
	Message *string `json:"message,omitempty"`

	// Target: The error target.
	Target *string `json:"target,omitempty"`
}

var _ genruntime.FromARMConverter = &ErrorDetail_STATUS_Unrolled{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (unrolled *ErrorDetail_STATUS_Unrolled) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ErrorDetail_STATUS_Unrolled{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (unrolled *ErrorDetail_STATUS_Unrolled) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ErrorDetail_STATUS_Unrolled)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ErrorDetail_STATUS_Unrolled, got %T", armInput)
	}

	// Set property "AdditionalInfo":
	for _, item := range typedInput.AdditionalInfo {
		var item1 ErrorAdditionalInfo_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		unrolled.AdditionalInfo = append(unrolled.AdditionalInfo, item1)
	}

	// Set property "Code":
	if typedInput.Code != nil {
		code := *typedInput.Code
		unrolled.Code = &code
	}

	// Set property "Message":
	if typedInput.Message != nil {
		message := *typedInput.Message
		unrolled.Message = &message
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		unrolled.Target = &target
	}

	// No error
	return nil
}

// AssignProperties_From_ErrorDetail_STATUS_Unrolled populates our ErrorDetail_STATUS_Unrolled from the provided source ErrorDetail_STATUS_Unrolled
func (unrolled *ErrorDetail_STATUS_Unrolled) AssignProperties_From_ErrorDetail_STATUS_Unrolled(source *storage.ErrorDetail_STATUS_Unrolled) error {

	// AdditionalInfo
	if source.AdditionalInfo != nil {
		additionalInfoList := make([]ErrorAdditionalInfo_STATUS, len(source.AdditionalInfo))
		for additionalInfoIndex, additionalInfoItem := range source.AdditionalInfo {
			// Shadow the loop variable to avoid aliasing
			additionalInfoItem := additionalInfoItem
			var additionalInfo ErrorAdditionalInfo_STATUS
			err := additionalInfo.AssignProperties_From_ErrorAdditionalInfo_STATUS(&additionalInfoItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ErrorAdditionalInfo_STATUS() to populate field AdditionalInfo")
			}
			additionalInfoList[additionalInfoIndex] = additionalInfo
		}
		unrolled.AdditionalInfo = additionalInfoList
	} else {
		unrolled.AdditionalInfo = nil
	}

	// Code
	unrolled.Code = genruntime.ClonePointerToString(source.Code)

	// Message
	unrolled.Message = genruntime.ClonePointerToString(source.Message)

	// Target
	unrolled.Target = genruntime.ClonePointerToString(source.Target)

	// No error
	return nil
}

// AssignProperties_To_ErrorDetail_STATUS_Unrolled populates the provided destination ErrorDetail_STATUS_Unrolled from our ErrorDetail_STATUS_Unrolled
func (unrolled *ErrorDetail_STATUS_Unrolled) AssignProperties_To_ErrorDetail_STATUS_Unrolled(destination *storage.ErrorDetail_STATUS_Unrolled) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalInfo
	if unrolled.AdditionalInfo != nil {
		additionalInfoList := make([]storage.ErrorAdditionalInfo_STATUS, len(unrolled.AdditionalInfo))
		for additionalInfoIndex, additionalInfoItem := range unrolled.AdditionalInfo {
			// Shadow the loop variable to avoid aliasing
			additionalInfoItem := additionalInfoItem
			var additionalInfo storage.ErrorAdditionalInfo_STATUS
			err := additionalInfoItem.AssignProperties_To_ErrorAdditionalInfo_STATUS(&additionalInfo)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ErrorAdditionalInfo_STATUS() to populate field AdditionalInfo")
			}
			additionalInfoList[additionalInfoIndex] = additionalInfo
		}
		destination.AdditionalInfo = additionalInfoList
	} else {
		destination.AdditionalInfo = nil
	}

	// Code
	destination.Code = genruntime.ClonePointerToString(unrolled.Code)

	// Message
	destination.Message = genruntime.ClonePointerToString(unrolled.Message)

	// Target
	destination.Target = genruntime.ClonePointerToString(unrolled.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes the Image Specifications
type Image struct {
	// Reference: Image reference
	Reference *string `json:"reference,omitempty"`

	// Type: Type of the image. Possible values are: docker - For docker images. azureml - For AzureML images
	Type *Image_Type `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &Image{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (image *Image) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if image == nil {
		return nil, nil
	}
	result := &arm.Image{}

	// Set property "Reference":
	if image.Reference != nil {
		reference := *image.Reference
		result.Reference = &reference
	}

	// Set property "Type":
	if image.Type != nil {
		var temp string
		temp = string(*image.Type)
		typeVar := arm.Image_Type(temp)
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (image *Image) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Image{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (image *Image) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Image)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Image, got %T", armInput)
	}

	// Set property "Reference":
	if typedInput.Reference != nil {
		reference := *typedInput.Reference
		image.Reference = &reference
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := Image_Type(temp)
		image.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_Image populates our Image from the provided source Image
func (image *Image) AssignProperties_From_Image(source *storage.Image) error {

	// Reference
	image.Reference = genruntime.ClonePointerToString(source.Reference)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, image_Type_Values)
		image.Type = &typeTemp
	} else {
		image.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Image populates the provided destination Image from our Image
func (image *Image) AssignProperties_To_Image(destination *storage.Image) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	destination.Reference = genruntime.ClonePointerToString(image.Reference)

	// Type
	if image.Type != nil {
		typeVar := string(*image.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Image_STATUS populates our Image from the provided source Image_STATUS
func (image *Image) Initialize_From_Image_STATUS(source *Image_STATUS) error {

	// Reference
	image.Reference = genruntime.ClonePointerToString(source.Reference)

	// Type
	if source.Type != nil {
		typeVar := genruntime.ToEnum(string(*source.Type), image_Type_Values)
		image.Type = &typeVar
	} else {
		image.Type = nil
	}

	// No error
	return nil
}

// Describes the Image Specifications
type Image_STATUS struct {
	// Reference: Image reference
	Reference *string `json:"reference,omitempty"`

	// Type: Type of the image. Possible values are: docker - For docker images. azureml - For AzureML images
	Type *Image_Type_STATUS `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &Image_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (image *Image_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Image_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (image *Image_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Image_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Image_STATUS, got %T", armInput)
	}

	// Set property "Reference":
	if typedInput.Reference != nil {
		reference := *typedInput.Reference
		image.Reference = &reference
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := Image_Type_STATUS(temp)
		image.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_Image_STATUS populates our Image_STATUS from the provided source Image_STATUS
func (image *Image_STATUS) AssignProperties_From_Image_STATUS(source *storage.Image_STATUS) error {

	// Reference
	image.Reference = genruntime.ClonePointerToString(source.Reference)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, image_Type_STATUS_Values)
		image.Type = &typeTemp
	} else {
		image.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Image_STATUS populates the provided destination Image_STATUS from our Image_STATUS
func (image *Image_STATUS) AssignProperties_To_Image_STATUS(destination *storage.Image_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	destination.Reference = genruntime.ClonePointerToString(image.Reference)

	// Type
	if image.Type != nil {
		typeVar := string(*image.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type InstanceTypeSchema_Resources struct {
	// Limits: Resource limits for this instance type
	Limits map[string]string `json:"limits,omitempty"`

	// Requests: Resource requests for this instance type
	Requests map[string]string `json:"requests,omitempty"`
}

var _ genruntime.ARMTransformer = &InstanceTypeSchema_Resources{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (resources *InstanceTypeSchema_Resources) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if resources == nil {
		return nil, nil
	}
	result := &arm.InstanceTypeSchema_Resources{}

	// Set property "Limits":
	if resources.Limits != nil {
		result.Limits = make(map[string]string, len(resources.Limits))
		for key, value := range resources.Limits {
			result.Limits[key] = value
		}
	}

	// Set property "Requests":
	if resources.Requests != nil {
		result.Requests = make(map[string]string, len(resources.Requests))
		for key, value := range resources.Requests {
			result.Requests[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resources *InstanceTypeSchema_Resources) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.InstanceTypeSchema_Resources{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resources *InstanceTypeSchema_Resources) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.InstanceTypeSchema_Resources)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.InstanceTypeSchema_Resources, got %T", armInput)
	}

	// Set property "Limits":
	if typedInput.Limits != nil {
		resources.Limits = make(map[string]string, len(typedInput.Limits))
		for key, value := range typedInput.Limits {
			resources.Limits[key] = value
		}
	}

	// Set property "Requests":
	if typedInput.Requests != nil {
		resources.Requests = make(map[string]string, len(typedInput.Requests))
		for key, value := range typedInput.Requests {
			resources.Requests[key] = value
		}
	}

	// No error
	return nil
}

// AssignProperties_From_InstanceTypeSchema_Resources populates our InstanceTypeSchema_Resources from the provided source InstanceTypeSchema_Resources
func (resources *InstanceTypeSchema_Resources) AssignProperties_From_InstanceTypeSchema_Resources(source *storage.InstanceTypeSchema_Resources) error {

	// Limits
	resources.Limits = genruntime.CloneMapOfStringToString(source.Limits)

	// Requests
	resources.Requests = genruntime.CloneMapOfStringToString(source.Requests)

	// No error
	return nil
}

// AssignProperties_To_InstanceTypeSchema_Resources populates the provided destination InstanceTypeSchema_Resources from our InstanceTypeSchema_Resources
func (resources *InstanceTypeSchema_Resources) AssignProperties_To_InstanceTypeSchema_Resources(destination *storage.InstanceTypeSchema_Resources) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Limits
	destination.Limits = genruntime.CloneMapOfStringToString(resources.Limits)

	// Requests
	destination.Requests = genruntime.CloneMapOfStringToString(resources.Requests)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_InstanceTypeSchema_Resources_STATUS populates our InstanceTypeSchema_Resources from the provided source InstanceTypeSchema_Resources_STATUS
func (resources *InstanceTypeSchema_Resources) Initialize_From_InstanceTypeSchema_Resources_STATUS(source *InstanceTypeSchema_Resources_STATUS) error {

	// Limits
	resources.Limits = genruntime.CloneMapOfStringToString(source.Limits)

	// Requests
	resources.Requests = genruntime.CloneMapOfStringToString(source.Requests)

	// No error
	return nil
}

type InstanceTypeSchema_Resources_STATUS struct {
	// Limits: Resource limits for this instance type
	Limits map[string]string `json:"limits,omitempty"`

	// Requests: Resource requests for this instance type
	Requests map[string]string `json:"requests,omitempty"`
}

var _ genruntime.FromARMConverter = &InstanceTypeSchema_Resources_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resources *InstanceTypeSchema_Resources_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.InstanceTypeSchema_Resources_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resources *InstanceTypeSchema_Resources_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.InstanceTypeSchema_Resources_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.InstanceTypeSchema_Resources_STATUS, got %T", armInput)
	}

	// Set property "Limits":
	if typedInput.Limits != nil {
		resources.Limits = make(map[string]string, len(typedInput.Limits))
		for key, value := range typedInput.Limits {
			resources.Limits[key] = value
		}
	}

	// Set property "Requests":
	if typedInput.Requests != nil {
		resources.Requests = make(map[string]string, len(typedInput.Requests))
		for key, value := range typedInput.Requests {
			resources.Requests[key] = value
		}
	}

	// No error
	return nil
}

// AssignProperties_From_InstanceTypeSchema_Resources_STATUS populates our InstanceTypeSchema_Resources_STATUS from the provided source InstanceTypeSchema_Resources_STATUS
func (resources *InstanceTypeSchema_Resources_STATUS) AssignProperties_From_InstanceTypeSchema_Resources_STATUS(source *storage.InstanceTypeSchema_Resources_STATUS) error {

	// Limits
	resources.Limits = genruntime.CloneMapOfStringToString(source.Limits)

	// Requests
	resources.Requests = genruntime.CloneMapOfStringToString(source.Requests)

	// No error
	return nil
}

// AssignProperties_To_InstanceTypeSchema_Resources_STATUS populates the provided destination InstanceTypeSchema_Resources_STATUS from our InstanceTypeSchema_Resources_STATUS
func (resources *InstanceTypeSchema_Resources_STATUS) AssignProperties_To_InstanceTypeSchema_Resources_STATUS(destination *storage.InstanceTypeSchema_Resources_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Limits
	destination.Limits = genruntime.CloneMapOfStringToString(resources.Limits)

	// Requests
	destination.Requests = genruntime.CloneMapOfStringToString(resources.Requests)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Customized setup scripts
type ScriptsToExecute struct {
	// CreationScript: Script that's run only once during provision of the compute.
	CreationScript *ScriptReference `json:"creationScript,omitempty"`

	// StartupScript: Script that's run every time the machine starts.
	StartupScript *ScriptReference `json:"startupScript,omitempty"`
}

var _ genruntime.ARMTransformer = &ScriptsToExecute{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (execute *ScriptsToExecute) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if execute == nil {
		return nil, nil
	}
	result := &arm.ScriptsToExecute{}

	// Set property "CreationScript":
	if execute.CreationScript != nil {
		creationScript_ARM, err := (*execute.CreationScript).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		creationScript := *creationScript_ARM.(*arm.ScriptReference)
		result.CreationScript = &creationScript
	}

	// Set property "StartupScript":
	if execute.StartupScript != nil {
		startupScript_ARM, err := (*execute.StartupScript).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		startupScript := *startupScript_ARM.(*arm.ScriptReference)
		result.StartupScript = &startupScript
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (execute *ScriptsToExecute) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ScriptsToExecute{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (execute *ScriptsToExecute) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ScriptsToExecute)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ScriptsToExecute, got %T", armInput)
	}

	// Set property "CreationScript":
	if typedInput.CreationScript != nil {
		var creationScript1 ScriptReference
		err := creationScript1.PopulateFromARM(owner, *typedInput.CreationScript)
		if err != nil {
			return err
		}
		creationScript := creationScript1
		execute.CreationScript = &creationScript
	}

	// Set property "StartupScript":
	if typedInput.StartupScript != nil {
		var startupScript1 ScriptReference
		err := startupScript1.PopulateFromARM(owner, *typedInput.StartupScript)
		if err != nil {
			return err
		}
		startupScript := startupScript1
		execute.StartupScript = &startupScript
	}

	// No error
	return nil
}

// AssignProperties_From_ScriptsToExecute populates our ScriptsToExecute from the provided source ScriptsToExecute
func (execute *ScriptsToExecute) AssignProperties_From_ScriptsToExecute(source *storage.ScriptsToExecute) error {

	// CreationScript
	if source.CreationScript != nil {
		var creationScript ScriptReference
		err := creationScript.AssignProperties_From_ScriptReference(source.CreationScript)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ScriptReference() to populate field CreationScript")
		}
		execute.CreationScript = &creationScript
	} else {
		execute.CreationScript = nil
	}

	// StartupScript
	if source.StartupScript != nil {
		var startupScript ScriptReference
		err := startupScript.AssignProperties_From_ScriptReference(source.StartupScript)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ScriptReference() to populate field StartupScript")
		}
		execute.StartupScript = &startupScript
	} else {
		execute.StartupScript = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ScriptsToExecute populates the provided destination ScriptsToExecute from our ScriptsToExecute
func (execute *ScriptsToExecute) AssignProperties_To_ScriptsToExecute(destination *storage.ScriptsToExecute) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CreationScript
	if execute.CreationScript != nil {
		var creationScript storage.ScriptReference
		err := execute.CreationScript.AssignProperties_To_ScriptReference(&creationScript)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ScriptReference() to populate field CreationScript")
		}
		destination.CreationScript = &creationScript
	} else {
		destination.CreationScript = nil
	}

	// StartupScript
	if execute.StartupScript != nil {
		var startupScript storage.ScriptReference
		err := execute.StartupScript.AssignProperties_To_ScriptReference(&startupScript)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ScriptReference() to populate field StartupScript")
		}
		destination.StartupScript = &startupScript
	} else {
		destination.StartupScript = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ScriptsToExecute_STATUS populates our ScriptsToExecute from the provided source ScriptsToExecute_STATUS
func (execute *ScriptsToExecute) Initialize_From_ScriptsToExecute_STATUS(source *ScriptsToExecute_STATUS) error {

	// CreationScript
	if source.CreationScript != nil {
		var creationScript ScriptReference
		err := creationScript.Initialize_From_ScriptReference_STATUS(source.CreationScript)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ScriptReference_STATUS() to populate field CreationScript")
		}
		execute.CreationScript = &creationScript
	} else {
		execute.CreationScript = nil
	}

	// StartupScript
	if source.StartupScript != nil {
		var startupScript ScriptReference
		err := startupScript.Initialize_From_ScriptReference_STATUS(source.StartupScript)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ScriptReference_STATUS() to populate field StartupScript")
		}
		execute.StartupScript = &startupScript
	} else {
		execute.StartupScript = nil
	}

	// No error
	return nil
}

// Customized setup scripts
type ScriptsToExecute_STATUS struct {
	// CreationScript: Script that's run only once during provision of the compute.
	CreationScript *ScriptReference_STATUS `json:"creationScript,omitempty"`

	// StartupScript: Script that's run every time the machine starts.
	StartupScript *ScriptReference_STATUS `json:"startupScript,omitempty"`
}

var _ genruntime.FromARMConverter = &ScriptsToExecute_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (execute *ScriptsToExecute_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ScriptsToExecute_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (execute *ScriptsToExecute_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ScriptsToExecute_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ScriptsToExecute_STATUS, got %T", armInput)
	}

	// Set property "CreationScript":
	if typedInput.CreationScript != nil {
		var creationScript1 ScriptReference_STATUS
		err := creationScript1.PopulateFromARM(owner, *typedInput.CreationScript)
		if err != nil {
			return err
		}
		creationScript := creationScript1
		execute.CreationScript = &creationScript
	}

	// Set property "StartupScript":
	if typedInput.StartupScript != nil {
		var startupScript1 ScriptReference_STATUS
		err := startupScript1.PopulateFromARM(owner, *typedInput.StartupScript)
		if err != nil {
			return err
		}
		startupScript := startupScript1
		execute.StartupScript = &startupScript
	}

	// No error
	return nil
}

// AssignProperties_From_ScriptsToExecute_STATUS populates our ScriptsToExecute_STATUS from the provided source ScriptsToExecute_STATUS
func (execute *ScriptsToExecute_STATUS) AssignProperties_From_ScriptsToExecute_STATUS(source *storage.ScriptsToExecute_STATUS) error {

	// CreationScript
	if source.CreationScript != nil {
		var creationScript ScriptReference_STATUS
		err := creationScript.AssignProperties_From_ScriptReference_STATUS(source.CreationScript)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ScriptReference_STATUS() to populate field CreationScript")
		}
		execute.CreationScript = &creationScript
	} else {
		execute.CreationScript = nil
	}

	// StartupScript
	if source.StartupScript != nil {
		var startupScript ScriptReference_STATUS
		err := startupScript.AssignProperties_From_ScriptReference_STATUS(source.StartupScript)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ScriptReference_STATUS() to populate field StartupScript")
		}
		execute.StartupScript = &startupScript
	} else {
		execute.StartupScript = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ScriptsToExecute_STATUS populates the provided destination ScriptsToExecute_STATUS from our ScriptsToExecute_STATUS
func (execute *ScriptsToExecute_STATUS) AssignProperties_To_ScriptsToExecute_STATUS(destination *storage.ScriptsToExecute_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CreationScript
	if execute.CreationScript != nil {
		var creationScript storage.ScriptReference_STATUS
		err := execute.CreationScript.AssignProperties_To_ScriptReference_STATUS(&creationScript)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ScriptReference_STATUS() to populate field CreationScript")
		}
		destination.CreationScript = &creationScript
	} else {
		destination.CreationScript = nil
	}

	// StartupScript
	if execute.StartupScript != nil {
		var startupScript storage.ScriptReference_STATUS
		err := execute.StartupScript.AssignProperties_To_ScriptReference_STATUS(&startupScript)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ScriptReference_STATUS() to populate field StartupScript")
		}
		destination.StartupScript = &startupScript
	} else {
		destination.StartupScript = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Auto","Disabled","Enabled"}
type SslConfiguration_Status string

const (
	SslConfiguration_Status_Auto     = SslConfiguration_Status("Auto")
	SslConfiguration_Status_Disabled = SslConfiguration_Status("Disabled")
	SslConfiguration_Status_Enabled  = SslConfiguration_Status("Enabled")
)

// Mapping from string to SslConfiguration_Status
var sslConfiguration_Status_Values = map[string]SslConfiguration_Status{
	"auto":     SslConfiguration_Status_Auto,
	"disabled": SslConfiguration_Status_Disabled,
	"enabled":  SslConfiguration_Status_Enabled,
}

type SslConfiguration_Status_STATUS string

const (
	SslConfiguration_Status_STATUS_Auto     = SslConfiguration_Status_STATUS("Auto")
	SslConfiguration_Status_STATUS_Disabled = SslConfiguration_Status_STATUS("Disabled")
	SslConfiguration_Status_STATUS_Enabled  = SslConfiguration_Status_STATUS("Enabled")
)

// Mapping from string to SslConfiguration_Status_STATUS
var sslConfiguration_Status_STATUS_Values = map[string]SslConfiguration_Status_STATUS{
	"auto":     SslConfiguration_Status_STATUS_Auto,
	"disabled": SslConfiguration_Status_STATUS_Disabled,
	"enabled":  SslConfiguration_Status_STATUS_Enabled,
}

// Describes the volume configuration for the container
type VolumeDefinition struct {
	// Bind: Bind Options of the mount
	Bind *BindOptions `json:"bind,omitempty"`

	// Consistency: Consistency of the volume
	Consistency *string `json:"consistency,omitempty"`

	// ReadOnly: Indicate whether to mount volume as readOnly. Default value for this is false.
	ReadOnly *bool `json:"readOnly,omitempty"`

	// Source: Source of the mount. For bind mounts this is the host path.
	Source *string `json:"source,omitempty"`

	// Target: Target of the mount. For bind mounts this is the path in the container.
	Target *string `json:"target,omitempty"`

	// Tmpfs: tmpfs option of the mount
	Tmpfs *TmpfsOptions `json:"tmpfs,omitempty"`

	// Type: Type of Volume Definition. Possible Values: bind,volume,tmpfs,npipe
	Type *VolumeDefinition_Type `json:"type,omitempty"`

	// Volume: Volume Options of the mount
	Volume *VolumeOptions `json:"volume,omitempty"`
}

var _ genruntime.ARMTransformer = &VolumeDefinition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (definition *VolumeDefinition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if definition == nil {
		return nil, nil
	}
	result := &arm.VolumeDefinition{}

	// Set property "Bind":
	if definition.Bind != nil {
		bind_ARM, err := (*definition.Bind).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		bind := *bind_ARM.(*arm.BindOptions)
		result.Bind = &bind
	}

	// Set property "Consistency":
	if definition.Consistency != nil {
		consistency := *definition.Consistency
		result.Consistency = &consistency
	}

	// Set property "ReadOnly":
	if definition.ReadOnly != nil {
		readOnly := *definition.ReadOnly
		result.ReadOnly = &readOnly
	}

	// Set property "Source":
	if definition.Source != nil {
		source := *definition.Source
		result.Source = &source
	}

	// Set property "Target":
	if definition.Target != nil {
		target := *definition.Target
		result.Target = &target
	}

	// Set property "Tmpfs":
	if definition.Tmpfs != nil {
		tmpfs_ARM, err := (*definition.Tmpfs).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		tmpfs := *tmpfs_ARM.(*arm.TmpfsOptions)
		result.Tmpfs = &tmpfs
	}

	// Set property "Type":
	if definition.Type != nil {
		var temp string
		temp = string(*definition.Type)
		typeVar := arm.VolumeDefinition_Type(temp)
		result.Type = &typeVar
	}

	// Set property "Volume":
	if definition.Volume != nil {
		volume_ARM, err := (*definition.Volume).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		volume := *volume_ARM.(*arm.VolumeOptions)
		result.Volume = &volume
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *VolumeDefinition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VolumeDefinition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *VolumeDefinition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VolumeDefinition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VolumeDefinition, got %T", armInput)
	}

	// Set property "Bind":
	if typedInput.Bind != nil {
		var bind1 BindOptions
		err := bind1.PopulateFromARM(owner, *typedInput.Bind)
		if err != nil {
			return err
		}
		bind := bind1
		definition.Bind = &bind
	}

	// Set property "Consistency":
	if typedInput.Consistency != nil {
		consistency := *typedInput.Consistency
		definition.Consistency = &consistency
	}

	// Set property "ReadOnly":
	if typedInput.ReadOnly != nil {
		readOnly := *typedInput.ReadOnly
		definition.ReadOnly = &readOnly
	}

	// Set property "Source":
	if typedInput.Source != nil {
		source := *typedInput.Source
		definition.Source = &source
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		definition.Target = &target
	}

	// Set property "Tmpfs":
	if typedInput.Tmpfs != nil {
		var tmpfs1 TmpfsOptions
		err := tmpfs1.PopulateFromARM(owner, *typedInput.Tmpfs)
		if err != nil {
			return err
		}
		tmpfs := tmpfs1
		definition.Tmpfs = &tmpfs
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := VolumeDefinition_Type(temp)
		definition.Type = &typeVar
	}

	// Set property "Volume":
	if typedInput.Volume != nil {
		var volume1 VolumeOptions
		err := volume1.PopulateFromARM(owner, *typedInput.Volume)
		if err != nil {
			return err
		}
		volume := volume1
		definition.Volume = &volume
	}

	// No error
	return nil
}

// AssignProperties_From_VolumeDefinition populates our VolumeDefinition from the provided source VolumeDefinition
func (definition *VolumeDefinition) AssignProperties_From_VolumeDefinition(source *storage.VolumeDefinition) error {

	// Bind
	if source.Bind != nil {
		var bind BindOptions
		err := bind.AssignProperties_From_BindOptions(source.Bind)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BindOptions() to populate field Bind")
		}
		definition.Bind = &bind
	} else {
		definition.Bind = nil
	}

	// Consistency
	definition.Consistency = genruntime.ClonePointerToString(source.Consistency)

	// ReadOnly
	if source.ReadOnly != nil {
		readOnly := *source.ReadOnly
		definition.ReadOnly = &readOnly
	} else {
		definition.ReadOnly = nil
	}

	// Source
	definition.Source = genruntime.ClonePointerToString(source.Source)

	// Target
	definition.Target = genruntime.ClonePointerToString(source.Target)

	// Tmpfs
	if source.Tmpfs != nil {
		var tmpf TmpfsOptions
		err := tmpf.AssignProperties_From_TmpfsOptions(source.Tmpfs)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_TmpfsOptions() to populate field Tmpfs")
		}
		definition.Tmpfs = &tmpf
	} else {
		definition.Tmpfs = nil
	}

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, volumeDefinition_Type_Values)
		definition.Type = &typeTemp
	} else {
		definition.Type = nil
	}

	// Volume
	if source.Volume != nil {
		var volume VolumeOptions
		err := volume.AssignProperties_From_VolumeOptions(source.Volume)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VolumeOptions() to populate field Volume")
		}
		definition.Volume = &volume
	} else {
		definition.Volume = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VolumeDefinition populates the provided destination VolumeDefinition from our VolumeDefinition
func (definition *VolumeDefinition) AssignProperties_To_VolumeDefinition(destination *storage.VolumeDefinition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Bind
	if definition.Bind != nil {
		var bind storage.BindOptions
		err := definition.Bind.AssignProperties_To_BindOptions(&bind)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BindOptions() to populate field Bind")
		}
		destination.Bind = &bind
	} else {
		destination.Bind = nil
	}

	// Consistency
	destination.Consistency = genruntime.ClonePointerToString(definition.Consistency)

	// ReadOnly
	if definition.ReadOnly != nil {
		readOnly := *definition.ReadOnly
		destination.ReadOnly = &readOnly
	} else {
		destination.ReadOnly = nil
	}

	// Source
	destination.Source = genruntime.ClonePointerToString(definition.Source)

	// Target
	destination.Target = genruntime.ClonePointerToString(definition.Target)

	// Tmpfs
	if definition.Tmpfs != nil {
		var tmpf storage.TmpfsOptions
		err := definition.Tmpfs.AssignProperties_To_TmpfsOptions(&tmpf)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_TmpfsOptions() to populate field Tmpfs")
		}
		destination.Tmpfs = &tmpf
	} else {
		destination.Tmpfs = nil
	}

	// Type
	if definition.Type != nil {
		typeVar := string(*definition.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Volume
	if definition.Volume != nil {
		var volume storage.VolumeOptions
		err := definition.Volume.AssignProperties_To_VolumeOptions(&volume)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VolumeOptions() to populate field Volume")
		}
		destination.Volume = &volume
	} else {
		destination.Volume = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VolumeDefinition_STATUS populates our VolumeDefinition from the provided source VolumeDefinition_STATUS
func (definition *VolumeDefinition) Initialize_From_VolumeDefinition_STATUS(source *VolumeDefinition_STATUS) error {

	// Bind
	if source.Bind != nil {
		var bind BindOptions
		err := bind.Initialize_From_BindOptions_STATUS(source.Bind)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_BindOptions_STATUS() to populate field Bind")
		}
		definition.Bind = &bind
	} else {
		definition.Bind = nil
	}

	// Consistency
	definition.Consistency = genruntime.ClonePointerToString(source.Consistency)

	// ReadOnly
	if source.ReadOnly != nil {
		readOnly := *source.ReadOnly
		definition.ReadOnly = &readOnly
	} else {
		definition.ReadOnly = nil
	}

	// Source
	definition.Source = genruntime.ClonePointerToString(source.Source)

	// Target
	definition.Target = genruntime.ClonePointerToString(source.Target)

	// Tmpfs
	if source.Tmpfs != nil {
		var tmpf TmpfsOptions
		err := tmpf.Initialize_From_TmpfsOptions_STATUS(source.Tmpfs)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_TmpfsOptions_STATUS() to populate field Tmpfs")
		}
		definition.Tmpfs = &tmpf
	} else {
		definition.Tmpfs = nil
	}

	// Type
	if source.Type != nil {
		typeVar := genruntime.ToEnum(string(*source.Type), volumeDefinition_Type_Values)
		definition.Type = &typeVar
	} else {
		definition.Type = nil
	}

	// Volume
	if source.Volume != nil {
		var volume VolumeOptions
		err := volume.Initialize_From_VolumeOptions_STATUS(source.Volume)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_VolumeOptions_STATUS() to populate field Volume")
		}
		definition.Volume = &volume
	} else {
		definition.Volume = nil
	}

	// No error
	return nil
}

// Describes the volume configuration for the container
type VolumeDefinition_STATUS struct {
	// Bind: Bind Options of the mount
	Bind *BindOptions_STATUS `json:"bind,omitempty"`

	// Consistency: Consistency of the volume
	Consistency *string `json:"consistency,omitempty"`

	// ReadOnly: Indicate whether to mount volume as readOnly. Default value for this is false.
	ReadOnly *bool `json:"readOnly,omitempty"`

	// Source: Source of the mount. For bind mounts this is the host path.
	Source *string `json:"source,omitempty"`

	// Target: Target of the mount. For bind mounts this is the path in the container.
	Target *string `json:"target,omitempty"`

	// Tmpfs: tmpfs option of the mount
	Tmpfs *TmpfsOptions_STATUS `json:"tmpfs,omitempty"`

	// Type: Type of Volume Definition. Possible Values: bind,volume,tmpfs,npipe
	Type *VolumeDefinition_Type_STATUS `json:"type,omitempty"`

	// Volume: Volume Options of the mount
	Volume *VolumeOptions_STATUS `json:"volume,omitempty"`
}

var _ genruntime.FromARMConverter = &VolumeDefinition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *VolumeDefinition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VolumeDefinition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *VolumeDefinition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VolumeDefinition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VolumeDefinition_STATUS, got %T", armInput)
	}

	// Set property "Bind":
	if typedInput.Bind != nil {
		var bind1 BindOptions_STATUS
		err := bind1.PopulateFromARM(owner, *typedInput.Bind)
		if err != nil {
			return err
		}
		bind := bind1
		definition.Bind = &bind
	}

	// Set property "Consistency":
	if typedInput.Consistency != nil {
		consistency := *typedInput.Consistency
		definition.Consistency = &consistency
	}

	// Set property "ReadOnly":
	if typedInput.ReadOnly != nil {
		readOnly := *typedInput.ReadOnly
		definition.ReadOnly = &readOnly
	}

	// Set property "Source":
	if typedInput.Source != nil {
		source := *typedInput.Source
		definition.Source = &source
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		definition.Target = &target
	}

	// Set property "Tmpfs":
	if typedInput.Tmpfs != nil {
		var tmpfs1 TmpfsOptions_STATUS
		err := tmpfs1.PopulateFromARM(owner, *typedInput.Tmpfs)
		if err != nil {
			return err
		}
		tmpfs := tmpfs1
		definition.Tmpfs = &tmpfs
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := VolumeDefinition_Type_STATUS(temp)
		definition.Type = &typeVar
	}

	// Set property "Volume":
	if typedInput.Volume != nil {
		var volume1 VolumeOptions_STATUS
		err := volume1.PopulateFromARM(owner, *typedInput.Volume)
		if err != nil {
			return err
		}
		volume := volume1
		definition.Volume = &volume
	}

	// No error
	return nil
}

// AssignProperties_From_VolumeDefinition_STATUS populates our VolumeDefinition_STATUS from the provided source VolumeDefinition_STATUS
func (definition *VolumeDefinition_STATUS) AssignProperties_From_VolumeDefinition_STATUS(source *storage.VolumeDefinition_STATUS) error {

	// Bind
	if source.Bind != nil {
		var bind BindOptions_STATUS
		err := bind.AssignProperties_From_BindOptions_STATUS(source.Bind)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BindOptions_STATUS() to populate field Bind")
		}
		definition.Bind = &bind
	} else {
		definition.Bind = nil
	}

	// Consistency
	definition.Consistency = genruntime.ClonePointerToString(source.Consistency)

	// ReadOnly
	if source.ReadOnly != nil {
		readOnly := *source.ReadOnly
		definition.ReadOnly = &readOnly
	} else {
		definition.ReadOnly = nil
	}

	// Source
	definition.Source = genruntime.ClonePointerToString(source.Source)

	// Target
	definition.Target = genruntime.ClonePointerToString(source.Target)

	// Tmpfs
	if source.Tmpfs != nil {
		var tmpf TmpfsOptions_STATUS
		err := tmpf.AssignProperties_From_TmpfsOptions_STATUS(source.Tmpfs)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_TmpfsOptions_STATUS() to populate field Tmpfs")
		}
		definition.Tmpfs = &tmpf
	} else {
		definition.Tmpfs = nil
	}

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, volumeDefinition_Type_STATUS_Values)
		definition.Type = &typeTemp
	} else {
		definition.Type = nil
	}

	// Volume
	if source.Volume != nil {
		var volume VolumeOptions_STATUS
		err := volume.AssignProperties_From_VolumeOptions_STATUS(source.Volume)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VolumeOptions_STATUS() to populate field Volume")
		}
		definition.Volume = &volume
	} else {
		definition.Volume = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VolumeDefinition_STATUS populates the provided destination VolumeDefinition_STATUS from our VolumeDefinition_STATUS
func (definition *VolumeDefinition_STATUS) AssignProperties_To_VolumeDefinition_STATUS(destination *storage.VolumeDefinition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Bind
	if definition.Bind != nil {
		var bind storage.BindOptions_STATUS
		err := definition.Bind.AssignProperties_To_BindOptions_STATUS(&bind)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BindOptions_STATUS() to populate field Bind")
		}
		destination.Bind = &bind
	} else {
		destination.Bind = nil
	}

	// Consistency
	destination.Consistency = genruntime.ClonePointerToString(definition.Consistency)

	// ReadOnly
	if definition.ReadOnly != nil {
		readOnly := *definition.ReadOnly
		destination.ReadOnly = &readOnly
	} else {
		destination.ReadOnly = nil
	}

	// Source
	destination.Source = genruntime.ClonePointerToString(definition.Source)

	// Target
	destination.Target = genruntime.ClonePointerToString(definition.Target)

	// Tmpfs
	if definition.Tmpfs != nil {
		var tmpf storage.TmpfsOptions_STATUS
		err := definition.Tmpfs.AssignProperties_To_TmpfsOptions_STATUS(&tmpf)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_TmpfsOptions_STATUS() to populate field Tmpfs")
		}
		destination.Tmpfs = &tmpf
	} else {
		destination.Tmpfs = nil
	}

	// Type
	if definition.Type != nil {
		typeVar := string(*definition.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Volume
	if definition.Volume != nil {
		var volume storage.VolumeOptions_STATUS
		err := definition.Volume.AssignProperties_To_VolumeOptions_STATUS(&volume)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VolumeOptions_STATUS() to populate field Volume")
		}
		destination.Volume = &volume
	} else {
		destination.Volume = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes the bind options for the container
type BindOptions struct {
	// CreateHostPath: Indicate whether to create host path.
	CreateHostPath *bool `json:"createHostPath,omitempty"`

	// Propagation: Type of Bind Option
	Propagation *string `json:"propagation,omitempty"`

	// Selinux: Mention the selinux options.
	Selinux *string `json:"selinux,omitempty"`
}

var _ genruntime.ARMTransformer = &BindOptions{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (options *BindOptions) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if options == nil {
		return nil, nil
	}
	result := &arm.BindOptions{}

	// Set property "CreateHostPath":
	if options.CreateHostPath != nil {
		createHostPath := *options.CreateHostPath
		result.CreateHostPath = &createHostPath
	}

	// Set property "Propagation":
	if options.Propagation != nil {
		propagation := *options.Propagation
		result.Propagation = &propagation
	}

	// Set property "Selinux":
	if options.Selinux != nil {
		selinux := *options.Selinux
		result.Selinux = &selinux
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (options *BindOptions) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BindOptions{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (options *BindOptions) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BindOptions)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BindOptions, got %T", armInput)
	}

	// Set property "CreateHostPath":
	if typedInput.CreateHostPath != nil {
		createHostPath := *typedInput.CreateHostPath
		options.CreateHostPath = &createHostPath
	}

	// Set property "Propagation":
	if typedInput.Propagation != nil {
		propagation := *typedInput.Propagation
		options.Propagation = &propagation
	}

	// Set property "Selinux":
	if typedInput.Selinux != nil {
		selinux := *typedInput.Selinux
		options.Selinux = &selinux
	}

	// No error
	return nil
}

// AssignProperties_From_BindOptions populates our BindOptions from the provided source BindOptions
func (options *BindOptions) AssignProperties_From_BindOptions(source *storage.BindOptions) error {

	// CreateHostPath
	if source.CreateHostPath != nil {
		createHostPath := *source.CreateHostPath
		options.CreateHostPath = &createHostPath
	} else {
		options.CreateHostPath = nil
	}

	// Propagation
	options.Propagation = genruntime.ClonePointerToString(source.Propagation)

	// Selinux
	options.Selinux = genruntime.ClonePointerToString(source.Selinux)

	// No error
	return nil
}

// AssignProperties_To_BindOptions populates the provided destination BindOptions from our BindOptions
func (options *BindOptions) AssignProperties_To_BindOptions(destination *storage.BindOptions) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CreateHostPath
	if options.CreateHostPath != nil {
		createHostPath := *options.CreateHostPath
		destination.CreateHostPath = &createHostPath
	} else {
		destination.CreateHostPath = nil
	}

	// Propagation
	destination.Propagation = genruntime.ClonePointerToString(options.Propagation)

	// Selinux
	destination.Selinux = genruntime.ClonePointerToString(options.Selinux)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_BindOptions_STATUS populates our BindOptions from the provided source BindOptions_STATUS
func (options *BindOptions) Initialize_From_BindOptions_STATUS(source *BindOptions_STATUS) error {

	// CreateHostPath
	if source.CreateHostPath != nil {
		createHostPath := *source.CreateHostPath
		options.CreateHostPath = &createHostPath
	} else {
		options.CreateHostPath = nil
	}

	// Propagation
	options.Propagation = genruntime.ClonePointerToString(source.Propagation)

	// Selinux
	options.Selinux = genruntime.ClonePointerToString(source.Selinux)

	// No error
	return nil
}

// Describes the bind options for the container
type BindOptions_STATUS struct {
	// CreateHostPath: Indicate whether to create host path.
	CreateHostPath *bool `json:"createHostPath,omitempty"`

	// Propagation: Type of Bind Option
	Propagation *string `json:"propagation,omitempty"`

	// Selinux: Mention the selinux options.
	Selinux *string `json:"selinux,omitempty"`
}

var _ genruntime.FromARMConverter = &BindOptions_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (options *BindOptions_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BindOptions_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (options *BindOptions_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BindOptions_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BindOptions_STATUS, got %T", armInput)
	}

	// Set property "CreateHostPath":
	if typedInput.CreateHostPath != nil {
		createHostPath := *typedInput.CreateHostPath
		options.CreateHostPath = &createHostPath
	}

	// Set property "Propagation":
	if typedInput.Propagation != nil {
		propagation := *typedInput.Propagation
		options.Propagation = &propagation
	}

	// Set property "Selinux":
	if typedInput.Selinux != nil {
		selinux := *typedInput.Selinux
		options.Selinux = &selinux
	}

	// No error
	return nil
}

// AssignProperties_From_BindOptions_STATUS populates our BindOptions_STATUS from the provided source BindOptions_STATUS
func (options *BindOptions_STATUS) AssignProperties_From_BindOptions_STATUS(source *storage.BindOptions_STATUS) error {

	// CreateHostPath
	if source.CreateHostPath != nil {
		createHostPath := *source.CreateHostPath
		options.CreateHostPath = &createHostPath
	} else {
		options.CreateHostPath = nil
	}

	// Propagation
	options.Propagation = genruntime.ClonePointerToString(source.Propagation)

	// Selinux
	options.Selinux = genruntime.ClonePointerToString(source.Selinux)

	// No error
	return nil
}

// AssignProperties_To_BindOptions_STATUS populates the provided destination BindOptions_STATUS from our BindOptions_STATUS
func (options *BindOptions_STATUS) AssignProperties_To_BindOptions_STATUS(destination *storage.BindOptions_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CreateHostPath
	if options.CreateHostPath != nil {
		createHostPath := *options.CreateHostPath
		destination.CreateHostPath = &createHostPath
	} else {
		destination.CreateHostPath = nil
	}

	// Propagation
	destination.Propagation = genruntime.ClonePointerToString(options.Propagation)

	// Selinux
	destination.Selinux = genruntime.ClonePointerToString(options.Selinux)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The compute power action.
// +kubebuilder:validation:Enum={"Start","Stop"}
type ComputePowerAction string

const (
	ComputePowerAction_Start = ComputePowerAction("Start")
	ComputePowerAction_Stop  = ComputePowerAction("Stop")
)

// Mapping from string to ComputePowerAction
var computePowerAction_Values = map[string]ComputePowerAction{
	"start": ComputePowerAction_Start,
	"stop":  ComputePowerAction_Stop,
}

// The compute power action.
type ComputePowerAction_STATUS string

const (
	ComputePowerAction_STATUS_Start = ComputePowerAction_STATUS("Start")
	ComputePowerAction_STATUS_Stop  = ComputePowerAction_STATUS("Stop")
)

// Mapping from string to ComputePowerAction_STATUS
var computePowerAction_STATUS_Values = map[string]ComputePowerAction_STATUS{
	"start": ComputePowerAction_STATUS_Start,
	"stop":  ComputePowerAction_STATUS_Stop,
}

type ComputeStartStopSchedule_ProvisioningStatus_STATUS string

const (
	ComputeStartStopSchedule_ProvisioningStatus_STATUS_Completed    = ComputeStartStopSchedule_ProvisioningStatus_STATUS("Completed")
	ComputeStartStopSchedule_ProvisioningStatus_STATUS_Failed       = ComputeStartStopSchedule_ProvisioningStatus_STATUS("Failed")
	ComputeStartStopSchedule_ProvisioningStatus_STATUS_Provisioning = ComputeStartStopSchedule_ProvisioningStatus_STATUS("Provisioning")
)

// Mapping from string to ComputeStartStopSchedule_ProvisioningStatus_STATUS
var computeStartStopSchedule_ProvisioningStatus_STATUS_Values = map[string]ComputeStartStopSchedule_ProvisioningStatus_STATUS{
	"completed":    ComputeStartStopSchedule_ProvisioningStatus_STATUS_Completed,
	"failed":       ComputeStartStopSchedule_ProvisioningStatus_STATUS_Failed,
	"provisioning": ComputeStartStopSchedule_ProvisioningStatus_STATUS_Provisioning,
}

// Is the trigger type recurrence or cron.
// +kubebuilder:validation:Enum={"Cron","Recurrence"}
type ComputeTriggerType string

const (
	ComputeTriggerType_Cron       = ComputeTriggerType("Cron")
	ComputeTriggerType_Recurrence = ComputeTriggerType("Recurrence")
)

// Mapping from string to ComputeTriggerType
var computeTriggerType_Values = map[string]ComputeTriggerType{
	"cron":       ComputeTriggerType_Cron,
	"recurrence": ComputeTriggerType_Recurrence,
}

// Is the trigger type recurrence or cron.
type ComputeTriggerType_STATUS string

const (
	ComputeTriggerType_STATUS_Cron       = ComputeTriggerType_STATUS("Cron")
	ComputeTriggerType_STATUS_Recurrence = ComputeTriggerType_STATUS("Recurrence")
)

// Mapping from string to ComputeTriggerType_STATUS
var computeTriggerType_STATUS_Values = map[string]ComputeTriggerType_STATUS{
	"cron":       ComputeTriggerType_STATUS_Cron,
	"recurrence": ComputeTriggerType_STATUS_Recurrence,
}

// The workflow trigger cron for ComputeStartStop schedule type.
type Cron struct {
	// Expression: [Required] Specifies cron expression of schedule.
	// The expression should follow NCronTab format.
	Expression *string `json:"expression,omitempty"`

	// StartTime: The start time in yyyy-MM-ddTHH:mm:ss format.
	StartTime *string `json:"startTime,omitempty"`

	// TimeZone: Specifies time zone in which the schedule runs.
	// TimeZone should follow Windows time zone format. Refer:
	// https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
	TimeZone *string `json:"timeZone,omitempty"`
}

var _ genruntime.ARMTransformer = &Cron{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (cron *Cron) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if cron == nil {
		return nil, nil
	}
	result := &arm.Cron{}

	// Set property "Expression":
	if cron.Expression != nil {
		expression := *cron.Expression
		result.Expression = &expression
	}

	// Set property "StartTime":
	if cron.StartTime != nil {
		startTime := *cron.StartTime
		result.StartTime = &startTime
	}

	// Set property "TimeZone":
	if cron.TimeZone != nil {
		timeZone := *cron.TimeZone
		result.TimeZone = &timeZone
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (cron *Cron) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Cron{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (cron *Cron) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Cron)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Cron, got %T", armInput)
	}

	// Set property "Expression":
	if typedInput.Expression != nil {
		expression := *typedInput.Expression
		cron.Expression = &expression
	}

	// Set property "StartTime":
	if typedInput.StartTime != nil {
		startTime := *typedInput.StartTime
		cron.StartTime = &startTime
	}

	// Set property "TimeZone":
	if typedInput.TimeZone != nil {
		timeZone := *typedInput.TimeZone
		cron.TimeZone = &timeZone
	}

	// No error
	return nil
}

// AssignProperties_From_Cron populates our Cron from the provided source Cron
func (cron *Cron) AssignProperties_From_Cron(source *storage.Cron) error {

	// Expression
	cron.Expression = genruntime.ClonePointerToString(source.Expression)

	// StartTime
	cron.StartTime = genruntime.ClonePointerToString(source.StartTime)

	// TimeZone
	cron.TimeZone = genruntime.ClonePointerToString(source.TimeZone)

	// No error
	return nil
}

// AssignProperties_To_Cron populates the provided destination Cron from our Cron
func (cron *Cron) AssignProperties_To_Cron(destination *storage.Cron) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Expression
	destination.Expression = genruntime.ClonePointerToString(cron.Expression)

	// StartTime
	destination.StartTime = genruntime.ClonePointerToString(cron.StartTime)

	// TimeZone
	destination.TimeZone = genruntime.ClonePointerToString(cron.TimeZone)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Cron_STATUS populates our Cron from the provided source Cron_STATUS
func (cron *Cron) Initialize_From_Cron_STATUS(source *Cron_STATUS) error {

	// Expression
	cron.Expression = genruntime.ClonePointerToString(source.Expression)

	// StartTime
	cron.StartTime = genruntime.ClonePointerToString(source.StartTime)

	// TimeZone
	cron.TimeZone = genruntime.ClonePointerToString(source.TimeZone)

	// No error
	return nil
}

// The workflow trigger cron for ComputeStartStop schedule type.
type Cron_STATUS struct {
	// Expression: [Required] Specifies cron expression of schedule.
	// The expression should follow NCronTab format.
	Expression *string `json:"expression,omitempty"`

	// StartTime: The start time in yyyy-MM-ddTHH:mm:ss format.
	StartTime *string `json:"startTime,omitempty"`

	// TimeZone: Specifies time zone in which the schedule runs.
	// TimeZone should follow Windows time zone format. Refer:
	// https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
	TimeZone *string `json:"timeZone,omitempty"`
}

var _ genruntime.FromARMConverter = &Cron_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (cron *Cron_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Cron_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (cron *Cron_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Cron_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Cron_STATUS, got %T", armInput)
	}

	// Set property "Expression":
	if typedInput.Expression != nil {
		expression := *typedInput.Expression
		cron.Expression = &expression
	}

	// Set property "StartTime":
	if typedInput.StartTime != nil {
		startTime := *typedInput.StartTime
		cron.StartTime = &startTime
	}

	// Set property "TimeZone":
	if typedInput.TimeZone != nil {
		timeZone := *typedInput.TimeZone
		cron.TimeZone = &timeZone
	}

	// No error
	return nil
}

// AssignProperties_From_Cron_STATUS populates our Cron_STATUS from the provided source Cron_STATUS
func (cron *Cron_STATUS) AssignProperties_From_Cron_STATUS(source *storage.Cron_STATUS) error {

	// Expression
	cron.Expression = genruntime.ClonePointerToString(source.Expression)

	// StartTime
	cron.StartTime = genruntime.ClonePointerToString(source.StartTime)

	// TimeZone
	cron.TimeZone = genruntime.ClonePointerToString(source.TimeZone)

	// No error
	return nil
}

// AssignProperties_To_Cron_STATUS populates the provided destination Cron_STATUS from our Cron_STATUS
func (cron *Cron_STATUS) AssignProperties_To_Cron_STATUS(destination *storage.Cron_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Expression
	destination.Expression = genruntime.ClonePointerToString(cron.Expression)

	// StartTime
	destination.StartTime = genruntime.ClonePointerToString(cron.StartTime)

	// TimeZone
	destination.TimeZone = genruntime.ClonePointerToString(cron.TimeZone)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"http","tcp","udp"}
type Endpoint_Protocol string

const (
	Endpoint_Protocol_Http = Endpoint_Protocol("http")
	Endpoint_Protocol_Tcp  = Endpoint_Protocol("tcp")
	Endpoint_Protocol_Udp  = Endpoint_Protocol("udp")
)

// Mapping from string to Endpoint_Protocol
var endpoint_Protocol_Values = map[string]Endpoint_Protocol{
	"http": Endpoint_Protocol_Http,
	"tcp":  Endpoint_Protocol_Tcp,
	"udp":  Endpoint_Protocol_Udp,
}

type Endpoint_Protocol_STATUS string

const (
	Endpoint_Protocol_STATUS_Http = Endpoint_Protocol_STATUS("http")
	Endpoint_Protocol_STATUS_Tcp  = Endpoint_Protocol_STATUS("tcp")
	Endpoint_Protocol_STATUS_Udp  = Endpoint_Protocol_STATUS("udp")
)

// Mapping from string to Endpoint_Protocol_STATUS
var endpoint_Protocol_STATUS_Values = map[string]Endpoint_Protocol_STATUS{
	"http": Endpoint_Protocol_STATUS_Http,
	"tcp":  Endpoint_Protocol_STATUS_Tcp,
	"udp":  Endpoint_Protocol_STATUS_Udp,
}

// +kubebuilder:validation:Enum={"local"}
type EnvironmentVariable_Type string

const EnvironmentVariable_Type_Local = EnvironmentVariable_Type("local")

// Mapping from string to EnvironmentVariable_Type
var environmentVariable_Type_Values = map[string]EnvironmentVariable_Type{
	"local": EnvironmentVariable_Type_Local,
}

type EnvironmentVariable_Type_STATUS string

const EnvironmentVariable_Type_STATUS_Local = EnvironmentVariable_Type_STATUS("local")

// Mapping from string to EnvironmentVariable_Type_STATUS
var environmentVariable_Type_STATUS_Values = map[string]EnvironmentVariable_Type_STATUS{
	"local": EnvironmentVariable_Type_STATUS_Local,
}

// +kubebuilder:validation:Enum={"azureml","docker"}
type Image_Type string

const (
	Image_Type_Azureml = Image_Type("azureml")
	Image_Type_Docker  = Image_Type("docker")
)

// Mapping from string to Image_Type
var image_Type_Values = map[string]Image_Type{
	"azureml": Image_Type_Azureml,
	"docker":  Image_Type_Docker,
}

type Image_Type_STATUS string

const (
	Image_Type_STATUS_Azureml = Image_Type_STATUS("azureml")
	Image_Type_STATUS_Docker  = Image_Type_STATUS("docker")
)

// Mapping from string to Image_Type_STATUS
var image_Type_STATUS_Values = map[string]Image_Type_STATUS{
	"azureml": Image_Type_STATUS_Azureml,
	"docker":  Image_Type_STATUS_Docker,
}

// The workflow trigger recurrence for ComputeStartStop schedule type.
type Recurrence struct {
	// Frequency: [Required] The frequency to trigger schedule.
	Frequency *ComputeRecurrenceFrequency `json:"frequency,omitempty"`

	// Interval: [Required] Specifies schedule interval in conjunction with frequency
	Interval *int `json:"interval,omitempty"`

	// Schedule: [Required] The recurrence schedule.
	Schedule *ComputeRecurrenceSchedule `json:"schedule,omitempty"`

	// StartTime: The start time in yyyy-MM-ddTHH:mm:ss format.
	StartTime *string `json:"startTime,omitempty"`

	// TimeZone: Specifies time zone in which the schedule runs.
	// TimeZone should follow Windows time zone format. Refer:
	// https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
	TimeZone *string `json:"timeZone,omitempty"`
}

var _ genruntime.ARMTransformer = &Recurrence{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (recurrence *Recurrence) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if recurrence == nil {
		return nil, nil
	}
	result := &arm.Recurrence{}

	// Set property "Frequency":
	if recurrence.Frequency != nil {
		var temp string
		temp = string(*recurrence.Frequency)
		frequency := arm.ComputeRecurrenceFrequency(temp)
		result.Frequency = &frequency
	}

	// Set property "Interval":
	if recurrence.Interval != nil {
		interval := *recurrence.Interval
		result.Interval = &interval
	}

	// Set property "Schedule":
	if recurrence.Schedule != nil {
		schedule_ARM, err := (*recurrence.Schedule).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		schedule := *schedule_ARM.(*arm.ComputeRecurrenceSchedule)
		result.Schedule = &schedule
	}

	// Set property "StartTime":
	if recurrence.StartTime != nil {
		startTime := *recurrence.StartTime
		result.StartTime = &startTime
	}

	// Set property "TimeZone":
	if recurrence.TimeZone != nil {
		timeZone := *recurrence.TimeZone
		result.TimeZone = &timeZone
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (recurrence *Recurrence) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Recurrence{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (recurrence *Recurrence) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Recurrence)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Recurrence, got %T", armInput)
	}

	// Set property "Frequency":
	if typedInput.Frequency != nil {
		var temp string
		temp = string(*typedInput.Frequency)
		frequency := ComputeRecurrenceFrequency(temp)
		recurrence.Frequency = &frequency
	}

	// Set property "Interval":
	if typedInput.Interval != nil {
		interval := *typedInput.Interval
		recurrence.Interval = &interval
	}

	// Set property "Schedule":
	if typedInput.Schedule != nil {
		var schedule1 ComputeRecurrenceSchedule
		err := schedule1.PopulateFromARM(owner, *typedInput.Schedule)
		if err != nil {
			return err
		}
		schedule := schedule1
		recurrence.Schedule = &schedule
	}

	// Set property "StartTime":
	if typedInput.StartTime != nil {
		startTime := *typedInput.StartTime
		recurrence.StartTime = &startTime
	}

	// Set property "TimeZone":
	if typedInput.TimeZone != nil {
		timeZone := *typedInput.TimeZone
		recurrence.TimeZone = &timeZone
	}

	// No error
	return nil
}

// AssignProperties_From_Recurrence populates our Recurrence from the provided source Recurrence
func (recurrence *Recurrence) AssignProperties_From_Recurrence(source *storage.Recurrence) error {

	// Frequency
	if source.Frequency != nil {
		frequency := *source.Frequency
		frequencyTemp := genruntime.ToEnum(frequency, computeRecurrenceFrequency_Values)
		recurrence.Frequency = &frequencyTemp
	} else {
		recurrence.Frequency = nil
	}

	// Interval
	recurrence.Interval = genruntime.ClonePointerToInt(source.Interval)

	// Schedule
	if source.Schedule != nil {
		var schedule ComputeRecurrenceSchedule
		err := schedule.AssignProperties_From_ComputeRecurrenceSchedule(source.Schedule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ComputeRecurrenceSchedule() to populate field Schedule")
		}
		recurrence.Schedule = &schedule
	} else {
		recurrence.Schedule = nil
	}

	// StartTime
	recurrence.StartTime = genruntime.ClonePointerToString(source.StartTime)

	// TimeZone
	recurrence.TimeZone = genruntime.ClonePointerToString(source.TimeZone)

	// No error
	return nil
}

// AssignProperties_To_Recurrence populates the provided destination Recurrence from our Recurrence
func (recurrence *Recurrence) AssignProperties_To_Recurrence(destination *storage.Recurrence) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Frequency
	if recurrence.Frequency != nil {
		frequency := string(*recurrence.Frequency)
		destination.Frequency = &frequency
	} else {
		destination.Frequency = nil
	}

	// Interval
	destination.Interval = genruntime.ClonePointerToInt(recurrence.Interval)

	// Schedule
	if recurrence.Schedule != nil {
		var schedule storage.ComputeRecurrenceSchedule
		err := recurrence.Schedule.AssignProperties_To_ComputeRecurrenceSchedule(&schedule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ComputeRecurrenceSchedule() to populate field Schedule")
		}
		destination.Schedule = &schedule
	} else {
		destination.Schedule = nil
	}

	// StartTime
	destination.StartTime = genruntime.ClonePointerToString(recurrence.StartTime)

	// TimeZone
	destination.TimeZone = genruntime.ClonePointerToString(recurrence.TimeZone)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Recurrence_STATUS populates our Recurrence from the provided source Recurrence_STATUS
func (recurrence *Recurrence) Initialize_From_Recurrence_STATUS(source *Recurrence_STATUS) error {

	// Frequency
	if source.Frequency != nil {
		frequency := genruntime.ToEnum(string(*source.Frequency), computeRecurrenceFrequency_Values)
		recurrence.Frequency = &frequency
	} else {
		recurrence.Frequency = nil
	}

	// Interval
	recurrence.Interval = genruntime.ClonePointerToInt(source.Interval)

	// Schedule
	if source.Schedule != nil {
		var schedule ComputeRecurrenceSchedule
		err := schedule.Initialize_From_ComputeRecurrenceSchedule_STATUS(source.Schedule)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ComputeRecurrenceSchedule_STATUS() to populate field Schedule")
		}
		recurrence.Schedule = &schedule
	} else {
		recurrence.Schedule = nil
	}

	// StartTime
	recurrence.StartTime = genruntime.ClonePointerToString(source.StartTime)

	// TimeZone
	recurrence.TimeZone = genruntime.ClonePointerToString(source.TimeZone)

	// No error
	return nil
}

// The workflow trigger recurrence for ComputeStartStop schedule type.
type Recurrence_STATUS struct {
	// Frequency: [Required] The frequency to trigger schedule.
	Frequency *ComputeRecurrenceFrequency_STATUS `json:"frequency,omitempty"`

	// Interval: [Required] Specifies schedule interval in conjunction with frequency
	Interval *int `json:"interval,omitempty"`

	// Schedule: [Required] The recurrence schedule.
	Schedule *ComputeRecurrenceSchedule_STATUS `json:"schedule,omitempty"`

	// StartTime: The start time in yyyy-MM-ddTHH:mm:ss format.
	StartTime *string `json:"startTime,omitempty"`

	// TimeZone: Specifies time zone in which the schedule runs.
	// TimeZone should follow Windows time zone format. Refer:
	// https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/default-time-zones?view=windows-11
	TimeZone *string `json:"timeZone,omitempty"`
}

var _ genruntime.FromARMConverter = &Recurrence_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (recurrence *Recurrence_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Recurrence_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (recurrence *Recurrence_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Recurrence_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Recurrence_STATUS, got %T", armInput)
	}

	// Set property "Frequency":
	if typedInput.Frequency != nil {
		var temp string
		temp = string(*typedInput.Frequency)
		frequency := ComputeRecurrenceFrequency_STATUS(temp)
		recurrence.Frequency = &frequency
	}

	// Set property "Interval":
	if typedInput.Interval != nil {
		interval := *typedInput.Interval
		recurrence.Interval = &interval
	}

	// Set property "Schedule":
	if typedInput.Schedule != nil {
		var schedule1 ComputeRecurrenceSchedule_STATUS
		err := schedule1.PopulateFromARM(owner, *typedInput.Schedule)
		if err != nil {
			return err
		}
		schedule := schedule1
		recurrence.Schedule = &schedule
	}

	// Set property "StartTime":
	if typedInput.StartTime != nil {
		startTime := *typedInput.StartTime
		recurrence.StartTime = &startTime
	}

	// Set property "TimeZone":
	if typedInput.TimeZone != nil {
		timeZone := *typedInput.TimeZone
		recurrence.TimeZone = &timeZone
	}

	// No error
	return nil
}

// AssignProperties_From_Recurrence_STATUS populates our Recurrence_STATUS from the provided source Recurrence_STATUS
func (recurrence *Recurrence_STATUS) AssignProperties_From_Recurrence_STATUS(source *storage.Recurrence_STATUS) error {

	// Frequency
	if source.Frequency != nil {
		frequency := *source.Frequency
		frequencyTemp := genruntime.ToEnum(frequency, computeRecurrenceFrequency_STATUS_Values)
		recurrence.Frequency = &frequencyTemp
	} else {
		recurrence.Frequency = nil
	}

	// Interval
	recurrence.Interval = genruntime.ClonePointerToInt(source.Interval)

	// Schedule
	if source.Schedule != nil {
		var schedule ComputeRecurrenceSchedule_STATUS
		err := schedule.AssignProperties_From_ComputeRecurrenceSchedule_STATUS(source.Schedule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ComputeRecurrenceSchedule_STATUS() to populate field Schedule")
		}
		recurrence.Schedule = &schedule
	} else {
		recurrence.Schedule = nil
	}

	// StartTime
	recurrence.StartTime = genruntime.ClonePointerToString(source.StartTime)

	// TimeZone
	recurrence.TimeZone = genruntime.ClonePointerToString(source.TimeZone)

	// No error
	return nil
}

// AssignProperties_To_Recurrence_STATUS populates the provided destination Recurrence_STATUS from our Recurrence_STATUS
func (recurrence *Recurrence_STATUS) AssignProperties_To_Recurrence_STATUS(destination *storage.Recurrence_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Frequency
	if recurrence.Frequency != nil {
		frequency := string(*recurrence.Frequency)
		destination.Frequency = &frequency
	} else {
		destination.Frequency = nil
	}

	// Interval
	destination.Interval = genruntime.ClonePointerToInt(recurrence.Interval)

	// Schedule
	if recurrence.Schedule != nil {
		var schedule storage.ComputeRecurrenceSchedule_STATUS
		err := recurrence.Schedule.AssignProperties_To_ComputeRecurrenceSchedule_STATUS(&schedule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ComputeRecurrenceSchedule_STATUS() to populate field Schedule")
		}
		destination.Schedule = &schedule
	} else {
		destination.Schedule = nil
	}

	// StartTime
	destination.StartTime = genruntime.ClonePointerToString(recurrence.StartTime)

	// TimeZone
	destination.TimeZone = genruntime.ClonePointerToString(recurrence.TimeZone)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ScheduleBase struct {
	// ProvisioningStatus: The current deployment state of schedule.
	ProvisioningStatus *ScheduleProvisioningState `json:"provisioningStatus,omitempty"`

	// Reference: A system assigned id for the schedule.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`

	// Status: Is the schedule enabled or disabled?
	Status *ScheduleStatus `json:"status,omitempty"`
}

var _ genruntime.ARMTransformer = &ScheduleBase{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (base *ScheduleBase) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if base == nil {
		return nil, nil
	}
	result := &arm.ScheduleBase{}

	// Set property "Id":
	if base.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*base.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property "ProvisioningStatus":
	if base.ProvisioningStatus != nil {
		var temp string
		temp = string(*base.ProvisioningStatus)
		provisioningStatus := arm.ScheduleProvisioningState(temp)
		result.ProvisioningStatus = &provisioningStatus
	}

	// Set property "Status":
	if base.Status != nil {
		var temp string
		temp = string(*base.Status)
		status := arm.ScheduleStatus(temp)
		result.Status = &status
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (base *ScheduleBase) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ScheduleBase{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (base *ScheduleBase) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ScheduleBase)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ScheduleBase, got %T", armInput)
	}

	// Set property "ProvisioningStatus":
	if typedInput.ProvisioningStatus != nil {
		var temp string
		temp = string(*typedInput.ProvisioningStatus)
		provisioningStatus := ScheduleProvisioningState(temp)
		base.ProvisioningStatus = &provisioningStatus
	}

	// no assignment for property "Reference"

	// Set property "Status":
	if typedInput.Status != nil {
		var temp string
		temp = string(*typedInput.Status)
		status := ScheduleStatus(temp)
		base.Status = &status
	}

	// No error
	return nil
}

// AssignProperties_From_ScheduleBase populates our ScheduleBase from the provided source ScheduleBase
func (base *ScheduleBase) AssignProperties_From_ScheduleBase(source *storage.ScheduleBase) error {

	// ProvisioningStatus
	if source.ProvisioningStatus != nil {
		provisioningStatus := *source.ProvisioningStatus
		provisioningStatusTemp := genruntime.ToEnum(provisioningStatus, scheduleProvisioningState_Values)
		base.ProvisioningStatus = &provisioningStatusTemp
	} else {
		base.ProvisioningStatus = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		base.Reference = &reference
	} else {
		base.Reference = nil
	}

	// Status
	if source.Status != nil {
		status := *source.Status
		statusTemp := genruntime.ToEnum(status, scheduleStatus_Values)
		base.Status = &statusTemp
	} else {
		base.Status = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ScheduleBase populates the provided destination ScheduleBase from our ScheduleBase
func (base *ScheduleBase) AssignProperties_To_ScheduleBase(destination *storage.ScheduleBase) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ProvisioningStatus
	if base.ProvisioningStatus != nil {
		provisioningStatus := string(*base.ProvisioningStatus)
		destination.ProvisioningStatus = &provisioningStatus
	} else {
		destination.ProvisioningStatus = nil
	}

	// Reference
	if base.Reference != nil {
		reference := base.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Status
	if base.Status != nil {
		status := string(*base.Status)
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ScheduleBase_STATUS populates our ScheduleBase from the provided source ScheduleBase_STATUS
func (base *ScheduleBase) Initialize_From_ScheduleBase_STATUS(source *ScheduleBase_STATUS) error {

	// ProvisioningStatus
	if source.ProvisioningStatus != nil {
		provisioningStatus := genruntime.ToEnum(string(*source.ProvisioningStatus), scheduleProvisioningState_Values)
		base.ProvisioningStatus = &provisioningStatus
	} else {
		base.ProvisioningStatus = nil
	}

	// Reference
	if source.Id != nil {
		reference := genruntime.CreateResourceReferenceFromARMID(*source.Id)
		base.Reference = &reference
	} else {
		base.Reference = nil
	}

	// Status
	if source.Status != nil {
		status := genruntime.ToEnum(string(*source.Status), scheduleStatus_Values)
		base.Status = &status
	} else {
		base.Status = nil
	}

	// No error
	return nil
}

type ScheduleBase_STATUS struct {
	// Id: A system assigned id for the schedule.
	Id *string `json:"id,omitempty"`

	// ProvisioningStatus: The current deployment state of schedule.
	ProvisioningStatus *ScheduleProvisioningState_STATUS `json:"provisioningStatus,omitempty"`

	// Status: Is the schedule enabled or disabled?
	Status *ScheduleStatus_STATUS `json:"status,omitempty"`
}

var _ genruntime.FromARMConverter = &ScheduleBase_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (base *ScheduleBase_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ScheduleBase_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (base *ScheduleBase_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ScheduleBase_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ScheduleBase_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		base.Id = &id
	}

	// Set property "ProvisioningStatus":
	if typedInput.ProvisioningStatus != nil {
		var temp string
		temp = string(*typedInput.ProvisioningStatus)
		provisioningStatus := ScheduleProvisioningState_STATUS(temp)
		base.ProvisioningStatus = &provisioningStatus
	}

	// Set property "Status":
	if typedInput.Status != nil {
		var temp string
		temp = string(*typedInput.Status)
		status := ScheduleStatus_STATUS(temp)
		base.Status = &status
	}

	// No error
	return nil
}

// AssignProperties_From_ScheduleBase_STATUS populates our ScheduleBase_STATUS from the provided source ScheduleBase_STATUS
func (base *ScheduleBase_STATUS) AssignProperties_From_ScheduleBase_STATUS(source *storage.ScheduleBase_STATUS) error {

	// Id
	base.Id = genruntime.ClonePointerToString(source.Id)

	// ProvisioningStatus
	if source.ProvisioningStatus != nil {
		provisioningStatus := *source.ProvisioningStatus
		provisioningStatusTemp := genruntime.ToEnum(provisioningStatus, scheduleProvisioningState_STATUS_Values)
		base.ProvisioningStatus = &provisioningStatusTemp
	} else {
		base.ProvisioningStatus = nil
	}

	// Status
	if source.Status != nil {
		status := *source.Status
		statusTemp := genruntime.ToEnum(status, scheduleStatus_STATUS_Values)
		base.Status = &statusTemp
	} else {
		base.Status = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ScheduleBase_STATUS populates the provided destination ScheduleBase_STATUS from our ScheduleBase_STATUS
func (base *ScheduleBase_STATUS) AssignProperties_To_ScheduleBase_STATUS(destination *storage.ScheduleBase_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(base.Id)

	// ProvisioningStatus
	if base.ProvisioningStatus != nil {
		provisioningStatus := string(*base.ProvisioningStatus)
		destination.ProvisioningStatus = &provisioningStatus
	} else {
		destination.ProvisioningStatus = nil
	}

	// Status
	if base.Status != nil {
		status := string(*base.Status)
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Is the schedule enabled or disabled?
// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type ScheduleStatus string

const (
	ScheduleStatus_Disabled = ScheduleStatus("Disabled")
	ScheduleStatus_Enabled  = ScheduleStatus("Enabled")
)

// Mapping from string to ScheduleStatus
var scheduleStatus_Values = map[string]ScheduleStatus{
	"disabled": ScheduleStatus_Disabled,
	"enabled":  ScheduleStatus_Enabled,
}

// Is the schedule enabled or disabled?
type ScheduleStatus_STATUS string

const (
	ScheduleStatus_STATUS_Disabled = ScheduleStatus_STATUS("Disabled")
	ScheduleStatus_STATUS_Enabled  = ScheduleStatus_STATUS("Enabled")
)

// Mapping from string to ScheduleStatus_STATUS
var scheduleStatus_STATUS_Values = map[string]ScheduleStatus_STATUS{
	"disabled": ScheduleStatus_STATUS_Disabled,
	"enabled":  ScheduleStatus_STATUS_Enabled,
}

// Script reference
type ScriptReference struct {
	// ScriptArguments: Optional command line arguments passed to the script to run.
	ScriptArguments *string `json:"scriptArguments,omitempty"`

	// ScriptData: The location of scripts in the mounted volume.
	ScriptData *string `json:"scriptData,omitempty"`

	// ScriptSource: The storage source of the script: workspace.
	ScriptSource *string `json:"scriptSource,omitempty"`

	// Timeout: Optional time period passed to timeout command.
	Timeout *string `json:"timeout,omitempty"`
}

var _ genruntime.ARMTransformer = &ScriptReference{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (reference *ScriptReference) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if reference == nil {
		return nil, nil
	}
	result := &arm.ScriptReference{}

	// Set property "ScriptArguments":
	if reference.ScriptArguments != nil {
		scriptArguments := *reference.ScriptArguments
		result.ScriptArguments = &scriptArguments
	}

	// Set property "ScriptData":
	if reference.ScriptData != nil {
		scriptData := *reference.ScriptData
		result.ScriptData = &scriptData
	}

	// Set property "ScriptSource":
	if reference.ScriptSource != nil {
		scriptSource := *reference.ScriptSource
		result.ScriptSource = &scriptSource
	}

	// Set property "Timeout":
	if reference.Timeout != nil {
		timeout := *reference.Timeout
		result.Timeout = &timeout
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *ScriptReference) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ScriptReference{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *ScriptReference) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ScriptReference)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ScriptReference, got %T", armInput)
	}

	// Set property "ScriptArguments":
	if typedInput.ScriptArguments != nil {
		scriptArguments := *typedInput.ScriptArguments
		reference.ScriptArguments = &scriptArguments
	}

	// Set property "ScriptData":
	if typedInput.ScriptData != nil {
		scriptData := *typedInput.ScriptData
		reference.ScriptData = &scriptData
	}

	// Set property "ScriptSource":
	if typedInput.ScriptSource != nil {
		scriptSource := *typedInput.ScriptSource
		reference.ScriptSource = &scriptSource
	}

	// Set property "Timeout":
	if typedInput.Timeout != nil {
		timeout := *typedInput.Timeout
		reference.Timeout = &timeout
	}

	// No error
	return nil
}

// AssignProperties_From_ScriptReference populates our ScriptReference from the provided source ScriptReference
func (reference *ScriptReference) AssignProperties_From_ScriptReference(source *storage.ScriptReference) error {

	// ScriptArguments
	reference.ScriptArguments = genruntime.ClonePointerToString(source.ScriptArguments)

	// ScriptData
	reference.ScriptData = genruntime.ClonePointerToString(source.ScriptData)

	// ScriptSource
	reference.ScriptSource = genruntime.ClonePointerToString(source.ScriptSource)

	// Timeout
	reference.Timeout = genruntime.ClonePointerToString(source.Timeout)

	// No error
	return nil
}

// AssignProperties_To_ScriptReference populates the provided destination ScriptReference from our ScriptReference
func (reference *ScriptReference) AssignProperties_To_ScriptReference(destination *storage.ScriptReference) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ScriptArguments
	destination.ScriptArguments = genruntime.ClonePointerToString(reference.ScriptArguments)

	// ScriptData
	destination.ScriptData = genruntime.ClonePointerToString(reference.ScriptData)

	// ScriptSource
	destination.ScriptSource = genruntime.ClonePointerToString(reference.ScriptSource)

	// Timeout
	destination.Timeout = genruntime.ClonePointerToString(reference.Timeout)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ScriptReference_STATUS populates our ScriptReference from the provided source ScriptReference_STATUS
func (reference *ScriptReference) Initialize_From_ScriptReference_STATUS(source *ScriptReference_STATUS) error {

	// ScriptArguments
	reference.ScriptArguments = genruntime.ClonePointerToString(source.ScriptArguments)

	// ScriptData
	reference.ScriptData = genruntime.ClonePointerToString(source.ScriptData)

	// ScriptSource
	reference.ScriptSource = genruntime.ClonePointerToString(source.ScriptSource)

	// Timeout
	reference.Timeout = genruntime.ClonePointerToString(source.Timeout)

	// No error
	return nil
}

// Script reference
type ScriptReference_STATUS struct {
	// ScriptArguments: Optional command line arguments passed to the script to run.
	ScriptArguments *string `json:"scriptArguments,omitempty"`

	// ScriptData: The location of scripts in the mounted volume.
	ScriptData *string `json:"scriptData,omitempty"`

	// ScriptSource: The storage source of the script: workspace.
	ScriptSource *string `json:"scriptSource,omitempty"`

	// Timeout: Optional time period passed to timeout command.
	Timeout *string `json:"timeout,omitempty"`
}

var _ genruntime.FromARMConverter = &ScriptReference_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *ScriptReference_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ScriptReference_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *ScriptReference_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ScriptReference_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ScriptReference_STATUS, got %T", armInput)
	}

	// Set property "ScriptArguments":
	if typedInput.ScriptArguments != nil {
		scriptArguments := *typedInput.ScriptArguments
		reference.ScriptArguments = &scriptArguments
	}

	// Set property "ScriptData":
	if typedInput.ScriptData != nil {
		scriptData := *typedInput.ScriptData
		reference.ScriptData = &scriptData
	}

	// Set property "ScriptSource":
	if typedInput.ScriptSource != nil {
		scriptSource := *typedInput.ScriptSource
		reference.ScriptSource = &scriptSource
	}

	// Set property "Timeout":
	if typedInput.Timeout != nil {
		timeout := *typedInput.Timeout
		reference.Timeout = &timeout
	}

	// No error
	return nil
}

// AssignProperties_From_ScriptReference_STATUS populates our ScriptReference_STATUS from the provided source ScriptReference_STATUS
func (reference *ScriptReference_STATUS) AssignProperties_From_ScriptReference_STATUS(source *storage.ScriptReference_STATUS) error {

	// ScriptArguments
	reference.ScriptArguments = genruntime.ClonePointerToString(source.ScriptArguments)

	// ScriptData
	reference.ScriptData = genruntime.ClonePointerToString(source.ScriptData)

	// ScriptSource
	reference.ScriptSource = genruntime.ClonePointerToString(source.ScriptSource)

	// Timeout
	reference.Timeout = genruntime.ClonePointerToString(source.Timeout)

	// No error
	return nil
}

// AssignProperties_To_ScriptReference_STATUS populates the provided destination ScriptReference_STATUS from our ScriptReference_STATUS
func (reference *ScriptReference_STATUS) AssignProperties_To_ScriptReference_STATUS(destination *storage.ScriptReference_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ScriptArguments
	destination.ScriptArguments = genruntime.ClonePointerToString(reference.ScriptArguments)

	// ScriptData
	destination.ScriptData = genruntime.ClonePointerToString(reference.ScriptData)

	// ScriptSource
	destination.ScriptSource = genruntime.ClonePointerToString(reference.ScriptSource)

	// Timeout
	destination.Timeout = genruntime.ClonePointerToString(reference.Timeout)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes the tmpfs options for the container
type TmpfsOptions struct {
	// Size: Mention the Tmpfs size
	Size *int `json:"size,omitempty"`
}

var _ genruntime.ARMTransformer = &TmpfsOptions{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (options *TmpfsOptions) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if options == nil {
		return nil, nil
	}
	result := &arm.TmpfsOptions{}

	// Set property "Size":
	if options.Size != nil {
		size := *options.Size
		result.Size = &size
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (options *TmpfsOptions) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TmpfsOptions{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (options *TmpfsOptions) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TmpfsOptions)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TmpfsOptions, got %T", armInput)
	}

	// Set property "Size":
	if typedInput.Size != nil {
		size := *typedInput.Size
		options.Size = &size
	}

	// No error
	return nil
}

// AssignProperties_From_TmpfsOptions populates our TmpfsOptions from the provided source TmpfsOptions
func (options *TmpfsOptions) AssignProperties_From_TmpfsOptions(source *storage.TmpfsOptions) error {

	// Size
	options.Size = genruntime.ClonePointerToInt(source.Size)

	// No error
	return nil
}

// AssignProperties_To_TmpfsOptions populates the provided destination TmpfsOptions from our TmpfsOptions
func (options *TmpfsOptions) AssignProperties_To_TmpfsOptions(destination *storage.TmpfsOptions) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Size
	destination.Size = genruntime.ClonePointerToInt(options.Size)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_TmpfsOptions_STATUS populates our TmpfsOptions from the provided source TmpfsOptions_STATUS
func (options *TmpfsOptions) Initialize_From_TmpfsOptions_STATUS(source *TmpfsOptions_STATUS) error {

	// Size
	options.Size = genruntime.ClonePointerToInt(source.Size)

	// No error
	return nil
}

// Describes the tmpfs options for the container
type TmpfsOptions_STATUS struct {
	// Size: Mention the Tmpfs size
	Size *int `json:"size,omitempty"`
}

var _ genruntime.FromARMConverter = &TmpfsOptions_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (options *TmpfsOptions_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TmpfsOptions_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (options *TmpfsOptions_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TmpfsOptions_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TmpfsOptions_STATUS, got %T", armInput)
	}

	// Set property "Size":
	if typedInput.Size != nil {
		size := *typedInput.Size
		options.Size = &size
	}

	// No error
	return nil
}

// AssignProperties_From_TmpfsOptions_STATUS populates our TmpfsOptions_STATUS from the provided source TmpfsOptions_STATUS
func (options *TmpfsOptions_STATUS) AssignProperties_From_TmpfsOptions_STATUS(source *storage.TmpfsOptions_STATUS) error {

	// Size
	options.Size = genruntime.ClonePointerToInt(source.Size)

	// No error
	return nil
}

// AssignProperties_To_TmpfsOptions_STATUS populates the provided destination TmpfsOptions_STATUS from our TmpfsOptions_STATUS
func (options *TmpfsOptions_STATUS) AssignProperties_To_TmpfsOptions_STATUS(destination *storage.TmpfsOptions_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Size
	destination.Size = genruntime.ClonePointerToInt(options.Size)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"bind","npipe","tmpfs","volume"}
type VolumeDefinition_Type string

const (
	VolumeDefinition_Type_Bind   = VolumeDefinition_Type("bind")
	VolumeDefinition_Type_Npipe  = VolumeDefinition_Type("npipe")
	VolumeDefinition_Type_Tmpfs  = VolumeDefinition_Type("tmpfs")
	VolumeDefinition_Type_Volume = VolumeDefinition_Type("volume")
)

// Mapping from string to VolumeDefinition_Type
var volumeDefinition_Type_Values = map[string]VolumeDefinition_Type{
	"bind":   VolumeDefinition_Type_Bind,
	"npipe":  VolumeDefinition_Type_Npipe,
	"tmpfs":  VolumeDefinition_Type_Tmpfs,
	"volume": VolumeDefinition_Type_Volume,
}

type VolumeDefinition_Type_STATUS string

const (
	VolumeDefinition_Type_STATUS_Bind   = VolumeDefinition_Type_STATUS("bind")
	VolumeDefinition_Type_STATUS_Npipe  = VolumeDefinition_Type_STATUS("npipe")
	VolumeDefinition_Type_STATUS_Tmpfs  = VolumeDefinition_Type_STATUS("tmpfs")
	VolumeDefinition_Type_STATUS_Volume = VolumeDefinition_Type_STATUS("volume")
)

// Mapping from string to VolumeDefinition_Type_STATUS
var volumeDefinition_Type_STATUS_Values = map[string]VolumeDefinition_Type_STATUS{
	"bind":   VolumeDefinition_Type_STATUS_Bind,
	"npipe":  VolumeDefinition_Type_STATUS_Npipe,
	"tmpfs":  VolumeDefinition_Type_STATUS_Tmpfs,
	"volume": VolumeDefinition_Type_STATUS_Volume,
}

// Describes the volume options for the container
type VolumeOptions struct {
	// Nocopy: Indicate whether volume is nocopy
	Nocopy *bool `json:"nocopy,omitempty"`
}

var _ genruntime.ARMTransformer = &VolumeOptions{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (options *VolumeOptions) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if options == nil {
		return nil, nil
	}
	result := &arm.VolumeOptions{}

	// Set property "Nocopy":
	if options.Nocopy != nil {
		nocopy := *options.Nocopy
		result.Nocopy = &nocopy
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (options *VolumeOptions) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VolumeOptions{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (options *VolumeOptions) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VolumeOptions)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VolumeOptions, got %T", armInput)
	}

	// Set property "Nocopy":
	if typedInput.Nocopy != nil {
		nocopy := *typedInput.Nocopy
		options.Nocopy = &nocopy
	}

	// No error
	return nil
}

// AssignProperties_From_VolumeOptions populates our VolumeOptions from the provided source VolumeOptions
func (options *VolumeOptions) AssignProperties_From_VolumeOptions(source *storage.VolumeOptions) error {

	// Nocopy
	if source.Nocopy != nil {
		nocopy := *source.Nocopy
		options.Nocopy = &nocopy
	} else {
		options.Nocopy = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VolumeOptions populates the provided destination VolumeOptions from our VolumeOptions
func (options *VolumeOptions) AssignProperties_To_VolumeOptions(destination *storage.VolumeOptions) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Nocopy
	if options.Nocopy != nil {
		nocopy := *options.Nocopy
		destination.Nocopy = &nocopy
	} else {
		destination.Nocopy = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VolumeOptions_STATUS populates our VolumeOptions from the provided source VolumeOptions_STATUS
func (options *VolumeOptions) Initialize_From_VolumeOptions_STATUS(source *VolumeOptions_STATUS) error {

	// Nocopy
	if source.Nocopy != nil {
		nocopy := *source.Nocopy
		options.Nocopy = &nocopy
	} else {
		options.Nocopy = nil
	}

	// No error
	return nil
}

// Describes the volume options for the container
type VolumeOptions_STATUS struct {
	// Nocopy: Indicate whether volume is nocopy
	Nocopy *bool `json:"nocopy,omitempty"`
}

var _ genruntime.FromARMConverter = &VolumeOptions_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (options *VolumeOptions_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VolumeOptions_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (options *VolumeOptions_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VolumeOptions_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VolumeOptions_STATUS, got %T", armInput)
	}

	// Set property "Nocopy":
	if typedInput.Nocopy != nil {
		nocopy := *typedInput.Nocopy
		options.Nocopy = &nocopy
	}

	// No error
	return nil
}

// AssignProperties_From_VolumeOptions_STATUS populates our VolumeOptions_STATUS from the provided source VolumeOptions_STATUS
func (options *VolumeOptions_STATUS) AssignProperties_From_VolumeOptions_STATUS(source *storage.VolumeOptions_STATUS) error {

	// Nocopy
	if source.Nocopy != nil {
		nocopy := *source.Nocopy
		options.Nocopy = &nocopy
	} else {
		options.Nocopy = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VolumeOptions_STATUS populates the provided destination VolumeOptions_STATUS from our VolumeOptions_STATUS
func (options *VolumeOptions_STATUS) AssignProperties_To_VolumeOptions_STATUS(destination *storage.VolumeOptions_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Nocopy
	if options.Nocopy != nil {
		nocopy := *options.Nocopy
		destination.Nocopy = &nocopy
	} else {
		destination.Nocopy = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Enum to describe the frequency of a compute recurrence schedule
// +kubebuilder:validation:Enum={"Day","Hour","Minute","Month","Week"}
type ComputeRecurrenceFrequency string

const (
	ComputeRecurrenceFrequency_Day    = ComputeRecurrenceFrequency("Day")
	ComputeRecurrenceFrequency_Hour   = ComputeRecurrenceFrequency("Hour")
	ComputeRecurrenceFrequency_Minute = ComputeRecurrenceFrequency("Minute")
	ComputeRecurrenceFrequency_Month  = ComputeRecurrenceFrequency("Month")
	ComputeRecurrenceFrequency_Week   = ComputeRecurrenceFrequency("Week")
)

// Mapping from string to ComputeRecurrenceFrequency
var computeRecurrenceFrequency_Values = map[string]ComputeRecurrenceFrequency{
	"day":    ComputeRecurrenceFrequency_Day,
	"hour":   ComputeRecurrenceFrequency_Hour,
	"minute": ComputeRecurrenceFrequency_Minute,
	"month":  ComputeRecurrenceFrequency_Month,
	"week":   ComputeRecurrenceFrequency_Week,
}

// Enum to describe the frequency of a compute recurrence schedule
type ComputeRecurrenceFrequency_STATUS string

const (
	ComputeRecurrenceFrequency_STATUS_Day    = ComputeRecurrenceFrequency_STATUS("Day")
	ComputeRecurrenceFrequency_STATUS_Hour   = ComputeRecurrenceFrequency_STATUS("Hour")
	ComputeRecurrenceFrequency_STATUS_Minute = ComputeRecurrenceFrequency_STATUS("Minute")
	ComputeRecurrenceFrequency_STATUS_Month  = ComputeRecurrenceFrequency_STATUS("Month")
	ComputeRecurrenceFrequency_STATUS_Week   = ComputeRecurrenceFrequency_STATUS("Week")
)

// Mapping from string to ComputeRecurrenceFrequency_STATUS
var computeRecurrenceFrequency_STATUS_Values = map[string]ComputeRecurrenceFrequency_STATUS{
	"day":    ComputeRecurrenceFrequency_STATUS_Day,
	"hour":   ComputeRecurrenceFrequency_STATUS_Hour,
	"minute": ComputeRecurrenceFrequency_STATUS_Minute,
	"month":  ComputeRecurrenceFrequency_STATUS_Month,
	"week":   ComputeRecurrenceFrequency_STATUS_Week,
}

type ComputeRecurrenceSchedule struct {
	// +kubebuilder:validation:Required
	// Hours: [Required] List of hours for the schedule.
	Hours []int `json:"hours,omitempty"`

	// +kubebuilder:validation:Required
	// Minutes: [Required] List of minutes for the schedule.
	Minutes []int `json:"minutes,omitempty"`

	// MonthDays: List of month days for the schedule
	MonthDays []int `json:"monthDays,omitempty"`

	// WeekDays: List of days for the schedule.
	WeekDays []ComputeWeekDay `json:"weekDays,omitempty"`
}

var _ genruntime.ARMTransformer = &ComputeRecurrenceSchedule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (schedule *ComputeRecurrenceSchedule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if schedule == nil {
		return nil, nil
	}
	result := &arm.ComputeRecurrenceSchedule{}

	// Set property "Hours":
	for _, item := range schedule.Hours {
		result.Hours = append(result.Hours, item)
	}

	// Set property "Minutes":
	for _, item := range schedule.Minutes {
		result.Minutes = append(result.Minutes, item)
	}

	// Set property "MonthDays":
	for _, item := range schedule.MonthDays {
		result.MonthDays = append(result.MonthDays, item)
	}

	// Set property "WeekDays":
	for _, item := range schedule.WeekDays {
		var temp string
		temp = string(item)
		result.WeekDays = append(result.WeekDays, arm.ComputeWeekDay(temp))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (schedule *ComputeRecurrenceSchedule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComputeRecurrenceSchedule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (schedule *ComputeRecurrenceSchedule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComputeRecurrenceSchedule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComputeRecurrenceSchedule, got %T", armInput)
	}

	// Set property "Hours":
	for _, item := range typedInput.Hours {
		schedule.Hours = append(schedule.Hours, item)
	}

	// Set property "Minutes":
	for _, item := range typedInput.Minutes {
		schedule.Minutes = append(schedule.Minutes, item)
	}

	// Set property "MonthDays":
	for _, item := range typedInput.MonthDays {
		schedule.MonthDays = append(schedule.MonthDays, item)
	}

	// Set property "WeekDays":
	for _, item := range typedInput.WeekDays {
		var temp string
		temp = string(item)
		schedule.WeekDays = append(schedule.WeekDays, ComputeWeekDay(temp))
	}

	// No error
	return nil
}

// AssignProperties_From_ComputeRecurrenceSchedule populates our ComputeRecurrenceSchedule from the provided source ComputeRecurrenceSchedule
func (schedule *ComputeRecurrenceSchedule) AssignProperties_From_ComputeRecurrenceSchedule(source *storage.ComputeRecurrenceSchedule) error {

	// Hours
	if source.Hours != nil {
		hourList := make([]int, len(source.Hours))
		for hourIndex, hourItem := range source.Hours {
			// Shadow the loop variable to avoid aliasing
			hourItem := hourItem
			hourList[hourIndex] = hourItem
		}
		schedule.Hours = hourList
	} else {
		schedule.Hours = nil
	}

	// Minutes
	if source.Minutes != nil {
		minuteList := make([]int, len(source.Minutes))
		for minuteIndex, minuteItem := range source.Minutes {
			// Shadow the loop variable to avoid aliasing
			minuteItem := minuteItem
			minuteList[minuteIndex] = minuteItem
		}
		schedule.Minutes = minuteList
	} else {
		schedule.Minutes = nil
	}

	// MonthDays
	if source.MonthDays != nil {
		monthDayList := make([]int, len(source.MonthDays))
		for monthDayIndex, monthDayItem := range source.MonthDays {
			// Shadow the loop variable to avoid aliasing
			monthDayItem := monthDayItem
			monthDayList[monthDayIndex] = monthDayItem
		}
		schedule.MonthDays = monthDayList
	} else {
		schedule.MonthDays = nil
	}

	// WeekDays
	if source.WeekDays != nil {
		weekDayList := make([]ComputeWeekDay, len(source.WeekDays))
		for weekDayIndex, weekDayItem := range source.WeekDays {
			// Shadow the loop variable to avoid aliasing
			weekDayItem := weekDayItem
			weekDayList[weekDayIndex] = genruntime.ToEnum(weekDayItem, computeWeekDay_Values)
		}
		schedule.WeekDays = weekDayList
	} else {
		schedule.WeekDays = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ComputeRecurrenceSchedule populates the provided destination ComputeRecurrenceSchedule from our ComputeRecurrenceSchedule
func (schedule *ComputeRecurrenceSchedule) AssignProperties_To_ComputeRecurrenceSchedule(destination *storage.ComputeRecurrenceSchedule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Hours
	if schedule.Hours != nil {
		hourList := make([]int, len(schedule.Hours))
		for hourIndex, hourItem := range schedule.Hours {
			// Shadow the loop variable to avoid aliasing
			hourItem := hourItem
			hourList[hourIndex] = hourItem
		}
		destination.Hours = hourList
	} else {
		destination.Hours = nil
	}

	// Minutes
	if schedule.Minutes != nil {
		minuteList := make([]int, len(schedule.Minutes))
		for minuteIndex, minuteItem := range schedule.Minutes {
			// Shadow the loop variable to avoid aliasing
			minuteItem := minuteItem
			minuteList[minuteIndex] = minuteItem
		}
		destination.Minutes = minuteList
	} else {
		destination.Minutes = nil
	}

	// MonthDays
	if schedule.MonthDays != nil {
		monthDayList := make([]int, len(schedule.MonthDays))
		for monthDayIndex, monthDayItem := range schedule.MonthDays {
			// Shadow the loop variable to avoid aliasing
			monthDayItem := monthDayItem
			monthDayList[monthDayIndex] = monthDayItem
		}
		destination.MonthDays = monthDayList
	} else {
		destination.MonthDays = nil
	}

	// WeekDays
	if schedule.WeekDays != nil {
		weekDayList := make([]string, len(schedule.WeekDays))
		for weekDayIndex, weekDayItem := range schedule.WeekDays {
			// Shadow the loop variable to avoid aliasing
			weekDayItem := weekDayItem
			weekDayList[weekDayIndex] = string(weekDayItem)
		}
		destination.WeekDays = weekDayList
	} else {
		destination.WeekDays = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ComputeRecurrenceSchedule_STATUS populates our ComputeRecurrenceSchedule from the provided source ComputeRecurrenceSchedule_STATUS
func (schedule *ComputeRecurrenceSchedule) Initialize_From_ComputeRecurrenceSchedule_STATUS(source *ComputeRecurrenceSchedule_STATUS) error {

	// Hours
	if source.Hours != nil {
		hourList := make([]int, len(source.Hours))
		for hourIndex, hourItem := range source.Hours {
			// Shadow the loop variable to avoid aliasing
			hourItem := hourItem
			hourList[hourIndex] = hourItem
		}
		schedule.Hours = hourList
	} else {
		schedule.Hours = nil
	}

	// Minutes
	if source.Minutes != nil {
		minuteList := make([]int, len(source.Minutes))
		for minuteIndex, minuteItem := range source.Minutes {
			// Shadow the loop variable to avoid aliasing
			minuteItem := minuteItem
			minuteList[minuteIndex] = minuteItem
		}
		schedule.Minutes = minuteList
	} else {
		schedule.Minutes = nil
	}

	// MonthDays
	if source.MonthDays != nil {
		monthDayList := make([]int, len(source.MonthDays))
		for monthDayIndex, monthDayItem := range source.MonthDays {
			// Shadow the loop variable to avoid aliasing
			monthDayItem := monthDayItem
			monthDayList[monthDayIndex] = monthDayItem
		}
		schedule.MonthDays = monthDayList
	} else {
		schedule.MonthDays = nil
	}

	// WeekDays
	if source.WeekDays != nil {
		weekDayList := make([]ComputeWeekDay, len(source.WeekDays))
		for weekDayIndex, weekDayItem := range source.WeekDays {
			// Shadow the loop variable to avoid aliasing
			weekDayItem := weekDayItem
			weekDay := genruntime.ToEnum(string(weekDayItem), computeWeekDay_Values)
			weekDayList[weekDayIndex] = weekDay
		}
		schedule.WeekDays = weekDayList
	} else {
		schedule.WeekDays = nil
	}

	// No error
	return nil
}

type ComputeRecurrenceSchedule_STATUS struct {
	// Hours: [Required] List of hours for the schedule.
	Hours []int `json:"hours,omitempty"`

	// Minutes: [Required] List of minutes for the schedule.
	Minutes []int `json:"minutes,omitempty"`

	// MonthDays: List of month days for the schedule
	MonthDays []int `json:"monthDays,omitempty"`

	// WeekDays: List of days for the schedule.
	WeekDays []ComputeWeekDay_STATUS `json:"weekDays,omitempty"`
}

var _ genruntime.FromARMConverter = &ComputeRecurrenceSchedule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (schedule *ComputeRecurrenceSchedule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComputeRecurrenceSchedule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (schedule *ComputeRecurrenceSchedule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComputeRecurrenceSchedule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComputeRecurrenceSchedule_STATUS, got %T", armInput)
	}

	// Set property "Hours":
	for _, item := range typedInput.Hours {
		schedule.Hours = append(schedule.Hours, item)
	}

	// Set property "Minutes":
	for _, item := range typedInput.Minutes {
		schedule.Minutes = append(schedule.Minutes, item)
	}

	// Set property "MonthDays":
	for _, item := range typedInput.MonthDays {
		schedule.MonthDays = append(schedule.MonthDays, item)
	}

	// Set property "WeekDays":
	for _, item := range typedInput.WeekDays {
		var temp string
		temp = string(item)
		schedule.WeekDays = append(schedule.WeekDays, ComputeWeekDay_STATUS(temp))
	}

	// No error
	return nil
}

// AssignProperties_From_ComputeRecurrenceSchedule_STATUS populates our ComputeRecurrenceSchedule_STATUS from the provided source ComputeRecurrenceSchedule_STATUS
func (schedule *ComputeRecurrenceSchedule_STATUS) AssignProperties_From_ComputeRecurrenceSchedule_STATUS(source *storage.ComputeRecurrenceSchedule_STATUS) error {

	// Hours
	if source.Hours != nil {
		hourList := make([]int, len(source.Hours))
		for hourIndex, hourItem := range source.Hours {
			// Shadow the loop variable to avoid aliasing
			hourItem := hourItem
			hourList[hourIndex] = hourItem
		}
		schedule.Hours = hourList
	} else {
		schedule.Hours = nil
	}

	// Minutes
	if source.Minutes != nil {
		minuteList := make([]int, len(source.Minutes))
		for minuteIndex, minuteItem := range source.Minutes {
			// Shadow the loop variable to avoid aliasing
			minuteItem := minuteItem
			minuteList[minuteIndex] = minuteItem
		}
		schedule.Minutes = minuteList
	} else {
		schedule.Minutes = nil
	}

	// MonthDays
	if source.MonthDays != nil {
		monthDayList := make([]int, len(source.MonthDays))
		for monthDayIndex, monthDayItem := range source.MonthDays {
			// Shadow the loop variable to avoid aliasing
			monthDayItem := monthDayItem
			monthDayList[monthDayIndex] = monthDayItem
		}
		schedule.MonthDays = monthDayList
	} else {
		schedule.MonthDays = nil
	}

	// WeekDays
	if source.WeekDays != nil {
		weekDayList := make([]ComputeWeekDay_STATUS, len(source.WeekDays))
		for weekDayIndex, weekDayItem := range source.WeekDays {
			// Shadow the loop variable to avoid aliasing
			weekDayItem := weekDayItem
			weekDayList[weekDayIndex] = genruntime.ToEnum(weekDayItem, computeWeekDay_STATUS_Values)
		}
		schedule.WeekDays = weekDayList
	} else {
		schedule.WeekDays = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ComputeRecurrenceSchedule_STATUS populates the provided destination ComputeRecurrenceSchedule_STATUS from our ComputeRecurrenceSchedule_STATUS
func (schedule *ComputeRecurrenceSchedule_STATUS) AssignProperties_To_ComputeRecurrenceSchedule_STATUS(destination *storage.ComputeRecurrenceSchedule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Hours
	if schedule.Hours != nil {
		hourList := make([]int, len(schedule.Hours))
		for hourIndex, hourItem := range schedule.Hours {
			// Shadow the loop variable to avoid aliasing
			hourItem := hourItem
			hourList[hourIndex] = hourItem
		}
		destination.Hours = hourList
	} else {
		destination.Hours = nil
	}

	// Minutes
	if schedule.Minutes != nil {
		minuteList := make([]int, len(schedule.Minutes))
		for minuteIndex, minuteItem := range schedule.Minutes {
			// Shadow the loop variable to avoid aliasing
			minuteItem := minuteItem
			minuteList[minuteIndex] = minuteItem
		}
		destination.Minutes = minuteList
	} else {
		destination.Minutes = nil
	}

	// MonthDays
	if schedule.MonthDays != nil {
		monthDayList := make([]int, len(schedule.MonthDays))
		for monthDayIndex, monthDayItem := range schedule.MonthDays {
			// Shadow the loop variable to avoid aliasing
			monthDayItem := monthDayItem
			monthDayList[monthDayIndex] = monthDayItem
		}
		destination.MonthDays = monthDayList
	} else {
		destination.MonthDays = nil
	}

	// WeekDays
	if schedule.WeekDays != nil {
		weekDayList := make([]string, len(schedule.WeekDays))
		for weekDayIndex, weekDayItem := range schedule.WeekDays {
			// Shadow the loop variable to avoid aliasing
			weekDayItem := weekDayItem
			weekDayList[weekDayIndex] = string(weekDayItem)
		}
		destination.WeekDays = weekDayList
	} else {
		destination.WeekDays = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The current deployment state of schedule.
// +kubebuilder:validation:Enum={"Completed","Failed","Provisioning"}
type ScheduleProvisioningState string

const (
	ScheduleProvisioningState_Completed    = ScheduleProvisioningState("Completed")
	ScheduleProvisioningState_Failed       = ScheduleProvisioningState("Failed")
	ScheduleProvisioningState_Provisioning = ScheduleProvisioningState("Provisioning")
)

// Mapping from string to ScheduleProvisioningState
var scheduleProvisioningState_Values = map[string]ScheduleProvisioningState{
	"completed":    ScheduleProvisioningState_Completed,
	"failed":       ScheduleProvisioningState_Failed,
	"provisioning": ScheduleProvisioningState_Provisioning,
}

// The current deployment state of schedule.
type ScheduleProvisioningState_STATUS string

const (
	ScheduleProvisioningState_STATUS_Completed    = ScheduleProvisioningState_STATUS("Completed")
	ScheduleProvisioningState_STATUS_Failed       = ScheduleProvisioningState_STATUS("Failed")
	ScheduleProvisioningState_STATUS_Provisioning = ScheduleProvisioningState_STATUS("Provisioning")
)

// Mapping from string to ScheduleProvisioningState_STATUS
var scheduleProvisioningState_STATUS_Values = map[string]ScheduleProvisioningState_STATUS{
	"completed":    ScheduleProvisioningState_STATUS_Completed,
	"failed":       ScheduleProvisioningState_STATUS_Failed,
	"provisioning": ScheduleProvisioningState_STATUS_Provisioning,
}

// Enum of weekday
// +kubebuilder:validation:Enum={"Friday","Monday","Saturday","Sunday","Thursday","Tuesday","Wednesday"}
type ComputeWeekDay string

const (
	ComputeWeekDay_Friday    = ComputeWeekDay("Friday")
	ComputeWeekDay_Monday    = ComputeWeekDay("Monday")
	ComputeWeekDay_Saturday  = ComputeWeekDay("Saturday")
	ComputeWeekDay_Sunday    = ComputeWeekDay("Sunday")
	ComputeWeekDay_Thursday  = ComputeWeekDay("Thursday")
	ComputeWeekDay_Tuesday   = ComputeWeekDay("Tuesday")
	ComputeWeekDay_Wednesday = ComputeWeekDay("Wednesday")
)

// Mapping from string to ComputeWeekDay
var computeWeekDay_Values = map[string]ComputeWeekDay{
	"friday":    ComputeWeekDay_Friday,
	"monday":    ComputeWeekDay_Monday,
	"saturday":  ComputeWeekDay_Saturday,
	"sunday":    ComputeWeekDay_Sunday,
	"thursday":  ComputeWeekDay_Thursday,
	"tuesday":   ComputeWeekDay_Tuesday,
	"wednesday": ComputeWeekDay_Wednesday,
}

// Enum of weekday
type ComputeWeekDay_STATUS string

const (
	ComputeWeekDay_STATUS_Friday    = ComputeWeekDay_STATUS("Friday")
	ComputeWeekDay_STATUS_Monday    = ComputeWeekDay_STATUS("Monday")
	ComputeWeekDay_STATUS_Saturday  = ComputeWeekDay_STATUS("Saturday")
	ComputeWeekDay_STATUS_Sunday    = ComputeWeekDay_STATUS("Sunday")
	ComputeWeekDay_STATUS_Thursday  = ComputeWeekDay_STATUS("Thursday")
	ComputeWeekDay_STATUS_Tuesday   = ComputeWeekDay_STATUS("Tuesday")
	ComputeWeekDay_STATUS_Wednesday = ComputeWeekDay_STATUS("Wednesday")
)

// Mapping from string to ComputeWeekDay_STATUS
var computeWeekDay_STATUS_Values = map[string]ComputeWeekDay_STATUS{
	"friday":    ComputeWeekDay_STATUS_Friday,
	"monday":    ComputeWeekDay_STATUS_Monday,
	"saturday":  ComputeWeekDay_STATUS_Saturday,
	"sunday":    ComputeWeekDay_STATUS_Sunday,
	"thursday":  ComputeWeekDay_STATUS_Thursday,
	"tuesday":   ComputeWeekDay_STATUS_Tuesday,
	"wednesday": ComputeWeekDay_STATUS_Wednesday,
}

func init() {
	SchemeBuilder.Register(&WorkspacesCompute{}, &WorkspacesComputeList{})
}
