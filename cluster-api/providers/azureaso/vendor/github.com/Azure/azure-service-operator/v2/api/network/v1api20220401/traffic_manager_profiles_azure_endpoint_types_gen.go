// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20220401

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/network/v1api20220401/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/network/v1api20220401/storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /trafficmanager/resource-manager/Microsoft.Network/stable/2022-04-01/trafficmanager.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficmanagerprofiles/{profileName}/AzureEndpoints/{endpointName}
type TrafficManagerProfilesAzureEndpoint struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              TrafficManagerProfilesAzureEndpoint_Spec   `json:"spec,omitempty"`
	Status            TrafficManagerProfilesAzureEndpoint_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &TrafficManagerProfilesAzureEndpoint{}

// GetConditions returns the conditions of the resource
func (endpoint *TrafficManagerProfilesAzureEndpoint) GetConditions() conditions.Conditions {
	return endpoint.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (endpoint *TrafficManagerProfilesAzureEndpoint) SetConditions(conditions conditions.Conditions) {
	endpoint.Status.Conditions = conditions
}

var _ conversion.Convertible = &TrafficManagerProfilesAzureEndpoint{}

// ConvertFrom populates our TrafficManagerProfilesAzureEndpoint from the provided hub TrafficManagerProfilesAzureEndpoint
func (endpoint *TrafficManagerProfilesAzureEndpoint) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.TrafficManagerProfilesAzureEndpoint)
	if !ok {
		return fmt.Errorf("expected network/v1api20220401/storage/TrafficManagerProfilesAzureEndpoint but received %T instead", hub)
	}

	return endpoint.AssignProperties_From_TrafficManagerProfilesAzureEndpoint(source)
}

// ConvertTo populates the provided hub TrafficManagerProfilesAzureEndpoint from our TrafficManagerProfilesAzureEndpoint
func (endpoint *TrafficManagerProfilesAzureEndpoint) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.TrafficManagerProfilesAzureEndpoint)
	if !ok {
		return fmt.Errorf("expected network/v1api20220401/storage/TrafficManagerProfilesAzureEndpoint but received %T instead", hub)
	}

	return endpoint.AssignProperties_To_TrafficManagerProfilesAzureEndpoint(destination)
}

// +kubebuilder:webhook:path=/mutate-network-azure-com-v1api20220401-trafficmanagerprofilesazureendpoint,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=network.azure.com,resources=trafficmanagerprofilesazureendpoints,verbs=create;update,versions=v1api20220401,name=default.v1api20220401.trafficmanagerprofilesazureendpoints.network.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &TrafficManagerProfilesAzureEndpoint{}

// Default applies defaults to the TrafficManagerProfilesAzureEndpoint resource
func (endpoint *TrafficManagerProfilesAzureEndpoint) Default() {
	endpoint.defaultImpl()
	var temp any = endpoint
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (endpoint *TrafficManagerProfilesAzureEndpoint) defaultAzureName() {
	if endpoint.Spec.AzureName == "" {
		endpoint.Spec.AzureName = endpoint.Name
	}
}

// defaultImpl applies the code generated defaults to the TrafficManagerProfilesAzureEndpoint resource
func (endpoint *TrafficManagerProfilesAzureEndpoint) defaultImpl() { endpoint.defaultAzureName() }

var _ configmaps.Exporter = &TrafficManagerProfilesAzureEndpoint{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (endpoint *TrafficManagerProfilesAzureEndpoint) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if endpoint.Spec.OperatorSpec == nil {
		return nil
	}
	return endpoint.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &TrafficManagerProfilesAzureEndpoint{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (endpoint *TrafficManagerProfilesAzureEndpoint) SecretDestinationExpressions() []*core.DestinationExpression {
	if endpoint.Spec.OperatorSpec == nil {
		return nil
	}
	return endpoint.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &TrafficManagerProfilesAzureEndpoint{}

// InitializeSpec initializes the spec for this resource from the given status
func (endpoint *TrafficManagerProfilesAzureEndpoint) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*TrafficManagerProfilesAzureEndpoint_STATUS); ok {
		return endpoint.Spec.Initialize_From_TrafficManagerProfilesAzureEndpoint_STATUS(s)
	}

	return fmt.Errorf("expected Status of type TrafficManagerProfilesAzureEndpoint_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &TrafficManagerProfilesAzureEndpoint{}

// AzureName returns the Azure name of the resource
func (endpoint *TrafficManagerProfilesAzureEndpoint) AzureName() string {
	return endpoint.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2022-04-01"
func (endpoint TrafficManagerProfilesAzureEndpoint) GetAPIVersion() string {
	return "2022-04-01"
}

// GetResourceScope returns the scope of the resource
func (endpoint *TrafficManagerProfilesAzureEndpoint) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (endpoint *TrafficManagerProfilesAzureEndpoint) GetSpec() genruntime.ConvertibleSpec {
	return &endpoint.Spec
}

// GetStatus returns the status of this resource
func (endpoint *TrafficManagerProfilesAzureEndpoint) GetStatus() genruntime.ConvertibleStatus {
	return &endpoint.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (endpoint *TrafficManagerProfilesAzureEndpoint) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Network/trafficmanagerprofiles/AzureEndpoints"
func (endpoint *TrafficManagerProfilesAzureEndpoint) GetType() string {
	return "Microsoft.Network/trafficmanagerprofiles/AzureEndpoints"
}

// NewEmptyStatus returns a new empty (blank) status
func (endpoint *TrafficManagerProfilesAzureEndpoint) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &TrafficManagerProfilesAzureEndpoint_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (endpoint *TrafficManagerProfilesAzureEndpoint) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(endpoint.Spec)
	return endpoint.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (endpoint *TrafficManagerProfilesAzureEndpoint) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*TrafficManagerProfilesAzureEndpoint_STATUS); ok {
		endpoint.Status = *st
		return nil
	}

	// Convert status to required version
	var st TrafficManagerProfilesAzureEndpoint_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	endpoint.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-network-azure-com-v1api20220401-trafficmanagerprofilesazureendpoint,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=network.azure.com,resources=trafficmanagerprofilesazureendpoints,verbs=create;update,versions=v1api20220401,name=validate.v1api20220401.trafficmanagerprofilesazureendpoints.network.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &TrafficManagerProfilesAzureEndpoint{}

// ValidateCreate validates the creation of the resource
func (endpoint *TrafficManagerProfilesAzureEndpoint) ValidateCreate() (admission.Warnings, error) {
	validations := endpoint.createValidations()
	var temp any = endpoint
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	return genruntime.ValidateCreate(validations)
}

// ValidateDelete validates the deletion of the resource
func (endpoint *TrafficManagerProfilesAzureEndpoint) ValidateDelete() (admission.Warnings, error) {
	validations := endpoint.deleteValidations()
	var temp any = endpoint
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	return genruntime.ValidateDelete(validations)
}

// ValidateUpdate validates an update of the resource
func (endpoint *TrafficManagerProfilesAzureEndpoint) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	validations := endpoint.updateValidations()
	var temp any = endpoint
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	return genruntime.ValidateUpdate(old, validations)
}

// createValidations validates the creation of the resource
func (endpoint *TrafficManagerProfilesAzureEndpoint) createValidations() []func() (admission.Warnings, error) {
	return []func() (admission.Warnings, error){endpoint.validateResourceReferences, endpoint.validateOwnerReference, endpoint.validateSecretDestinations, endpoint.validateConfigMapDestinations}
}

// deleteValidations validates the deletion of the resource
func (endpoint *TrafficManagerProfilesAzureEndpoint) deleteValidations() []func() (admission.Warnings, error) {
	return nil
}

// updateValidations validates the update of the resource
func (endpoint *TrafficManagerProfilesAzureEndpoint) updateValidations() []func(old runtime.Object) (admission.Warnings, error) {
	return []func(old runtime.Object) (admission.Warnings, error){
		func(old runtime.Object) (admission.Warnings, error) {
			return endpoint.validateResourceReferences()
		},
		endpoint.validateWriteOnceProperties,
		func(old runtime.Object) (admission.Warnings, error) {
			return endpoint.validateOwnerReference()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return endpoint.validateSecretDestinations()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return endpoint.validateConfigMapDestinations()
		},
	}
}

// validateConfigMapDestinations validates there are no colliding genruntime.ConfigMapDestinations
func (endpoint *TrafficManagerProfilesAzureEndpoint) validateConfigMapDestinations() (admission.Warnings, error) {
	if endpoint.Spec.OperatorSpec == nil {
		return nil, nil
	}
	return configmaps.ValidateDestinations(endpoint, nil, endpoint.Spec.OperatorSpec.ConfigMapExpressions)
}

// validateOwnerReference validates the owner field
func (endpoint *TrafficManagerProfilesAzureEndpoint) validateOwnerReference() (admission.Warnings, error) {
	return genruntime.ValidateOwner(endpoint)
}

// validateResourceReferences validates all resource references
func (endpoint *TrafficManagerProfilesAzureEndpoint) validateResourceReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindResourceReferences(&endpoint.Spec)
	if err != nil {
		return nil, err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateSecretDestinations validates there are no colliding genruntime.SecretDestination's
func (endpoint *TrafficManagerProfilesAzureEndpoint) validateSecretDestinations() (admission.Warnings, error) {
	if endpoint.Spec.OperatorSpec == nil {
		return nil, nil
	}
	return secrets.ValidateDestinations(endpoint, nil, endpoint.Spec.OperatorSpec.SecretExpressions)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (endpoint *TrafficManagerProfilesAzureEndpoint) validateWriteOnceProperties(old runtime.Object) (admission.Warnings, error) {
	oldObj, ok := old.(*TrafficManagerProfilesAzureEndpoint)
	if !ok {
		return nil, nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, endpoint)
}

// AssignProperties_From_TrafficManagerProfilesAzureEndpoint populates our TrafficManagerProfilesAzureEndpoint from the provided source TrafficManagerProfilesAzureEndpoint
func (endpoint *TrafficManagerProfilesAzureEndpoint) AssignProperties_From_TrafficManagerProfilesAzureEndpoint(source *storage.TrafficManagerProfilesAzureEndpoint) error {

	// ObjectMeta
	endpoint.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec TrafficManagerProfilesAzureEndpoint_Spec
	err := spec.AssignProperties_From_TrafficManagerProfilesAzureEndpoint_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_TrafficManagerProfilesAzureEndpoint_Spec() to populate field Spec")
	}
	endpoint.Spec = spec

	// Status
	var status TrafficManagerProfilesAzureEndpoint_STATUS
	err = status.AssignProperties_From_TrafficManagerProfilesAzureEndpoint_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_TrafficManagerProfilesAzureEndpoint_STATUS() to populate field Status")
	}
	endpoint.Status = status

	// No error
	return nil
}

// AssignProperties_To_TrafficManagerProfilesAzureEndpoint populates the provided destination TrafficManagerProfilesAzureEndpoint from our TrafficManagerProfilesAzureEndpoint
func (endpoint *TrafficManagerProfilesAzureEndpoint) AssignProperties_To_TrafficManagerProfilesAzureEndpoint(destination *storage.TrafficManagerProfilesAzureEndpoint) error {

	// ObjectMeta
	destination.ObjectMeta = *endpoint.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.TrafficManagerProfilesAzureEndpoint_Spec
	err := endpoint.Spec.AssignProperties_To_TrafficManagerProfilesAzureEndpoint_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_TrafficManagerProfilesAzureEndpoint_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.TrafficManagerProfilesAzureEndpoint_STATUS
	err = endpoint.Status.AssignProperties_To_TrafficManagerProfilesAzureEndpoint_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_TrafficManagerProfilesAzureEndpoint_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (endpoint *TrafficManagerProfilesAzureEndpoint) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: endpoint.Spec.OriginalVersion(),
		Kind:    "TrafficManagerProfilesAzureEndpoint",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /trafficmanager/resource-manager/Microsoft.Network/stable/2022-04-01/trafficmanager.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficmanagerprofiles/{profileName}/AzureEndpoints/{endpointName}
type TrafficManagerProfilesAzureEndpointList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []TrafficManagerProfilesAzureEndpoint `json:"items"`
}

type TrafficManagerProfilesAzureEndpoint_Spec struct {
	// AlwaysServe: If Always Serve is enabled, probing for endpoint health will be disabled and endpoints will be included in
	// the traffic routing method.
	AlwaysServe *EndpointProperties_AlwaysServe `json:"alwaysServe,omitempty"`

	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// CustomHeaders: List of custom headers.
	CustomHeaders []EndpointProperties_CustomHeaders `json:"customHeaders,omitempty"`

	// EndpointLocation: Specifies the location of the external or nested endpoints when using the 'Performance' traffic
	// routing method.
	EndpointLocation *string `json:"endpointLocation,omitempty"`

	// EndpointMonitorStatus: The monitoring status of the endpoint.
	EndpointMonitorStatus *EndpointProperties_EndpointMonitorStatus `json:"endpointMonitorStatus,omitempty"`

	// EndpointStatus: The status of the endpoint. If the endpoint is Enabled, it is probed for endpoint health and is included
	// in the traffic routing method.
	EndpointStatus *EndpointProperties_EndpointStatus `json:"endpointStatus,omitempty"`

	// GeoMapping: The list of countries/regions mapped to this endpoint when using the 'Geographic' traffic routing method.
	// Please consult Traffic Manager Geographic documentation for a full list of accepted values.
	GeoMapping []string `json:"geoMapping,omitempty"`

	// MinChildEndpoints: The minimum number of endpoints that must be available in the child profile in order for the parent
	// profile to be considered available. Only applicable to endpoint of type 'NestedEndpoints'.
	MinChildEndpoints *int `json:"minChildEndpoints,omitempty"`

	// MinChildEndpointsIPv4: The minimum number of IPv4 (DNS record type A) endpoints that must be available in the child
	// profile in order for the parent profile to be considered available. Only applicable to endpoint of type
	// 'NestedEndpoints'.
	MinChildEndpointsIPv4 *int `json:"minChildEndpointsIPv4,omitempty"`

	// MinChildEndpointsIPv6: The minimum number of IPv6 (DNS record type AAAA) endpoints that must be available in the child
	// profile in order for the parent profile to be considered available. Only applicable to endpoint of type
	// 'NestedEndpoints'.
	MinChildEndpointsIPv6 *int `json:"minChildEndpointsIPv6,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *TrafficManagerProfilesAzureEndpointOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a network.azure.com/TrafficManagerProfile resource
	Owner *genruntime.KnownResourceReference `group:"network.azure.com" json:"owner,omitempty" kind:"TrafficManagerProfile"`

	// Priority: The priority of this endpoint when using the 'Priority' traffic routing method. Possible values are from 1 to
	// 1000, lower values represent higher priority. This is an optional parameter.  If specified, it must be specified on all
	// endpoints, and no two endpoints can share the same priority value.
	Priority *int `json:"priority,omitempty"`

	// Subnets: The list of subnets, IP addresses, and/or address ranges mapped to this endpoint when using the 'Subnet'
	// traffic routing method. An empty list will match all ranges not covered by other endpoints.
	Subnets []EndpointProperties_Subnets `json:"subnets,omitempty"`

	// Target: The fully-qualified DNS name or IP address of the endpoint. Traffic Manager returns this value in DNS responses
	// to direct traffic to this endpoint.
	Target *string `json:"target,omitempty"`

	// TargetResourceReference: The Azure Resource URI of the of the endpoint. Not applicable to endpoints of type
	// 'ExternalEndpoints'.
	TargetResourceReference *genruntime.ResourceReference `armReference:"TargetResourceId" json:"targetResourceReference,omitempty"`

	// Type: The type of the resource. Ex- Microsoft.Network/trafficManagerProfiles.
	Type *string `json:"type,omitempty"`

	// Weight: The weight of this endpoint when using the 'Weighted' traffic routing method. Possible values are from 1 to 1000.
	Weight *int `json:"weight,omitempty"`
}

var _ genruntime.ARMTransformer = &TrafficManagerProfilesAzureEndpoint_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (endpoint *TrafficManagerProfilesAzureEndpoint_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if endpoint == nil {
		return nil, nil
	}
	result := &arm.TrafficManagerProfilesAzureEndpoint_Spec{}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if endpoint.AlwaysServe != nil ||
		endpoint.CustomHeaders != nil ||
		endpoint.EndpointLocation != nil ||
		endpoint.EndpointMonitorStatus != nil ||
		endpoint.EndpointStatus != nil ||
		endpoint.GeoMapping != nil ||
		endpoint.MinChildEndpoints != nil ||
		endpoint.MinChildEndpointsIPv4 != nil ||
		endpoint.MinChildEndpointsIPv6 != nil ||
		endpoint.Priority != nil ||
		endpoint.Subnets != nil ||
		endpoint.Target != nil ||
		endpoint.TargetResourceReference != nil ||
		endpoint.Weight != nil {
		result.Properties = &arm.EndpointProperties{}
	}
	if endpoint.AlwaysServe != nil {
		var temp string
		temp = string(*endpoint.AlwaysServe)
		alwaysServe := arm.EndpointProperties_AlwaysServe(temp)
		result.Properties.AlwaysServe = &alwaysServe
	}
	for _, item := range endpoint.CustomHeaders {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.CustomHeaders = append(result.Properties.CustomHeaders, *item_ARM.(*arm.EndpointProperties_CustomHeaders))
	}
	if endpoint.EndpointLocation != nil {
		endpointLocation := *endpoint.EndpointLocation
		result.Properties.EndpointLocation = &endpointLocation
	}
	if endpoint.EndpointMonitorStatus != nil {
		var temp string
		temp = string(*endpoint.EndpointMonitorStatus)
		endpointMonitorStatus := arm.EndpointProperties_EndpointMonitorStatus(temp)
		result.Properties.EndpointMonitorStatus = &endpointMonitorStatus
	}
	if endpoint.EndpointStatus != nil {
		var temp string
		temp = string(*endpoint.EndpointStatus)
		endpointStatus := arm.EndpointProperties_EndpointStatus(temp)
		result.Properties.EndpointStatus = &endpointStatus
	}
	for _, item := range endpoint.GeoMapping {
		result.Properties.GeoMapping = append(result.Properties.GeoMapping, item)
	}
	if endpoint.MinChildEndpoints != nil {
		minChildEndpoints := *endpoint.MinChildEndpoints
		result.Properties.MinChildEndpoints = &minChildEndpoints
	}
	if endpoint.MinChildEndpointsIPv4 != nil {
		minChildEndpointsIPv4 := *endpoint.MinChildEndpointsIPv4
		result.Properties.MinChildEndpointsIPv4 = &minChildEndpointsIPv4
	}
	if endpoint.MinChildEndpointsIPv6 != nil {
		minChildEndpointsIPv6 := *endpoint.MinChildEndpointsIPv6
		result.Properties.MinChildEndpointsIPv6 = &minChildEndpointsIPv6
	}
	if endpoint.Priority != nil {
		priority := *endpoint.Priority
		result.Properties.Priority = &priority
	}
	for _, item := range endpoint.Subnets {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.Subnets = append(result.Properties.Subnets, *item_ARM.(*arm.EndpointProperties_Subnets))
	}
	if endpoint.Target != nil {
		target := *endpoint.Target
		result.Properties.Target = &target
	}
	if endpoint.TargetResourceReference != nil {
		targetResourceIdARMID, err := resolved.ResolvedReferences.Lookup(*endpoint.TargetResourceReference)
		if err != nil {
			return nil, err
		}
		targetResourceId := targetResourceIdARMID
		result.Properties.TargetResourceId = &targetResourceId
	}
	if endpoint.Weight != nil {
		weight := *endpoint.Weight
		result.Properties.Weight = &weight
	}

	// Set property "Type":
	if endpoint.Type != nil {
		typeVar := *endpoint.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (endpoint *TrafficManagerProfilesAzureEndpoint_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TrafficManagerProfilesAzureEndpoint_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (endpoint *TrafficManagerProfilesAzureEndpoint_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TrafficManagerProfilesAzureEndpoint_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TrafficManagerProfilesAzureEndpoint_Spec, got %T", armInput)
	}

	// Set property "AlwaysServe":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AlwaysServe != nil {
			var temp string
			temp = string(*typedInput.Properties.AlwaysServe)
			alwaysServe := EndpointProperties_AlwaysServe(temp)
			endpoint.AlwaysServe = &alwaysServe
		}
	}

	// Set property "AzureName":
	endpoint.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "CustomHeaders":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.CustomHeaders {
			var item1 EndpointProperties_CustomHeaders
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.CustomHeaders = append(endpoint.CustomHeaders, item1)
		}
	}

	// Set property "EndpointLocation":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EndpointLocation != nil {
			endpointLocation := *typedInput.Properties.EndpointLocation
			endpoint.EndpointLocation = &endpointLocation
		}
	}

	// Set property "EndpointMonitorStatus":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EndpointMonitorStatus != nil {
			var temp string
			temp = string(*typedInput.Properties.EndpointMonitorStatus)
			endpointMonitorStatus := EndpointProperties_EndpointMonitorStatus(temp)
			endpoint.EndpointMonitorStatus = &endpointMonitorStatus
		}
	}

	// Set property "EndpointStatus":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EndpointStatus != nil {
			var temp string
			temp = string(*typedInput.Properties.EndpointStatus)
			endpointStatus := EndpointProperties_EndpointStatus(temp)
			endpoint.EndpointStatus = &endpointStatus
		}
	}

	// Set property "GeoMapping":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.GeoMapping {
			endpoint.GeoMapping = append(endpoint.GeoMapping, item)
		}
	}

	// Set property "MinChildEndpoints":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinChildEndpoints != nil {
			minChildEndpoints := *typedInput.Properties.MinChildEndpoints
			endpoint.MinChildEndpoints = &minChildEndpoints
		}
	}

	// Set property "MinChildEndpointsIPv4":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinChildEndpointsIPv4 != nil {
			minChildEndpointsIPv4 := *typedInput.Properties.MinChildEndpointsIPv4
			endpoint.MinChildEndpointsIPv4 = &minChildEndpointsIPv4
		}
	}

	// Set property "MinChildEndpointsIPv6":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinChildEndpointsIPv6 != nil {
			minChildEndpointsIPv6 := *typedInput.Properties.MinChildEndpointsIPv6
			endpoint.MinChildEndpointsIPv6 = &minChildEndpointsIPv6
		}
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	endpoint.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "Priority":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Priority != nil {
			priority := *typedInput.Properties.Priority
			endpoint.Priority = &priority
		}
	}

	// Set property "Subnets":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Subnets {
			var item1 EndpointProperties_Subnets
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.Subnets = append(endpoint.Subnets, item1)
		}
	}

	// Set property "Target":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Target != nil {
			target := *typedInput.Properties.Target
			endpoint.Target = &target
		}
	}

	// no assignment for property "TargetResourceReference"

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		endpoint.Type = &typeVar
	}

	// Set property "Weight":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Weight != nil {
			weight := *typedInput.Properties.Weight
			endpoint.Weight = &weight
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &TrafficManagerProfilesAzureEndpoint_Spec{}

// ConvertSpecFrom populates our TrafficManagerProfilesAzureEndpoint_Spec from the provided source
func (endpoint *TrafficManagerProfilesAzureEndpoint_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.TrafficManagerProfilesAzureEndpoint_Spec)
	if ok {
		// Populate our instance from source
		return endpoint.AssignProperties_From_TrafficManagerProfilesAzureEndpoint_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.TrafficManagerProfilesAzureEndpoint_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = endpoint.AssignProperties_From_TrafficManagerProfilesAzureEndpoint_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our TrafficManagerProfilesAzureEndpoint_Spec
func (endpoint *TrafficManagerProfilesAzureEndpoint_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.TrafficManagerProfilesAzureEndpoint_Spec)
	if ok {
		// Populate destination from our instance
		return endpoint.AssignProperties_To_TrafficManagerProfilesAzureEndpoint_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.TrafficManagerProfilesAzureEndpoint_Spec{}
	err := endpoint.AssignProperties_To_TrafficManagerProfilesAzureEndpoint_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_TrafficManagerProfilesAzureEndpoint_Spec populates our TrafficManagerProfilesAzureEndpoint_Spec from the provided source TrafficManagerProfilesAzureEndpoint_Spec
func (endpoint *TrafficManagerProfilesAzureEndpoint_Spec) AssignProperties_From_TrafficManagerProfilesAzureEndpoint_Spec(source *storage.TrafficManagerProfilesAzureEndpoint_Spec) error {

	// AlwaysServe
	if source.AlwaysServe != nil {
		alwaysServe := *source.AlwaysServe
		alwaysServeTemp := genruntime.ToEnum(alwaysServe, endpointProperties_AlwaysServe_Values)
		endpoint.AlwaysServe = &alwaysServeTemp
	} else {
		endpoint.AlwaysServe = nil
	}

	// AzureName
	endpoint.AzureName = source.AzureName

	// CustomHeaders
	if source.CustomHeaders != nil {
		customHeaderList := make([]EndpointProperties_CustomHeaders, len(source.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range source.CustomHeaders {
			// Shadow the loop variable to avoid aliasing
			customHeaderItem := customHeaderItem
			var customHeader EndpointProperties_CustomHeaders
			err := customHeader.AssignProperties_From_EndpointProperties_CustomHeaders(&customHeaderItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_EndpointProperties_CustomHeaders() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		endpoint.CustomHeaders = customHeaderList
	} else {
		endpoint.CustomHeaders = nil
	}

	// EndpointLocation
	endpoint.EndpointLocation = genruntime.ClonePointerToString(source.EndpointLocation)

	// EndpointMonitorStatus
	if source.EndpointMonitorStatus != nil {
		endpointMonitorStatus := *source.EndpointMonitorStatus
		endpointMonitorStatusTemp := genruntime.ToEnum(endpointMonitorStatus, endpointProperties_EndpointMonitorStatus_Values)
		endpoint.EndpointMonitorStatus = &endpointMonitorStatusTemp
	} else {
		endpoint.EndpointMonitorStatus = nil
	}

	// EndpointStatus
	if source.EndpointStatus != nil {
		endpointStatus := *source.EndpointStatus
		endpointStatusTemp := genruntime.ToEnum(endpointStatus, endpointProperties_EndpointStatus_Values)
		endpoint.EndpointStatus = &endpointStatusTemp
	} else {
		endpoint.EndpointStatus = nil
	}

	// GeoMapping
	endpoint.GeoMapping = genruntime.CloneSliceOfString(source.GeoMapping)

	// MinChildEndpoints
	endpoint.MinChildEndpoints = genruntime.ClonePointerToInt(source.MinChildEndpoints)

	// MinChildEndpointsIPv4
	endpoint.MinChildEndpointsIPv4 = genruntime.ClonePointerToInt(source.MinChildEndpointsIPv4)

	// MinChildEndpointsIPv6
	endpoint.MinChildEndpointsIPv6 = genruntime.ClonePointerToInt(source.MinChildEndpointsIPv6)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec TrafficManagerProfilesAzureEndpointOperatorSpec
		err := operatorSpec.AssignProperties_From_TrafficManagerProfilesAzureEndpointOperatorSpec(source.OperatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_TrafficManagerProfilesAzureEndpointOperatorSpec() to populate field OperatorSpec")
		}
		endpoint.OperatorSpec = &operatorSpec
	} else {
		endpoint.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		endpoint.Owner = &owner
	} else {
		endpoint.Owner = nil
	}

	// Priority
	endpoint.Priority = genruntime.ClonePointerToInt(source.Priority)

	// Subnets
	if source.Subnets != nil {
		subnetList := make([]EndpointProperties_Subnets, len(source.Subnets))
		for subnetIndex, subnetItem := range source.Subnets {
			// Shadow the loop variable to avoid aliasing
			subnetItem := subnetItem
			var subnet EndpointProperties_Subnets
			err := subnet.AssignProperties_From_EndpointProperties_Subnets(&subnetItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_EndpointProperties_Subnets() to populate field Subnets")
			}
			subnetList[subnetIndex] = subnet
		}
		endpoint.Subnets = subnetList
	} else {
		endpoint.Subnets = nil
	}

	// Target
	endpoint.Target = genruntime.ClonePointerToString(source.Target)

	// TargetResourceReference
	if source.TargetResourceReference != nil {
		targetResourceReference := source.TargetResourceReference.Copy()
		endpoint.TargetResourceReference = &targetResourceReference
	} else {
		endpoint.TargetResourceReference = nil
	}

	// Type
	endpoint.Type = genruntime.ClonePointerToString(source.Type)

	// Weight
	endpoint.Weight = genruntime.ClonePointerToInt(source.Weight)

	// No error
	return nil
}

// AssignProperties_To_TrafficManagerProfilesAzureEndpoint_Spec populates the provided destination TrafficManagerProfilesAzureEndpoint_Spec from our TrafficManagerProfilesAzureEndpoint_Spec
func (endpoint *TrafficManagerProfilesAzureEndpoint_Spec) AssignProperties_To_TrafficManagerProfilesAzureEndpoint_Spec(destination *storage.TrafficManagerProfilesAzureEndpoint_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AlwaysServe
	if endpoint.AlwaysServe != nil {
		alwaysServe := string(*endpoint.AlwaysServe)
		destination.AlwaysServe = &alwaysServe
	} else {
		destination.AlwaysServe = nil
	}

	// AzureName
	destination.AzureName = endpoint.AzureName

	// CustomHeaders
	if endpoint.CustomHeaders != nil {
		customHeaderList := make([]storage.EndpointProperties_CustomHeaders, len(endpoint.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range endpoint.CustomHeaders {
			// Shadow the loop variable to avoid aliasing
			customHeaderItem := customHeaderItem
			var customHeader storage.EndpointProperties_CustomHeaders
			err := customHeaderItem.AssignProperties_To_EndpointProperties_CustomHeaders(&customHeader)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_EndpointProperties_CustomHeaders() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		destination.CustomHeaders = customHeaderList
	} else {
		destination.CustomHeaders = nil
	}

	// EndpointLocation
	destination.EndpointLocation = genruntime.ClonePointerToString(endpoint.EndpointLocation)

	// EndpointMonitorStatus
	if endpoint.EndpointMonitorStatus != nil {
		endpointMonitorStatus := string(*endpoint.EndpointMonitorStatus)
		destination.EndpointMonitorStatus = &endpointMonitorStatus
	} else {
		destination.EndpointMonitorStatus = nil
	}

	// EndpointStatus
	if endpoint.EndpointStatus != nil {
		endpointStatus := string(*endpoint.EndpointStatus)
		destination.EndpointStatus = &endpointStatus
	} else {
		destination.EndpointStatus = nil
	}

	// GeoMapping
	destination.GeoMapping = genruntime.CloneSliceOfString(endpoint.GeoMapping)

	// MinChildEndpoints
	destination.MinChildEndpoints = genruntime.ClonePointerToInt(endpoint.MinChildEndpoints)

	// MinChildEndpointsIPv4
	destination.MinChildEndpointsIPv4 = genruntime.ClonePointerToInt(endpoint.MinChildEndpointsIPv4)

	// MinChildEndpointsIPv6
	destination.MinChildEndpointsIPv6 = genruntime.ClonePointerToInt(endpoint.MinChildEndpointsIPv6)

	// OperatorSpec
	if endpoint.OperatorSpec != nil {
		var operatorSpec storage.TrafficManagerProfilesAzureEndpointOperatorSpec
		err := endpoint.OperatorSpec.AssignProperties_To_TrafficManagerProfilesAzureEndpointOperatorSpec(&operatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_TrafficManagerProfilesAzureEndpointOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = endpoint.OriginalVersion()

	// Owner
	if endpoint.Owner != nil {
		owner := endpoint.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Priority
	destination.Priority = genruntime.ClonePointerToInt(endpoint.Priority)

	// Subnets
	if endpoint.Subnets != nil {
		subnetList := make([]storage.EndpointProperties_Subnets, len(endpoint.Subnets))
		for subnetIndex, subnetItem := range endpoint.Subnets {
			// Shadow the loop variable to avoid aliasing
			subnetItem := subnetItem
			var subnet storage.EndpointProperties_Subnets
			err := subnetItem.AssignProperties_To_EndpointProperties_Subnets(&subnet)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_EndpointProperties_Subnets() to populate field Subnets")
			}
			subnetList[subnetIndex] = subnet
		}
		destination.Subnets = subnetList
	} else {
		destination.Subnets = nil
	}

	// Target
	destination.Target = genruntime.ClonePointerToString(endpoint.Target)

	// TargetResourceReference
	if endpoint.TargetResourceReference != nil {
		targetResourceReference := endpoint.TargetResourceReference.Copy()
		destination.TargetResourceReference = &targetResourceReference
	} else {
		destination.TargetResourceReference = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(endpoint.Type)

	// Weight
	destination.Weight = genruntime.ClonePointerToInt(endpoint.Weight)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_TrafficManagerProfilesAzureEndpoint_STATUS populates our TrafficManagerProfilesAzureEndpoint_Spec from the provided source TrafficManagerProfilesAzureEndpoint_STATUS
func (endpoint *TrafficManagerProfilesAzureEndpoint_Spec) Initialize_From_TrafficManagerProfilesAzureEndpoint_STATUS(source *TrafficManagerProfilesAzureEndpoint_STATUS) error {

	// AlwaysServe
	if source.AlwaysServe != nil {
		alwaysServe := genruntime.ToEnum(string(*source.AlwaysServe), endpointProperties_AlwaysServe_Values)
		endpoint.AlwaysServe = &alwaysServe
	} else {
		endpoint.AlwaysServe = nil
	}

	// CustomHeaders
	if source.CustomHeaders != nil {
		customHeaderList := make([]EndpointProperties_CustomHeaders, len(source.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range source.CustomHeaders {
			// Shadow the loop variable to avoid aliasing
			customHeaderItem := customHeaderItem
			var customHeader EndpointProperties_CustomHeaders
			err := customHeader.Initialize_From_EndpointProperties_CustomHeaders_STATUS(&customHeaderItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_EndpointProperties_CustomHeaders_STATUS() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		endpoint.CustomHeaders = customHeaderList
	} else {
		endpoint.CustomHeaders = nil
	}

	// EndpointLocation
	endpoint.EndpointLocation = genruntime.ClonePointerToString(source.EndpointLocation)

	// EndpointMonitorStatus
	if source.EndpointMonitorStatus != nil {
		endpointMonitorStatus := genruntime.ToEnum(string(*source.EndpointMonitorStatus), endpointProperties_EndpointMonitorStatus_Values)
		endpoint.EndpointMonitorStatus = &endpointMonitorStatus
	} else {
		endpoint.EndpointMonitorStatus = nil
	}

	// EndpointStatus
	if source.EndpointStatus != nil {
		endpointStatus := genruntime.ToEnum(string(*source.EndpointStatus), endpointProperties_EndpointStatus_Values)
		endpoint.EndpointStatus = &endpointStatus
	} else {
		endpoint.EndpointStatus = nil
	}

	// GeoMapping
	endpoint.GeoMapping = genruntime.CloneSliceOfString(source.GeoMapping)

	// MinChildEndpoints
	endpoint.MinChildEndpoints = genruntime.ClonePointerToInt(source.MinChildEndpoints)

	// MinChildEndpointsIPv4
	endpoint.MinChildEndpointsIPv4 = genruntime.ClonePointerToInt(source.MinChildEndpointsIPv4)

	// MinChildEndpointsIPv6
	endpoint.MinChildEndpointsIPv6 = genruntime.ClonePointerToInt(source.MinChildEndpointsIPv6)

	// Priority
	endpoint.Priority = genruntime.ClonePointerToInt(source.Priority)

	// Subnets
	if source.Subnets != nil {
		subnetList := make([]EndpointProperties_Subnets, len(source.Subnets))
		for subnetIndex, subnetItem := range source.Subnets {
			// Shadow the loop variable to avoid aliasing
			subnetItem := subnetItem
			var subnet EndpointProperties_Subnets
			err := subnet.Initialize_From_EndpointProperties_Subnets_STATUS(&subnetItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_EndpointProperties_Subnets_STATUS() to populate field Subnets")
			}
			subnetList[subnetIndex] = subnet
		}
		endpoint.Subnets = subnetList
	} else {
		endpoint.Subnets = nil
	}

	// Target
	endpoint.Target = genruntime.ClonePointerToString(source.Target)

	// TargetResourceReference
	if source.TargetResourceId != nil {
		targetResourceReference := genruntime.CreateResourceReferenceFromARMID(*source.TargetResourceId)
		endpoint.TargetResourceReference = &targetResourceReference
	} else {
		endpoint.TargetResourceReference = nil
	}

	// Type
	endpoint.Type = genruntime.ClonePointerToString(source.Type)

	// Weight
	endpoint.Weight = genruntime.ClonePointerToInt(source.Weight)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (endpoint *TrafficManagerProfilesAzureEndpoint_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (endpoint *TrafficManagerProfilesAzureEndpoint_Spec) SetAzureName(azureName string) {
	endpoint.AzureName = azureName
}

type TrafficManagerProfilesAzureEndpoint_STATUS struct {
	// AlwaysServe: If Always Serve is enabled, probing for endpoint health will be disabled and endpoints will be included in
	// the traffic routing method.
	AlwaysServe *EndpointProperties_AlwaysServe_STATUS `json:"alwaysServe,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// CustomHeaders: List of custom headers.
	CustomHeaders []EndpointProperties_CustomHeaders_STATUS `json:"customHeaders,omitempty"`

	// EndpointLocation: Specifies the location of the external or nested endpoints when using the 'Performance' traffic
	// routing method.
	EndpointLocation *string `json:"endpointLocation,omitempty"`

	// EndpointMonitorStatus: The monitoring status of the endpoint.
	EndpointMonitorStatus *EndpointProperties_EndpointMonitorStatus_STATUS `json:"endpointMonitorStatus,omitempty"`

	// EndpointStatus: The status of the endpoint. If the endpoint is Enabled, it is probed for endpoint health and is included
	// in the traffic routing method.
	EndpointStatus *EndpointProperties_EndpointStatus_STATUS `json:"endpointStatus,omitempty"`

	// GeoMapping: The list of countries/regions mapped to this endpoint when using the 'Geographic' traffic routing method.
	// Please consult Traffic Manager Geographic documentation for a full list of accepted values.
	GeoMapping []string `json:"geoMapping,omitempty"`

	// Id: Fully qualified resource Id for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{resourceName}
	Id *string `json:"id,omitempty"`

	// MinChildEndpoints: The minimum number of endpoints that must be available in the child profile in order for the parent
	// profile to be considered available. Only applicable to endpoint of type 'NestedEndpoints'.
	MinChildEndpoints *int `json:"minChildEndpoints,omitempty"`

	// MinChildEndpointsIPv4: The minimum number of IPv4 (DNS record type A) endpoints that must be available in the child
	// profile in order for the parent profile to be considered available. Only applicable to endpoint of type
	// 'NestedEndpoints'.
	MinChildEndpointsIPv4 *int `json:"minChildEndpointsIPv4,omitempty"`

	// MinChildEndpointsIPv6: The minimum number of IPv6 (DNS record type AAAA) endpoints that must be available in the child
	// profile in order for the parent profile to be considered available. Only applicable to endpoint of type
	// 'NestedEndpoints'.
	MinChildEndpointsIPv6 *int `json:"minChildEndpointsIPv6,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// Priority: The priority of this endpoint when using the 'Priority' traffic routing method. Possible values are from 1 to
	// 1000, lower values represent higher priority. This is an optional parameter.  If specified, it must be specified on all
	// endpoints, and no two endpoints can share the same priority value.
	Priority *int `json:"priority,omitempty"`

	// Subnets: The list of subnets, IP addresses, and/or address ranges mapped to this endpoint when using the 'Subnet'
	// traffic routing method. An empty list will match all ranges not covered by other endpoints.
	Subnets []EndpointProperties_Subnets_STATUS `json:"subnets,omitempty"`

	// Target: The fully-qualified DNS name or IP address of the endpoint. Traffic Manager returns this value in DNS responses
	// to direct traffic to this endpoint.
	Target *string `json:"target,omitempty"`

	// TargetResourceId: The Azure Resource URI of the of the endpoint. Not applicable to endpoints of type 'ExternalEndpoints'.
	TargetResourceId *string `json:"targetResourceId,omitempty"`

	// Type: The type of the resource. Ex- Microsoft.Network/trafficManagerProfiles.
	Type *string `json:"type,omitempty"`

	// Weight: The weight of this endpoint when using the 'Weighted' traffic routing method. Possible values are from 1 to 1000.
	Weight *int `json:"weight,omitempty"`
}

var _ genruntime.ConvertibleStatus = &TrafficManagerProfilesAzureEndpoint_STATUS{}

// ConvertStatusFrom populates our TrafficManagerProfilesAzureEndpoint_STATUS from the provided source
func (endpoint *TrafficManagerProfilesAzureEndpoint_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.TrafficManagerProfilesAzureEndpoint_STATUS)
	if ok {
		// Populate our instance from source
		return endpoint.AssignProperties_From_TrafficManagerProfilesAzureEndpoint_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.TrafficManagerProfilesAzureEndpoint_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = endpoint.AssignProperties_From_TrafficManagerProfilesAzureEndpoint_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our TrafficManagerProfilesAzureEndpoint_STATUS
func (endpoint *TrafficManagerProfilesAzureEndpoint_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.TrafficManagerProfilesAzureEndpoint_STATUS)
	if ok {
		// Populate destination from our instance
		return endpoint.AssignProperties_To_TrafficManagerProfilesAzureEndpoint_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.TrafficManagerProfilesAzureEndpoint_STATUS{}
	err := endpoint.AssignProperties_To_TrafficManagerProfilesAzureEndpoint_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &TrafficManagerProfilesAzureEndpoint_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (endpoint *TrafficManagerProfilesAzureEndpoint_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TrafficManagerProfilesAzureEndpoint_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (endpoint *TrafficManagerProfilesAzureEndpoint_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TrafficManagerProfilesAzureEndpoint_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TrafficManagerProfilesAzureEndpoint_STATUS, got %T", armInput)
	}

	// Set property "AlwaysServe":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AlwaysServe != nil {
			var temp string
			temp = string(*typedInput.Properties.AlwaysServe)
			alwaysServe := EndpointProperties_AlwaysServe_STATUS(temp)
			endpoint.AlwaysServe = &alwaysServe
		}
	}

	// no assignment for property "Conditions"

	// Set property "CustomHeaders":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.CustomHeaders {
			var item1 EndpointProperties_CustomHeaders_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.CustomHeaders = append(endpoint.CustomHeaders, item1)
		}
	}

	// Set property "EndpointLocation":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EndpointLocation != nil {
			endpointLocation := *typedInput.Properties.EndpointLocation
			endpoint.EndpointLocation = &endpointLocation
		}
	}

	// Set property "EndpointMonitorStatus":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EndpointMonitorStatus != nil {
			var temp string
			temp = string(*typedInput.Properties.EndpointMonitorStatus)
			endpointMonitorStatus := EndpointProperties_EndpointMonitorStatus_STATUS(temp)
			endpoint.EndpointMonitorStatus = &endpointMonitorStatus
		}
	}

	// Set property "EndpointStatus":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EndpointStatus != nil {
			var temp string
			temp = string(*typedInput.Properties.EndpointStatus)
			endpointStatus := EndpointProperties_EndpointStatus_STATUS(temp)
			endpoint.EndpointStatus = &endpointStatus
		}
	}

	// Set property "GeoMapping":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.GeoMapping {
			endpoint.GeoMapping = append(endpoint.GeoMapping, item)
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		endpoint.Id = &id
	}

	// Set property "MinChildEndpoints":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinChildEndpoints != nil {
			minChildEndpoints := *typedInput.Properties.MinChildEndpoints
			endpoint.MinChildEndpoints = &minChildEndpoints
		}
	}

	// Set property "MinChildEndpointsIPv4":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinChildEndpointsIPv4 != nil {
			minChildEndpointsIPv4 := *typedInput.Properties.MinChildEndpointsIPv4
			endpoint.MinChildEndpointsIPv4 = &minChildEndpointsIPv4
		}
	}

	// Set property "MinChildEndpointsIPv6":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinChildEndpointsIPv6 != nil {
			minChildEndpointsIPv6 := *typedInput.Properties.MinChildEndpointsIPv6
			endpoint.MinChildEndpointsIPv6 = &minChildEndpointsIPv6
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		endpoint.Name = &name
	}

	// Set property "Priority":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Priority != nil {
			priority := *typedInput.Properties.Priority
			endpoint.Priority = &priority
		}
	}

	// Set property "Subnets":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Subnets {
			var item1 EndpointProperties_Subnets_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.Subnets = append(endpoint.Subnets, item1)
		}
	}

	// Set property "Target":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Target != nil {
			target := *typedInput.Properties.Target
			endpoint.Target = &target
		}
	}

	// Set property "TargetResourceId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TargetResourceId != nil {
			targetResourceId := *typedInput.Properties.TargetResourceId
			endpoint.TargetResourceId = &targetResourceId
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		endpoint.Type = &typeVar
	}

	// Set property "Weight":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Weight != nil {
			weight := *typedInput.Properties.Weight
			endpoint.Weight = &weight
		}
	}

	// No error
	return nil
}

// AssignProperties_From_TrafficManagerProfilesAzureEndpoint_STATUS populates our TrafficManagerProfilesAzureEndpoint_STATUS from the provided source TrafficManagerProfilesAzureEndpoint_STATUS
func (endpoint *TrafficManagerProfilesAzureEndpoint_STATUS) AssignProperties_From_TrafficManagerProfilesAzureEndpoint_STATUS(source *storage.TrafficManagerProfilesAzureEndpoint_STATUS) error {

	// AlwaysServe
	if source.AlwaysServe != nil {
		alwaysServe := *source.AlwaysServe
		alwaysServeTemp := genruntime.ToEnum(alwaysServe, endpointProperties_AlwaysServe_STATUS_Values)
		endpoint.AlwaysServe = &alwaysServeTemp
	} else {
		endpoint.AlwaysServe = nil
	}

	// Conditions
	endpoint.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// CustomHeaders
	if source.CustomHeaders != nil {
		customHeaderList := make([]EndpointProperties_CustomHeaders_STATUS, len(source.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range source.CustomHeaders {
			// Shadow the loop variable to avoid aliasing
			customHeaderItem := customHeaderItem
			var customHeader EndpointProperties_CustomHeaders_STATUS
			err := customHeader.AssignProperties_From_EndpointProperties_CustomHeaders_STATUS(&customHeaderItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_EndpointProperties_CustomHeaders_STATUS() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		endpoint.CustomHeaders = customHeaderList
	} else {
		endpoint.CustomHeaders = nil
	}

	// EndpointLocation
	endpoint.EndpointLocation = genruntime.ClonePointerToString(source.EndpointLocation)

	// EndpointMonitorStatus
	if source.EndpointMonitorStatus != nil {
		endpointMonitorStatus := *source.EndpointMonitorStatus
		endpointMonitorStatusTemp := genruntime.ToEnum(endpointMonitorStatus, endpointProperties_EndpointMonitorStatus_STATUS_Values)
		endpoint.EndpointMonitorStatus = &endpointMonitorStatusTemp
	} else {
		endpoint.EndpointMonitorStatus = nil
	}

	// EndpointStatus
	if source.EndpointStatus != nil {
		endpointStatus := *source.EndpointStatus
		endpointStatusTemp := genruntime.ToEnum(endpointStatus, endpointProperties_EndpointStatus_STATUS_Values)
		endpoint.EndpointStatus = &endpointStatusTemp
	} else {
		endpoint.EndpointStatus = nil
	}

	// GeoMapping
	endpoint.GeoMapping = genruntime.CloneSliceOfString(source.GeoMapping)

	// Id
	endpoint.Id = genruntime.ClonePointerToString(source.Id)

	// MinChildEndpoints
	endpoint.MinChildEndpoints = genruntime.ClonePointerToInt(source.MinChildEndpoints)

	// MinChildEndpointsIPv4
	endpoint.MinChildEndpointsIPv4 = genruntime.ClonePointerToInt(source.MinChildEndpointsIPv4)

	// MinChildEndpointsIPv6
	endpoint.MinChildEndpointsIPv6 = genruntime.ClonePointerToInt(source.MinChildEndpointsIPv6)

	// Name
	endpoint.Name = genruntime.ClonePointerToString(source.Name)

	// Priority
	endpoint.Priority = genruntime.ClonePointerToInt(source.Priority)

	// Subnets
	if source.Subnets != nil {
		subnetList := make([]EndpointProperties_Subnets_STATUS, len(source.Subnets))
		for subnetIndex, subnetItem := range source.Subnets {
			// Shadow the loop variable to avoid aliasing
			subnetItem := subnetItem
			var subnet EndpointProperties_Subnets_STATUS
			err := subnet.AssignProperties_From_EndpointProperties_Subnets_STATUS(&subnetItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_EndpointProperties_Subnets_STATUS() to populate field Subnets")
			}
			subnetList[subnetIndex] = subnet
		}
		endpoint.Subnets = subnetList
	} else {
		endpoint.Subnets = nil
	}

	// Target
	endpoint.Target = genruntime.ClonePointerToString(source.Target)

	// TargetResourceId
	endpoint.TargetResourceId = genruntime.ClonePointerToString(source.TargetResourceId)

	// Type
	endpoint.Type = genruntime.ClonePointerToString(source.Type)

	// Weight
	endpoint.Weight = genruntime.ClonePointerToInt(source.Weight)

	// No error
	return nil
}

// AssignProperties_To_TrafficManagerProfilesAzureEndpoint_STATUS populates the provided destination TrafficManagerProfilesAzureEndpoint_STATUS from our TrafficManagerProfilesAzureEndpoint_STATUS
func (endpoint *TrafficManagerProfilesAzureEndpoint_STATUS) AssignProperties_To_TrafficManagerProfilesAzureEndpoint_STATUS(destination *storage.TrafficManagerProfilesAzureEndpoint_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AlwaysServe
	if endpoint.AlwaysServe != nil {
		alwaysServe := string(*endpoint.AlwaysServe)
		destination.AlwaysServe = &alwaysServe
	} else {
		destination.AlwaysServe = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(endpoint.Conditions)

	// CustomHeaders
	if endpoint.CustomHeaders != nil {
		customHeaderList := make([]storage.EndpointProperties_CustomHeaders_STATUS, len(endpoint.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range endpoint.CustomHeaders {
			// Shadow the loop variable to avoid aliasing
			customHeaderItem := customHeaderItem
			var customHeader storage.EndpointProperties_CustomHeaders_STATUS
			err := customHeaderItem.AssignProperties_To_EndpointProperties_CustomHeaders_STATUS(&customHeader)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_EndpointProperties_CustomHeaders_STATUS() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		destination.CustomHeaders = customHeaderList
	} else {
		destination.CustomHeaders = nil
	}

	// EndpointLocation
	destination.EndpointLocation = genruntime.ClonePointerToString(endpoint.EndpointLocation)

	// EndpointMonitorStatus
	if endpoint.EndpointMonitorStatus != nil {
		endpointMonitorStatus := string(*endpoint.EndpointMonitorStatus)
		destination.EndpointMonitorStatus = &endpointMonitorStatus
	} else {
		destination.EndpointMonitorStatus = nil
	}

	// EndpointStatus
	if endpoint.EndpointStatus != nil {
		endpointStatus := string(*endpoint.EndpointStatus)
		destination.EndpointStatus = &endpointStatus
	} else {
		destination.EndpointStatus = nil
	}

	// GeoMapping
	destination.GeoMapping = genruntime.CloneSliceOfString(endpoint.GeoMapping)

	// Id
	destination.Id = genruntime.ClonePointerToString(endpoint.Id)

	// MinChildEndpoints
	destination.MinChildEndpoints = genruntime.ClonePointerToInt(endpoint.MinChildEndpoints)

	// MinChildEndpointsIPv4
	destination.MinChildEndpointsIPv4 = genruntime.ClonePointerToInt(endpoint.MinChildEndpointsIPv4)

	// MinChildEndpointsIPv6
	destination.MinChildEndpointsIPv6 = genruntime.ClonePointerToInt(endpoint.MinChildEndpointsIPv6)

	// Name
	destination.Name = genruntime.ClonePointerToString(endpoint.Name)

	// Priority
	destination.Priority = genruntime.ClonePointerToInt(endpoint.Priority)

	// Subnets
	if endpoint.Subnets != nil {
		subnetList := make([]storage.EndpointProperties_Subnets_STATUS, len(endpoint.Subnets))
		for subnetIndex, subnetItem := range endpoint.Subnets {
			// Shadow the loop variable to avoid aliasing
			subnetItem := subnetItem
			var subnet storage.EndpointProperties_Subnets_STATUS
			err := subnetItem.AssignProperties_To_EndpointProperties_Subnets_STATUS(&subnet)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_EndpointProperties_Subnets_STATUS() to populate field Subnets")
			}
			subnetList[subnetIndex] = subnet
		}
		destination.Subnets = subnetList
	} else {
		destination.Subnets = nil
	}

	// Target
	destination.Target = genruntime.ClonePointerToString(endpoint.Target)

	// TargetResourceId
	destination.TargetResourceId = genruntime.ClonePointerToString(endpoint.TargetResourceId)

	// Type
	destination.Type = genruntime.ClonePointerToString(endpoint.Type)

	// Weight
	destination.Weight = genruntime.ClonePointerToInt(endpoint.Weight)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type EndpointProperties_AlwaysServe string

const (
	EndpointProperties_AlwaysServe_Disabled = EndpointProperties_AlwaysServe("Disabled")
	EndpointProperties_AlwaysServe_Enabled  = EndpointProperties_AlwaysServe("Enabled")
)

// Mapping from string to EndpointProperties_AlwaysServe
var endpointProperties_AlwaysServe_Values = map[string]EndpointProperties_AlwaysServe{
	"disabled": EndpointProperties_AlwaysServe_Disabled,
	"enabled":  EndpointProperties_AlwaysServe_Enabled,
}

type EndpointProperties_AlwaysServe_STATUS string

const (
	EndpointProperties_AlwaysServe_STATUS_Disabled = EndpointProperties_AlwaysServe_STATUS("Disabled")
	EndpointProperties_AlwaysServe_STATUS_Enabled  = EndpointProperties_AlwaysServe_STATUS("Enabled")
)

// Mapping from string to EndpointProperties_AlwaysServe_STATUS
var endpointProperties_AlwaysServe_STATUS_Values = map[string]EndpointProperties_AlwaysServe_STATUS{
	"disabled": EndpointProperties_AlwaysServe_STATUS_Disabled,
	"enabled":  EndpointProperties_AlwaysServe_STATUS_Enabled,
}

type EndpointProperties_CustomHeaders struct {
	// Name: Header name.
	Name *string `json:"name,omitempty"`

	// Value: Header value.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &EndpointProperties_CustomHeaders{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (headers *EndpointProperties_CustomHeaders) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if headers == nil {
		return nil, nil
	}
	result := &arm.EndpointProperties_CustomHeaders{}

	// Set property "Name":
	if headers.Name != nil {
		name := *headers.Name
		result.Name = &name
	}

	// Set property "Value":
	if headers.Value != nil {
		value := *headers.Value
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (headers *EndpointProperties_CustomHeaders) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EndpointProperties_CustomHeaders{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (headers *EndpointProperties_CustomHeaders) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EndpointProperties_CustomHeaders)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EndpointProperties_CustomHeaders, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		headers.Name = &name
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		headers.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_EndpointProperties_CustomHeaders populates our EndpointProperties_CustomHeaders from the provided source EndpointProperties_CustomHeaders
func (headers *EndpointProperties_CustomHeaders) AssignProperties_From_EndpointProperties_CustomHeaders(source *storage.EndpointProperties_CustomHeaders) error {

	// Name
	headers.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	headers.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_EndpointProperties_CustomHeaders populates the provided destination EndpointProperties_CustomHeaders from our EndpointProperties_CustomHeaders
func (headers *EndpointProperties_CustomHeaders) AssignProperties_To_EndpointProperties_CustomHeaders(destination *storage.EndpointProperties_CustomHeaders) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(headers.Name)

	// Value
	destination.Value = genruntime.ClonePointerToString(headers.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_EndpointProperties_CustomHeaders_STATUS populates our EndpointProperties_CustomHeaders from the provided source EndpointProperties_CustomHeaders_STATUS
func (headers *EndpointProperties_CustomHeaders) Initialize_From_EndpointProperties_CustomHeaders_STATUS(source *EndpointProperties_CustomHeaders_STATUS) error {

	// Name
	headers.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	headers.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

type EndpointProperties_CustomHeaders_STATUS struct {
	// Name: Header name.
	Name *string `json:"name,omitempty"`

	// Value: Header value.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &EndpointProperties_CustomHeaders_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (headers *EndpointProperties_CustomHeaders_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EndpointProperties_CustomHeaders_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (headers *EndpointProperties_CustomHeaders_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EndpointProperties_CustomHeaders_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EndpointProperties_CustomHeaders_STATUS, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		headers.Name = &name
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		headers.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_EndpointProperties_CustomHeaders_STATUS populates our EndpointProperties_CustomHeaders_STATUS from the provided source EndpointProperties_CustomHeaders_STATUS
func (headers *EndpointProperties_CustomHeaders_STATUS) AssignProperties_From_EndpointProperties_CustomHeaders_STATUS(source *storage.EndpointProperties_CustomHeaders_STATUS) error {

	// Name
	headers.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	headers.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_EndpointProperties_CustomHeaders_STATUS populates the provided destination EndpointProperties_CustomHeaders_STATUS from our EndpointProperties_CustomHeaders_STATUS
func (headers *EndpointProperties_CustomHeaders_STATUS) AssignProperties_To_EndpointProperties_CustomHeaders_STATUS(destination *storage.EndpointProperties_CustomHeaders_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(headers.Name)

	// Value
	destination.Value = genruntime.ClonePointerToString(headers.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"CheckingEndpoint","Degraded","Disabled","Inactive","Online","Stopped","Unmonitored"}
type EndpointProperties_EndpointMonitorStatus string

const (
	EndpointProperties_EndpointMonitorStatus_CheckingEndpoint = EndpointProperties_EndpointMonitorStatus("CheckingEndpoint")
	EndpointProperties_EndpointMonitorStatus_Degraded         = EndpointProperties_EndpointMonitorStatus("Degraded")
	EndpointProperties_EndpointMonitorStatus_Disabled         = EndpointProperties_EndpointMonitorStatus("Disabled")
	EndpointProperties_EndpointMonitorStatus_Inactive         = EndpointProperties_EndpointMonitorStatus("Inactive")
	EndpointProperties_EndpointMonitorStatus_Online           = EndpointProperties_EndpointMonitorStatus("Online")
	EndpointProperties_EndpointMonitorStatus_Stopped          = EndpointProperties_EndpointMonitorStatus("Stopped")
	EndpointProperties_EndpointMonitorStatus_Unmonitored      = EndpointProperties_EndpointMonitorStatus("Unmonitored")
)

// Mapping from string to EndpointProperties_EndpointMonitorStatus
var endpointProperties_EndpointMonitorStatus_Values = map[string]EndpointProperties_EndpointMonitorStatus{
	"checkingendpoint": EndpointProperties_EndpointMonitorStatus_CheckingEndpoint,
	"degraded":         EndpointProperties_EndpointMonitorStatus_Degraded,
	"disabled":         EndpointProperties_EndpointMonitorStatus_Disabled,
	"inactive":         EndpointProperties_EndpointMonitorStatus_Inactive,
	"online":           EndpointProperties_EndpointMonitorStatus_Online,
	"stopped":          EndpointProperties_EndpointMonitorStatus_Stopped,
	"unmonitored":      EndpointProperties_EndpointMonitorStatus_Unmonitored,
}

type EndpointProperties_EndpointMonitorStatus_STATUS string

const (
	EndpointProperties_EndpointMonitorStatus_STATUS_CheckingEndpoint = EndpointProperties_EndpointMonitorStatus_STATUS("CheckingEndpoint")
	EndpointProperties_EndpointMonitorStatus_STATUS_Degraded         = EndpointProperties_EndpointMonitorStatus_STATUS("Degraded")
	EndpointProperties_EndpointMonitorStatus_STATUS_Disabled         = EndpointProperties_EndpointMonitorStatus_STATUS("Disabled")
	EndpointProperties_EndpointMonitorStatus_STATUS_Inactive         = EndpointProperties_EndpointMonitorStatus_STATUS("Inactive")
	EndpointProperties_EndpointMonitorStatus_STATUS_Online           = EndpointProperties_EndpointMonitorStatus_STATUS("Online")
	EndpointProperties_EndpointMonitorStatus_STATUS_Stopped          = EndpointProperties_EndpointMonitorStatus_STATUS("Stopped")
	EndpointProperties_EndpointMonitorStatus_STATUS_Unmonitored      = EndpointProperties_EndpointMonitorStatus_STATUS("Unmonitored")
)

// Mapping from string to EndpointProperties_EndpointMonitorStatus_STATUS
var endpointProperties_EndpointMonitorStatus_STATUS_Values = map[string]EndpointProperties_EndpointMonitorStatus_STATUS{
	"checkingendpoint": EndpointProperties_EndpointMonitorStatus_STATUS_CheckingEndpoint,
	"degraded":         EndpointProperties_EndpointMonitorStatus_STATUS_Degraded,
	"disabled":         EndpointProperties_EndpointMonitorStatus_STATUS_Disabled,
	"inactive":         EndpointProperties_EndpointMonitorStatus_STATUS_Inactive,
	"online":           EndpointProperties_EndpointMonitorStatus_STATUS_Online,
	"stopped":          EndpointProperties_EndpointMonitorStatus_STATUS_Stopped,
	"unmonitored":      EndpointProperties_EndpointMonitorStatus_STATUS_Unmonitored,
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type EndpointProperties_EndpointStatus string

const (
	EndpointProperties_EndpointStatus_Disabled = EndpointProperties_EndpointStatus("Disabled")
	EndpointProperties_EndpointStatus_Enabled  = EndpointProperties_EndpointStatus("Enabled")
)

// Mapping from string to EndpointProperties_EndpointStatus
var endpointProperties_EndpointStatus_Values = map[string]EndpointProperties_EndpointStatus{
	"disabled": EndpointProperties_EndpointStatus_Disabled,
	"enabled":  EndpointProperties_EndpointStatus_Enabled,
}

type EndpointProperties_EndpointStatus_STATUS string

const (
	EndpointProperties_EndpointStatus_STATUS_Disabled = EndpointProperties_EndpointStatus_STATUS("Disabled")
	EndpointProperties_EndpointStatus_STATUS_Enabled  = EndpointProperties_EndpointStatus_STATUS("Enabled")
)

// Mapping from string to EndpointProperties_EndpointStatus_STATUS
var endpointProperties_EndpointStatus_STATUS_Values = map[string]EndpointProperties_EndpointStatus_STATUS{
	"disabled": EndpointProperties_EndpointStatus_STATUS_Disabled,
	"enabled":  EndpointProperties_EndpointStatus_STATUS_Enabled,
}

type EndpointProperties_Subnets struct {
	// First: First address in the subnet.
	First *string `json:"first,omitempty"`

	// Last: Last address in the subnet.
	Last *string `json:"last,omitempty"`

	// Scope: Block size (number of leading bits in the subnet mask).
	Scope *int `json:"scope,omitempty"`
}

var _ genruntime.ARMTransformer = &EndpointProperties_Subnets{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (subnets *EndpointProperties_Subnets) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if subnets == nil {
		return nil, nil
	}
	result := &arm.EndpointProperties_Subnets{}

	// Set property "First":
	if subnets.First != nil {
		first := *subnets.First
		result.First = &first
	}

	// Set property "Last":
	if subnets.Last != nil {
		last := *subnets.Last
		result.Last = &last
	}

	// Set property "Scope":
	if subnets.Scope != nil {
		scope := *subnets.Scope
		result.Scope = &scope
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (subnets *EndpointProperties_Subnets) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EndpointProperties_Subnets{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (subnets *EndpointProperties_Subnets) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EndpointProperties_Subnets)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EndpointProperties_Subnets, got %T", armInput)
	}

	// Set property "First":
	if typedInput.First != nil {
		first := *typedInput.First
		subnets.First = &first
	}

	// Set property "Last":
	if typedInput.Last != nil {
		last := *typedInput.Last
		subnets.Last = &last
	}

	// Set property "Scope":
	if typedInput.Scope != nil {
		scope := *typedInput.Scope
		subnets.Scope = &scope
	}

	// No error
	return nil
}

// AssignProperties_From_EndpointProperties_Subnets populates our EndpointProperties_Subnets from the provided source EndpointProperties_Subnets
func (subnets *EndpointProperties_Subnets) AssignProperties_From_EndpointProperties_Subnets(source *storage.EndpointProperties_Subnets) error {

	// First
	subnets.First = genruntime.ClonePointerToString(source.First)

	// Last
	subnets.Last = genruntime.ClonePointerToString(source.Last)

	// Scope
	subnets.Scope = genruntime.ClonePointerToInt(source.Scope)

	// No error
	return nil
}

// AssignProperties_To_EndpointProperties_Subnets populates the provided destination EndpointProperties_Subnets from our EndpointProperties_Subnets
func (subnets *EndpointProperties_Subnets) AssignProperties_To_EndpointProperties_Subnets(destination *storage.EndpointProperties_Subnets) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// First
	destination.First = genruntime.ClonePointerToString(subnets.First)

	// Last
	destination.Last = genruntime.ClonePointerToString(subnets.Last)

	// Scope
	destination.Scope = genruntime.ClonePointerToInt(subnets.Scope)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_EndpointProperties_Subnets_STATUS populates our EndpointProperties_Subnets from the provided source EndpointProperties_Subnets_STATUS
func (subnets *EndpointProperties_Subnets) Initialize_From_EndpointProperties_Subnets_STATUS(source *EndpointProperties_Subnets_STATUS) error {

	// First
	subnets.First = genruntime.ClonePointerToString(source.First)

	// Last
	subnets.Last = genruntime.ClonePointerToString(source.Last)

	// Scope
	subnets.Scope = genruntime.ClonePointerToInt(source.Scope)

	// No error
	return nil
}

type EndpointProperties_Subnets_STATUS struct {
	// First: First address in the subnet.
	First *string `json:"first,omitempty"`

	// Last: Last address in the subnet.
	Last *string `json:"last,omitempty"`

	// Scope: Block size (number of leading bits in the subnet mask).
	Scope *int `json:"scope,omitempty"`
}

var _ genruntime.FromARMConverter = &EndpointProperties_Subnets_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (subnets *EndpointProperties_Subnets_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EndpointProperties_Subnets_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (subnets *EndpointProperties_Subnets_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EndpointProperties_Subnets_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EndpointProperties_Subnets_STATUS, got %T", armInput)
	}

	// Set property "First":
	if typedInput.First != nil {
		first := *typedInput.First
		subnets.First = &first
	}

	// Set property "Last":
	if typedInput.Last != nil {
		last := *typedInput.Last
		subnets.Last = &last
	}

	// Set property "Scope":
	if typedInput.Scope != nil {
		scope := *typedInput.Scope
		subnets.Scope = &scope
	}

	// No error
	return nil
}

// AssignProperties_From_EndpointProperties_Subnets_STATUS populates our EndpointProperties_Subnets_STATUS from the provided source EndpointProperties_Subnets_STATUS
func (subnets *EndpointProperties_Subnets_STATUS) AssignProperties_From_EndpointProperties_Subnets_STATUS(source *storage.EndpointProperties_Subnets_STATUS) error {

	// First
	subnets.First = genruntime.ClonePointerToString(source.First)

	// Last
	subnets.Last = genruntime.ClonePointerToString(source.Last)

	// Scope
	subnets.Scope = genruntime.ClonePointerToInt(source.Scope)

	// No error
	return nil
}

// AssignProperties_To_EndpointProperties_Subnets_STATUS populates the provided destination EndpointProperties_Subnets_STATUS from our EndpointProperties_Subnets_STATUS
func (subnets *EndpointProperties_Subnets_STATUS) AssignProperties_To_EndpointProperties_Subnets_STATUS(destination *storage.EndpointProperties_Subnets_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// First
	destination.First = genruntime.ClonePointerToString(subnets.First)

	// Last
	destination.Last = genruntime.ClonePointerToString(subnets.Last)

	// Scope
	destination.Scope = genruntime.ClonePointerToInt(subnets.Scope)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type TrafficManagerProfilesAzureEndpointOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_TrafficManagerProfilesAzureEndpointOperatorSpec populates our TrafficManagerProfilesAzureEndpointOperatorSpec from the provided source TrafficManagerProfilesAzureEndpointOperatorSpec
func (operator *TrafficManagerProfilesAzureEndpointOperatorSpec) AssignProperties_From_TrafficManagerProfilesAzureEndpointOperatorSpec(source *storage.TrafficManagerProfilesAzureEndpointOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_TrafficManagerProfilesAzureEndpointOperatorSpec populates the provided destination TrafficManagerProfilesAzureEndpointOperatorSpec from our TrafficManagerProfilesAzureEndpointOperatorSpec
func (operator *TrafficManagerProfilesAzureEndpointOperatorSpec) AssignProperties_To_TrafficManagerProfilesAzureEndpointOperatorSpec(destination *storage.TrafficManagerProfilesAzureEndpointOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&TrafficManagerProfilesAzureEndpoint{}, &TrafficManagerProfilesAzureEndpointList{})
}
