// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20220901

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/search/v1api20220901/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/search/v1api20220901/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/rotisserie/eris"
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /search/resource-manager/Microsoft.Search/stable/2022-09-01/search.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Search/searchServices/{searchServiceName}
type SearchService struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              SearchService_Spec   `json:"spec,omitempty"`
	Status            SearchService_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &SearchService{}

// GetConditions returns the conditions of the resource
func (service *SearchService) GetConditions() conditions.Conditions {
	return service.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (service *SearchService) SetConditions(conditions conditions.Conditions) {
	service.Status.Conditions = conditions
}

var _ conversion.Convertible = &SearchService{}

// ConvertFrom populates our SearchService from the provided hub SearchService
func (service *SearchService) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.SearchService)
	if !ok {
		return fmt.Errorf("expected search/v1api20220901/storage/SearchService but received %T instead", hub)
	}

	return service.AssignProperties_From_SearchService(source)
}

// ConvertTo populates the provided hub SearchService from our SearchService
func (service *SearchService) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.SearchService)
	if !ok {
		return fmt.Errorf("expected search/v1api20220901/storage/SearchService but received %T instead", hub)
	}

	return service.AssignProperties_To_SearchService(destination)
}

var _ configmaps.Exporter = &SearchService{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (service *SearchService) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if service.Spec.OperatorSpec == nil {
		return nil
	}
	return service.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &SearchService{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (service *SearchService) SecretDestinationExpressions() []*core.DestinationExpression {
	if service.Spec.OperatorSpec == nil {
		return nil
	}
	return service.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &SearchService{}

// InitializeSpec initializes the spec for this resource from the given status
func (service *SearchService) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*SearchService_STATUS); ok {
		return service.Spec.Initialize_From_SearchService_STATUS(s)
	}

	return fmt.Errorf("expected Status of type SearchService_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &SearchService{}

// AzureName returns the Azure name of the resource
func (service *SearchService) AzureName() string {
	return service.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2022-09-01"
func (service SearchService) GetAPIVersion() string {
	return "2022-09-01"
}

// GetResourceScope returns the scope of the resource
func (service *SearchService) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (service *SearchService) GetSpec() genruntime.ConvertibleSpec {
	return &service.Spec
}

// GetStatus returns the status of this resource
func (service *SearchService) GetStatus() genruntime.ConvertibleStatus {
	return &service.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (service *SearchService) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Search/searchServices"
func (service *SearchService) GetType() string {
	return "Microsoft.Search/searchServices"
}

// NewEmptyStatus returns a new empty (blank) status
func (service *SearchService) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &SearchService_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (service *SearchService) Owner() *genruntime.ResourceReference {
	if service.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(service.Spec)
	return service.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (service *SearchService) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*SearchService_STATUS); ok {
		service.Status = *st
		return nil
	}

	// Convert status to required version
	var st SearchService_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	service.Status = st
	return nil
}

// AssignProperties_From_SearchService populates our SearchService from the provided source SearchService
func (service *SearchService) AssignProperties_From_SearchService(source *storage.SearchService) error {

	// ObjectMeta
	service.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec SearchService_Spec
	err := spec.AssignProperties_From_SearchService_Spec(&source.Spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_SearchService_Spec() to populate field Spec")
	}
	service.Spec = spec

	// Status
	var status SearchService_STATUS
	err = status.AssignProperties_From_SearchService_STATUS(&source.Status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_SearchService_STATUS() to populate field Status")
	}
	service.Status = status

	// No error
	return nil
}

// AssignProperties_To_SearchService populates the provided destination SearchService from our SearchService
func (service *SearchService) AssignProperties_To_SearchService(destination *storage.SearchService) error {

	// ObjectMeta
	destination.ObjectMeta = *service.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.SearchService_Spec
	err := service.Spec.AssignProperties_To_SearchService_Spec(&spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_SearchService_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.SearchService_STATUS
	err = service.Status.AssignProperties_To_SearchService_STATUS(&status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_SearchService_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (service *SearchService) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: service.Spec.OriginalVersion(),
		Kind:    "SearchService",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /search/resource-manager/Microsoft.Search/stable/2022-09-01/search.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Search/searchServices/{searchServiceName}
type SearchServiceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []SearchService `json:"items"`
}

// +kubebuilder:validation:Enum={"2022-09-01"}
type APIVersion string

const APIVersion_Value = APIVersion("2022-09-01")

type SearchService_Spec struct {
	// AuthOptions: Defines the options for how the data plane API of a search service authenticates requests. This cannot be
	// set if 'disableLocalAuth' is set to true.
	AuthOptions *DataPlaneAuthOptions `json:"authOptions,omitempty"`

	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// DisableLocalAuth: When set to true, calls to the search service will not be permitted to utilize API keys for
	// authentication. This cannot be set to true if 'dataPlaneAuthOptions' are defined.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// EncryptionWithCmk: Specifies any policy regarding encryption of resources (such as indexes) using customer manager keys
	// within a search service.
	EncryptionWithCmk *EncryptionWithCmk `json:"encryptionWithCmk,omitempty"`

	// HostingMode: Applicable only for the standard3 SKU. You can set this property to enable up to 3 high density partitions
	// that allow up to 1000 indexes, which is much higher than the maximum indexes allowed for any other SKU. For the
	// standard3 SKU, the value is either 'default' or 'highDensity'. For all other SKUs, this value must be 'default'.
	HostingMode *SearchServiceProperties_HostingMode `json:"hostingMode,omitempty"`

	// Identity: The identity of the resource.
	Identity *Identity `json:"identity,omitempty"`

	// +kubebuilder:validation:Required
	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// NetworkRuleSet: Network specific rules that determine how the Azure Cognitive Search service may be reached.
	NetworkRuleSet *NetworkRuleSet `json:"networkRuleSet,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *SearchServiceOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// +kubebuilder:validation:Maximum=12
	// +kubebuilder:validation:Minimum=1
	// PartitionCount: The number of partitions in the search service; if specified, it can be 1, 2, 3, 4, 6, or 12. Values
	// greater than 1 are only valid for standard SKUs. For 'standard3' services with hostingMode set to 'highDensity', the
	// allowed values are between 1 and 3.
	PartitionCount *int `json:"partitionCount,omitempty"`

	// PublicNetworkAccess: This value can be set to 'enabled' to avoid breaking changes on existing customer resources and
	// templates. If set to 'disabled', traffic over public interface is not allowed, and private endpoint connections would be
	// the exclusive access method.
	PublicNetworkAccess *SearchServiceProperties_PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// +kubebuilder:validation:Maximum=12
	// +kubebuilder:validation:Minimum=1
	// ReplicaCount: The number of replicas in the search service. If specified, it must be a value between 1 and 12 inclusive
	// for standard SKUs or between 1 and 3 inclusive for basic SKU.
	ReplicaCount *int `json:"replicaCount,omitempty"`

	// Sku: The SKU of the Search Service, which determines price tier and capacity limits. This property is required when
	// creating a new Search Service.
	Sku *Sku `json:"sku,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &SearchService_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (service *SearchService_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if service == nil {
		return nil, nil
	}
	result := &arm.SearchService_Spec{}

	// Set property "Identity":
	if service.Identity != nil {
		identity_ARM, err := (*service.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*arm.Identity)
		result.Identity = &identity
	}

	// Set property "Location":
	if service.Location != nil {
		location := *service.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if service.AuthOptions != nil ||
		service.DisableLocalAuth != nil ||
		service.EncryptionWithCmk != nil ||
		service.HostingMode != nil ||
		service.NetworkRuleSet != nil ||
		service.PartitionCount != nil ||
		service.PublicNetworkAccess != nil ||
		service.ReplicaCount != nil {
		result.Properties = &arm.SearchServiceProperties{}
	}
	if service.AuthOptions != nil {
		authOptions_ARM, err := (*service.AuthOptions).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		authOptions := *authOptions_ARM.(*arm.DataPlaneAuthOptions)
		result.Properties.AuthOptions = &authOptions
	}
	if service.DisableLocalAuth != nil {
		disableLocalAuth := *service.DisableLocalAuth
		result.Properties.DisableLocalAuth = &disableLocalAuth
	}
	if service.EncryptionWithCmk != nil {
		encryptionWithCmk_ARM, err := (*service.EncryptionWithCmk).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		encryptionWithCmk := *encryptionWithCmk_ARM.(*arm.EncryptionWithCmk)
		result.Properties.EncryptionWithCmk = &encryptionWithCmk
	}
	if service.HostingMode != nil {
		var temp string
		temp = string(*service.HostingMode)
		hostingMode := arm.SearchServiceProperties_HostingMode(temp)
		result.Properties.HostingMode = &hostingMode
	}
	if service.NetworkRuleSet != nil {
		networkRuleSet_ARM, err := (*service.NetworkRuleSet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		networkRuleSet := *networkRuleSet_ARM.(*arm.NetworkRuleSet)
		result.Properties.NetworkRuleSet = &networkRuleSet
	}
	if service.PartitionCount != nil {
		partitionCount := *service.PartitionCount
		result.Properties.PartitionCount = &partitionCount
	}
	if service.PublicNetworkAccess != nil {
		var temp string
		temp = string(*service.PublicNetworkAccess)
		publicNetworkAccess := arm.SearchServiceProperties_PublicNetworkAccess(temp)
		result.Properties.PublicNetworkAccess = &publicNetworkAccess
	}
	if service.ReplicaCount != nil {
		replicaCount := *service.ReplicaCount
		result.Properties.ReplicaCount = &replicaCount
	}

	// Set property "Sku":
	if service.Sku != nil {
		sku_ARM, err := (*service.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := *sku_ARM.(*arm.Sku)
		result.Sku = &sku
	}

	// Set property "Tags":
	if service.Tags != nil {
		result.Tags = make(map[string]string, len(service.Tags))
		for key, value := range service.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (service *SearchService_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SearchService_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (service *SearchService_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SearchService_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SearchService_Spec, got %T", armInput)
	}

	// Set property "AuthOptions":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AuthOptions != nil {
			var authOptions1 DataPlaneAuthOptions
			err := authOptions1.PopulateFromARM(owner, *typedInput.Properties.AuthOptions)
			if err != nil {
				return err
			}
			authOptions := authOptions1
			service.AuthOptions = &authOptions
		}
	}

	// Set property "AzureName":
	service.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "DisableLocalAuth":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DisableLocalAuth != nil {
			disableLocalAuth := *typedInput.Properties.DisableLocalAuth
			service.DisableLocalAuth = &disableLocalAuth
		}
	}

	// Set property "EncryptionWithCmk":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EncryptionWithCmk != nil {
			var encryptionWithCmk1 EncryptionWithCmk
			err := encryptionWithCmk1.PopulateFromARM(owner, *typedInput.Properties.EncryptionWithCmk)
			if err != nil {
				return err
			}
			encryptionWithCmk := encryptionWithCmk1
			service.EncryptionWithCmk = &encryptionWithCmk
		}
	}

	// Set property "HostingMode":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostingMode != nil {
			var temp string
			temp = string(*typedInput.Properties.HostingMode)
			hostingMode := SearchServiceProperties_HostingMode(temp)
			service.HostingMode = &hostingMode
		}
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 Identity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		service.Identity = &identity
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		service.Location = &location
	}

	// Set property "NetworkRuleSet":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkRuleSet != nil {
			var networkRuleSet1 NetworkRuleSet
			err := networkRuleSet1.PopulateFromARM(owner, *typedInput.Properties.NetworkRuleSet)
			if err != nil {
				return err
			}
			networkRuleSet := networkRuleSet1
			service.NetworkRuleSet = &networkRuleSet
		}
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	service.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "PartitionCount":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PartitionCount != nil {
			partitionCount := *typedInput.Properties.PartitionCount
			service.PartitionCount = &partitionCount
		}
	}

	// Set property "PublicNetworkAccess":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicNetworkAccess != nil {
			var temp string
			temp = string(*typedInput.Properties.PublicNetworkAccess)
			publicNetworkAccess := SearchServiceProperties_PublicNetworkAccess(temp)
			service.PublicNetworkAccess = &publicNetworkAccess
		}
	}

	// Set property "ReplicaCount":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ReplicaCount != nil {
			replicaCount := *typedInput.Properties.ReplicaCount
			service.ReplicaCount = &replicaCount
		}
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 Sku
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		service.Sku = &sku
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		service.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			service.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &SearchService_Spec{}

// ConvertSpecFrom populates our SearchService_Spec from the provided source
func (service *SearchService_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.SearchService_Spec)
	if ok {
		// Populate our instance from source
		return service.AssignProperties_From_SearchService_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.SearchService_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = service.AssignProperties_From_SearchService_Spec(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our SearchService_Spec
func (service *SearchService_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.SearchService_Spec)
	if ok {
		// Populate destination from our instance
		return service.AssignProperties_To_SearchService_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.SearchService_Spec{}
	err := service.AssignProperties_To_SearchService_Spec(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_SearchService_Spec populates our SearchService_Spec from the provided source SearchService_Spec
func (service *SearchService_Spec) AssignProperties_From_SearchService_Spec(source *storage.SearchService_Spec) error {

	// AuthOptions
	if source.AuthOptions != nil {
		var authOption DataPlaneAuthOptions
		err := authOption.AssignProperties_From_DataPlaneAuthOptions(source.AuthOptions)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DataPlaneAuthOptions() to populate field AuthOptions")
		}
		service.AuthOptions = &authOption
	} else {
		service.AuthOptions = nil
	}

	// AzureName
	service.AzureName = source.AzureName

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		service.DisableLocalAuth = &disableLocalAuth
	} else {
		service.DisableLocalAuth = nil
	}

	// EncryptionWithCmk
	if source.EncryptionWithCmk != nil {
		var encryptionWithCmk EncryptionWithCmk
		err := encryptionWithCmk.AssignProperties_From_EncryptionWithCmk(source.EncryptionWithCmk)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EncryptionWithCmk() to populate field EncryptionWithCmk")
		}
		service.EncryptionWithCmk = &encryptionWithCmk
	} else {
		service.EncryptionWithCmk = nil
	}

	// HostingMode
	if source.HostingMode != nil {
		hostingMode := *source.HostingMode
		hostingModeTemp := genruntime.ToEnum(hostingMode, searchServiceProperties_HostingMode_Values)
		service.HostingMode = &hostingModeTemp
	} else {
		service.HostingMode = nil
	}

	// Identity
	if source.Identity != nil {
		var identity Identity
		err := identity.AssignProperties_From_Identity(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Identity() to populate field Identity")
		}
		service.Identity = &identity
	} else {
		service.Identity = nil
	}

	// Location
	service.Location = genruntime.ClonePointerToString(source.Location)

	// NetworkRuleSet
	if source.NetworkRuleSet != nil {
		var networkRuleSet NetworkRuleSet
		err := networkRuleSet.AssignProperties_From_NetworkRuleSet(source.NetworkRuleSet)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_NetworkRuleSet() to populate field NetworkRuleSet")
		}
		service.NetworkRuleSet = &networkRuleSet
	} else {
		service.NetworkRuleSet = nil
	}

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec SearchServiceOperatorSpec
		err := operatorSpec.AssignProperties_From_SearchServiceOperatorSpec(source.OperatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SearchServiceOperatorSpec() to populate field OperatorSpec")
		}
		service.OperatorSpec = &operatorSpec
	} else {
		service.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		service.Owner = &owner
	} else {
		service.Owner = nil
	}

	// PartitionCount
	service.PartitionCount = genruntime.ClonePointerToInt(source.PartitionCount)

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := *source.PublicNetworkAccess
		publicNetworkAccessTemp := genruntime.ToEnum(publicNetworkAccess, searchServiceProperties_PublicNetworkAccess_Values)
		service.PublicNetworkAccess = &publicNetworkAccessTemp
	} else {
		service.PublicNetworkAccess = nil
	}

	// ReplicaCount
	service.ReplicaCount = genruntime.ClonePointerToInt(source.ReplicaCount)

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.AssignProperties_From_Sku(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Sku() to populate field Sku")
		}
		service.Sku = &sku
	} else {
		service.Sku = nil
	}

	// Tags
	service.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// AssignProperties_To_SearchService_Spec populates the provided destination SearchService_Spec from our SearchService_Spec
func (service *SearchService_Spec) AssignProperties_To_SearchService_Spec(destination *storage.SearchService_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthOptions
	if service.AuthOptions != nil {
		var authOption storage.DataPlaneAuthOptions
		err := service.AuthOptions.AssignProperties_To_DataPlaneAuthOptions(&authOption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DataPlaneAuthOptions() to populate field AuthOptions")
		}
		destination.AuthOptions = &authOption
	} else {
		destination.AuthOptions = nil
	}

	// AzureName
	destination.AzureName = service.AzureName

	// DisableLocalAuth
	if service.DisableLocalAuth != nil {
		disableLocalAuth := *service.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// EncryptionWithCmk
	if service.EncryptionWithCmk != nil {
		var encryptionWithCmk storage.EncryptionWithCmk
		err := service.EncryptionWithCmk.AssignProperties_To_EncryptionWithCmk(&encryptionWithCmk)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EncryptionWithCmk() to populate field EncryptionWithCmk")
		}
		destination.EncryptionWithCmk = &encryptionWithCmk
	} else {
		destination.EncryptionWithCmk = nil
	}

	// HostingMode
	if service.HostingMode != nil {
		hostingMode := string(*service.HostingMode)
		destination.HostingMode = &hostingMode
	} else {
		destination.HostingMode = nil
	}

	// Identity
	if service.Identity != nil {
		var identity storage.Identity
		err := service.Identity.AssignProperties_To_Identity(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Identity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(service.Location)

	// NetworkRuleSet
	if service.NetworkRuleSet != nil {
		var networkRuleSet storage.NetworkRuleSet
		err := service.NetworkRuleSet.AssignProperties_To_NetworkRuleSet(&networkRuleSet)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_NetworkRuleSet() to populate field NetworkRuleSet")
		}
		destination.NetworkRuleSet = &networkRuleSet
	} else {
		destination.NetworkRuleSet = nil
	}

	// OperatorSpec
	if service.OperatorSpec != nil {
		var operatorSpec storage.SearchServiceOperatorSpec
		err := service.OperatorSpec.AssignProperties_To_SearchServiceOperatorSpec(&operatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SearchServiceOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = service.OriginalVersion()

	// Owner
	if service.Owner != nil {
		owner := service.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// PartitionCount
	destination.PartitionCount = genruntime.ClonePointerToInt(service.PartitionCount)

	// PublicNetworkAccess
	if service.PublicNetworkAccess != nil {
		publicNetworkAccess := string(*service.PublicNetworkAccess)
		destination.PublicNetworkAccess = &publicNetworkAccess
	} else {
		destination.PublicNetworkAccess = nil
	}

	// ReplicaCount
	destination.ReplicaCount = genruntime.ClonePointerToInt(service.ReplicaCount)

	// Sku
	if service.Sku != nil {
		var sku storage.Sku
		err := service.Sku.AssignProperties_To_Sku(&sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Sku() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(service.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_SearchService_STATUS populates our SearchService_Spec from the provided source SearchService_STATUS
func (service *SearchService_Spec) Initialize_From_SearchService_STATUS(source *SearchService_STATUS) error {

	// AuthOptions
	if source.AuthOptions != nil {
		var authOption DataPlaneAuthOptions
		err := authOption.Initialize_From_DataPlaneAuthOptions_STATUS(source.AuthOptions)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_DataPlaneAuthOptions_STATUS() to populate field AuthOptions")
		}
		service.AuthOptions = &authOption
	} else {
		service.AuthOptions = nil
	}

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		service.DisableLocalAuth = &disableLocalAuth
	} else {
		service.DisableLocalAuth = nil
	}

	// EncryptionWithCmk
	if source.EncryptionWithCmk != nil {
		var encryptionWithCmk EncryptionWithCmk
		err := encryptionWithCmk.Initialize_From_EncryptionWithCmk_STATUS(source.EncryptionWithCmk)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_EncryptionWithCmk_STATUS() to populate field EncryptionWithCmk")
		}
		service.EncryptionWithCmk = &encryptionWithCmk
	} else {
		service.EncryptionWithCmk = nil
	}

	// HostingMode
	if source.HostingMode != nil {
		hostingMode := genruntime.ToEnum(string(*source.HostingMode), searchServiceProperties_HostingMode_Values)
		service.HostingMode = &hostingMode
	} else {
		service.HostingMode = nil
	}

	// Identity
	if source.Identity != nil {
		var identity Identity
		err := identity.Initialize_From_Identity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_Identity_STATUS() to populate field Identity")
		}
		service.Identity = &identity
	} else {
		service.Identity = nil
	}

	// Location
	service.Location = genruntime.ClonePointerToString(source.Location)

	// NetworkRuleSet
	if source.NetworkRuleSet != nil {
		var networkRuleSet NetworkRuleSet
		err := networkRuleSet.Initialize_From_NetworkRuleSet_STATUS(source.NetworkRuleSet)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_NetworkRuleSet_STATUS() to populate field NetworkRuleSet")
		}
		service.NetworkRuleSet = &networkRuleSet
	} else {
		service.NetworkRuleSet = nil
	}

	// PartitionCount
	service.PartitionCount = genruntime.ClonePointerToInt(source.PartitionCount)

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := genruntime.ToEnum(string(*source.PublicNetworkAccess), searchServiceProperties_PublicNetworkAccess_Values)
		service.PublicNetworkAccess = &publicNetworkAccess
	} else {
		service.PublicNetworkAccess = nil
	}

	// ReplicaCount
	service.ReplicaCount = genruntime.ClonePointerToInt(source.ReplicaCount)

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.Initialize_From_Sku_STATUS(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_Sku_STATUS() to populate field Sku")
		}
		service.Sku = &sku
	} else {
		service.Sku = nil
	}

	// Tags
	service.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (service *SearchService_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (service *SearchService_Spec) SetAzureName(azureName string) { service.AzureName = azureName }

// Describes an Azure Cognitive Search service and its current state.
type SearchService_STATUS struct {
	// AuthOptions: Defines the options for how the data plane API of a search service authenticates requests. This cannot be
	// set if 'disableLocalAuth' is set to true.
	AuthOptions *DataPlaneAuthOptions_STATUS `json:"authOptions,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// DisableLocalAuth: When set to true, calls to the search service will not be permitted to utilize API keys for
	// authentication. This cannot be set to true if 'dataPlaneAuthOptions' are defined.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// EncryptionWithCmk: Specifies any policy regarding encryption of resources (such as indexes) using customer manager keys
	// within a search service.
	EncryptionWithCmk *EncryptionWithCmk_STATUS `json:"encryptionWithCmk,omitempty"`

	// HostingMode: Applicable only for the standard3 SKU. You can set this property to enable up to 3 high density partitions
	// that allow up to 1000 indexes, which is much higher than the maximum indexes allowed for any other SKU. For the
	// standard3 SKU, the value is either 'default' or 'highDensity'. For all other SKUs, this value must be 'default'.
	HostingMode *SearchServiceProperties_HostingMode_STATUS `json:"hostingMode,omitempty"`

	// Id: Fully qualified resource ID for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`

	// Identity: The identity of the resource.
	Identity *Identity_STATUS `json:"identity,omitempty"`

	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// NetworkRuleSet: Network specific rules that determine how the Azure Cognitive Search service may be reached.
	NetworkRuleSet *NetworkRuleSet_STATUS `json:"networkRuleSet,omitempty"`

	// PartitionCount: The number of partitions in the search service; if specified, it can be 1, 2, 3, 4, 6, or 12. Values
	// greater than 1 are only valid for standard SKUs. For 'standard3' services with hostingMode set to 'highDensity', the
	// allowed values are between 1 and 3.
	PartitionCount *int `json:"partitionCount,omitempty"`

	// PrivateEndpointConnections: The list of private endpoint connections to the Azure Cognitive Search service.
	PrivateEndpointConnections []PrivateEndpointConnection_STATUS `json:"privateEndpointConnections,omitempty"`

	// ProvisioningState: The state of the last provisioning operation performed on the search service. Provisioning is an
	// intermediate state that occurs while service capacity is being established. After capacity is set up, provisioningState
	// changes to either 'succeeded' or 'failed'. Client applications can poll provisioning status (the recommended polling
	// interval is from 30 seconds to one minute) by using the Get Search Service operation to see when an operation is
	// completed. If you are using the free service, this value tends to come back as 'succeeded' directly in the call to
	// Create search service. This is because the free service uses capacity that is already set up.
	ProvisioningState *SearchServiceProperties_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// PublicNetworkAccess: This value can be set to 'enabled' to avoid breaking changes on existing customer resources and
	// templates. If set to 'disabled', traffic over public interface is not allowed, and private endpoint connections would be
	// the exclusive access method.
	PublicNetworkAccess *SearchServiceProperties_PublicNetworkAccess_STATUS `json:"publicNetworkAccess,omitempty"`

	// ReplicaCount: The number of replicas in the search service. If specified, it must be a value between 1 and 12 inclusive
	// for standard SKUs or between 1 and 3 inclusive for basic SKU.
	ReplicaCount *int `json:"replicaCount,omitempty"`

	// SharedPrivateLinkResources: The list of shared private link resources managed by the Azure Cognitive Search service.
	SharedPrivateLinkResources []SharedPrivateLinkResource_STATUS `json:"sharedPrivateLinkResources,omitempty"`

	// Sku: The SKU of the Search Service, which determines price tier and capacity limits. This property is required when
	// creating a new Search Service.
	Sku *Sku_STATUS `json:"sku,omitempty"`

	// Status: The status of the search service. Possible values include: 'running': The search service is running and no
	// provisioning operations are underway. 'provisioning': The search service is being provisioned or scaled up or down.
	// 'deleting': The search service is being deleted. 'degraded': The search service is degraded. This can occur when the
	// underlying search units are not healthy. The search service is most likely operational, but performance might be slow
	// and some requests might be dropped. 'disabled': The search service is disabled. In this state, the service will reject
	// all API requests. 'error': The search service is in an error state. If your service is in the degraded, disabled, or
	// error states, it means the Azure Cognitive Search team is actively investigating the underlying issue. Dedicated
	// services in these states are still chargeable based on the number of search units provisioned.
	Status *SearchServiceProperties_Status_STATUS `json:"status,omitempty"`

	// StatusDetails: The details of the search service status.
	StatusDetails *string `json:"statusDetails,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &SearchService_STATUS{}

// ConvertStatusFrom populates our SearchService_STATUS from the provided source
func (service *SearchService_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.SearchService_STATUS)
	if ok {
		// Populate our instance from source
		return service.AssignProperties_From_SearchService_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.SearchService_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = service.AssignProperties_From_SearchService_STATUS(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our SearchService_STATUS
func (service *SearchService_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.SearchService_STATUS)
	if ok {
		// Populate destination from our instance
		return service.AssignProperties_To_SearchService_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.SearchService_STATUS{}
	err := service.AssignProperties_To_SearchService_STATUS(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &SearchService_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (service *SearchService_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SearchService_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (service *SearchService_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SearchService_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SearchService_STATUS, got %T", armInput)
	}

	// Set property "AuthOptions":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AuthOptions != nil {
			var authOptions1 DataPlaneAuthOptions_STATUS
			err := authOptions1.PopulateFromARM(owner, *typedInput.Properties.AuthOptions)
			if err != nil {
				return err
			}
			authOptions := authOptions1
			service.AuthOptions = &authOptions
		}
	}

	// no assignment for property "Conditions"

	// Set property "DisableLocalAuth":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DisableLocalAuth != nil {
			disableLocalAuth := *typedInput.Properties.DisableLocalAuth
			service.DisableLocalAuth = &disableLocalAuth
		}
	}

	// Set property "EncryptionWithCmk":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EncryptionWithCmk != nil {
			var encryptionWithCmk1 EncryptionWithCmk_STATUS
			err := encryptionWithCmk1.PopulateFromARM(owner, *typedInput.Properties.EncryptionWithCmk)
			if err != nil {
				return err
			}
			encryptionWithCmk := encryptionWithCmk1
			service.EncryptionWithCmk = &encryptionWithCmk
		}
	}

	// Set property "HostingMode":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostingMode != nil {
			var temp string
			temp = string(*typedInput.Properties.HostingMode)
			hostingMode := SearchServiceProperties_HostingMode_STATUS(temp)
			service.HostingMode = &hostingMode
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		service.Id = &id
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 Identity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		service.Identity = &identity
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		service.Location = &location
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		service.Name = &name
	}

	// Set property "NetworkRuleSet":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkRuleSet != nil {
			var networkRuleSet1 NetworkRuleSet_STATUS
			err := networkRuleSet1.PopulateFromARM(owner, *typedInput.Properties.NetworkRuleSet)
			if err != nil {
				return err
			}
			networkRuleSet := networkRuleSet1
			service.NetworkRuleSet = &networkRuleSet
		}
	}

	// Set property "PartitionCount":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PartitionCount != nil {
			partitionCount := *typedInput.Properties.PartitionCount
			service.PartitionCount = &partitionCount
		}
	}

	// Set property "PrivateEndpointConnections":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.PrivateEndpointConnections {
			var item1 PrivateEndpointConnection_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			service.PrivateEndpointConnections = append(service.PrivateEndpointConnections, item1)
		}
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			var temp string
			temp = string(*typedInput.Properties.ProvisioningState)
			provisioningState := SearchServiceProperties_ProvisioningState_STATUS(temp)
			service.ProvisioningState = &provisioningState
		}
	}

	// Set property "PublicNetworkAccess":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicNetworkAccess != nil {
			var temp string
			temp = string(*typedInput.Properties.PublicNetworkAccess)
			publicNetworkAccess := SearchServiceProperties_PublicNetworkAccess_STATUS(temp)
			service.PublicNetworkAccess = &publicNetworkAccess
		}
	}

	// Set property "ReplicaCount":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ReplicaCount != nil {
			replicaCount := *typedInput.Properties.ReplicaCount
			service.ReplicaCount = &replicaCount
		}
	}

	// Set property "SharedPrivateLinkResources":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.SharedPrivateLinkResources {
			var item1 SharedPrivateLinkResource_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			service.SharedPrivateLinkResources = append(service.SharedPrivateLinkResources, item1)
		}
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 Sku_STATUS
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		service.Sku = &sku
	}

	// Set property "Status":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Status != nil {
			var temp string
			temp = string(*typedInput.Properties.Status)
			status := SearchServiceProperties_Status_STATUS(temp)
			service.Status = &status
		}
	}

	// Set property "StatusDetails":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.StatusDetails != nil {
			statusDetails := *typedInput.Properties.StatusDetails
			service.StatusDetails = &statusDetails
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		service.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			service.Tags[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		service.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_SearchService_STATUS populates our SearchService_STATUS from the provided source SearchService_STATUS
func (service *SearchService_STATUS) AssignProperties_From_SearchService_STATUS(source *storage.SearchService_STATUS) error {

	// AuthOptions
	if source.AuthOptions != nil {
		var authOption DataPlaneAuthOptions_STATUS
		err := authOption.AssignProperties_From_DataPlaneAuthOptions_STATUS(source.AuthOptions)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DataPlaneAuthOptions_STATUS() to populate field AuthOptions")
		}
		service.AuthOptions = &authOption
	} else {
		service.AuthOptions = nil
	}

	// Conditions
	service.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		service.DisableLocalAuth = &disableLocalAuth
	} else {
		service.DisableLocalAuth = nil
	}

	// EncryptionWithCmk
	if source.EncryptionWithCmk != nil {
		var encryptionWithCmk EncryptionWithCmk_STATUS
		err := encryptionWithCmk.AssignProperties_From_EncryptionWithCmk_STATUS(source.EncryptionWithCmk)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EncryptionWithCmk_STATUS() to populate field EncryptionWithCmk")
		}
		service.EncryptionWithCmk = &encryptionWithCmk
	} else {
		service.EncryptionWithCmk = nil
	}

	// HostingMode
	if source.HostingMode != nil {
		hostingMode := *source.HostingMode
		hostingModeTemp := genruntime.ToEnum(hostingMode, searchServiceProperties_HostingMode_STATUS_Values)
		service.HostingMode = &hostingModeTemp
	} else {
		service.HostingMode = nil
	}

	// Id
	service.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity Identity_STATUS
		err := identity.AssignProperties_From_Identity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Identity_STATUS() to populate field Identity")
		}
		service.Identity = &identity
	} else {
		service.Identity = nil
	}

	// Location
	service.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	service.Name = genruntime.ClonePointerToString(source.Name)

	// NetworkRuleSet
	if source.NetworkRuleSet != nil {
		var networkRuleSet NetworkRuleSet_STATUS
		err := networkRuleSet.AssignProperties_From_NetworkRuleSet_STATUS(source.NetworkRuleSet)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_NetworkRuleSet_STATUS() to populate field NetworkRuleSet")
		}
		service.NetworkRuleSet = &networkRuleSet
	} else {
		service.NetworkRuleSet = nil
	}

	// PartitionCount
	service.PartitionCount = genruntime.ClonePointerToInt(source.PartitionCount)

	// PrivateEndpointConnections
	if source.PrivateEndpointConnections != nil {
		privateEndpointConnectionList := make([]PrivateEndpointConnection_STATUS, len(source.PrivateEndpointConnections))
		for privateEndpointConnectionIndex, privateEndpointConnectionItem := range source.PrivateEndpointConnections {
			// Shadow the loop variable to avoid aliasing
			privateEndpointConnectionItem := privateEndpointConnectionItem
			var privateEndpointConnection PrivateEndpointConnection_STATUS
			err := privateEndpointConnection.AssignProperties_From_PrivateEndpointConnection_STATUS(&privateEndpointConnectionItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_PrivateEndpointConnection_STATUS() to populate field PrivateEndpointConnections")
			}
			privateEndpointConnectionList[privateEndpointConnectionIndex] = privateEndpointConnection
		}
		service.PrivateEndpointConnections = privateEndpointConnectionList
	} else {
		service.PrivateEndpointConnections = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, searchServiceProperties_ProvisioningState_STATUS_Values)
		service.ProvisioningState = &provisioningStateTemp
	} else {
		service.ProvisioningState = nil
	}

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := *source.PublicNetworkAccess
		publicNetworkAccessTemp := genruntime.ToEnum(publicNetworkAccess, searchServiceProperties_PublicNetworkAccess_STATUS_Values)
		service.PublicNetworkAccess = &publicNetworkAccessTemp
	} else {
		service.PublicNetworkAccess = nil
	}

	// ReplicaCount
	service.ReplicaCount = genruntime.ClonePointerToInt(source.ReplicaCount)

	// SharedPrivateLinkResources
	if source.SharedPrivateLinkResources != nil {
		sharedPrivateLinkResourceList := make([]SharedPrivateLinkResource_STATUS, len(source.SharedPrivateLinkResources))
		for sharedPrivateLinkResourceIndex, sharedPrivateLinkResourceItem := range source.SharedPrivateLinkResources {
			// Shadow the loop variable to avoid aliasing
			sharedPrivateLinkResourceItem := sharedPrivateLinkResourceItem
			var sharedPrivateLinkResource SharedPrivateLinkResource_STATUS
			err := sharedPrivateLinkResource.AssignProperties_From_SharedPrivateLinkResource_STATUS(&sharedPrivateLinkResourceItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_SharedPrivateLinkResource_STATUS() to populate field SharedPrivateLinkResources")
			}
			sharedPrivateLinkResourceList[sharedPrivateLinkResourceIndex] = sharedPrivateLinkResource
		}
		service.SharedPrivateLinkResources = sharedPrivateLinkResourceList
	} else {
		service.SharedPrivateLinkResources = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku_STATUS
		err := sku.AssignProperties_From_Sku_STATUS(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Sku_STATUS() to populate field Sku")
		}
		service.Sku = &sku
	} else {
		service.Sku = nil
	}

	// Status
	if source.Status != nil {
		status := *source.Status
		statusTemp := genruntime.ToEnum(status, searchServiceProperties_Status_STATUS_Values)
		service.Status = &statusTemp
	} else {
		service.Status = nil
	}

	// StatusDetails
	service.StatusDetails = genruntime.ClonePointerToString(source.StatusDetails)

	// Tags
	service.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	service.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_SearchService_STATUS populates the provided destination SearchService_STATUS from our SearchService_STATUS
func (service *SearchService_STATUS) AssignProperties_To_SearchService_STATUS(destination *storage.SearchService_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthOptions
	if service.AuthOptions != nil {
		var authOption storage.DataPlaneAuthOptions_STATUS
		err := service.AuthOptions.AssignProperties_To_DataPlaneAuthOptions_STATUS(&authOption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DataPlaneAuthOptions_STATUS() to populate field AuthOptions")
		}
		destination.AuthOptions = &authOption
	} else {
		destination.AuthOptions = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(service.Conditions)

	// DisableLocalAuth
	if service.DisableLocalAuth != nil {
		disableLocalAuth := *service.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// EncryptionWithCmk
	if service.EncryptionWithCmk != nil {
		var encryptionWithCmk storage.EncryptionWithCmk_STATUS
		err := service.EncryptionWithCmk.AssignProperties_To_EncryptionWithCmk_STATUS(&encryptionWithCmk)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EncryptionWithCmk_STATUS() to populate field EncryptionWithCmk")
		}
		destination.EncryptionWithCmk = &encryptionWithCmk
	} else {
		destination.EncryptionWithCmk = nil
	}

	// HostingMode
	if service.HostingMode != nil {
		hostingMode := string(*service.HostingMode)
		destination.HostingMode = &hostingMode
	} else {
		destination.HostingMode = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(service.Id)

	// Identity
	if service.Identity != nil {
		var identity storage.Identity_STATUS
		err := service.Identity.AssignProperties_To_Identity_STATUS(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Identity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(service.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(service.Name)

	// NetworkRuleSet
	if service.NetworkRuleSet != nil {
		var networkRuleSet storage.NetworkRuleSet_STATUS
		err := service.NetworkRuleSet.AssignProperties_To_NetworkRuleSet_STATUS(&networkRuleSet)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_NetworkRuleSet_STATUS() to populate field NetworkRuleSet")
		}
		destination.NetworkRuleSet = &networkRuleSet
	} else {
		destination.NetworkRuleSet = nil
	}

	// PartitionCount
	destination.PartitionCount = genruntime.ClonePointerToInt(service.PartitionCount)

	// PrivateEndpointConnections
	if service.PrivateEndpointConnections != nil {
		privateEndpointConnectionList := make([]storage.PrivateEndpointConnection_STATUS, len(service.PrivateEndpointConnections))
		for privateEndpointConnectionIndex, privateEndpointConnectionItem := range service.PrivateEndpointConnections {
			// Shadow the loop variable to avoid aliasing
			privateEndpointConnectionItem := privateEndpointConnectionItem
			var privateEndpointConnection storage.PrivateEndpointConnection_STATUS
			err := privateEndpointConnectionItem.AssignProperties_To_PrivateEndpointConnection_STATUS(&privateEndpointConnection)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_PrivateEndpointConnection_STATUS() to populate field PrivateEndpointConnections")
			}
			privateEndpointConnectionList[privateEndpointConnectionIndex] = privateEndpointConnection
		}
		destination.PrivateEndpointConnections = privateEndpointConnectionList
	} else {
		destination.PrivateEndpointConnections = nil
	}

	// ProvisioningState
	if service.ProvisioningState != nil {
		provisioningState := string(*service.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// PublicNetworkAccess
	if service.PublicNetworkAccess != nil {
		publicNetworkAccess := string(*service.PublicNetworkAccess)
		destination.PublicNetworkAccess = &publicNetworkAccess
	} else {
		destination.PublicNetworkAccess = nil
	}

	// ReplicaCount
	destination.ReplicaCount = genruntime.ClonePointerToInt(service.ReplicaCount)

	// SharedPrivateLinkResources
	if service.SharedPrivateLinkResources != nil {
		sharedPrivateLinkResourceList := make([]storage.SharedPrivateLinkResource_STATUS, len(service.SharedPrivateLinkResources))
		for sharedPrivateLinkResourceIndex, sharedPrivateLinkResourceItem := range service.SharedPrivateLinkResources {
			// Shadow the loop variable to avoid aliasing
			sharedPrivateLinkResourceItem := sharedPrivateLinkResourceItem
			var sharedPrivateLinkResource storage.SharedPrivateLinkResource_STATUS
			err := sharedPrivateLinkResourceItem.AssignProperties_To_SharedPrivateLinkResource_STATUS(&sharedPrivateLinkResource)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_SharedPrivateLinkResource_STATUS() to populate field SharedPrivateLinkResources")
			}
			sharedPrivateLinkResourceList[sharedPrivateLinkResourceIndex] = sharedPrivateLinkResource
		}
		destination.SharedPrivateLinkResources = sharedPrivateLinkResourceList
	} else {
		destination.SharedPrivateLinkResources = nil
	}

	// Sku
	if service.Sku != nil {
		var sku storage.Sku_STATUS
		err := service.Sku.AssignProperties_To_Sku_STATUS(&sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Sku_STATUS() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Status
	if service.Status != nil {
		status := string(*service.Status)
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// StatusDetails
	destination.StatusDetails = genruntime.ClonePointerToString(service.StatusDetails)

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(service.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(service.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the options for how the data plane API of a Search service authenticates requests. This cannot be set if
// 'disableLocalAuth' is set to true.
type DataPlaneAuthOptions struct {
	// AadOrApiKey: Indicates that either the API key or an access token from Azure Active Directory can be used for
	// authentication.
	AadOrApiKey *DataPlaneAadOrApiKeyAuthOption `json:"aadOrApiKey,omitempty"`
}

var _ genruntime.ARMTransformer = &DataPlaneAuthOptions{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (options *DataPlaneAuthOptions) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if options == nil {
		return nil, nil
	}
	result := &arm.DataPlaneAuthOptions{}

	// Set property "AadOrApiKey":
	if options.AadOrApiKey != nil {
		aadOrApiKey_ARM, err := (*options.AadOrApiKey).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		aadOrApiKey := *aadOrApiKey_ARM.(*arm.DataPlaneAadOrApiKeyAuthOption)
		result.AadOrApiKey = &aadOrApiKey
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (options *DataPlaneAuthOptions) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DataPlaneAuthOptions{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (options *DataPlaneAuthOptions) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DataPlaneAuthOptions)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DataPlaneAuthOptions, got %T", armInput)
	}

	// Set property "AadOrApiKey":
	if typedInput.AadOrApiKey != nil {
		var aadOrApiKey1 DataPlaneAadOrApiKeyAuthOption
		err := aadOrApiKey1.PopulateFromARM(owner, *typedInput.AadOrApiKey)
		if err != nil {
			return err
		}
		aadOrApiKey := aadOrApiKey1
		options.AadOrApiKey = &aadOrApiKey
	}

	// No error
	return nil
}

// AssignProperties_From_DataPlaneAuthOptions populates our DataPlaneAuthOptions from the provided source DataPlaneAuthOptions
func (options *DataPlaneAuthOptions) AssignProperties_From_DataPlaneAuthOptions(source *storage.DataPlaneAuthOptions) error {

	// AadOrApiKey
	if source.AadOrApiKey != nil {
		var aadOrApiKey DataPlaneAadOrApiKeyAuthOption
		err := aadOrApiKey.AssignProperties_From_DataPlaneAadOrApiKeyAuthOption(source.AadOrApiKey)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DataPlaneAadOrApiKeyAuthOption() to populate field AadOrApiKey")
		}
		options.AadOrApiKey = &aadOrApiKey
	} else {
		options.AadOrApiKey = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DataPlaneAuthOptions populates the provided destination DataPlaneAuthOptions from our DataPlaneAuthOptions
func (options *DataPlaneAuthOptions) AssignProperties_To_DataPlaneAuthOptions(destination *storage.DataPlaneAuthOptions) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AadOrApiKey
	if options.AadOrApiKey != nil {
		var aadOrApiKey storage.DataPlaneAadOrApiKeyAuthOption
		err := options.AadOrApiKey.AssignProperties_To_DataPlaneAadOrApiKeyAuthOption(&aadOrApiKey)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DataPlaneAadOrApiKeyAuthOption() to populate field AadOrApiKey")
		}
		destination.AadOrApiKey = &aadOrApiKey
	} else {
		destination.AadOrApiKey = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DataPlaneAuthOptions_STATUS populates our DataPlaneAuthOptions from the provided source DataPlaneAuthOptions_STATUS
func (options *DataPlaneAuthOptions) Initialize_From_DataPlaneAuthOptions_STATUS(source *DataPlaneAuthOptions_STATUS) error {

	// AadOrApiKey
	if source.AadOrApiKey != nil {
		var aadOrApiKey DataPlaneAadOrApiKeyAuthOption
		err := aadOrApiKey.Initialize_From_DataPlaneAadOrApiKeyAuthOption_STATUS(source.AadOrApiKey)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_DataPlaneAadOrApiKeyAuthOption_STATUS() to populate field AadOrApiKey")
		}
		options.AadOrApiKey = &aadOrApiKey
	} else {
		options.AadOrApiKey = nil
	}

	// No error
	return nil
}

// Defines the options for how the data plane API of a Search service authenticates requests. This cannot be set if
// 'disableLocalAuth' is set to true.
type DataPlaneAuthOptions_STATUS struct {
	// AadOrApiKey: Indicates that either the API key or an access token from Azure Active Directory can be used for
	// authentication.
	AadOrApiKey *DataPlaneAadOrApiKeyAuthOption_STATUS `json:"aadOrApiKey,omitempty"`

	// ApiKeyOnly: Indicates that only the API key needs to be used for authentication.
	ApiKeyOnly map[string]v1.JSON `json:"apiKeyOnly,omitempty"`
}

var _ genruntime.FromARMConverter = &DataPlaneAuthOptions_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (options *DataPlaneAuthOptions_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DataPlaneAuthOptions_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (options *DataPlaneAuthOptions_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DataPlaneAuthOptions_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DataPlaneAuthOptions_STATUS, got %T", armInput)
	}

	// Set property "AadOrApiKey":
	if typedInput.AadOrApiKey != nil {
		var aadOrApiKey1 DataPlaneAadOrApiKeyAuthOption_STATUS
		err := aadOrApiKey1.PopulateFromARM(owner, *typedInput.AadOrApiKey)
		if err != nil {
			return err
		}
		aadOrApiKey := aadOrApiKey1
		options.AadOrApiKey = &aadOrApiKey
	}

	// Set property "ApiKeyOnly":
	if typedInput.ApiKeyOnly != nil {
		options.ApiKeyOnly = make(map[string]v1.JSON, len(typedInput.ApiKeyOnly))
		for key, value := range typedInput.ApiKeyOnly {
			options.ApiKeyOnly[key] = *value.DeepCopy()
		}
	}

	// No error
	return nil
}

// AssignProperties_From_DataPlaneAuthOptions_STATUS populates our DataPlaneAuthOptions_STATUS from the provided source DataPlaneAuthOptions_STATUS
func (options *DataPlaneAuthOptions_STATUS) AssignProperties_From_DataPlaneAuthOptions_STATUS(source *storage.DataPlaneAuthOptions_STATUS) error {

	// AadOrApiKey
	if source.AadOrApiKey != nil {
		var aadOrApiKey DataPlaneAadOrApiKeyAuthOption_STATUS
		err := aadOrApiKey.AssignProperties_From_DataPlaneAadOrApiKeyAuthOption_STATUS(source.AadOrApiKey)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DataPlaneAadOrApiKeyAuthOption_STATUS() to populate field AadOrApiKey")
		}
		options.AadOrApiKey = &aadOrApiKey
	} else {
		options.AadOrApiKey = nil
	}

	// ApiKeyOnly
	if source.ApiKeyOnly != nil {
		apiKeyOnlyMap := make(map[string]v1.JSON, len(source.ApiKeyOnly))
		for apiKeyOnlyKey, apiKeyOnlyValue := range source.ApiKeyOnly {
			// Shadow the loop variable to avoid aliasing
			apiKeyOnlyValue := apiKeyOnlyValue
			apiKeyOnlyMap[apiKeyOnlyKey] = *apiKeyOnlyValue.DeepCopy()
		}
		options.ApiKeyOnly = apiKeyOnlyMap
	} else {
		options.ApiKeyOnly = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DataPlaneAuthOptions_STATUS populates the provided destination DataPlaneAuthOptions_STATUS from our DataPlaneAuthOptions_STATUS
func (options *DataPlaneAuthOptions_STATUS) AssignProperties_To_DataPlaneAuthOptions_STATUS(destination *storage.DataPlaneAuthOptions_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AadOrApiKey
	if options.AadOrApiKey != nil {
		var aadOrApiKey storage.DataPlaneAadOrApiKeyAuthOption_STATUS
		err := options.AadOrApiKey.AssignProperties_To_DataPlaneAadOrApiKeyAuthOption_STATUS(&aadOrApiKey)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DataPlaneAadOrApiKeyAuthOption_STATUS() to populate field AadOrApiKey")
		}
		destination.AadOrApiKey = &aadOrApiKey
	} else {
		destination.AadOrApiKey = nil
	}

	// ApiKeyOnly
	if options.ApiKeyOnly != nil {
		apiKeyOnlyMap := make(map[string]v1.JSON, len(options.ApiKeyOnly))
		for apiKeyOnlyKey, apiKeyOnlyValue := range options.ApiKeyOnly {
			// Shadow the loop variable to avoid aliasing
			apiKeyOnlyValue := apiKeyOnlyValue
			apiKeyOnlyMap[apiKeyOnlyKey] = *apiKeyOnlyValue.DeepCopy()
		}
		destination.ApiKeyOnly = apiKeyOnlyMap
	} else {
		destination.ApiKeyOnly = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes a policy that determines how resources within the search service are to be encrypted with Customer Managed
// Keys.
type EncryptionWithCmk struct {
	// Enforcement: Describes how a search service should enforce having one or more non customer encrypted resources.
	Enforcement *EncryptionWithCmk_Enforcement `json:"enforcement,omitempty"`
}

var _ genruntime.ARMTransformer = &EncryptionWithCmk{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (withCmk *EncryptionWithCmk) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if withCmk == nil {
		return nil, nil
	}
	result := &arm.EncryptionWithCmk{}

	// Set property "Enforcement":
	if withCmk.Enforcement != nil {
		var temp string
		temp = string(*withCmk.Enforcement)
		enforcement := arm.EncryptionWithCmk_Enforcement(temp)
		result.Enforcement = &enforcement
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (withCmk *EncryptionWithCmk) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EncryptionWithCmk{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (withCmk *EncryptionWithCmk) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EncryptionWithCmk)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EncryptionWithCmk, got %T", armInput)
	}

	// Set property "Enforcement":
	if typedInput.Enforcement != nil {
		var temp string
		temp = string(*typedInput.Enforcement)
		enforcement := EncryptionWithCmk_Enforcement(temp)
		withCmk.Enforcement = &enforcement
	}

	// No error
	return nil
}

// AssignProperties_From_EncryptionWithCmk populates our EncryptionWithCmk from the provided source EncryptionWithCmk
func (withCmk *EncryptionWithCmk) AssignProperties_From_EncryptionWithCmk(source *storage.EncryptionWithCmk) error {

	// Enforcement
	if source.Enforcement != nil {
		enforcement := *source.Enforcement
		enforcementTemp := genruntime.ToEnum(enforcement, encryptionWithCmk_Enforcement_Values)
		withCmk.Enforcement = &enforcementTemp
	} else {
		withCmk.Enforcement = nil
	}

	// No error
	return nil
}

// AssignProperties_To_EncryptionWithCmk populates the provided destination EncryptionWithCmk from our EncryptionWithCmk
func (withCmk *EncryptionWithCmk) AssignProperties_To_EncryptionWithCmk(destination *storage.EncryptionWithCmk) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enforcement
	if withCmk.Enforcement != nil {
		enforcement := string(*withCmk.Enforcement)
		destination.Enforcement = &enforcement
	} else {
		destination.Enforcement = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_EncryptionWithCmk_STATUS populates our EncryptionWithCmk from the provided source EncryptionWithCmk_STATUS
func (withCmk *EncryptionWithCmk) Initialize_From_EncryptionWithCmk_STATUS(source *EncryptionWithCmk_STATUS) error {

	// Enforcement
	if source.Enforcement != nil {
		enforcement := genruntime.ToEnum(string(*source.Enforcement), encryptionWithCmk_Enforcement_Values)
		withCmk.Enforcement = &enforcement
	} else {
		withCmk.Enforcement = nil
	}

	// No error
	return nil
}

// Describes a policy that determines how resources within the search service are to be encrypted with Customer Managed
// Keys.
type EncryptionWithCmk_STATUS struct {
	// EncryptionComplianceStatus: Describes whether the search service is compliant or not with respect to having non customer
	// encrypted resources. If a service has more than one non customer encrypted resource and 'Enforcement' is 'enabled' then
	// the service will be marked as 'nonCompliant'.
	EncryptionComplianceStatus *EncryptionWithCmk_EncryptionComplianceStatus_STATUS `json:"encryptionComplianceStatus,omitempty"`

	// Enforcement: Describes how a search service should enforce having one or more non customer encrypted resources.
	Enforcement *EncryptionWithCmk_Enforcement_STATUS `json:"enforcement,omitempty"`
}

var _ genruntime.FromARMConverter = &EncryptionWithCmk_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (withCmk *EncryptionWithCmk_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EncryptionWithCmk_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (withCmk *EncryptionWithCmk_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EncryptionWithCmk_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EncryptionWithCmk_STATUS, got %T", armInput)
	}

	// Set property "EncryptionComplianceStatus":
	if typedInput.EncryptionComplianceStatus != nil {
		var temp string
		temp = string(*typedInput.EncryptionComplianceStatus)
		encryptionComplianceStatus := EncryptionWithCmk_EncryptionComplianceStatus_STATUS(temp)
		withCmk.EncryptionComplianceStatus = &encryptionComplianceStatus
	}

	// Set property "Enforcement":
	if typedInput.Enforcement != nil {
		var temp string
		temp = string(*typedInput.Enforcement)
		enforcement := EncryptionWithCmk_Enforcement_STATUS(temp)
		withCmk.Enforcement = &enforcement
	}

	// No error
	return nil
}

// AssignProperties_From_EncryptionWithCmk_STATUS populates our EncryptionWithCmk_STATUS from the provided source EncryptionWithCmk_STATUS
func (withCmk *EncryptionWithCmk_STATUS) AssignProperties_From_EncryptionWithCmk_STATUS(source *storage.EncryptionWithCmk_STATUS) error {

	// EncryptionComplianceStatus
	if source.EncryptionComplianceStatus != nil {
		encryptionComplianceStatus := *source.EncryptionComplianceStatus
		encryptionComplianceStatusTemp := genruntime.ToEnum(encryptionComplianceStatus, encryptionWithCmk_EncryptionComplianceStatus_STATUS_Values)
		withCmk.EncryptionComplianceStatus = &encryptionComplianceStatusTemp
	} else {
		withCmk.EncryptionComplianceStatus = nil
	}

	// Enforcement
	if source.Enforcement != nil {
		enforcement := *source.Enforcement
		enforcementTemp := genruntime.ToEnum(enforcement, encryptionWithCmk_Enforcement_STATUS_Values)
		withCmk.Enforcement = &enforcementTemp
	} else {
		withCmk.Enforcement = nil
	}

	// No error
	return nil
}

// AssignProperties_To_EncryptionWithCmk_STATUS populates the provided destination EncryptionWithCmk_STATUS from our EncryptionWithCmk_STATUS
func (withCmk *EncryptionWithCmk_STATUS) AssignProperties_To_EncryptionWithCmk_STATUS(destination *storage.EncryptionWithCmk_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EncryptionComplianceStatus
	if withCmk.EncryptionComplianceStatus != nil {
		encryptionComplianceStatus := string(*withCmk.EncryptionComplianceStatus)
		destination.EncryptionComplianceStatus = &encryptionComplianceStatus
	} else {
		destination.EncryptionComplianceStatus = nil
	}

	// Enforcement
	if withCmk.Enforcement != nil {
		enforcement := string(*withCmk.Enforcement)
		destination.Enforcement = &enforcement
	} else {
		destination.Enforcement = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Identity for the resource.
type Identity struct {
	// +kubebuilder:validation:Required
	// Type: The identity type.
	Type *Identity_Type `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &Identity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *Identity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &arm.Identity{}

	// Set property "Type":
	if identity.Type != nil {
		var temp string
		temp = string(*identity.Type)
		typeVar := arm.Identity_Type(temp)
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *Identity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Identity{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *Identity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Identity)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Identity, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := Identity_Type(temp)
		identity.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_Identity populates our Identity from the provided source Identity
func (identity *Identity) AssignProperties_From_Identity(source *storage.Identity) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, identity_Type_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Identity populates the provided destination Identity from our Identity
func (identity *Identity) AssignProperties_To_Identity(destination *storage.Identity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Identity_STATUS populates our Identity from the provided source Identity_STATUS
func (identity *Identity) Initialize_From_Identity_STATUS(source *Identity_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := genruntime.ToEnum(string(*source.Type), identity_Type_Values)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// No error
	return nil
}

// Identity for the resource.
type Identity_STATUS struct {
	// PrincipalId: The principal ID of the system-assigned identity of the search service.
	PrincipalId *string `json:"principalId,omitempty"`

	// TenantId: The tenant ID of the system-assigned identity of the search service.
	TenantId *string `json:"tenantId,omitempty"`

	// Type: The identity type.
	Type *Identity_Type_STATUS `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &Identity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *Identity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Identity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *Identity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Identity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Identity_STATUS, got %T", armInput)
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		identity.TenantId = &tenantId
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := Identity_Type_STATUS(temp)
		identity.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_Identity_STATUS populates our Identity_STATUS from the provided source Identity_STATUS
func (identity *Identity_STATUS) AssignProperties_From_Identity_STATUS(source *storage.Identity_STATUS) error {

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, identity_Type_STATUS_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Identity_STATUS populates the provided destination Identity_STATUS from our Identity_STATUS
func (identity *Identity_STATUS) AssignProperties_To_Identity_STATUS(destination *storage.Identity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Network specific rules that determine how the Azure Cognitive Search service may be reached.
type NetworkRuleSet struct {
	// IpRules: A list of IP restriction rules that defines the inbound network(s) with allowing access to the search service
	// endpoint. At the meantime, all other public IP networks are blocked by the firewall. These restriction rules are applied
	// only when the 'publicNetworkAccess' of the search service is 'enabled'; otherwise, traffic over public interface is not
	// allowed even with any public IP rules, and private endpoint connections would be the exclusive access method.
	IpRules []IpRule `json:"ipRules,omitempty"`
}

var _ genruntime.ARMTransformer = &NetworkRuleSet{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (ruleSet *NetworkRuleSet) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if ruleSet == nil {
		return nil, nil
	}
	result := &arm.NetworkRuleSet{}

	// Set property "IpRules":
	for _, item := range ruleSet.IpRules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.IpRules = append(result.IpRules, *item_ARM.(*arm.IpRule))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (ruleSet *NetworkRuleSet) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NetworkRuleSet{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (ruleSet *NetworkRuleSet) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NetworkRuleSet)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NetworkRuleSet, got %T", armInput)
	}

	// Set property "IpRules":
	for _, item := range typedInput.IpRules {
		var item1 IpRule
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		ruleSet.IpRules = append(ruleSet.IpRules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_NetworkRuleSet populates our NetworkRuleSet from the provided source NetworkRuleSet
func (ruleSet *NetworkRuleSet) AssignProperties_From_NetworkRuleSet(source *storage.NetworkRuleSet) error {

	// IpRules
	if source.IpRules != nil {
		ipRuleList := make([]IpRule, len(source.IpRules))
		for ipRuleIndex, ipRuleItem := range source.IpRules {
			// Shadow the loop variable to avoid aliasing
			ipRuleItem := ipRuleItem
			var ipRule IpRule
			err := ipRule.AssignProperties_From_IpRule(&ipRuleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_IpRule() to populate field IpRules")
			}
			ipRuleList[ipRuleIndex] = ipRule
		}
		ruleSet.IpRules = ipRuleList
	} else {
		ruleSet.IpRules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_NetworkRuleSet populates the provided destination NetworkRuleSet from our NetworkRuleSet
func (ruleSet *NetworkRuleSet) AssignProperties_To_NetworkRuleSet(destination *storage.NetworkRuleSet) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IpRules
	if ruleSet.IpRules != nil {
		ipRuleList := make([]storage.IpRule, len(ruleSet.IpRules))
		for ipRuleIndex, ipRuleItem := range ruleSet.IpRules {
			// Shadow the loop variable to avoid aliasing
			ipRuleItem := ipRuleItem
			var ipRule storage.IpRule
			err := ipRuleItem.AssignProperties_To_IpRule(&ipRule)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_IpRule() to populate field IpRules")
			}
			ipRuleList[ipRuleIndex] = ipRule
		}
		destination.IpRules = ipRuleList
	} else {
		destination.IpRules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_NetworkRuleSet_STATUS populates our NetworkRuleSet from the provided source NetworkRuleSet_STATUS
func (ruleSet *NetworkRuleSet) Initialize_From_NetworkRuleSet_STATUS(source *NetworkRuleSet_STATUS) error {

	// IpRules
	if source.IpRules != nil {
		ipRuleList := make([]IpRule, len(source.IpRules))
		for ipRuleIndex, ipRuleItem := range source.IpRules {
			// Shadow the loop variable to avoid aliasing
			ipRuleItem := ipRuleItem
			var ipRule IpRule
			err := ipRule.Initialize_From_IpRule_STATUS(&ipRuleItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_IpRule_STATUS() to populate field IpRules")
			}
			ipRuleList[ipRuleIndex] = ipRule
		}
		ruleSet.IpRules = ipRuleList
	} else {
		ruleSet.IpRules = nil
	}

	// No error
	return nil
}

// Network specific rules that determine how the Azure Cognitive Search service may be reached.
type NetworkRuleSet_STATUS struct {
	// IpRules: A list of IP restriction rules that defines the inbound network(s) with allowing access to the search service
	// endpoint. At the meantime, all other public IP networks are blocked by the firewall. These restriction rules are applied
	// only when the 'publicNetworkAccess' of the search service is 'enabled'; otherwise, traffic over public interface is not
	// allowed even with any public IP rules, and private endpoint connections would be the exclusive access method.
	IpRules []IpRule_STATUS `json:"ipRules,omitempty"`
}

var _ genruntime.FromARMConverter = &NetworkRuleSet_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (ruleSet *NetworkRuleSet_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NetworkRuleSet_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (ruleSet *NetworkRuleSet_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NetworkRuleSet_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NetworkRuleSet_STATUS, got %T", armInput)
	}

	// Set property "IpRules":
	for _, item := range typedInput.IpRules {
		var item1 IpRule_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		ruleSet.IpRules = append(ruleSet.IpRules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_NetworkRuleSet_STATUS populates our NetworkRuleSet_STATUS from the provided source NetworkRuleSet_STATUS
func (ruleSet *NetworkRuleSet_STATUS) AssignProperties_From_NetworkRuleSet_STATUS(source *storage.NetworkRuleSet_STATUS) error {

	// IpRules
	if source.IpRules != nil {
		ipRuleList := make([]IpRule_STATUS, len(source.IpRules))
		for ipRuleIndex, ipRuleItem := range source.IpRules {
			// Shadow the loop variable to avoid aliasing
			ipRuleItem := ipRuleItem
			var ipRule IpRule_STATUS
			err := ipRule.AssignProperties_From_IpRule_STATUS(&ipRuleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_IpRule_STATUS() to populate field IpRules")
			}
			ipRuleList[ipRuleIndex] = ipRule
		}
		ruleSet.IpRules = ipRuleList
	} else {
		ruleSet.IpRules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_NetworkRuleSet_STATUS populates the provided destination NetworkRuleSet_STATUS from our NetworkRuleSet_STATUS
func (ruleSet *NetworkRuleSet_STATUS) AssignProperties_To_NetworkRuleSet_STATUS(destination *storage.NetworkRuleSet_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IpRules
	if ruleSet.IpRules != nil {
		ipRuleList := make([]storage.IpRule_STATUS, len(ruleSet.IpRules))
		for ipRuleIndex, ipRuleItem := range ruleSet.IpRules {
			// Shadow the loop variable to avoid aliasing
			ipRuleItem := ipRuleItem
			var ipRule storage.IpRule_STATUS
			err := ipRuleItem.AssignProperties_To_IpRule_STATUS(&ipRule)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_IpRule_STATUS() to populate field IpRules")
			}
			ipRuleList[ipRuleIndex] = ipRule
		}
		destination.IpRules = ipRuleList
	} else {
		destination.IpRules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes an existing Private Endpoint connection to the Azure Cognitive Search service.
type PrivateEndpointConnection_STATUS struct {
	// Id: Fully qualified resource ID for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &PrivateEndpointConnection_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (connection *PrivateEndpointConnection_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PrivateEndpointConnection_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (connection *PrivateEndpointConnection_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PrivateEndpointConnection_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PrivateEndpointConnection_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		connection.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_PrivateEndpointConnection_STATUS populates our PrivateEndpointConnection_STATUS from the provided source PrivateEndpointConnection_STATUS
func (connection *PrivateEndpointConnection_STATUS) AssignProperties_From_PrivateEndpointConnection_STATUS(source *storage.PrivateEndpointConnection_STATUS) error {

	// Id
	connection.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_PrivateEndpointConnection_STATUS populates the provided destination PrivateEndpointConnection_STATUS from our PrivateEndpointConnection_STATUS
func (connection *PrivateEndpointConnection_STATUS) AssignProperties_To_PrivateEndpointConnection_STATUS(destination *storage.PrivateEndpointConnection_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(connection.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type SearchServiceOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`

	// Secrets: configures where to place Azure generated secrets.
	Secrets *SearchServiceOperatorSecrets `json:"secrets,omitempty"`
}

// AssignProperties_From_SearchServiceOperatorSpec populates our SearchServiceOperatorSpec from the provided source SearchServiceOperatorSpec
func (operator *SearchServiceOperatorSpec) AssignProperties_From_SearchServiceOperatorSpec(source *storage.SearchServiceOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// Secrets
	if source.Secrets != nil {
		var secret SearchServiceOperatorSecrets
		err := secret.AssignProperties_From_SearchServiceOperatorSecrets(source.Secrets)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SearchServiceOperatorSecrets() to populate field Secrets")
		}
		operator.Secrets = &secret
	} else {
		operator.Secrets = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SearchServiceOperatorSpec populates the provided destination SearchServiceOperatorSpec from our SearchServiceOperatorSpec
func (operator *SearchServiceOperatorSpec) AssignProperties_To_SearchServiceOperatorSpec(destination *storage.SearchServiceOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Secrets
	if operator.Secrets != nil {
		var secret storage.SearchServiceOperatorSecrets
		err := operator.Secrets.AssignProperties_To_SearchServiceOperatorSecrets(&secret)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SearchServiceOperatorSecrets() to populate field Secrets")
		}
		destination.Secrets = &secret
	} else {
		destination.Secrets = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"default","highDensity"}
type SearchServiceProperties_HostingMode string

const (
	SearchServiceProperties_HostingMode_Default     = SearchServiceProperties_HostingMode("default")
	SearchServiceProperties_HostingMode_HighDensity = SearchServiceProperties_HostingMode("highDensity")
)

// Mapping from string to SearchServiceProperties_HostingMode
var searchServiceProperties_HostingMode_Values = map[string]SearchServiceProperties_HostingMode{
	"default":     SearchServiceProperties_HostingMode_Default,
	"highdensity": SearchServiceProperties_HostingMode_HighDensity,
}

type SearchServiceProperties_HostingMode_STATUS string

const (
	SearchServiceProperties_HostingMode_STATUS_Default     = SearchServiceProperties_HostingMode_STATUS("default")
	SearchServiceProperties_HostingMode_STATUS_HighDensity = SearchServiceProperties_HostingMode_STATUS("highDensity")
)

// Mapping from string to SearchServiceProperties_HostingMode_STATUS
var searchServiceProperties_HostingMode_STATUS_Values = map[string]SearchServiceProperties_HostingMode_STATUS{
	"default":     SearchServiceProperties_HostingMode_STATUS_Default,
	"highdensity": SearchServiceProperties_HostingMode_STATUS_HighDensity,
}

type SearchServiceProperties_ProvisioningState_STATUS string

const (
	SearchServiceProperties_ProvisioningState_STATUS_Failed       = SearchServiceProperties_ProvisioningState_STATUS("failed")
	SearchServiceProperties_ProvisioningState_STATUS_Provisioning = SearchServiceProperties_ProvisioningState_STATUS("provisioning")
	SearchServiceProperties_ProvisioningState_STATUS_Succeeded    = SearchServiceProperties_ProvisioningState_STATUS("succeeded")
)

// Mapping from string to SearchServiceProperties_ProvisioningState_STATUS
var searchServiceProperties_ProvisioningState_STATUS_Values = map[string]SearchServiceProperties_ProvisioningState_STATUS{
	"failed":       SearchServiceProperties_ProvisioningState_STATUS_Failed,
	"provisioning": SearchServiceProperties_ProvisioningState_STATUS_Provisioning,
	"succeeded":    SearchServiceProperties_ProvisioningState_STATUS_Succeeded,
}

// +kubebuilder:validation:Enum={"disabled","enabled"}
type SearchServiceProperties_PublicNetworkAccess string

const (
	SearchServiceProperties_PublicNetworkAccess_Disabled = SearchServiceProperties_PublicNetworkAccess("disabled")
	SearchServiceProperties_PublicNetworkAccess_Enabled  = SearchServiceProperties_PublicNetworkAccess("enabled")
)

// Mapping from string to SearchServiceProperties_PublicNetworkAccess
var searchServiceProperties_PublicNetworkAccess_Values = map[string]SearchServiceProperties_PublicNetworkAccess{
	"disabled": SearchServiceProperties_PublicNetworkAccess_Disabled,
	"enabled":  SearchServiceProperties_PublicNetworkAccess_Enabled,
}

type SearchServiceProperties_PublicNetworkAccess_STATUS string

const (
	SearchServiceProperties_PublicNetworkAccess_STATUS_Disabled = SearchServiceProperties_PublicNetworkAccess_STATUS("disabled")
	SearchServiceProperties_PublicNetworkAccess_STATUS_Enabled  = SearchServiceProperties_PublicNetworkAccess_STATUS("enabled")
)

// Mapping from string to SearchServiceProperties_PublicNetworkAccess_STATUS
var searchServiceProperties_PublicNetworkAccess_STATUS_Values = map[string]SearchServiceProperties_PublicNetworkAccess_STATUS{
	"disabled": SearchServiceProperties_PublicNetworkAccess_STATUS_Disabled,
	"enabled":  SearchServiceProperties_PublicNetworkAccess_STATUS_Enabled,
}

type SearchServiceProperties_Status_STATUS string

const (
	SearchServiceProperties_Status_STATUS_Degraded     = SearchServiceProperties_Status_STATUS("degraded")
	SearchServiceProperties_Status_STATUS_Deleting     = SearchServiceProperties_Status_STATUS("deleting")
	SearchServiceProperties_Status_STATUS_Disabled     = SearchServiceProperties_Status_STATUS("disabled")
	SearchServiceProperties_Status_STATUS_Error        = SearchServiceProperties_Status_STATUS("error")
	SearchServiceProperties_Status_STATUS_Provisioning = SearchServiceProperties_Status_STATUS("provisioning")
	SearchServiceProperties_Status_STATUS_Running      = SearchServiceProperties_Status_STATUS("running")
)

// Mapping from string to SearchServiceProperties_Status_STATUS
var searchServiceProperties_Status_STATUS_Values = map[string]SearchServiceProperties_Status_STATUS{
	"degraded":     SearchServiceProperties_Status_STATUS_Degraded,
	"deleting":     SearchServiceProperties_Status_STATUS_Deleting,
	"disabled":     SearchServiceProperties_Status_STATUS_Disabled,
	"error":        SearchServiceProperties_Status_STATUS_Error,
	"provisioning": SearchServiceProperties_Status_STATUS_Provisioning,
	"running":      SearchServiceProperties_Status_STATUS_Running,
}

// Describes a Shared Private Link Resource managed by the Azure Cognitive Search service.
type SharedPrivateLinkResource_STATUS struct {
	// Id: Fully qualified resource ID for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &SharedPrivateLinkResource_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *SharedPrivateLinkResource_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SharedPrivateLinkResource_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *SharedPrivateLinkResource_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SharedPrivateLinkResource_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SharedPrivateLinkResource_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		resource.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_SharedPrivateLinkResource_STATUS populates our SharedPrivateLinkResource_STATUS from the provided source SharedPrivateLinkResource_STATUS
func (resource *SharedPrivateLinkResource_STATUS) AssignProperties_From_SharedPrivateLinkResource_STATUS(source *storage.SharedPrivateLinkResource_STATUS) error {

	// Id
	resource.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_SharedPrivateLinkResource_STATUS populates the provided destination SharedPrivateLinkResource_STATUS from our SharedPrivateLinkResource_STATUS
func (resource *SharedPrivateLinkResource_STATUS) AssignProperties_To_SharedPrivateLinkResource_STATUS(destination *storage.SharedPrivateLinkResource_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(resource.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the SKU of an Azure Cognitive Search Service, which determines price tier and capacity limits.
type Sku struct {
	// Name: The SKU of the search service. Valid values include: 'free': Shared service. 'basic': Dedicated service with up to
	// 3 replicas. 'standard': Dedicated service with up to 12 partitions and 12 replicas. 'standard2': Similar to standard,
	// but with more capacity per search unit. 'standard3': The largest Standard offering with up to 12 partitions and 12
	// replicas (or up to 3 partitions with more indexes if you also set the hostingMode property to 'highDensity').
	// 'storage_optimized_l1': Supports 1TB per partition, up to 12 partitions. 'storage_optimized_l2': Supports 2TB per
	// partition, up to 12 partitions.'
	Name *Sku_Name `json:"name,omitempty"`
}

var _ genruntime.ARMTransformer = &Sku{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (sku *Sku) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if sku == nil {
		return nil, nil
	}
	result := &arm.Sku{}

	// Set property "Name":
	if sku.Name != nil {
		var temp string
		temp = string(*sku.Name)
		name := arm.Sku_Name(temp)
		result.Name = &name
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sku *Sku) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Sku{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sku *Sku) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Sku)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Sku, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		var temp string
		temp = string(*typedInput.Name)
		name := Sku_Name(temp)
		sku.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_Sku populates our Sku from the provided source Sku
func (sku *Sku) AssignProperties_From_Sku(source *storage.Sku) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, sku_Name_Values)
		sku.Name = &nameTemp
	} else {
		sku.Name = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Sku populates the provided destination Sku from our Sku
func (sku *Sku) AssignProperties_To_Sku(destination *storage.Sku) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if sku.Name != nil {
		name := string(*sku.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Sku_STATUS populates our Sku from the provided source Sku_STATUS
func (sku *Sku) Initialize_From_Sku_STATUS(source *Sku_STATUS) error {

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), sku_Name_Values)
		sku.Name = &name
	} else {
		sku.Name = nil
	}

	// No error
	return nil
}

// Defines the SKU of an Azure Cognitive Search Service, which determines price tier and capacity limits.
type Sku_STATUS struct {
	// Name: The SKU of the search service. Valid values include: 'free': Shared service. 'basic': Dedicated service with up to
	// 3 replicas. 'standard': Dedicated service with up to 12 partitions and 12 replicas. 'standard2': Similar to standard,
	// but with more capacity per search unit. 'standard3': The largest Standard offering with up to 12 partitions and 12
	// replicas (or up to 3 partitions with more indexes if you also set the hostingMode property to 'highDensity').
	// 'storage_optimized_l1': Supports 1TB per partition, up to 12 partitions. 'storage_optimized_l2': Supports 2TB per
	// partition, up to 12 partitions.'
	Name *Sku_Name_STATUS `json:"name,omitempty"`
}

var _ genruntime.FromARMConverter = &Sku_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sku *Sku_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Sku_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sku *Sku_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Sku_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Sku_STATUS, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		var temp string
		temp = string(*typedInput.Name)
		name := Sku_Name_STATUS(temp)
		sku.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_Sku_STATUS populates our Sku_STATUS from the provided source Sku_STATUS
func (sku *Sku_STATUS) AssignProperties_From_Sku_STATUS(source *storage.Sku_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, sku_Name_STATUS_Values)
		sku.Name = &nameTemp
	} else {
		sku.Name = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Sku_STATUS populates the provided destination Sku_STATUS from our Sku_STATUS
func (sku *Sku_STATUS) AssignProperties_To_Sku_STATUS(destination *storage.Sku_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if sku.Name != nil {
		name := string(*sku.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Indicates that either the API key or an access token from Azure Active Directory can be used for authentication.
type DataPlaneAadOrApiKeyAuthOption struct {
	// AadAuthFailureMode: Describes what response the data plane API of a Search service would send for requests that failed
	// authentication.
	AadAuthFailureMode *DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode `json:"aadAuthFailureMode,omitempty"`
}

var _ genruntime.ARMTransformer = &DataPlaneAadOrApiKeyAuthOption{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (option *DataPlaneAadOrApiKeyAuthOption) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if option == nil {
		return nil, nil
	}
	result := &arm.DataPlaneAadOrApiKeyAuthOption{}

	// Set property "AadAuthFailureMode":
	if option.AadAuthFailureMode != nil {
		var temp string
		temp = string(*option.AadAuthFailureMode)
		aadAuthFailureMode := arm.DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode(temp)
		result.AadAuthFailureMode = &aadAuthFailureMode
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (option *DataPlaneAadOrApiKeyAuthOption) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DataPlaneAadOrApiKeyAuthOption{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (option *DataPlaneAadOrApiKeyAuthOption) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DataPlaneAadOrApiKeyAuthOption)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DataPlaneAadOrApiKeyAuthOption, got %T", armInput)
	}

	// Set property "AadAuthFailureMode":
	if typedInput.AadAuthFailureMode != nil {
		var temp string
		temp = string(*typedInput.AadAuthFailureMode)
		aadAuthFailureMode := DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode(temp)
		option.AadAuthFailureMode = &aadAuthFailureMode
	}

	// No error
	return nil
}

// AssignProperties_From_DataPlaneAadOrApiKeyAuthOption populates our DataPlaneAadOrApiKeyAuthOption from the provided source DataPlaneAadOrApiKeyAuthOption
func (option *DataPlaneAadOrApiKeyAuthOption) AssignProperties_From_DataPlaneAadOrApiKeyAuthOption(source *storage.DataPlaneAadOrApiKeyAuthOption) error {

	// AadAuthFailureMode
	if source.AadAuthFailureMode != nil {
		aadAuthFailureMode := *source.AadAuthFailureMode
		aadAuthFailureModeTemp := genruntime.ToEnum(aadAuthFailureMode, dataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode_Values)
		option.AadAuthFailureMode = &aadAuthFailureModeTemp
	} else {
		option.AadAuthFailureMode = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DataPlaneAadOrApiKeyAuthOption populates the provided destination DataPlaneAadOrApiKeyAuthOption from our DataPlaneAadOrApiKeyAuthOption
func (option *DataPlaneAadOrApiKeyAuthOption) AssignProperties_To_DataPlaneAadOrApiKeyAuthOption(destination *storage.DataPlaneAadOrApiKeyAuthOption) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AadAuthFailureMode
	if option.AadAuthFailureMode != nil {
		aadAuthFailureMode := string(*option.AadAuthFailureMode)
		destination.AadAuthFailureMode = &aadAuthFailureMode
	} else {
		destination.AadAuthFailureMode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DataPlaneAadOrApiKeyAuthOption_STATUS populates our DataPlaneAadOrApiKeyAuthOption from the provided source DataPlaneAadOrApiKeyAuthOption_STATUS
func (option *DataPlaneAadOrApiKeyAuthOption) Initialize_From_DataPlaneAadOrApiKeyAuthOption_STATUS(source *DataPlaneAadOrApiKeyAuthOption_STATUS) error {

	// AadAuthFailureMode
	if source.AadAuthFailureMode != nil {
		aadAuthFailureMode := genruntime.ToEnum(string(*source.AadAuthFailureMode), dataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode_Values)
		option.AadAuthFailureMode = &aadAuthFailureMode
	} else {
		option.AadAuthFailureMode = nil
	}

	// No error
	return nil
}

// Indicates that either the API key or an access token from Azure Active Directory can be used for authentication.
type DataPlaneAadOrApiKeyAuthOption_STATUS struct {
	// AadAuthFailureMode: Describes what response the data plane API of a Search service would send for requests that failed
	// authentication.
	AadAuthFailureMode *DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode_STATUS `json:"aadAuthFailureMode,omitempty"`
}

var _ genruntime.FromARMConverter = &DataPlaneAadOrApiKeyAuthOption_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (option *DataPlaneAadOrApiKeyAuthOption_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DataPlaneAadOrApiKeyAuthOption_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (option *DataPlaneAadOrApiKeyAuthOption_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DataPlaneAadOrApiKeyAuthOption_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DataPlaneAadOrApiKeyAuthOption_STATUS, got %T", armInput)
	}

	// Set property "AadAuthFailureMode":
	if typedInput.AadAuthFailureMode != nil {
		var temp string
		temp = string(*typedInput.AadAuthFailureMode)
		aadAuthFailureMode := DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode_STATUS(temp)
		option.AadAuthFailureMode = &aadAuthFailureMode
	}

	// No error
	return nil
}

// AssignProperties_From_DataPlaneAadOrApiKeyAuthOption_STATUS populates our DataPlaneAadOrApiKeyAuthOption_STATUS from the provided source DataPlaneAadOrApiKeyAuthOption_STATUS
func (option *DataPlaneAadOrApiKeyAuthOption_STATUS) AssignProperties_From_DataPlaneAadOrApiKeyAuthOption_STATUS(source *storage.DataPlaneAadOrApiKeyAuthOption_STATUS) error {

	// AadAuthFailureMode
	if source.AadAuthFailureMode != nil {
		aadAuthFailureMode := *source.AadAuthFailureMode
		aadAuthFailureModeTemp := genruntime.ToEnum(aadAuthFailureMode, dataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode_STATUS_Values)
		option.AadAuthFailureMode = &aadAuthFailureModeTemp
	} else {
		option.AadAuthFailureMode = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DataPlaneAadOrApiKeyAuthOption_STATUS populates the provided destination DataPlaneAadOrApiKeyAuthOption_STATUS from our DataPlaneAadOrApiKeyAuthOption_STATUS
func (option *DataPlaneAadOrApiKeyAuthOption_STATUS) AssignProperties_To_DataPlaneAadOrApiKeyAuthOption_STATUS(destination *storage.DataPlaneAadOrApiKeyAuthOption_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AadAuthFailureMode
	if option.AadAuthFailureMode != nil {
		aadAuthFailureMode := string(*option.AadAuthFailureMode)
		destination.AadAuthFailureMode = &aadAuthFailureMode
	} else {
		destination.AadAuthFailureMode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type EncryptionWithCmk_EncryptionComplianceStatus_STATUS string

const (
	EncryptionWithCmk_EncryptionComplianceStatus_STATUS_Compliant    = EncryptionWithCmk_EncryptionComplianceStatus_STATUS("Compliant")
	EncryptionWithCmk_EncryptionComplianceStatus_STATUS_NonCompliant = EncryptionWithCmk_EncryptionComplianceStatus_STATUS("NonCompliant")
)

// Mapping from string to EncryptionWithCmk_EncryptionComplianceStatus_STATUS
var encryptionWithCmk_EncryptionComplianceStatus_STATUS_Values = map[string]EncryptionWithCmk_EncryptionComplianceStatus_STATUS{
	"compliant":    EncryptionWithCmk_EncryptionComplianceStatus_STATUS_Compliant,
	"noncompliant": EncryptionWithCmk_EncryptionComplianceStatus_STATUS_NonCompliant,
}

// +kubebuilder:validation:Enum={"Disabled","Enabled","Unspecified"}
type EncryptionWithCmk_Enforcement string

const (
	EncryptionWithCmk_Enforcement_Disabled    = EncryptionWithCmk_Enforcement("Disabled")
	EncryptionWithCmk_Enforcement_Enabled     = EncryptionWithCmk_Enforcement("Enabled")
	EncryptionWithCmk_Enforcement_Unspecified = EncryptionWithCmk_Enforcement("Unspecified")
)

// Mapping from string to EncryptionWithCmk_Enforcement
var encryptionWithCmk_Enforcement_Values = map[string]EncryptionWithCmk_Enforcement{
	"disabled":    EncryptionWithCmk_Enforcement_Disabled,
	"enabled":     EncryptionWithCmk_Enforcement_Enabled,
	"unspecified": EncryptionWithCmk_Enforcement_Unspecified,
}

type EncryptionWithCmk_Enforcement_STATUS string

const (
	EncryptionWithCmk_Enforcement_STATUS_Disabled    = EncryptionWithCmk_Enforcement_STATUS("Disabled")
	EncryptionWithCmk_Enforcement_STATUS_Enabled     = EncryptionWithCmk_Enforcement_STATUS("Enabled")
	EncryptionWithCmk_Enforcement_STATUS_Unspecified = EncryptionWithCmk_Enforcement_STATUS("Unspecified")
)

// Mapping from string to EncryptionWithCmk_Enforcement_STATUS
var encryptionWithCmk_Enforcement_STATUS_Values = map[string]EncryptionWithCmk_Enforcement_STATUS{
	"disabled":    EncryptionWithCmk_Enforcement_STATUS_Disabled,
	"enabled":     EncryptionWithCmk_Enforcement_STATUS_Enabled,
	"unspecified": EncryptionWithCmk_Enforcement_STATUS_Unspecified,
}

// +kubebuilder:validation:Enum={"None","SystemAssigned"}
type Identity_Type string

const (
	Identity_Type_None           = Identity_Type("None")
	Identity_Type_SystemAssigned = Identity_Type("SystemAssigned")
)

// Mapping from string to Identity_Type
var identity_Type_Values = map[string]Identity_Type{
	"none":           Identity_Type_None,
	"systemassigned": Identity_Type_SystemAssigned,
}

type Identity_Type_STATUS string

const (
	Identity_Type_STATUS_None           = Identity_Type_STATUS("None")
	Identity_Type_STATUS_SystemAssigned = Identity_Type_STATUS("SystemAssigned")
)

// Mapping from string to Identity_Type_STATUS
var identity_Type_STATUS_Values = map[string]Identity_Type_STATUS{
	"none":           Identity_Type_STATUS_None,
	"systemassigned": Identity_Type_STATUS_SystemAssigned,
}

// The IP restriction rule of the Azure Cognitive Search service.
type IpRule struct {
	// Value: Value corresponding to a single IPv4 address (eg., 123.1.2.3) or an IP range in CIDR format (eg., 123.1.2.3/24)
	// to be allowed.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &IpRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *IpRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.IpRule{}

	// Set property "Value":
	if rule.Value != nil {
		value := *rule.Value
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *IpRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IpRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *IpRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IpRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IpRule, got %T", armInput)
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		rule.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_IpRule populates our IpRule from the provided source IpRule
func (rule *IpRule) AssignProperties_From_IpRule(source *storage.IpRule) error {

	// Value
	rule.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_IpRule populates the provided destination IpRule from our IpRule
func (rule *IpRule) AssignProperties_To_IpRule(destination *storage.IpRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Value
	destination.Value = genruntime.ClonePointerToString(rule.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_IpRule_STATUS populates our IpRule from the provided source IpRule_STATUS
func (rule *IpRule) Initialize_From_IpRule_STATUS(source *IpRule_STATUS) error {

	// Value
	rule.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// The IP restriction rule of the Azure Cognitive Search service.
type IpRule_STATUS struct {
	// Value: Value corresponding to a single IPv4 address (eg., 123.1.2.3) or an IP range in CIDR format (eg., 123.1.2.3/24)
	// to be allowed.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &IpRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *IpRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IpRule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *IpRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IpRule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IpRule_STATUS, got %T", armInput)
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		rule.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_IpRule_STATUS populates our IpRule_STATUS from the provided source IpRule_STATUS
func (rule *IpRule_STATUS) AssignProperties_From_IpRule_STATUS(source *storage.IpRule_STATUS) error {

	// Value
	rule.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_IpRule_STATUS populates the provided destination IpRule_STATUS from our IpRule_STATUS
func (rule *IpRule_STATUS) AssignProperties_To_IpRule_STATUS(destination *storage.IpRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Value
	destination.Value = genruntime.ClonePointerToString(rule.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type SearchServiceOperatorSecrets struct {
	// AdminPrimaryKey: indicates where the AdminPrimaryKey secret should be placed. If omitted, the secret will not be
	// retrieved from Azure.
	AdminPrimaryKey *genruntime.SecretDestination `json:"adminPrimaryKey,omitempty"`

	// AdminSecondaryKey: indicates where the AdminSecondaryKey secret should be placed. If omitted, the secret will not be
	// retrieved from Azure.
	AdminSecondaryKey *genruntime.SecretDestination `json:"adminSecondaryKey,omitempty"`

	// QueryKey: indicates where the QueryKey secret should be placed. If omitted, the secret will not be retrieved from Azure.
	QueryKey *genruntime.SecretDestination `json:"queryKey,omitempty"`
}

// AssignProperties_From_SearchServiceOperatorSecrets populates our SearchServiceOperatorSecrets from the provided source SearchServiceOperatorSecrets
func (secrets *SearchServiceOperatorSecrets) AssignProperties_From_SearchServiceOperatorSecrets(source *storage.SearchServiceOperatorSecrets) error {

	// AdminPrimaryKey
	if source.AdminPrimaryKey != nil {
		adminPrimaryKey := source.AdminPrimaryKey.Copy()
		secrets.AdminPrimaryKey = &adminPrimaryKey
	} else {
		secrets.AdminPrimaryKey = nil
	}

	// AdminSecondaryKey
	if source.AdminSecondaryKey != nil {
		adminSecondaryKey := source.AdminSecondaryKey.Copy()
		secrets.AdminSecondaryKey = &adminSecondaryKey
	} else {
		secrets.AdminSecondaryKey = nil
	}

	// QueryKey
	if source.QueryKey != nil {
		queryKey := source.QueryKey.Copy()
		secrets.QueryKey = &queryKey
	} else {
		secrets.QueryKey = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SearchServiceOperatorSecrets populates the provided destination SearchServiceOperatorSecrets from our SearchServiceOperatorSecrets
func (secrets *SearchServiceOperatorSecrets) AssignProperties_To_SearchServiceOperatorSecrets(destination *storage.SearchServiceOperatorSecrets) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminPrimaryKey
	if secrets.AdminPrimaryKey != nil {
		adminPrimaryKey := secrets.AdminPrimaryKey.Copy()
		destination.AdminPrimaryKey = &adminPrimaryKey
	} else {
		destination.AdminPrimaryKey = nil
	}

	// AdminSecondaryKey
	if secrets.AdminSecondaryKey != nil {
		adminSecondaryKey := secrets.AdminSecondaryKey.Copy()
		destination.AdminSecondaryKey = &adminSecondaryKey
	} else {
		destination.AdminSecondaryKey = nil
	}

	// QueryKey
	if secrets.QueryKey != nil {
		queryKey := secrets.QueryKey.Copy()
		destination.QueryKey = &queryKey
	} else {
		destination.QueryKey = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"basic","free","standard","standard2","standard3","storage_optimized_l1","storage_optimized_l2"}
type Sku_Name string

const (
	Sku_Name_Basic                = Sku_Name("basic")
	Sku_Name_Free                 = Sku_Name("free")
	Sku_Name_Standard             = Sku_Name("standard")
	Sku_Name_Standard2            = Sku_Name("standard2")
	Sku_Name_Standard3            = Sku_Name("standard3")
	Sku_Name_Storage_Optimized_L1 = Sku_Name("storage_optimized_l1")
	Sku_Name_Storage_Optimized_L2 = Sku_Name("storage_optimized_l2")
)

// Mapping from string to Sku_Name
var sku_Name_Values = map[string]Sku_Name{
	"basic":                Sku_Name_Basic,
	"free":                 Sku_Name_Free,
	"standard":             Sku_Name_Standard,
	"standard2":            Sku_Name_Standard2,
	"standard3":            Sku_Name_Standard3,
	"storage_optimized_l1": Sku_Name_Storage_Optimized_L1,
	"storage_optimized_l2": Sku_Name_Storage_Optimized_L2,
}

type Sku_Name_STATUS string

const (
	Sku_Name_STATUS_Basic                = Sku_Name_STATUS("basic")
	Sku_Name_STATUS_Free                 = Sku_Name_STATUS("free")
	Sku_Name_STATUS_Standard             = Sku_Name_STATUS("standard")
	Sku_Name_STATUS_Standard2            = Sku_Name_STATUS("standard2")
	Sku_Name_STATUS_Standard3            = Sku_Name_STATUS("standard3")
	Sku_Name_STATUS_Storage_Optimized_L1 = Sku_Name_STATUS("storage_optimized_l1")
	Sku_Name_STATUS_Storage_Optimized_L2 = Sku_Name_STATUS("storage_optimized_l2")
)

// Mapping from string to Sku_Name_STATUS
var sku_Name_STATUS_Values = map[string]Sku_Name_STATUS{
	"basic":                Sku_Name_STATUS_Basic,
	"free":                 Sku_Name_STATUS_Free,
	"standard":             Sku_Name_STATUS_Standard,
	"standard2":            Sku_Name_STATUS_Standard2,
	"standard3":            Sku_Name_STATUS_Standard3,
	"storage_optimized_l1": Sku_Name_STATUS_Storage_Optimized_L1,
	"storage_optimized_l2": Sku_Name_STATUS_Storage_Optimized_L2,
}

// +kubebuilder:validation:Enum={"http401WithBearerChallenge","http403"}
type DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode string

const (
	DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode_Http401WithBearerChallenge = DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode("http401WithBearerChallenge")
	DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode_Http403                    = DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode("http403")
)

// Mapping from string to DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode
var dataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode_Values = map[string]DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode{
	"http401withbearerchallenge": DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode_Http401WithBearerChallenge,
	"http403":                    DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode_Http403,
}

type DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode_STATUS string

const (
	DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode_STATUS_Http401WithBearerChallenge = DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode_STATUS("http401WithBearerChallenge")
	DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode_STATUS_Http403                    = DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode_STATUS("http403")
)

// Mapping from string to DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode_STATUS
var dataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode_STATUS_Values = map[string]DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode_STATUS{
	"http401withbearerchallenge": DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode_STATUS_Http401WithBearerChallenge,
	"http403":                    DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode_STATUS_Http403,
}

func init() {
	SchemeBuilder.Register(&SearchService{}, &SearchServiceList{})
}
