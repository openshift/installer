// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20220801

import (
	"fmt"
	v20220801s "github.com/Azure/azure-service-operator/v2/api/apimanagement/v1api20220801/storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /apimanagement/resource-manager/Microsoft.ApiManagement/stable/2022-08-01/apimbackends.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/backends/{backendId}
type Backend struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              Service_Backend_Spec   `json:"spec,omitempty"`
	Status            Service_Backend_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &Backend{}

// GetConditions returns the conditions of the resource
func (backend *Backend) GetConditions() conditions.Conditions {
	return backend.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (backend *Backend) SetConditions(conditions conditions.Conditions) {
	backend.Status.Conditions = conditions
}

var _ conversion.Convertible = &Backend{}

// ConvertFrom populates our Backend from the provided hub Backend
func (backend *Backend) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v20220801s.Backend)
	if !ok {
		return fmt.Errorf("expected apimanagement/v1api20220801/storage/Backend but received %T instead", hub)
	}

	return backend.AssignProperties_From_Backend(source)
}

// ConvertTo populates the provided hub Backend from our Backend
func (backend *Backend) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v20220801s.Backend)
	if !ok {
		return fmt.Errorf("expected apimanagement/v1api20220801/storage/Backend but received %T instead", hub)
	}

	return backend.AssignProperties_To_Backend(destination)
}

// +kubebuilder:webhook:path=/mutate-apimanagement-azure-com-v1api20220801-backend,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=apimanagement.azure.com,resources=backends,verbs=create;update,versions=v1api20220801,name=default.v1api20220801.backends.apimanagement.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &Backend{}

// Default applies defaults to the Backend resource
func (backend *Backend) Default() {
	backend.defaultImpl()
	var temp any = backend
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (backend *Backend) defaultAzureName() {
	if backend.Spec.AzureName == "" {
		backend.Spec.AzureName = backend.Name
	}
}

// defaultImpl applies the code generated defaults to the Backend resource
func (backend *Backend) defaultImpl() { backend.defaultAzureName() }

var _ genruntime.ImportableResource = &Backend{}

// InitializeSpec initializes the spec for this resource from the given status
func (backend *Backend) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*Service_Backend_STATUS); ok {
		return backend.Spec.Initialize_From_Service_Backend_STATUS(s)
	}

	return fmt.Errorf("expected Status of type Service_Backend_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &Backend{}

// AzureName returns the Azure name of the resource
func (backend *Backend) AzureName() string {
	return backend.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2022-08-01"
func (backend Backend) GetAPIVersion() string {
	return string(APIVersion_Value)
}

// GetResourceScope returns the scope of the resource
func (backend *Backend) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (backend *Backend) GetSpec() genruntime.ConvertibleSpec {
	return &backend.Spec
}

// GetStatus returns the status of this resource
func (backend *Backend) GetStatus() genruntime.ConvertibleStatus {
	return &backend.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (backend *Backend) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationHead,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.ApiManagement/service/backends"
func (backend *Backend) GetType() string {
	return "Microsoft.ApiManagement/service/backends"
}

// NewEmptyStatus returns a new empty (blank) status
func (backend *Backend) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &Service_Backend_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (backend *Backend) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(backend.Spec)
	return backend.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (backend *Backend) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*Service_Backend_STATUS); ok {
		backend.Status = *st
		return nil
	}

	// Convert status to required version
	var st Service_Backend_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	backend.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-apimanagement-azure-com-v1api20220801-backend,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=apimanagement.azure.com,resources=backends,verbs=create;update,versions=v1api20220801,name=validate.v1api20220801.backends.apimanagement.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &Backend{}

// ValidateCreate validates the creation of the resource
func (backend *Backend) ValidateCreate() (admission.Warnings, error) {
	validations := backend.createValidations()
	var temp any = backend
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	return genruntime.ValidateCreate(validations)
}

// ValidateDelete validates the deletion of the resource
func (backend *Backend) ValidateDelete() (admission.Warnings, error) {
	validations := backend.deleteValidations()
	var temp any = backend
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	return genruntime.ValidateDelete(validations)
}

// ValidateUpdate validates an update of the resource
func (backend *Backend) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	validations := backend.updateValidations()
	var temp any = backend
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	return genruntime.ValidateUpdate(old, validations)
}

// createValidations validates the creation of the resource
func (backend *Backend) createValidations() []func() (admission.Warnings, error) {
	return []func() (admission.Warnings, error){backend.validateResourceReferences, backend.validateOwnerReference}
}

// deleteValidations validates the deletion of the resource
func (backend *Backend) deleteValidations() []func() (admission.Warnings, error) {
	return nil
}

// updateValidations validates the update of the resource
func (backend *Backend) updateValidations() []func(old runtime.Object) (admission.Warnings, error) {
	return []func(old runtime.Object) (admission.Warnings, error){
		func(old runtime.Object) (admission.Warnings, error) {
			return backend.validateResourceReferences()
		},
		backend.validateWriteOnceProperties,
		func(old runtime.Object) (admission.Warnings, error) {
			return backend.validateOwnerReference()
		},
	}
}

// validateOwnerReference validates the owner field
func (backend *Backend) validateOwnerReference() (admission.Warnings, error) {
	return genruntime.ValidateOwner(backend)
}

// validateResourceReferences validates all resource references
func (backend *Backend) validateResourceReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindResourceReferences(&backend.Spec)
	if err != nil {
		return nil, err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (backend *Backend) validateWriteOnceProperties(old runtime.Object) (admission.Warnings, error) {
	oldObj, ok := old.(*Backend)
	if !ok {
		return nil, nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, backend)
}

// AssignProperties_From_Backend populates our Backend from the provided source Backend
func (backend *Backend) AssignProperties_From_Backend(source *v20220801s.Backend) error {

	// ObjectMeta
	backend.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec Service_Backend_Spec
	err := spec.AssignProperties_From_Service_Backend_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_Service_Backend_Spec() to populate field Spec")
	}
	backend.Spec = spec

	// Status
	var status Service_Backend_STATUS
	err = status.AssignProperties_From_Service_Backend_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_Service_Backend_STATUS() to populate field Status")
	}
	backend.Status = status

	// No error
	return nil
}

// AssignProperties_To_Backend populates the provided destination Backend from our Backend
func (backend *Backend) AssignProperties_To_Backend(destination *v20220801s.Backend) error {

	// ObjectMeta
	destination.ObjectMeta = *backend.ObjectMeta.DeepCopy()

	// Spec
	var spec v20220801s.Service_Backend_Spec
	err := backend.Spec.AssignProperties_To_Service_Backend_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_Service_Backend_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v20220801s.Service_Backend_STATUS
	err = backend.Status.AssignProperties_To_Service_Backend_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_Service_Backend_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (backend *Backend) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: backend.Spec.OriginalVersion(),
		Kind:    "Backend",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /apimanagement/resource-manager/Microsoft.ApiManagement/stable/2022-08-01/apimbackends.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/backends/{backendId}
type BackendList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Backend `json:"items"`
}

type Service_Backend_Spec struct {
	// +kubebuilder:validation:MaxLength=80
	// +kubebuilder:validation:MinLength=1
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// Credentials: Backend Credentials Contract Properties
	Credentials *BackendCredentialsContract `json:"credentials,omitempty"`

	// +kubebuilder:validation:MaxLength=2000
	// +kubebuilder:validation:MinLength=1
	// Description: Backend Description.
	Description *string `json:"description,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a apimanagement.azure.com/Service resource
	Owner *genruntime.KnownResourceReference `group:"apimanagement.azure.com" json:"owner,omitempty" kind:"Service"`

	// Properties: Backend Properties contract
	Properties *BackendProperties `json:"properties,omitempty"`

	// +kubebuilder:validation:Required
	// Protocol: Backend communication protocol.
	Protocol *BackendContractProperties_Protocol `json:"protocol,omitempty"`

	// Proxy: Backend gateway Contract Properties
	Proxy *BackendProxyContract `json:"proxy,omitempty"`

	// ResourceReference: Management Uri of the Resource in External System. This URL can be the Arm Resource Id of Logic Apps,
	// Function Apps or API Apps.
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`

	// +kubebuilder:validation:MaxLength=300
	// +kubebuilder:validation:MinLength=1
	// Title: Backend Title.
	Title *string `json:"title,omitempty"`

	// Tls: Backend TLS Properties
	Tls *BackendTlsProperties `json:"tls,omitempty"`

	// +kubebuilder:validation:Required
	// +kubebuilder:validation:MaxLength=2000
	// +kubebuilder:validation:MinLength=1
	// Url: Runtime Url of the Backend.
	Url *string `json:"url,omitempty"`
}

var _ genruntime.ARMTransformer = &Service_Backend_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (backend *Service_Backend_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if backend == nil {
		return nil, nil
	}
	result := &Service_Backend_Spec_ARM{}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if backend.Credentials != nil ||
		backend.Description != nil ||
		backend.Properties != nil ||
		backend.Protocol != nil ||
		backend.Proxy != nil ||
		backend.ResourceReference != nil ||
		backend.Title != nil ||
		backend.Tls != nil ||
		backend.Url != nil {
		result.Properties = &BackendContractProperties_ARM{}
	}
	if backend.Credentials != nil {
		credentials_ARM, err := (*backend.Credentials).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		credentials := *credentials_ARM.(*BackendCredentialsContract_ARM)
		result.Properties.Credentials = &credentials
	}
	if backend.Description != nil {
		description := *backend.Description
		result.Properties.Description = &description
	}
	if backend.Properties != nil {
		properties_ARM, err := (*backend.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*BackendProperties_ARM)
		result.Properties.Properties = &properties
	}
	if backend.Protocol != nil {
		protocol := *backend.Protocol
		result.Properties.Protocol = &protocol
	}
	if backend.Proxy != nil {
		proxy_ARM, err := (*backend.Proxy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		proxy := *proxy_ARM.(*BackendProxyContract_ARM)
		result.Properties.Proxy = &proxy
	}
	if backend.ResourceReference != nil {
		resourceIdARMID, err := resolved.ResolvedReferences.Lookup(*backend.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceId := resourceIdARMID
		result.Properties.ResourceId = &resourceId
	}
	if backend.Title != nil {
		title := *backend.Title
		result.Properties.Title = &title
	}
	if backend.Tls != nil {
		tls_ARM, err := (*backend.Tls).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		tls := *tls_ARM.(*BackendTlsProperties_ARM)
		result.Properties.Tls = &tls
	}
	if backend.Url != nil {
		url := *backend.Url
		result.Properties.Url = &url
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (backend *Service_Backend_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Service_Backend_Spec_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (backend *Service_Backend_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Service_Backend_Spec_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Service_Backend_Spec_ARM, got %T", armInput)
	}

	// Set property "AzureName":
	backend.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "Credentials":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Credentials != nil {
			var credentials1 BackendCredentialsContract
			err := credentials1.PopulateFromARM(owner, *typedInput.Properties.Credentials)
			if err != nil {
				return err
			}
			credentials := credentials1
			backend.Credentials = &credentials
		}
	}

	// Set property "Description":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Description != nil {
			description := *typedInput.Properties.Description
			backend.Description = &description
		}
	}

	// Set property "Owner":
	backend.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "Properties":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Properties != nil {
			var properties1 BackendProperties
			err := properties1.PopulateFromARM(owner, *typedInput.Properties.Properties)
			if err != nil {
				return err
			}
			properties := properties1
			backend.Properties = &properties
		}
	}

	// Set property "Protocol":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Protocol != nil {
			protocol := *typedInput.Properties.Protocol
			backend.Protocol = &protocol
		}
	}

	// Set property "Proxy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Proxy != nil {
			var proxy1 BackendProxyContract
			err := proxy1.PopulateFromARM(owner, *typedInput.Properties.Proxy)
			if err != nil {
				return err
			}
			proxy := proxy1
			backend.Proxy = &proxy
		}
	}

	// no assignment for property "ResourceReference"

	// Set property "Title":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Title != nil {
			title := *typedInput.Properties.Title
			backend.Title = &title
		}
	}

	// Set property "Tls":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Tls != nil {
			var tls1 BackendTlsProperties
			err := tls1.PopulateFromARM(owner, *typedInput.Properties.Tls)
			if err != nil {
				return err
			}
			tls := tls1
			backend.Tls = &tls
		}
	}

	// Set property "Url":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Url != nil {
			url := *typedInput.Properties.Url
			backend.Url = &url
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &Service_Backend_Spec{}

// ConvertSpecFrom populates our Service_Backend_Spec from the provided source
func (backend *Service_Backend_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v20220801s.Service_Backend_Spec)
	if ok {
		// Populate our instance from source
		return backend.AssignProperties_From_Service_Backend_Spec(src)
	}

	// Convert to an intermediate form
	src = &v20220801s.Service_Backend_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = backend.AssignProperties_From_Service_Backend_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our Service_Backend_Spec
func (backend *Service_Backend_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v20220801s.Service_Backend_Spec)
	if ok {
		// Populate destination from our instance
		return backend.AssignProperties_To_Service_Backend_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &v20220801s.Service_Backend_Spec{}
	err := backend.AssignProperties_To_Service_Backend_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_Service_Backend_Spec populates our Service_Backend_Spec from the provided source Service_Backend_Spec
func (backend *Service_Backend_Spec) AssignProperties_From_Service_Backend_Spec(source *v20220801s.Service_Backend_Spec) error {

	// AzureName
	backend.AzureName = source.AzureName

	// Credentials
	if source.Credentials != nil {
		var credential BackendCredentialsContract
		err := credential.AssignProperties_From_BackendCredentialsContract(source.Credentials)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BackendCredentialsContract() to populate field Credentials")
		}
		backend.Credentials = &credential
	} else {
		backend.Credentials = nil
	}

	// Description
	if source.Description != nil {
		description := *source.Description
		backend.Description = &description
	} else {
		backend.Description = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		backend.Owner = &owner
	} else {
		backend.Owner = nil
	}

	// Properties
	if source.Properties != nil {
		var property BackendProperties
		err := property.AssignProperties_From_BackendProperties(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BackendProperties() to populate field Properties")
		}
		backend.Properties = &property
	} else {
		backend.Properties = nil
	}

	// Protocol
	if source.Protocol != nil {
		protocol := BackendContractProperties_Protocol(*source.Protocol)
		backend.Protocol = &protocol
	} else {
		backend.Protocol = nil
	}

	// Proxy
	if source.Proxy != nil {
		var proxy BackendProxyContract
		err := proxy.AssignProperties_From_BackendProxyContract(source.Proxy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BackendProxyContract() to populate field Proxy")
		}
		backend.Proxy = &proxy
	} else {
		backend.Proxy = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		backend.ResourceReference = &resourceReference
	} else {
		backend.ResourceReference = nil
	}

	// Title
	if source.Title != nil {
		title := *source.Title
		backend.Title = &title
	} else {
		backend.Title = nil
	}

	// Tls
	if source.Tls != nil {
		var tl BackendTlsProperties
		err := tl.AssignProperties_From_BackendTlsProperties(source.Tls)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BackendTlsProperties() to populate field Tls")
		}
		backend.Tls = &tl
	} else {
		backend.Tls = nil
	}

	// Url
	if source.Url != nil {
		url := *source.Url
		backend.Url = &url
	} else {
		backend.Url = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Service_Backend_Spec populates the provided destination Service_Backend_Spec from our Service_Backend_Spec
func (backend *Service_Backend_Spec) AssignProperties_To_Service_Backend_Spec(destination *v20220801s.Service_Backend_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = backend.AzureName

	// Credentials
	if backend.Credentials != nil {
		var credential v20220801s.BackendCredentialsContract
		err := backend.Credentials.AssignProperties_To_BackendCredentialsContract(&credential)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BackendCredentialsContract() to populate field Credentials")
		}
		destination.Credentials = &credential
	} else {
		destination.Credentials = nil
	}

	// Description
	if backend.Description != nil {
		description := *backend.Description
		destination.Description = &description
	} else {
		destination.Description = nil
	}

	// OriginalVersion
	destination.OriginalVersion = backend.OriginalVersion()

	// Owner
	if backend.Owner != nil {
		owner := backend.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Properties
	if backend.Properties != nil {
		var property v20220801s.BackendProperties
		err := backend.Properties.AssignProperties_To_BackendProperties(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BackendProperties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// Protocol
	if backend.Protocol != nil {
		protocol := string(*backend.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Proxy
	if backend.Proxy != nil {
		var proxy v20220801s.BackendProxyContract
		err := backend.Proxy.AssignProperties_To_BackendProxyContract(&proxy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BackendProxyContract() to populate field Proxy")
		}
		destination.Proxy = &proxy
	} else {
		destination.Proxy = nil
	}

	// ResourceReference
	if backend.ResourceReference != nil {
		resourceReference := backend.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Title
	if backend.Title != nil {
		title := *backend.Title
		destination.Title = &title
	} else {
		destination.Title = nil
	}

	// Tls
	if backend.Tls != nil {
		var tl v20220801s.BackendTlsProperties
		err := backend.Tls.AssignProperties_To_BackendTlsProperties(&tl)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BackendTlsProperties() to populate field Tls")
		}
		destination.Tls = &tl
	} else {
		destination.Tls = nil
	}

	// Url
	if backend.Url != nil {
		url := *backend.Url
		destination.Url = &url
	} else {
		destination.Url = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Service_Backend_STATUS populates our Service_Backend_Spec from the provided source Service_Backend_STATUS
func (backend *Service_Backend_Spec) Initialize_From_Service_Backend_STATUS(source *Service_Backend_STATUS) error {

	// Credentials
	if source.Credentials != nil {
		var credential BackendCredentialsContract
		err := credential.Initialize_From_BackendCredentialsContract_STATUS(source.Credentials)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_BackendCredentialsContract_STATUS() to populate field Credentials")
		}
		backend.Credentials = &credential
	} else {
		backend.Credentials = nil
	}

	// Description
	if source.Description != nil {
		description := *source.Description
		backend.Description = &description
	} else {
		backend.Description = nil
	}

	// Properties
	if source.Properties != nil {
		var property BackendProperties
		err := property.Initialize_From_BackendProperties_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_BackendProperties_STATUS() to populate field Properties")
		}
		backend.Properties = &property
	} else {
		backend.Properties = nil
	}

	// Protocol
	if source.Protocol != nil {
		protocol := BackendContractProperties_Protocol(*source.Protocol)
		backend.Protocol = &protocol
	} else {
		backend.Protocol = nil
	}

	// Proxy
	if source.Proxy != nil {
		var proxy BackendProxyContract
		err := proxy.Initialize_From_BackendProxyContract_STATUS(source.Proxy)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_BackendProxyContract_STATUS() to populate field Proxy")
		}
		backend.Proxy = &proxy
	} else {
		backend.Proxy = nil
	}

	// ResourceReference
	if source.ResourceId != nil {
		resourceReference := genruntime.CreateResourceReferenceFromARMID(*source.ResourceId)
		backend.ResourceReference = &resourceReference
	} else {
		backend.ResourceReference = nil
	}

	// Title
	if source.Title != nil {
		title := *source.Title
		backend.Title = &title
	} else {
		backend.Title = nil
	}

	// Tls
	if source.Tls != nil {
		var tl BackendTlsProperties
		err := tl.Initialize_From_BackendTlsProperties_STATUS(source.Tls)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_BackendTlsProperties_STATUS() to populate field Tls")
		}
		backend.Tls = &tl
	} else {
		backend.Tls = nil
	}

	// Url
	if source.Url != nil {
		url := *source.Url
		backend.Url = &url
	} else {
		backend.Url = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (backend *Service_Backend_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (backend *Service_Backend_Spec) SetAzureName(azureName string) { backend.AzureName = azureName }

type Service_Backend_STATUS struct {
	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// Credentials: Backend Credentials Contract Properties
	Credentials *BackendCredentialsContract_STATUS `json:"credentials,omitempty"`

	// Description: Backend Description.
	Description *string `json:"description,omitempty"`

	// Id: Fully qualified resource ID for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// Properties: Backend Properties contract
	Properties *BackendProperties_STATUS `json:"properties,omitempty"`

	// Protocol: Backend communication protocol.
	Protocol *BackendContractProperties_Protocol_STATUS `json:"protocol,omitempty"`

	// Proxy: Backend gateway Contract Properties
	Proxy *BackendProxyContract_STATUS `json:"proxy,omitempty"`

	// ResourceId: Management Uri of the Resource in External System. This URL can be the Arm Resource Id of Logic Apps,
	// Function Apps or API Apps.
	ResourceId *string `json:"resourceId,omitempty"`

	// Title: Backend Title.
	Title *string `json:"title,omitempty"`

	// Tls: Backend TLS Properties
	Tls *BackendTlsProperties_STATUS `json:"tls,omitempty"`

	// Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`

	// Url: Runtime Url of the Backend.
	Url *string `json:"url,omitempty"`
}

var _ genruntime.ConvertibleStatus = &Service_Backend_STATUS{}

// ConvertStatusFrom populates our Service_Backend_STATUS from the provided source
func (backend *Service_Backend_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v20220801s.Service_Backend_STATUS)
	if ok {
		// Populate our instance from source
		return backend.AssignProperties_From_Service_Backend_STATUS(src)
	}

	// Convert to an intermediate form
	src = &v20220801s.Service_Backend_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = backend.AssignProperties_From_Service_Backend_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our Service_Backend_STATUS
func (backend *Service_Backend_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v20220801s.Service_Backend_STATUS)
	if ok {
		// Populate destination from our instance
		return backend.AssignProperties_To_Service_Backend_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &v20220801s.Service_Backend_STATUS{}
	err := backend.AssignProperties_To_Service_Backend_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &Service_Backend_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (backend *Service_Backend_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Service_Backend_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (backend *Service_Backend_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Service_Backend_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Service_Backend_STATUS_ARM, got %T", armInput)
	}

	// no assignment for property "Conditions"

	// Set property "Credentials":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Credentials != nil {
			var credentials1 BackendCredentialsContract_STATUS
			err := credentials1.PopulateFromARM(owner, *typedInput.Properties.Credentials)
			if err != nil {
				return err
			}
			credentials := credentials1
			backend.Credentials = &credentials
		}
	}

	// Set property "Description":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Description != nil {
			description := *typedInput.Properties.Description
			backend.Description = &description
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		backend.Id = &id
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		backend.Name = &name
	}

	// Set property "Properties":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Properties != nil {
			var properties1 BackendProperties_STATUS
			err := properties1.PopulateFromARM(owner, *typedInput.Properties.Properties)
			if err != nil {
				return err
			}
			properties := properties1
			backend.Properties = &properties
		}
	}

	// Set property "Protocol":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Protocol != nil {
			protocol := *typedInput.Properties.Protocol
			backend.Protocol = &protocol
		}
	}

	// Set property "Proxy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Proxy != nil {
			var proxy1 BackendProxyContract_STATUS
			err := proxy1.PopulateFromARM(owner, *typedInput.Properties.Proxy)
			if err != nil {
				return err
			}
			proxy := proxy1
			backend.Proxy = &proxy
		}
	}

	// Set property "ResourceId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ResourceId != nil {
			resourceId := *typedInput.Properties.ResourceId
			backend.ResourceId = &resourceId
		}
	}

	// Set property "Title":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Title != nil {
			title := *typedInput.Properties.Title
			backend.Title = &title
		}
	}

	// Set property "Tls":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Tls != nil {
			var tls1 BackendTlsProperties_STATUS
			err := tls1.PopulateFromARM(owner, *typedInput.Properties.Tls)
			if err != nil {
				return err
			}
			tls := tls1
			backend.Tls = &tls
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		backend.Type = &typeVar
	}

	// Set property "Url":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Url != nil {
			url := *typedInput.Properties.Url
			backend.Url = &url
		}
	}

	// No error
	return nil
}

// AssignProperties_From_Service_Backend_STATUS populates our Service_Backend_STATUS from the provided source Service_Backend_STATUS
func (backend *Service_Backend_STATUS) AssignProperties_From_Service_Backend_STATUS(source *v20220801s.Service_Backend_STATUS) error {

	// Conditions
	backend.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// Credentials
	if source.Credentials != nil {
		var credential BackendCredentialsContract_STATUS
		err := credential.AssignProperties_From_BackendCredentialsContract_STATUS(source.Credentials)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BackendCredentialsContract_STATUS() to populate field Credentials")
		}
		backend.Credentials = &credential
	} else {
		backend.Credentials = nil
	}

	// Description
	backend.Description = genruntime.ClonePointerToString(source.Description)

	// Id
	backend.Id = genruntime.ClonePointerToString(source.Id)

	// Name
	backend.Name = genruntime.ClonePointerToString(source.Name)

	// Properties
	if source.Properties != nil {
		var property BackendProperties_STATUS
		err := property.AssignProperties_From_BackendProperties_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BackendProperties_STATUS() to populate field Properties")
		}
		backend.Properties = &property
	} else {
		backend.Properties = nil
	}

	// Protocol
	if source.Protocol != nil {
		protocol := BackendContractProperties_Protocol_STATUS(*source.Protocol)
		backend.Protocol = &protocol
	} else {
		backend.Protocol = nil
	}

	// Proxy
	if source.Proxy != nil {
		var proxy BackendProxyContract_STATUS
		err := proxy.AssignProperties_From_BackendProxyContract_STATUS(source.Proxy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BackendProxyContract_STATUS() to populate field Proxy")
		}
		backend.Proxy = &proxy
	} else {
		backend.Proxy = nil
	}

	// ResourceId
	backend.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// Title
	backend.Title = genruntime.ClonePointerToString(source.Title)

	// Tls
	if source.Tls != nil {
		var tl BackendTlsProperties_STATUS
		err := tl.AssignProperties_From_BackendTlsProperties_STATUS(source.Tls)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BackendTlsProperties_STATUS() to populate field Tls")
		}
		backend.Tls = &tl
	} else {
		backend.Tls = nil
	}

	// Type
	backend.Type = genruntime.ClonePointerToString(source.Type)

	// Url
	backend.Url = genruntime.ClonePointerToString(source.Url)

	// No error
	return nil
}

// AssignProperties_To_Service_Backend_STATUS populates the provided destination Service_Backend_STATUS from our Service_Backend_STATUS
func (backend *Service_Backend_STATUS) AssignProperties_To_Service_Backend_STATUS(destination *v20220801s.Service_Backend_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(backend.Conditions)

	// Credentials
	if backend.Credentials != nil {
		var credential v20220801s.BackendCredentialsContract_STATUS
		err := backend.Credentials.AssignProperties_To_BackendCredentialsContract_STATUS(&credential)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BackendCredentialsContract_STATUS() to populate field Credentials")
		}
		destination.Credentials = &credential
	} else {
		destination.Credentials = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(backend.Description)

	// Id
	destination.Id = genruntime.ClonePointerToString(backend.Id)

	// Name
	destination.Name = genruntime.ClonePointerToString(backend.Name)

	// Properties
	if backend.Properties != nil {
		var property v20220801s.BackendProperties_STATUS
		err := backend.Properties.AssignProperties_To_BackendProperties_STATUS(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BackendProperties_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// Protocol
	if backend.Protocol != nil {
		protocol := string(*backend.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Proxy
	if backend.Proxy != nil {
		var proxy v20220801s.BackendProxyContract_STATUS
		err := backend.Proxy.AssignProperties_To_BackendProxyContract_STATUS(&proxy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BackendProxyContract_STATUS() to populate field Proxy")
		}
		destination.Proxy = &proxy
	} else {
		destination.Proxy = nil
	}

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(backend.ResourceId)

	// Title
	destination.Title = genruntime.ClonePointerToString(backend.Title)

	// Tls
	if backend.Tls != nil {
		var tl v20220801s.BackendTlsProperties_STATUS
		err := backend.Tls.AssignProperties_To_BackendTlsProperties_STATUS(&tl)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BackendTlsProperties_STATUS() to populate field Tls")
		}
		destination.Tls = &tl
	} else {
		destination.Tls = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(backend.Type)

	// Url
	destination.Url = genruntime.ClonePointerToString(backend.Url)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"http","soap"}
type BackendContractProperties_Protocol string

const (
	BackendContractProperties_Protocol_Http = BackendContractProperties_Protocol("http")
	BackendContractProperties_Protocol_Soap = BackendContractProperties_Protocol("soap")
)

type BackendContractProperties_Protocol_STATUS string

const (
	BackendContractProperties_Protocol_STATUS_Http = BackendContractProperties_Protocol_STATUS("http")
	BackendContractProperties_Protocol_STATUS_Soap = BackendContractProperties_Protocol_STATUS("soap")
)

// Details of the Credentials used to connect to Backend.
type BackendCredentialsContract struct {
	// Authorization: Authorization header authentication
	Authorization *BackendAuthorizationHeaderCredentials `json:"authorization,omitempty"`

	// +kubebuilder:validation:MaxItems=32
	// Certificate: List of Client Certificate Thumbprints. Will be ignored if certificatesIds are provided.
	Certificate []string `json:"certificate,omitempty"`

	// +kubebuilder:validation:MaxItems=32
	// CertificateIds: List of Client Certificate Ids.
	CertificateIds []string `json:"certificateIds,omitempty"`

	// Header: Header Parameter description.
	Header map[string][]string `json:"header,omitempty"`

	// Query: Query Parameter description.
	Query map[string][]string `json:"query,omitempty"`
}

var _ genruntime.ARMTransformer = &BackendCredentialsContract{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (contract *BackendCredentialsContract) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if contract == nil {
		return nil, nil
	}
	result := &BackendCredentialsContract_ARM{}

	// Set property "Authorization":
	if contract.Authorization != nil {
		authorization_ARM, err := (*contract.Authorization).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		authorization := *authorization_ARM.(*BackendAuthorizationHeaderCredentials_ARM)
		result.Authorization = &authorization
	}

	// Set property "Certificate":
	for _, item := range contract.Certificate {
		result.Certificate = append(result.Certificate, item)
	}

	// Set property "CertificateIds":
	for _, item := range contract.CertificateIds {
		result.CertificateIds = append(result.CertificateIds, item)
	}

	// Set property "Header":
	if contract.Header != nil {
		result.Header = make(map[string][]string, len(contract.Header))
		for key, value := range contract.Header {
			var valueTemp []string
			for _, item := range value {
				valueTemp = append(valueTemp, item)
			}
			result.Header[key] = valueTemp
		}
	}

	// Set property "Query":
	if contract.Query != nil {
		result.Query = make(map[string][]string, len(contract.Query))
		for key, value := range contract.Query {
			var valueTemp []string
			for _, item := range value {
				valueTemp = append(valueTemp, item)
			}
			result.Query[key] = valueTemp
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (contract *BackendCredentialsContract) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackendCredentialsContract_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (contract *BackendCredentialsContract) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackendCredentialsContract_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackendCredentialsContract_ARM, got %T", armInput)
	}

	// Set property "Authorization":
	if typedInput.Authorization != nil {
		var authorization1 BackendAuthorizationHeaderCredentials
		err := authorization1.PopulateFromARM(owner, *typedInput.Authorization)
		if err != nil {
			return err
		}
		authorization := authorization1
		contract.Authorization = &authorization
	}

	// Set property "Certificate":
	for _, item := range typedInput.Certificate {
		contract.Certificate = append(contract.Certificate, item)
	}

	// Set property "CertificateIds":
	for _, item := range typedInput.CertificateIds {
		contract.CertificateIds = append(contract.CertificateIds, item)
	}

	// Set property "Header":
	if typedInput.Header != nil {
		contract.Header = make(map[string][]string, len(typedInput.Header))
		for key, value := range typedInput.Header {
			var valueTemp []string
			for _, item := range value {
				valueTemp = append(valueTemp, item)
			}
			contract.Header[key] = valueTemp
		}
	}

	// Set property "Query":
	if typedInput.Query != nil {
		contract.Query = make(map[string][]string, len(typedInput.Query))
		for key, value := range typedInput.Query {
			var valueTemp []string
			for _, item := range value {
				valueTemp = append(valueTemp, item)
			}
			contract.Query[key] = valueTemp
		}
	}

	// No error
	return nil
}

// AssignProperties_From_BackendCredentialsContract populates our BackendCredentialsContract from the provided source BackendCredentialsContract
func (contract *BackendCredentialsContract) AssignProperties_From_BackendCredentialsContract(source *v20220801s.BackendCredentialsContract) error {

	// Authorization
	if source.Authorization != nil {
		var authorization BackendAuthorizationHeaderCredentials
		err := authorization.AssignProperties_From_BackendAuthorizationHeaderCredentials(source.Authorization)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BackendAuthorizationHeaderCredentials() to populate field Authorization")
		}
		contract.Authorization = &authorization
	} else {
		contract.Authorization = nil
	}

	// Certificate
	if source.Certificate != nil {
		certificateList := make([]string, len(source.Certificate))
		for certificateIndex, certificateItem := range source.Certificate {
			// Shadow the loop variable to avoid aliasing
			certificateItem := certificateItem
			certificateList[certificateIndex] = certificateItem
		}
		contract.Certificate = certificateList
	} else {
		contract.Certificate = nil
	}

	// CertificateIds
	if source.CertificateIds != nil {
		certificateIdList := make([]string, len(source.CertificateIds))
		for certificateIdIndex, certificateIdItem := range source.CertificateIds {
			// Shadow the loop variable to avoid aliasing
			certificateIdItem := certificateIdItem
			certificateIdList[certificateIdIndex] = certificateIdItem
		}
		contract.CertificateIds = certificateIdList
	} else {
		contract.CertificateIds = nil
	}

	// Header
	if source.Header != nil {
		headerMap := make(map[string][]string, len(source.Header))
		for headerKey, headerValue := range source.Header {
			// Shadow the loop variable to avoid aliasing
			headerValue := headerValue
			headerMap[headerKey] = genruntime.CloneSliceOfString(headerValue)
		}
		contract.Header = headerMap
	} else {
		contract.Header = nil
	}

	// Query
	if source.Query != nil {
		queryMap := make(map[string][]string, len(source.Query))
		for queryKey, queryValue := range source.Query {
			// Shadow the loop variable to avoid aliasing
			queryValue := queryValue
			queryMap[queryKey] = genruntime.CloneSliceOfString(queryValue)
		}
		contract.Query = queryMap
	} else {
		contract.Query = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackendCredentialsContract populates the provided destination BackendCredentialsContract from our BackendCredentialsContract
func (contract *BackendCredentialsContract) AssignProperties_To_BackendCredentialsContract(destination *v20220801s.BackendCredentialsContract) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Authorization
	if contract.Authorization != nil {
		var authorization v20220801s.BackendAuthorizationHeaderCredentials
		err := contract.Authorization.AssignProperties_To_BackendAuthorizationHeaderCredentials(&authorization)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BackendAuthorizationHeaderCredentials() to populate field Authorization")
		}
		destination.Authorization = &authorization
	} else {
		destination.Authorization = nil
	}

	// Certificate
	if contract.Certificate != nil {
		certificateList := make([]string, len(contract.Certificate))
		for certificateIndex, certificateItem := range contract.Certificate {
			// Shadow the loop variable to avoid aliasing
			certificateItem := certificateItem
			certificateList[certificateIndex] = certificateItem
		}
		destination.Certificate = certificateList
	} else {
		destination.Certificate = nil
	}

	// CertificateIds
	if contract.CertificateIds != nil {
		certificateIdList := make([]string, len(contract.CertificateIds))
		for certificateIdIndex, certificateIdItem := range contract.CertificateIds {
			// Shadow the loop variable to avoid aliasing
			certificateIdItem := certificateIdItem
			certificateIdList[certificateIdIndex] = certificateIdItem
		}
		destination.CertificateIds = certificateIdList
	} else {
		destination.CertificateIds = nil
	}

	// Header
	if contract.Header != nil {
		headerMap := make(map[string][]string, len(contract.Header))
		for headerKey, headerValue := range contract.Header {
			// Shadow the loop variable to avoid aliasing
			headerValue := headerValue
			headerMap[headerKey] = genruntime.CloneSliceOfString(headerValue)
		}
		destination.Header = headerMap
	} else {
		destination.Header = nil
	}

	// Query
	if contract.Query != nil {
		queryMap := make(map[string][]string, len(contract.Query))
		for queryKey, queryValue := range contract.Query {
			// Shadow the loop variable to avoid aliasing
			queryValue := queryValue
			queryMap[queryKey] = genruntime.CloneSliceOfString(queryValue)
		}
		destination.Query = queryMap
	} else {
		destination.Query = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_BackendCredentialsContract_STATUS populates our BackendCredentialsContract from the provided source BackendCredentialsContract_STATUS
func (contract *BackendCredentialsContract) Initialize_From_BackendCredentialsContract_STATUS(source *BackendCredentialsContract_STATUS) error {

	// Authorization
	if source.Authorization != nil {
		var authorization BackendAuthorizationHeaderCredentials
		err := authorization.Initialize_From_BackendAuthorizationHeaderCredentials_STATUS(source.Authorization)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_BackendAuthorizationHeaderCredentials_STATUS() to populate field Authorization")
		}
		contract.Authorization = &authorization
	} else {
		contract.Authorization = nil
	}

	// Certificate
	if source.Certificate != nil {
		certificateList := make([]string, len(source.Certificate))
		for certificateIndex, certificateItem := range source.Certificate {
			// Shadow the loop variable to avoid aliasing
			certificateItem := certificateItem
			certificateList[certificateIndex] = certificateItem
		}
		contract.Certificate = certificateList
	} else {
		contract.Certificate = nil
	}

	// CertificateIds
	if source.CertificateIds != nil {
		certificateIdList := make([]string, len(source.CertificateIds))
		for certificateIdIndex, certificateIdItem := range source.CertificateIds {
			// Shadow the loop variable to avoid aliasing
			certificateIdItem := certificateIdItem
			certificateIdList[certificateIdIndex] = certificateIdItem
		}
		contract.CertificateIds = certificateIdList
	} else {
		contract.CertificateIds = nil
	}

	// Header
	if source.Header != nil {
		headerMap := make(map[string][]string, len(source.Header))
		for headerKey, headerValue := range source.Header {
			// Shadow the loop variable to avoid aliasing
			headerValue := headerValue
			headerMap[headerKey] = genruntime.CloneSliceOfString(headerValue)
		}
		contract.Header = headerMap
	} else {
		contract.Header = nil
	}

	// Query
	if source.Query != nil {
		queryMap := make(map[string][]string, len(source.Query))
		for queryKey, queryValue := range source.Query {
			// Shadow the loop variable to avoid aliasing
			queryValue := queryValue
			queryMap[queryKey] = genruntime.CloneSliceOfString(queryValue)
		}
		contract.Query = queryMap
	} else {
		contract.Query = nil
	}

	// No error
	return nil
}

// Details of the Credentials used to connect to Backend.
type BackendCredentialsContract_STATUS struct {
	// Authorization: Authorization header authentication
	Authorization *BackendAuthorizationHeaderCredentials_STATUS `json:"authorization,omitempty"`

	// Certificate: List of Client Certificate Thumbprints. Will be ignored if certificatesIds are provided.
	Certificate []string `json:"certificate,omitempty"`

	// CertificateIds: List of Client Certificate Ids.
	CertificateIds []string `json:"certificateIds,omitempty"`

	// Header: Header Parameter description.
	Header map[string][]string `json:"header,omitempty"`

	// Query: Query Parameter description.
	Query map[string][]string `json:"query,omitempty"`
}

var _ genruntime.FromARMConverter = &BackendCredentialsContract_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (contract *BackendCredentialsContract_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackendCredentialsContract_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (contract *BackendCredentialsContract_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackendCredentialsContract_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackendCredentialsContract_STATUS_ARM, got %T", armInput)
	}

	// Set property "Authorization":
	if typedInput.Authorization != nil {
		var authorization1 BackendAuthorizationHeaderCredentials_STATUS
		err := authorization1.PopulateFromARM(owner, *typedInput.Authorization)
		if err != nil {
			return err
		}
		authorization := authorization1
		contract.Authorization = &authorization
	}

	// Set property "Certificate":
	for _, item := range typedInput.Certificate {
		contract.Certificate = append(contract.Certificate, item)
	}

	// Set property "CertificateIds":
	for _, item := range typedInput.CertificateIds {
		contract.CertificateIds = append(contract.CertificateIds, item)
	}

	// Set property "Header":
	if typedInput.Header != nil {
		contract.Header = make(map[string][]string, len(typedInput.Header))
		for key, value := range typedInput.Header {
			var valueTemp []string
			for _, item := range value {
				valueTemp = append(valueTemp, item)
			}
			contract.Header[key] = valueTemp
		}
	}

	// Set property "Query":
	if typedInput.Query != nil {
		contract.Query = make(map[string][]string, len(typedInput.Query))
		for key, value := range typedInput.Query {
			var valueTemp []string
			for _, item := range value {
				valueTemp = append(valueTemp, item)
			}
			contract.Query[key] = valueTemp
		}
	}

	// No error
	return nil
}

// AssignProperties_From_BackendCredentialsContract_STATUS populates our BackendCredentialsContract_STATUS from the provided source BackendCredentialsContract_STATUS
func (contract *BackendCredentialsContract_STATUS) AssignProperties_From_BackendCredentialsContract_STATUS(source *v20220801s.BackendCredentialsContract_STATUS) error {

	// Authorization
	if source.Authorization != nil {
		var authorization BackendAuthorizationHeaderCredentials_STATUS
		err := authorization.AssignProperties_From_BackendAuthorizationHeaderCredentials_STATUS(source.Authorization)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BackendAuthorizationHeaderCredentials_STATUS() to populate field Authorization")
		}
		contract.Authorization = &authorization
	} else {
		contract.Authorization = nil
	}

	// Certificate
	contract.Certificate = genruntime.CloneSliceOfString(source.Certificate)

	// CertificateIds
	contract.CertificateIds = genruntime.CloneSliceOfString(source.CertificateIds)

	// Header
	if source.Header != nil {
		headerMap := make(map[string][]string, len(source.Header))
		for headerKey, headerValue := range source.Header {
			// Shadow the loop variable to avoid aliasing
			headerValue := headerValue
			headerMap[headerKey] = genruntime.CloneSliceOfString(headerValue)
		}
		contract.Header = headerMap
	} else {
		contract.Header = nil
	}

	// Query
	if source.Query != nil {
		queryMap := make(map[string][]string, len(source.Query))
		for queryKey, queryValue := range source.Query {
			// Shadow the loop variable to avoid aliasing
			queryValue := queryValue
			queryMap[queryKey] = genruntime.CloneSliceOfString(queryValue)
		}
		contract.Query = queryMap
	} else {
		contract.Query = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackendCredentialsContract_STATUS populates the provided destination BackendCredentialsContract_STATUS from our BackendCredentialsContract_STATUS
func (contract *BackendCredentialsContract_STATUS) AssignProperties_To_BackendCredentialsContract_STATUS(destination *v20220801s.BackendCredentialsContract_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Authorization
	if contract.Authorization != nil {
		var authorization v20220801s.BackendAuthorizationHeaderCredentials_STATUS
		err := contract.Authorization.AssignProperties_To_BackendAuthorizationHeaderCredentials_STATUS(&authorization)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BackendAuthorizationHeaderCredentials_STATUS() to populate field Authorization")
		}
		destination.Authorization = &authorization
	} else {
		destination.Authorization = nil
	}

	// Certificate
	destination.Certificate = genruntime.CloneSliceOfString(contract.Certificate)

	// CertificateIds
	destination.CertificateIds = genruntime.CloneSliceOfString(contract.CertificateIds)

	// Header
	if contract.Header != nil {
		headerMap := make(map[string][]string, len(contract.Header))
		for headerKey, headerValue := range contract.Header {
			// Shadow the loop variable to avoid aliasing
			headerValue := headerValue
			headerMap[headerKey] = genruntime.CloneSliceOfString(headerValue)
		}
		destination.Header = headerMap
	} else {
		destination.Header = nil
	}

	// Query
	if contract.Query != nil {
		queryMap := make(map[string][]string, len(contract.Query))
		for queryKey, queryValue := range contract.Query {
			// Shadow the loop variable to avoid aliasing
			queryValue := queryValue
			queryMap[queryKey] = genruntime.CloneSliceOfString(queryValue)
		}
		destination.Query = queryMap
	} else {
		destination.Query = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Properties specific to the Backend Type.
type BackendProperties struct {
	// ServiceFabricCluster: Backend Service Fabric Cluster Properties
	ServiceFabricCluster *BackendServiceFabricClusterProperties `json:"serviceFabricCluster,omitempty"`
}

var _ genruntime.ARMTransformer = &BackendProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *BackendProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &BackendProperties_ARM{}

	// Set property "ServiceFabricCluster":
	if properties.ServiceFabricCluster != nil {
		serviceFabricCluster_ARM, err := (*properties.ServiceFabricCluster).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		serviceFabricCluster := *serviceFabricCluster_ARM.(*BackendServiceFabricClusterProperties_ARM)
		result.ServiceFabricCluster = &serviceFabricCluster
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *BackendProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackendProperties_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *BackendProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackendProperties_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackendProperties_ARM, got %T", armInput)
	}

	// Set property "ServiceFabricCluster":
	if typedInput.ServiceFabricCluster != nil {
		var serviceFabricCluster1 BackendServiceFabricClusterProperties
		err := serviceFabricCluster1.PopulateFromARM(owner, *typedInput.ServiceFabricCluster)
		if err != nil {
			return err
		}
		serviceFabricCluster := serviceFabricCluster1
		properties.ServiceFabricCluster = &serviceFabricCluster
	}

	// No error
	return nil
}

// AssignProperties_From_BackendProperties populates our BackendProperties from the provided source BackendProperties
func (properties *BackendProperties) AssignProperties_From_BackendProperties(source *v20220801s.BackendProperties) error {

	// ServiceFabricCluster
	if source.ServiceFabricCluster != nil {
		var serviceFabricCluster BackendServiceFabricClusterProperties
		err := serviceFabricCluster.AssignProperties_From_BackendServiceFabricClusterProperties(source.ServiceFabricCluster)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BackendServiceFabricClusterProperties() to populate field ServiceFabricCluster")
		}
		properties.ServiceFabricCluster = &serviceFabricCluster
	} else {
		properties.ServiceFabricCluster = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackendProperties populates the provided destination BackendProperties from our BackendProperties
func (properties *BackendProperties) AssignProperties_To_BackendProperties(destination *v20220801s.BackendProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ServiceFabricCluster
	if properties.ServiceFabricCluster != nil {
		var serviceFabricCluster v20220801s.BackendServiceFabricClusterProperties
		err := properties.ServiceFabricCluster.AssignProperties_To_BackendServiceFabricClusterProperties(&serviceFabricCluster)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BackendServiceFabricClusterProperties() to populate field ServiceFabricCluster")
		}
		destination.ServiceFabricCluster = &serviceFabricCluster
	} else {
		destination.ServiceFabricCluster = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_BackendProperties_STATUS populates our BackendProperties from the provided source BackendProperties_STATUS
func (properties *BackendProperties) Initialize_From_BackendProperties_STATUS(source *BackendProperties_STATUS) error {

	// ServiceFabricCluster
	if source.ServiceFabricCluster != nil {
		var serviceFabricCluster BackendServiceFabricClusterProperties
		err := serviceFabricCluster.Initialize_From_BackendServiceFabricClusterProperties_STATUS(source.ServiceFabricCluster)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_BackendServiceFabricClusterProperties_STATUS() to populate field ServiceFabricCluster")
		}
		properties.ServiceFabricCluster = &serviceFabricCluster
	} else {
		properties.ServiceFabricCluster = nil
	}

	// No error
	return nil
}

// Properties specific to the Backend Type.
type BackendProperties_STATUS struct {
	// ServiceFabricCluster: Backend Service Fabric Cluster Properties
	ServiceFabricCluster *BackendServiceFabricClusterProperties_STATUS `json:"serviceFabricCluster,omitempty"`
}

var _ genruntime.FromARMConverter = &BackendProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *BackendProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackendProperties_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *BackendProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackendProperties_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackendProperties_STATUS_ARM, got %T", armInput)
	}

	// Set property "ServiceFabricCluster":
	if typedInput.ServiceFabricCluster != nil {
		var serviceFabricCluster1 BackendServiceFabricClusterProperties_STATUS
		err := serviceFabricCluster1.PopulateFromARM(owner, *typedInput.ServiceFabricCluster)
		if err != nil {
			return err
		}
		serviceFabricCluster := serviceFabricCluster1
		properties.ServiceFabricCluster = &serviceFabricCluster
	}

	// No error
	return nil
}

// AssignProperties_From_BackendProperties_STATUS populates our BackendProperties_STATUS from the provided source BackendProperties_STATUS
func (properties *BackendProperties_STATUS) AssignProperties_From_BackendProperties_STATUS(source *v20220801s.BackendProperties_STATUS) error {

	// ServiceFabricCluster
	if source.ServiceFabricCluster != nil {
		var serviceFabricCluster BackendServiceFabricClusterProperties_STATUS
		err := serviceFabricCluster.AssignProperties_From_BackendServiceFabricClusterProperties_STATUS(source.ServiceFabricCluster)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BackendServiceFabricClusterProperties_STATUS() to populate field ServiceFabricCluster")
		}
		properties.ServiceFabricCluster = &serviceFabricCluster
	} else {
		properties.ServiceFabricCluster = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackendProperties_STATUS populates the provided destination BackendProperties_STATUS from our BackendProperties_STATUS
func (properties *BackendProperties_STATUS) AssignProperties_To_BackendProperties_STATUS(destination *v20220801s.BackendProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ServiceFabricCluster
	if properties.ServiceFabricCluster != nil {
		var serviceFabricCluster v20220801s.BackendServiceFabricClusterProperties_STATUS
		err := properties.ServiceFabricCluster.AssignProperties_To_BackendServiceFabricClusterProperties_STATUS(&serviceFabricCluster)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BackendServiceFabricClusterProperties_STATUS() to populate field ServiceFabricCluster")
		}
		destination.ServiceFabricCluster = &serviceFabricCluster
	} else {
		destination.ServiceFabricCluster = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details of the Backend WebProxy Server to use in the Request to Backend.
type BackendProxyContract struct {
	// Password: Password to connect to the WebProxy Server
	Password *genruntime.SecretReference `json:"password,omitempty"`

	// +kubebuilder:validation:Required
	// +kubebuilder:validation:MaxLength=2000
	// +kubebuilder:validation:MinLength=1
	// Url: WebProxy Server AbsoluteUri property which includes the entire URI stored in the Uri instance, including all
	// fragments and query strings.
	Url *string `json:"url,omitempty"`

	// Username: Username to connect to the WebProxy server
	Username *string `json:"username,omitempty"`
}

var _ genruntime.ARMTransformer = &BackendProxyContract{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (contract *BackendProxyContract) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if contract == nil {
		return nil, nil
	}
	result := &BackendProxyContract_ARM{}

	// Set property "Password":
	if contract.Password != nil {
		passwordSecret, err := resolved.ResolvedSecrets.Lookup(*contract.Password)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property Password")
		}
		password := passwordSecret
		result.Password = &password
	}

	// Set property "Url":
	if contract.Url != nil {
		url := *contract.Url
		result.Url = &url
	}

	// Set property "Username":
	if contract.Username != nil {
		username := *contract.Username
		result.Username = &username
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (contract *BackendProxyContract) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackendProxyContract_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (contract *BackendProxyContract) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackendProxyContract_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackendProxyContract_ARM, got %T", armInput)
	}

	// no assignment for property "Password"

	// Set property "Url":
	if typedInput.Url != nil {
		url := *typedInput.Url
		contract.Url = &url
	}

	// Set property "Username":
	if typedInput.Username != nil {
		username := *typedInput.Username
		contract.Username = &username
	}

	// No error
	return nil
}

// AssignProperties_From_BackendProxyContract populates our BackendProxyContract from the provided source BackendProxyContract
func (contract *BackendProxyContract) AssignProperties_From_BackendProxyContract(source *v20220801s.BackendProxyContract) error {

	// Password
	if source.Password != nil {
		password := source.Password.Copy()
		contract.Password = &password
	} else {
		contract.Password = nil
	}

	// Url
	if source.Url != nil {
		url := *source.Url
		contract.Url = &url
	} else {
		contract.Url = nil
	}

	// Username
	contract.Username = genruntime.ClonePointerToString(source.Username)

	// No error
	return nil
}

// AssignProperties_To_BackendProxyContract populates the provided destination BackendProxyContract from our BackendProxyContract
func (contract *BackendProxyContract) AssignProperties_To_BackendProxyContract(destination *v20220801s.BackendProxyContract) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Password
	if contract.Password != nil {
		password := contract.Password.Copy()
		destination.Password = &password
	} else {
		destination.Password = nil
	}

	// Url
	if contract.Url != nil {
		url := *contract.Url
		destination.Url = &url
	} else {
		destination.Url = nil
	}

	// Username
	destination.Username = genruntime.ClonePointerToString(contract.Username)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_BackendProxyContract_STATUS populates our BackendProxyContract from the provided source BackendProxyContract_STATUS
func (contract *BackendProxyContract) Initialize_From_BackendProxyContract_STATUS(source *BackendProxyContract_STATUS) error {

	// Url
	if source.Url != nil {
		url := *source.Url
		contract.Url = &url
	} else {
		contract.Url = nil
	}

	// Username
	contract.Username = genruntime.ClonePointerToString(source.Username)

	// No error
	return nil
}

// Details of the Backend WebProxy Server to use in the Request to Backend.
type BackendProxyContract_STATUS struct {
	// Url: WebProxy Server AbsoluteUri property which includes the entire URI stored in the Uri instance, including all
	// fragments and query strings.
	Url *string `json:"url,omitempty"`

	// Username: Username to connect to the WebProxy server
	Username *string `json:"username,omitempty"`
}

var _ genruntime.FromARMConverter = &BackendProxyContract_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (contract *BackendProxyContract_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackendProxyContract_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (contract *BackendProxyContract_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackendProxyContract_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackendProxyContract_STATUS_ARM, got %T", armInput)
	}

	// Set property "Url":
	if typedInput.Url != nil {
		url := *typedInput.Url
		contract.Url = &url
	}

	// Set property "Username":
	if typedInput.Username != nil {
		username := *typedInput.Username
		contract.Username = &username
	}

	// No error
	return nil
}

// AssignProperties_From_BackendProxyContract_STATUS populates our BackendProxyContract_STATUS from the provided source BackendProxyContract_STATUS
func (contract *BackendProxyContract_STATUS) AssignProperties_From_BackendProxyContract_STATUS(source *v20220801s.BackendProxyContract_STATUS) error {

	// Url
	contract.Url = genruntime.ClonePointerToString(source.Url)

	// Username
	contract.Username = genruntime.ClonePointerToString(source.Username)

	// No error
	return nil
}

// AssignProperties_To_BackendProxyContract_STATUS populates the provided destination BackendProxyContract_STATUS from our BackendProxyContract_STATUS
func (contract *BackendProxyContract_STATUS) AssignProperties_To_BackendProxyContract_STATUS(destination *v20220801s.BackendProxyContract_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Url
	destination.Url = genruntime.ClonePointerToString(contract.Url)

	// Username
	destination.Username = genruntime.ClonePointerToString(contract.Username)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Properties controlling TLS Certificate Validation.
type BackendTlsProperties struct {
	// ValidateCertificateChain: Flag indicating whether SSL certificate chain validation should be done when using self-signed
	// certificates for this backend host.
	ValidateCertificateChain *bool `json:"validateCertificateChain,omitempty"`

	// ValidateCertificateName: Flag indicating whether SSL certificate name validation should be done when using self-signed
	// certificates for this backend host.
	ValidateCertificateName *bool `json:"validateCertificateName,omitempty"`
}

var _ genruntime.ARMTransformer = &BackendTlsProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *BackendTlsProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &BackendTlsProperties_ARM{}

	// Set property "ValidateCertificateChain":
	if properties.ValidateCertificateChain != nil {
		validateCertificateChain := *properties.ValidateCertificateChain
		result.ValidateCertificateChain = &validateCertificateChain
	}

	// Set property "ValidateCertificateName":
	if properties.ValidateCertificateName != nil {
		validateCertificateName := *properties.ValidateCertificateName
		result.ValidateCertificateName = &validateCertificateName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *BackendTlsProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackendTlsProperties_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *BackendTlsProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackendTlsProperties_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackendTlsProperties_ARM, got %T", armInput)
	}

	// Set property "ValidateCertificateChain":
	if typedInput.ValidateCertificateChain != nil {
		validateCertificateChain := *typedInput.ValidateCertificateChain
		properties.ValidateCertificateChain = &validateCertificateChain
	}

	// Set property "ValidateCertificateName":
	if typedInput.ValidateCertificateName != nil {
		validateCertificateName := *typedInput.ValidateCertificateName
		properties.ValidateCertificateName = &validateCertificateName
	}

	// No error
	return nil
}

// AssignProperties_From_BackendTlsProperties populates our BackendTlsProperties from the provided source BackendTlsProperties
func (properties *BackendTlsProperties) AssignProperties_From_BackendTlsProperties(source *v20220801s.BackendTlsProperties) error {

	// ValidateCertificateChain
	if source.ValidateCertificateChain != nil {
		validateCertificateChain := *source.ValidateCertificateChain
		properties.ValidateCertificateChain = &validateCertificateChain
	} else {
		properties.ValidateCertificateChain = nil
	}

	// ValidateCertificateName
	if source.ValidateCertificateName != nil {
		validateCertificateName := *source.ValidateCertificateName
		properties.ValidateCertificateName = &validateCertificateName
	} else {
		properties.ValidateCertificateName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackendTlsProperties populates the provided destination BackendTlsProperties from our BackendTlsProperties
func (properties *BackendTlsProperties) AssignProperties_To_BackendTlsProperties(destination *v20220801s.BackendTlsProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ValidateCertificateChain
	if properties.ValidateCertificateChain != nil {
		validateCertificateChain := *properties.ValidateCertificateChain
		destination.ValidateCertificateChain = &validateCertificateChain
	} else {
		destination.ValidateCertificateChain = nil
	}

	// ValidateCertificateName
	if properties.ValidateCertificateName != nil {
		validateCertificateName := *properties.ValidateCertificateName
		destination.ValidateCertificateName = &validateCertificateName
	} else {
		destination.ValidateCertificateName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_BackendTlsProperties_STATUS populates our BackendTlsProperties from the provided source BackendTlsProperties_STATUS
func (properties *BackendTlsProperties) Initialize_From_BackendTlsProperties_STATUS(source *BackendTlsProperties_STATUS) error {

	// ValidateCertificateChain
	if source.ValidateCertificateChain != nil {
		validateCertificateChain := *source.ValidateCertificateChain
		properties.ValidateCertificateChain = &validateCertificateChain
	} else {
		properties.ValidateCertificateChain = nil
	}

	// ValidateCertificateName
	if source.ValidateCertificateName != nil {
		validateCertificateName := *source.ValidateCertificateName
		properties.ValidateCertificateName = &validateCertificateName
	} else {
		properties.ValidateCertificateName = nil
	}

	// No error
	return nil
}

// Properties controlling TLS Certificate Validation.
type BackendTlsProperties_STATUS struct {
	// ValidateCertificateChain: Flag indicating whether SSL certificate chain validation should be done when using self-signed
	// certificates for this backend host.
	ValidateCertificateChain *bool `json:"validateCertificateChain,omitempty"`

	// ValidateCertificateName: Flag indicating whether SSL certificate name validation should be done when using self-signed
	// certificates for this backend host.
	ValidateCertificateName *bool `json:"validateCertificateName,omitempty"`
}

var _ genruntime.FromARMConverter = &BackendTlsProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *BackendTlsProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackendTlsProperties_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *BackendTlsProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackendTlsProperties_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackendTlsProperties_STATUS_ARM, got %T", armInput)
	}

	// Set property "ValidateCertificateChain":
	if typedInput.ValidateCertificateChain != nil {
		validateCertificateChain := *typedInput.ValidateCertificateChain
		properties.ValidateCertificateChain = &validateCertificateChain
	}

	// Set property "ValidateCertificateName":
	if typedInput.ValidateCertificateName != nil {
		validateCertificateName := *typedInput.ValidateCertificateName
		properties.ValidateCertificateName = &validateCertificateName
	}

	// No error
	return nil
}

// AssignProperties_From_BackendTlsProperties_STATUS populates our BackendTlsProperties_STATUS from the provided source BackendTlsProperties_STATUS
func (properties *BackendTlsProperties_STATUS) AssignProperties_From_BackendTlsProperties_STATUS(source *v20220801s.BackendTlsProperties_STATUS) error {

	// ValidateCertificateChain
	if source.ValidateCertificateChain != nil {
		validateCertificateChain := *source.ValidateCertificateChain
		properties.ValidateCertificateChain = &validateCertificateChain
	} else {
		properties.ValidateCertificateChain = nil
	}

	// ValidateCertificateName
	if source.ValidateCertificateName != nil {
		validateCertificateName := *source.ValidateCertificateName
		properties.ValidateCertificateName = &validateCertificateName
	} else {
		properties.ValidateCertificateName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackendTlsProperties_STATUS populates the provided destination BackendTlsProperties_STATUS from our BackendTlsProperties_STATUS
func (properties *BackendTlsProperties_STATUS) AssignProperties_To_BackendTlsProperties_STATUS(destination *v20220801s.BackendTlsProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ValidateCertificateChain
	if properties.ValidateCertificateChain != nil {
		validateCertificateChain := *properties.ValidateCertificateChain
		destination.ValidateCertificateChain = &validateCertificateChain
	} else {
		destination.ValidateCertificateChain = nil
	}

	// ValidateCertificateName
	if properties.ValidateCertificateName != nil {
		validateCertificateName := *properties.ValidateCertificateName
		destination.ValidateCertificateName = &validateCertificateName
	} else {
		destination.ValidateCertificateName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Authorization header information.
type BackendAuthorizationHeaderCredentials struct {
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:MaxLength=300
	// +kubebuilder:validation:MinLength=1
	// Parameter: Authentication Parameter value.
	Parameter *string `json:"parameter,omitempty"`

	// +kubebuilder:validation:Required
	// +kubebuilder:validation:MaxLength=100
	// +kubebuilder:validation:MinLength=1
	// Scheme: Authentication Scheme name.
	Scheme *string `json:"scheme,omitempty"`
}

var _ genruntime.ARMTransformer = &BackendAuthorizationHeaderCredentials{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (credentials *BackendAuthorizationHeaderCredentials) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if credentials == nil {
		return nil, nil
	}
	result := &BackendAuthorizationHeaderCredentials_ARM{}

	// Set property "Parameter":
	if credentials.Parameter != nil {
		parameter := *credentials.Parameter
		result.Parameter = &parameter
	}

	// Set property "Scheme":
	if credentials.Scheme != nil {
		scheme := *credentials.Scheme
		result.Scheme = &scheme
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (credentials *BackendAuthorizationHeaderCredentials) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackendAuthorizationHeaderCredentials_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (credentials *BackendAuthorizationHeaderCredentials) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackendAuthorizationHeaderCredentials_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackendAuthorizationHeaderCredentials_ARM, got %T", armInput)
	}

	// Set property "Parameter":
	if typedInput.Parameter != nil {
		parameter := *typedInput.Parameter
		credentials.Parameter = &parameter
	}

	// Set property "Scheme":
	if typedInput.Scheme != nil {
		scheme := *typedInput.Scheme
		credentials.Scheme = &scheme
	}

	// No error
	return nil
}

// AssignProperties_From_BackendAuthorizationHeaderCredentials populates our BackendAuthorizationHeaderCredentials from the provided source BackendAuthorizationHeaderCredentials
func (credentials *BackendAuthorizationHeaderCredentials) AssignProperties_From_BackendAuthorizationHeaderCredentials(source *v20220801s.BackendAuthorizationHeaderCredentials) error {

	// Parameter
	if source.Parameter != nil {
		parameter := *source.Parameter
		credentials.Parameter = &parameter
	} else {
		credentials.Parameter = nil
	}

	// Scheme
	if source.Scheme != nil {
		scheme := *source.Scheme
		credentials.Scheme = &scheme
	} else {
		credentials.Scheme = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackendAuthorizationHeaderCredentials populates the provided destination BackendAuthorizationHeaderCredentials from our BackendAuthorizationHeaderCredentials
func (credentials *BackendAuthorizationHeaderCredentials) AssignProperties_To_BackendAuthorizationHeaderCredentials(destination *v20220801s.BackendAuthorizationHeaderCredentials) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Parameter
	if credentials.Parameter != nil {
		parameter := *credentials.Parameter
		destination.Parameter = &parameter
	} else {
		destination.Parameter = nil
	}

	// Scheme
	if credentials.Scheme != nil {
		scheme := *credentials.Scheme
		destination.Scheme = &scheme
	} else {
		destination.Scheme = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_BackendAuthorizationHeaderCredentials_STATUS populates our BackendAuthorizationHeaderCredentials from the provided source BackendAuthorizationHeaderCredentials_STATUS
func (credentials *BackendAuthorizationHeaderCredentials) Initialize_From_BackendAuthorizationHeaderCredentials_STATUS(source *BackendAuthorizationHeaderCredentials_STATUS) error {

	// Parameter
	if source.Parameter != nil {
		parameter := *source.Parameter
		credentials.Parameter = &parameter
	} else {
		credentials.Parameter = nil
	}

	// Scheme
	if source.Scheme != nil {
		scheme := *source.Scheme
		credentials.Scheme = &scheme
	} else {
		credentials.Scheme = nil
	}

	// No error
	return nil
}

// Authorization header information.
type BackendAuthorizationHeaderCredentials_STATUS struct {
	// Parameter: Authentication Parameter value.
	Parameter *string `json:"parameter,omitempty"`

	// Scheme: Authentication Scheme name.
	Scheme *string `json:"scheme,omitempty"`
}

var _ genruntime.FromARMConverter = &BackendAuthorizationHeaderCredentials_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (credentials *BackendAuthorizationHeaderCredentials_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackendAuthorizationHeaderCredentials_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (credentials *BackendAuthorizationHeaderCredentials_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackendAuthorizationHeaderCredentials_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackendAuthorizationHeaderCredentials_STATUS_ARM, got %T", armInput)
	}

	// Set property "Parameter":
	if typedInput.Parameter != nil {
		parameter := *typedInput.Parameter
		credentials.Parameter = &parameter
	}

	// Set property "Scheme":
	if typedInput.Scheme != nil {
		scheme := *typedInput.Scheme
		credentials.Scheme = &scheme
	}

	// No error
	return nil
}

// AssignProperties_From_BackendAuthorizationHeaderCredentials_STATUS populates our BackendAuthorizationHeaderCredentials_STATUS from the provided source BackendAuthorizationHeaderCredentials_STATUS
func (credentials *BackendAuthorizationHeaderCredentials_STATUS) AssignProperties_From_BackendAuthorizationHeaderCredentials_STATUS(source *v20220801s.BackendAuthorizationHeaderCredentials_STATUS) error {

	// Parameter
	credentials.Parameter = genruntime.ClonePointerToString(source.Parameter)

	// Scheme
	credentials.Scheme = genruntime.ClonePointerToString(source.Scheme)

	// No error
	return nil
}

// AssignProperties_To_BackendAuthorizationHeaderCredentials_STATUS populates the provided destination BackendAuthorizationHeaderCredentials_STATUS from our BackendAuthorizationHeaderCredentials_STATUS
func (credentials *BackendAuthorizationHeaderCredentials_STATUS) AssignProperties_To_BackendAuthorizationHeaderCredentials_STATUS(destination *v20220801s.BackendAuthorizationHeaderCredentials_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Parameter
	destination.Parameter = genruntime.ClonePointerToString(credentials.Parameter)

	// Scheme
	destination.Scheme = genruntime.ClonePointerToString(credentials.Scheme)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Properties of the Service Fabric Type Backend.
type BackendServiceFabricClusterProperties struct {
	// ClientCertificateId: The client certificate id for the management endpoint.
	ClientCertificateId *string `json:"clientCertificateId,omitempty"`

	// ClientCertificatethumbprint: The client certificate thumbprint for the management endpoint. Will be ignored if
	// certificatesIds are provided
	ClientCertificatethumbprint *string `json:"clientCertificatethumbprint,omitempty"`

	// +kubebuilder:validation:Required
	// ManagementEndpoints: The cluster management endpoint.
	ManagementEndpoints []string `json:"managementEndpoints,omitempty"`

	// MaxPartitionResolutionRetries: Maximum number of retries while attempting resolve the partition.
	MaxPartitionResolutionRetries *int `json:"maxPartitionResolutionRetries,omitempty"`

	// ServerCertificateThumbprints: Thumbprints of certificates cluster management service uses for tls communication
	ServerCertificateThumbprints []string `json:"serverCertificateThumbprints,omitempty"`

	// ServerX509Names: Server X509 Certificate Names Collection
	ServerX509Names []X509CertificateName `json:"serverX509Names,omitempty"`
}

var _ genruntime.ARMTransformer = &BackendServiceFabricClusterProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *BackendServiceFabricClusterProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &BackendServiceFabricClusterProperties_ARM{}

	// Set property "ClientCertificateId":
	if properties.ClientCertificateId != nil {
		clientCertificateId := *properties.ClientCertificateId
		result.ClientCertificateId = &clientCertificateId
	}

	// Set property "ClientCertificatethumbprint":
	if properties.ClientCertificatethumbprint != nil {
		clientCertificatethumbprint := *properties.ClientCertificatethumbprint
		result.ClientCertificatethumbprint = &clientCertificatethumbprint
	}

	// Set property "ManagementEndpoints":
	for _, item := range properties.ManagementEndpoints {
		result.ManagementEndpoints = append(result.ManagementEndpoints, item)
	}

	// Set property "MaxPartitionResolutionRetries":
	if properties.MaxPartitionResolutionRetries != nil {
		maxPartitionResolutionRetries := *properties.MaxPartitionResolutionRetries
		result.MaxPartitionResolutionRetries = &maxPartitionResolutionRetries
	}

	// Set property "ServerCertificateThumbprints":
	for _, item := range properties.ServerCertificateThumbprints {
		result.ServerCertificateThumbprints = append(result.ServerCertificateThumbprints, item)
	}

	// Set property "ServerX509Names":
	for _, item := range properties.ServerX509Names {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.ServerX509Names = append(result.ServerX509Names, *item_ARM.(*X509CertificateName_ARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *BackendServiceFabricClusterProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackendServiceFabricClusterProperties_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *BackendServiceFabricClusterProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackendServiceFabricClusterProperties_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackendServiceFabricClusterProperties_ARM, got %T", armInput)
	}

	// Set property "ClientCertificateId":
	if typedInput.ClientCertificateId != nil {
		clientCertificateId := *typedInput.ClientCertificateId
		properties.ClientCertificateId = &clientCertificateId
	}

	// Set property "ClientCertificatethumbprint":
	if typedInput.ClientCertificatethumbprint != nil {
		clientCertificatethumbprint := *typedInput.ClientCertificatethumbprint
		properties.ClientCertificatethumbprint = &clientCertificatethumbprint
	}

	// Set property "ManagementEndpoints":
	for _, item := range typedInput.ManagementEndpoints {
		properties.ManagementEndpoints = append(properties.ManagementEndpoints, item)
	}

	// Set property "MaxPartitionResolutionRetries":
	if typedInput.MaxPartitionResolutionRetries != nil {
		maxPartitionResolutionRetries := *typedInput.MaxPartitionResolutionRetries
		properties.MaxPartitionResolutionRetries = &maxPartitionResolutionRetries
	}

	// Set property "ServerCertificateThumbprints":
	for _, item := range typedInput.ServerCertificateThumbprints {
		properties.ServerCertificateThumbprints = append(properties.ServerCertificateThumbprints, item)
	}

	// Set property "ServerX509Names":
	for _, item := range typedInput.ServerX509Names {
		var item1 X509CertificateName
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.ServerX509Names = append(properties.ServerX509Names, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_BackendServiceFabricClusterProperties populates our BackendServiceFabricClusterProperties from the provided source BackendServiceFabricClusterProperties
func (properties *BackendServiceFabricClusterProperties) AssignProperties_From_BackendServiceFabricClusterProperties(source *v20220801s.BackendServiceFabricClusterProperties) error {

	// ClientCertificateId
	properties.ClientCertificateId = genruntime.ClonePointerToString(source.ClientCertificateId)

	// ClientCertificatethumbprint
	properties.ClientCertificatethumbprint = genruntime.ClonePointerToString(source.ClientCertificatethumbprint)

	// ManagementEndpoints
	properties.ManagementEndpoints = genruntime.CloneSliceOfString(source.ManagementEndpoints)

	// MaxPartitionResolutionRetries
	properties.MaxPartitionResolutionRetries = genruntime.ClonePointerToInt(source.MaxPartitionResolutionRetries)

	// ServerCertificateThumbprints
	properties.ServerCertificateThumbprints = genruntime.CloneSliceOfString(source.ServerCertificateThumbprints)

	// ServerX509Names
	if source.ServerX509Names != nil {
		serverX509NameList := make([]X509CertificateName, len(source.ServerX509Names))
		for serverX509NameIndex, serverX509NameItem := range source.ServerX509Names {
			// Shadow the loop variable to avoid aliasing
			serverX509NameItem := serverX509NameItem
			var serverX509Name X509CertificateName
			err := serverX509Name.AssignProperties_From_X509CertificateName(&serverX509NameItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_X509CertificateName() to populate field ServerX509Names")
			}
			serverX509NameList[serverX509NameIndex] = serverX509Name
		}
		properties.ServerX509Names = serverX509NameList
	} else {
		properties.ServerX509Names = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackendServiceFabricClusterProperties populates the provided destination BackendServiceFabricClusterProperties from our BackendServiceFabricClusterProperties
func (properties *BackendServiceFabricClusterProperties) AssignProperties_To_BackendServiceFabricClusterProperties(destination *v20220801s.BackendServiceFabricClusterProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientCertificateId
	destination.ClientCertificateId = genruntime.ClonePointerToString(properties.ClientCertificateId)

	// ClientCertificatethumbprint
	destination.ClientCertificatethumbprint = genruntime.ClonePointerToString(properties.ClientCertificatethumbprint)

	// ManagementEndpoints
	destination.ManagementEndpoints = genruntime.CloneSliceOfString(properties.ManagementEndpoints)

	// MaxPartitionResolutionRetries
	destination.MaxPartitionResolutionRetries = genruntime.ClonePointerToInt(properties.MaxPartitionResolutionRetries)

	// ServerCertificateThumbprints
	destination.ServerCertificateThumbprints = genruntime.CloneSliceOfString(properties.ServerCertificateThumbprints)

	// ServerX509Names
	if properties.ServerX509Names != nil {
		serverX509NameList := make([]v20220801s.X509CertificateName, len(properties.ServerX509Names))
		for serverX509NameIndex, serverX509NameItem := range properties.ServerX509Names {
			// Shadow the loop variable to avoid aliasing
			serverX509NameItem := serverX509NameItem
			var serverX509Name v20220801s.X509CertificateName
			err := serverX509NameItem.AssignProperties_To_X509CertificateName(&serverX509Name)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_X509CertificateName() to populate field ServerX509Names")
			}
			serverX509NameList[serverX509NameIndex] = serverX509Name
		}
		destination.ServerX509Names = serverX509NameList
	} else {
		destination.ServerX509Names = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_BackendServiceFabricClusterProperties_STATUS populates our BackendServiceFabricClusterProperties from the provided source BackendServiceFabricClusterProperties_STATUS
func (properties *BackendServiceFabricClusterProperties) Initialize_From_BackendServiceFabricClusterProperties_STATUS(source *BackendServiceFabricClusterProperties_STATUS) error {

	// ClientCertificateId
	properties.ClientCertificateId = genruntime.ClonePointerToString(source.ClientCertificateId)

	// ClientCertificatethumbprint
	properties.ClientCertificatethumbprint = genruntime.ClonePointerToString(source.ClientCertificatethumbprint)

	// ManagementEndpoints
	properties.ManagementEndpoints = genruntime.CloneSliceOfString(source.ManagementEndpoints)

	// MaxPartitionResolutionRetries
	properties.MaxPartitionResolutionRetries = genruntime.ClonePointerToInt(source.MaxPartitionResolutionRetries)

	// ServerCertificateThumbprints
	properties.ServerCertificateThumbprints = genruntime.CloneSliceOfString(source.ServerCertificateThumbprints)

	// ServerX509Names
	if source.ServerX509Names != nil {
		serverX509NameList := make([]X509CertificateName, len(source.ServerX509Names))
		for serverX509NameIndex, serverX509NameItem := range source.ServerX509Names {
			// Shadow the loop variable to avoid aliasing
			serverX509NameItem := serverX509NameItem
			var serverX509Name X509CertificateName
			err := serverX509Name.Initialize_From_X509CertificateName_STATUS(&serverX509NameItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_X509CertificateName_STATUS() to populate field ServerX509Names")
			}
			serverX509NameList[serverX509NameIndex] = serverX509Name
		}
		properties.ServerX509Names = serverX509NameList
	} else {
		properties.ServerX509Names = nil
	}

	// No error
	return nil
}

// Properties of the Service Fabric Type Backend.
type BackendServiceFabricClusterProperties_STATUS struct {
	// ClientCertificateId: The client certificate id for the management endpoint.
	ClientCertificateId *string `json:"clientCertificateId,omitempty"`

	// ClientCertificatethumbprint: The client certificate thumbprint for the management endpoint. Will be ignored if
	// certificatesIds are provided
	ClientCertificatethumbprint *string `json:"clientCertificatethumbprint,omitempty"`

	// ManagementEndpoints: The cluster management endpoint.
	ManagementEndpoints []string `json:"managementEndpoints,omitempty"`

	// MaxPartitionResolutionRetries: Maximum number of retries while attempting resolve the partition.
	MaxPartitionResolutionRetries *int `json:"maxPartitionResolutionRetries,omitempty"`

	// ServerCertificateThumbprints: Thumbprints of certificates cluster management service uses for tls communication
	ServerCertificateThumbprints []string `json:"serverCertificateThumbprints,omitempty"`

	// ServerX509Names: Server X509 Certificate Names Collection
	ServerX509Names []X509CertificateName_STATUS `json:"serverX509Names,omitempty"`
}

var _ genruntime.FromARMConverter = &BackendServiceFabricClusterProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *BackendServiceFabricClusterProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackendServiceFabricClusterProperties_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *BackendServiceFabricClusterProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackendServiceFabricClusterProperties_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackendServiceFabricClusterProperties_STATUS_ARM, got %T", armInput)
	}

	// Set property "ClientCertificateId":
	if typedInput.ClientCertificateId != nil {
		clientCertificateId := *typedInput.ClientCertificateId
		properties.ClientCertificateId = &clientCertificateId
	}

	// Set property "ClientCertificatethumbprint":
	if typedInput.ClientCertificatethumbprint != nil {
		clientCertificatethumbprint := *typedInput.ClientCertificatethumbprint
		properties.ClientCertificatethumbprint = &clientCertificatethumbprint
	}

	// Set property "ManagementEndpoints":
	for _, item := range typedInput.ManagementEndpoints {
		properties.ManagementEndpoints = append(properties.ManagementEndpoints, item)
	}

	// Set property "MaxPartitionResolutionRetries":
	if typedInput.MaxPartitionResolutionRetries != nil {
		maxPartitionResolutionRetries := *typedInput.MaxPartitionResolutionRetries
		properties.MaxPartitionResolutionRetries = &maxPartitionResolutionRetries
	}

	// Set property "ServerCertificateThumbprints":
	for _, item := range typedInput.ServerCertificateThumbprints {
		properties.ServerCertificateThumbprints = append(properties.ServerCertificateThumbprints, item)
	}

	// Set property "ServerX509Names":
	for _, item := range typedInput.ServerX509Names {
		var item1 X509CertificateName_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.ServerX509Names = append(properties.ServerX509Names, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_BackendServiceFabricClusterProperties_STATUS populates our BackendServiceFabricClusterProperties_STATUS from the provided source BackendServiceFabricClusterProperties_STATUS
func (properties *BackendServiceFabricClusterProperties_STATUS) AssignProperties_From_BackendServiceFabricClusterProperties_STATUS(source *v20220801s.BackendServiceFabricClusterProperties_STATUS) error {

	// ClientCertificateId
	properties.ClientCertificateId = genruntime.ClonePointerToString(source.ClientCertificateId)

	// ClientCertificatethumbprint
	properties.ClientCertificatethumbprint = genruntime.ClonePointerToString(source.ClientCertificatethumbprint)

	// ManagementEndpoints
	properties.ManagementEndpoints = genruntime.CloneSliceOfString(source.ManagementEndpoints)

	// MaxPartitionResolutionRetries
	properties.MaxPartitionResolutionRetries = genruntime.ClonePointerToInt(source.MaxPartitionResolutionRetries)

	// ServerCertificateThumbprints
	properties.ServerCertificateThumbprints = genruntime.CloneSliceOfString(source.ServerCertificateThumbprints)

	// ServerX509Names
	if source.ServerX509Names != nil {
		serverX509NameList := make([]X509CertificateName_STATUS, len(source.ServerX509Names))
		for serverX509NameIndex, serverX509NameItem := range source.ServerX509Names {
			// Shadow the loop variable to avoid aliasing
			serverX509NameItem := serverX509NameItem
			var serverX509Name X509CertificateName_STATUS
			err := serverX509Name.AssignProperties_From_X509CertificateName_STATUS(&serverX509NameItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_X509CertificateName_STATUS() to populate field ServerX509Names")
			}
			serverX509NameList[serverX509NameIndex] = serverX509Name
		}
		properties.ServerX509Names = serverX509NameList
	} else {
		properties.ServerX509Names = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackendServiceFabricClusterProperties_STATUS populates the provided destination BackendServiceFabricClusterProperties_STATUS from our BackendServiceFabricClusterProperties_STATUS
func (properties *BackendServiceFabricClusterProperties_STATUS) AssignProperties_To_BackendServiceFabricClusterProperties_STATUS(destination *v20220801s.BackendServiceFabricClusterProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientCertificateId
	destination.ClientCertificateId = genruntime.ClonePointerToString(properties.ClientCertificateId)

	// ClientCertificatethumbprint
	destination.ClientCertificatethumbprint = genruntime.ClonePointerToString(properties.ClientCertificatethumbprint)

	// ManagementEndpoints
	destination.ManagementEndpoints = genruntime.CloneSliceOfString(properties.ManagementEndpoints)

	// MaxPartitionResolutionRetries
	destination.MaxPartitionResolutionRetries = genruntime.ClonePointerToInt(properties.MaxPartitionResolutionRetries)

	// ServerCertificateThumbprints
	destination.ServerCertificateThumbprints = genruntime.CloneSliceOfString(properties.ServerCertificateThumbprints)

	// ServerX509Names
	if properties.ServerX509Names != nil {
		serverX509NameList := make([]v20220801s.X509CertificateName_STATUS, len(properties.ServerX509Names))
		for serverX509NameIndex, serverX509NameItem := range properties.ServerX509Names {
			// Shadow the loop variable to avoid aliasing
			serverX509NameItem := serverX509NameItem
			var serverX509Name v20220801s.X509CertificateName_STATUS
			err := serverX509NameItem.AssignProperties_To_X509CertificateName_STATUS(&serverX509Name)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_X509CertificateName_STATUS() to populate field ServerX509Names")
			}
			serverX509NameList[serverX509NameIndex] = serverX509Name
		}
		destination.ServerX509Names = serverX509NameList
	} else {
		destination.ServerX509Names = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Properties of server X509Names.
type X509CertificateName struct {
	// IssuerCertificateThumbprint: Thumbprint for the Issuer of the Certificate.
	IssuerCertificateThumbprint *string `json:"issuerCertificateThumbprint,omitempty"`

	// Name: Common Name of the Certificate.
	Name *string `json:"name,omitempty"`
}

var _ genruntime.ARMTransformer = &X509CertificateName{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (name *X509CertificateName) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if name == nil {
		return nil, nil
	}
	result := &X509CertificateName_ARM{}

	// Set property "IssuerCertificateThumbprint":
	if name.IssuerCertificateThumbprint != nil {
		issuerCertificateThumbprint := *name.IssuerCertificateThumbprint
		result.IssuerCertificateThumbprint = &issuerCertificateThumbprint
	}

	// Set property "Name":
	if name.Name != nil {
		name1 := *name.Name
		result.Name = &name1
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (name *X509CertificateName) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &X509CertificateName_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (name *X509CertificateName) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(X509CertificateName_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected X509CertificateName_ARM, got %T", armInput)
	}

	// Set property "IssuerCertificateThumbprint":
	if typedInput.IssuerCertificateThumbprint != nil {
		issuerCertificateThumbprint := *typedInput.IssuerCertificateThumbprint
		name.IssuerCertificateThumbprint = &issuerCertificateThumbprint
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name1 := *typedInput.Name
		name.Name = &name1
	}

	// No error
	return nil
}

// AssignProperties_From_X509CertificateName populates our X509CertificateName from the provided source X509CertificateName
func (name *X509CertificateName) AssignProperties_From_X509CertificateName(source *v20220801s.X509CertificateName) error {

	// IssuerCertificateThumbprint
	name.IssuerCertificateThumbprint = genruntime.ClonePointerToString(source.IssuerCertificateThumbprint)

	// Name
	name.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// AssignProperties_To_X509CertificateName populates the provided destination X509CertificateName from our X509CertificateName
func (name *X509CertificateName) AssignProperties_To_X509CertificateName(destination *v20220801s.X509CertificateName) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IssuerCertificateThumbprint
	destination.IssuerCertificateThumbprint = genruntime.ClonePointerToString(name.IssuerCertificateThumbprint)

	// Name
	destination.Name = genruntime.ClonePointerToString(name.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_X509CertificateName_STATUS populates our X509CertificateName from the provided source X509CertificateName_STATUS
func (name *X509CertificateName) Initialize_From_X509CertificateName_STATUS(source *X509CertificateName_STATUS) error {

	// IssuerCertificateThumbprint
	name.IssuerCertificateThumbprint = genruntime.ClonePointerToString(source.IssuerCertificateThumbprint)

	// Name
	name.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// Properties of server X509Names.
type X509CertificateName_STATUS struct {
	// IssuerCertificateThumbprint: Thumbprint for the Issuer of the Certificate.
	IssuerCertificateThumbprint *string `json:"issuerCertificateThumbprint,omitempty"`

	// Name: Common Name of the Certificate.
	Name *string `json:"name,omitempty"`
}

var _ genruntime.FromARMConverter = &X509CertificateName_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (name *X509CertificateName_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &X509CertificateName_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (name *X509CertificateName_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(X509CertificateName_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected X509CertificateName_STATUS_ARM, got %T", armInput)
	}

	// Set property "IssuerCertificateThumbprint":
	if typedInput.IssuerCertificateThumbprint != nil {
		issuerCertificateThumbprint := *typedInput.IssuerCertificateThumbprint
		name.IssuerCertificateThumbprint = &issuerCertificateThumbprint
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name1 := *typedInput.Name
		name.Name = &name1
	}

	// No error
	return nil
}

// AssignProperties_From_X509CertificateName_STATUS populates our X509CertificateName_STATUS from the provided source X509CertificateName_STATUS
func (name *X509CertificateName_STATUS) AssignProperties_From_X509CertificateName_STATUS(source *v20220801s.X509CertificateName_STATUS) error {

	// IssuerCertificateThumbprint
	name.IssuerCertificateThumbprint = genruntime.ClonePointerToString(source.IssuerCertificateThumbprint)

	// Name
	name.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// AssignProperties_To_X509CertificateName_STATUS populates the provided destination X509CertificateName_STATUS from our X509CertificateName_STATUS
func (name *X509CertificateName_STATUS) AssignProperties_To_X509CertificateName_STATUS(destination *v20220801s.X509CertificateName_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IssuerCertificateThumbprint
	destination.IssuerCertificateThumbprint = genruntime.ClonePointerToString(name.IssuerCertificateThumbprint)

	// Name
	destination.Name = genruntime.ClonePointerToString(name.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&Backend{}, &BackendList{})
}
