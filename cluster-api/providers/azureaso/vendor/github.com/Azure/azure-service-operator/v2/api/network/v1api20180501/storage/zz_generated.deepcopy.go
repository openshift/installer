//go:build !ignore_autogenerated

/*
Copyright (c) Microsoft Corporation.
Licensed under the MIT license.
*/

// Code generated by controller-gen. DO NOT EDIT.

package storage

import (
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	runtime "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ARecord) DeepCopyInto(out *ARecord) {
	*out = *in
	if in.Ipv4Address != nil {
		in, out := &in.Ipv4Address, &out.Ipv4Address
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ARecord.
func (in *ARecord) DeepCopy() *ARecord {
	if in == nil {
		return nil
	}
	out := new(ARecord)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ARecord_STATUS) DeepCopyInto(out *ARecord_STATUS) {
	*out = *in
	if in.Ipv4Address != nil {
		in, out := &in.Ipv4Address, &out.Ipv4Address
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ARecord_STATUS.
func (in *ARecord_STATUS) DeepCopy() *ARecord_STATUS {
	if in == nil {
		return nil
	}
	out := new(ARecord_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AaaaRecord) DeepCopyInto(out *AaaaRecord) {
	*out = *in
	if in.Ipv6Address != nil {
		in, out := &in.Ipv6Address, &out.Ipv6Address
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AaaaRecord.
func (in *AaaaRecord) DeepCopy() *AaaaRecord {
	if in == nil {
		return nil
	}
	out := new(AaaaRecord)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AaaaRecord_STATUS) DeepCopyInto(out *AaaaRecord_STATUS) {
	*out = *in
	if in.Ipv6Address != nil {
		in, out := &in.Ipv6Address, &out.Ipv6Address
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AaaaRecord_STATUS.
func (in *AaaaRecord_STATUS) DeepCopy() *AaaaRecord_STATUS {
	if in == nil {
		return nil
	}
	out := new(AaaaRecord_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CaaRecord) DeepCopyInto(out *CaaRecord) {
	*out = *in
	if in.Flags != nil {
		in, out := &in.Flags, &out.Flags
		*out = new(int)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Tag != nil {
		in, out := &in.Tag, &out.Tag
		*out = new(string)
		**out = **in
	}
	if in.Value != nil {
		in, out := &in.Value, &out.Value
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CaaRecord.
func (in *CaaRecord) DeepCopy() *CaaRecord {
	if in == nil {
		return nil
	}
	out := new(CaaRecord)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CaaRecord_STATUS) DeepCopyInto(out *CaaRecord_STATUS) {
	*out = *in
	if in.Flags != nil {
		in, out := &in.Flags, &out.Flags
		*out = new(int)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Tag != nil {
		in, out := &in.Tag, &out.Tag
		*out = new(string)
		**out = **in
	}
	if in.Value != nil {
		in, out := &in.Value, &out.Value
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CaaRecord_STATUS.
func (in *CaaRecord_STATUS) DeepCopy() *CaaRecord_STATUS {
	if in == nil {
		return nil
	}
	out := new(CaaRecord_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CnameRecord) DeepCopyInto(out *CnameRecord) {
	*out = *in
	if in.Cname != nil {
		in, out := &in.Cname, &out.Cname
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CnameRecord.
func (in *CnameRecord) DeepCopy() *CnameRecord {
	if in == nil {
		return nil
	}
	out := new(CnameRecord)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CnameRecord_STATUS) DeepCopyInto(out *CnameRecord_STATUS) {
	*out = *in
	if in.Cname != nil {
		in, out := &in.Cname, &out.Cname
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CnameRecord_STATUS.
func (in *CnameRecord_STATUS) DeepCopy() *CnameRecord_STATUS {
	if in == nil {
		return nil
	}
	out := new(CnameRecord_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZone) DeepCopyInto(out *DnsZone) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZone.
func (in *DnsZone) DeepCopy() *DnsZone {
	if in == nil {
		return nil
	}
	out := new(DnsZone)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *DnsZone) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZoneList) DeepCopyInto(out *DnsZoneList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]DnsZone, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZoneList.
func (in *DnsZoneList) DeepCopy() *DnsZoneList {
	if in == nil {
		return nil
	}
	out := new(DnsZoneList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *DnsZoneList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZoneOperatorSpec) DeepCopyInto(out *DnsZoneOperatorSpec) {
	*out = *in
	if in.ConfigMapExpressions != nil {
		in, out := &in.ConfigMapExpressions, &out.ConfigMapExpressions
		*out = make([]*core.DestinationExpression, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(core.DestinationExpression)
				**out = **in
			}
		}
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SecretExpressions != nil {
		in, out := &in.SecretExpressions, &out.SecretExpressions
		*out = make([]*core.DestinationExpression, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(core.DestinationExpression)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZoneOperatorSpec.
func (in *DnsZoneOperatorSpec) DeepCopy() *DnsZoneOperatorSpec {
	if in == nil {
		return nil
	}
	out := new(DnsZoneOperatorSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZone_STATUS) DeepCopyInto(out *DnsZone_STATUS) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]conditions.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Etag != nil {
		in, out := &in.Etag, &out.Etag
		*out = new(string)
		**out = **in
	}
	if in.Id != nil {
		in, out := &in.Id, &out.Id
		*out = new(string)
		**out = **in
	}
	if in.Location != nil {
		in, out := &in.Location, &out.Location
		*out = new(string)
		**out = **in
	}
	if in.MaxNumberOfRecordSets != nil {
		in, out := &in.MaxNumberOfRecordSets, &out.MaxNumberOfRecordSets
		*out = new(int)
		**out = **in
	}
	if in.MaxNumberOfRecordsPerRecordSet != nil {
		in, out := &in.MaxNumberOfRecordsPerRecordSet, &out.MaxNumberOfRecordsPerRecordSet
		*out = new(int)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NameServers != nil {
		in, out := &in.NameServers, &out.NameServers
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.NumberOfRecordSets != nil {
		in, out := &in.NumberOfRecordSets, &out.NumberOfRecordSets
		*out = new(int)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.RegistrationVirtualNetworks != nil {
		in, out := &in.RegistrationVirtualNetworks, &out.RegistrationVirtualNetworks
		*out = make([]SubResource_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ResolutionVirtualNetworks != nil {
		in, out := &in.ResolutionVirtualNetworks, &out.ResolutionVirtualNetworks
		*out = make([]SubResource_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
	if in.ZoneType != nil {
		in, out := &in.ZoneType, &out.ZoneType
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZone_STATUS.
func (in *DnsZone_STATUS) DeepCopy() *DnsZone_STATUS {
	if in == nil {
		return nil
	}
	out := new(DnsZone_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZone_Spec) DeepCopyInto(out *DnsZone_Spec) {
	*out = *in
	if in.Location != nil {
		in, out := &in.Location, &out.Location
		*out = new(string)
		**out = **in
	}
	if in.OperatorSpec != nil {
		in, out := &in.OperatorSpec, &out.OperatorSpec
		*out = new(DnsZoneOperatorSpec)
		(*in).DeepCopyInto(*out)
	}
	if in.Owner != nil {
		in, out := &in.Owner, &out.Owner
		*out = new(genruntime.KnownResourceReference)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.RegistrationVirtualNetworks != nil {
		in, out := &in.RegistrationVirtualNetworks, &out.RegistrationVirtualNetworks
		*out = make([]SubResource, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ResolutionVirtualNetworks != nil {
		in, out := &in.ResolutionVirtualNetworks, &out.ResolutionVirtualNetworks
		*out = make([]SubResource, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ZoneType != nil {
		in, out := &in.ZoneType, &out.ZoneType
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZone_Spec.
func (in *DnsZone_Spec) DeepCopy() *DnsZone_Spec {
	if in == nil {
		return nil
	}
	out := new(DnsZone_Spec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesAAAARecord) DeepCopyInto(out *DnsZonesAAAARecord) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesAAAARecord.
func (in *DnsZonesAAAARecord) DeepCopy() *DnsZonesAAAARecord {
	if in == nil {
		return nil
	}
	out := new(DnsZonesAAAARecord)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *DnsZonesAAAARecord) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesAAAARecordList) DeepCopyInto(out *DnsZonesAAAARecordList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]DnsZonesAAAARecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesAAAARecordList.
func (in *DnsZonesAAAARecordList) DeepCopy() *DnsZonesAAAARecordList {
	if in == nil {
		return nil
	}
	out := new(DnsZonesAAAARecordList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *DnsZonesAAAARecordList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesAAAARecordOperatorSpec) DeepCopyInto(out *DnsZonesAAAARecordOperatorSpec) {
	*out = *in
	if in.ConfigMapExpressions != nil {
		in, out := &in.ConfigMapExpressions, &out.ConfigMapExpressions
		*out = make([]*core.DestinationExpression, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(core.DestinationExpression)
				**out = **in
			}
		}
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SecretExpressions != nil {
		in, out := &in.SecretExpressions, &out.SecretExpressions
		*out = make([]*core.DestinationExpression, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(core.DestinationExpression)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesAAAARecordOperatorSpec.
func (in *DnsZonesAAAARecordOperatorSpec) DeepCopy() *DnsZonesAAAARecordOperatorSpec {
	if in == nil {
		return nil
	}
	out := new(DnsZonesAAAARecordOperatorSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesAAAARecord_STATUS) DeepCopyInto(out *DnsZonesAAAARecord_STATUS) {
	*out = *in
	if in.AAAARecords != nil {
		in, out := &in.AAAARecords, &out.AAAARecords
		*out = make([]AaaaRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ARecords != nil {
		in, out := &in.ARecords, &out.ARecords
		*out = make([]ARecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.CNAMERecord != nil {
		in, out := &in.CNAMERecord, &out.CNAMERecord
		*out = new(CnameRecord_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.CaaRecords != nil {
		in, out := &in.CaaRecords, &out.CaaRecords
		*out = make([]CaaRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]conditions.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Etag != nil {
		in, out := &in.Etag, &out.Etag
		*out = new(string)
		**out = **in
	}
	if in.Fqdn != nil {
		in, out := &in.Fqdn, &out.Fqdn
		*out = new(string)
		**out = **in
	}
	if in.Id != nil {
		in, out := &in.Id, &out.Id
		*out = new(string)
		**out = **in
	}
	if in.MXRecords != nil {
		in, out := &in.MXRecords, &out.MXRecords
		*out = make([]MxRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Metadata != nil {
		in, out := &in.Metadata, &out.Metadata
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.NSRecords != nil {
		in, out := &in.NSRecords, &out.NSRecords
		*out = make([]NsRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PTRRecords != nil {
		in, out := &in.PTRRecords, &out.PTRRecords
		*out = make([]PtrRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ProvisioningState != nil {
		in, out := &in.ProvisioningState, &out.ProvisioningState
		*out = new(string)
		**out = **in
	}
	if in.SOARecord != nil {
		in, out := &in.SOARecord, &out.SOARecord
		*out = new(SoaRecord_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.SRVRecords != nil {
		in, out := &in.SRVRecords, &out.SRVRecords
		*out = make([]SrvRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TTL != nil {
		in, out := &in.TTL, &out.TTL
		*out = new(int)
		**out = **in
	}
	if in.TXTRecords != nil {
		in, out := &in.TXTRecords, &out.TXTRecords
		*out = make([]TxtRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TargetResource != nil {
		in, out := &in.TargetResource, &out.TargetResource
		*out = new(SubResource_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesAAAARecord_STATUS.
func (in *DnsZonesAAAARecord_STATUS) DeepCopy() *DnsZonesAAAARecord_STATUS {
	if in == nil {
		return nil
	}
	out := new(DnsZonesAAAARecord_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesAAAARecord_Spec) DeepCopyInto(out *DnsZonesAAAARecord_Spec) {
	*out = *in
	if in.AAAARecords != nil {
		in, out := &in.AAAARecords, &out.AAAARecords
		*out = make([]AaaaRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ARecords != nil {
		in, out := &in.ARecords, &out.ARecords
		*out = make([]ARecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.CNAMERecord != nil {
		in, out := &in.CNAMERecord, &out.CNAMERecord
		*out = new(CnameRecord)
		(*in).DeepCopyInto(*out)
	}
	if in.CaaRecords != nil {
		in, out := &in.CaaRecords, &out.CaaRecords
		*out = make([]CaaRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MXRecords != nil {
		in, out := &in.MXRecords, &out.MXRecords
		*out = make([]MxRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Metadata != nil {
		in, out := &in.Metadata, &out.Metadata
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.NSRecords != nil {
		in, out := &in.NSRecords, &out.NSRecords
		*out = make([]NsRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.OperatorSpec != nil {
		in, out := &in.OperatorSpec, &out.OperatorSpec
		*out = new(DnsZonesAAAARecordOperatorSpec)
		(*in).DeepCopyInto(*out)
	}
	if in.Owner != nil {
		in, out := &in.Owner, &out.Owner
		*out = new(genruntime.KnownResourceReference)
		**out = **in
	}
	if in.PTRRecords != nil {
		in, out := &in.PTRRecords, &out.PTRRecords
		*out = make([]PtrRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SOARecord != nil {
		in, out := &in.SOARecord, &out.SOARecord
		*out = new(SoaRecord)
		(*in).DeepCopyInto(*out)
	}
	if in.SRVRecords != nil {
		in, out := &in.SRVRecords, &out.SRVRecords
		*out = make([]SrvRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TTL != nil {
		in, out := &in.TTL, &out.TTL
		*out = new(int)
		**out = **in
	}
	if in.TXTRecords != nil {
		in, out := &in.TXTRecords, &out.TXTRecords
		*out = make([]TxtRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TargetResource != nil {
		in, out := &in.TargetResource, &out.TargetResource
		*out = new(SubResource)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesAAAARecord_Spec.
func (in *DnsZonesAAAARecord_Spec) DeepCopy() *DnsZonesAAAARecord_Spec {
	if in == nil {
		return nil
	}
	out := new(DnsZonesAAAARecord_Spec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesARecord) DeepCopyInto(out *DnsZonesARecord) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesARecord.
func (in *DnsZonesARecord) DeepCopy() *DnsZonesARecord {
	if in == nil {
		return nil
	}
	out := new(DnsZonesARecord)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *DnsZonesARecord) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesARecordList) DeepCopyInto(out *DnsZonesARecordList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]DnsZonesARecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesARecordList.
func (in *DnsZonesARecordList) DeepCopy() *DnsZonesARecordList {
	if in == nil {
		return nil
	}
	out := new(DnsZonesARecordList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *DnsZonesARecordList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesARecordOperatorSpec) DeepCopyInto(out *DnsZonesARecordOperatorSpec) {
	*out = *in
	if in.ConfigMapExpressions != nil {
		in, out := &in.ConfigMapExpressions, &out.ConfigMapExpressions
		*out = make([]*core.DestinationExpression, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(core.DestinationExpression)
				**out = **in
			}
		}
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SecretExpressions != nil {
		in, out := &in.SecretExpressions, &out.SecretExpressions
		*out = make([]*core.DestinationExpression, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(core.DestinationExpression)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesARecordOperatorSpec.
func (in *DnsZonesARecordOperatorSpec) DeepCopy() *DnsZonesARecordOperatorSpec {
	if in == nil {
		return nil
	}
	out := new(DnsZonesARecordOperatorSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesARecord_STATUS) DeepCopyInto(out *DnsZonesARecord_STATUS) {
	*out = *in
	if in.AAAARecords != nil {
		in, out := &in.AAAARecords, &out.AAAARecords
		*out = make([]AaaaRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ARecords != nil {
		in, out := &in.ARecords, &out.ARecords
		*out = make([]ARecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.CNAMERecord != nil {
		in, out := &in.CNAMERecord, &out.CNAMERecord
		*out = new(CnameRecord_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.CaaRecords != nil {
		in, out := &in.CaaRecords, &out.CaaRecords
		*out = make([]CaaRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]conditions.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Etag != nil {
		in, out := &in.Etag, &out.Etag
		*out = new(string)
		**out = **in
	}
	if in.Fqdn != nil {
		in, out := &in.Fqdn, &out.Fqdn
		*out = new(string)
		**out = **in
	}
	if in.Id != nil {
		in, out := &in.Id, &out.Id
		*out = new(string)
		**out = **in
	}
	if in.MXRecords != nil {
		in, out := &in.MXRecords, &out.MXRecords
		*out = make([]MxRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Metadata != nil {
		in, out := &in.Metadata, &out.Metadata
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.NSRecords != nil {
		in, out := &in.NSRecords, &out.NSRecords
		*out = make([]NsRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PTRRecords != nil {
		in, out := &in.PTRRecords, &out.PTRRecords
		*out = make([]PtrRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ProvisioningState != nil {
		in, out := &in.ProvisioningState, &out.ProvisioningState
		*out = new(string)
		**out = **in
	}
	if in.SOARecord != nil {
		in, out := &in.SOARecord, &out.SOARecord
		*out = new(SoaRecord_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.SRVRecords != nil {
		in, out := &in.SRVRecords, &out.SRVRecords
		*out = make([]SrvRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TTL != nil {
		in, out := &in.TTL, &out.TTL
		*out = new(int)
		**out = **in
	}
	if in.TXTRecords != nil {
		in, out := &in.TXTRecords, &out.TXTRecords
		*out = make([]TxtRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TargetResource != nil {
		in, out := &in.TargetResource, &out.TargetResource
		*out = new(SubResource_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesARecord_STATUS.
func (in *DnsZonesARecord_STATUS) DeepCopy() *DnsZonesARecord_STATUS {
	if in == nil {
		return nil
	}
	out := new(DnsZonesARecord_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesARecord_Spec) DeepCopyInto(out *DnsZonesARecord_Spec) {
	*out = *in
	if in.AAAARecords != nil {
		in, out := &in.AAAARecords, &out.AAAARecords
		*out = make([]AaaaRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ARecords != nil {
		in, out := &in.ARecords, &out.ARecords
		*out = make([]ARecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.CNAMERecord != nil {
		in, out := &in.CNAMERecord, &out.CNAMERecord
		*out = new(CnameRecord)
		(*in).DeepCopyInto(*out)
	}
	if in.CaaRecords != nil {
		in, out := &in.CaaRecords, &out.CaaRecords
		*out = make([]CaaRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Etag != nil {
		in, out := &in.Etag, &out.Etag
		*out = new(string)
		**out = **in
	}
	if in.MXRecords != nil {
		in, out := &in.MXRecords, &out.MXRecords
		*out = make([]MxRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Metadata != nil {
		in, out := &in.Metadata, &out.Metadata
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.NSRecords != nil {
		in, out := &in.NSRecords, &out.NSRecords
		*out = make([]NsRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.OperatorSpec != nil {
		in, out := &in.OperatorSpec, &out.OperatorSpec
		*out = new(DnsZonesARecordOperatorSpec)
		(*in).DeepCopyInto(*out)
	}
	if in.Owner != nil {
		in, out := &in.Owner, &out.Owner
		*out = new(genruntime.KnownResourceReference)
		**out = **in
	}
	if in.PTRRecords != nil {
		in, out := &in.PTRRecords, &out.PTRRecords
		*out = make([]PtrRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SOARecord != nil {
		in, out := &in.SOARecord, &out.SOARecord
		*out = new(SoaRecord)
		(*in).DeepCopyInto(*out)
	}
	if in.SRVRecords != nil {
		in, out := &in.SRVRecords, &out.SRVRecords
		*out = make([]SrvRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TTL != nil {
		in, out := &in.TTL, &out.TTL
		*out = new(int)
		**out = **in
	}
	if in.TXTRecords != nil {
		in, out := &in.TXTRecords, &out.TXTRecords
		*out = make([]TxtRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TargetResource != nil {
		in, out := &in.TargetResource, &out.TargetResource
		*out = new(SubResource)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesARecord_Spec.
func (in *DnsZonesARecord_Spec) DeepCopy() *DnsZonesARecord_Spec {
	if in == nil {
		return nil
	}
	out := new(DnsZonesARecord_Spec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesCAARecord) DeepCopyInto(out *DnsZonesCAARecord) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesCAARecord.
func (in *DnsZonesCAARecord) DeepCopy() *DnsZonesCAARecord {
	if in == nil {
		return nil
	}
	out := new(DnsZonesCAARecord)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *DnsZonesCAARecord) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesCAARecordList) DeepCopyInto(out *DnsZonesCAARecordList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]DnsZonesCAARecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesCAARecordList.
func (in *DnsZonesCAARecordList) DeepCopy() *DnsZonesCAARecordList {
	if in == nil {
		return nil
	}
	out := new(DnsZonesCAARecordList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *DnsZonesCAARecordList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesCAARecordOperatorSpec) DeepCopyInto(out *DnsZonesCAARecordOperatorSpec) {
	*out = *in
	if in.ConfigMapExpressions != nil {
		in, out := &in.ConfigMapExpressions, &out.ConfigMapExpressions
		*out = make([]*core.DestinationExpression, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(core.DestinationExpression)
				**out = **in
			}
		}
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SecretExpressions != nil {
		in, out := &in.SecretExpressions, &out.SecretExpressions
		*out = make([]*core.DestinationExpression, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(core.DestinationExpression)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesCAARecordOperatorSpec.
func (in *DnsZonesCAARecordOperatorSpec) DeepCopy() *DnsZonesCAARecordOperatorSpec {
	if in == nil {
		return nil
	}
	out := new(DnsZonesCAARecordOperatorSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesCAARecord_STATUS) DeepCopyInto(out *DnsZonesCAARecord_STATUS) {
	*out = *in
	if in.AAAARecords != nil {
		in, out := &in.AAAARecords, &out.AAAARecords
		*out = make([]AaaaRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ARecords != nil {
		in, out := &in.ARecords, &out.ARecords
		*out = make([]ARecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.CNAMERecord != nil {
		in, out := &in.CNAMERecord, &out.CNAMERecord
		*out = new(CnameRecord_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.CaaRecords != nil {
		in, out := &in.CaaRecords, &out.CaaRecords
		*out = make([]CaaRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]conditions.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Etag != nil {
		in, out := &in.Etag, &out.Etag
		*out = new(string)
		**out = **in
	}
	if in.Fqdn != nil {
		in, out := &in.Fqdn, &out.Fqdn
		*out = new(string)
		**out = **in
	}
	if in.Id != nil {
		in, out := &in.Id, &out.Id
		*out = new(string)
		**out = **in
	}
	if in.MXRecords != nil {
		in, out := &in.MXRecords, &out.MXRecords
		*out = make([]MxRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Metadata != nil {
		in, out := &in.Metadata, &out.Metadata
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.NSRecords != nil {
		in, out := &in.NSRecords, &out.NSRecords
		*out = make([]NsRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PTRRecords != nil {
		in, out := &in.PTRRecords, &out.PTRRecords
		*out = make([]PtrRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ProvisioningState != nil {
		in, out := &in.ProvisioningState, &out.ProvisioningState
		*out = new(string)
		**out = **in
	}
	if in.SOARecord != nil {
		in, out := &in.SOARecord, &out.SOARecord
		*out = new(SoaRecord_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.SRVRecords != nil {
		in, out := &in.SRVRecords, &out.SRVRecords
		*out = make([]SrvRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TTL != nil {
		in, out := &in.TTL, &out.TTL
		*out = new(int)
		**out = **in
	}
	if in.TXTRecords != nil {
		in, out := &in.TXTRecords, &out.TXTRecords
		*out = make([]TxtRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TargetResource != nil {
		in, out := &in.TargetResource, &out.TargetResource
		*out = new(SubResource_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesCAARecord_STATUS.
func (in *DnsZonesCAARecord_STATUS) DeepCopy() *DnsZonesCAARecord_STATUS {
	if in == nil {
		return nil
	}
	out := new(DnsZonesCAARecord_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesCAARecord_Spec) DeepCopyInto(out *DnsZonesCAARecord_Spec) {
	*out = *in
	if in.AAAARecords != nil {
		in, out := &in.AAAARecords, &out.AAAARecords
		*out = make([]AaaaRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ARecords != nil {
		in, out := &in.ARecords, &out.ARecords
		*out = make([]ARecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.CNAMERecord != nil {
		in, out := &in.CNAMERecord, &out.CNAMERecord
		*out = new(CnameRecord)
		(*in).DeepCopyInto(*out)
	}
	if in.CaaRecords != nil {
		in, out := &in.CaaRecords, &out.CaaRecords
		*out = make([]CaaRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MXRecords != nil {
		in, out := &in.MXRecords, &out.MXRecords
		*out = make([]MxRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Metadata != nil {
		in, out := &in.Metadata, &out.Metadata
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.NSRecords != nil {
		in, out := &in.NSRecords, &out.NSRecords
		*out = make([]NsRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.OperatorSpec != nil {
		in, out := &in.OperatorSpec, &out.OperatorSpec
		*out = new(DnsZonesCAARecordOperatorSpec)
		(*in).DeepCopyInto(*out)
	}
	if in.Owner != nil {
		in, out := &in.Owner, &out.Owner
		*out = new(genruntime.KnownResourceReference)
		**out = **in
	}
	if in.PTRRecords != nil {
		in, out := &in.PTRRecords, &out.PTRRecords
		*out = make([]PtrRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SOARecord != nil {
		in, out := &in.SOARecord, &out.SOARecord
		*out = new(SoaRecord)
		(*in).DeepCopyInto(*out)
	}
	if in.SRVRecords != nil {
		in, out := &in.SRVRecords, &out.SRVRecords
		*out = make([]SrvRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TTL != nil {
		in, out := &in.TTL, &out.TTL
		*out = new(int)
		**out = **in
	}
	if in.TXTRecords != nil {
		in, out := &in.TXTRecords, &out.TXTRecords
		*out = make([]TxtRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TargetResource != nil {
		in, out := &in.TargetResource, &out.TargetResource
		*out = new(SubResource)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesCAARecord_Spec.
func (in *DnsZonesCAARecord_Spec) DeepCopy() *DnsZonesCAARecord_Spec {
	if in == nil {
		return nil
	}
	out := new(DnsZonesCAARecord_Spec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesCNAMERecord) DeepCopyInto(out *DnsZonesCNAMERecord) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesCNAMERecord.
func (in *DnsZonesCNAMERecord) DeepCopy() *DnsZonesCNAMERecord {
	if in == nil {
		return nil
	}
	out := new(DnsZonesCNAMERecord)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *DnsZonesCNAMERecord) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesCNAMERecordList) DeepCopyInto(out *DnsZonesCNAMERecordList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]DnsZonesCNAMERecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesCNAMERecordList.
func (in *DnsZonesCNAMERecordList) DeepCopy() *DnsZonesCNAMERecordList {
	if in == nil {
		return nil
	}
	out := new(DnsZonesCNAMERecordList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *DnsZonesCNAMERecordList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesCNAMERecordOperatorSpec) DeepCopyInto(out *DnsZonesCNAMERecordOperatorSpec) {
	*out = *in
	if in.ConfigMapExpressions != nil {
		in, out := &in.ConfigMapExpressions, &out.ConfigMapExpressions
		*out = make([]*core.DestinationExpression, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(core.DestinationExpression)
				**out = **in
			}
		}
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SecretExpressions != nil {
		in, out := &in.SecretExpressions, &out.SecretExpressions
		*out = make([]*core.DestinationExpression, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(core.DestinationExpression)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesCNAMERecordOperatorSpec.
func (in *DnsZonesCNAMERecordOperatorSpec) DeepCopy() *DnsZonesCNAMERecordOperatorSpec {
	if in == nil {
		return nil
	}
	out := new(DnsZonesCNAMERecordOperatorSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesCNAMERecord_STATUS) DeepCopyInto(out *DnsZonesCNAMERecord_STATUS) {
	*out = *in
	if in.AAAARecords != nil {
		in, out := &in.AAAARecords, &out.AAAARecords
		*out = make([]AaaaRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ARecords != nil {
		in, out := &in.ARecords, &out.ARecords
		*out = make([]ARecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.CNAMERecord != nil {
		in, out := &in.CNAMERecord, &out.CNAMERecord
		*out = new(CnameRecord_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.CaaRecords != nil {
		in, out := &in.CaaRecords, &out.CaaRecords
		*out = make([]CaaRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]conditions.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Etag != nil {
		in, out := &in.Etag, &out.Etag
		*out = new(string)
		**out = **in
	}
	if in.Fqdn != nil {
		in, out := &in.Fqdn, &out.Fqdn
		*out = new(string)
		**out = **in
	}
	if in.Id != nil {
		in, out := &in.Id, &out.Id
		*out = new(string)
		**out = **in
	}
	if in.MXRecords != nil {
		in, out := &in.MXRecords, &out.MXRecords
		*out = make([]MxRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Metadata != nil {
		in, out := &in.Metadata, &out.Metadata
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.NSRecords != nil {
		in, out := &in.NSRecords, &out.NSRecords
		*out = make([]NsRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PTRRecords != nil {
		in, out := &in.PTRRecords, &out.PTRRecords
		*out = make([]PtrRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ProvisioningState != nil {
		in, out := &in.ProvisioningState, &out.ProvisioningState
		*out = new(string)
		**out = **in
	}
	if in.SOARecord != nil {
		in, out := &in.SOARecord, &out.SOARecord
		*out = new(SoaRecord_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.SRVRecords != nil {
		in, out := &in.SRVRecords, &out.SRVRecords
		*out = make([]SrvRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TTL != nil {
		in, out := &in.TTL, &out.TTL
		*out = new(int)
		**out = **in
	}
	if in.TXTRecords != nil {
		in, out := &in.TXTRecords, &out.TXTRecords
		*out = make([]TxtRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TargetResource != nil {
		in, out := &in.TargetResource, &out.TargetResource
		*out = new(SubResource_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesCNAMERecord_STATUS.
func (in *DnsZonesCNAMERecord_STATUS) DeepCopy() *DnsZonesCNAMERecord_STATUS {
	if in == nil {
		return nil
	}
	out := new(DnsZonesCNAMERecord_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesCNAMERecord_Spec) DeepCopyInto(out *DnsZonesCNAMERecord_Spec) {
	*out = *in
	if in.AAAARecords != nil {
		in, out := &in.AAAARecords, &out.AAAARecords
		*out = make([]AaaaRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ARecords != nil {
		in, out := &in.ARecords, &out.ARecords
		*out = make([]ARecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.CNAMERecord != nil {
		in, out := &in.CNAMERecord, &out.CNAMERecord
		*out = new(CnameRecord)
		(*in).DeepCopyInto(*out)
	}
	if in.CaaRecords != nil {
		in, out := &in.CaaRecords, &out.CaaRecords
		*out = make([]CaaRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MXRecords != nil {
		in, out := &in.MXRecords, &out.MXRecords
		*out = make([]MxRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Metadata != nil {
		in, out := &in.Metadata, &out.Metadata
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.NSRecords != nil {
		in, out := &in.NSRecords, &out.NSRecords
		*out = make([]NsRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.OperatorSpec != nil {
		in, out := &in.OperatorSpec, &out.OperatorSpec
		*out = new(DnsZonesCNAMERecordOperatorSpec)
		(*in).DeepCopyInto(*out)
	}
	if in.Owner != nil {
		in, out := &in.Owner, &out.Owner
		*out = new(genruntime.KnownResourceReference)
		**out = **in
	}
	if in.PTRRecords != nil {
		in, out := &in.PTRRecords, &out.PTRRecords
		*out = make([]PtrRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SOARecord != nil {
		in, out := &in.SOARecord, &out.SOARecord
		*out = new(SoaRecord)
		(*in).DeepCopyInto(*out)
	}
	if in.SRVRecords != nil {
		in, out := &in.SRVRecords, &out.SRVRecords
		*out = make([]SrvRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TTL != nil {
		in, out := &in.TTL, &out.TTL
		*out = new(int)
		**out = **in
	}
	if in.TXTRecords != nil {
		in, out := &in.TXTRecords, &out.TXTRecords
		*out = make([]TxtRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TargetResource != nil {
		in, out := &in.TargetResource, &out.TargetResource
		*out = new(SubResource)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesCNAMERecord_Spec.
func (in *DnsZonesCNAMERecord_Spec) DeepCopy() *DnsZonesCNAMERecord_Spec {
	if in == nil {
		return nil
	}
	out := new(DnsZonesCNAMERecord_Spec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesMXRecord) DeepCopyInto(out *DnsZonesMXRecord) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesMXRecord.
func (in *DnsZonesMXRecord) DeepCopy() *DnsZonesMXRecord {
	if in == nil {
		return nil
	}
	out := new(DnsZonesMXRecord)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *DnsZonesMXRecord) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesMXRecordList) DeepCopyInto(out *DnsZonesMXRecordList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]DnsZonesMXRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesMXRecordList.
func (in *DnsZonesMXRecordList) DeepCopy() *DnsZonesMXRecordList {
	if in == nil {
		return nil
	}
	out := new(DnsZonesMXRecordList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *DnsZonesMXRecordList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesMXRecordOperatorSpec) DeepCopyInto(out *DnsZonesMXRecordOperatorSpec) {
	*out = *in
	if in.ConfigMapExpressions != nil {
		in, out := &in.ConfigMapExpressions, &out.ConfigMapExpressions
		*out = make([]*core.DestinationExpression, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(core.DestinationExpression)
				**out = **in
			}
		}
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SecretExpressions != nil {
		in, out := &in.SecretExpressions, &out.SecretExpressions
		*out = make([]*core.DestinationExpression, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(core.DestinationExpression)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesMXRecordOperatorSpec.
func (in *DnsZonesMXRecordOperatorSpec) DeepCopy() *DnsZonesMXRecordOperatorSpec {
	if in == nil {
		return nil
	}
	out := new(DnsZonesMXRecordOperatorSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesMXRecord_STATUS) DeepCopyInto(out *DnsZonesMXRecord_STATUS) {
	*out = *in
	if in.AAAARecords != nil {
		in, out := &in.AAAARecords, &out.AAAARecords
		*out = make([]AaaaRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ARecords != nil {
		in, out := &in.ARecords, &out.ARecords
		*out = make([]ARecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.CNAMERecord != nil {
		in, out := &in.CNAMERecord, &out.CNAMERecord
		*out = new(CnameRecord_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.CaaRecords != nil {
		in, out := &in.CaaRecords, &out.CaaRecords
		*out = make([]CaaRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]conditions.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Etag != nil {
		in, out := &in.Etag, &out.Etag
		*out = new(string)
		**out = **in
	}
	if in.Fqdn != nil {
		in, out := &in.Fqdn, &out.Fqdn
		*out = new(string)
		**out = **in
	}
	if in.Id != nil {
		in, out := &in.Id, &out.Id
		*out = new(string)
		**out = **in
	}
	if in.MXRecords != nil {
		in, out := &in.MXRecords, &out.MXRecords
		*out = make([]MxRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Metadata != nil {
		in, out := &in.Metadata, &out.Metadata
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.NSRecords != nil {
		in, out := &in.NSRecords, &out.NSRecords
		*out = make([]NsRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PTRRecords != nil {
		in, out := &in.PTRRecords, &out.PTRRecords
		*out = make([]PtrRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ProvisioningState != nil {
		in, out := &in.ProvisioningState, &out.ProvisioningState
		*out = new(string)
		**out = **in
	}
	if in.SOARecord != nil {
		in, out := &in.SOARecord, &out.SOARecord
		*out = new(SoaRecord_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.SRVRecords != nil {
		in, out := &in.SRVRecords, &out.SRVRecords
		*out = make([]SrvRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TTL != nil {
		in, out := &in.TTL, &out.TTL
		*out = new(int)
		**out = **in
	}
	if in.TXTRecords != nil {
		in, out := &in.TXTRecords, &out.TXTRecords
		*out = make([]TxtRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TargetResource != nil {
		in, out := &in.TargetResource, &out.TargetResource
		*out = new(SubResource_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesMXRecord_STATUS.
func (in *DnsZonesMXRecord_STATUS) DeepCopy() *DnsZonesMXRecord_STATUS {
	if in == nil {
		return nil
	}
	out := new(DnsZonesMXRecord_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesMXRecord_Spec) DeepCopyInto(out *DnsZonesMXRecord_Spec) {
	*out = *in
	if in.AAAARecords != nil {
		in, out := &in.AAAARecords, &out.AAAARecords
		*out = make([]AaaaRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ARecords != nil {
		in, out := &in.ARecords, &out.ARecords
		*out = make([]ARecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.CNAMERecord != nil {
		in, out := &in.CNAMERecord, &out.CNAMERecord
		*out = new(CnameRecord)
		(*in).DeepCopyInto(*out)
	}
	if in.CaaRecords != nil {
		in, out := &in.CaaRecords, &out.CaaRecords
		*out = make([]CaaRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MXRecords != nil {
		in, out := &in.MXRecords, &out.MXRecords
		*out = make([]MxRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Metadata != nil {
		in, out := &in.Metadata, &out.Metadata
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.NSRecords != nil {
		in, out := &in.NSRecords, &out.NSRecords
		*out = make([]NsRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.OperatorSpec != nil {
		in, out := &in.OperatorSpec, &out.OperatorSpec
		*out = new(DnsZonesMXRecordOperatorSpec)
		(*in).DeepCopyInto(*out)
	}
	if in.Owner != nil {
		in, out := &in.Owner, &out.Owner
		*out = new(genruntime.KnownResourceReference)
		**out = **in
	}
	if in.PTRRecords != nil {
		in, out := &in.PTRRecords, &out.PTRRecords
		*out = make([]PtrRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SOARecord != nil {
		in, out := &in.SOARecord, &out.SOARecord
		*out = new(SoaRecord)
		(*in).DeepCopyInto(*out)
	}
	if in.SRVRecords != nil {
		in, out := &in.SRVRecords, &out.SRVRecords
		*out = make([]SrvRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TTL != nil {
		in, out := &in.TTL, &out.TTL
		*out = new(int)
		**out = **in
	}
	if in.TXTRecords != nil {
		in, out := &in.TXTRecords, &out.TXTRecords
		*out = make([]TxtRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TargetResource != nil {
		in, out := &in.TargetResource, &out.TargetResource
		*out = new(SubResource)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesMXRecord_Spec.
func (in *DnsZonesMXRecord_Spec) DeepCopy() *DnsZonesMXRecord_Spec {
	if in == nil {
		return nil
	}
	out := new(DnsZonesMXRecord_Spec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesNSRecord) DeepCopyInto(out *DnsZonesNSRecord) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesNSRecord.
func (in *DnsZonesNSRecord) DeepCopy() *DnsZonesNSRecord {
	if in == nil {
		return nil
	}
	out := new(DnsZonesNSRecord)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *DnsZonesNSRecord) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesNSRecordList) DeepCopyInto(out *DnsZonesNSRecordList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]DnsZonesNSRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesNSRecordList.
func (in *DnsZonesNSRecordList) DeepCopy() *DnsZonesNSRecordList {
	if in == nil {
		return nil
	}
	out := new(DnsZonesNSRecordList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *DnsZonesNSRecordList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesNSRecordOperatorSpec) DeepCopyInto(out *DnsZonesNSRecordOperatorSpec) {
	*out = *in
	if in.ConfigMapExpressions != nil {
		in, out := &in.ConfigMapExpressions, &out.ConfigMapExpressions
		*out = make([]*core.DestinationExpression, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(core.DestinationExpression)
				**out = **in
			}
		}
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SecretExpressions != nil {
		in, out := &in.SecretExpressions, &out.SecretExpressions
		*out = make([]*core.DestinationExpression, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(core.DestinationExpression)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesNSRecordOperatorSpec.
func (in *DnsZonesNSRecordOperatorSpec) DeepCopy() *DnsZonesNSRecordOperatorSpec {
	if in == nil {
		return nil
	}
	out := new(DnsZonesNSRecordOperatorSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesNSRecord_STATUS) DeepCopyInto(out *DnsZonesNSRecord_STATUS) {
	*out = *in
	if in.AAAARecords != nil {
		in, out := &in.AAAARecords, &out.AAAARecords
		*out = make([]AaaaRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ARecords != nil {
		in, out := &in.ARecords, &out.ARecords
		*out = make([]ARecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.CNAMERecord != nil {
		in, out := &in.CNAMERecord, &out.CNAMERecord
		*out = new(CnameRecord_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.CaaRecords != nil {
		in, out := &in.CaaRecords, &out.CaaRecords
		*out = make([]CaaRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]conditions.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Etag != nil {
		in, out := &in.Etag, &out.Etag
		*out = new(string)
		**out = **in
	}
	if in.Fqdn != nil {
		in, out := &in.Fqdn, &out.Fqdn
		*out = new(string)
		**out = **in
	}
	if in.Id != nil {
		in, out := &in.Id, &out.Id
		*out = new(string)
		**out = **in
	}
	if in.MXRecords != nil {
		in, out := &in.MXRecords, &out.MXRecords
		*out = make([]MxRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Metadata != nil {
		in, out := &in.Metadata, &out.Metadata
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.NSRecords != nil {
		in, out := &in.NSRecords, &out.NSRecords
		*out = make([]NsRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PTRRecords != nil {
		in, out := &in.PTRRecords, &out.PTRRecords
		*out = make([]PtrRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ProvisioningState != nil {
		in, out := &in.ProvisioningState, &out.ProvisioningState
		*out = new(string)
		**out = **in
	}
	if in.SOARecord != nil {
		in, out := &in.SOARecord, &out.SOARecord
		*out = new(SoaRecord_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.SRVRecords != nil {
		in, out := &in.SRVRecords, &out.SRVRecords
		*out = make([]SrvRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TTL != nil {
		in, out := &in.TTL, &out.TTL
		*out = new(int)
		**out = **in
	}
	if in.TXTRecords != nil {
		in, out := &in.TXTRecords, &out.TXTRecords
		*out = make([]TxtRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TargetResource != nil {
		in, out := &in.TargetResource, &out.TargetResource
		*out = new(SubResource_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesNSRecord_STATUS.
func (in *DnsZonesNSRecord_STATUS) DeepCopy() *DnsZonesNSRecord_STATUS {
	if in == nil {
		return nil
	}
	out := new(DnsZonesNSRecord_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesNSRecord_Spec) DeepCopyInto(out *DnsZonesNSRecord_Spec) {
	*out = *in
	if in.AAAARecords != nil {
		in, out := &in.AAAARecords, &out.AAAARecords
		*out = make([]AaaaRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ARecords != nil {
		in, out := &in.ARecords, &out.ARecords
		*out = make([]ARecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.CNAMERecord != nil {
		in, out := &in.CNAMERecord, &out.CNAMERecord
		*out = new(CnameRecord)
		(*in).DeepCopyInto(*out)
	}
	if in.CaaRecords != nil {
		in, out := &in.CaaRecords, &out.CaaRecords
		*out = make([]CaaRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MXRecords != nil {
		in, out := &in.MXRecords, &out.MXRecords
		*out = make([]MxRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Metadata != nil {
		in, out := &in.Metadata, &out.Metadata
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.NSRecords != nil {
		in, out := &in.NSRecords, &out.NSRecords
		*out = make([]NsRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.OperatorSpec != nil {
		in, out := &in.OperatorSpec, &out.OperatorSpec
		*out = new(DnsZonesNSRecordOperatorSpec)
		(*in).DeepCopyInto(*out)
	}
	if in.Owner != nil {
		in, out := &in.Owner, &out.Owner
		*out = new(genruntime.KnownResourceReference)
		**out = **in
	}
	if in.PTRRecords != nil {
		in, out := &in.PTRRecords, &out.PTRRecords
		*out = make([]PtrRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SOARecord != nil {
		in, out := &in.SOARecord, &out.SOARecord
		*out = new(SoaRecord)
		(*in).DeepCopyInto(*out)
	}
	if in.SRVRecords != nil {
		in, out := &in.SRVRecords, &out.SRVRecords
		*out = make([]SrvRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TTL != nil {
		in, out := &in.TTL, &out.TTL
		*out = new(int)
		**out = **in
	}
	if in.TXTRecords != nil {
		in, out := &in.TXTRecords, &out.TXTRecords
		*out = make([]TxtRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TargetResource != nil {
		in, out := &in.TargetResource, &out.TargetResource
		*out = new(SubResource)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesNSRecord_Spec.
func (in *DnsZonesNSRecord_Spec) DeepCopy() *DnsZonesNSRecord_Spec {
	if in == nil {
		return nil
	}
	out := new(DnsZonesNSRecord_Spec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesPTRRecord) DeepCopyInto(out *DnsZonesPTRRecord) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesPTRRecord.
func (in *DnsZonesPTRRecord) DeepCopy() *DnsZonesPTRRecord {
	if in == nil {
		return nil
	}
	out := new(DnsZonesPTRRecord)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *DnsZonesPTRRecord) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesPTRRecordList) DeepCopyInto(out *DnsZonesPTRRecordList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]DnsZonesPTRRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesPTRRecordList.
func (in *DnsZonesPTRRecordList) DeepCopy() *DnsZonesPTRRecordList {
	if in == nil {
		return nil
	}
	out := new(DnsZonesPTRRecordList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *DnsZonesPTRRecordList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesPTRRecordOperatorSpec) DeepCopyInto(out *DnsZonesPTRRecordOperatorSpec) {
	*out = *in
	if in.ConfigMapExpressions != nil {
		in, out := &in.ConfigMapExpressions, &out.ConfigMapExpressions
		*out = make([]*core.DestinationExpression, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(core.DestinationExpression)
				**out = **in
			}
		}
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SecretExpressions != nil {
		in, out := &in.SecretExpressions, &out.SecretExpressions
		*out = make([]*core.DestinationExpression, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(core.DestinationExpression)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesPTRRecordOperatorSpec.
func (in *DnsZonesPTRRecordOperatorSpec) DeepCopy() *DnsZonesPTRRecordOperatorSpec {
	if in == nil {
		return nil
	}
	out := new(DnsZonesPTRRecordOperatorSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesPTRRecord_STATUS) DeepCopyInto(out *DnsZonesPTRRecord_STATUS) {
	*out = *in
	if in.AAAARecords != nil {
		in, out := &in.AAAARecords, &out.AAAARecords
		*out = make([]AaaaRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ARecords != nil {
		in, out := &in.ARecords, &out.ARecords
		*out = make([]ARecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.CNAMERecord != nil {
		in, out := &in.CNAMERecord, &out.CNAMERecord
		*out = new(CnameRecord_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.CaaRecords != nil {
		in, out := &in.CaaRecords, &out.CaaRecords
		*out = make([]CaaRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]conditions.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Etag != nil {
		in, out := &in.Etag, &out.Etag
		*out = new(string)
		**out = **in
	}
	if in.Fqdn != nil {
		in, out := &in.Fqdn, &out.Fqdn
		*out = new(string)
		**out = **in
	}
	if in.Id != nil {
		in, out := &in.Id, &out.Id
		*out = new(string)
		**out = **in
	}
	if in.MXRecords != nil {
		in, out := &in.MXRecords, &out.MXRecords
		*out = make([]MxRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Metadata != nil {
		in, out := &in.Metadata, &out.Metadata
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.NSRecords != nil {
		in, out := &in.NSRecords, &out.NSRecords
		*out = make([]NsRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PTRRecords != nil {
		in, out := &in.PTRRecords, &out.PTRRecords
		*out = make([]PtrRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ProvisioningState != nil {
		in, out := &in.ProvisioningState, &out.ProvisioningState
		*out = new(string)
		**out = **in
	}
	if in.SOARecord != nil {
		in, out := &in.SOARecord, &out.SOARecord
		*out = new(SoaRecord_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.SRVRecords != nil {
		in, out := &in.SRVRecords, &out.SRVRecords
		*out = make([]SrvRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TTL != nil {
		in, out := &in.TTL, &out.TTL
		*out = new(int)
		**out = **in
	}
	if in.TXTRecords != nil {
		in, out := &in.TXTRecords, &out.TXTRecords
		*out = make([]TxtRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TargetResource != nil {
		in, out := &in.TargetResource, &out.TargetResource
		*out = new(SubResource_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesPTRRecord_STATUS.
func (in *DnsZonesPTRRecord_STATUS) DeepCopy() *DnsZonesPTRRecord_STATUS {
	if in == nil {
		return nil
	}
	out := new(DnsZonesPTRRecord_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesPTRRecord_Spec) DeepCopyInto(out *DnsZonesPTRRecord_Spec) {
	*out = *in
	if in.AAAARecords != nil {
		in, out := &in.AAAARecords, &out.AAAARecords
		*out = make([]AaaaRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ARecords != nil {
		in, out := &in.ARecords, &out.ARecords
		*out = make([]ARecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.CNAMERecord != nil {
		in, out := &in.CNAMERecord, &out.CNAMERecord
		*out = new(CnameRecord)
		(*in).DeepCopyInto(*out)
	}
	if in.CaaRecords != nil {
		in, out := &in.CaaRecords, &out.CaaRecords
		*out = make([]CaaRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MXRecords != nil {
		in, out := &in.MXRecords, &out.MXRecords
		*out = make([]MxRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Metadata != nil {
		in, out := &in.Metadata, &out.Metadata
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.NSRecords != nil {
		in, out := &in.NSRecords, &out.NSRecords
		*out = make([]NsRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.OperatorSpec != nil {
		in, out := &in.OperatorSpec, &out.OperatorSpec
		*out = new(DnsZonesPTRRecordOperatorSpec)
		(*in).DeepCopyInto(*out)
	}
	if in.Owner != nil {
		in, out := &in.Owner, &out.Owner
		*out = new(genruntime.KnownResourceReference)
		**out = **in
	}
	if in.PTRRecords != nil {
		in, out := &in.PTRRecords, &out.PTRRecords
		*out = make([]PtrRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SOARecord != nil {
		in, out := &in.SOARecord, &out.SOARecord
		*out = new(SoaRecord)
		(*in).DeepCopyInto(*out)
	}
	if in.SRVRecords != nil {
		in, out := &in.SRVRecords, &out.SRVRecords
		*out = make([]SrvRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TTL != nil {
		in, out := &in.TTL, &out.TTL
		*out = new(int)
		**out = **in
	}
	if in.TXTRecords != nil {
		in, out := &in.TXTRecords, &out.TXTRecords
		*out = make([]TxtRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TargetResource != nil {
		in, out := &in.TargetResource, &out.TargetResource
		*out = new(SubResource)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesPTRRecord_Spec.
func (in *DnsZonesPTRRecord_Spec) DeepCopy() *DnsZonesPTRRecord_Spec {
	if in == nil {
		return nil
	}
	out := new(DnsZonesPTRRecord_Spec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesSRVRecord) DeepCopyInto(out *DnsZonesSRVRecord) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesSRVRecord.
func (in *DnsZonesSRVRecord) DeepCopy() *DnsZonesSRVRecord {
	if in == nil {
		return nil
	}
	out := new(DnsZonesSRVRecord)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *DnsZonesSRVRecord) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesSRVRecordList) DeepCopyInto(out *DnsZonesSRVRecordList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]DnsZonesSRVRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesSRVRecordList.
func (in *DnsZonesSRVRecordList) DeepCopy() *DnsZonesSRVRecordList {
	if in == nil {
		return nil
	}
	out := new(DnsZonesSRVRecordList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *DnsZonesSRVRecordList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesSRVRecordOperatorSpec) DeepCopyInto(out *DnsZonesSRVRecordOperatorSpec) {
	*out = *in
	if in.ConfigMapExpressions != nil {
		in, out := &in.ConfigMapExpressions, &out.ConfigMapExpressions
		*out = make([]*core.DestinationExpression, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(core.DestinationExpression)
				**out = **in
			}
		}
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SecretExpressions != nil {
		in, out := &in.SecretExpressions, &out.SecretExpressions
		*out = make([]*core.DestinationExpression, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(core.DestinationExpression)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesSRVRecordOperatorSpec.
func (in *DnsZonesSRVRecordOperatorSpec) DeepCopy() *DnsZonesSRVRecordOperatorSpec {
	if in == nil {
		return nil
	}
	out := new(DnsZonesSRVRecordOperatorSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesSRVRecord_STATUS) DeepCopyInto(out *DnsZonesSRVRecord_STATUS) {
	*out = *in
	if in.AAAARecords != nil {
		in, out := &in.AAAARecords, &out.AAAARecords
		*out = make([]AaaaRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ARecords != nil {
		in, out := &in.ARecords, &out.ARecords
		*out = make([]ARecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.CNAMERecord != nil {
		in, out := &in.CNAMERecord, &out.CNAMERecord
		*out = new(CnameRecord_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.CaaRecords != nil {
		in, out := &in.CaaRecords, &out.CaaRecords
		*out = make([]CaaRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]conditions.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Etag != nil {
		in, out := &in.Etag, &out.Etag
		*out = new(string)
		**out = **in
	}
	if in.Fqdn != nil {
		in, out := &in.Fqdn, &out.Fqdn
		*out = new(string)
		**out = **in
	}
	if in.Id != nil {
		in, out := &in.Id, &out.Id
		*out = new(string)
		**out = **in
	}
	if in.MXRecords != nil {
		in, out := &in.MXRecords, &out.MXRecords
		*out = make([]MxRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Metadata != nil {
		in, out := &in.Metadata, &out.Metadata
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.NSRecords != nil {
		in, out := &in.NSRecords, &out.NSRecords
		*out = make([]NsRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PTRRecords != nil {
		in, out := &in.PTRRecords, &out.PTRRecords
		*out = make([]PtrRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ProvisioningState != nil {
		in, out := &in.ProvisioningState, &out.ProvisioningState
		*out = new(string)
		**out = **in
	}
	if in.SOARecord != nil {
		in, out := &in.SOARecord, &out.SOARecord
		*out = new(SoaRecord_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.SRVRecords != nil {
		in, out := &in.SRVRecords, &out.SRVRecords
		*out = make([]SrvRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TTL != nil {
		in, out := &in.TTL, &out.TTL
		*out = new(int)
		**out = **in
	}
	if in.TXTRecords != nil {
		in, out := &in.TXTRecords, &out.TXTRecords
		*out = make([]TxtRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TargetResource != nil {
		in, out := &in.TargetResource, &out.TargetResource
		*out = new(SubResource_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesSRVRecord_STATUS.
func (in *DnsZonesSRVRecord_STATUS) DeepCopy() *DnsZonesSRVRecord_STATUS {
	if in == nil {
		return nil
	}
	out := new(DnsZonesSRVRecord_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesSRVRecord_Spec) DeepCopyInto(out *DnsZonesSRVRecord_Spec) {
	*out = *in
	if in.AAAARecords != nil {
		in, out := &in.AAAARecords, &out.AAAARecords
		*out = make([]AaaaRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ARecords != nil {
		in, out := &in.ARecords, &out.ARecords
		*out = make([]ARecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.CNAMERecord != nil {
		in, out := &in.CNAMERecord, &out.CNAMERecord
		*out = new(CnameRecord)
		(*in).DeepCopyInto(*out)
	}
	if in.CaaRecords != nil {
		in, out := &in.CaaRecords, &out.CaaRecords
		*out = make([]CaaRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MXRecords != nil {
		in, out := &in.MXRecords, &out.MXRecords
		*out = make([]MxRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Metadata != nil {
		in, out := &in.Metadata, &out.Metadata
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.NSRecords != nil {
		in, out := &in.NSRecords, &out.NSRecords
		*out = make([]NsRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.OperatorSpec != nil {
		in, out := &in.OperatorSpec, &out.OperatorSpec
		*out = new(DnsZonesSRVRecordOperatorSpec)
		(*in).DeepCopyInto(*out)
	}
	if in.Owner != nil {
		in, out := &in.Owner, &out.Owner
		*out = new(genruntime.KnownResourceReference)
		**out = **in
	}
	if in.PTRRecords != nil {
		in, out := &in.PTRRecords, &out.PTRRecords
		*out = make([]PtrRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SOARecord != nil {
		in, out := &in.SOARecord, &out.SOARecord
		*out = new(SoaRecord)
		(*in).DeepCopyInto(*out)
	}
	if in.SRVRecords != nil {
		in, out := &in.SRVRecords, &out.SRVRecords
		*out = make([]SrvRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TTL != nil {
		in, out := &in.TTL, &out.TTL
		*out = new(int)
		**out = **in
	}
	if in.TXTRecords != nil {
		in, out := &in.TXTRecords, &out.TXTRecords
		*out = make([]TxtRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TargetResource != nil {
		in, out := &in.TargetResource, &out.TargetResource
		*out = new(SubResource)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesSRVRecord_Spec.
func (in *DnsZonesSRVRecord_Spec) DeepCopy() *DnsZonesSRVRecord_Spec {
	if in == nil {
		return nil
	}
	out := new(DnsZonesSRVRecord_Spec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesTXTRecord) DeepCopyInto(out *DnsZonesTXTRecord) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesTXTRecord.
func (in *DnsZonesTXTRecord) DeepCopy() *DnsZonesTXTRecord {
	if in == nil {
		return nil
	}
	out := new(DnsZonesTXTRecord)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *DnsZonesTXTRecord) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesTXTRecordList) DeepCopyInto(out *DnsZonesTXTRecordList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]DnsZonesTXTRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesTXTRecordList.
func (in *DnsZonesTXTRecordList) DeepCopy() *DnsZonesTXTRecordList {
	if in == nil {
		return nil
	}
	out := new(DnsZonesTXTRecordList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *DnsZonesTXTRecordList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesTXTRecordOperatorSpec) DeepCopyInto(out *DnsZonesTXTRecordOperatorSpec) {
	*out = *in
	if in.ConfigMapExpressions != nil {
		in, out := &in.ConfigMapExpressions, &out.ConfigMapExpressions
		*out = make([]*core.DestinationExpression, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(core.DestinationExpression)
				**out = **in
			}
		}
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SecretExpressions != nil {
		in, out := &in.SecretExpressions, &out.SecretExpressions
		*out = make([]*core.DestinationExpression, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(core.DestinationExpression)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesTXTRecordOperatorSpec.
func (in *DnsZonesTXTRecordOperatorSpec) DeepCopy() *DnsZonesTXTRecordOperatorSpec {
	if in == nil {
		return nil
	}
	out := new(DnsZonesTXTRecordOperatorSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesTXTRecord_STATUS) DeepCopyInto(out *DnsZonesTXTRecord_STATUS) {
	*out = *in
	if in.AAAARecords != nil {
		in, out := &in.AAAARecords, &out.AAAARecords
		*out = make([]AaaaRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ARecords != nil {
		in, out := &in.ARecords, &out.ARecords
		*out = make([]ARecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.CNAMERecord != nil {
		in, out := &in.CNAMERecord, &out.CNAMERecord
		*out = new(CnameRecord_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.CaaRecords != nil {
		in, out := &in.CaaRecords, &out.CaaRecords
		*out = make([]CaaRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]conditions.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Etag != nil {
		in, out := &in.Etag, &out.Etag
		*out = new(string)
		**out = **in
	}
	if in.Fqdn != nil {
		in, out := &in.Fqdn, &out.Fqdn
		*out = new(string)
		**out = **in
	}
	if in.Id != nil {
		in, out := &in.Id, &out.Id
		*out = new(string)
		**out = **in
	}
	if in.MXRecords != nil {
		in, out := &in.MXRecords, &out.MXRecords
		*out = make([]MxRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Metadata != nil {
		in, out := &in.Metadata, &out.Metadata
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.NSRecords != nil {
		in, out := &in.NSRecords, &out.NSRecords
		*out = make([]NsRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PTRRecords != nil {
		in, out := &in.PTRRecords, &out.PTRRecords
		*out = make([]PtrRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ProvisioningState != nil {
		in, out := &in.ProvisioningState, &out.ProvisioningState
		*out = new(string)
		**out = **in
	}
	if in.SOARecord != nil {
		in, out := &in.SOARecord, &out.SOARecord
		*out = new(SoaRecord_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.SRVRecords != nil {
		in, out := &in.SRVRecords, &out.SRVRecords
		*out = make([]SrvRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TTL != nil {
		in, out := &in.TTL, &out.TTL
		*out = new(int)
		**out = **in
	}
	if in.TXTRecords != nil {
		in, out := &in.TXTRecords, &out.TXTRecords
		*out = make([]TxtRecord_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TargetResource != nil {
		in, out := &in.TargetResource, &out.TargetResource
		*out = new(SubResource_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesTXTRecord_STATUS.
func (in *DnsZonesTXTRecord_STATUS) DeepCopy() *DnsZonesTXTRecord_STATUS {
	if in == nil {
		return nil
	}
	out := new(DnsZonesTXTRecord_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DnsZonesTXTRecord_Spec) DeepCopyInto(out *DnsZonesTXTRecord_Spec) {
	*out = *in
	if in.AAAARecords != nil {
		in, out := &in.AAAARecords, &out.AAAARecords
		*out = make([]AaaaRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ARecords != nil {
		in, out := &in.ARecords, &out.ARecords
		*out = make([]ARecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.CNAMERecord != nil {
		in, out := &in.CNAMERecord, &out.CNAMERecord
		*out = new(CnameRecord)
		(*in).DeepCopyInto(*out)
	}
	if in.CaaRecords != nil {
		in, out := &in.CaaRecords, &out.CaaRecords
		*out = make([]CaaRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.MXRecords != nil {
		in, out := &in.MXRecords, &out.MXRecords
		*out = make([]MxRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Metadata != nil {
		in, out := &in.Metadata, &out.Metadata
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.NSRecords != nil {
		in, out := &in.NSRecords, &out.NSRecords
		*out = make([]NsRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.OperatorSpec != nil {
		in, out := &in.OperatorSpec, &out.OperatorSpec
		*out = new(DnsZonesTXTRecordOperatorSpec)
		(*in).DeepCopyInto(*out)
	}
	if in.Owner != nil {
		in, out := &in.Owner, &out.Owner
		*out = new(genruntime.KnownResourceReference)
		**out = **in
	}
	if in.PTRRecords != nil {
		in, out := &in.PTRRecords, &out.PTRRecords
		*out = make([]PtrRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SOARecord != nil {
		in, out := &in.SOARecord, &out.SOARecord
		*out = new(SoaRecord)
		(*in).DeepCopyInto(*out)
	}
	if in.SRVRecords != nil {
		in, out := &in.SRVRecords, &out.SRVRecords
		*out = make([]SrvRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TTL != nil {
		in, out := &in.TTL, &out.TTL
		*out = new(int)
		**out = **in
	}
	if in.TXTRecords != nil {
		in, out := &in.TXTRecords, &out.TXTRecords
		*out = make([]TxtRecord, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.TargetResource != nil {
		in, out := &in.TargetResource, &out.TargetResource
		*out = new(SubResource)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DnsZonesTXTRecord_Spec.
func (in *DnsZonesTXTRecord_Spec) DeepCopy() *DnsZonesTXTRecord_Spec {
	if in == nil {
		return nil
	}
	out := new(DnsZonesTXTRecord_Spec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MxRecord) DeepCopyInto(out *MxRecord) {
	*out = *in
	if in.Exchange != nil {
		in, out := &in.Exchange, &out.Exchange
		*out = new(string)
		**out = **in
	}
	if in.Preference != nil {
		in, out := &in.Preference, &out.Preference
		*out = new(int)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MxRecord.
func (in *MxRecord) DeepCopy() *MxRecord {
	if in == nil {
		return nil
	}
	out := new(MxRecord)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MxRecord_STATUS) DeepCopyInto(out *MxRecord_STATUS) {
	*out = *in
	if in.Exchange != nil {
		in, out := &in.Exchange, &out.Exchange
		*out = new(string)
		**out = **in
	}
	if in.Preference != nil {
		in, out := &in.Preference, &out.Preference
		*out = new(int)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MxRecord_STATUS.
func (in *MxRecord_STATUS) DeepCopy() *MxRecord_STATUS {
	if in == nil {
		return nil
	}
	out := new(MxRecord_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NsRecord) DeepCopyInto(out *NsRecord) {
	*out = *in
	if in.Nsdname != nil {
		in, out := &in.Nsdname, &out.Nsdname
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NsRecord.
func (in *NsRecord) DeepCopy() *NsRecord {
	if in == nil {
		return nil
	}
	out := new(NsRecord)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NsRecord_STATUS) DeepCopyInto(out *NsRecord_STATUS) {
	*out = *in
	if in.Nsdname != nil {
		in, out := &in.Nsdname, &out.Nsdname
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NsRecord_STATUS.
func (in *NsRecord_STATUS) DeepCopy() *NsRecord_STATUS {
	if in == nil {
		return nil
	}
	out := new(NsRecord_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PtrRecord) DeepCopyInto(out *PtrRecord) {
	*out = *in
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Ptrdname != nil {
		in, out := &in.Ptrdname, &out.Ptrdname
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PtrRecord.
func (in *PtrRecord) DeepCopy() *PtrRecord {
	if in == nil {
		return nil
	}
	out := new(PtrRecord)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PtrRecord_STATUS) DeepCopyInto(out *PtrRecord_STATUS) {
	*out = *in
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Ptrdname != nil {
		in, out := &in.Ptrdname, &out.Ptrdname
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PtrRecord_STATUS.
func (in *PtrRecord_STATUS) DeepCopy() *PtrRecord_STATUS {
	if in == nil {
		return nil
	}
	out := new(PtrRecord_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SoaRecord) DeepCopyInto(out *SoaRecord) {
	*out = *in
	if in.Email != nil {
		in, out := &in.Email, &out.Email
		*out = new(string)
		**out = **in
	}
	if in.ExpireTime != nil {
		in, out := &in.ExpireTime, &out.ExpireTime
		*out = new(int)
		**out = **in
	}
	if in.Host != nil {
		in, out := &in.Host, &out.Host
		*out = new(string)
		**out = **in
	}
	if in.MinimumTTL != nil {
		in, out := &in.MinimumTTL, &out.MinimumTTL
		*out = new(int)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.RefreshTime != nil {
		in, out := &in.RefreshTime, &out.RefreshTime
		*out = new(int)
		**out = **in
	}
	if in.RetryTime != nil {
		in, out := &in.RetryTime, &out.RetryTime
		*out = new(int)
		**out = **in
	}
	if in.SerialNumber != nil {
		in, out := &in.SerialNumber, &out.SerialNumber
		*out = new(int)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SoaRecord.
func (in *SoaRecord) DeepCopy() *SoaRecord {
	if in == nil {
		return nil
	}
	out := new(SoaRecord)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SoaRecord_STATUS) DeepCopyInto(out *SoaRecord_STATUS) {
	*out = *in
	if in.Email != nil {
		in, out := &in.Email, &out.Email
		*out = new(string)
		**out = **in
	}
	if in.ExpireTime != nil {
		in, out := &in.ExpireTime, &out.ExpireTime
		*out = new(int)
		**out = **in
	}
	if in.Host != nil {
		in, out := &in.Host, &out.Host
		*out = new(string)
		**out = **in
	}
	if in.MinimumTTL != nil {
		in, out := &in.MinimumTTL, &out.MinimumTTL
		*out = new(int)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.RefreshTime != nil {
		in, out := &in.RefreshTime, &out.RefreshTime
		*out = new(int)
		**out = **in
	}
	if in.RetryTime != nil {
		in, out := &in.RetryTime, &out.RetryTime
		*out = new(int)
		**out = **in
	}
	if in.SerialNumber != nil {
		in, out := &in.SerialNumber, &out.SerialNumber
		*out = new(int)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SoaRecord_STATUS.
func (in *SoaRecord_STATUS) DeepCopy() *SoaRecord_STATUS {
	if in == nil {
		return nil
	}
	out := new(SoaRecord_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SrvRecord) DeepCopyInto(out *SrvRecord) {
	*out = *in
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(int)
		**out = **in
	}
	if in.Priority != nil {
		in, out := &in.Priority, &out.Priority
		*out = new(int)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Target != nil {
		in, out := &in.Target, &out.Target
		*out = new(string)
		**out = **in
	}
	if in.Weight != nil {
		in, out := &in.Weight, &out.Weight
		*out = new(int)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SrvRecord.
func (in *SrvRecord) DeepCopy() *SrvRecord {
	if in == nil {
		return nil
	}
	out := new(SrvRecord)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SrvRecord_STATUS) DeepCopyInto(out *SrvRecord_STATUS) {
	*out = *in
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(int)
		**out = **in
	}
	if in.Priority != nil {
		in, out := &in.Priority, &out.Priority
		*out = new(int)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Target != nil {
		in, out := &in.Target, &out.Target
		*out = new(string)
		**out = **in
	}
	if in.Weight != nil {
		in, out := &in.Weight, &out.Weight
		*out = new(int)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SrvRecord_STATUS.
func (in *SrvRecord_STATUS) DeepCopy() *SrvRecord_STATUS {
	if in == nil {
		return nil
	}
	out := new(SrvRecord_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SubResource) DeepCopyInto(out *SubResource) {
	*out = *in
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Reference != nil {
		in, out := &in.Reference, &out.Reference
		*out = new(genruntime.ResourceReference)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SubResource.
func (in *SubResource) DeepCopy() *SubResource {
	if in == nil {
		return nil
	}
	out := new(SubResource)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SubResource_STATUS) DeepCopyInto(out *SubResource_STATUS) {
	*out = *in
	if in.Id != nil {
		in, out := &in.Id, &out.Id
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SubResource_STATUS.
func (in *SubResource_STATUS) DeepCopy() *SubResource_STATUS {
	if in == nil {
		return nil
	}
	out := new(SubResource_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TxtRecord) DeepCopyInto(out *TxtRecord) {
	*out = *in
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Value != nil {
		in, out := &in.Value, &out.Value
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TxtRecord.
func (in *TxtRecord) DeepCopy() *TxtRecord {
	if in == nil {
		return nil
	}
	out := new(TxtRecord)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TxtRecord_STATUS) DeepCopyInto(out *TxtRecord_STATUS) {
	*out = *in
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Value != nil {
		in, out := &in.Value, &out.Value
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TxtRecord_STATUS.
func (in *TxtRecord_STATUS) DeepCopy() *TxtRecord_STATUS {
	if in == nil {
		return nil
	}
	out := new(TxtRecord_STATUS)
	in.DeepCopyInto(out)
	return out
}
