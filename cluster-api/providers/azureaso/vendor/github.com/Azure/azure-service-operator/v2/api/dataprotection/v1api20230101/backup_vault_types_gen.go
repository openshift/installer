// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20230101

import (
	"fmt"
	v20230101s "github.com/Azure/azure-service-operator/v2/api/dataprotection/v1api20230101/storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /dataprotection/resource-manager/Microsoft.DataProtection/stable/2023-01-01/dataprotection.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}
type BackupVault struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              BackupVault_Spec           `json:"spec,omitempty"`
	Status            BackupVaultResource_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &BackupVault{}

// GetConditions returns the conditions of the resource
func (vault *BackupVault) GetConditions() conditions.Conditions {
	return vault.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (vault *BackupVault) SetConditions(conditions conditions.Conditions) {
	vault.Status.Conditions = conditions
}

var _ conversion.Convertible = &BackupVault{}

// ConvertFrom populates our BackupVault from the provided hub BackupVault
func (vault *BackupVault) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v20230101s.BackupVault)
	if !ok {
		return fmt.Errorf("expected dataprotection/v1api20230101/storage/BackupVault but received %T instead", hub)
	}

	return vault.AssignProperties_From_BackupVault(source)
}

// ConvertTo populates the provided hub BackupVault from our BackupVault
func (vault *BackupVault) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v20230101s.BackupVault)
	if !ok {
		return fmt.Errorf("expected dataprotection/v1api20230101/storage/BackupVault but received %T instead", hub)
	}

	return vault.AssignProperties_To_BackupVault(destination)
}

// +kubebuilder:webhook:path=/mutate-dataprotection-azure-com-v1api20230101-backupvault,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=dataprotection.azure.com,resources=backupvaults,verbs=create;update,versions=v1api20230101,name=default.v1api20230101.backupvaults.dataprotection.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &BackupVault{}

// Default applies defaults to the BackupVault resource
func (vault *BackupVault) Default() {
	vault.defaultImpl()
	var temp any = vault
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (vault *BackupVault) defaultAzureName() {
	if vault.Spec.AzureName == "" {
		vault.Spec.AzureName = vault.Name
	}
}

// defaultImpl applies the code generated defaults to the BackupVault resource
func (vault *BackupVault) defaultImpl() { vault.defaultAzureName() }

var _ genruntime.ImportableResource = &BackupVault{}

// InitializeSpec initializes the spec for this resource from the given status
func (vault *BackupVault) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*BackupVaultResource_STATUS); ok {
		return vault.Spec.Initialize_From_BackupVaultResource_STATUS(s)
	}

	return fmt.Errorf("expected Status of type BackupVaultResource_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &BackupVault{}

// AzureName returns the Azure name of the resource
func (vault *BackupVault) AzureName() string {
	return vault.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2023-01-01"
func (vault BackupVault) GetAPIVersion() string {
	return string(APIVersion_Value)
}

// GetResourceScope returns the scope of the resource
func (vault *BackupVault) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (vault *BackupVault) GetSpec() genruntime.ConvertibleSpec {
	return &vault.Spec
}

// GetStatus returns the status of this resource
func (vault *BackupVault) GetStatus() genruntime.ConvertibleStatus {
	return &vault.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (vault *BackupVault) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.DataProtection/backupVaults"
func (vault *BackupVault) GetType() string {
	return "Microsoft.DataProtection/backupVaults"
}

// NewEmptyStatus returns a new empty (blank) status
func (vault *BackupVault) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &BackupVaultResource_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (vault *BackupVault) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(vault.Spec)
	return vault.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (vault *BackupVault) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*BackupVaultResource_STATUS); ok {
		vault.Status = *st
		return nil
	}

	// Convert status to required version
	var st BackupVaultResource_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	vault.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-dataprotection-azure-com-v1api20230101-backupvault,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=dataprotection.azure.com,resources=backupvaults,verbs=create;update,versions=v1api20230101,name=validate.v1api20230101.backupvaults.dataprotection.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &BackupVault{}

// ValidateCreate validates the creation of the resource
func (vault *BackupVault) ValidateCreate() (admission.Warnings, error) {
	validations := vault.createValidations()
	var temp any = vault
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	return genruntime.ValidateCreate(validations)
}

// ValidateDelete validates the deletion of the resource
func (vault *BackupVault) ValidateDelete() (admission.Warnings, error) {
	validations := vault.deleteValidations()
	var temp any = vault
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	return genruntime.ValidateDelete(validations)
}

// ValidateUpdate validates an update of the resource
func (vault *BackupVault) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	validations := vault.updateValidations()
	var temp any = vault
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	return genruntime.ValidateUpdate(old, validations)
}

// createValidations validates the creation of the resource
func (vault *BackupVault) createValidations() []func() (admission.Warnings, error) {
	return []func() (admission.Warnings, error){vault.validateResourceReferences, vault.validateOwnerReference}
}

// deleteValidations validates the deletion of the resource
func (vault *BackupVault) deleteValidations() []func() (admission.Warnings, error) {
	return nil
}

// updateValidations validates the update of the resource
func (vault *BackupVault) updateValidations() []func(old runtime.Object) (admission.Warnings, error) {
	return []func(old runtime.Object) (admission.Warnings, error){
		func(old runtime.Object) (admission.Warnings, error) {
			return vault.validateResourceReferences()
		},
		vault.validateWriteOnceProperties,
		func(old runtime.Object) (admission.Warnings, error) {
			return vault.validateOwnerReference()
		},
	}
}

// validateOwnerReference validates the owner field
func (vault *BackupVault) validateOwnerReference() (admission.Warnings, error) {
	return genruntime.ValidateOwner(vault)
}

// validateResourceReferences validates all resource references
func (vault *BackupVault) validateResourceReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindResourceReferences(&vault.Spec)
	if err != nil {
		return nil, err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (vault *BackupVault) validateWriteOnceProperties(old runtime.Object) (admission.Warnings, error) {
	oldObj, ok := old.(*BackupVault)
	if !ok {
		return nil, nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, vault)
}

// AssignProperties_From_BackupVault populates our BackupVault from the provided source BackupVault
func (vault *BackupVault) AssignProperties_From_BackupVault(source *v20230101s.BackupVault) error {

	// ObjectMeta
	vault.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec BackupVault_Spec
	err := spec.AssignProperties_From_BackupVault_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_BackupVault_Spec() to populate field Spec")
	}
	vault.Spec = spec

	// Status
	var status BackupVaultResource_STATUS
	err = status.AssignProperties_From_BackupVaultResource_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_BackupVaultResource_STATUS() to populate field Status")
	}
	vault.Status = status

	// No error
	return nil
}

// AssignProperties_To_BackupVault populates the provided destination BackupVault from our BackupVault
func (vault *BackupVault) AssignProperties_To_BackupVault(destination *v20230101s.BackupVault) error {

	// ObjectMeta
	destination.ObjectMeta = *vault.ObjectMeta.DeepCopy()

	// Spec
	var spec v20230101s.BackupVault_Spec
	err := vault.Spec.AssignProperties_To_BackupVault_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_BackupVault_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v20230101s.BackupVaultResource_STATUS
	err = vault.Status.AssignProperties_To_BackupVaultResource_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_BackupVaultResource_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (vault *BackupVault) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: vault.Spec.OriginalVersion(),
		Kind:    "BackupVault",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /dataprotection/resource-manager/Microsoft.DataProtection/stable/2023-01-01/dataprotection.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}
type BackupVaultList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []BackupVault `json:"items"`
}

// +kubebuilder:validation:Enum={"2023-01-01"}
type APIVersion string

const APIVersion_Value = APIVersion("2023-01-01")

type BackupVault_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// Identity: Input Managed Identity Details
	Identity *DppIdentityDetails `json:"identity,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// +kubebuilder:validation:Required
	// Properties: BackupVaultResource properties
	Properties *BackupVaultSpec `json:"properties,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &BackupVault_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (vault *BackupVault_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if vault == nil {
		return nil, nil
	}
	result := &BackupVault_Spec_ARM{}

	// Set property "Identity":
	if vault.Identity != nil {
		identity_ARM, err := (*vault.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*DppIdentityDetails_ARM)
		result.Identity = &identity
	}

	// Set property "Location":
	if vault.Location != nil {
		location := *vault.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if vault.Properties != nil {
		properties_ARM, err := (*vault.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*BackupVaultSpec_ARM)
		result.Properties = &properties
	}

	// Set property "Tags":
	if vault.Tags != nil {
		result.Tags = make(map[string]string, len(vault.Tags))
		for key, value := range vault.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (vault *BackupVault_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackupVault_Spec_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (vault *BackupVault_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackupVault_Spec_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackupVault_Spec_ARM, got %T", armInput)
	}

	// Set property "AzureName":
	vault.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 DppIdentityDetails
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		vault.Identity = &identity
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		vault.Location = &location
	}

	// Set property "Owner":
	vault.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 BackupVaultSpec
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		vault.Properties = &properties
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		vault.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			vault.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &BackupVault_Spec{}

// ConvertSpecFrom populates our BackupVault_Spec from the provided source
func (vault *BackupVault_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v20230101s.BackupVault_Spec)
	if ok {
		// Populate our instance from source
		return vault.AssignProperties_From_BackupVault_Spec(src)
	}

	// Convert to an intermediate form
	src = &v20230101s.BackupVault_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = vault.AssignProperties_From_BackupVault_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our BackupVault_Spec
func (vault *BackupVault_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v20230101s.BackupVault_Spec)
	if ok {
		// Populate destination from our instance
		return vault.AssignProperties_To_BackupVault_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &v20230101s.BackupVault_Spec{}
	err := vault.AssignProperties_To_BackupVault_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_BackupVault_Spec populates our BackupVault_Spec from the provided source BackupVault_Spec
func (vault *BackupVault_Spec) AssignProperties_From_BackupVault_Spec(source *v20230101s.BackupVault_Spec) error {

	// AzureName
	vault.AzureName = source.AzureName

	// Identity
	if source.Identity != nil {
		var identity DppIdentityDetails
		err := identity.AssignProperties_From_DppIdentityDetails(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DppIdentityDetails() to populate field Identity")
		}
		vault.Identity = &identity
	} else {
		vault.Identity = nil
	}

	// Location
	vault.Location = genruntime.ClonePointerToString(source.Location)

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		vault.Owner = &owner
	} else {
		vault.Owner = nil
	}

	// Properties
	if source.Properties != nil {
		var property BackupVaultSpec
		err := property.AssignProperties_From_BackupVaultSpec(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BackupVaultSpec() to populate field Properties")
		}
		vault.Properties = &property
	} else {
		vault.Properties = nil
	}

	// Tags
	vault.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// AssignProperties_To_BackupVault_Spec populates the provided destination BackupVault_Spec from our BackupVault_Spec
func (vault *BackupVault_Spec) AssignProperties_To_BackupVault_Spec(destination *v20230101s.BackupVault_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = vault.AzureName

	// Identity
	if vault.Identity != nil {
		var identity v20230101s.DppIdentityDetails
		err := vault.Identity.AssignProperties_To_DppIdentityDetails(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DppIdentityDetails() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(vault.Location)

	// OriginalVersion
	destination.OriginalVersion = vault.OriginalVersion()

	// Owner
	if vault.Owner != nil {
		owner := vault.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Properties
	if vault.Properties != nil {
		var property v20230101s.BackupVaultSpec
		err := vault.Properties.AssignProperties_To_BackupVaultSpec(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BackupVaultSpec() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(vault.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_BackupVaultResource_STATUS populates our BackupVault_Spec from the provided source BackupVaultResource_STATUS
func (vault *BackupVault_Spec) Initialize_From_BackupVaultResource_STATUS(source *BackupVaultResource_STATUS) error {

	// Identity
	if source.Identity != nil {
		var identity DppIdentityDetails
		err := identity.Initialize_From_DppIdentityDetails_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DppIdentityDetails_STATUS() to populate field Identity")
		}
		vault.Identity = &identity
	} else {
		vault.Identity = nil
	}

	// Location
	vault.Location = genruntime.ClonePointerToString(source.Location)

	// Properties
	if source.Properties != nil {
		var property BackupVaultSpec
		err := property.Initialize_From_BackupVault_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_BackupVault_STATUS() to populate field Properties")
		}
		vault.Properties = &property
	} else {
		vault.Properties = nil
	}

	// Tags
	vault.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (vault *BackupVault_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (vault *BackupVault_Spec) SetAzureName(azureName string) { vault.AzureName = azureName }

// Backup Vault Resource
type BackupVaultResource_STATUS struct {
	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// ETag: Optional ETag.
	ETag *string `json:"eTag,omitempty"`

	// Id: Resource Id represents the complete path to the resource.
	Id *string `json:"id,omitempty"`

	// Identity: Input Managed Identity Details
	Identity *DppIdentityDetails_STATUS `json:"identity,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// Name: Resource name associated with the resource.
	Name *string `json:"name,omitempty"`

	// Properties: BackupVaultResource properties
	Properties *BackupVault_STATUS `json:"properties,omitempty"`

	// SystemData: Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData_STATUS `json:"systemData,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: Resource type represents the complete path of the form Namespace/ResourceType/ResourceType/...
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &BackupVaultResource_STATUS{}

// ConvertStatusFrom populates our BackupVaultResource_STATUS from the provided source
func (resource *BackupVaultResource_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v20230101s.BackupVaultResource_STATUS)
	if ok {
		// Populate our instance from source
		return resource.AssignProperties_From_BackupVaultResource_STATUS(src)
	}

	// Convert to an intermediate form
	src = &v20230101s.BackupVaultResource_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = resource.AssignProperties_From_BackupVaultResource_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our BackupVaultResource_STATUS
func (resource *BackupVaultResource_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v20230101s.BackupVaultResource_STATUS)
	if ok {
		// Populate destination from our instance
		return resource.AssignProperties_To_BackupVaultResource_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &v20230101s.BackupVaultResource_STATUS{}
	err := resource.AssignProperties_To_BackupVaultResource_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &BackupVaultResource_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *BackupVaultResource_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackupVaultResource_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *BackupVaultResource_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackupVaultResource_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackupVaultResource_STATUS_ARM, got %T", armInput)
	}

	// no assignment for property "Conditions"

	// Set property "ETag":
	if typedInput.ETag != nil {
		eTag := *typedInput.ETag
		resource.ETag = &eTag
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		resource.Id = &id
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 DppIdentityDetails_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		resource.Identity = &identity
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		resource.Location = &location
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		resource.Name = &name
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 BackupVault_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		resource.Properties = &properties
	}

	// Set property "SystemData":
	if typedInput.SystemData != nil {
		var systemData1 SystemData_STATUS
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		resource.SystemData = &systemData
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		resource.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			resource.Tags[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		resource.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_BackupVaultResource_STATUS populates our BackupVaultResource_STATUS from the provided source BackupVaultResource_STATUS
func (resource *BackupVaultResource_STATUS) AssignProperties_From_BackupVaultResource_STATUS(source *v20230101s.BackupVaultResource_STATUS) error {

	// Conditions
	resource.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// ETag
	resource.ETag = genruntime.ClonePointerToString(source.ETag)

	// Id
	resource.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity DppIdentityDetails_STATUS
		err := identity.AssignProperties_From_DppIdentityDetails_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DppIdentityDetails_STATUS() to populate field Identity")
		}
		resource.Identity = &identity
	} else {
		resource.Identity = nil
	}

	// Location
	resource.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	resource.Name = genruntime.ClonePointerToString(source.Name)

	// Properties
	if source.Properties != nil {
		var property BackupVault_STATUS
		err := property.AssignProperties_From_BackupVault_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BackupVault_STATUS() to populate field Properties")
		}
		resource.Properties = &property
	} else {
		resource.Properties = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		resource.SystemData = &systemDatum
	} else {
		resource.SystemData = nil
	}

	// Tags
	resource.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	resource.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_BackupVaultResource_STATUS populates the provided destination BackupVaultResource_STATUS from our BackupVaultResource_STATUS
func (resource *BackupVaultResource_STATUS) AssignProperties_To_BackupVaultResource_STATUS(destination *v20230101s.BackupVaultResource_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(resource.Conditions)

	// ETag
	destination.ETag = genruntime.ClonePointerToString(resource.ETag)

	// Id
	destination.Id = genruntime.ClonePointerToString(resource.Id)

	// Identity
	if resource.Identity != nil {
		var identity v20230101s.DppIdentityDetails_STATUS
		err := resource.Identity.AssignProperties_To_DppIdentityDetails_STATUS(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DppIdentityDetails_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(resource.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(resource.Name)

	// Properties
	if resource.Properties != nil {
		var property v20230101s.BackupVault_STATUS
		err := resource.Properties.AssignProperties_To_BackupVault_STATUS(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BackupVault_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// SystemData
	if resource.SystemData != nil {
		var systemDatum v20230101s.SystemData_STATUS
		err := resource.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(resource.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(resource.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Backup Vault
type BackupVault_STATUS struct {
	// FeatureSettings: Feature Settings
	FeatureSettings *FeatureSettings_STATUS `json:"featureSettings,omitempty"`

	// IsVaultProtectedByResourceGuard: Is vault protected by resource guard
	IsVaultProtectedByResourceGuard *bool `json:"isVaultProtectedByResourceGuard,omitempty"`

	// MonitoringSettings: Monitoring Settings
	MonitoringSettings *MonitoringSettings_STATUS `json:"monitoringSettings,omitempty"`

	// ProvisioningState: Provisioning state of the BackupVault resource
	ProvisioningState *BackupVault_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// ResourceMoveDetails: Resource move details for backup vault
	ResourceMoveDetails *ResourceMoveDetails_STATUS `json:"resourceMoveDetails,omitempty"`

	// ResourceMoveState: Resource move state for backup vault
	ResourceMoveState *BackupVault_ResourceMoveState_STATUS `json:"resourceMoveState,omitempty"`

	// SecuritySettings: Security Settings
	SecuritySettings *SecuritySettings_STATUS `json:"securitySettings,omitempty"`

	// StorageSettings: Storage Settings
	StorageSettings []StorageSetting_STATUS `json:"storageSettings,omitempty"`
}

var _ genruntime.FromARMConverter = &BackupVault_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (vault *BackupVault_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackupVault_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (vault *BackupVault_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackupVault_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackupVault_STATUS_ARM, got %T", armInput)
	}

	// Set property "FeatureSettings":
	if typedInput.FeatureSettings != nil {
		var featureSettings1 FeatureSettings_STATUS
		err := featureSettings1.PopulateFromARM(owner, *typedInput.FeatureSettings)
		if err != nil {
			return err
		}
		featureSettings := featureSettings1
		vault.FeatureSettings = &featureSettings
	}

	// Set property "IsVaultProtectedByResourceGuard":
	if typedInput.IsVaultProtectedByResourceGuard != nil {
		isVaultProtectedByResourceGuard := *typedInput.IsVaultProtectedByResourceGuard
		vault.IsVaultProtectedByResourceGuard = &isVaultProtectedByResourceGuard
	}

	// Set property "MonitoringSettings":
	if typedInput.MonitoringSettings != nil {
		var monitoringSettings1 MonitoringSettings_STATUS
		err := monitoringSettings1.PopulateFromARM(owner, *typedInput.MonitoringSettings)
		if err != nil {
			return err
		}
		monitoringSettings := monitoringSettings1
		vault.MonitoringSettings = &monitoringSettings
	}

	// Set property "ProvisioningState":
	if typedInput.ProvisioningState != nil {
		provisioningState := *typedInput.ProvisioningState
		vault.ProvisioningState = &provisioningState
	}

	// Set property "ResourceMoveDetails":
	if typedInput.ResourceMoveDetails != nil {
		var resourceMoveDetails1 ResourceMoveDetails_STATUS
		err := resourceMoveDetails1.PopulateFromARM(owner, *typedInput.ResourceMoveDetails)
		if err != nil {
			return err
		}
		resourceMoveDetails := resourceMoveDetails1
		vault.ResourceMoveDetails = &resourceMoveDetails
	}

	// Set property "ResourceMoveState":
	if typedInput.ResourceMoveState != nil {
		resourceMoveState := *typedInput.ResourceMoveState
		vault.ResourceMoveState = &resourceMoveState
	}

	// Set property "SecuritySettings":
	if typedInput.SecuritySettings != nil {
		var securitySettings1 SecuritySettings_STATUS
		err := securitySettings1.PopulateFromARM(owner, *typedInput.SecuritySettings)
		if err != nil {
			return err
		}
		securitySettings := securitySettings1
		vault.SecuritySettings = &securitySettings
	}

	// Set property "StorageSettings":
	for _, item := range typedInput.StorageSettings {
		var item1 StorageSetting_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		vault.StorageSettings = append(vault.StorageSettings, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_BackupVault_STATUS populates our BackupVault_STATUS from the provided source BackupVault_STATUS
func (vault *BackupVault_STATUS) AssignProperties_From_BackupVault_STATUS(source *v20230101s.BackupVault_STATUS) error {

	// FeatureSettings
	if source.FeatureSettings != nil {
		var featureSetting FeatureSettings_STATUS
		err := featureSetting.AssignProperties_From_FeatureSettings_STATUS(source.FeatureSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_FeatureSettings_STATUS() to populate field FeatureSettings")
		}
		vault.FeatureSettings = &featureSetting
	} else {
		vault.FeatureSettings = nil
	}

	// IsVaultProtectedByResourceGuard
	if source.IsVaultProtectedByResourceGuard != nil {
		isVaultProtectedByResourceGuard := *source.IsVaultProtectedByResourceGuard
		vault.IsVaultProtectedByResourceGuard = &isVaultProtectedByResourceGuard
	} else {
		vault.IsVaultProtectedByResourceGuard = nil
	}

	// MonitoringSettings
	if source.MonitoringSettings != nil {
		var monitoringSetting MonitoringSettings_STATUS
		err := monitoringSetting.AssignProperties_From_MonitoringSettings_STATUS(source.MonitoringSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_MonitoringSettings_STATUS() to populate field MonitoringSettings")
		}
		vault.MonitoringSettings = &monitoringSetting
	} else {
		vault.MonitoringSettings = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := BackupVault_ProvisioningState_STATUS(*source.ProvisioningState)
		vault.ProvisioningState = &provisioningState
	} else {
		vault.ProvisioningState = nil
	}

	// ResourceMoveDetails
	if source.ResourceMoveDetails != nil {
		var resourceMoveDetail ResourceMoveDetails_STATUS
		err := resourceMoveDetail.AssignProperties_From_ResourceMoveDetails_STATUS(source.ResourceMoveDetails)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceMoveDetails_STATUS() to populate field ResourceMoveDetails")
		}
		vault.ResourceMoveDetails = &resourceMoveDetail
	} else {
		vault.ResourceMoveDetails = nil
	}

	// ResourceMoveState
	if source.ResourceMoveState != nil {
		resourceMoveState := BackupVault_ResourceMoveState_STATUS(*source.ResourceMoveState)
		vault.ResourceMoveState = &resourceMoveState
	} else {
		vault.ResourceMoveState = nil
	}

	// SecuritySettings
	if source.SecuritySettings != nil {
		var securitySetting SecuritySettings_STATUS
		err := securitySetting.AssignProperties_From_SecuritySettings_STATUS(source.SecuritySettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SecuritySettings_STATUS() to populate field SecuritySettings")
		}
		vault.SecuritySettings = &securitySetting
	} else {
		vault.SecuritySettings = nil
	}

	// StorageSettings
	if source.StorageSettings != nil {
		storageSettingList := make([]StorageSetting_STATUS, len(source.StorageSettings))
		for storageSettingIndex, storageSettingItem := range source.StorageSettings {
			// Shadow the loop variable to avoid aliasing
			storageSettingItem := storageSettingItem
			var storageSetting StorageSetting_STATUS
			err := storageSetting.AssignProperties_From_StorageSetting_STATUS(&storageSettingItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_StorageSetting_STATUS() to populate field StorageSettings")
			}
			storageSettingList[storageSettingIndex] = storageSetting
		}
		vault.StorageSettings = storageSettingList
	} else {
		vault.StorageSettings = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackupVault_STATUS populates the provided destination BackupVault_STATUS from our BackupVault_STATUS
func (vault *BackupVault_STATUS) AssignProperties_To_BackupVault_STATUS(destination *v20230101s.BackupVault_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// FeatureSettings
	if vault.FeatureSettings != nil {
		var featureSetting v20230101s.FeatureSettings_STATUS
		err := vault.FeatureSettings.AssignProperties_To_FeatureSettings_STATUS(&featureSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_FeatureSettings_STATUS() to populate field FeatureSettings")
		}
		destination.FeatureSettings = &featureSetting
	} else {
		destination.FeatureSettings = nil
	}

	// IsVaultProtectedByResourceGuard
	if vault.IsVaultProtectedByResourceGuard != nil {
		isVaultProtectedByResourceGuard := *vault.IsVaultProtectedByResourceGuard
		destination.IsVaultProtectedByResourceGuard = &isVaultProtectedByResourceGuard
	} else {
		destination.IsVaultProtectedByResourceGuard = nil
	}

	// MonitoringSettings
	if vault.MonitoringSettings != nil {
		var monitoringSetting v20230101s.MonitoringSettings_STATUS
		err := vault.MonitoringSettings.AssignProperties_To_MonitoringSettings_STATUS(&monitoringSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_MonitoringSettings_STATUS() to populate field MonitoringSettings")
		}
		destination.MonitoringSettings = &monitoringSetting
	} else {
		destination.MonitoringSettings = nil
	}

	// ProvisioningState
	if vault.ProvisioningState != nil {
		provisioningState := string(*vault.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ResourceMoveDetails
	if vault.ResourceMoveDetails != nil {
		var resourceMoveDetail v20230101s.ResourceMoveDetails_STATUS
		err := vault.ResourceMoveDetails.AssignProperties_To_ResourceMoveDetails_STATUS(&resourceMoveDetail)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceMoveDetails_STATUS() to populate field ResourceMoveDetails")
		}
		destination.ResourceMoveDetails = &resourceMoveDetail
	} else {
		destination.ResourceMoveDetails = nil
	}

	// ResourceMoveState
	if vault.ResourceMoveState != nil {
		resourceMoveState := string(*vault.ResourceMoveState)
		destination.ResourceMoveState = &resourceMoveState
	} else {
		destination.ResourceMoveState = nil
	}

	// SecuritySettings
	if vault.SecuritySettings != nil {
		var securitySetting v20230101s.SecuritySettings_STATUS
		err := vault.SecuritySettings.AssignProperties_To_SecuritySettings_STATUS(&securitySetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SecuritySettings_STATUS() to populate field SecuritySettings")
		}
		destination.SecuritySettings = &securitySetting
	} else {
		destination.SecuritySettings = nil
	}

	// StorageSettings
	if vault.StorageSettings != nil {
		storageSettingList := make([]v20230101s.StorageSetting_STATUS, len(vault.StorageSettings))
		for storageSettingIndex, storageSettingItem := range vault.StorageSettings {
			// Shadow the loop variable to avoid aliasing
			storageSettingItem := storageSettingItem
			var storageSetting v20230101s.StorageSetting_STATUS
			err := storageSettingItem.AssignProperties_To_StorageSetting_STATUS(&storageSetting)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_StorageSetting_STATUS() to populate field StorageSettings")
			}
			storageSettingList[storageSettingIndex] = storageSetting
		}
		destination.StorageSettings = storageSettingList
	} else {
		destination.StorageSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Backup Vault
type BackupVaultSpec struct {
	// FeatureSettings: Feature Settings
	FeatureSettings *FeatureSettings `json:"featureSettings,omitempty"`

	// MonitoringSettings: Monitoring Settings
	MonitoringSettings *MonitoringSettings `json:"monitoringSettings,omitempty"`

	// SecuritySettings: Security Settings
	SecuritySettings *SecuritySettings `json:"securitySettings,omitempty"`

	// +kubebuilder:validation:Required
	// StorageSettings: Storage Settings
	StorageSettings []StorageSetting `json:"storageSettings,omitempty"`
}

var _ genruntime.ARMTransformer = &BackupVaultSpec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (vault *BackupVaultSpec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if vault == nil {
		return nil, nil
	}
	result := &BackupVaultSpec_ARM{}

	// Set property "FeatureSettings":
	if vault.FeatureSettings != nil {
		featureSettings_ARM, err := (*vault.FeatureSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		featureSettings := *featureSettings_ARM.(*FeatureSettings_ARM)
		result.FeatureSettings = &featureSettings
	}

	// Set property "MonitoringSettings":
	if vault.MonitoringSettings != nil {
		monitoringSettings_ARM, err := (*vault.MonitoringSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		monitoringSettings := *monitoringSettings_ARM.(*MonitoringSettings_ARM)
		result.MonitoringSettings = &monitoringSettings
	}

	// Set property "SecuritySettings":
	if vault.SecuritySettings != nil {
		securitySettings_ARM, err := (*vault.SecuritySettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		securitySettings := *securitySettings_ARM.(*SecuritySettings_ARM)
		result.SecuritySettings = &securitySettings
	}

	// Set property "StorageSettings":
	for _, item := range vault.StorageSettings {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.StorageSettings = append(result.StorageSettings, *item_ARM.(*StorageSetting_ARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (vault *BackupVaultSpec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &BackupVaultSpec_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (vault *BackupVaultSpec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BackupVaultSpec_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BackupVaultSpec_ARM, got %T", armInput)
	}

	// Set property "FeatureSettings":
	if typedInput.FeatureSettings != nil {
		var featureSettings1 FeatureSettings
		err := featureSettings1.PopulateFromARM(owner, *typedInput.FeatureSettings)
		if err != nil {
			return err
		}
		featureSettings := featureSettings1
		vault.FeatureSettings = &featureSettings
	}

	// Set property "MonitoringSettings":
	if typedInput.MonitoringSettings != nil {
		var monitoringSettings1 MonitoringSettings
		err := monitoringSettings1.PopulateFromARM(owner, *typedInput.MonitoringSettings)
		if err != nil {
			return err
		}
		monitoringSettings := monitoringSettings1
		vault.MonitoringSettings = &monitoringSettings
	}

	// Set property "SecuritySettings":
	if typedInput.SecuritySettings != nil {
		var securitySettings1 SecuritySettings
		err := securitySettings1.PopulateFromARM(owner, *typedInput.SecuritySettings)
		if err != nil {
			return err
		}
		securitySettings := securitySettings1
		vault.SecuritySettings = &securitySettings
	}

	// Set property "StorageSettings":
	for _, item := range typedInput.StorageSettings {
		var item1 StorageSetting
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		vault.StorageSettings = append(vault.StorageSettings, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_BackupVaultSpec populates our BackupVaultSpec from the provided source BackupVaultSpec
func (vault *BackupVaultSpec) AssignProperties_From_BackupVaultSpec(source *v20230101s.BackupVaultSpec) error {

	// FeatureSettings
	if source.FeatureSettings != nil {
		var featureSetting FeatureSettings
		err := featureSetting.AssignProperties_From_FeatureSettings(source.FeatureSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_FeatureSettings() to populate field FeatureSettings")
		}
		vault.FeatureSettings = &featureSetting
	} else {
		vault.FeatureSettings = nil
	}

	// MonitoringSettings
	if source.MonitoringSettings != nil {
		var monitoringSetting MonitoringSettings
		err := monitoringSetting.AssignProperties_From_MonitoringSettings(source.MonitoringSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_MonitoringSettings() to populate field MonitoringSettings")
		}
		vault.MonitoringSettings = &monitoringSetting
	} else {
		vault.MonitoringSettings = nil
	}

	// SecuritySettings
	if source.SecuritySettings != nil {
		var securitySetting SecuritySettings
		err := securitySetting.AssignProperties_From_SecuritySettings(source.SecuritySettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SecuritySettings() to populate field SecuritySettings")
		}
		vault.SecuritySettings = &securitySetting
	} else {
		vault.SecuritySettings = nil
	}

	// StorageSettings
	if source.StorageSettings != nil {
		storageSettingList := make([]StorageSetting, len(source.StorageSettings))
		for storageSettingIndex, storageSettingItem := range source.StorageSettings {
			// Shadow the loop variable to avoid aliasing
			storageSettingItem := storageSettingItem
			var storageSetting StorageSetting
			err := storageSetting.AssignProperties_From_StorageSetting(&storageSettingItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_StorageSetting() to populate field StorageSettings")
			}
			storageSettingList[storageSettingIndex] = storageSetting
		}
		vault.StorageSettings = storageSettingList
	} else {
		vault.StorageSettings = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackupVaultSpec populates the provided destination BackupVaultSpec from our BackupVaultSpec
func (vault *BackupVaultSpec) AssignProperties_To_BackupVaultSpec(destination *v20230101s.BackupVaultSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// FeatureSettings
	if vault.FeatureSettings != nil {
		var featureSetting v20230101s.FeatureSettings
		err := vault.FeatureSettings.AssignProperties_To_FeatureSettings(&featureSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_FeatureSettings() to populate field FeatureSettings")
		}
		destination.FeatureSettings = &featureSetting
	} else {
		destination.FeatureSettings = nil
	}

	// MonitoringSettings
	if vault.MonitoringSettings != nil {
		var monitoringSetting v20230101s.MonitoringSettings
		err := vault.MonitoringSettings.AssignProperties_To_MonitoringSettings(&monitoringSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_MonitoringSettings() to populate field MonitoringSettings")
		}
		destination.MonitoringSettings = &monitoringSetting
	} else {
		destination.MonitoringSettings = nil
	}

	// SecuritySettings
	if vault.SecuritySettings != nil {
		var securitySetting v20230101s.SecuritySettings
		err := vault.SecuritySettings.AssignProperties_To_SecuritySettings(&securitySetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SecuritySettings() to populate field SecuritySettings")
		}
		destination.SecuritySettings = &securitySetting
	} else {
		destination.SecuritySettings = nil
	}

	// StorageSettings
	if vault.StorageSettings != nil {
		storageSettingList := make([]v20230101s.StorageSetting, len(vault.StorageSettings))
		for storageSettingIndex, storageSettingItem := range vault.StorageSettings {
			// Shadow the loop variable to avoid aliasing
			storageSettingItem := storageSettingItem
			var storageSetting v20230101s.StorageSetting
			err := storageSettingItem.AssignProperties_To_StorageSetting(&storageSetting)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_StorageSetting() to populate field StorageSettings")
			}
			storageSettingList[storageSettingIndex] = storageSetting
		}
		destination.StorageSettings = storageSettingList
	} else {
		destination.StorageSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_BackupVault_STATUS populates our BackupVaultSpec from the provided source BackupVault_STATUS
func (vault *BackupVaultSpec) Initialize_From_BackupVault_STATUS(source *BackupVault_STATUS) error {

	// FeatureSettings
	if source.FeatureSettings != nil {
		var featureSetting FeatureSettings
		err := featureSetting.Initialize_From_FeatureSettings_STATUS(source.FeatureSettings)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_FeatureSettings_STATUS() to populate field FeatureSettings")
		}
		vault.FeatureSettings = &featureSetting
	} else {
		vault.FeatureSettings = nil
	}

	// MonitoringSettings
	if source.MonitoringSettings != nil {
		var monitoringSetting MonitoringSettings
		err := monitoringSetting.Initialize_From_MonitoringSettings_STATUS(source.MonitoringSettings)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_MonitoringSettings_STATUS() to populate field MonitoringSettings")
		}
		vault.MonitoringSettings = &monitoringSetting
	} else {
		vault.MonitoringSettings = nil
	}

	// SecuritySettings
	if source.SecuritySettings != nil {
		var securitySetting SecuritySettings
		err := securitySetting.Initialize_From_SecuritySettings_STATUS(source.SecuritySettings)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SecuritySettings_STATUS() to populate field SecuritySettings")
		}
		vault.SecuritySettings = &securitySetting
	} else {
		vault.SecuritySettings = nil
	}

	// StorageSettings
	if source.StorageSettings != nil {
		storageSettingList := make([]StorageSetting, len(source.StorageSettings))
		for storageSettingIndex, storageSettingItem := range source.StorageSettings {
			// Shadow the loop variable to avoid aliasing
			storageSettingItem := storageSettingItem
			var storageSetting StorageSetting
			err := storageSetting.Initialize_From_StorageSetting_STATUS(&storageSettingItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_StorageSetting_STATUS() to populate field StorageSettings")
			}
			storageSettingList[storageSettingIndex] = storageSetting
		}
		vault.StorageSettings = storageSettingList
	} else {
		vault.StorageSettings = nil
	}

	// No error
	return nil
}

// Identity details
type DppIdentityDetails struct {
	// Type: The identityType which can be either SystemAssigned or None
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &DppIdentityDetails{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (details *DppIdentityDetails) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if details == nil {
		return nil, nil
	}
	result := &DppIdentityDetails_ARM{}

	// Set property "Type":
	if details.Type != nil {
		typeVar := *details.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (details *DppIdentityDetails) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DppIdentityDetails_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (details *DppIdentityDetails) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DppIdentityDetails_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DppIdentityDetails_ARM, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		details.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_DppIdentityDetails populates our DppIdentityDetails from the provided source DppIdentityDetails
func (details *DppIdentityDetails) AssignProperties_From_DppIdentityDetails(source *v20230101s.DppIdentityDetails) error {

	// Type
	details.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_DppIdentityDetails populates the provided destination DppIdentityDetails from our DppIdentityDetails
func (details *DppIdentityDetails) AssignProperties_To_DppIdentityDetails(destination *v20230101s.DppIdentityDetails) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	destination.Type = genruntime.ClonePointerToString(details.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DppIdentityDetails_STATUS populates our DppIdentityDetails from the provided source DppIdentityDetails_STATUS
func (details *DppIdentityDetails) Initialize_From_DppIdentityDetails_STATUS(source *DppIdentityDetails_STATUS) error {

	// Type
	details.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// Identity details
type DppIdentityDetails_STATUS struct {
	// PrincipalId: The object ID of the service principal object for the managed identity that is used to grant role-based
	// access to an Azure resource.
	PrincipalId *string `json:"principalId,omitempty"`

	// TenantId: A Globally Unique Identifier (GUID) that represents the Azure AD tenant where the resource is now a member.
	TenantId *string `json:"tenantId,omitempty"`

	// Type: The identityType which can be either SystemAssigned or None
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &DppIdentityDetails_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (details *DppIdentityDetails_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DppIdentityDetails_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (details *DppIdentityDetails_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DppIdentityDetails_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DppIdentityDetails_STATUS_ARM, got %T", armInput)
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		details.PrincipalId = &principalId
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		details.TenantId = &tenantId
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		details.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_DppIdentityDetails_STATUS populates our DppIdentityDetails_STATUS from the provided source DppIdentityDetails_STATUS
func (details *DppIdentityDetails_STATUS) AssignProperties_From_DppIdentityDetails_STATUS(source *v20230101s.DppIdentityDetails_STATUS) error {

	// PrincipalId
	details.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	details.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	details.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_DppIdentityDetails_STATUS populates the provided destination DppIdentityDetails_STATUS from our DppIdentityDetails_STATUS
func (details *DppIdentityDetails_STATUS) AssignProperties_To_DppIdentityDetails_STATUS(destination *v20230101s.DppIdentityDetails_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(details.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(details.TenantId)

	// Type
	destination.Type = genruntime.ClonePointerToString(details.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Metadata pertaining to creation and last modification of the resource.
type SystemData_STATUS struct {
	// CreatedAt: The timestamp of resource creation (UTC).
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy: The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`

	// CreatedByType: The type of identity that created the resource.
	CreatedByType *SystemData_CreatedByType_STATUS `json:"createdByType,omitempty"`

	// LastModifiedAt: The timestamp of resource last modification (UTC)
	LastModifiedAt *string `json:"lastModifiedAt,omitempty"`

	// LastModifiedBy: The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`

	// LastModifiedByType: The type of identity that last modified the resource.
	LastModifiedByType *SystemData_LastModifiedByType_STATUS `json:"lastModifiedByType,omitempty"`
}

var _ genruntime.FromARMConverter = &SystemData_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (data *SystemData_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SystemData_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (data *SystemData_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SystemData_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SystemData_STATUS_ARM, got %T", armInput)
	}

	// Set property "CreatedAt":
	if typedInput.CreatedAt != nil {
		createdAt := *typedInput.CreatedAt
		data.CreatedAt = &createdAt
	}

	// Set property "CreatedBy":
	if typedInput.CreatedBy != nil {
		createdBy := *typedInput.CreatedBy
		data.CreatedBy = &createdBy
	}

	// Set property "CreatedByType":
	if typedInput.CreatedByType != nil {
		createdByType := *typedInput.CreatedByType
		data.CreatedByType = &createdByType
	}

	// Set property "LastModifiedAt":
	if typedInput.LastModifiedAt != nil {
		lastModifiedAt := *typedInput.LastModifiedAt
		data.LastModifiedAt = &lastModifiedAt
	}

	// Set property "LastModifiedBy":
	if typedInput.LastModifiedBy != nil {
		lastModifiedBy := *typedInput.LastModifiedBy
		data.LastModifiedBy = &lastModifiedBy
	}

	// Set property "LastModifiedByType":
	if typedInput.LastModifiedByType != nil {
		lastModifiedByType := *typedInput.LastModifiedByType
		data.LastModifiedByType = &lastModifiedByType
	}

	// No error
	return nil
}

// AssignProperties_From_SystemData_STATUS populates our SystemData_STATUS from the provided source SystemData_STATUS
func (data *SystemData_STATUS) AssignProperties_From_SystemData_STATUS(source *v20230101s.SystemData_STATUS) error {

	// CreatedAt
	data.CreatedAt = genruntime.ClonePointerToString(source.CreatedAt)

	// CreatedBy
	data.CreatedBy = genruntime.ClonePointerToString(source.CreatedBy)

	// CreatedByType
	if source.CreatedByType != nil {
		createdByType := SystemData_CreatedByType_STATUS(*source.CreatedByType)
		data.CreatedByType = &createdByType
	} else {
		data.CreatedByType = nil
	}

	// LastModifiedAt
	data.LastModifiedAt = genruntime.ClonePointerToString(source.LastModifiedAt)

	// LastModifiedBy
	data.LastModifiedBy = genruntime.ClonePointerToString(source.LastModifiedBy)

	// LastModifiedByType
	if source.LastModifiedByType != nil {
		lastModifiedByType := SystemData_LastModifiedByType_STATUS(*source.LastModifiedByType)
		data.LastModifiedByType = &lastModifiedByType
	} else {
		data.LastModifiedByType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SystemData_STATUS populates the provided destination SystemData_STATUS from our SystemData_STATUS
func (data *SystemData_STATUS) AssignProperties_To_SystemData_STATUS(destination *v20230101s.SystemData_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CreatedAt
	destination.CreatedAt = genruntime.ClonePointerToString(data.CreatedAt)

	// CreatedBy
	destination.CreatedBy = genruntime.ClonePointerToString(data.CreatedBy)

	// CreatedByType
	if data.CreatedByType != nil {
		createdByType := string(*data.CreatedByType)
		destination.CreatedByType = &createdByType
	} else {
		destination.CreatedByType = nil
	}

	// LastModifiedAt
	destination.LastModifiedAt = genruntime.ClonePointerToString(data.LastModifiedAt)

	// LastModifiedBy
	destination.LastModifiedBy = genruntime.ClonePointerToString(data.LastModifiedBy)

	// LastModifiedByType
	if data.LastModifiedByType != nil {
		lastModifiedByType := string(*data.LastModifiedByType)
		destination.LastModifiedByType = &lastModifiedByType
	} else {
		destination.LastModifiedByType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Class containing feature settings of vault
type FeatureSettings struct {
	// CrossSubscriptionRestoreSettings: CrossSubscriptionRestore Settings
	CrossSubscriptionRestoreSettings *CrossSubscriptionRestoreSettings `json:"crossSubscriptionRestoreSettings,omitempty"`
}

var _ genruntime.ARMTransformer = &FeatureSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *FeatureSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &FeatureSettings_ARM{}

	// Set property "CrossSubscriptionRestoreSettings":
	if settings.CrossSubscriptionRestoreSettings != nil {
		crossSubscriptionRestoreSettings_ARM, err := (*settings.CrossSubscriptionRestoreSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		crossSubscriptionRestoreSettings := *crossSubscriptionRestoreSettings_ARM.(*CrossSubscriptionRestoreSettings_ARM)
		result.CrossSubscriptionRestoreSettings = &crossSubscriptionRestoreSettings
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *FeatureSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &FeatureSettings_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *FeatureSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(FeatureSettings_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected FeatureSettings_ARM, got %T", armInput)
	}

	// Set property "CrossSubscriptionRestoreSettings":
	if typedInput.CrossSubscriptionRestoreSettings != nil {
		var crossSubscriptionRestoreSettings1 CrossSubscriptionRestoreSettings
		err := crossSubscriptionRestoreSettings1.PopulateFromARM(owner, *typedInput.CrossSubscriptionRestoreSettings)
		if err != nil {
			return err
		}
		crossSubscriptionRestoreSettings := crossSubscriptionRestoreSettings1
		settings.CrossSubscriptionRestoreSettings = &crossSubscriptionRestoreSettings
	}

	// No error
	return nil
}

// AssignProperties_From_FeatureSettings populates our FeatureSettings from the provided source FeatureSettings
func (settings *FeatureSettings) AssignProperties_From_FeatureSettings(source *v20230101s.FeatureSettings) error {

	// CrossSubscriptionRestoreSettings
	if source.CrossSubscriptionRestoreSettings != nil {
		var crossSubscriptionRestoreSetting CrossSubscriptionRestoreSettings
		err := crossSubscriptionRestoreSetting.AssignProperties_From_CrossSubscriptionRestoreSettings(source.CrossSubscriptionRestoreSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CrossSubscriptionRestoreSettings() to populate field CrossSubscriptionRestoreSettings")
		}
		settings.CrossSubscriptionRestoreSettings = &crossSubscriptionRestoreSetting
	} else {
		settings.CrossSubscriptionRestoreSettings = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FeatureSettings populates the provided destination FeatureSettings from our FeatureSettings
func (settings *FeatureSettings) AssignProperties_To_FeatureSettings(destination *v20230101s.FeatureSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CrossSubscriptionRestoreSettings
	if settings.CrossSubscriptionRestoreSettings != nil {
		var crossSubscriptionRestoreSetting v20230101s.CrossSubscriptionRestoreSettings
		err := settings.CrossSubscriptionRestoreSettings.AssignProperties_To_CrossSubscriptionRestoreSettings(&crossSubscriptionRestoreSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CrossSubscriptionRestoreSettings() to populate field CrossSubscriptionRestoreSettings")
		}
		destination.CrossSubscriptionRestoreSettings = &crossSubscriptionRestoreSetting
	} else {
		destination.CrossSubscriptionRestoreSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_FeatureSettings_STATUS populates our FeatureSettings from the provided source FeatureSettings_STATUS
func (settings *FeatureSettings) Initialize_From_FeatureSettings_STATUS(source *FeatureSettings_STATUS) error {

	// CrossSubscriptionRestoreSettings
	if source.CrossSubscriptionRestoreSettings != nil {
		var crossSubscriptionRestoreSetting CrossSubscriptionRestoreSettings
		err := crossSubscriptionRestoreSetting.Initialize_From_CrossSubscriptionRestoreSettings_STATUS(source.CrossSubscriptionRestoreSettings)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_CrossSubscriptionRestoreSettings_STATUS() to populate field CrossSubscriptionRestoreSettings")
		}
		settings.CrossSubscriptionRestoreSettings = &crossSubscriptionRestoreSetting
	} else {
		settings.CrossSubscriptionRestoreSettings = nil
	}

	// No error
	return nil
}

// Class containing feature settings of vault
type FeatureSettings_STATUS struct {
	// CrossSubscriptionRestoreSettings: CrossSubscriptionRestore Settings
	CrossSubscriptionRestoreSettings *CrossSubscriptionRestoreSettings_STATUS `json:"crossSubscriptionRestoreSettings,omitempty"`
}

var _ genruntime.FromARMConverter = &FeatureSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *FeatureSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &FeatureSettings_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *FeatureSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(FeatureSettings_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected FeatureSettings_STATUS_ARM, got %T", armInput)
	}

	// Set property "CrossSubscriptionRestoreSettings":
	if typedInput.CrossSubscriptionRestoreSettings != nil {
		var crossSubscriptionRestoreSettings1 CrossSubscriptionRestoreSettings_STATUS
		err := crossSubscriptionRestoreSettings1.PopulateFromARM(owner, *typedInput.CrossSubscriptionRestoreSettings)
		if err != nil {
			return err
		}
		crossSubscriptionRestoreSettings := crossSubscriptionRestoreSettings1
		settings.CrossSubscriptionRestoreSettings = &crossSubscriptionRestoreSettings
	}

	// No error
	return nil
}

// AssignProperties_From_FeatureSettings_STATUS populates our FeatureSettings_STATUS from the provided source FeatureSettings_STATUS
func (settings *FeatureSettings_STATUS) AssignProperties_From_FeatureSettings_STATUS(source *v20230101s.FeatureSettings_STATUS) error {

	// CrossSubscriptionRestoreSettings
	if source.CrossSubscriptionRestoreSettings != nil {
		var crossSubscriptionRestoreSetting CrossSubscriptionRestoreSettings_STATUS
		err := crossSubscriptionRestoreSetting.AssignProperties_From_CrossSubscriptionRestoreSettings_STATUS(source.CrossSubscriptionRestoreSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CrossSubscriptionRestoreSettings_STATUS() to populate field CrossSubscriptionRestoreSettings")
		}
		settings.CrossSubscriptionRestoreSettings = &crossSubscriptionRestoreSetting
	} else {
		settings.CrossSubscriptionRestoreSettings = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FeatureSettings_STATUS populates the provided destination FeatureSettings_STATUS from our FeatureSettings_STATUS
func (settings *FeatureSettings_STATUS) AssignProperties_To_FeatureSettings_STATUS(destination *v20230101s.FeatureSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CrossSubscriptionRestoreSettings
	if settings.CrossSubscriptionRestoreSettings != nil {
		var crossSubscriptionRestoreSetting v20230101s.CrossSubscriptionRestoreSettings_STATUS
		err := settings.CrossSubscriptionRestoreSettings.AssignProperties_To_CrossSubscriptionRestoreSettings_STATUS(&crossSubscriptionRestoreSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CrossSubscriptionRestoreSettings_STATUS() to populate field CrossSubscriptionRestoreSettings")
		}
		destination.CrossSubscriptionRestoreSettings = &crossSubscriptionRestoreSetting
	} else {
		destination.CrossSubscriptionRestoreSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Monitoring Settings
type MonitoringSettings struct {
	// AzureMonitorAlertSettings: Settings for Azure Monitor based alerts
	AzureMonitorAlertSettings *AzureMonitorAlertSettings `json:"azureMonitorAlertSettings,omitempty"`
}

var _ genruntime.ARMTransformer = &MonitoringSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *MonitoringSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &MonitoringSettings_ARM{}

	// Set property "AzureMonitorAlertSettings":
	if settings.AzureMonitorAlertSettings != nil {
		azureMonitorAlertSettings_ARM, err := (*settings.AzureMonitorAlertSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		azureMonitorAlertSettings := *azureMonitorAlertSettings_ARM.(*AzureMonitorAlertSettings_ARM)
		result.AzureMonitorAlertSettings = &azureMonitorAlertSettings
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *MonitoringSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &MonitoringSettings_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *MonitoringSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(MonitoringSettings_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected MonitoringSettings_ARM, got %T", armInput)
	}

	// Set property "AzureMonitorAlertSettings":
	if typedInput.AzureMonitorAlertSettings != nil {
		var azureMonitorAlertSettings1 AzureMonitorAlertSettings
		err := azureMonitorAlertSettings1.PopulateFromARM(owner, *typedInput.AzureMonitorAlertSettings)
		if err != nil {
			return err
		}
		azureMonitorAlertSettings := azureMonitorAlertSettings1
		settings.AzureMonitorAlertSettings = &azureMonitorAlertSettings
	}

	// No error
	return nil
}

// AssignProperties_From_MonitoringSettings populates our MonitoringSettings from the provided source MonitoringSettings
func (settings *MonitoringSettings) AssignProperties_From_MonitoringSettings(source *v20230101s.MonitoringSettings) error {

	// AzureMonitorAlertSettings
	if source.AzureMonitorAlertSettings != nil {
		var azureMonitorAlertSetting AzureMonitorAlertSettings
		err := azureMonitorAlertSetting.AssignProperties_From_AzureMonitorAlertSettings(source.AzureMonitorAlertSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AzureMonitorAlertSettings() to populate field AzureMonitorAlertSettings")
		}
		settings.AzureMonitorAlertSettings = &azureMonitorAlertSetting
	} else {
		settings.AzureMonitorAlertSettings = nil
	}

	// No error
	return nil
}

// AssignProperties_To_MonitoringSettings populates the provided destination MonitoringSettings from our MonitoringSettings
func (settings *MonitoringSettings) AssignProperties_To_MonitoringSettings(destination *v20230101s.MonitoringSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureMonitorAlertSettings
	if settings.AzureMonitorAlertSettings != nil {
		var azureMonitorAlertSetting v20230101s.AzureMonitorAlertSettings
		err := settings.AzureMonitorAlertSettings.AssignProperties_To_AzureMonitorAlertSettings(&azureMonitorAlertSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AzureMonitorAlertSettings() to populate field AzureMonitorAlertSettings")
		}
		destination.AzureMonitorAlertSettings = &azureMonitorAlertSetting
	} else {
		destination.AzureMonitorAlertSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_MonitoringSettings_STATUS populates our MonitoringSettings from the provided source MonitoringSettings_STATUS
func (settings *MonitoringSettings) Initialize_From_MonitoringSettings_STATUS(source *MonitoringSettings_STATUS) error {

	// AzureMonitorAlertSettings
	if source.AzureMonitorAlertSettings != nil {
		var azureMonitorAlertSetting AzureMonitorAlertSettings
		err := azureMonitorAlertSetting.Initialize_From_AzureMonitorAlertSettings_STATUS(source.AzureMonitorAlertSettings)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_AzureMonitorAlertSettings_STATUS() to populate field AzureMonitorAlertSettings")
		}
		settings.AzureMonitorAlertSettings = &azureMonitorAlertSetting
	} else {
		settings.AzureMonitorAlertSettings = nil
	}

	// No error
	return nil
}

// Monitoring Settings
type MonitoringSettings_STATUS struct {
	// AzureMonitorAlertSettings: Settings for Azure Monitor based alerts
	AzureMonitorAlertSettings *AzureMonitorAlertSettings_STATUS `json:"azureMonitorAlertSettings,omitempty"`
}

var _ genruntime.FromARMConverter = &MonitoringSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *MonitoringSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &MonitoringSettings_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *MonitoringSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(MonitoringSettings_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected MonitoringSettings_STATUS_ARM, got %T", armInput)
	}

	// Set property "AzureMonitorAlertSettings":
	if typedInput.AzureMonitorAlertSettings != nil {
		var azureMonitorAlertSettings1 AzureMonitorAlertSettings_STATUS
		err := azureMonitorAlertSettings1.PopulateFromARM(owner, *typedInput.AzureMonitorAlertSettings)
		if err != nil {
			return err
		}
		azureMonitorAlertSettings := azureMonitorAlertSettings1
		settings.AzureMonitorAlertSettings = &azureMonitorAlertSettings
	}

	// No error
	return nil
}

// AssignProperties_From_MonitoringSettings_STATUS populates our MonitoringSettings_STATUS from the provided source MonitoringSettings_STATUS
func (settings *MonitoringSettings_STATUS) AssignProperties_From_MonitoringSettings_STATUS(source *v20230101s.MonitoringSettings_STATUS) error {

	// AzureMonitorAlertSettings
	if source.AzureMonitorAlertSettings != nil {
		var azureMonitorAlertSetting AzureMonitorAlertSettings_STATUS
		err := azureMonitorAlertSetting.AssignProperties_From_AzureMonitorAlertSettings_STATUS(source.AzureMonitorAlertSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AzureMonitorAlertSettings_STATUS() to populate field AzureMonitorAlertSettings")
		}
		settings.AzureMonitorAlertSettings = &azureMonitorAlertSetting
	} else {
		settings.AzureMonitorAlertSettings = nil
	}

	// No error
	return nil
}

// AssignProperties_To_MonitoringSettings_STATUS populates the provided destination MonitoringSettings_STATUS from our MonitoringSettings_STATUS
func (settings *MonitoringSettings_STATUS) AssignProperties_To_MonitoringSettings_STATUS(destination *v20230101s.MonitoringSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureMonitorAlertSettings
	if settings.AzureMonitorAlertSettings != nil {
		var azureMonitorAlertSetting v20230101s.AzureMonitorAlertSettings_STATUS
		err := settings.AzureMonitorAlertSettings.AssignProperties_To_AzureMonitorAlertSettings_STATUS(&azureMonitorAlertSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AzureMonitorAlertSettings_STATUS() to populate field AzureMonitorAlertSettings")
		}
		destination.AzureMonitorAlertSettings = &azureMonitorAlertSetting
	} else {
		destination.AzureMonitorAlertSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// ResourceMoveDetails will be returned in response to GetResource call from ARM
type ResourceMoveDetails_STATUS struct {
	// CompletionTimeUtc: Completion time in UTC of latest ResourceMove operation attempted. ISO 8601 format.
	CompletionTimeUtc *string `json:"completionTimeUtc,omitempty"`

	// OperationId: CorrelationId of latest ResourceMove operation attempted
	OperationId *string `json:"operationId,omitempty"`

	// SourceResourcePath: ARM resource path of source resource
	SourceResourcePath *string `json:"sourceResourcePath,omitempty"`

	// StartTimeUtc: Start time in UTC of latest ResourceMove operation attempted. ISO 8601 format.
	StartTimeUtc *string `json:"startTimeUtc,omitempty"`

	// TargetResourcePath: ARM resource path of target resource used in latest ResourceMove operation
	TargetResourcePath *string `json:"targetResourcePath,omitempty"`
}

var _ genruntime.FromARMConverter = &ResourceMoveDetails_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (details *ResourceMoveDetails_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ResourceMoveDetails_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (details *ResourceMoveDetails_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ResourceMoveDetails_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ResourceMoveDetails_STATUS_ARM, got %T", armInput)
	}

	// Set property "CompletionTimeUtc":
	if typedInput.CompletionTimeUtc != nil {
		completionTimeUtc := *typedInput.CompletionTimeUtc
		details.CompletionTimeUtc = &completionTimeUtc
	}

	// Set property "OperationId":
	if typedInput.OperationId != nil {
		operationId := *typedInput.OperationId
		details.OperationId = &operationId
	}

	// Set property "SourceResourcePath":
	if typedInput.SourceResourcePath != nil {
		sourceResourcePath := *typedInput.SourceResourcePath
		details.SourceResourcePath = &sourceResourcePath
	}

	// Set property "StartTimeUtc":
	if typedInput.StartTimeUtc != nil {
		startTimeUtc := *typedInput.StartTimeUtc
		details.StartTimeUtc = &startTimeUtc
	}

	// Set property "TargetResourcePath":
	if typedInput.TargetResourcePath != nil {
		targetResourcePath := *typedInput.TargetResourcePath
		details.TargetResourcePath = &targetResourcePath
	}

	// No error
	return nil
}

// AssignProperties_From_ResourceMoveDetails_STATUS populates our ResourceMoveDetails_STATUS from the provided source ResourceMoveDetails_STATUS
func (details *ResourceMoveDetails_STATUS) AssignProperties_From_ResourceMoveDetails_STATUS(source *v20230101s.ResourceMoveDetails_STATUS) error {

	// CompletionTimeUtc
	details.CompletionTimeUtc = genruntime.ClonePointerToString(source.CompletionTimeUtc)

	// OperationId
	details.OperationId = genruntime.ClonePointerToString(source.OperationId)

	// SourceResourcePath
	details.SourceResourcePath = genruntime.ClonePointerToString(source.SourceResourcePath)

	// StartTimeUtc
	details.StartTimeUtc = genruntime.ClonePointerToString(source.StartTimeUtc)

	// TargetResourcePath
	details.TargetResourcePath = genruntime.ClonePointerToString(source.TargetResourcePath)

	// No error
	return nil
}

// AssignProperties_To_ResourceMoveDetails_STATUS populates the provided destination ResourceMoveDetails_STATUS from our ResourceMoveDetails_STATUS
func (details *ResourceMoveDetails_STATUS) AssignProperties_To_ResourceMoveDetails_STATUS(destination *v20230101s.ResourceMoveDetails_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CompletionTimeUtc
	destination.CompletionTimeUtc = genruntime.ClonePointerToString(details.CompletionTimeUtc)

	// OperationId
	destination.OperationId = genruntime.ClonePointerToString(details.OperationId)

	// SourceResourcePath
	destination.SourceResourcePath = genruntime.ClonePointerToString(details.SourceResourcePath)

	// StartTimeUtc
	destination.StartTimeUtc = genruntime.ClonePointerToString(details.StartTimeUtc)

	// TargetResourcePath
	destination.TargetResourcePath = genruntime.ClonePointerToString(details.TargetResourcePath)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Class containing security settings of vault
type SecuritySettings struct {
	// ImmutabilitySettings: Immutability Settings at vault level
	ImmutabilitySettings *ImmutabilitySettings `json:"immutabilitySettings,omitempty"`

	// SoftDeleteSettings: Soft delete related settings
	SoftDeleteSettings *SoftDeleteSettings `json:"softDeleteSettings,omitempty"`
}

var _ genruntime.ARMTransformer = &SecuritySettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *SecuritySettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &SecuritySettings_ARM{}

	// Set property "ImmutabilitySettings":
	if settings.ImmutabilitySettings != nil {
		immutabilitySettings_ARM, err := (*settings.ImmutabilitySettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		immutabilitySettings := *immutabilitySettings_ARM.(*ImmutabilitySettings_ARM)
		result.ImmutabilitySettings = &immutabilitySettings
	}

	// Set property "SoftDeleteSettings":
	if settings.SoftDeleteSettings != nil {
		softDeleteSettings_ARM, err := (*settings.SoftDeleteSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		softDeleteSettings := *softDeleteSettings_ARM.(*SoftDeleteSettings_ARM)
		result.SoftDeleteSettings = &softDeleteSettings
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *SecuritySettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SecuritySettings_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *SecuritySettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SecuritySettings_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SecuritySettings_ARM, got %T", armInput)
	}

	// Set property "ImmutabilitySettings":
	if typedInput.ImmutabilitySettings != nil {
		var immutabilitySettings1 ImmutabilitySettings
		err := immutabilitySettings1.PopulateFromARM(owner, *typedInput.ImmutabilitySettings)
		if err != nil {
			return err
		}
		immutabilitySettings := immutabilitySettings1
		settings.ImmutabilitySettings = &immutabilitySettings
	}

	// Set property "SoftDeleteSettings":
	if typedInput.SoftDeleteSettings != nil {
		var softDeleteSettings1 SoftDeleteSettings
		err := softDeleteSettings1.PopulateFromARM(owner, *typedInput.SoftDeleteSettings)
		if err != nil {
			return err
		}
		softDeleteSettings := softDeleteSettings1
		settings.SoftDeleteSettings = &softDeleteSettings
	}

	// No error
	return nil
}

// AssignProperties_From_SecuritySettings populates our SecuritySettings from the provided source SecuritySettings
func (settings *SecuritySettings) AssignProperties_From_SecuritySettings(source *v20230101s.SecuritySettings) error {

	// ImmutabilitySettings
	if source.ImmutabilitySettings != nil {
		var immutabilitySetting ImmutabilitySettings
		err := immutabilitySetting.AssignProperties_From_ImmutabilitySettings(source.ImmutabilitySettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ImmutabilitySettings() to populate field ImmutabilitySettings")
		}
		settings.ImmutabilitySettings = &immutabilitySetting
	} else {
		settings.ImmutabilitySettings = nil
	}

	// SoftDeleteSettings
	if source.SoftDeleteSettings != nil {
		var softDeleteSetting SoftDeleteSettings
		err := softDeleteSetting.AssignProperties_From_SoftDeleteSettings(source.SoftDeleteSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SoftDeleteSettings() to populate field SoftDeleteSettings")
		}
		settings.SoftDeleteSettings = &softDeleteSetting
	} else {
		settings.SoftDeleteSettings = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SecuritySettings populates the provided destination SecuritySettings from our SecuritySettings
func (settings *SecuritySettings) AssignProperties_To_SecuritySettings(destination *v20230101s.SecuritySettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ImmutabilitySettings
	if settings.ImmutabilitySettings != nil {
		var immutabilitySetting v20230101s.ImmutabilitySettings
		err := settings.ImmutabilitySettings.AssignProperties_To_ImmutabilitySettings(&immutabilitySetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ImmutabilitySettings() to populate field ImmutabilitySettings")
		}
		destination.ImmutabilitySettings = &immutabilitySetting
	} else {
		destination.ImmutabilitySettings = nil
	}

	// SoftDeleteSettings
	if settings.SoftDeleteSettings != nil {
		var softDeleteSetting v20230101s.SoftDeleteSettings
		err := settings.SoftDeleteSettings.AssignProperties_To_SoftDeleteSettings(&softDeleteSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SoftDeleteSettings() to populate field SoftDeleteSettings")
		}
		destination.SoftDeleteSettings = &softDeleteSetting
	} else {
		destination.SoftDeleteSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_SecuritySettings_STATUS populates our SecuritySettings from the provided source SecuritySettings_STATUS
func (settings *SecuritySettings) Initialize_From_SecuritySettings_STATUS(source *SecuritySettings_STATUS) error {

	// ImmutabilitySettings
	if source.ImmutabilitySettings != nil {
		var immutabilitySetting ImmutabilitySettings
		err := immutabilitySetting.Initialize_From_ImmutabilitySettings_STATUS(source.ImmutabilitySettings)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ImmutabilitySettings_STATUS() to populate field ImmutabilitySettings")
		}
		settings.ImmutabilitySettings = &immutabilitySetting
	} else {
		settings.ImmutabilitySettings = nil
	}

	// SoftDeleteSettings
	if source.SoftDeleteSettings != nil {
		var softDeleteSetting SoftDeleteSettings
		err := softDeleteSetting.Initialize_From_SoftDeleteSettings_STATUS(source.SoftDeleteSettings)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SoftDeleteSettings_STATUS() to populate field SoftDeleteSettings")
		}
		settings.SoftDeleteSettings = &softDeleteSetting
	} else {
		settings.SoftDeleteSettings = nil
	}

	// No error
	return nil
}

// Class containing security settings of vault
type SecuritySettings_STATUS struct {
	// ImmutabilitySettings: Immutability Settings at vault level
	ImmutabilitySettings *ImmutabilitySettings_STATUS `json:"immutabilitySettings,omitempty"`

	// SoftDeleteSettings: Soft delete related settings
	SoftDeleteSettings *SoftDeleteSettings_STATUS `json:"softDeleteSettings,omitempty"`
}

var _ genruntime.FromARMConverter = &SecuritySettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *SecuritySettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SecuritySettings_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *SecuritySettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SecuritySettings_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SecuritySettings_STATUS_ARM, got %T", armInput)
	}

	// Set property "ImmutabilitySettings":
	if typedInput.ImmutabilitySettings != nil {
		var immutabilitySettings1 ImmutabilitySettings_STATUS
		err := immutabilitySettings1.PopulateFromARM(owner, *typedInput.ImmutabilitySettings)
		if err != nil {
			return err
		}
		immutabilitySettings := immutabilitySettings1
		settings.ImmutabilitySettings = &immutabilitySettings
	}

	// Set property "SoftDeleteSettings":
	if typedInput.SoftDeleteSettings != nil {
		var softDeleteSettings1 SoftDeleteSettings_STATUS
		err := softDeleteSettings1.PopulateFromARM(owner, *typedInput.SoftDeleteSettings)
		if err != nil {
			return err
		}
		softDeleteSettings := softDeleteSettings1
		settings.SoftDeleteSettings = &softDeleteSettings
	}

	// No error
	return nil
}

// AssignProperties_From_SecuritySettings_STATUS populates our SecuritySettings_STATUS from the provided source SecuritySettings_STATUS
func (settings *SecuritySettings_STATUS) AssignProperties_From_SecuritySettings_STATUS(source *v20230101s.SecuritySettings_STATUS) error {

	// ImmutabilitySettings
	if source.ImmutabilitySettings != nil {
		var immutabilitySetting ImmutabilitySettings_STATUS
		err := immutabilitySetting.AssignProperties_From_ImmutabilitySettings_STATUS(source.ImmutabilitySettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ImmutabilitySettings_STATUS() to populate field ImmutabilitySettings")
		}
		settings.ImmutabilitySettings = &immutabilitySetting
	} else {
		settings.ImmutabilitySettings = nil
	}

	// SoftDeleteSettings
	if source.SoftDeleteSettings != nil {
		var softDeleteSetting SoftDeleteSettings_STATUS
		err := softDeleteSetting.AssignProperties_From_SoftDeleteSettings_STATUS(source.SoftDeleteSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SoftDeleteSettings_STATUS() to populate field SoftDeleteSettings")
		}
		settings.SoftDeleteSettings = &softDeleteSetting
	} else {
		settings.SoftDeleteSettings = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SecuritySettings_STATUS populates the provided destination SecuritySettings_STATUS from our SecuritySettings_STATUS
func (settings *SecuritySettings_STATUS) AssignProperties_To_SecuritySettings_STATUS(destination *v20230101s.SecuritySettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ImmutabilitySettings
	if settings.ImmutabilitySettings != nil {
		var immutabilitySetting v20230101s.ImmutabilitySettings_STATUS
		err := settings.ImmutabilitySettings.AssignProperties_To_ImmutabilitySettings_STATUS(&immutabilitySetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ImmutabilitySettings_STATUS() to populate field ImmutabilitySettings")
		}
		destination.ImmutabilitySettings = &immutabilitySetting
	} else {
		destination.ImmutabilitySettings = nil
	}

	// SoftDeleteSettings
	if settings.SoftDeleteSettings != nil {
		var softDeleteSetting v20230101s.SoftDeleteSettings_STATUS
		err := settings.SoftDeleteSettings.AssignProperties_To_SoftDeleteSettings_STATUS(&softDeleteSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SoftDeleteSettings_STATUS() to populate field SoftDeleteSettings")
		}
		destination.SoftDeleteSettings = &softDeleteSetting
	} else {
		destination.SoftDeleteSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage setting
type StorageSetting struct {
	// DatastoreType: Gets or sets the type of the datastore.
	DatastoreType *StorageSetting_DatastoreType `json:"datastoreType,omitempty"`

	// Type: Gets or sets the type.
	Type *StorageSetting_Type `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &StorageSetting{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (setting *StorageSetting) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if setting == nil {
		return nil, nil
	}
	result := &StorageSetting_ARM{}

	// Set property "DatastoreType":
	if setting.DatastoreType != nil {
		datastoreType := *setting.DatastoreType
		result.DatastoreType = &datastoreType
	}

	// Set property "Type":
	if setting.Type != nil {
		typeVar := *setting.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (setting *StorageSetting) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &StorageSetting_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (setting *StorageSetting) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(StorageSetting_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected StorageSetting_ARM, got %T", armInput)
	}

	// Set property "DatastoreType":
	if typedInput.DatastoreType != nil {
		datastoreType := *typedInput.DatastoreType
		setting.DatastoreType = &datastoreType
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		setting.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_StorageSetting populates our StorageSetting from the provided source StorageSetting
func (setting *StorageSetting) AssignProperties_From_StorageSetting(source *v20230101s.StorageSetting) error {

	// DatastoreType
	if source.DatastoreType != nil {
		datastoreType := StorageSetting_DatastoreType(*source.DatastoreType)
		setting.DatastoreType = &datastoreType
	} else {
		setting.DatastoreType = nil
	}

	// Type
	if source.Type != nil {
		typeVar := StorageSetting_Type(*source.Type)
		setting.Type = &typeVar
	} else {
		setting.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_StorageSetting populates the provided destination StorageSetting from our StorageSetting
func (setting *StorageSetting) AssignProperties_To_StorageSetting(destination *v20230101s.StorageSetting) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DatastoreType
	if setting.DatastoreType != nil {
		datastoreType := string(*setting.DatastoreType)
		destination.DatastoreType = &datastoreType
	} else {
		destination.DatastoreType = nil
	}

	// Type
	if setting.Type != nil {
		typeVar := string(*setting.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_StorageSetting_STATUS populates our StorageSetting from the provided source StorageSetting_STATUS
func (setting *StorageSetting) Initialize_From_StorageSetting_STATUS(source *StorageSetting_STATUS) error {

	// DatastoreType
	if source.DatastoreType != nil {
		datastoreType := StorageSetting_DatastoreType(*source.DatastoreType)
		setting.DatastoreType = &datastoreType
	} else {
		setting.DatastoreType = nil
	}

	// Type
	if source.Type != nil {
		typeVar := StorageSetting_Type(*source.Type)
		setting.Type = &typeVar
	} else {
		setting.Type = nil
	}

	// No error
	return nil
}

// Storage setting
type StorageSetting_STATUS struct {
	// DatastoreType: Gets or sets the type of the datastore.
	DatastoreType *StorageSetting_DatastoreType_STATUS `json:"datastoreType,omitempty"`

	// Type: Gets or sets the type.
	Type *StorageSetting_Type_STATUS `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &StorageSetting_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (setting *StorageSetting_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &StorageSetting_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (setting *StorageSetting_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(StorageSetting_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected StorageSetting_STATUS_ARM, got %T", armInput)
	}

	// Set property "DatastoreType":
	if typedInput.DatastoreType != nil {
		datastoreType := *typedInput.DatastoreType
		setting.DatastoreType = &datastoreType
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		setting.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_StorageSetting_STATUS populates our StorageSetting_STATUS from the provided source StorageSetting_STATUS
func (setting *StorageSetting_STATUS) AssignProperties_From_StorageSetting_STATUS(source *v20230101s.StorageSetting_STATUS) error {

	// DatastoreType
	if source.DatastoreType != nil {
		datastoreType := StorageSetting_DatastoreType_STATUS(*source.DatastoreType)
		setting.DatastoreType = &datastoreType
	} else {
		setting.DatastoreType = nil
	}

	// Type
	if source.Type != nil {
		typeVar := StorageSetting_Type_STATUS(*source.Type)
		setting.Type = &typeVar
	} else {
		setting.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_StorageSetting_STATUS populates the provided destination StorageSetting_STATUS from our StorageSetting_STATUS
func (setting *StorageSetting_STATUS) AssignProperties_To_StorageSetting_STATUS(destination *v20230101s.StorageSetting_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DatastoreType
	if setting.DatastoreType != nil {
		datastoreType := string(*setting.DatastoreType)
		destination.DatastoreType = &datastoreType
	} else {
		destination.DatastoreType = nil
	}

	// Type
	if setting.Type != nil {
		typeVar := string(*setting.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Settings for Azure Monitor based alerts
type AzureMonitorAlertSettings struct {
	AlertsForAllJobFailures *AzureMonitorAlertSettings_AlertsForAllJobFailures `json:"alertsForAllJobFailures,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureMonitorAlertSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *AzureMonitorAlertSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &AzureMonitorAlertSettings_ARM{}

	// Set property "AlertsForAllJobFailures":
	if settings.AlertsForAllJobFailures != nil {
		alertsForAllJobFailures := *settings.AlertsForAllJobFailures
		result.AlertsForAllJobFailures = &alertsForAllJobFailures
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *AzureMonitorAlertSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AzureMonitorAlertSettings_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *AzureMonitorAlertSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AzureMonitorAlertSettings_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AzureMonitorAlertSettings_ARM, got %T", armInput)
	}

	// Set property "AlertsForAllJobFailures":
	if typedInput.AlertsForAllJobFailures != nil {
		alertsForAllJobFailures := *typedInput.AlertsForAllJobFailures
		settings.AlertsForAllJobFailures = &alertsForAllJobFailures
	}

	// No error
	return nil
}

// AssignProperties_From_AzureMonitorAlertSettings populates our AzureMonitorAlertSettings from the provided source AzureMonitorAlertSettings
func (settings *AzureMonitorAlertSettings) AssignProperties_From_AzureMonitorAlertSettings(source *v20230101s.AzureMonitorAlertSettings) error {

	// AlertsForAllJobFailures
	if source.AlertsForAllJobFailures != nil {
		alertsForAllJobFailure := AzureMonitorAlertSettings_AlertsForAllJobFailures(*source.AlertsForAllJobFailures)
		settings.AlertsForAllJobFailures = &alertsForAllJobFailure
	} else {
		settings.AlertsForAllJobFailures = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureMonitorAlertSettings populates the provided destination AzureMonitorAlertSettings from our AzureMonitorAlertSettings
func (settings *AzureMonitorAlertSettings) AssignProperties_To_AzureMonitorAlertSettings(destination *v20230101s.AzureMonitorAlertSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AlertsForAllJobFailures
	if settings.AlertsForAllJobFailures != nil {
		alertsForAllJobFailure := string(*settings.AlertsForAllJobFailures)
		destination.AlertsForAllJobFailures = &alertsForAllJobFailure
	} else {
		destination.AlertsForAllJobFailures = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AzureMonitorAlertSettings_STATUS populates our AzureMonitorAlertSettings from the provided source AzureMonitorAlertSettings_STATUS
func (settings *AzureMonitorAlertSettings) Initialize_From_AzureMonitorAlertSettings_STATUS(source *AzureMonitorAlertSettings_STATUS) error {

	// AlertsForAllJobFailures
	if source.AlertsForAllJobFailures != nil {
		alertsForAllJobFailure := AzureMonitorAlertSettings_AlertsForAllJobFailures(*source.AlertsForAllJobFailures)
		settings.AlertsForAllJobFailures = &alertsForAllJobFailure
	} else {
		settings.AlertsForAllJobFailures = nil
	}

	// No error
	return nil
}

// Settings for Azure Monitor based alerts
type AzureMonitorAlertSettings_STATUS struct {
	AlertsForAllJobFailures *AzureMonitorAlertSettings_AlertsForAllJobFailures_STATUS `json:"alertsForAllJobFailures,omitempty"`
}

var _ genruntime.FromARMConverter = &AzureMonitorAlertSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *AzureMonitorAlertSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &AzureMonitorAlertSettings_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *AzureMonitorAlertSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AzureMonitorAlertSettings_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AzureMonitorAlertSettings_STATUS_ARM, got %T", armInput)
	}

	// Set property "AlertsForAllJobFailures":
	if typedInput.AlertsForAllJobFailures != nil {
		alertsForAllJobFailures := *typedInput.AlertsForAllJobFailures
		settings.AlertsForAllJobFailures = &alertsForAllJobFailures
	}

	// No error
	return nil
}

// AssignProperties_From_AzureMonitorAlertSettings_STATUS populates our AzureMonitorAlertSettings_STATUS from the provided source AzureMonitorAlertSettings_STATUS
func (settings *AzureMonitorAlertSettings_STATUS) AssignProperties_From_AzureMonitorAlertSettings_STATUS(source *v20230101s.AzureMonitorAlertSettings_STATUS) error {

	// AlertsForAllJobFailures
	if source.AlertsForAllJobFailures != nil {
		alertsForAllJobFailure := AzureMonitorAlertSettings_AlertsForAllJobFailures_STATUS(*source.AlertsForAllJobFailures)
		settings.AlertsForAllJobFailures = &alertsForAllJobFailure
	} else {
		settings.AlertsForAllJobFailures = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureMonitorAlertSettings_STATUS populates the provided destination AzureMonitorAlertSettings_STATUS from our AzureMonitorAlertSettings_STATUS
func (settings *AzureMonitorAlertSettings_STATUS) AssignProperties_To_AzureMonitorAlertSettings_STATUS(destination *v20230101s.AzureMonitorAlertSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AlertsForAllJobFailures
	if settings.AlertsForAllJobFailures != nil {
		alertsForAllJobFailure := string(*settings.AlertsForAllJobFailures)
		destination.AlertsForAllJobFailures = &alertsForAllJobFailure
	} else {
		destination.AlertsForAllJobFailures = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// CrossSubscriptionRestore Settings
type CrossSubscriptionRestoreSettings struct {
	// State: CrossSubscriptionRestore state
	State *CrossSubscriptionRestoreSettings_State `json:"state,omitempty"`
}

var _ genruntime.ARMTransformer = &CrossSubscriptionRestoreSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *CrossSubscriptionRestoreSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &CrossSubscriptionRestoreSettings_ARM{}

	// Set property "State":
	if settings.State != nil {
		state := *settings.State
		result.State = &state
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *CrossSubscriptionRestoreSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CrossSubscriptionRestoreSettings_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *CrossSubscriptionRestoreSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CrossSubscriptionRestoreSettings_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CrossSubscriptionRestoreSettings_ARM, got %T", armInput)
	}

	// Set property "State":
	if typedInput.State != nil {
		state := *typedInput.State
		settings.State = &state
	}

	// No error
	return nil
}

// AssignProperties_From_CrossSubscriptionRestoreSettings populates our CrossSubscriptionRestoreSettings from the provided source CrossSubscriptionRestoreSettings
func (settings *CrossSubscriptionRestoreSettings) AssignProperties_From_CrossSubscriptionRestoreSettings(source *v20230101s.CrossSubscriptionRestoreSettings) error {

	// State
	if source.State != nil {
		state := CrossSubscriptionRestoreSettings_State(*source.State)
		settings.State = &state
	} else {
		settings.State = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CrossSubscriptionRestoreSettings populates the provided destination CrossSubscriptionRestoreSettings from our CrossSubscriptionRestoreSettings
func (settings *CrossSubscriptionRestoreSettings) AssignProperties_To_CrossSubscriptionRestoreSettings(destination *v20230101s.CrossSubscriptionRestoreSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// State
	if settings.State != nil {
		state := string(*settings.State)
		destination.State = &state
	} else {
		destination.State = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_CrossSubscriptionRestoreSettings_STATUS populates our CrossSubscriptionRestoreSettings from the provided source CrossSubscriptionRestoreSettings_STATUS
func (settings *CrossSubscriptionRestoreSettings) Initialize_From_CrossSubscriptionRestoreSettings_STATUS(source *CrossSubscriptionRestoreSettings_STATUS) error {

	// State
	if source.State != nil {
		state := CrossSubscriptionRestoreSettings_State(*source.State)
		settings.State = &state
	} else {
		settings.State = nil
	}

	// No error
	return nil
}

// CrossSubscriptionRestore Settings
type CrossSubscriptionRestoreSettings_STATUS struct {
	// State: CrossSubscriptionRestore state
	State *CrossSubscriptionRestoreSettings_State_STATUS `json:"state,omitempty"`
}

var _ genruntime.FromARMConverter = &CrossSubscriptionRestoreSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *CrossSubscriptionRestoreSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CrossSubscriptionRestoreSettings_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *CrossSubscriptionRestoreSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CrossSubscriptionRestoreSettings_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CrossSubscriptionRestoreSettings_STATUS_ARM, got %T", armInput)
	}

	// Set property "State":
	if typedInput.State != nil {
		state := *typedInput.State
		settings.State = &state
	}

	// No error
	return nil
}

// AssignProperties_From_CrossSubscriptionRestoreSettings_STATUS populates our CrossSubscriptionRestoreSettings_STATUS from the provided source CrossSubscriptionRestoreSettings_STATUS
func (settings *CrossSubscriptionRestoreSettings_STATUS) AssignProperties_From_CrossSubscriptionRestoreSettings_STATUS(source *v20230101s.CrossSubscriptionRestoreSettings_STATUS) error {

	// State
	if source.State != nil {
		state := CrossSubscriptionRestoreSettings_State_STATUS(*source.State)
		settings.State = &state
	} else {
		settings.State = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CrossSubscriptionRestoreSettings_STATUS populates the provided destination CrossSubscriptionRestoreSettings_STATUS from our CrossSubscriptionRestoreSettings_STATUS
func (settings *CrossSubscriptionRestoreSettings_STATUS) AssignProperties_To_CrossSubscriptionRestoreSettings_STATUS(destination *v20230101s.CrossSubscriptionRestoreSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// State
	if settings.State != nil {
		state := string(*settings.State)
		destination.State = &state
	} else {
		destination.State = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Immutability Settings at vault level
type ImmutabilitySettings struct {
	// State: Immutability state
	State *ImmutabilitySettings_State `json:"state,omitempty"`
}

var _ genruntime.ARMTransformer = &ImmutabilitySettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *ImmutabilitySettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &ImmutabilitySettings_ARM{}

	// Set property "State":
	if settings.State != nil {
		state := *settings.State
		result.State = &state
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *ImmutabilitySettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ImmutabilitySettings_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *ImmutabilitySettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ImmutabilitySettings_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ImmutabilitySettings_ARM, got %T", armInput)
	}

	// Set property "State":
	if typedInput.State != nil {
		state := *typedInput.State
		settings.State = &state
	}

	// No error
	return nil
}

// AssignProperties_From_ImmutabilitySettings populates our ImmutabilitySettings from the provided source ImmutabilitySettings
func (settings *ImmutabilitySettings) AssignProperties_From_ImmutabilitySettings(source *v20230101s.ImmutabilitySettings) error {

	// State
	if source.State != nil {
		state := ImmutabilitySettings_State(*source.State)
		settings.State = &state
	} else {
		settings.State = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ImmutabilitySettings populates the provided destination ImmutabilitySettings from our ImmutabilitySettings
func (settings *ImmutabilitySettings) AssignProperties_To_ImmutabilitySettings(destination *v20230101s.ImmutabilitySettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// State
	if settings.State != nil {
		state := string(*settings.State)
		destination.State = &state
	} else {
		destination.State = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ImmutabilitySettings_STATUS populates our ImmutabilitySettings from the provided source ImmutabilitySettings_STATUS
func (settings *ImmutabilitySettings) Initialize_From_ImmutabilitySettings_STATUS(source *ImmutabilitySettings_STATUS) error {

	// State
	if source.State != nil {
		state := ImmutabilitySettings_State(*source.State)
		settings.State = &state
	} else {
		settings.State = nil
	}

	// No error
	return nil
}

// Immutability Settings at vault level
type ImmutabilitySettings_STATUS struct {
	// State: Immutability state
	State *ImmutabilitySettings_State_STATUS `json:"state,omitempty"`
}

var _ genruntime.FromARMConverter = &ImmutabilitySettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *ImmutabilitySettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ImmutabilitySettings_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *ImmutabilitySettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ImmutabilitySettings_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ImmutabilitySettings_STATUS_ARM, got %T", armInput)
	}

	// Set property "State":
	if typedInput.State != nil {
		state := *typedInput.State
		settings.State = &state
	}

	// No error
	return nil
}

// AssignProperties_From_ImmutabilitySettings_STATUS populates our ImmutabilitySettings_STATUS from the provided source ImmutabilitySettings_STATUS
func (settings *ImmutabilitySettings_STATUS) AssignProperties_From_ImmutabilitySettings_STATUS(source *v20230101s.ImmutabilitySettings_STATUS) error {

	// State
	if source.State != nil {
		state := ImmutabilitySettings_State_STATUS(*source.State)
		settings.State = &state
	} else {
		settings.State = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ImmutabilitySettings_STATUS populates the provided destination ImmutabilitySettings_STATUS from our ImmutabilitySettings_STATUS
func (settings *ImmutabilitySettings_STATUS) AssignProperties_To_ImmutabilitySettings_STATUS(destination *v20230101s.ImmutabilitySettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// State
	if settings.State != nil {
		state := string(*settings.State)
		destination.State = &state
	} else {
		destination.State = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Soft delete related settings
type SoftDeleteSettings struct {
	// RetentionDurationInDays: Soft delete retention duration
	RetentionDurationInDays *float64 `json:"retentionDurationInDays,omitempty"`

	// State: State of soft delete
	State *SoftDeleteSettings_State `json:"state,omitempty"`
}

var _ genruntime.ARMTransformer = &SoftDeleteSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *SoftDeleteSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &SoftDeleteSettings_ARM{}

	// Set property "RetentionDurationInDays":
	if settings.RetentionDurationInDays != nil {
		retentionDurationInDays := *settings.RetentionDurationInDays
		result.RetentionDurationInDays = &retentionDurationInDays
	}

	// Set property "State":
	if settings.State != nil {
		state := *settings.State
		result.State = &state
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *SoftDeleteSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SoftDeleteSettings_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *SoftDeleteSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SoftDeleteSettings_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SoftDeleteSettings_ARM, got %T", armInput)
	}

	// Set property "RetentionDurationInDays":
	if typedInput.RetentionDurationInDays != nil {
		retentionDurationInDays := *typedInput.RetentionDurationInDays
		settings.RetentionDurationInDays = &retentionDurationInDays
	}

	// Set property "State":
	if typedInput.State != nil {
		state := *typedInput.State
		settings.State = &state
	}

	// No error
	return nil
}

// AssignProperties_From_SoftDeleteSettings populates our SoftDeleteSettings from the provided source SoftDeleteSettings
func (settings *SoftDeleteSettings) AssignProperties_From_SoftDeleteSettings(source *v20230101s.SoftDeleteSettings) error {

	// RetentionDurationInDays
	if source.RetentionDurationInDays != nil {
		retentionDurationInDay := *source.RetentionDurationInDays
		settings.RetentionDurationInDays = &retentionDurationInDay
	} else {
		settings.RetentionDurationInDays = nil
	}

	// State
	if source.State != nil {
		state := SoftDeleteSettings_State(*source.State)
		settings.State = &state
	} else {
		settings.State = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SoftDeleteSettings populates the provided destination SoftDeleteSettings from our SoftDeleteSettings
func (settings *SoftDeleteSettings) AssignProperties_To_SoftDeleteSettings(destination *v20230101s.SoftDeleteSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RetentionDurationInDays
	if settings.RetentionDurationInDays != nil {
		retentionDurationInDay := *settings.RetentionDurationInDays
		destination.RetentionDurationInDays = &retentionDurationInDay
	} else {
		destination.RetentionDurationInDays = nil
	}

	// State
	if settings.State != nil {
		state := string(*settings.State)
		destination.State = &state
	} else {
		destination.State = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_SoftDeleteSettings_STATUS populates our SoftDeleteSettings from the provided source SoftDeleteSettings_STATUS
func (settings *SoftDeleteSettings) Initialize_From_SoftDeleteSettings_STATUS(source *SoftDeleteSettings_STATUS) error {

	// RetentionDurationInDays
	if source.RetentionDurationInDays != nil {
		retentionDurationInDay := *source.RetentionDurationInDays
		settings.RetentionDurationInDays = &retentionDurationInDay
	} else {
		settings.RetentionDurationInDays = nil
	}

	// State
	if source.State != nil {
		state := SoftDeleteSettings_State(*source.State)
		settings.State = &state
	} else {
		settings.State = nil
	}

	// No error
	return nil
}

// Soft delete related settings
type SoftDeleteSettings_STATUS struct {
	// RetentionDurationInDays: Soft delete retention duration
	RetentionDurationInDays *float64 `json:"retentionDurationInDays,omitempty"`

	// State: State of soft delete
	State *SoftDeleteSettings_State_STATUS `json:"state,omitempty"`
}

var _ genruntime.FromARMConverter = &SoftDeleteSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *SoftDeleteSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SoftDeleteSettings_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *SoftDeleteSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SoftDeleteSettings_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SoftDeleteSettings_STATUS_ARM, got %T", armInput)
	}

	// Set property "RetentionDurationInDays":
	if typedInput.RetentionDurationInDays != nil {
		retentionDurationInDays := *typedInput.RetentionDurationInDays
		settings.RetentionDurationInDays = &retentionDurationInDays
	}

	// Set property "State":
	if typedInput.State != nil {
		state := *typedInput.State
		settings.State = &state
	}

	// No error
	return nil
}

// AssignProperties_From_SoftDeleteSettings_STATUS populates our SoftDeleteSettings_STATUS from the provided source SoftDeleteSettings_STATUS
func (settings *SoftDeleteSettings_STATUS) AssignProperties_From_SoftDeleteSettings_STATUS(source *v20230101s.SoftDeleteSettings_STATUS) error {

	// RetentionDurationInDays
	if source.RetentionDurationInDays != nil {
		retentionDurationInDay := *source.RetentionDurationInDays
		settings.RetentionDurationInDays = &retentionDurationInDay
	} else {
		settings.RetentionDurationInDays = nil
	}

	// State
	if source.State != nil {
		state := SoftDeleteSettings_State_STATUS(*source.State)
		settings.State = &state
	} else {
		settings.State = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SoftDeleteSettings_STATUS populates the provided destination SoftDeleteSettings_STATUS from our SoftDeleteSettings_STATUS
func (settings *SoftDeleteSettings_STATUS) AssignProperties_To_SoftDeleteSettings_STATUS(destination *v20230101s.SoftDeleteSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RetentionDurationInDays
	if settings.RetentionDurationInDays != nil {
		retentionDurationInDay := *settings.RetentionDurationInDays
		destination.RetentionDurationInDays = &retentionDurationInDay
	} else {
		destination.RetentionDurationInDays = nil
	}

	// State
	if settings.State != nil {
		state := string(*settings.State)
		destination.State = &state
	} else {
		destination.State = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&BackupVault{}, &BackupVaultList{})
}
