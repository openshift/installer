// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20230101

import (
	"context"
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/dataprotection/v1api20230101/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/dataprotection/v1api20230101/storage"
	"github.com/Azure/azure-service-operator/v2/internal/genericarmclient"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/go-logr/logr"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /dataprotection/resource-manager/Microsoft.DataProtection/stable/2023-01-01/dataprotection.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}
type BackupVault struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              BackupVault_Spec           `json:"spec,omitempty"`
	Status            BackupVaultResource_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &BackupVault{}

// GetConditions returns the conditions of the resource
func (vault *BackupVault) GetConditions() conditions.Conditions {
	return vault.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (vault *BackupVault) SetConditions(conditions conditions.Conditions) {
	vault.Status.Conditions = conditions
}

var _ conversion.Convertible = &BackupVault{}

// ConvertFrom populates our BackupVault from the provided hub BackupVault
func (vault *BackupVault) ConvertFrom(hub conversion.Hub) error {
	// intermediate variable for conversion
	var source storage.BackupVault

	err := source.ConvertFrom(hub)
	if err != nil {
		return errors.Wrap(err, "converting from hub to source")
	}

	err = vault.AssignProperties_From_BackupVault(&source)
	if err != nil {
		return errors.Wrap(err, "converting from source to vault")
	}

	return nil
}

// ConvertTo populates the provided hub BackupVault from our BackupVault
func (vault *BackupVault) ConvertTo(hub conversion.Hub) error {
	// intermediate variable for conversion
	var destination storage.BackupVault
	err := vault.AssignProperties_To_BackupVault(&destination)
	if err != nil {
		return errors.Wrap(err, "converting to destination from vault")
	}
	err = destination.ConvertTo(hub)
	if err != nil {
		return errors.Wrap(err, "converting from destination to hub")
	}

	return nil
}

// +kubebuilder:webhook:path=/mutate-dataprotection-azure-com-v1api20230101-backupvault,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=dataprotection.azure.com,resources=backupvaults,verbs=create;update,versions=v1api20230101,name=default.v1api20230101.backupvaults.dataprotection.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &BackupVault{}

// Default applies defaults to the BackupVault resource
func (vault *BackupVault) Default() {
	vault.defaultImpl()
	var temp any = vault
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (vault *BackupVault) defaultAzureName() {
	if vault.Spec.AzureName == "" {
		vault.Spec.AzureName = vault.Name
	}
}

// defaultImpl applies the code generated defaults to the BackupVault resource
func (vault *BackupVault) defaultImpl() { vault.defaultAzureName() }

var _ configmaps.Exporter = &BackupVault{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (vault *BackupVault) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if vault.Spec.OperatorSpec == nil {
		return nil
	}
	return vault.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &BackupVault{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (vault *BackupVault) SecretDestinationExpressions() []*core.DestinationExpression {
	if vault.Spec.OperatorSpec == nil {
		return nil
	}
	return vault.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.KubernetesConfigExporter = &BackupVault{}

// ExportKubernetesConfigMaps defines a resource which can create ConfigMaps in Kubernetes.
func (vault *BackupVault) ExportKubernetesConfigMaps(_ context.Context, _ genruntime.MetaObject, _ *genericarmclient.GenericClient, _ logr.Logger) ([]client.Object, error) {
	collector := configmaps.NewCollector(vault.Namespace)
	if vault.Spec.OperatorSpec != nil && vault.Spec.OperatorSpec.ConfigMaps != nil {
		if vault.Status.Identity != nil {
			if vault.Status.Identity.PrincipalId != nil {
				collector.AddValue(vault.Spec.OperatorSpec.ConfigMaps.PrincipalId, *vault.Status.Identity.PrincipalId)
			}
		}
	}
	result, err := collector.Values()
	if err != nil {
		return nil, err
	}
	return configmaps.SliceToClientObjectSlice(result), nil
}

var _ genruntime.KubernetesResource = &BackupVault{}

// AzureName returns the Azure name of the resource
func (vault *BackupVault) AzureName() string {
	return vault.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2023-01-01"
func (vault BackupVault) GetAPIVersion() string {
	return "2023-01-01"
}

// GetResourceScope returns the scope of the resource
func (vault *BackupVault) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (vault *BackupVault) GetSpec() genruntime.ConvertibleSpec {
	return &vault.Spec
}

// GetStatus returns the status of this resource
func (vault *BackupVault) GetStatus() genruntime.ConvertibleStatus {
	return &vault.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (vault *BackupVault) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.DataProtection/backupVaults"
func (vault *BackupVault) GetType() string {
	return "Microsoft.DataProtection/backupVaults"
}

// NewEmptyStatus returns a new empty (blank) status
func (vault *BackupVault) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &BackupVaultResource_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (vault *BackupVault) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(vault.Spec)
	return vault.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (vault *BackupVault) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*BackupVaultResource_STATUS); ok {
		vault.Status = *st
		return nil
	}

	// Convert status to required version
	var st BackupVaultResource_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	vault.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-dataprotection-azure-com-v1api20230101-backupvault,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=dataprotection.azure.com,resources=backupvaults,verbs=create;update,versions=v1api20230101,name=validate.v1api20230101.backupvaults.dataprotection.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &BackupVault{}

// ValidateCreate validates the creation of the resource
func (vault *BackupVault) ValidateCreate() (admission.Warnings, error) {
	validations := vault.createValidations()
	var temp any = vault
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	return genruntime.ValidateCreate(validations)
}

// ValidateDelete validates the deletion of the resource
func (vault *BackupVault) ValidateDelete() (admission.Warnings, error) {
	validations := vault.deleteValidations()
	var temp any = vault
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	return genruntime.ValidateDelete(validations)
}

// ValidateUpdate validates an update of the resource
func (vault *BackupVault) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	validations := vault.updateValidations()
	var temp any = vault
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	return genruntime.ValidateUpdate(old, validations)
}

// createValidations validates the creation of the resource
func (vault *BackupVault) createValidations() []func() (admission.Warnings, error) {
	return []func() (admission.Warnings, error){vault.validateResourceReferences, vault.validateOwnerReference, vault.validateSecretDestinations, vault.validateConfigMapDestinations}
}

// deleteValidations validates the deletion of the resource
func (vault *BackupVault) deleteValidations() []func() (admission.Warnings, error) {
	return nil
}

// updateValidations validates the update of the resource
func (vault *BackupVault) updateValidations() []func(old runtime.Object) (admission.Warnings, error) {
	return []func(old runtime.Object) (admission.Warnings, error){
		func(old runtime.Object) (admission.Warnings, error) {
			return vault.validateResourceReferences()
		},
		vault.validateWriteOnceProperties,
		func(old runtime.Object) (admission.Warnings, error) {
			return vault.validateOwnerReference()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return vault.validateSecretDestinations()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return vault.validateConfigMapDestinations()
		},
	}
}

// validateConfigMapDestinations validates there are no colliding genruntime.ConfigMapDestinations
func (vault *BackupVault) validateConfigMapDestinations() (admission.Warnings, error) {
	if vault.Spec.OperatorSpec == nil {
		return nil, nil
	}
	var toValidate []*genruntime.ConfigMapDestination
	if vault.Spec.OperatorSpec.ConfigMaps != nil {
		toValidate = []*genruntime.ConfigMapDestination{
			vault.Spec.OperatorSpec.ConfigMaps.PrincipalId,
		}
	}
	return configmaps.ValidateDestinations(vault, toValidate, vault.Spec.OperatorSpec.ConfigMapExpressions)
}

// validateOwnerReference validates the owner field
func (vault *BackupVault) validateOwnerReference() (admission.Warnings, error) {
	return genruntime.ValidateOwner(vault)
}

// validateResourceReferences validates all resource references
func (vault *BackupVault) validateResourceReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindResourceReferences(&vault.Spec)
	if err != nil {
		return nil, err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateSecretDestinations validates there are no colliding genruntime.SecretDestination's
func (vault *BackupVault) validateSecretDestinations() (admission.Warnings, error) {
	if vault.Spec.OperatorSpec == nil {
		return nil, nil
	}
	return secrets.ValidateDestinations(vault, nil, vault.Spec.OperatorSpec.SecretExpressions)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (vault *BackupVault) validateWriteOnceProperties(old runtime.Object) (admission.Warnings, error) {
	oldObj, ok := old.(*BackupVault)
	if !ok {
		return nil, nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, vault)
}

// AssignProperties_From_BackupVault populates our BackupVault from the provided source BackupVault
func (vault *BackupVault) AssignProperties_From_BackupVault(source *storage.BackupVault) error {

	// ObjectMeta
	vault.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec BackupVault_Spec
	err := spec.AssignProperties_From_BackupVault_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_BackupVault_Spec() to populate field Spec")
	}
	vault.Spec = spec

	// Status
	var status BackupVaultResource_STATUS
	err = status.AssignProperties_From_BackupVaultResource_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_BackupVaultResource_STATUS() to populate field Status")
	}
	vault.Status = status

	// No error
	return nil
}

// AssignProperties_To_BackupVault populates the provided destination BackupVault from our BackupVault
func (vault *BackupVault) AssignProperties_To_BackupVault(destination *storage.BackupVault) error {

	// ObjectMeta
	destination.ObjectMeta = *vault.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.BackupVault_Spec
	err := vault.Spec.AssignProperties_To_BackupVault_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_BackupVault_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.BackupVaultResource_STATUS
	err = vault.Status.AssignProperties_To_BackupVaultResource_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_BackupVaultResource_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (vault *BackupVault) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: vault.Spec.OriginalVersion(),
		Kind:    "BackupVault",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /dataprotection/resource-manager/Microsoft.DataProtection/stable/2023-01-01/dataprotection.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}
type BackupVaultList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []BackupVault `json:"items"`
}

// +kubebuilder:validation:Enum={"2023-01-01"}
type APIVersion string

const APIVersion_Value = APIVersion("2023-01-01")

type BackupVault_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// Identity: Input Managed Identity Details
	Identity *DppIdentityDetails `json:"identity,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *BackupVaultOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// +kubebuilder:validation:Required
	// Properties: BackupVaultResource properties
	Properties *BackupVaultSpec `json:"properties,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &BackupVault_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (vault *BackupVault_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if vault == nil {
		return nil, nil
	}
	result := &arm.BackupVault_Spec{}

	// Set property "Identity":
	if vault.Identity != nil {
		identity_ARM, err := (*vault.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*arm.DppIdentityDetails)
		result.Identity = &identity
	}

	// Set property "Location":
	if vault.Location != nil {
		location := *vault.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if vault.Properties != nil {
		properties_ARM, err := (*vault.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*arm.BackupVaultSpec)
		result.Properties = &properties
	}

	// Set property "Tags":
	if vault.Tags != nil {
		result.Tags = make(map[string]string, len(vault.Tags))
		for key, value := range vault.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (vault *BackupVault_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackupVault_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (vault *BackupVault_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackupVault_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackupVault_Spec, got %T", armInput)
	}

	// Set property "AzureName":
	vault.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 DppIdentityDetails
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		vault.Identity = &identity
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		vault.Location = &location
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	vault.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 BackupVaultSpec
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		vault.Properties = &properties
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		vault.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			vault.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &BackupVault_Spec{}

// ConvertSpecFrom populates our BackupVault_Spec from the provided source
func (vault *BackupVault_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.BackupVault_Spec)
	if ok {
		// Populate our instance from source
		return vault.AssignProperties_From_BackupVault_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.BackupVault_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = vault.AssignProperties_From_BackupVault_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our BackupVault_Spec
func (vault *BackupVault_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.BackupVault_Spec)
	if ok {
		// Populate destination from our instance
		return vault.AssignProperties_To_BackupVault_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.BackupVault_Spec{}
	err := vault.AssignProperties_To_BackupVault_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_BackupVault_Spec populates our BackupVault_Spec from the provided source BackupVault_Spec
func (vault *BackupVault_Spec) AssignProperties_From_BackupVault_Spec(source *storage.BackupVault_Spec) error {

	// AzureName
	vault.AzureName = source.AzureName

	// Identity
	if source.Identity != nil {
		var identity DppIdentityDetails
		err := identity.AssignProperties_From_DppIdentityDetails(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DppIdentityDetails() to populate field Identity")
		}
		vault.Identity = &identity
	} else {
		vault.Identity = nil
	}

	// Location
	vault.Location = genruntime.ClonePointerToString(source.Location)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec BackupVaultOperatorSpec
		err := operatorSpec.AssignProperties_From_BackupVaultOperatorSpec(source.OperatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BackupVaultOperatorSpec() to populate field OperatorSpec")
		}
		vault.OperatorSpec = &operatorSpec
	} else {
		vault.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		vault.Owner = &owner
	} else {
		vault.Owner = nil
	}

	// Properties
	if source.Properties != nil {
		var property BackupVaultSpec
		err := property.AssignProperties_From_BackupVaultSpec(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BackupVaultSpec() to populate field Properties")
		}
		vault.Properties = &property
	} else {
		vault.Properties = nil
	}

	// Tags
	vault.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// AssignProperties_To_BackupVault_Spec populates the provided destination BackupVault_Spec from our BackupVault_Spec
func (vault *BackupVault_Spec) AssignProperties_To_BackupVault_Spec(destination *storage.BackupVault_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = vault.AzureName

	// Identity
	if vault.Identity != nil {
		var identity storage.DppIdentityDetails
		err := vault.Identity.AssignProperties_To_DppIdentityDetails(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DppIdentityDetails() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(vault.Location)

	// OperatorSpec
	if vault.OperatorSpec != nil {
		var operatorSpec storage.BackupVaultOperatorSpec
		err := vault.OperatorSpec.AssignProperties_To_BackupVaultOperatorSpec(&operatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BackupVaultOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = vault.OriginalVersion()

	// Owner
	if vault.Owner != nil {
		owner := vault.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Properties
	if vault.Properties != nil {
		var property storage.BackupVaultSpec
		err := vault.Properties.AssignProperties_To_BackupVaultSpec(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BackupVaultSpec() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(vault.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (vault *BackupVault_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (vault *BackupVault_Spec) SetAzureName(azureName string) { vault.AzureName = azureName }

// Backup Vault Resource
type BackupVaultResource_STATUS struct {
	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// ETag: Optional ETag.
	ETag *string `json:"eTag,omitempty"`

	// Id: Resource Id represents the complete path to the resource.
	Id *string `json:"id,omitempty"`

	// Identity: Input Managed Identity Details
	Identity *DppIdentityDetails_STATUS `json:"identity,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// Name: Resource name associated with the resource.
	Name *string `json:"name,omitempty"`

	// Properties: BackupVaultResource properties
	Properties *BackupVault_STATUS `json:"properties,omitempty"`

	// SystemData: Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData_STATUS `json:"systemData,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: Resource type represents the complete path of the form Namespace/ResourceType/ResourceType/...
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &BackupVaultResource_STATUS{}

// ConvertStatusFrom populates our BackupVaultResource_STATUS from the provided source
func (resource *BackupVaultResource_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.BackupVaultResource_STATUS)
	if ok {
		// Populate our instance from source
		return resource.AssignProperties_From_BackupVaultResource_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.BackupVaultResource_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = resource.AssignProperties_From_BackupVaultResource_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our BackupVaultResource_STATUS
func (resource *BackupVaultResource_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.BackupVaultResource_STATUS)
	if ok {
		// Populate destination from our instance
		return resource.AssignProperties_To_BackupVaultResource_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.BackupVaultResource_STATUS{}
	err := resource.AssignProperties_To_BackupVaultResource_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &BackupVaultResource_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *BackupVaultResource_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackupVaultResource_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *BackupVaultResource_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackupVaultResource_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackupVaultResource_STATUS, got %T", armInput)
	}

	// no assignment for property "Conditions"

	// Set property "ETag":
	if typedInput.ETag != nil {
		eTag := *typedInput.ETag
		resource.ETag = &eTag
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		resource.Id = &id
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 DppIdentityDetails_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		resource.Identity = &identity
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		resource.Location = &location
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		resource.Name = &name
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 BackupVault_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		resource.Properties = &properties
	}

	// Set property "SystemData":
	if typedInput.SystemData != nil {
		var systemData1 SystemData_STATUS
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		resource.SystemData = &systemData
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		resource.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			resource.Tags[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		resource.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_BackupVaultResource_STATUS populates our BackupVaultResource_STATUS from the provided source BackupVaultResource_STATUS
func (resource *BackupVaultResource_STATUS) AssignProperties_From_BackupVaultResource_STATUS(source *storage.BackupVaultResource_STATUS) error {

	// Conditions
	resource.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// ETag
	resource.ETag = genruntime.ClonePointerToString(source.ETag)

	// Id
	resource.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity DppIdentityDetails_STATUS
		err := identity.AssignProperties_From_DppIdentityDetails_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DppIdentityDetails_STATUS() to populate field Identity")
		}
		resource.Identity = &identity
	} else {
		resource.Identity = nil
	}

	// Location
	resource.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	resource.Name = genruntime.ClonePointerToString(source.Name)

	// Properties
	if source.Properties != nil {
		var property BackupVault_STATUS
		err := property.AssignProperties_From_BackupVault_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BackupVault_STATUS() to populate field Properties")
		}
		resource.Properties = &property
	} else {
		resource.Properties = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		resource.SystemData = &systemDatum
	} else {
		resource.SystemData = nil
	}

	// Tags
	resource.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	resource.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_BackupVaultResource_STATUS populates the provided destination BackupVaultResource_STATUS from our BackupVaultResource_STATUS
func (resource *BackupVaultResource_STATUS) AssignProperties_To_BackupVaultResource_STATUS(destination *storage.BackupVaultResource_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(resource.Conditions)

	// ETag
	destination.ETag = genruntime.ClonePointerToString(resource.ETag)

	// Id
	destination.Id = genruntime.ClonePointerToString(resource.Id)

	// Identity
	if resource.Identity != nil {
		var identity storage.DppIdentityDetails_STATUS
		err := resource.Identity.AssignProperties_To_DppIdentityDetails_STATUS(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DppIdentityDetails_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(resource.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(resource.Name)

	// Properties
	if resource.Properties != nil {
		var property storage.BackupVault_STATUS
		err := resource.Properties.AssignProperties_To_BackupVault_STATUS(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BackupVault_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// SystemData
	if resource.SystemData != nil {
		var systemDatum storage.SystemData_STATUS
		err := resource.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(resource.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(resource.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Backup Vault
type BackupVault_STATUS struct {
	// FeatureSettings: Feature Settings
	FeatureSettings *FeatureSettings_STATUS `json:"featureSettings,omitempty"`

	// IsVaultProtectedByResourceGuard: Is vault protected by resource guard
	IsVaultProtectedByResourceGuard *bool `json:"isVaultProtectedByResourceGuard,omitempty"`

	// MonitoringSettings: Monitoring Settings
	MonitoringSettings *MonitoringSettings_STATUS `json:"monitoringSettings,omitempty"`

	// ProvisioningState: Provisioning state of the BackupVault resource
	ProvisioningState *BackupVault_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// ResourceMoveDetails: Resource move details for backup vault
	ResourceMoveDetails *ResourceMoveDetails_STATUS `json:"resourceMoveDetails,omitempty"`

	// ResourceMoveState: Resource move state for backup vault
	ResourceMoveState *BackupVault_ResourceMoveState_STATUS `json:"resourceMoveState,omitempty"`

	// SecuritySettings: Security Settings
	SecuritySettings *SecuritySettings_STATUS `json:"securitySettings,omitempty"`

	// StorageSettings: Storage Settings
	StorageSettings []StorageSetting_STATUS `json:"storageSettings,omitempty"`
}

var _ genruntime.FromARMConverter = &BackupVault_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (vault *BackupVault_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackupVault_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (vault *BackupVault_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackupVault_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackupVault_STATUS, got %T", armInput)
	}

	// Set property "FeatureSettings":
	if typedInput.FeatureSettings != nil {
		var featureSettings1 FeatureSettings_STATUS
		err := featureSettings1.PopulateFromARM(owner, *typedInput.FeatureSettings)
		if err != nil {
			return err
		}
		featureSettings := featureSettings1
		vault.FeatureSettings = &featureSettings
	}

	// Set property "IsVaultProtectedByResourceGuard":
	if typedInput.IsVaultProtectedByResourceGuard != nil {
		isVaultProtectedByResourceGuard := *typedInput.IsVaultProtectedByResourceGuard
		vault.IsVaultProtectedByResourceGuard = &isVaultProtectedByResourceGuard
	}

	// Set property "MonitoringSettings":
	if typedInput.MonitoringSettings != nil {
		var monitoringSettings1 MonitoringSettings_STATUS
		err := monitoringSettings1.PopulateFromARM(owner, *typedInput.MonitoringSettings)
		if err != nil {
			return err
		}
		monitoringSettings := monitoringSettings1
		vault.MonitoringSettings = &monitoringSettings
	}

	// Set property "ProvisioningState":
	if typedInput.ProvisioningState != nil {
		var temp string
		temp = string(*typedInput.ProvisioningState)
		provisioningState := BackupVault_ProvisioningState_STATUS(temp)
		vault.ProvisioningState = &provisioningState
	}

	// Set property "ResourceMoveDetails":
	if typedInput.ResourceMoveDetails != nil {
		var resourceMoveDetails1 ResourceMoveDetails_STATUS
		err := resourceMoveDetails1.PopulateFromARM(owner, *typedInput.ResourceMoveDetails)
		if err != nil {
			return err
		}
		resourceMoveDetails := resourceMoveDetails1
		vault.ResourceMoveDetails = &resourceMoveDetails
	}

	// Set property "ResourceMoveState":
	if typedInput.ResourceMoveState != nil {
		var temp string
		temp = string(*typedInput.ResourceMoveState)
		resourceMoveState := BackupVault_ResourceMoveState_STATUS(temp)
		vault.ResourceMoveState = &resourceMoveState
	}

	// Set property "SecuritySettings":
	if typedInput.SecuritySettings != nil {
		var securitySettings1 SecuritySettings_STATUS
		err := securitySettings1.PopulateFromARM(owner, *typedInput.SecuritySettings)
		if err != nil {
			return err
		}
		securitySettings := securitySettings1
		vault.SecuritySettings = &securitySettings
	}

	// Set property "StorageSettings":
	for _, item := range typedInput.StorageSettings {
		var item1 StorageSetting_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		vault.StorageSettings = append(vault.StorageSettings, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_BackupVault_STATUS populates our BackupVault_STATUS from the provided source BackupVault_STATUS
func (vault *BackupVault_STATUS) AssignProperties_From_BackupVault_STATUS(source *storage.BackupVault_STATUS) error {

	// FeatureSettings
	if source.FeatureSettings != nil {
		var featureSetting FeatureSettings_STATUS
		err := featureSetting.AssignProperties_From_FeatureSettings_STATUS(source.FeatureSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_FeatureSettings_STATUS() to populate field FeatureSettings")
		}
		vault.FeatureSettings = &featureSetting
	} else {
		vault.FeatureSettings = nil
	}

	// IsVaultProtectedByResourceGuard
	if source.IsVaultProtectedByResourceGuard != nil {
		isVaultProtectedByResourceGuard := *source.IsVaultProtectedByResourceGuard
		vault.IsVaultProtectedByResourceGuard = &isVaultProtectedByResourceGuard
	} else {
		vault.IsVaultProtectedByResourceGuard = nil
	}

	// MonitoringSettings
	if source.MonitoringSettings != nil {
		var monitoringSetting MonitoringSettings_STATUS
		err := monitoringSetting.AssignProperties_From_MonitoringSettings_STATUS(source.MonitoringSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_MonitoringSettings_STATUS() to populate field MonitoringSettings")
		}
		vault.MonitoringSettings = &monitoringSetting
	} else {
		vault.MonitoringSettings = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, backupVault_ProvisioningState_STATUS_Values)
		vault.ProvisioningState = &provisioningStateTemp
	} else {
		vault.ProvisioningState = nil
	}

	// ResourceMoveDetails
	if source.ResourceMoveDetails != nil {
		var resourceMoveDetail ResourceMoveDetails_STATUS
		err := resourceMoveDetail.AssignProperties_From_ResourceMoveDetails_STATUS(source.ResourceMoveDetails)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceMoveDetails_STATUS() to populate field ResourceMoveDetails")
		}
		vault.ResourceMoveDetails = &resourceMoveDetail
	} else {
		vault.ResourceMoveDetails = nil
	}

	// ResourceMoveState
	if source.ResourceMoveState != nil {
		resourceMoveState := *source.ResourceMoveState
		resourceMoveStateTemp := genruntime.ToEnum(resourceMoveState, backupVault_ResourceMoveState_STATUS_Values)
		vault.ResourceMoveState = &resourceMoveStateTemp
	} else {
		vault.ResourceMoveState = nil
	}

	// SecuritySettings
	if source.SecuritySettings != nil {
		var securitySetting SecuritySettings_STATUS
		err := securitySetting.AssignProperties_From_SecuritySettings_STATUS(source.SecuritySettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SecuritySettings_STATUS() to populate field SecuritySettings")
		}
		vault.SecuritySettings = &securitySetting
	} else {
		vault.SecuritySettings = nil
	}

	// StorageSettings
	if source.StorageSettings != nil {
		storageSettingList := make([]StorageSetting_STATUS, len(source.StorageSettings))
		for storageSettingIndex, storageSettingItem := range source.StorageSettings {
			// Shadow the loop variable to avoid aliasing
			storageSettingItem := storageSettingItem
			var storageSetting StorageSetting_STATUS
			err := storageSetting.AssignProperties_From_StorageSetting_STATUS(&storageSettingItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_StorageSetting_STATUS() to populate field StorageSettings")
			}
			storageSettingList[storageSettingIndex] = storageSetting
		}
		vault.StorageSettings = storageSettingList
	} else {
		vault.StorageSettings = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackupVault_STATUS populates the provided destination BackupVault_STATUS from our BackupVault_STATUS
func (vault *BackupVault_STATUS) AssignProperties_To_BackupVault_STATUS(destination *storage.BackupVault_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// FeatureSettings
	if vault.FeatureSettings != nil {
		var featureSetting storage.FeatureSettings_STATUS
		err := vault.FeatureSettings.AssignProperties_To_FeatureSettings_STATUS(&featureSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_FeatureSettings_STATUS() to populate field FeatureSettings")
		}
		destination.FeatureSettings = &featureSetting
	} else {
		destination.FeatureSettings = nil
	}

	// IsVaultProtectedByResourceGuard
	if vault.IsVaultProtectedByResourceGuard != nil {
		isVaultProtectedByResourceGuard := *vault.IsVaultProtectedByResourceGuard
		destination.IsVaultProtectedByResourceGuard = &isVaultProtectedByResourceGuard
	} else {
		destination.IsVaultProtectedByResourceGuard = nil
	}

	// MonitoringSettings
	if vault.MonitoringSettings != nil {
		var monitoringSetting storage.MonitoringSettings_STATUS
		err := vault.MonitoringSettings.AssignProperties_To_MonitoringSettings_STATUS(&monitoringSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_MonitoringSettings_STATUS() to populate field MonitoringSettings")
		}
		destination.MonitoringSettings = &monitoringSetting
	} else {
		destination.MonitoringSettings = nil
	}

	// ProvisioningState
	if vault.ProvisioningState != nil {
		provisioningState := string(*vault.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ResourceMoveDetails
	if vault.ResourceMoveDetails != nil {
		var resourceMoveDetail storage.ResourceMoveDetails_STATUS
		err := vault.ResourceMoveDetails.AssignProperties_To_ResourceMoveDetails_STATUS(&resourceMoveDetail)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceMoveDetails_STATUS() to populate field ResourceMoveDetails")
		}
		destination.ResourceMoveDetails = &resourceMoveDetail
	} else {
		destination.ResourceMoveDetails = nil
	}

	// ResourceMoveState
	if vault.ResourceMoveState != nil {
		resourceMoveState := string(*vault.ResourceMoveState)
		destination.ResourceMoveState = &resourceMoveState
	} else {
		destination.ResourceMoveState = nil
	}

	// SecuritySettings
	if vault.SecuritySettings != nil {
		var securitySetting storage.SecuritySettings_STATUS
		err := vault.SecuritySettings.AssignProperties_To_SecuritySettings_STATUS(&securitySetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SecuritySettings_STATUS() to populate field SecuritySettings")
		}
		destination.SecuritySettings = &securitySetting
	} else {
		destination.SecuritySettings = nil
	}

	// StorageSettings
	if vault.StorageSettings != nil {
		storageSettingList := make([]storage.StorageSetting_STATUS, len(vault.StorageSettings))
		for storageSettingIndex, storageSettingItem := range vault.StorageSettings {
			// Shadow the loop variable to avoid aliasing
			storageSettingItem := storageSettingItem
			var storageSetting storage.StorageSetting_STATUS
			err := storageSettingItem.AssignProperties_To_StorageSetting_STATUS(&storageSetting)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_StorageSetting_STATUS() to populate field StorageSettings")
			}
			storageSettingList[storageSettingIndex] = storageSetting
		}
		destination.StorageSettings = storageSettingList
	} else {
		destination.StorageSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type BackupVaultOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// ConfigMaps: configures where to place operator written ConfigMaps.
	ConfigMaps *BackupVaultOperatorConfigMaps `json:"configMaps,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_BackupVaultOperatorSpec populates our BackupVaultOperatorSpec from the provided source BackupVaultOperatorSpec
func (operator *BackupVaultOperatorSpec) AssignProperties_From_BackupVaultOperatorSpec(source *storage.BackupVaultOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// ConfigMaps
	if source.ConfigMaps != nil {
		var configMap BackupVaultOperatorConfigMaps
		err := configMap.AssignProperties_From_BackupVaultOperatorConfigMaps(source.ConfigMaps)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BackupVaultOperatorConfigMaps() to populate field ConfigMaps")
		}
		operator.ConfigMaps = &configMap
	} else {
		operator.ConfigMaps = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackupVaultOperatorSpec populates the provided destination BackupVaultOperatorSpec from our BackupVaultOperatorSpec
func (operator *BackupVaultOperatorSpec) AssignProperties_To_BackupVaultOperatorSpec(destination *storage.BackupVaultOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// ConfigMaps
	if operator.ConfigMaps != nil {
		var configMap storage.BackupVaultOperatorConfigMaps
		err := operator.ConfigMaps.AssignProperties_To_BackupVaultOperatorConfigMaps(&configMap)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BackupVaultOperatorConfigMaps() to populate field ConfigMaps")
		}
		destination.ConfigMaps = &configMap
	} else {
		destination.ConfigMaps = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Backup Vault
type BackupVaultSpec struct {
	// FeatureSettings: Feature Settings
	FeatureSettings *FeatureSettings `json:"featureSettings,omitempty"`

	// MonitoringSettings: Monitoring Settings
	MonitoringSettings *MonitoringSettings `json:"monitoringSettings,omitempty"`

	// SecuritySettings: Security Settings
	SecuritySettings *SecuritySettings `json:"securitySettings,omitempty"`

	// +kubebuilder:validation:Required
	// StorageSettings: Storage Settings
	StorageSettings []StorageSetting `json:"storageSettings,omitempty"`
}

var _ genruntime.ARMTransformer = &BackupVaultSpec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (vault *BackupVaultSpec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if vault == nil {
		return nil, nil
	}
	result := &arm.BackupVaultSpec{}

	// Set property "FeatureSettings":
	if vault.FeatureSettings != nil {
		featureSettings_ARM, err := (*vault.FeatureSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		featureSettings := *featureSettings_ARM.(*arm.FeatureSettings)
		result.FeatureSettings = &featureSettings
	}

	// Set property "MonitoringSettings":
	if vault.MonitoringSettings != nil {
		monitoringSettings_ARM, err := (*vault.MonitoringSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		monitoringSettings := *monitoringSettings_ARM.(*arm.MonitoringSettings)
		result.MonitoringSettings = &monitoringSettings
	}

	// Set property "SecuritySettings":
	if vault.SecuritySettings != nil {
		securitySettings_ARM, err := (*vault.SecuritySettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		securitySettings := *securitySettings_ARM.(*arm.SecuritySettings)
		result.SecuritySettings = &securitySettings
	}

	// Set property "StorageSettings":
	for _, item := range vault.StorageSettings {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.StorageSettings = append(result.StorageSettings, *item_ARM.(*arm.StorageSetting))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (vault *BackupVaultSpec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackupVaultSpec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (vault *BackupVaultSpec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackupVaultSpec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackupVaultSpec, got %T", armInput)
	}

	// Set property "FeatureSettings":
	if typedInput.FeatureSettings != nil {
		var featureSettings1 FeatureSettings
		err := featureSettings1.PopulateFromARM(owner, *typedInput.FeatureSettings)
		if err != nil {
			return err
		}
		featureSettings := featureSettings1
		vault.FeatureSettings = &featureSettings
	}

	// Set property "MonitoringSettings":
	if typedInput.MonitoringSettings != nil {
		var monitoringSettings1 MonitoringSettings
		err := monitoringSettings1.PopulateFromARM(owner, *typedInput.MonitoringSettings)
		if err != nil {
			return err
		}
		monitoringSettings := monitoringSettings1
		vault.MonitoringSettings = &monitoringSettings
	}

	// Set property "SecuritySettings":
	if typedInput.SecuritySettings != nil {
		var securitySettings1 SecuritySettings
		err := securitySettings1.PopulateFromARM(owner, *typedInput.SecuritySettings)
		if err != nil {
			return err
		}
		securitySettings := securitySettings1
		vault.SecuritySettings = &securitySettings
	}

	// Set property "StorageSettings":
	for _, item := range typedInput.StorageSettings {
		var item1 StorageSetting
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		vault.StorageSettings = append(vault.StorageSettings, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_BackupVaultSpec populates our BackupVaultSpec from the provided source BackupVaultSpec
func (vault *BackupVaultSpec) AssignProperties_From_BackupVaultSpec(source *storage.BackupVaultSpec) error {

	// FeatureSettings
	if source.FeatureSettings != nil {
		var featureSetting FeatureSettings
		err := featureSetting.AssignProperties_From_FeatureSettings(source.FeatureSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_FeatureSettings() to populate field FeatureSettings")
		}
		vault.FeatureSettings = &featureSetting
	} else {
		vault.FeatureSettings = nil
	}

	// MonitoringSettings
	if source.MonitoringSettings != nil {
		var monitoringSetting MonitoringSettings
		err := monitoringSetting.AssignProperties_From_MonitoringSettings(source.MonitoringSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_MonitoringSettings() to populate field MonitoringSettings")
		}
		vault.MonitoringSettings = &monitoringSetting
	} else {
		vault.MonitoringSettings = nil
	}

	// SecuritySettings
	if source.SecuritySettings != nil {
		var securitySetting SecuritySettings
		err := securitySetting.AssignProperties_From_SecuritySettings(source.SecuritySettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SecuritySettings() to populate field SecuritySettings")
		}
		vault.SecuritySettings = &securitySetting
	} else {
		vault.SecuritySettings = nil
	}

	// StorageSettings
	if source.StorageSettings != nil {
		storageSettingList := make([]StorageSetting, len(source.StorageSettings))
		for storageSettingIndex, storageSettingItem := range source.StorageSettings {
			// Shadow the loop variable to avoid aliasing
			storageSettingItem := storageSettingItem
			var storageSetting StorageSetting
			err := storageSetting.AssignProperties_From_StorageSetting(&storageSettingItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_StorageSetting() to populate field StorageSettings")
			}
			storageSettingList[storageSettingIndex] = storageSetting
		}
		vault.StorageSettings = storageSettingList
	} else {
		vault.StorageSettings = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackupVaultSpec populates the provided destination BackupVaultSpec from our BackupVaultSpec
func (vault *BackupVaultSpec) AssignProperties_To_BackupVaultSpec(destination *storage.BackupVaultSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// FeatureSettings
	if vault.FeatureSettings != nil {
		var featureSetting storage.FeatureSettings
		err := vault.FeatureSettings.AssignProperties_To_FeatureSettings(&featureSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_FeatureSettings() to populate field FeatureSettings")
		}
		destination.FeatureSettings = &featureSetting
	} else {
		destination.FeatureSettings = nil
	}

	// MonitoringSettings
	if vault.MonitoringSettings != nil {
		var monitoringSetting storage.MonitoringSettings
		err := vault.MonitoringSettings.AssignProperties_To_MonitoringSettings(&monitoringSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_MonitoringSettings() to populate field MonitoringSettings")
		}
		destination.MonitoringSettings = &monitoringSetting
	} else {
		destination.MonitoringSettings = nil
	}

	// SecuritySettings
	if vault.SecuritySettings != nil {
		var securitySetting storage.SecuritySettings
		err := vault.SecuritySettings.AssignProperties_To_SecuritySettings(&securitySetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SecuritySettings() to populate field SecuritySettings")
		}
		destination.SecuritySettings = &securitySetting
	} else {
		destination.SecuritySettings = nil
	}

	// StorageSettings
	if vault.StorageSettings != nil {
		storageSettingList := make([]storage.StorageSetting, len(vault.StorageSettings))
		for storageSettingIndex, storageSettingItem := range vault.StorageSettings {
			// Shadow the loop variable to avoid aliasing
			storageSettingItem := storageSettingItem
			var storageSetting storage.StorageSetting
			err := storageSettingItem.AssignProperties_To_StorageSetting(&storageSetting)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_StorageSetting() to populate field StorageSettings")
			}
			storageSettingList[storageSettingIndex] = storageSetting
		}
		destination.StorageSettings = storageSettingList
	} else {
		destination.StorageSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Identity details
type DppIdentityDetails struct {
	// Type: The identityType which can be either SystemAssigned or None
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &DppIdentityDetails{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (details *DppIdentityDetails) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if details == nil {
		return nil, nil
	}
	result := &arm.DppIdentityDetails{}

	// Set property "Type":
	if details.Type != nil {
		typeVar := *details.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (details *DppIdentityDetails) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DppIdentityDetails{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (details *DppIdentityDetails) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DppIdentityDetails)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DppIdentityDetails, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		details.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_DppIdentityDetails populates our DppIdentityDetails from the provided source DppIdentityDetails
func (details *DppIdentityDetails) AssignProperties_From_DppIdentityDetails(source *storage.DppIdentityDetails) error {

	// Type
	details.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_DppIdentityDetails populates the provided destination DppIdentityDetails from our DppIdentityDetails
func (details *DppIdentityDetails) AssignProperties_To_DppIdentityDetails(destination *storage.DppIdentityDetails) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	destination.Type = genruntime.ClonePointerToString(details.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Identity details
type DppIdentityDetails_STATUS struct {
	// PrincipalId: The object ID of the service principal object for the managed identity that is used to grant role-based
	// access to an Azure resource.
	PrincipalId *string `json:"principalId,omitempty"`

	// TenantId: A Globally Unique Identifier (GUID) that represents the Azure AD tenant where the resource is now a member.
	TenantId *string `json:"tenantId,omitempty"`

	// Type: The identityType which can be either SystemAssigned or None
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &DppIdentityDetails_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (details *DppIdentityDetails_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DppIdentityDetails_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (details *DppIdentityDetails_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DppIdentityDetails_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DppIdentityDetails_STATUS, got %T", armInput)
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		details.PrincipalId = &principalId
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		details.TenantId = &tenantId
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		details.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_DppIdentityDetails_STATUS populates our DppIdentityDetails_STATUS from the provided source DppIdentityDetails_STATUS
func (details *DppIdentityDetails_STATUS) AssignProperties_From_DppIdentityDetails_STATUS(source *storage.DppIdentityDetails_STATUS) error {

	// PrincipalId
	details.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	details.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	details.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_DppIdentityDetails_STATUS populates the provided destination DppIdentityDetails_STATUS from our DppIdentityDetails_STATUS
func (details *DppIdentityDetails_STATUS) AssignProperties_To_DppIdentityDetails_STATUS(destination *storage.DppIdentityDetails_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(details.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(details.TenantId)

	// Type
	destination.Type = genruntime.ClonePointerToString(details.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Metadata pertaining to creation and last modification of the resource.
type SystemData_STATUS struct {
	// CreatedAt: The timestamp of resource creation (UTC).
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy: The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`

	// CreatedByType: The type of identity that created the resource.
	CreatedByType *SystemData_CreatedByType_STATUS `json:"createdByType,omitempty"`

	// LastModifiedAt: The timestamp of resource last modification (UTC)
	LastModifiedAt *string `json:"lastModifiedAt,omitempty"`

	// LastModifiedBy: The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`

	// LastModifiedByType: The type of identity that last modified the resource.
	LastModifiedByType *SystemData_LastModifiedByType_STATUS `json:"lastModifiedByType,omitempty"`
}

var _ genruntime.FromARMConverter = &SystemData_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (data *SystemData_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SystemData_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (data *SystemData_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SystemData_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SystemData_STATUS, got %T", armInput)
	}

	// Set property "CreatedAt":
	if typedInput.CreatedAt != nil {
		createdAt := *typedInput.CreatedAt
		data.CreatedAt = &createdAt
	}

	// Set property "CreatedBy":
	if typedInput.CreatedBy != nil {
		createdBy := *typedInput.CreatedBy
		data.CreatedBy = &createdBy
	}

	// Set property "CreatedByType":
	if typedInput.CreatedByType != nil {
		var temp string
		temp = string(*typedInput.CreatedByType)
		createdByType := SystemData_CreatedByType_STATUS(temp)
		data.CreatedByType = &createdByType
	}

	// Set property "LastModifiedAt":
	if typedInput.LastModifiedAt != nil {
		lastModifiedAt := *typedInput.LastModifiedAt
		data.LastModifiedAt = &lastModifiedAt
	}

	// Set property "LastModifiedBy":
	if typedInput.LastModifiedBy != nil {
		lastModifiedBy := *typedInput.LastModifiedBy
		data.LastModifiedBy = &lastModifiedBy
	}

	// Set property "LastModifiedByType":
	if typedInput.LastModifiedByType != nil {
		var temp string
		temp = string(*typedInput.LastModifiedByType)
		lastModifiedByType := SystemData_LastModifiedByType_STATUS(temp)
		data.LastModifiedByType = &lastModifiedByType
	}

	// No error
	return nil
}

// AssignProperties_From_SystemData_STATUS populates our SystemData_STATUS from the provided source SystemData_STATUS
func (data *SystemData_STATUS) AssignProperties_From_SystemData_STATUS(source *storage.SystemData_STATUS) error {

	// CreatedAt
	data.CreatedAt = genruntime.ClonePointerToString(source.CreatedAt)

	// CreatedBy
	data.CreatedBy = genruntime.ClonePointerToString(source.CreatedBy)

	// CreatedByType
	if source.CreatedByType != nil {
		createdByType := *source.CreatedByType
		createdByTypeTemp := genruntime.ToEnum(createdByType, systemData_CreatedByType_STATUS_Values)
		data.CreatedByType = &createdByTypeTemp
	} else {
		data.CreatedByType = nil
	}

	// LastModifiedAt
	data.LastModifiedAt = genruntime.ClonePointerToString(source.LastModifiedAt)

	// LastModifiedBy
	data.LastModifiedBy = genruntime.ClonePointerToString(source.LastModifiedBy)

	// LastModifiedByType
	if source.LastModifiedByType != nil {
		lastModifiedByType := *source.LastModifiedByType
		lastModifiedByTypeTemp := genruntime.ToEnum(lastModifiedByType, systemData_LastModifiedByType_STATUS_Values)
		data.LastModifiedByType = &lastModifiedByTypeTemp
	} else {
		data.LastModifiedByType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SystemData_STATUS populates the provided destination SystemData_STATUS from our SystemData_STATUS
func (data *SystemData_STATUS) AssignProperties_To_SystemData_STATUS(destination *storage.SystemData_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CreatedAt
	destination.CreatedAt = genruntime.ClonePointerToString(data.CreatedAt)

	// CreatedBy
	destination.CreatedBy = genruntime.ClonePointerToString(data.CreatedBy)

	// CreatedByType
	if data.CreatedByType != nil {
		createdByType := string(*data.CreatedByType)
		destination.CreatedByType = &createdByType
	} else {
		destination.CreatedByType = nil
	}

	// LastModifiedAt
	destination.LastModifiedAt = genruntime.ClonePointerToString(data.LastModifiedAt)

	// LastModifiedBy
	destination.LastModifiedBy = genruntime.ClonePointerToString(data.LastModifiedBy)

	// LastModifiedByType
	if data.LastModifiedByType != nil {
		lastModifiedByType := string(*data.LastModifiedByType)
		destination.LastModifiedByType = &lastModifiedByType
	} else {
		destination.LastModifiedByType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type BackupVault_ProvisioningState_STATUS string

const (
	BackupVault_ProvisioningState_STATUS_Failed       = BackupVault_ProvisioningState_STATUS("Failed")
	BackupVault_ProvisioningState_STATUS_Provisioning = BackupVault_ProvisioningState_STATUS("Provisioning")
	BackupVault_ProvisioningState_STATUS_Succeeded    = BackupVault_ProvisioningState_STATUS("Succeeded")
	BackupVault_ProvisioningState_STATUS_Unknown      = BackupVault_ProvisioningState_STATUS("Unknown")
	BackupVault_ProvisioningState_STATUS_Updating     = BackupVault_ProvisioningState_STATUS("Updating")
)

// Mapping from string to BackupVault_ProvisioningState_STATUS
var backupVault_ProvisioningState_STATUS_Values = map[string]BackupVault_ProvisioningState_STATUS{
	"failed":       BackupVault_ProvisioningState_STATUS_Failed,
	"provisioning": BackupVault_ProvisioningState_STATUS_Provisioning,
	"succeeded":    BackupVault_ProvisioningState_STATUS_Succeeded,
	"unknown":      BackupVault_ProvisioningState_STATUS_Unknown,
	"updating":     BackupVault_ProvisioningState_STATUS_Updating,
}

type BackupVault_ResourceMoveState_STATUS string

const (
	BackupVault_ResourceMoveState_STATUS_CommitFailed    = BackupVault_ResourceMoveState_STATUS("CommitFailed")
	BackupVault_ResourceMoveState_STATUS_CommitTimedout  = BackupVault_ResourceMoveState_STATUS("CommitTimedout")
	BackupVault_ResourceMoveState_STATUS_CriticalFailure = BackupVault_ResourceMoveState_STATUS("CriticalFailure")
	BackupVault_ResourceMoveState_STATUS_Failed          = BackupVault_ResourceMoveState_STATUS("Failed")
	BackupVault_ResourceMoveState_STATUS_InProgress      = BackupVault_ResourceMoveState_STATUS("InProgress")
	BackupVault_ResourceMoveState_STATUS_MoveSucceeded   = BackupVault_ResourceMoveState_STATUS("MoveSucceeded")
	BackupVault_ResourceMoveState_STATUS_PartialSuccess  = BackupVault_ResourceMoveState_STATUS("PartialSuccess")
	BackupVault_ResourceMoveState_STATUS_PrepareFailed   = BackupVault_ResourceMoveState_STATUS("PrepareFailed")
	BackupVault_ResourceMoveState_STATUS_PrepareTimedout = BackupVault_ResourceMoveState_STATUS("PrepareTimedout")
	BackupVault_ResourceMoveState_STATUS_Unknown         = BackupVault_ResourceMoveState_STATUS("Unknown")
)

// Mapping from string to BackupVault_ResourceMoveState_STATUS
var backupVault_ResourceMoveState_STATUS_Values = map[string]BackupVault_ResourceMoveState_STATUS{
	"commitfailed":    BackupVault_ResourceMoveState_STATUS_CommitFailed,
	"committimedout":  BackupVault_ResourceMoveState_STATUS_CommitTimedout,
	"criticalfailure": BackupVault_ResourceMoveState_STATUS_CriticalFailure,
	"failed":          BackupVault_ResourceMoveState_STATUS_Failed,
	"inprogress":      BackupVault_ResourceMoveState_STATUS_InProgress,
	"movesucceeded":   BackupVault_ResourceMoveState_STATUS_MoveSucceeded,
	"partialsuccess":  BackupVault_ResourceMoveState_STATUS_PartialSuccess,
	"preparefailed":   BackupVault_ResourceMoveState_STATUS_PrepareFailed,
	"preparetimedout": BackupVault_ResourceMoveState_STATUS_PrepareTimedout,
	"unknown":         BackupVault_ResourceMoveState_STATUS_Unknown,
}

type BackupVaultOperatorConfigMaps struct {
	// PrincipalId: indicates where the PrincipalId config map should be placed. If omitted, no config map will be created.
	PrincipalId *genruntime.ConfigMapDestination `json:"principalId,omitempty"`
}

// AssignProperties_From_BackupVaultOperatorConfigMaps populates our BackupVaultOperatorConfigMaps from the provided source BackupVaultOperatorConfigMaps
func (maps *BackupVaultOperatorConfigMaps) AssignProperties_From_BackupVaultOperatorConfigMaps(source *storage.BackupVaultOperatorConfigMaps) error {

	// PrincipalId
	if source.PrincipalId != nil {
		principalId := source.PrincipalId.Copy()
		maps.PrincipalId = &principalId
	} else {
		maps.PrincipalId = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackupVaultOperatorConfigMaps populates the provided destination BackupVaultOperatorConfigMaps from our BackupVaultOperatorConfigMaps
func (maps *BackupVaultOperatorConfigMaps) AssignProperties_To_BackupVaultOperatorConfigMaps(destination *storage.BackupVaultOperatorConfigMaps) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	if maps.PrincipalId != nil {
		principalId := maps.PrincipalId.Copy()
		destination.PrincipalId = &principalId
	} else {
		destination.PrincipalId = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Class containing feature settings of vault
type FeatureSettings struct {
	// CrossSubscriptionRestoreSettings: CrossSubscriptionRestore Settings
	CrossSubscriptionRestoreSettings *CrossSubscriptionRestoreSettings `json:"crossSubscriptionRestoreSettings,omitempty"`
}

var _ genruntime.ARMTransformer = &FeatureSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *FeatureSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.FeatureSettings{}

	// Set property "CrossSubscriptionRestoreSettings":
	if settings.CrossSubscriptionRestoreSettings != nil {
		crossSubscriptionRestoreSettings_ARM, err := (*settings.CrossSubscriptionRestoreSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		crossSubscriptionRestoreSettings := *crossSubscriptionRestoreSettings_ARM.(*arm.CrossSubscriptionRestoreSettings)
		result.CrossSubscriptionRestoreSettings = &crossSubscriptionRestoreSettings
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *FeatureSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FeatureSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *FeatureSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FeatureSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FeatureSettings, got %T", armInput)
	}

	// Set property "CrossSubscriptionRestoreSettings":
	if typedInput.CrossSubscriptionRestoreSettings != nil {
		var crossSubscriptionRestoreSettings1 CrossSubscriptionRestoreSettings
		err := crossSubscriptionRestoreSettings1.PopulateFromARM(owner, *typedInput.CrossSubscriptionRestoreSettings)
		if err != nil {
			return err
		}
		crossSubscriptionRestoreSettings := crossSubscriptionRestoreSettings1
		settings.CrossSubscriptionRestoreSettings = &crossSubscriptionRestoreSettings
	}

	// No error
	return nil
}

// AssignProperties_From_FeatureSettings populates our FeatureSettings from the provided source FeatureSettings
func (settings *FeatureSettings) AssignProperties_From_FeatureSettings(source *storage.FeatureSettings) error {

	// CrossSubscriptionRestoreSettings
	if source.CrossSubscriptionRestoreSettings != nil {
		var crossSubscriptionRestoreSetting CrossSubscriptionRestoreSettings
		err := crossSubscriptionRestoreSetting.AssignProperties_From_CrossSubscriptionRestoreSettings(source.CrossSubscriptionRestoreSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CrossSubscriptionRestoreSettings() to populate field CrossSubscriptionRestoreSettings")
		}
		settings.CrossSubscriptionRestoreSettings = &crossSubscriptionRestoreSetting
	} else {
		settings.CrossSubscriptionRestoreSettings = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FeatureSettings populates the provided destination FeatureSettings from our FeatureSettings
func (settings *FeatureSettings) AssignProperties_To_FeatureSettings(destination *storage.FeatureSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CrossSubscriptionRestoreSettings
	if settings.CrossSubscriptionRestoreSettings != nil {
		var crossSubscriptionRestoreSetting storage.CrossSubscriptionRestoreSettings
		err := settings.CrossSubscriptionRestoreSettings.AssignProperties_To_CrossSubscriptionRestoreSettings(&crossSubscriptionRestoreSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CrossSubscriptionRestoreSettings() to populate field CrossSubscriptionRestoreSettings")
		}
		destination.CrossSubscriptionRestoreSettings = &crossSubscriptionRestoreSetting
	} else {
		destination.CrossSubscriptionRestoreSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Class containing feature settings of vault
type FeatureSettings_STATUS struct {
	// CrossSubscriptionRestoreSettings: CrossSubscriptionRestore Settings
	CrossSubscriptionRestoreSettings *CrossSubscriptionRestoreSettings_STATUS `json:"crossSubscriptionRestoreSettings,omitempty"`
}

var _ genruntime.FromARMConverter = &FeatureSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *FeatureSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FeatureSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *FeatureSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FeatureSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FeatureSettings_STATUS, got %T", armInput)
	}

	// Set property "CrossSubscriptionRestoreSettings":
	if typedInput.CrossSubscriptionRestoreSettings != nil {
		var crossSubscriptionRestoreSettings1 CrossSubscriptionRestoreSettings_STATUS
		err := crossSubscriptionRestoreSettings1.PopulateFromARM(owner, *typedInput.CrossSubscriptionRestoreSettings)
		if err != nil {
			return err
		}
		crossSubscriptionRestoreSettings := crossSubscriptionRestoreSettings1
		settings.CrossSubscriptionRestoreSettings = &crossSubscriptionRestoreSettings
	}

	// No error
	return nil
}

// AssignProperties_From_FeatureSettings_STATUS populates our FeatureSettings_STATUS from the provided source FeatureSettings_STATUS
func (settings *FeatureSettings_STATUS) AssignProperties_From_FeatureSettings_STATUS(source *storage.FeatureSettings_STATUS) error {

	// CrossSubscriptionRestoreSettings
	if source.CrossSubscriptionRestoreSettings != nil {
		var crossSubscriptionRestoreSetting CrossSubscriptionRestoreSettings_STATUS
		err := crossSubscriptionRestoreSetting.AssignProperties_From_CrossSubscriptionRestoreSettings_STATUS(source.CrossSubscriptionRestoreSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CrossSubscriptionRestoreSettings_STATUS() to populate field CrossSubscriptionRestoreSettings")
		}
		settings.CrossSubscriptionRestoreSettings = &crossSubscriptionRestoreSetting
	} else {
		settings.CrossSubscriptionRestoreSettings = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FeatureSettings_STATUS populates the provided destination FeatureSettings_STATUS from our FeatureSettings_STATUS
func (settings *FeatureSettings_STATUS) AssignProperties_To_FeatureSettings_STATUS(destination *storage.FeatureSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CrossSubscriptionRestoreSettings
	if settings.CrossSubscriptionRestoreSettings != nil {
		var crossSubscriptionRestoreSetting storage.CrossSubscriptionRestoreSettings_STATUS
		err := settings.CrossSubscriptionRestoreSettings.AssignProperties_To_CrossSubscriptionRestoreSettings_STATUS(&crossSubscriptionRestoreSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CrossSubscriptionRestoreSettings_STATUS() to populate field CrossSubscriptionRestoreSettings")
		}
		destination.CrossSubscriptionRestoreSettings = &crossSubscriptionRestoreSetting
	} else {
		destination.CrossSubscriptionRestoreSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Monitoring Settings
type MonitoringSettings struct {
	// AzureMonitorAlertSettings: Settings for Azure Monitor based alerts
	AzureMonitorAlertSettings *AzureMonitorAlertSettings `json:"azureMonitorAlertSettings,omitempty"`
}

var _ genruntime.ARMTransformer = &MonitoringSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *MonitoringSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.MonitoringSettings{}

	// Set property "AzureMonitorAlertSettings":
	if settings.AzureMonitorAlertSettings != nil {
		azureMonitorAlertSettings_ARM, err := (*settings.AzureMonitorAlertSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		azureMonitorAlertSettings := *azureMonitorAlertSettings_ARM.(*arm.AzureMonitorAlertSettings)
		result.AzureMonitorAlertSettings = &azureMonitorAlertSettings
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *MonitoringSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.MonitoringSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *MonitoringSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.MonitoringSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.MonitoringSettings, got %T", armInput)
	}

	// Set property "AzureMonitorAlertSettings":
	if typedInput.AzureMonitorAlertSettings != nil {
		var azureMonitorAlertSettings1 AzureMonitorAlertSettings
		err := azureMonitorAlertSettings1.PopulateFromARM(owner, *typedInput.AzureMonitorAlertSettings)
		if err != nil {
			return err
		}
		azureMonitorAlertSettings := azureMonitorAlertSettings1
		settings.AzureMonitorAlertSettings = &azureMonitorAlertSettings
	}

	// No error
	return nil
}

// AssignProperties_From_MonitoringSettings populates our MonitoringSettings from the provided source MonitoringSettings
func (settings *MonitoringSettings) AssignProperties_From_MonitoringSettings(source *storage.MonitoringSettings) error {

	// AzureMonitorAlertSettings
	if source.AzureMonitorAlertSettings != nil {
		var azureMonitorAlertSetting AzureMonitorAlertSettings
		err := azureMonitorAlertSetting.AssignProperties_From_AzureMonitorAlertSettings(source.AzureMonitorAlertSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AzureMonitorAlertSettings() to populate field AzureMonitorAlertSettings")
		}
		settings.AzureMonitorAlertSettings = &azureMonitorAlertSetting
	} else {
		settings.AzureMonitorAlertSettings = nil
	}

	// No error
	return nil
}

// AssignProperties_To_MonitoringSettings populates the provided destination MonitoringSettings from our MonitoringSettings
func (settings *MonitoringSettings) AssignProperties_To_MonitoringSettings(destination *storage.MonitoringSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureMonitorAlertSettings
	if settings.AzureMonitorAlertSettings != nil {
		var azureMonitorAlertSetting storage.AzureMonitorAlertSettings
		err := settings.AzureMonitorAlertSettings.AssignProperties_To_AzureMonitorAlertSettings(&azureMonitorAlertSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AzureMonitorAlertSettings() to populate field AzureMonitorAlertSettings")
		}
		destination.AzureMonitorAlertSettings = &azureMonitorAlertSetting
	} else {
		destination.AzureMonitorAlertSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Monitoring Settings
type MonitoringSettings_STATUS struct {
	// AzureMonitorAlertSettings: Settings for Azure Monitor based alerts
	AzureMonitorAlertSettings *AzureMonitorAlertSettings_STATUS `json:"azureMonitorAlertSettings,omitempty"`
}

var _ genruntime.FromARMConverter = &MonitoringSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *MonitoringSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.MonitoringSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *MonitoringSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.MonitoringSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.MonitoringSettings_STATUS, got %T", armInput)
	}

	// Set property "AzureMonitorAlertSettings":
	if typedInput.AzureMonitorAlertSettings != nil {
		var azureMonitorAlertSettings1 AzureMonitorAlertSettings_STATUS
		err := azureMonitorAlertSettings1.PopulateFromARM(owner, *typedInput.AzureMonitorAlertSettings)
		if err != nil {
			return err
		}
		azureMonitorAlertSettings := azureMonitorAlertSettings1
		settings.AzureMonitorAlertSettings = &azureMonitorAlertSettings
	}

	// No error
	return nil
}

// AssignProperties_From_MonitoringSettings_STATUS populates our MonitoringSettings_STATUS from the provided source MonitoringSettings_STATUS
func (settings *MonitoringSettings_STATUS) AssignProperties_From_MonitoringSettings_STATUS(source *storage.MonitoringSettings_STATUS) error {

	// AzureMonitorAlertSettings
	if source.AzureMonitorAlertSettings != nil {
		var azureMonitorAlertSetting AzureMonitorAlertSettings_STATUS
		err := azureMonitorAlertSetting.AssignProperties_From_AzureMonitorAlertSettings_STATUS(source.AzureMonitorAlertSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AzureMonitorAlertSettings_STATUS() to populate field AzureMonitorAlertSettings")
		}
		settings.AzureMonitorAlertSettings = &azureMonitorAlertSetting
	} else {
		settings.AzureMonitorAlertSettings = nil
	}

	// No error
	return nil
}

// AssignProperties_To_MonitoringSettings_STATUS populates the provided destination MonitoringSettings_STATUS from our MonitoringSettings_STATUS
func (settings *MonitoringSettings_STATUS) AssignProperties_To_MonitoringSettings_STATUS(destination *storage.MonitoringSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureMonitorAlertSettings
	if settings.AzureMonitorAlertSettings != nil {
		var azureMonitorAlertSetting storage.AzureMonitorAlertSettings_STATUS
		err := settings.AzureMonitorAlertSettings.AssignProperties_To_AzureMonitorAlertSettings_STATUS(&azureMonitorAlertSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AzureMonitorAlertSettings_STATUS() to populate field AzureMonitorAlertSettings")
		}
		destination.AzureMonitorAlertSettings = &azureMonitorAlertSetting
	} else {
		destination.AzureMonitorAlertSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// ResourceMoveDetails will be returned in response to GetResource call from ARM
type ResourceMoveDetails_STATUS struct {
	// CompletionTimeUtc: Completion time in UTC of latest ResourceMove operation attempted. ISO 8601 format.
	CompletionTimeUtc *string `json:"completionTimeUtc,omitempty"`

	// OperationId: CorrelationId of latest ResourceMove operation attempted
	OperationId *string `json:"operationId,omitempty"`

	// SourceResourcePath: ARM resource path of source resource
	SourceResourcePath *string `json:"sourceResourcePath,omitempty"`

	// StartTimeUtc: Start time in UTC of latest ResourceMove operation attempted. ISO 8601 format.
	StartTimeUtc *string `json:"startTimeUtc,omitempty"`

	// TargetResourcePath: ARM resource path of target resource used in latest ResourceMove operation
	TargetResourcePath *string `json:"targetResourcePath,omitempty"`
}

var _ genruntime.FromARMConverter = &ResourceMoveDetails_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (details *ResourceMoveDetails_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ResourceMoveDetails_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (details *ResourceMoveDetails_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ResourceMoveDetails_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ResourceMoveDetails_STATUS, got %T", armInput)
	}

	// Set property "CompletionTimeUtc":
	if typedInput.CompletionTimeUtc != nil {
		completionTimeUtc := *typedInput.CompletionTimeUtc
		details.CompletionTimeUtc = &completionTimeUtc
	}

	// Set property "OperationId":
	if typedInput.OperationId != nil {
		operationId := *typedInput.OperationId
		details.OperationId = &operationId
	}

	// Set property "SourceResourcePath":
	if typedInput.SourceResourcePath != nil {
		sourceResourcePath := *typedInput.SourceResourcePath
		details.SourceResourcePath = &sourceResourcePath
	}

	// Set property "StartTimeUtc":
	if typedInput.StartTimeUtc != nil {
		startTimeUtc := *typedInput.StartTimeUtc
		details.StartTimeUtc = &startTimeUtc
	}

	// Set property "TargetResourcePath":
	if typedInput.TargetResourcePath != nil {
		targetResourcePath := *typedInput.TargetResourcePath
		details.TargetResourcePath = &targetResourcePath
	}

	// No error
	return nil
}

// AssignProperties_From_ResourceMoveDetails_STATUS populates our ResourceMoveDetails_STATUS from the provided source ResourceMoveDetails_STATUS
func (details *ResourceMoveDetails_STATUS) AssignProperties_From_ResourceMoveDetails_STATUS(source *storage.ResourceMoveDetails_STATUS) error {

	// CompletionTimeUtc
	details.CompletionTimeUtc = genruntime.ClonePointerToString(source.CompletionTimeUtc)

	// OperationId
	details.OperationId = genruntime.ClonePointerToString(source.OperationId)

	// SourceResourcePath
	details.SourceResourcePath = genruntime.ClonePointerToString(source.SourceResourcePath)

	// StartTimeUtc
	details.StartTimeUtc = genruntime.ClonePointerToString(source.StartTimeUtc)

	// TargetResourcePath
	details.TargetResourcePath = genruntime.ClonePointerToString(source.TargetResourcePath)

	// No error
	return nil
}

// AssignProperties_To_ResourceMoveDetails_STATUS populates the provided destination ResourceMoveDetails_STATUS from our ResourceMoveDetails_STATUS
func (details *ResourceMoveDetails_STATUS) AssignProperties_To_ResourceMoveDetails_STATUS(destination *storage.ResourceMoveDetails_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CompletionTimeUtc
	destination.CompletionTimeUtc = genruntime.ClonePointerToString(details.CompletionTimeUtc)

	// OperationId
	destination.OperationId = genruntime.ClonePointerToString(details.OperationId)

	// SourceResourcePath
	destination.SourceResourcePath = genruntime.ClonePointerToString(details.SourceResourcePath)

	// StartTimeUtc
	destination.StartTimeUtc = genruntime.ClonePointerToString(details.StartTimeUtc)

	// TargetResourcePath
	destination.TargetResourcePath = genruntime.ClonePointerToString(details.TargetResourcePath)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Class containing security settings of vault
type SecuritySettings struct {
	// ImmutabilitySettings: Immutability Settings at vault level
	ImmutabilitySettings *ImmutabilitySettings `json:"immutabilitySettings,omitempty"`

	// SoftDeleteSettings: Soft delete related settings
	SoftDeleteSettings *SoftDeleteSettings `json:"softDeleteSettings,omitempty"`
}

var _ genruntime.ARMTransformer = &SecuritySettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *SecuritySettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.SecuritySettings{}

	// Set property "ImmutabilitySettings":
	if settings.ImmutabilitySettings != nil {
		immutabilitySettings_ARM, err := (*settings.ImmutabilitySettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		immutabilitySettings := *immutabilitySettings_ARM.(*arm.ImmutabilitySettings)
		result.ImmutabilitySettings = &immutabilitySettings
	}

	// Set property "SoftDeleteSettings":
	if settings.SoftDeleteSettings != nil {
		softDeleteSettings_ARM, err := (*settings.SoftDeleteSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		softDeleteSettings := *softDeleteSettings_ARM.(*arm.SoftDeleteSettings)
		result.SoftDeleteSettings = &softDeleteSettings
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *SecuritySettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SecuritySettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *SecuritySettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SecuritySettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SecuritySettings, got %T", armInput)
	}

	// Set property "ImmutabilitySettings":
	if typedInput.ImmutabilitySettings != nil {
		var immutabilitySettings1 ImmutabilitySettings
		err := immutabilitySettings1.PopulateFromARM(owner, *typedInput.ImmutabilitySettings)
		if err != nil {
			return err
		}
		immutabilitySettings := immutabilitySettings1
		settings.ImmutabilitySettings = &immutabilitySettings
	}

	// Set property "SoftDeleteSettings":
	if typedInput.SoftDeleteSettings != nil {
		var softDeleteSettings1 SoftDeleteSettings
		err := softDeleteSettings1.PopulateFromARM(owner, *typedInput.SoftDeleteSettings)
		if err != nil {
			return err
		}
		softDeleteSettings := softDeleteSettings1
		settings.SoftDeleteSettings = &softDeleteSettings
	}

	// No error
	return nil
}

// AssignProperties_From_SecuritySettings populates our SecuritySettings from the provided source SecuritySettings
func (settings *SecuritySettings) AssignProperties_From_SecuritySettings(source *storage.SecuritySettings) error {

	// ImmutabilitySettings
	if source.ImmutabilitySettings != nil {
		var immutabilitySetting ImmutabilitySettings
		err := immutabilitySetting.AssignProperties_From_ImmutabilitySettings(source.ImmutabilitySettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ImmutabilitySettings() to populate field ImmutabilitySettings")
		}
		settings.ImmutabilitySettings = &immutabilitySetting
	} else {
		settings.ImmutabilitySettings = nil
	}

	// SoftDeleteSettings
	if source.SoftDeleteSettings != nil {
		var softDeleteSetting SoftDeleteSettings
		err := softDeleteSetting.AssignProperties_From_SoftDeleteSettings(source.SoftDeleteSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SoftDeleteSettings() to populate field SoftDeleteSettings")
		}
		settings.SoftDeleteSettings = &softDeleteSetting
	} else {
		settings.SoftDeleteSettings = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SecuritySettings populates the provided destination SecuritySettings from our SecuritySettings
func (settings *SecuritySettings) AssignProperties_To_SecuritySettings(destination *storage.SecuritySettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ImmutabilitySettings
	if settings.ImmutabilitySettings != nil {
		var immutabilitySetting storage.ImmutabilitySettings
		err := settings.ImmutabilitySettings.AssignProperties_To_ImmutabilitySettings(&immutabilitySetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ImmutabilitySettings() to populate field ImmutabilitySettings")
		}
		destination.ImmutabilitySettings = &immutabilitySetting
	} else {
		destination.ImmutabilitySettings = nil
	}

	// SoftDeleteSettings
	if settings.SoftDeleteSettings != nil {
		var softDeleteSetting storage.SoftDeleteSettings
		err := settings.SoftDeleteSettings.AssignProperties_To_SoftDeleteSettings(&softDeleteSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SoftDeleteSettings() to populate field SoftDeleteSettings")
		}
		destination.SoftDeleteSettings = &softDeleteSetting
	} else {
		destination.SoftDeleteSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Class containing security settings of vault
type SecuritySettings_STATUS struct {
	// ImmutabilitySettings: Immutability Settings at vault level
	ImmutabilitySettings *ImmutabilitySettings_STATUS `json:"immutabilitySettings,omitempty"`

	// SoftDeleteSettings: Soft delete related settings
	SoftDeleteSettings *SoftDeleteSettings_STATUS `json:"softDeleteSettings,omitempty"`
}

var _ genruntime.FromARMConverter = &SecuritySettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *SecuritySettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SecuritySettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *SecuritySettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SecuritySettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SecuritySettings_STATUS, got %T", armInput)
	}

	// Set property "ImmutabilitySettings":
	if typedInput.ImmutabilitySettings != nil {
		var immutabilitySettings1 ImmutabilitySettings_STATUS
		err := immutabilitySettings1.PopulateFromARM(owner, *typedInput.ImmutabilitySettings)
		if err != nil {
			return err
		}
		immutabilitySettings := immutabilitySettings1
		settings.ImmutabilitySettings = &immutabilitySettings
	}

	// Set property "SoftDeleteSettings":
	if typedInput.SoftDeleteSettings != nil {
		var softDeleteSettings1 SoftDeleteSettings_STATUS
		err := softDeleteSettings1.PopulateFromARM(owner, *typedInput.SoftDeleteSettings)
		if err != nil {
			return err
		}
		softDeleteSettings := softDeleteSettings1
		settings.SoftDeleteSettings = &softDeleteSettings
	}

	// No error
	return nil
}

// AssignProperties_From_SecuritySettings_STATUS populates our SecuritySettings_STATUS from the provided source SecuritySettings_STATUS
func (settings *SecuritySettings_STATUS) AssignProperties_From_SecuritySettings_STATUS(source *storage.SecuritySettings_STATUS) error {

	// ImmutabilitySettings
	if source.ImmutabilitySettings != nil {
		var immutabilitySetting ImmutabilitySettings_STATUS
		err := immutabilitySetting.AssignProperties_From_ImmutabilitySettings_STATUS(source.ImmutabilitySettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ImmutabilitySettings_STATUS() to populate field ImmutabilitySettings")
		}
		settings.ImmutabilitySettings = &immutabilitySetting
	} else {
		settings.ImmutabilitySettings = nil
	}

	// SoftDeleteSettings
	if source.SoftDeleteSettings != nil {
		var softDeleteSetting SoftDeleteSettings_STATUS
		err := softDeleteSetting.AssignProperties_From_SoftDeleteSettings_STATUS(source.SoftDeleteSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SoftDeleteSettings_STATUS() to populate field SoftDeleteSettings")
		}
		settings.SoftDeleteSettings = &softDeleteSetting
	} else {
		settings.SoftDeleteSettings = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SecuritySettings_STATUS populates the provided destination SecuritySettings_STATUS from our SecuritySettings_STATUS
func (settings *SecuritySettings_STATUS) AssignProperties_To_SecuritySettings_STATUS(destination *storage.SecuritySettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ImmutabilitySettings
	if settings.ImmutabilitySettings != nil {
		var immutabilitySetting storage.ImmutabilitySettings_STATUS
		err := settings.ImmutabilitySettings.AssignProperties_To_ImmutabilitySettings_STATUS(&immutabilitySetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ImmutabilitySettings_STATUS() to populate field ImmutabilitySettings")
		}
		destination.ImmutabilitySettings = &immutabilitySetting
	} else {
		destination.ImmutabilitySettings = nil
	}

	// SoftDeleteSettings
	if settings.SoftDeleteSettings != nil {
		var softDeleteSetting storage.SoftDeleteSettings_STATUS
		err := settings.SoftDeleteSettings.AssignProperties_To_SoftDeleteSettings_STATUS(&softDeleteSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SoftDeleteSettings_STATUS() to populate field SoftDeleteSettings")
		}
		destination.SoftDeleteSettings = &softDeleteSetting
	} else {
		destination.SoftDeleteSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage setting
type StorageSetting struct {
	// DatastoreType: Gets or sets the type of the datastore.
	DatastoreType *StorageSetting_DatastoreType `json:"datastoreType,omitempty"`

	// Type: Gets or sets the type.
	Type *StorageSetting_Type `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &StorageSetting{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (setting *StorageSetting) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if setting == nil {
		return nil, nil
	}
	result := &arm.StorageSetting{}

	// Set property "DatastoreType":
	if setting.DatastoreType != nil {
		var temp string
		temp = string(*setting.DatastoreType)
		datastoreType := arm.StorageSetting_DatastoreType(temp)
		result.DatastoreType = &datastoreType
	}

	// Set property "Type":
	if setting.Type != nil {
		var temp string
		temp = string(*setting.Type)
		typeVar := arm.StorageSetting_Type(temp)
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (setting *StorageSetting) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.StorageSetting{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (setting *StorageSetting) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.StorageSetting)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.StorageSetting, got %T", armInput)
	}

	// Set property "DatastoreType":
	if typedInput.DatastoreType != nil {
		var temp string
		temp = string(*typedInput.DatastoreType)
		datastoreType := StorageSetting_DatastoreType(temp)
		setting.DatastoreType = &datastoreType
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := StorageSetting_Type(temp)
		setting.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_StorageSetting populates our StorageSetting from the provided source StorageSetting
func (setting *StorageSetting) AssignProperties_From_StorageSetting(source *storage.StorageSetting) error {

	// DatastoreType
	if source.DatastoreType != nil {
		datastoreType := *source.DatastoreType
		datastoreTypeTemp := genruntime.ToEnum(datastoreType, storageSetting_DatastoreType_Values)
		setting.DatastoreType = &datastoreTypeTemp
	} else {
		setting.DatastoreType = nil
	}

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, storageSetting_Type_Values)
		setting.Type = &typeTemp
	} else {
		setting.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_StorageSetting populates the provided destination StorageSetting from our StorageSetting
func (setting *StorageSetting) AssignProperties_To_StorageSetting(destination *storage.StorageSetting) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DatastoreType
	if setting.DatastoreType != nil {
		datastoreType := string(*setting.DatastoreType)
		destination.DatastoreType = &datastoreType
	} else {
		destination.DatastoreType = nil
	}

	// Type
	if setting.Type != nil {
		typeVar := string(*setting.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage setting
type StorageSetting_STATUS struct {
	// DatastoreType: Gets or sets the type of the datastore.
	DatastoreType *StorageSetting_DatastoreType_STATUS `json:"datastoreType,omitempty"`

	// Type: Gets or sets the type.
	Type *StorageSetting_Type_STATUS `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &StorageSetting_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (setting *StorageSetting_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.StorageSetting_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (setting *StorageSetting_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.StorageSetting_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.StorageSetting_STATUS, got %T", armInput)
	}

	// Set property "DatastoreType":
	if typedInput.DatastoreType != nil {
		var temp string
		temp = string(*typedInput.DatastoreType)
		datastoreType := StorageSetting_DatastoreType_STATUS(temp)
		setting.DatastoreType = &datastoreType
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := StorageSetting_Type_STATUS(temp)
		setting.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_StorageSetting_STATUS populates our StorageSetting_STATUS from the provided source StorageSetting_STATUS
func (setting *StorageSetting_STATUS) AssignProperties_From_StorageSetting_STATUS(source *storage.StorageSetting_STATUS) error {

	// DatastoreType
	if source.DatastoreType != nil {
		datastoreType := *source.DatastoreType
		datastoreTypeTemp := genruntime.ToEnum(datastoreType, storageSetting_DatastoreType_STATUS_Values)
		setting.DatastoreType = &datastoreTypeTemp
	} else {
		setting.DatastoreType = nil
	}

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, storageSetting_Type_STATUS_Values)
		setting.Type = &typeTemp
	} else {
		setting.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_StorageSetting_STATUS populates the provided destination StorageSetting_STATUS from our StorageSetting_STATUS
func (setting *StorageSetting_STATUS) AssignProperties_To_StorageSetting_STATUS(destination *storage.StorageSetting_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DatastoreType
	if setting.DatastoreType != nil {
		datastoreType := string(*setting.DatastoreType)
		destination.DatastoreType = &datastoreType
	} else {
		destination.DatastoreType = nil
	}

	// Type
	if setting.Type != nil {
		typeVar := string(*setting.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type SystemData_CreatedByType_STATUS string

const (
	SystemData_CreatedByType_STATUS_Application     = SystemData_CreatedByType_STATUS("Application")
	SystemData_CreatedByType_STATUS_Key             = SystemData_CreatedByType_STATUS("Key")
	SystemData_CreatedByType_STATUS_ManagedIdentity = SystemData_CreatedByType_STATUS("ManagedIdentity")
	SystemData_CreatedByType_STATUS_User            = SystemData_CreatedByType_STATUS("User")
)

// Mapping from string to SystemData_CreatedByType_STATUS
var systemData_CreatedByType_STATUS_Values = map[string]SystemData_CreatedByType_STATUS{
	"application":     SystemData_CreatedByType_STATUS_Application,
	"key":             SystemData_CreatedByType_STATUS_Key,
	"managedidentity": SystemData_CreatedByType_STATUS_ManagedIdentity,
	"user":            SystemData_CreatedByType_STATUS_User,
}

type SystemData_LastModifiedByType_STATUS string

const (
	SystemData_LastModifiedByType_STATUS_Application     = SystemData_LastModifiedByType_STATUS("Application")
	SystemData_LastModifiedByType_STATUS_Key             = SystemData_LastModifiedByType_STATUS("Key")
	SystemData_LastModifiedByType_STATUS_ManagedIdentity = SystemData_LastModifiedByType_STATUS("ManagedIdentity")
	SystemData_LastModifiedByType_STATUS_User            = SystemData_LastModifiedByType_STATUS("User")
)

// Mapping from string to SystemData_LastModifiedByType_STATUS
var systemData_LastModifiedByType_STATUS_Values = map[string]SystemData_LastModifiedByType_STATUS{
	"application":     SystemData_LastModifiedByType_STATUS_Application,
	"key":             SystemData_LastModifiedByType_STATUS_Key,
	"managedidentity": SystemData_LastModifiedByType_STATUS_ManagedIdentity,
	"user":            SystemData_LastModifiedByType_STATUS_User,
}

// Settings for Azure Monitor based alerts
type AzureMonitorAlertSettings struct {
	AlertsForAllJobFailures *AzureMonitorAlertSettings_AlertsForAllJobFailures `json:"alertsForAllJobFailures,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureMonitorAlertSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *AzureMonitorAlertSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.AzureMonitorAlertSettings{}

	// Set property "AlertsForAllJobFailures":
	if settings.AlertsForAllJobFailures != nil {
		var temp string
		temp = string(*settings.AlertsForAllJobFailures)
		alertsForAllJobFailures := arm.AzureMonitorAlertSettings_AlertsForAllJobFailures(temp)
		result.AlertsForAllJobFailures = &alertsForAllJobFailures
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *AzureMonitorAlertSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureMonitorAlertSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *AzureMonitorAlertSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureMonitorAlertSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureMonitorAlertSettings, got %T", armInput)
	}

	// Set property "AlertsForAllJobFailures":
	if typedInput.AlertsForAllJobFailures != nil {
		var temp string
		temp = string(*typedInput.AlertsForAllJobFailures)
		alertsForAllJobFailures := AzureMonitorAlertSettings_AlertsForAllJobFailures(temp)
		settings.AlertsForAllJobFailures = &alertsForAllJobFailures
	}

	// No error
	return nil
}

// AssignProperties_From_AzureMonitorAlertSettings populates our AzureMonitorAlertSettings from the provided source AzureMonitorAlertSettings
func (settings *AzureMonitorAlertSettings) AssignProperties_From_AzureMonitorAlertSettings(source *storage.AzureMonitorAlertSettings) error {

	// AlertsForAllJobFailures
	if source.AlertsForAllJobFailures != nil {
		alertsForAllJobFailure := *source.AlertsForAllJobFailures
		alertsForAllJobFailureTemp := genruntime.ToEnum(alertsForAllJobFailure, azureMonitorAlertSettings_AlertsForAllJobFailures_Values)
		settings.AlertsForAllJobFailures = &alertsForAllJobFailureTemp
	} else {
		settings.AlertsForAllJobFailures = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureMonitorAlertSettings populates the provided destination AzureMonitorAlertSettings from our AzureMonitorAlertSettings
func (settings *AzureMonitorAlertSettings) AssignProperties_To_AzureMonitorAlertSettings(destination *storage.AzureMonitorAlertSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AlertsForAllJobFailures
	if settings.AlertsForAllJobFailures != nil {
		alertsForAllJobFailure := string(*settings.AlertsForAllJobFailures)
		destination.AlertsForAllJobFailures = &alertsForAllJobFailure
	} else {
		destination.AlertsForAllJobFailures = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Settings for Azure Monitor based alerts
type AzureMonitorAlertSettings_STATUS struct {
	AlertsForAllJobFailures *AzureMonitorAlertSettings_AlertsForAllJobFailures_STATUS `json:"alertsForAllJobFailures,omitempty"`
}

var _ genruntime.FromARMConverter = &AzureMonitorAlertSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *AzureMonitorAlertSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureMonitorAlertSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *AzureMonitorAlertSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureMonitorAlertSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureMonitorAlertSettings_STATUS, got %T", armInput)
	}

	// Set property "AlertsForAllJobFailures":
	if typedInput.AlertsForAllJobFailures != nil {
		var temp string
		temp = string(*typedInput.AlertsForAllJobFailures)
		alertsForAllJobFailures := AzureMonitorAlertSettings_AlertsForAllJobFailures_STATUS(temp)
		settings.AlertsForAllJobFailures = &alertsForAllJobFailures
	}

	// No error
	return nil
}

// AssignProperties_From_AzureMonitorAlertSettings_STATUS populates our AzureMonitorAlertSettings_STATUS from the provided source AzureMonitorAlertSettings_STATUS
func (settings *AzureMonitorAlertSettings_STATUS) AssignProperties_From_AzureMonitorAlertSettings_STATUS(source *storage.AzureMonitorAlertSettings_STATUS) error {

	// AlertsForAllJobFailures
	if source.AlertsForAllJobFailures != nil {
		alertsForAllJobFailure := *source.AlertsForAllJobFailures
		alertsForAllJobFailureTemp := genruntime.ToEnum(alertsForAllJobFailure, azureMonitorAlertSettings_AlertsForAllJobFailures_STATUS_Values)
		settings.AlertsForAllJobFailures = &alertsForAllJobFailureTemp
	} else {
		settings.AlertsForAllJobFailures = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureMonitorAlertSettings_STATUS populates the provided destination AzureMonitorAlertSettings_STATUS from our AzureMonitorAlertSettings_STATUS
func (settings *AzureMonitorAlertSettings_STATUS) AssignProperties_To_AzureMonitorAlertSettings_STATUS(destination *storage.AzureMonitorAlertSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AlertsForAllJobFailures
	if settings.AlertsForAllJobFailures != nil {
		alertsForAllJobFailure := string(*settings.AlertsForAllJobFailures)
		destination.AlertsForAllJobFailures = &alertsForAllJobFailure
	} else {
		destination.AlertsForAllJobFailures = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// CrossSubscriptionRestore Settings
type CrossSubscriptionRestoreSettings struct {
	// State: CrossSubscriptionRestore state
	State *CrossSubscriptionRestoreSettings_State `json:"state,omitempty"`
}

var _ genruntime.ARMTransformer = &CrossSubscriptionRestoreSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *CrossSubscriptionRestoreSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.CrossSubscriptionRestoreSettings{}

	// Set property "State":
	if settings.State != nil {
		var temp string
		temp = string(*settings.State)
		state := arm.CrossSubscriptionRestoreSettings_State(temp)
		result.State = &state
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *CrossSubscriptionRestoreSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CrossSubscriptionRestoreSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *CrossSubscriptionRestoreSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CrossSubscriptionRestoreSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CrossSubscriptionRestoreSettings, got %T", armInput)
	}

	// Set property "State":
	if typedInput.State != nil {
		var temp string
		temp = string(*typedInput.State)
		state := CrossSubscriptionRestoreSettings_State(temp)
		settings.State = &state
	}

	// No error
	return nil
}

// AssignProperties_From_CrossSubscriptionRestoreSettings populates our CrossSubscriptionRestoreSettings from the provided source CrossSubscriptionRestoreSettings
func (settings *CrossSubscriptionRestoreSettings) AssignProperties_From_CrossSubscriptionRestoreSettings(source *storage.CrossSubscriptionRestoreSettings) error {

	// State
	if source.State != nil {
		state := *source.State
		stateTemp := genruntime.ToEnum(state, crossSubscriptionRestoreSettings_State_Values)
		settings.State = &stateTemp
	} else {
		settings.State = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CrossSubscriptionRestoreSettings populates the provided destination CrossSubscriptionRestoreSettings from our CrossSubscriptionRestoreSettings
func (settings *CrossSubscriptionRestoreSettings) AssignProperties_To_CrossSubscriptionRestoreSettings(destination *storage.CrossSubscriptionRestoreSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// State
	if settings.State != nil {
		state := string(*settings.State)
		destination.State = &state
	} else {
		destination.State = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// CrossSubscriptionRestore Settings
type CrossSubscriptionRestoreSettings_STATUS struct {
	// State: CrossSubscriptionRestore state
	State *CrossSubscriptionRestoreSettings_State_STATUS `json:"state,omitempty"`
}

var _ genruntime.FromARMConverter = &CrossSubscriptionRestoreSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *CrossSubscriptionRestoreSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CrossSubscriptionRestoreSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *CrossSubscriptionRestoreSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CrossSubscriptionRestoreSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CrossSubscriptionRestoreSettings_STATUS, got %T", armInput)
	}

	// Set property "State":
	if typedInput.State != nil {
		var temp string
		temp = string(*typedInput.State)
		state := CrossSubscriptionRestoreSettings_State_STATUS(temp)
		settings.State = &state
	}

	// No error
	return nil
}

// AssignProperties_From_CrossSubscriptionRestoreSettings_STATUS populates our CrossSubscriptionRestoreSettings_STATUS from the provided source CrossSubscriptionRestoreSettings_STATUS
func (settings *CrossSubscriptionRestoreSettings_STATUS) AssignProperties_From_CrossSubscriptionRestoreSettings_STATUS(source *storage.CrossSubscriptionRestoreSettings_STATUS) error {

	// State
	if source.State != nil {
		state := *source.State
		stateTemp := genruntime.ToEnum(state, crossSubscriptionRestoreSettings_State_STATUS_Values)
		settings.State = &stateTemp
	} else {
		settings.State = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CrossSubscriptionRestoreSettings_STATUS populates the provided destination CrossSubscriptionRestoreSettings_STATUS from our CrossSubscriptionRestoreSettings_STATUS
func (settings *CrossSubscriptionRestoreSettings_STATUS) AssignProperties_To_CrossSubscriptionRestoreSettings_STATUS(destination *storage.CrossSubscriptionRestoreSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// State
	if settings.State != nil {
		state := string(*settings.State)
		destination.State = &state
	} else {
		destination.State = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Immutability Settings at vault level
type ImmutabilitySettings struct {
	// State: Immutability state
	State *ImmutabilitySettings_State `json:"state,omitempty"`
}

var _ genruntime.ARMTransformer = &ImmutabilitySettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *ImmutabilitySettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.ImmutabilitySettings{}

	// Set property "State":
	if settings.State != nil {
		var temp string
		temp = string(*settings.State)
		state := arm.ImmutabilitySettings_State(temp)
		result.State = &state
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *ImmutabilitySettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ImmutabilitySettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *ImmutabilitySettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ImmutabilitySettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ImmutabilitySettings, got %T", armInput)
	}

	// Set property "State":
	if typedInput.State != nil {
		var temp string
		temp = string(*typedInput.State)
		state := ImmutabilitySettings_State(temp)
		settings.State = &state
	}

	// No error
	return nil
}

// AssignProperties_From_ImmutabilitySettings populates our ImmutabilitySettings from the provided source ImmutabilitySettings
func (settings *ImmutabilitySettings) AssignProperties_From_ImmutabilitySettings(source *storage.ImmutabilitySettings) error {

	// State
	if source.State != nil {
		state := *source.State
		stateTemp := genruntime.ToEnum(state, immutabilitySettings_State_Values)
		settings.State = &stateTemp
	} else {
		settings.State = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ImmutabilitySettings populates the provided destination ImmutabilitySettings from our ImmutabilitySettings
func (settings *ImmutabilitySettings) AssignProperties_To_ImmutabilitySettings(destination *storage.ImmutabilitySettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// State
	if settings.State != nil {
		state := string(*settings.State)
		destination.State = &state
	} else {
		destination.State = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Immutability Settings at vault level
type ImmutabilitySettings_STATUS struct {
	// State: Immutability state
	State *ImmutabilitySettings_State_STATUS `json:"state,omitempty"`
}

var _ genruntime.FromARMConverter = &ImmutabilitySettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *ImmutabilitySettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ImmutabilitySettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *ImmutabilitySettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ImmutabilitySettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ImmutabilitySettings_STATUS, got %T", armInput)
	}

	// Set property "State":
	if typedInput.State != nil {
		var temp string
		temp = string(*typedInput.State)
		state := ImmutabilitySettings_State_STATUS(temp)
		settings.State = &state
	}

	// No error
	return nil
}

// AssignProperties_From_ImmutabilitySettings_STATUS populates our ImmutabilitySettings_STATUS from the provided source ImmutabilitySettings_STATUS
func (settings *ImmutabilitySettings_STATUS) AssignProperties_From_ImmutabilitySettings_STATUS(source *storage.ImmutabilitySettings_STATUS) error {

	// State
	if source.State != nil {
		state := *source.State
		stateTemp := genruntime.ToEnum(state, immutabilitySettings_State_STATUS_Values)
		settings.State = &stateTemp
	} else {
		settings.State = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ImmutabilitySettings_STATUS populates the provided destination ImmutabilitySettings_STATUS from our ImmutabilitySettings_STATUS
func (settings *ImmutabilitySettings_STATUS) AssignProperties_To_ImmutabilitySettings_STATUS(destination *storage.ImmutabilitySettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// State
	if settings.State != nil {
		state := string(*settings.State)
		destination.State = &state
	} else {
		destination.State = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Soft delete related settings
type SoftDeleteSettings struct {
	// RetentionDurationInDays: Soft delete retention duration
	RetentionDurationInDays *float64 `json:"retentionDurationInDays,omitempty"`

	// State: State of soft delete
	State *SoftDeleteSettings_State `json:"state,omitempty"`
}

var _ genruntime.ARMTransformer = &SoftDeleteSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *SoftDeleteSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.SoftDeleteSettings{}

	// Set property "RetentionDurationInDays":
	if settings.RetentionDurationInDays != nil {
		retentionDurationInDays := *settings.RetentionDurationInDays
		result.RetentionDurationInDays = &retentionDurationInDays
	}

	// Set property "State":
	if settings.State != nil {
		var temp string
		temp = string(*settings.State)
		state := arm.SoftDeleteSettings_State(temp)
		result.State = &state
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *SoftDeleteSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SoftDeleteSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *SoftDeleteSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SoftDeleteSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SoftDeleteSettings, got %T", armInput)
	}

	// Set property "RetentionDurationInDays":
	if typedInput.RetentionDurationInDays != nil {
		retentionDurationInDays := *typedInput.RetentionDurationInDays
		settings.RetentionDurationInDays = &retentionDurationInDays
	}

	// Set property "State":
	if typedInput.State != nil {
		var temp string
		temp = string(*typedInput.State)
		state := SoftDeleteSettings_State(temp)
		settings.State = &state
	}

	// No error
	return nil
}

// AssignProperties_From_SoftDeleteSettings populates our SoftDeleteSettings from the provided source SoftDeleteSettings
func (settings *SoftDeleteSettings) AssignProperties_From_SoftDeleteSettings(source *storage.SoftDeleteSettings) error {

	// RetentionDurationInDays
	if source.RetentionDurationInDays != nil {
		retentionDurationInDay := *source.RetentionDurationInDays
		settings.RetentionDurationInDays = &retentionDurationInDay
	} else {
		settings.RetentionDurationInDays = nil
	}

	// State
	if source.State != nil {
		state := *source.State
		stateTemp := genruntime.ToEnum(state, softDeleteSettings_State_Values)
		settings.State = &stateTemp
	} else {
		settings.State = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SoftDeleteSettings populates the provided destination SoftDeleteSettings from our SoftDeleteSettings
func (settings *SoftDeleteSettings) AssignProperties_To_SoftDeleteSettings(destination *storage.SoftDeleteSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RetentionDurationInDays
	if settings.RetentionDurationInDays != nil {
		retentionDurationInDay := *settings.RetentionDurationInDays
		destination.RetentionDurationInDays = &retentionDurationInDay
	} else {
		destination.RetentionDurationInDays = nil
	}

	// State
	if settings.State != nil {
		state := string(*settings.State)
		destination.State = &state
	} else {
		destination.State = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Soft delete related settings
type SoftDeleteSettings_STATUS struct {
	// RetentionDurationInDays: Soft delete retention duration
	RetentionDurationInDays *float64 `json:"retentionDurationInDays,omitempty"`

	// State: State of soft delete
	State *SoftDeleteSettings_State_STATUS `json:"state,omitempty"`
}

var _ genruntime.FromARMConverter = &SoftDeleteSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *SoftDeleteSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SoftDeleteSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *SoftDeleteSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SoftDeleteSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SoftDeleteSettings_STATUS, got %T", armInput)
	}

	// Set property "RetentionDurationInDays":
	if typedInput.RetentionDurationInDays != nil {
		retentionDurationInDays := *typedInput.RetentionDurationInDays
		settings.RetentionDurationInDays = &retentionDurationInDays
	}

	// Set property "State":
	if typedInput.State != nil {
		var temp string
		temp = string(*typedInput.State)
		state := SoftDeleteSettings_State_STATUS(temp)
		settings.State = &state
	}

	// No error
	return nil
}

// AssignProperties_From_SoftDeleteSettings_STATUS populates our SoftDeleteSettings_STATUS from the provided source SoftDeleteSettings_STATUS
func (settings *SoftDeleteSettings_STATUS) AssignProperties_From_SoftDeleteSettings_STATUS(source *storage.SoftDeleteSettings_STATUS) error {

	// RetentionDurationInDays
	if source.RetentionDurationInDays != nil {
		retentionDurationInDay := *source.RetentionDurationInDays
		settings.RetentionDurationInDays = &retentionDurationInDay
	} else {
		settings.RetentionDurationInDays = nil
	}

	// State
	if source.State != nil {
		state := *source.State
		stateTemp := genruntime.ToEnum(state, softDeleteSettings_State_STATUS_Values)
		settings.State = &stateTemp
	} else {
		settings.State = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SoftDeleteSettings_STATUS populates the provided destination SoftDeleteSettings_STATUS from our SoftDeleteSettings_STATUS
func (settings *SoftDeleteSettings_STATUS) AssignProperties_To_SoftDeleteSettings_STATUS(destination *storage.SoftDeleteSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RetentionDurationInDays
	if settings.RetentionDurationInDays != nil {
		retentionDurationInDay := *settings.RetentionDurationInDays
		destination.RetentionDurationInDays = &retentionDurationInDay
	} else {
		destination.RetentionDurationInDays = nil
	}

	// State
	if settings.State != nil {
		state := string(*settings.State)
		destination.State = &state
	} else {
		destination.State = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"ArchiveStore","OperationalStore","VaultStore"}
type StorageSetting_DatastoreType string

const (
	StorageSetting_DatastoreType_ArchiveStore     = StorageSetting_DatastoreType("ArchiveStore")
	StorageSetting_DatastoreType_OperationalStore = StorageSetting_DatastoreType("OperationalStore")
	StorageSetting_DatastoreType_VaultStore       = StorageSetting_DatastoreType("VaultStore")
)

// Mapping from string to StorageSetting_DatastoreType
var storageSetting_DatastoreType_Values = map[string]StorageSetting_DatastoreType{
	"archivestore":     StorageSetting_DatastoreType_ArchiveStore,
	"operationalstore": StorageSetting_DatastoreType_OperationalStore,
	"vaultstore":       StorageSetting_DatastoreType_VaultStore,
}

type StorageSetting_DatastoreType_STATUS string

const (
	StorageSetting_DatastoreType_STATUS_ArchiveStore     = StorageSetting_DatastoreType_STATUS("ArchiveStore")
	StorageSetting_DatastoreType_STATUS_OperationalStore = StorageSetting_DatastoreType_STATUS("OperationalStore")
	StorageSetting_DatastoreType_STATUS_VaultStore       = StorageSetting_DatastoreType_STATUS("VaultStore")
)

// Mapping from string to StorageSetting_DatastoreType_STATUS
var storageSetting_DatastoreType_STATUS_Values = map[string]StorageSetting_DatastoreType_STATUS{
	"archivestore":     StorageSetting_DatastoreType_STATUS_ArchiveStore,
	"operationalstore": StorageSetting_DatastoreType_STATUS_OperationalStore,
	"vaultstore":       StorageSetting_DatastoreType_STATUS_VaultStore,
}

// +kubebuilder:validation:Enum={"GeoRedundant","LocallyRedundant","ZoneRedundant"}
type StorageSetting_Type string

const (
	StorageSetting_Type_GeoRedundant     = StorageSetting_Type("GeoRedundant")
	StorageSetting_Type_LocallyRedundant = StorageSetting_Type("LocallyRedundant")
	StorageSetting_Type_ZoneRedundant    = StorageSetting_Type("ZoneRedundant")
)

// Mapping from string to StorageSetting_Type
var storageSetting_Type_Values = map[string]StorageSetting_Type{
	"georedundant":     StorageSetting_Type_GeoRedundant,
	"locallyredundant": StorageSetting_Type_LocallyRedundant,
	"zoneredundant":    StorageSetting_Type_ZoneRedundant,
}

type StorageSetting_Type_STATUS string

const (
	StorageSetting_Type_STATUS_GeoRedundant     = StorageSetting_Type_STATUS("GeoRedundant")
	StorageSetting_Type_STATUS_LocallyRedundant = StorageSetting_Type_STATUS("LocallyRedundant")
	StorageSetting_Type_STATUS_ZoneRedundant    = StorageSetting_Type_STATUS("ZoneRedundant")
)

// Mapping from string to StorageSetting_Type_STATUS
var storageSetting_Type_STATUS_Values = map[string]StorageSetting_Type_STATUS{
	"georedundant":     StorageSetting_Type_STATUS_GeoRedundant,
	"locallyredundant": StorageSetting_Type_STATUS_LocallyRedundant,
	"zoneredundant":    StorageSetting_Type_STATUS_ZoneRedundant,
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type AzureMonitorAlertSettings_AlertsForAllJobFailures string

const (
	AzureMonitorAlertSettings_AlertsForAllJobFailures_Disabled = AzureMonitorAlertSettings_AlertsForAllJobFailures("Disabled")
	AzureMonitorAlertSettings_AlertsForAllJobFailures_Enabled  = AzureMonitorAlertSettings_AlertsForAllJobFailures("Enabled")
)

// Mapping from string to AzureMonitorAlertSettings_AlertsForAllJobFailures
var azureMonitorAlertSettings_AlertsForAllJobFailures_Values = map[string]AzureMonitorAlertSettings_AlertsForAllJobFailures{
	"disabled": AzureMonitorAlertSettings_AlertsForAllJobFailures_Disabled,
	"enabled":  AzureMonitorAlertSettings_AlertsForAllJobFailures_Enabled,
}

type AzureMonitorAlertSettings_AlertsForAllJobFailures_STATUS string

const (
	AzureMonitorAlertSettings_AlertsForAllJobFailures_STATUS_Disabled = AzureMonitorAlertSettings_AlertsForAllJobFailures_STATUS("Disabled")
	AzureMonitorAlertSettings_AlertsForAllJobFailures_STATUS_Enabled  = AzureMonitorAlertSettings_AlertsForAllJobFailures_STATUS("Enabled")
)

// Mapping from string to AzureMonitorAlertSettings_AlertsForAllJobFailures_STATUS
var azureMonitorAlertSettings_AlertsForAllJobFailures_STATUS_Values = map[string]AzureMonitorAlertSettings_AlertsForAllJobFailures_STATUS{
	"disabled": AzureMonitorAlertSettings_AlertsForAllJobFailures_STATUS_Disabled,
	"enabled":  AzureMonitorAlertSettings_AlertsForAllJobFailures_STATUS_Enabled,
}

// +kubebuilder:validation:Enum={"Disabled","Enabled","PermanentlyDisabled"}
type CrossSubscriptionRestoreSettings_State string

const (
	CrossSubscriptionRestoreSettings_State_Disabled            = CrossSubscriptionRestoreSettings_State("Disabled")
	CrossSubscriptionRestoreSettings_State_Enabled             = CrossSubscriptionRestoreSettings_State("Enabled")
	CrossSubscriptionRestoreSettings_State_PermanentlyDisabled = CrossSubscriptionRestoreSettings_State("PermanentlyDisabled")
)

// Mapping from string to CrossSubscriptionRestoreSettings_State
var crossSubscriptionRestoreSettings_State_Values = map[string]CrossSubscriptionRestoreSettings_State{
	"disabled":            CrossSubscriptionRestoreSettings_State_Disabled,
	"enabled":             CrossSubscriptionRestoreSettings_State_Enabled,
	"permanentlydisabled": CrossSubscriptionRestoreSettings_State_PermanentlyDisabled,
}

type CrossSubscriptionRestoreSettings_State_STATUS string

const (
	CrossSubscriptionRestoreSettings_State_STATUS_Disabled            = CrossSubscriptionRestoreSettings_State_STATUS("Disabled")
	CrossSubscriptionRestoreSettings_State_STATUS_Enabled             = CrossSubscriptionRestoreSettings_State_STATUS("Enabled")
	CrossSubscriptionRestoreSettings_State_STATUS_PermanentlyDisabled = CrossSubscriptionRestoreSettings_State_STATUS("PermanentlyDisabled")
)

// Mapping from string to CrossSubscriptionRestoreSettings_State_STATUS
var crossSubscriptionRestoreSettings_State_STATUS_Values = map[string]CrossSubscriptionRestoreSettings_State_STATUS{
	"disabled":            CrossSubscriptionRestoreSettings_State_STATUS_Disabled,
	"enabled":             CrossSubscriptionRestoreSettings_State_STATUS_Enabled,
	"permanentlydisabled": CrossSubscriptionRestoreSettings_State_STATUS_PermanentlyDisabled,
}

// +kubebuilder:validation:Enum={"Disabled","Locked","Unlocked"}
type ImmutabilitySettings_State string

const (
	ImmutabilitySettings_State_Disabled = ImmutabilitySettings_State("Disabled")
	ImmutabilitySettings_State_Locked   = ImmutabilitySettings_State("Locked")
	ImmutabilitySettings_State_Unlocked = ImmutabilitySettings_State("Unlocked")
)

// Mapping from string to ImmutabilitySettings_State
var immutabilitySettings_State_Values = map[string]ImmutabilitySettings_State{
	"disabled": ImmutabilitySettings_State_Disabled,
	"locked":   ImmutabilitySettings_State_Locked,
	"unlocked": ImmutabilitySettings_State_Unlocked,
}

type ImmutabilitySettings_State_STATUS string

const (
	ImmutabilitySettings_State_STATUS_Disabled = ImmutabilitySettings_State_STATUS("Disabled")
	ImmutabilitySettings_State_STATUS_Locked   = ImmutabilitySettings_State_STATUS("Locked")
	ImmutabilitySettings_State_STATUS_Unlocked = ImmutabilitySettings_State_STATUS("Unlocked")
)

// Mapping from string to ImmutabilitySettings_State_STATUS
var immutabilitySettings_State_STATUS_Values = map[string]ImmutabilitySettings_State_STATUS{
	"disabled": ImmutabilitySettings_State_STATUS_Disabled,
	"locked":   ImmutabilitySettings_State_STATUS_Locked,
	"unlocked": ImmutabilitySettings_State_STATUS_Unlocked,
}

// +kubebuilder:validation:Enum={"AlwaysOn","Off","On"}
type SoftDeleteSettings_State string

const (
	SoftDeleteSettings_State_AlwaysOn = SoftDeleteSettings_State("AlwaysOn")
	SoftDeleteSettings_State_Off      = SoftDeleteSettings_State("Off")
	SoftDeleteSettings_State_On       = SoftDeleteSettings_State("On")
)

// Mapping from string to SoftDeleteSettings_State
var softDeleteSettings_State_Values = map[string]SoftDeleteSettings_State{
	"alwayson": SoftDeleteSettings_State_AlwaysOn,
	"off":      SoftDeleteSettings_State_Off,
	"on":       SoftDeleteSettings_State_On,
}

type SoftDeleteSettings_State_STATUS string

const (
	SoftDeleteSettings_State_STATUS_AlwaysOn = SoftDeleteSettings_State_STATUS("AlwaysOn")
	SoftDeleteSettings_State_STATUS_Off      = SoftDeleteSettings_State_STATUS("Off")
	SoftDeleteSettings_State_STATUS_On       = SoftDeleteSettings_State_STATUS("On")
)

// Mapping from string to SoftDeleteSettings_State_STATUS
var softDeleteSettings_State_STATUS_Values = map[string]SoftDeleteSettings_State_STATUS{
	"alwayson": SoftDeleteSettings_State_STATUS_AlwaysOn,
	"off":      SoftDeleteSettings_State_STATUS_Off,
	"on":       SoftDeleteSettings_State_STATUS_On,
}

func init() {
	SchemeBuilder.Register(&BackupVault{}, &BackupVaultList{})
}
