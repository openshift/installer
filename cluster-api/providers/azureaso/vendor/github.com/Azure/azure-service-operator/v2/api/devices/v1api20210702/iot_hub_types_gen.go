// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20210702

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/devices/v1api20210702/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/devices/v1api20210702/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/rotisserie/eris"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /iothub/resource-manager/Microsoft.Devices/stable/2021-07-02/iothub.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Devices/IotHubs/{resourceName}
type IotHub struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              IotHub_Spec   `json:"spec,omitempty"`
	Status            IotHub_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &IotHub{}

// GetConditions returns the conditions of the resource
func (iotHub *IotHub) GetConditions() conditions.Conditions {
	return iotHub.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (iotHub *IotHub) SetConditions(conditions conditions.Conditions) {
	iotHub.Status.Conditions = conditions
}

var _ conversion.Convertible = &IotHub{}

// ConvertFrom populates our IotHub from the provided hub IotHub
func (iotHub *IotHub) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.IotHub)
	if !ok {
		return fmt.Errorf("expected devices/v1api20210702/storage/IotHub but received %T instead", hub)
	}

	return iotHub.AssignProperties_From_IotHub(source)
}

// ConvertTo populates the provided hub IotHub from our IotHub
func (iotHub *IotHub) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.IotHub)
	if !ok {
		return fmt.Errorf("expected devices/v1api20210702/storage/IotHub but received %T instead", hub)
	}

	return iotHub.AssignProperties_To_IotHub(destination)
}

var _ configmaps.Exporter = &IotHub{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (iotHub *IotHub) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if iotHub.Spec.OperatorSpec == nil {
		return nil
	}
	return iotHub.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &IotHub{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (iotHub *IotHub) SecretDestinationExpressions() []*core.DestinationExpression {
	if iotHub.Spec.OperatorSpec == nil {
		return nil
	}
	return iotHub.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &IotHub{}

// InitializeSpec initializes the spec for this resource from the given status
func (iotHub *IotHub) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*IotHub_STATUS); ok {
		return iotHub.Spec.Initialize_From_IotHub_STATUS(s)
	}

	return fmt.Errorf("expected Status of type IotHub_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &IotHub{}

// AzureName returns the Azure name of the resource
func (iotHub *IotHub) AzureName() string {
	return iotHub.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2021-07-02"
func (iotHub IotHub) GetAPIVersion() string {
	return "2021-07-02"
}

// GetResourceScope returns the scope of the resource
func (iotHub *IotHub) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (iotHub *IotHub) GetSpec() genruntime.ConvertibleSpec {
	return &iotHub.Spec
}

// GetStatus returns the status of this resource
func (iotHub *IotHub) GetStatus() genruntime.ConvertibleStatus {
	return &iotHub.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (iotHub *IotHub) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Devices/IotHubs"
func (iotHub *IotHub) GetType() string {
	return "Microsoft.Devices/IotHubs"
}

// NewEmptyStatus returns a new empty (blank) status
func (iotHub *IotHub) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &IotHub_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (iotHub *IotHub) Owner() *genruntime.ResourceReference {
	if iotHub.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(iotHub.Spec)
	return iotHub.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (iotHub *IotHub) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*IotHub_STATUS); ok {
		iotHub.Status = *st
		return nil
	}

	// Convert status to required version
	var st IotHub_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	iotHub.Status = st
	return nil
}

// AssignProperties_From_IotHub populates our IotHub from the provided source IotHub
func (iotHub *IotHub) AssignProperties_From_IotHub(source *storage.IotHub) error {

	// ObjectMeta
	iotHub.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec IotHub_Spec
	err := spec.AssignProperties_From_IotHub_Spec(&source.Spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_IotHub_Spec() to populate field Spec")
	}
	iotHub.Spec = spec

	// Status
	var status IotHub_STATUS
	err = status.AssignProperties_From_IotHub_STATUS(&source.Status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_IotHub_STATUS() to populate field Status")
	}
	iotHub.Status = status

	// No error
	return nil
}

// AssignProperties_To_IotHub populates the provided destination IotHub from our IotHub
func (iotHub *IotHub) AssignProperties_To_IotHub(destination *storage.IotHub) error {

	// ObjectMeta
	destination.ObjectMeta = *iotHub.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.IotHub_Spec
	err := iotHub.Spec.AssignProperties_To_IotHub_Spec(&spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_IotHub_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.IotHub_STATUS
	err = iotHub.Status.AssignProperties_To_IotHub_STATUS(&status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_IotHub_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (iotHub *IotHub) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: iotHub.Spec.OriginalVersion(),
		Kind:    "IotHub",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /iothub/resource-manager/Microsoft.Devices/stable/2021-07-02/iothub.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Devices/IotHubs/{resourceName}
type IotHubList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []IotHub `json:"items"`
}

// +kubebuilder:validation:Enum={"2021-07-02"}
type APIVersion string

const APIVersion_Value = APIVersion("2021-07-02")

type IotHub_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// Identity: The managed identities for the IotHub.
	Identity *ArmIdentity `json:"identity,omitempty"`

	// +kubebuilder:validation:Required
	// Location: The resource location.
	Location *string `json:"location,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *IotHubOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// Properties: IotHub properties
	Properties *IotHubProperties `json:"properties,omitempty"`

	// +kubebuilder:validation:Required
	// Sku: IotHub SKU info
	Sku *IotHubSkuInfo `json:"sku,omitempty"`

	// Tags: The resource tags.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &IotHub_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (iotHub *IotHub_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if iotHub == nil {
		return nil, nil
	}
	result := &arm.IotHub_Spec{}

	// Set property "Identity":
	if iotHub.Identity != nil {
		identity_ARM, err := (*iotHub.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*arm.ArmIdentity)
		result.Identity = &identity
	}

	// Set property "Location":
	if iotHub.Location != nil {
		location := *iotHub.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if iotHub.Properties != nil {
		properties_ARM, err := (*iotHub.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*arm.IotHubProperties)
		result.Properties = &properties
	}

	// Set property "Sku":
	if iotHub.Sku != nil {
		sku_ARM, err := (*iotHub.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := *sku_ARM.(*arm.IotHubSkuInfo)
		result.Sku = &sku
	}

	// Set property "Tags":
	if iotHub.Tags != nil {
		result.Tags = make(map[string]string, len(iotHub.Tags))
		for key, value := range iotHub.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (iotHub *IotHub_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IotHub_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (iotHub *IotHub_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IotHub_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IotHub_Spec, got %T", armInput)
	}

	// Set property "AzureName":
	iotHub.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ArmIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		iotHub.Identity = &identity
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		iotHub.Location = &location
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	iotHub.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 IotHubProperties
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		iotHub.Properties = &properties
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 IotHubSkuInfo
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		iotHub.Sku = &sku
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		iotHub.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			iotHub.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &IotHub_Spec{}

// ConvertSpecFrom populates our IotHub_Spec from the provided source
func (iotHub *IotHub_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.IotHub_Spec)
	if ok {
		// Populate our instance from source
		return iotHub.AssignProperties_From_IotHub_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.IotHub_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = iotHub.AssignProperties_From_IotHub_Spec(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our IotHub_Spec
func (iotHub *IotHub_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.IotHub_Spec)
	if ok {
		// Populate destination from our instance
		return iotHub.AssignProperties_To_IotHub_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.IotHub_Spec{}
	err := iotHub.AssignProperties_To_IotHub_Spec(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_IotHub_Spec populates our IotHub_Spec from the provided source IotHub_Spec
func (iotHub *IotHub_Spec) AssignProperties_From_IotHub_Spec(source *storage.IotHub_Spec) error {

	// AzureName
	iotHub.AzureName = source.AzureName

	// Identity
	if source.Identity != nil {
		var identity ArmIdentity
		err := identity.AssignProperties_From_ArmIdentity(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ArmIdentity() to populate field Identity")
		}
		iotHub.Identity = &identity
	} else {
		iotHub.Identity = nil
	}

	// Location
	iotHub.Location = genruntime.ClonePointerToString(source.Location)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec IotHubOperatorSpec
		err := operatorSpec.AssignProperties_From_IotHubOperatorSpec(source.OperatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_IotHubOperatorSpec() to populate field OperatorSpec")
		}
		iotHub.OperatorSpec = &operatorSpec
	} else {
		iotHub.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		iotHub.Owner = &owner
	} else {
		iotHub.Owner = nil
	}

	// Properties
	if source.Properties != nil {
		var property IotHubProperties
		err := property.AssignProperties_From_IotHubProperties(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_IotHubProperties() to populate field Properties")
		}
		iotHub.Properties = &property
	} else {
		iotHub.Properties = nil
	}

	// Sku
	if source.Sku != nil {
		var sku IotHubSkuInfo
		err := sku.AssignProperties_From_IotHubSkuInfo(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_IotHubSkuInfo() to populate field Sku")
		}
		iotHub.Sku = &sku
	} else {
		iotHub.Sku = nil
	}

	// Tags
	iotHub.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// AssignProperties_To_IotHub_Spec populates the provided destination IotHub_Spec from our IotHub_Spec
func (iotHub *IotHub_Spec) AssignProperties_To_IotHub_Spec(destination *storage.IotHub_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = iotHub.AzureName

	// Identity
	if iotHub.Identity != nil {
		var identity storage.ArmIdentity
		err := iotHub.Identity.AssignProperties_To_ArmIdentity(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ArmIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(iotHub.Location)

	// OperatorSpec
	if iotHub.OperatorSpec != nil {
		var operatorSpec storage.IotHubOperatorSpec
		err := iotHub.OperatorSpec.AssignProperties_To_IotHubOperatorSpec(&operatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_IotHubOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = iotHub.OriginalVersion()

	// Owner
	if iotHub.Owner != nil {
		owner := iotHub.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Properties
	if iotHub.Properties != nil {
		var property storage.IotHubProperties
		err := iotHub.Properties.AssignProperties_To_IotHubProperties(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_IotHubProperties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// Sku
	if iotHub.Sku != nil {
		var sku storage.IotHubSkuInfo
		err := iotHub.Sku.AssignProperties_To_IotHubSkuInfo(&sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_IotHubSkuInfo() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(iotHub.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_IotHub_STATUS populates our IotHub_Spec from the provided source IotHub_STATUS
func (iotHub *IotHub_Spec) Initialize_From_IotHub_STATUS(source *IotHub_STATUS) error {

	// Identity
	if source.Identity != nil {
		var identity ArmIdentity
		err := identity.Initialize_From_ArmIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ArmIdentity_STATUS() to populate field Identity")
		}
		iotHub.Identity = &identity
	} else {
		iotHub.Identity = nil
	}

	// Location
	iotHub.Location = genruntime.ClonePointerToString(source.Location)

	// Properties
	if source.Properties != nil {
		var property IotHubProperties
		err := property.Initialize_From_IotHubProperties_STATUS(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_IotHubProperties_STATUS() to populate field Properties")
		}
		iotHub.Properties = &property
	} else {
		iotHub.Properties = nil
	}

	// Sku
	if source.Sku != nil {
		var sku IotHubSkuInfo
		err := sku.Initialize_From_IotHubSkuInfo_STATUS(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_IotHubSkuInfo_STATUS() to populate field Sku")
		}
		iotHub.Sku = &sku
	} else {
		iotHub.Sku = nil
	}

	// Tags
	iotHub.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (iotHub *IotHub_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (iotHub *IotHub_Spec) SetAzureName(azureName string) { iotHub.AzureName = azureName }

type IotHub_STATUS struct {
	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// Etag: The Etag field is *not* required. If it is provided in the response body, it must also be provided as a header per
	// the normal ETag convention.
	Etag *string `json:"etag,omitempty"`

	// Id: The resource identifier.
	Id *string `json:"id,omitempty"`

	// Identity: The managed identities for the IotHub.
	Identity *ArmIdentity_STATUS `json:"identity,omitempty"`

	// Location: The resource location.
	Location *string `json:"location,omitempty"`

	// Name: The resource name.
	Name *string `json:"name,omitempty"`

	// Properties: IotHub properties
	Properties *IotHubProperties_STATUS `json:"properties,omitempty"`

	// Sku: IotHub SKU info
	Sku *IotHubSkuInfo_STATUS `json:"sku,omitempty"`

	// SystemData: The system meta data relating to this resource.
	SystemData *SystemData_STATUS `json:"systemData,omitempty"`

	// Tags: The resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: The resource type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &IotHub_STATUS{}

// ConvertStatusFrom populates our IotHub_STATUS from the provided source
func (iotHub *IotHub_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.IotHub_STATUS)
	if ok {
		// Populate our instance from source
		return iotHub.AssignProperties_From_IotHub_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.IotHub_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = iotHub.AssignProperties_From_IotHub_STATUS(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our IotHub_STATUS
func (iotHub *IotHub_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.IotHub_STATUS)
	if ok {
		// Populate destination from our instance
		return iotHub.AssignProperties_To_IotHub_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.IotHub_STATUS{}
	err := iotHub.AssignProperties_To_IotHub_STATUS(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &IotHub_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (iotHub *IotHub_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IotHub_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (iotHub *IotHub_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IotHub_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IotHub_STATUS, got %T", armInput)
	}

	// no assignment for property "Conditions"

	// Set property "Etag":
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		iotHub.Etag = &etag
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		iotHub.Id = &id
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ArmIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		iotHub.Identity = &identity
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		iotHub.Location = &location
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		iotHub.Name = &name
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 IotHubProperties_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		iotHub.Properties = &properties
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 IotHubSkuInfo_STATUS
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		iotHub.Sku = &sku
	}

	// Set property "SystemData":
	if typedInput.SystemData != nil {
		var systemData1 SystemData_STATUS
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		iotHub.SystemData = &systemData
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		iotHub.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			iotHub.Tags[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		iotHub.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_IotHub_STATUS populates our IotHub_STATUS from the provided source IotHub_STATUS
func (iotHub *IotHub_STATUS) AssignProperties_From_IotHub_STATUS(source *storage.IotHub_STATUS) error {

	// Conditions
	iotHub.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// Etag
	iotHub.Etag = genruntime.ClonePointerToString(source.Etag)

	// Id
	iotHub.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity ArmIdentity_STATUS
		err := identity.AssignProperties_From_ArmIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ArmIdentity_STATUS() to populate field Identity")
		}
		iotHub.Identity = &identity
	} else {
		iotHub.Identity = nil
	}

	// Location
	iotHub.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	iotHub.Name = genruntime.ClonePointerToString(source.Name)

	// Properties
	if source.Properties != nil {
		var property IotHubProperties_STATUS
		err := property.AssignProperties_From_IotHubProperties_STATUS(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_IotHubProperties_STATUS() to populate field Properties")
		}
		iotHub.Properties = &property
	} else {
		iotHub.Properties = nil
	}

	// Sku
	if source.Sku != nil {
		var sku IotHubSkuInfo_STATUS
		err := sku.AssignProperties_From_IotHubSkuInfo_STATUS(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_IotHubSkuInfo_STATUS() to populate field Sku")
		}
		iotHub.Sku = &sku
	} else {
		iotHub.Sku = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		iotHub.SystemData = &systemDatum
	} else {
		iotHub.SystemData = nil
	}

	// Tags
	iotHub.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	iotHub.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_IotHub_STATUS populates the provided destination IotHub_STATUS from our IotHub_STATUS
func (iotHub *IotHub_STATUS) AssignProperties_To_IotHub_STATUS(destination *storage.IotHub_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(iotHub.Conditions)

	// Etag
	destination.Etag = genruntime.ClonePointerToString(iotHub.Etag)

	// Id
	destination.Id = genruntime.ClonePointerToString(iotHub.Id)

	// Identity
	if iotHub.Identity != nil {
		var identity storage.ArmIdentity_STATUS
		err := iotHub.Identity.AssignProperties_To_ArmIdentity_STATUS(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ArmIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(iotHub.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(iotHub.Name)

	// Properties
	if iotHub.Properties != nil {
		var property storage.IotHubProperties_STATUS
		err := iotHub.Properties.AssignProperties_To_IotHubProperties_STATUS(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_IotHubProperties_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// Sku
	if iotHub.Sku != nil {
		var sku storage.IotHubSkuInfo_STATUS
		err := iotHub.Sku.AssignProperties_To_IotHubSkuInfo_STATUS(&sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_IotHubSkuInfo_STATUS() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// SystemData
	if iotHub.SystemData != nil {
		var systemDatum storage.SystemData_STATUS
		err := iotHub.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(iotHub.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(iotHub.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ArmIdentity struct {
	// Type: The type of identity used for the resource. The type 'SystemAssigned, UserAssigned' includes both an implicitly
	// created identity and a set of user assigned identities. The type 'None' will remove any identities from the service.
	Type                   *ArmIdentity_Type             `json:"type,omitempty"`
	UserAssignedIdentities []UserAssignedIdentityDetails `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.ARMTransformer = &ArmIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *ArmIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &arm.ArmIdentity{}

	// Set property "Type":
	if identity.Type != nil {
		var temp string
		temp = string(*identity.Type)
		typeVar := arm.ArmIdentity_Type(temp)
		result.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	result.UserAssignedIdentities = make(map[string]arm.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
	for _, ident := range identity.UserAssignedIdentities {
		identARMID, err := resolved.ResolvedReferences.Lookup(ident.Reference)
		if err != nil {
			return nil, err
		}
		key := identARMID
		result.UserAssignedIdentities[key] = arm.UserAssignedIdentityDetails{}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ArmIdentity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ArmIdentity{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ArmIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ArmIdentity)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ArmIdentity, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ArmIdentity_Type(temp)
		identity.Type = &typeVar
	}

	// no assignment for property "UserAssignedIdentities"

	// No error
	return nil
}

// AssignProperties_From_ArmIdentity populates our ArmIdentity from the provided source ArmIdentity
func (identity *ArmIdentity) AssignProperties_From_ArmIdentity(source *storage.ArmIdentity) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, armIdentity_Type_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, len(source.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity UserAssignedIdentityDetails
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentityDetails(&userAssignedIdentityItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ArmIdentity populates the provided destination ArmIdentity from our ArmIdentity
func (identity *ArmIdentity) AssignProperties_To_ArmIdentity(destination *storage.ArmIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]storage.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity storage.UserAssignedIdentityDetails
			err := userAssignedIdentityItem.AssignProperties_To_UserAssignedIdentityDetails(&userAssignedIdentity)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityList
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ArmIdentity_STATUS populates our ArmIdentity from the provided source ArmIdentity_STATUS
func (identity *ArmIdentity) Initialize_From_ArmIdentity_STATUS(source *ArmIdentity_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := genruntime.ToEnum(string(*source.Type), armIdentity_Type_Values)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, 0, len(source.UserAssignedIdentities))
		for userAssignedIdentitiesKey := range source.UserAssignedIdentities {
			userAssignedIdentitiesRef := genruntime.CreateResourceReferenceFromARMID(userAssignedIdentitiesKey)
			userAssignedIdentityList = append(userAssignedIdentityList, UserAssignedIdentityDetails{Reference: userAssignedIdentitiesRef})
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

type ArmIdentity_STATUS struct {
	// PrincipalId: Principal Id
	PrincipalId *string `json:"principalId,omitempty"`

	// TenantId: Tenant Id
	TenantId *string `json:"tenantId,omitempty"`

	// Type: The type of identity used for the resource. The type 'SystemAssigned, UserAssigned' includes both an implicitly
	// created identity and a set of user assigned identities. The type 'None' will remove any identities from the service.
	Type                   *ArmIdentity_Type_STATUS          `json:"type,omitempty"`
	UserAssignedIdentities map[string]ArmUserIdentity_STATUS `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.FromARMConverter = &ArmIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ArmIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ArmIdentity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ArmIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ArmIdentity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ArmIdentity_STATUS, got %T", armInput)
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		identity.TenantId = &tenantId
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ArmIdentity_Type_STATUS(temp)
		identity.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	if typedInput.UserAssignedIdentities != nil {
		identity.UserAssignedIdentities = make(map[string]ArmUserIdentity_STATUS, len(typedInput.UserAssignedIdentities))
		for key, value := range typedInput.UserAssignedIdentities {
			var value1 ArmUserIdentity_STATUS
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			identity.UserAssignedIdentities[key] = value1
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ArmIdentity_STATUS populates our ArmIdentity_STATUS from the provided source ArmIdentity_STATUS
func (identity *ArmIdentity_STATUS) AssignProperties_From_ArmIdentity_STATUS(source *storage.ArmIdentity_STATUS) error {

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, armIdentity_Type_STATUS_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]ArmUserIdentity_STATUS, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity ArmUserIdentity_STATUS
			err := userAssignedIdentity.AssignProperties_From_ArmUserIdentity_STATUS(&userAssignedIdentityValue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ArmUserIdentity_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ArmIdentity_STATUS populates the provided destination ArmIdentity_STATUS from our ArmIdentity_STATUS
func (identity *ArmIdentity_STATUS) AssignProperties_To_ArmIdentity_STATUS(destination *storage.ArmIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]storage.ArmUserIdentity_STATUS, len(identity.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity storage.ArmUserIdentity_STATUS
			err := userAssignedIdentityValue.AssignProperties_To_ArmUserIdentity_STATUS(&userAssignedIdentity)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ArmUserIdentity_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type IotHubOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`

	// Secrets: configures where to place Azure generated secrets.
	Secrets *IotHubOperatorSecrets `json:"secrets,omitempty"`
}

// AssignProperties_From_IotHubOperatorSpec populates our IotHubOperatorSpec from the provided source IotHubOperatorSpec
func (operator *IotHubOperatorSpec) AssignProperties_From_IotHubOperatorSpec(source *storage.IotHubOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// Secrets
	if source.Secrets != nil {
		var secret IotHubOperatorSecrets
		err := secret.AssignProperties_From_IotHubOperatorSecrets(source.Secrets)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_IotHubOperatorSecrets() to populate field Secrets")
		}
		operator.Secrets = &secret
	} else {
		operator.Secrets = nil
	}

	// No error
	return nil
}

// AssignProperties_To_IotHubOperatorSpec populates the provided destination IotHubOperatorSpec from our IotHubOperatorSpec
func (operator *IotHubOperatorSpec) AssignProperties_To_IotHubOperatorSpec(destination *storage.IotHubOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Secrets
	if operator.Secrets != nil {
		var secret storage.IotHubOperatorSecrets
		err := operator.Secrets.AssignProperties_To_IotHubOperatorSecrets(&secret)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_IotHubOperatorSecrets() to populate field Secrets")
		}
		destination.Secrets = &secret
	} else {
		destination.Secrets = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The properties of an IoT hub.
type IotHubProperties struct {
	// AllowedFqdnList: List of allowed FQDNs(Fully Qualified Domain Name) for egress from Iot Hub.
	AllowedFqdnList []string `json:"allowedFqdnList,omitempty"`

	// AuthorizationPolicies: The shared access policies you can use to secure a connection to the IoT hub.
	AuthorizationPolicies []SharedAccessSignatureAuthorizationRule `json:"authorizationPolicies,omitempty"`

	// CloudToDevice: The IoT hub cloud-to-device messaging properties.
	CloudToDevice *CloudToDeviceProperties `json:"cloudToDevice,omitempty"`

	// Comments: IoT hub comments.
	Comments *string `json:"comments,omitempty"`

	// DisableDeviceSAS: If true, all device(including Edge devices but excluding modules) scoped SAS keys cannot be used for
	// authentication.
	DisableDeviceSAS *bool `json:"disableDeviceSAS,omitempty"`

	// DisableLocalAuth: If true, SAS tokens with Iot hub scoped SAS keys cannot be used for authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// DisableModuleSAS: If true, all module scoped SAS keys cannot be used for authentication.
	DisableModuleSAS *bool `json:"disableModuleSAS,omitempty"`

	// EnableDataResidency: This property when set to true, will enable data residency, thus, disabling disaster recovery.
	EnableDataResidency *bool `json:"enableDataResidency,omitempty"`

	// EnableFileUploadNotifications: If True, file upload notifications are enabled.
	EnableFileUploadNotifications *bool `json:"enableFileUploadNotifications,omitempty"`

	// EventHubEndpoints: The Event Hub-compatible endpoint properties. The only possible keys to this dictionary is events.
	// This key has to be present in the dictionary while making create or update calls for the IoT hub.
	EventHubEndpoints map[string]EventHubProperties `json:"eventHubEndpoints,omitempty"`

	// Features: The capabilities and features enabled for the IoT hub.
	Features *IotHubProperties_Features `json:"features,omitempty"`

	// IpFilterRules: The IP filter rules.
	IpFilterRules []IpFilterRule `json:"ipFilterRules,omitempty"`

	// MessagingEndpoints: The messaging endpoint properties for the file upload notification queue.
	MessagingEndpoints map[string]MessagingEndpointProperties `json:"messagingEndpoints,omitempty"`

	// MinTlsVersion: Specifies the minimum TLS version to support for this hub. Can be set to "1.2" to have clients that use a
	// TLS version below 1.2 to be rejected.
	MinTlsVersion *string `json:"minTlsVersion,omitempty"`

	// NetworkRuleSets: Network Rule Set Properties of IotHub
	NetworkRuleSets *NetworkRuleSetProperties `json:"networkRuleSets,omitempty"`

	// PublicNetworkAccess: Whether requests from Public Network are allowed
	PublicNetworkAccess *IotHubProperties_PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// RestrictOutboundNetworkAccess: If true, egress from IotHub will be restricted to only the allowed FQDNs that are
	// configured via allowedFqdnList.
	RestrictOutboundNetworkAccess *bool `json:"restrictOutboundNetworkAccess,omitempty"`

	// Routing: The routing related properties of the IoT hub. See:
	// https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-messaging
	Routing *RoutingProperties `json:"routing,omitempty"`

	// StorageEndpoints: The list of Azure Storage endpoints where you can upload files. Currently you can configure only one
	// Azure Storage account and that MUST have its key as $default. Specifying more than one storage account causes an error
	// to be thrown. Not specifying a value for this property when the enableFileUploadNotifications property is set to True,
	// causes an error to be thrown.
	StorageEndpoints map[string]StorageEndpointProperties `json:"storageEndpoints,omitempty"`
}

var _ genruntime.ARMTransformer = &IotHubProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *IotHubProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.IotHubProperties{}

	// Set property "AllowedFqdnList":
	for _, item := range properties.AllowedFqdnList {
		result.AllowedFqdnList = append(result.AllowedFqdnList, item)
	}

	// Set property "AuthorizationPolicies":
	for _, item := range properties.AuthorizationPolicies {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.AuthorizationPolicies = append(result.AuthorizationPolicies, *item_ARM.(*arm.SharedAccessSignatureAuthorizationRule))
	}

	// Set property "CloudToDevice":
	if properties.CloudToDevice != nil {
		cloudToDevice_ARM, err := (*properties.CloudToDevice).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		cloudToDevice := *cloudToDevice_ARM.(*arm.CloudToDeviceProperties)
		result.CloudToDevice = &cloudToDevice
	}

	// Set property "Comments":
	if properties.Comments != nil {
		comments := *properties.Comments
		result.Comments = &comments
	}

	// Set property "DisableDeviceSAS":
	if properties.DisableDeviceSAS != nil {
		disableDeviceSAS := *properties.DisableDeviceSAS
		result.DisableDeviceSAS = &disableDeviceSAS
	}

	// Set property "DisableLocalAuth":
	if properties.DisableLocalAuth != nil {
		disableLocalAuth := *properties.DisableLocalAuth
		result.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "DisableModuleSAS":
	if properties.DisableModuleSAS != nil {
		disableModuleSAS := *properties.DisableModuleSAS
		result.DisableModuleSAS = &disableModuleSAS
	}

	// Set property "EnableDataResidency":
	if properties.EnableDataResidency != nil {
		enableDataResidency := *properties.EnableDataResidency
		result.EnableDataResidency = &enableDataResidency
	}

	// Set property "EnableFileUploadNotifications":
	if properties.EnableFileUploadNotifications != nil {
		enableFileUploadNotifications := *properties.EnableFileUploadNotifications
		result.EnableFileUploadNotifications = &enableFileUploadNotifications
	}

	// Set property "EventHubEndpoints":
	if properties.EventHubEndpoints != nil {
		result.EventHubEndpoints = make(map[string]arm.EventHubProperties, len(properties.EventHubEndpoints))
		for key, value := range properties.EventHubEndpoints {
			value_ARM, err := value.ConvertToARM(resolved)
			if err != nil {
				return nil, err
			}
			result.EventHubEndpoints[key] = *value_ARM.(*arm.EventHubProperties)
		}
	}

	// Set property "Features":
	if properties.Features != nil {
		var temp string
		temp = string(*properties.Features)
		features := arm.IotHubProperties_Features(temp)
		result.Features = &features
	}

	// Set property "IpFilterRules":
	for _, item := range properties.IpFilterRules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.IpFilterRules = append(result.IpFilterRules, *item_ARM.(*arm.IpFilterRule))
	}

	// Set property "MessagingEndpoints":
	if properties.MessagingEndpoints != nil {
		result.MessagingEndpoints = make(map[string]arm.MessagingEndpointProperties, len(properties.MessagingEndpoints))
		for key, value := range properties.MessagingEndpoints {
			value_ARM, err := value.ConvertToARM(resolved)
			if err != nil {
				return nil, err
			}
			result.MessagingEndpoints[key] = *value_ARM.(*arm.MessagingEndpointProperties)
		}
	}

	// Set property "MinTlsVersion":
	if properties.MinTlsVersion != nil {
		minTlsVersion := *properties.MinTlsVersion
		result.MinTlsVersion = &minTlsVersion
	}

	// Set property "NetworkRuleSets":
	if properties.NetworkRuleSets != nil {
		networkRuleSets_ARM, err := (*properties.NetworkRuleSets).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		networkRuleSets := *networkRuleSets_ARM.(*arm.NetworkRuleSetProperties)
		result.NetworkRuleSets = &networkRuleSets
	}

	// Set property "PublicNetworkAccess":
	if properties.PublicNetworkAccess != nil {
		var temp string
		temp = string(*properties.PublicNetworkAccess)
		publicNetworkAccess := arm.IotHubProperties_PublicNetworkAccess(temp)
		result.PublicNetworkAccess = &publicNetworkAccess
	}

	// Set property "RestrictOutboundNetworkAccess":
	if properties.RestrictOutboundNetworkAccess != nil {
		restrictOutboundNetworkAccess := *properties.RestrictOutboundNetworkAccess
		result.RestrictOutboundNetworkAccess = &restrictOutboundNetworkAccess
	}

	// Set property "Routing":
	if properties.Routing != nil {
		routing_ARM, err := (*properties.Routing).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		routing := *routing_ARM.(*arm.RoutingProperties)
		result.Routing = &routing
	}

	// Set property "StorageEndpoints":
	if properties.StorageEndpoints != nil {
		result.StorageEndpoints = make(map[string]arm.StorageEndpointProperties, len(properties.StorageEndpoints))
		for key, value := range properties.StorageEndpoints {
			value_ARM, err := value.ConvertToARM(resolved)
			if err != nil {
				return nil, err
			}
			result.StorageEndpoints[key] = *value_ARM.(*arm.StorageEndpointProperties)
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *IotHubProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IotHubProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *IotHubProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IotHubProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IotHubProperties, got %T", armInput)
	}

	// Set property "AllowedFqdnList":
	for _, item := range typedInput.AllowedFqdnList {
		properties.AllowedFqdnList = append(properties.AllowedFqdnList, item)
	}

	// Set property "AuthorizationPolicies":
	for _, item := range typedInput.AuthorizationPolicies {
		var item1 SharedAccessSignatureAuthorizationRule
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.AuthorizationPolicies = append(properties.AuthorizationPolicies, item1)
	}

	// Set property "CloudToDevice":
	if typedInput.CloudToDevice != nil {
		var cloudToDevice1 CloudToDeviceProperties
		err := cloudToDevice1.PopulateFromARM(owner, *typedInput.CloudToDevice)
		if err != nil {
			return err
		}
		cloudToDevice := cloudToDevice1
		properties.CloudToDevice = &cloudToDevice
	}

	// Set property "Comments":
	if typedInput.Comments != nil {
		comments := *typedInput.Comments
		properties.Comments = &comments
	}

	// Set property "DisableDeviceSAS":
	if typedInput.DisableDeviceSAS != nil {
		disableDeviceSAS := *typedInput.DisableDeviceSAS
		properties.DisableDeviceSAS = &disableDeviceSAS
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		properties.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "DisableModuleSAS":
	if typedInput.DisableModuleSAS != nil {
		disableModuleSAS := *typedInput.DisableModuleSAS
		properties.DisableModuleSAS = &disableModuleSAS
	}

	// Set property "EnableDataResidency":
	if typedInput.EnableDataResidency != nil {
		enableDataResidency := *typedInput.EnableDataResidency
		properties.EnableDataResidency = &enableDataResidency
	}

	// Set property "EnableFileUploadNotifications":
	if typedInput.EnableFileUploadNotifications != nil {
		enableFileUploadNotifications := *typedInput.EnableFileUploadNotifications
		properties.EnableFileUploadNotifications = &enableFileUploadNotifications
	}

	// Set property "EventHubEndpoints":
	if typedInput.EventHubEndpoints != nil {
		properties.EventHubEndpoints = make(map[string]EventHubProperties, len(typedInput.EventHubEndpoints))
		for key, value := range typedInput.EventHubEndpoints {
			var value1 EventHubProperties
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			properties.EventHubEndpoints[key] = value1
		}
	}

	// Set property "Features":
	if typedInput.Features != nil {
		var temp string
		temp = string(*typedInput.Features)
		features := IotHubProperties_Features(temp)
		properties.Features = &features
	}

	// Set property "IpFilterRules":
	for _, item := range typedInput.IpFilterRules {
		var item1 IpFilterRule
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.IpFilterRules = append(properties.IpFilterRules, item1)
	}

	// Set property "MessagingEndpoints":
	if typedInput.MessagingEndpoints != nil {
		properties.MessagingEndpoints = make(map[string]MessagingEndpointProperties, len(typedInput.MessagingEndpoints))
		for key, value := range typedInput.MessagingEndpoints {
			var value1 MessagingEndpointProperties
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			properties.MessagingEndpoints[key] = value1
		}
	}

	// Set property "MinTlsVersion":
	if typedInput.MinTlsVersion != nil {
		minTlsVersion := *typedInput.MinTlsVersion
		properties.MinTlsVersion = &minTlsVersion
	}

	// Set property "NetworkRuleSets":
	if typedInput.NetworkRuleSets != nil {
		var networkRuleSets1 NetworkRuleSetProperties
		err := networkRuleSets1.PopulateFromARM(owner, *typedInput.NetworkRuleSets)
		if err != nil {
			return err
		}
		networkRuleSets := networkRuleSets1
		properties.NetworkRuleSets = &networkRuleSets
	}

	// Set property "PublicNetworkAccess":
	if typedInput.PublicNetworkAccess != nil {
		var temp string
		temp = string(*typedInput.PublicNetworkAccess)
		publicNetworkAccess := IotHubProperties_PublicNetworkAccess(temp)
		properties.PublicNetworkAccess = &publicNetworkAccess
	}

	// Set property "RestrictOutboundNetworkAccess":
	if typedInput.RestrictOutboundNetworkAccess != nil {
		restrictOutboundNetworkAccess := *typedInput.RestrictOutboundNetworkAccess
		properties.RestrictOutboundNetworkAccess = &restrictOutboundNetworkAccess
	}

	// Set property "Routing":
	if typedInput.Routing != nil {
		var routing1 RoutingProperties
		err := routing1.PopulateFromARM(owner, *typedInput.Routing)
		if err != nil {
			return err
		}
		routing := routing1
		properties.Routing = &routing
	}

	// Set property "StorageEndpoints":
	if typedInput.StorageEndpoints != nil {
		properties.StorageEndpoints = make(map[string]StorageEndpointProperties, len(typedInput.StorageEndpoints))
		for key, value := range typedInput.StorageEndpoints {
			var value1 StorageEndpointProperties
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			properties.StorageEndpoints[key] = value1
		}
	}

	// No error
	return nil
}

// AssignProperties_From_IotHubProperties populates our IotHubProperties from the provided source IotHubProperties
func (properties *IotHubProperties) AssignProperties_From_IotHubProperties(source *storage.IotHubProperties) error {

	// AllowedFqdnList
	properties.AllowedFqdnList = genruntime.CloneSliceOfString(source.AllowedFqdnList)

	// AuthorizationPolicies
	if source.AuthorizationPolicies != nil {
		authorizationPolicyList := make([]SharedAccessSignatureAuthorizationRule, len(source.AuthorizationPolicies))
		for authorizationPolicyIndex, authorizationPolicyItem := range source.AuthorizationPolicies {
			// Shadow the loop variable to avoid aliasing
			authorizationPolicyItem := authorizationPolicyItem
			var authorizationPolicy SharedAccessSignatureAuthorizationRule
			err := authorizationPolicy.AssignProperties_From_SharedAccessSignatureAuthorizationRule(&authorizationPolicyItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_SharedAccessSignatureAuthorizationRule() to populate field AuthorizationPolicies")
			}
			authorizationPolicyList[authorizationPolicyIndex] = authorizationPolicy
		}
		properties.AuthorizationPolicies = authorizationPolicyList
	} else {
		properties.AuthorizationPolicies = nil
	}

	// CloudToDevice
	if source.CloudToDevice != nil {
		var cloudToDevice CloudToDeviceProperties
		err := cloudToDevice.AssignProperties_From_CloudToDeviceProperties(source.CloudToDevice)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CloudToDeviceProperties() to populate field CloudToDevice")
		}
		properties.CloudToDevice = &cloudToDevice
	} else {
		properties.CloudToDevice = nil
	}

	// Comments
	properties.Comments = genruntime.ClonePointerToString(source.Comments)

	// DisableDeviceSAS
	if source.DisableDeviceSAS != nil {
		disableDeviceSAS := *source.DisableDeviceSAS
		properties.DisableDeviceSAS = &disableDeviceSAS
	} else {
		properties.DisableDeviceSAS = nil
	}

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		properties.DisableLocalAuth = &disableLocalAuth
	} else {
		properties.DisableLocalAuth = nil
	}

	// DisableModuleSAS
	if source.DisableModuleSAS != nil {
		disableModuleSAS := *source.DisableModuleSAS
		properties.DisableModuleSAS = &disableModuleSAS
	} else {
		properties.DisableModuleSAS = nil
	}

	// EnableDataResidency
	if source.EnableDataResidency != nil {
		enableDataResidency := *source.EnableDataResidency
		properties.EnableDataResidency = &enableDataResidency
	} else {
		properties.EnableDataResidency = nil
	}

	// EnableFileUploadNotifications
	if source.EnableFileUploadNotifications != nil {
		enableFileUploadNotification := *source.EnableFileUploadNotifications
		properties.EnableFileUploadNotifications = &enableFileUploadNotification
	} else {
		properties.EnableFileUploadNotifications = nil
	}

	// EventHubEndpoints
	if source.EventHubEndpoints != nil {
		eventHubEndpointMap := make(map[string]EventHubProperties, len(source.EventHubEndpoints))
		for eventHubEndpointKey, eventHubEndpointValue := range source.EventHubEndpoints {
			// Shadow the loop variable to avoid aliasing
			eventHubEndpointValue := eventHubEndpointValue
			var eventHubEndpoint EventHubProperties
			err := eventHubEndpoint.AssignProperties_From_EventHubProperties(&eventHubEndpointValue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_EventHubProperties() to populate field EventHubEndpoints")
			}
			eventHubEndpointMap[eventHubEndpointKey] = eventHubEndpoint
		}
		properties.EventHubEndpoints = eventHubEndpointMap
	} else {
		properties.EventHubEndpoints = nil
	}

	// Features
	if source.Features != nil {
		feature := *source.Features
		featureTemp := genruntime.ToEnum(feature, iotHubProperties_Features_Values)
		properties.Features = &featureTemp
	} else {
		properties.Features = nil
	}

	// IpFilterRules
	if source.IpFilterRules != nil {
		ipFilterRuleList := make([]IpFilterRule, len(source.IpFilterRules))
		for ipFilterRuleIndex, ipFilterRuleItem := range source.IpFilterRules {
			// Shadow the loop variable to avoid aliasing
			ipFilterRuleItem := ipFilterRuleItem
			var ipFilterRule IpFilterRule
			err := ipFilterRule.AssignProperties_From_IpFilterRule(&ipFilterRuleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_IpFilterRule() to populate field IpFilterRules")
			}
			ipFilterRuleList[ipFilterRuleIndex] = ipFilterRule
		}
		properties.IpFilterRules = ipFilterRuleList
	} else {
		properties.IpFilterRules = nil
	}

	// MessagingEndpoints
	if source.MessagingEndpoints != nil {
		messagingEndpointMap := make(map[string]MessagingEndpointProperties, len(source.MessagingEndpoints))
		for messagingEndpointKey, messagingEndpointValue := range source.MessagingEndpoints {
			// Shadow the loop variable to avoid aliasing
			messagingEndpointValue := messagingEndpointValue
			var messagingEndpoint MessagingEndpointProperties
			err := messagingEndpoint.AssignProperties_From_MessagingEndpointProperties(&messagingEndpointValue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_MessagingEndpointProperties() to populate field MessagingEndpoints")
			}
			messagingEndpointMap[messagingEndpointKey] = messagingEndpoint
		}
		properties.MessagingEndpoints = messagingEndpointMap
	} else {
		properties.MessagingEndpoints = nil
	}

	// MinTlsVersion
	properties.MinTlsVersion = genruntime.ClonePointerToString(source.MinTlsVersion)

	// NetworkRuleSets
	if source.NetworkRuleSets != nil {
		var networkRuleSet NetworkRuleSetProperties
		err := networkRuleSet.AssignProperties_From_NetworkRuleSetProperties(source.NetworkRuleSets)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_NetworkRuleSetProperties() to populate field NetworkRuleSets")
		}
		properties.NetworkRuleSets = &networkRuleSet
	} else {
		properties.NetworkRuleSets = nil
	}

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := *source.PublicNetworkAccess
		publicNetworkAccessTemp := genruntime.ToEnum(publicNetworkAccess, iotHubProperties_PublicNetworkAccess_Values)
		properties.PublicNetworkAccess = &publicNetworkAccessTemp
	} else {
		properties.PublicNetworkAccess = nil
	}

	// RestrictOutboundNetworkAccess
	if source.RestrictOutboundNetworkAccess != nil {
		restrictOutboundNetworkAccess := *source.RestrictOutboundNetworkAccess
		properties.RestrictOutboundNetworkAccess = &restrictOutboundNetworkAccess
	} else {
		properties.RestrictOutboundNetworkAccess = nil
	}

	// Routing
	if source.Routing != nil {
		var routing RoutingProperties
		err := routing.AssignProperties_From_RoutingProperties(source.Routing)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_RoutingProperties() to populate field Routing")
		}
		properties.Routing = &routing
	} else {
		properties.Routing = nil
	}

	// StorageEndpoints
	if source.StorageEndpoints != nil {
		storageEndpointMap := make(map[string]StorageEndpointProperties, len(source.StorageEndpoints))
		for storageEndpointKey, storageEndpointValue := range source.StorageEndpoints {
			// Shadow the loop variable to avoid aliasing
			storageEndpointValue := storageEndpointValue
			var storageEndpoint StorageEndpointProperties
			err := storageEndpoint.AssignProperties_From_StorageEndpointProperties(&storageEndpointValue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_StorageEndpointProperties() to populate field StorageEndpoints")
			}
			storageEndpointMap[storageEndpointKey] = storageEndpoint
		}
		properties.StorageEndpoints = storageEndpointMap
	} else {
		properties.StorageEndpoints = nil
	}

	// No error
	return nil
}

// AssignProperties_To_IotHubProperties populates the provided destination IotHubProperties from our IotHubProperties
func (properties *IotHubProperties) AssignProperties_To_IotHubProperties(destination *storage.IotHubProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowedFqdnList
	destination.AllowedFqdnList = genruntime.CloneSliceOfString(properties.AllowedFqdnList)

	// AuthorizationPolicies
	if properties.AuthorizationPolicies != nil {
		authorizationPolicyList := make([]storage.SharedAccessSignatureAuthorizationRule, len(properties.AuthorizationPolicies))
		for authorizationPolicyIndex, authorizationPolicyItem := range properties.AuthorizationPolicies {
			// Shadow the loop variable to avoid aliasing
			authorizationPolicyItem := authorizationPolicyItem
			var authorizationPolicy storage.SharedAccessSignatureAuthorizationRule
			err := authorizationPolicyItem.AssignProperties_To_SharedAccessSignatureAuthorizationRule(&authorizationPolicy)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_SharedAccessSignatureAuthorizationRule() to populate field AuthorizationPolicies")
			}
			authorizationPolicyList[authorizationPolicyIndex] = authorizationPolicy
		}
		destination.AuthorizationPolicies = authorizationPolicyList
	} else {
		destination.AuthorizationPolicies = nil
	}

	// CloudToDevice
	if properties.CloudToDevice != nil {
		var cloudToDevice storage.CloudToDeviceProperties
		err := properties.CloudToDevice.AssignProperties_To_CloudToDeviceProperties(&cloudToDevice)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CloudToDeviceProperties() to populate field CloudToDevice")
		}
		destination.CloudToDevice = &cloudToDevice
	} else {
		destination.CloudToDevice = nil
	}

	// Comments
	destination.Comments = genruntime.ClonePointerToString(properties.Comments)

	// DisableDeviceSAS
	if properties.DisableDeviceSAS != nil {
		disableDeviceSAS := *properties.DisableDeviceSAS
		destination.DisableDeviceSAS = &disableDeviceSAS
	} else {
		destination.DisableDeviceSAS = nil
	}

	// DisableLocalAuth
	if properties.DisableLocalAuth != nil {
		disableLocalAuth := *properties.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// DisableModuleSAS
	if properties.DisableModuleSAS != nil {
		disableModuleSAS := *properties.DisableModuleSAS
		destination.DisableModuleSAS = &disableModuleSAS
	} else {
		destination.DisableModuleSAS = nil
	}

	// EnableDataResidency
	if properties.EnableDataResidency != nil {
		enableDataResidency := *properties.EnableDataResidency
		destination.EnableDataResidency = &enableDataResidency
	} else {
		destination.EnableDataResidency = nil
	}

	// EnableFileUploadNotifications
	if properties.EnableFileUploadNotifications != nil {
		enableFileUploadNotification := *properties.EnableFileUploadNotifications
		destination.EnableFileUploadNotifications = &enableFileUploadNotification
	} else {
		destination.EnableFileUploadNotifications = nil
	}

	// EventHubEndpoints
	if properties.EventHubEndpoints != nil {
		eventHubEndpointMap := make(map[string]storage.EventHubProperties, len(properties.EventHubEndpoints))
		for eventHubEndpointKey, eventHubEndpointValue := range properties.EventHubEndpoints {
			// Shadow the loop variable to avoid aliasing
			eventHubEndpointValue := eventHubEndpointValue
			var eventHubEndpoint storage.EventHubProperties
			err := eventHubEndpointValue.AssignProperties_To_EventHubProperties(&eventHubEndpoint)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_EventHubProperties() to populate field EventHubEndpoints")
			}
			eventHubEndpointMap[eventHubEndpointKey] = eventHubEndpoint
		}
		destination.EventHubEndpoints = eventHubEndpointMap
	} else {
		destination.EventHubEndpoints = nil
	}

	// Features
	if properties.Features != nil {
		feature := string(*properties.Features)
		destination.Features = &feature
	} else {
		destination.Features = nil
	}

	// IpFilterRules
	if properties.IpFilterRules != nil {
		ipFilterRuleList := make([]storage.IpFilterRule, len(properties.IpFilterRules))
		for ipFilterRuleIndex, ipFilterRuleItem := range properties.IpFilterRules {
			// Shadow the loop variable to avoid aliasing
			ipFilterRuleItem := ipFilterRuleItem
			var ipFilterRule storage.IpFilterRule
			err := ipFilterRuleItem.AssignProperties_To_IpFilterRule(&ipFilterRule)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_IpFilterRule() to populate field IpFilterRules")
			}
			ipFilterRuleList[ipFilterRuleIndex] = ipFilterRule
		}
		destination.IpFilterRules = ipFilterRuleList
	} else {
		destination.IpFilterRules = nil
	}

	// MessagingEndpoints
	if properties.MessagingEndpoints != nil {
		messagingEndpointMap := make(map[string]storage.MessagingEndpointProperties, len(properties.MessagingEndpoints))
		for messagingEndpointKey, messagingEndpointValue := range properties.MessagingEndpoints {
			// Shadow the loop variable to avoid aliasing
			messagingEndpointValue := messagingEndpointValue
			var messagingEndpoint storage.MessagingEndpointProperties
			err := messagingEndpointValue.AssignProperties_To_MessagingEndpointProperties(&messagingEndpoint)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_MessagingEndpointProperties() to populate field MessagingEndpoints")
			}
			messagingEndpointMap[messagingEndpointKey] = messagingEndpoint
		}
		destination.MessagingEndpoints = messagingEndpointMap
	} else {
		destination.MessagingEndpoints = nil
	}

	// MinTlsVersion
	destination.MinTlsVersion = genruntime.ClonePointerToString(properties.MinTlsVersion)

	// NetworkRuleSets
	if properties.NetworkRuleSets != nil {
		var networkRuleSet storage.NetworkRuleSetProperties
		err := properties.NetworkRuleSets.AssignProperties_To_NetworkRuleSetProperties(&networkRuleSet)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_NetworkRuleSetProperties() to populate field NetworkRuleSets")
		}
		destination.NetworkRuleSets = &networkRuleSet
	} else {
		destination.NetworkRuleSets = nil
	}

	// PublicNetworkAccess
	if properties.PublicNetworkAccess != nil {
		publicNetworkAccess := string(*properties.PublicNetworkAccess)
		destination.PublicNetworkAccess = &publicNetworkAccess
	} else {
		destination.PublicNetworkAccess = nil
	}

	// RestrictOutboundNetworkAccess
	if properties.RestrictOutboundNetworkAccess != nil {
		restrictOutboundNetworkAccess := *properties.RestrictOutboundNetworkAccess
		destination.RestrictOutboundNetworkAccess = &restrictOutboundNetworkAccess
	} else {
		destination.RestrictOutboundNetworkAccess = nil
	}

	// Routing
	if properties.Routing != nil {
		var routing storage.RoutingProperties
		err := properties.Routing.AssignProperties_To_RoutingProperties(&routing)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_RoutingProperties() to populate field Routing")
		}
		destination.Routing = &routing
	} else {
		destination.Routing = nil
	}

	// StorageEndpoints
	if properties.StorageEndpoints != nil {
		storageEndpointMap := make(map[string]storage.StorageEndpointProperties, len(properties.StorageEndpoints))
		for storageEndpointKey, storageEndpointValue := range properties.StorageEndpoints {
			// Shadow the loop variable to avoid aliasing
			storageEndpointValue := storageEndpointValue
			var storageEndpoint storage.StorageEndpointProperties
			err := storageEndpointValue.AssignProperties_To_StorageEndpointProperties(&storageEndpoint)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_StorageEndpointProperties() to populate field StorageEndpoints")
			}
			storageEndpointMap[storageEndpointKey] = storageEndpoint
		}
		destination.StorageEndpoints = storageEndpointMap
	} else {
		destination.StorageEndpoints = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_IotHubProperties_STATUS populates our IotHubProperties from the provided source IotHubProperties_STATUS
func (properties *IotHubProperties) Initialize_From_IotHubProperties_STATUS(source *IotHubProperties_STATUS) error {

	// AllowedFqdnList
	properties.AllowedFqdnList = genruntime.CloneSliceOfString(source.AllowedFqdnList)

	// AuthorizationPolicies
	if source.AuthorizationPolicies != nil {
		authorizationPolicyList := make([]SharedAccessSignatureAuthorizationRule, len(source.AuthorizationPolicies))
		for authorizationPolicyIndex, authorizationPolicyItem := range source.AuthorizationPolicies {
			// Shadow the loop variable to avoid aliasing
			authorizationPolicyItem := authorizationPolicyItem
			var authorizationPolicy SharedAccessSignatureAuthorizationRule
			err := authorizationPolicy.Initialize_From_SharedAccessSignatureAuthorizationRule_STATUS(&authorizationPolicyItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_SharedAccessSignatureAuthorizationRule_STATUS() to populate field AuthorizationPolicies")
			}
			authorizationPolicyList[authorizationPolicyIndex] = authorizationPolicy
		}
		properties.AuthorizationPolicies = authorizationPolicyList
	} else {
		properties.AuthorizationPolicies = nil
	}

	// CloudToDevice
	if source.CloudToDevice != nil {
		var cloudToDevice CloudToDeviceProperties
		err := cloudToDevice.Initialize_From_CloudToDeviceProperties_STATUS(source.CloudToDevice)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_CloudToDeviceProperties_STATUS() to populate field CloudToDevice")
		}
		properties.CloudToDevice = &cloudToDevice
	} else {
		properties.CloudToDevice = nil
	}

	// Comments
	properties.Comments = genruntime.ClonePointerToString(source.Comments)

	// DisableDeviceSAS
	if source.DisableDeviceSAS != nil {
		disableDeviceSAS := *source.DisableDeviceSAS
		properties.DisableDeviceSAS = &disableDeviceSAS
	} else {
		properties.DisableDeviceSAS = nil
	}

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		properties.DisableLocalAuth = &disableLocalAuth
	} else {
		properties.DisableLocalAuth = nil
	}

	// DisableModuleSAS
	if source.DisableModuleSAS != nil {
		disableModuleSAS := *source.DisableModuleSAS
		properties.DisableModuleSAS = &disableModuleSAS
	} else {
		properties.DisableModuleSAS = nil
	}

	// EnableDataResidency
	if source.EnableDataResidency != nil {
		enableDataResidency := *source.EnableDataResidency
		properties.EnableDataResidency = &enableDataResidency
	} else {
		properties.EnableDataResidency = nil
	}

	// EnableFileUploadNotifications
	if source.EnableFileUploadNotifications != nil {
		enableFileUploadNotification := *source.EnableFileUploadNotifications
		properties.EnableFileUploadNotifications = &enableFileUploadNotification
	} else {
		properties.EnableFileUploadNotifications = nil
	}

	// EventHubEndpoints
	if source.EventHubEndpoints != nil {
		eventHubEndpointMap := make(map[string]EventHubProperties, len(source.EventHubEndpoints))
		for eventHubEndpointKey, eventHubEndpointValue := range source.EventHubEndpoints {
			// Shadow the loop variable to avoid aliasing
			eventHubEndpointValue := eventHubEndpointValue
			var eventHubEndpoint EventHubProperties
			err := eventHubEndpoint.Initialize_From_EventHubProperties_STATUS(&eventHubEndpointValue)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_EventHubProperties_STATUS() to populate field EventHubEndpoints")
			}
			eventHubEndpointMap[eventHubEndpointKey] = eventHubEndpoint
		}
		properties.EventHubEndpoints = eventHubEndpointMap
	} else {
		properties.EventHubEndpoints = nil
	}

	// Features
	if source.Features != nil {
		feature := genruntime.ToEnum(string(*source.Features), iotHubProperties_Features_Values)
		properties.Features = &feature
	} else {
		properties.Features = nil
	}

	// IpFilterRules
	if source.IpFilterRules != nil {
		ipFilterRuleList := make([]IpFilterRule, len(source.IpFilterRules))
		for ipFilterRuleIndex, ipFilterRuleItem := range source.IpFilterRules {
			// Shadow the loop variable to avoid aliasing
			ipFilterRuleItem := ipFilterRuleItem
			var ipFilterRule IpFilterRule
			err := ipFilterRule.Initialize_From_IpFilterRule_STATUS(&ipFilterRuleItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_IpFilterRule_STATUS() to populate field IpFilterRules")
			}
			ipFilterRuleList[ipFilterRuleIndex] = ipFilterRule
		}
		properties.IpFilterRules = ipFilterRuleList
	} else {
		properties.IpFilterRules = nil
	}

	// MessagingEndpoints
	if source.MessagingEndpoints != nil {
		messagingEndpointMap := make(map[string]MessagingEndpointProperties, len(source.MessagingEndpoints))
		for messagingEndpointKey, messagingEndpointValue := range source.MessagingEndpoints {
			// Shadow the loop variable to avoid aliasing
			messagingEndpointValue := messagingEndpointValue
			var messagingEndpoint MessagingEndpointProperties
			err := messagingEndpoint.Initialize_From_MessagingEndpointProperties_STATUS(&messagingEndpointValue)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_MessagingEndpointProperties_STATUS() to populate field MessagingEndpoints")
			}
			messagingEndpointMap[messagingEndpointKey] = messagingEndpoint
		}
		properties.MessagingEndpoints = messagingEndpointMap
	} else {
		properties.MessagingEndpoints = nil
	}

	// MinTlsVersion
	properties.MinTlsVersion = genruntime.ClonePointerToString(source.MinTlsVersion)

	// NetworkRuleSets
	if source.NetworkRuleSets != nil {
		var networkRuleSet NetworkRuleSetProperties
		err := networkRuleSet.Initialize_From_NetworkRuleSetProperties_STATUS(source.NetworkRuleSets)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_NetworkRuleSetProperties_STATUS() to populate field NetworkRuleSets")
		}
		properties.NetworkRuleSets = &networkRuleSet
	} else {
		properties.NetworkRuleSets = nil
	}

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := genruntime.ToEnum(string(*source.PublicNetworkAccess), iotHubProperties_PublicNetworkAccess_Values)
		properties.PublicNetworkAccess = &publicNetworkAccess
	} else {
		properties.PublicNetworkAccess = nil
	}

	// RestrictOutboundNetworkAccess
	if source.RestrictOutboundNetworkAccess != nil {
		restrictOutboundNetworkAccess := *source.RestrictOutboundNetworkAccess
		properties.RestrictOutboundNetworkAccess = &restrictOutboundNetworkAccess
	} else {
		properties.RestrictOutboundNetworkAccess = nil
	}

	// Routing
	if source.Routing != nil {
		var routing RoutingProperties
		err := routing.Initialize_From_RoutingProperties_STATUS(source.Routing)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_RoutingProperties_STATUS() to populate field Routing")
		}
		properties.Routing = &routing
	} else {
		properties.Routing = nil
	}

	// StorageEndpoints
	if source.StorageEndpoints != nil {
		storageEndpointMap := make(map[string]StorageEndpointProperties, len(source.StorageEndpoints))
		for storageEndpointKey, storageEndpointValue := range source.StorageEndpoints {
			// Shadow the loop variable to avoid aliasing
			storageEndpointValue := storageEndpointValue
			var storageEndpoint StorageEndpointProperties
			err := storageEndpoint.Initialize_From_StorageEndpointProperties_STATUS(&storageEndpointValue)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_StorageEndpointProperties_STATUS() to populate field StorageEndpoints")
			}
			storageEndpointMap[storageEndpointKey] = storageEndpoint
		}
		properties.StorageEndpoints = storageEndpointMap
	} else {
		properties.StorageEndpoints = nil
	}

	// No error
	return nil
}

// The properties of an IoT hub.
type IotHubProperties_STATUS struct {
	// AllowedFqdnList: List of allowed FQDNs(Fully Qualified Domain Name) for egress from Iot Hub.
	AllowedFqdnList []string `json:"allowedFqdnList,omitempty"`

	// AuthorizationPolicies: The shared access policies you can use to secure a connection to the IoT hub.
	AuthorizationPolicies []SharedAccessSignatureAuthorizationRule_STATUS `json:"authorizationPolicies,omitempty"`

	// CloudToDevice: The IoT hub cloud-to-device messaging properties.
	CloudToDevice *CloudToDeviceProperties_STATUS `json:"cloudToDevice,omitempty"`

	// Comments: IoT hub comments.
	Comments *string `json:"comments,omitempty"`

	// DisableDeviceSAS: If true, all device(including Edge devices but excluding modules) scoped SAS keys cannot be used for
	// authentication.
	DisableDeviceSAS *bool `json:"disableDeviceSAS,omitempty"`

	// DisableLocalAuth: If true, SAS tokens with Iot hub scoped SAS keys cannot be used for authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// DisableModuleSAS: If true, all module scoped SAS keys cannot be used for authentication.
	DisableModuleSAS *bool `json:"disableModuleSAS,omitempty"`

	// EnableDataResidency: This property when set to true, will enable data residency, thus, disabling disaster recovery.
	EnableDataResidency *bool `json:"enableDataResidency,omitempty"`

	// EnableFileUploadNotifications: If True, file upload notifications are enabled.
	EnableFileUploadNotifications *bool `json:"enableFileUploadNotifications,omitempty"`

	// EventHubEndpoints: The Event Hub-compatible endpoint properties. The only possible keys to this dictionary is events.
	// This key has to be present in the dictionary while making create or update calls for the IoT hub.
	EventHubEndpoints map[string]EventHubProperties_STATUS `json:"eventHubEndpoints,omitempty"`

	// Features: The capabilities and features enabled for the IoT hub.
	Features *IotHubProperties_Features_STATUS `json:"features,omitempty"`

	// HostName: The name of the host.
	HostName *string `json:"hostName,omitempty"`

	// IpFilterRules: The IP filter rules.
	IpFilterRules []IpFilterRule_STATUS `json:"ipFilterRules,omitempty"`

	// Locations: Primary and secondary location for iot hub
	Locations []IotHubLocationDescription_STATUS `json:"locations,omitempty"`

	// MessagingEndpoints: The messaging endpoint properties for the file upload notification queue.
	MessagingEndpoints map[string]MessagingEndpointProperties_STATUS `json:"messagingEndpoints,omitempty"`

	// MinTlsVersion: Specifies the minimum TLS version to support for this hub. Can be set to "1.2" to have clients that use a
	// TLS version below 1.2 to be rejected.
	MinTlsVersion *string `json:"minTlsVersion,omitempty"`

	// NetworkRuleSets: Network Rule Set Properties of IotHub
	NetworkRuleSets *NetworkRuleSetProperties_STATUS `json:"networkRuleSets,omitempty"`

	// PrivateEndpointConnections: Private endpoint connections created on this IotHub
	PrivateEndpointConnections []PrivateEndpointConnection_STATUS `json:"privateEndpointConnections,omitempty"`

	// ProvisioningState: The provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty"`

	// PublicNetworkAccess: Whether requests from Public Network are allowed
	PublicNetworkAccess *IotHubProperties_PublicNetworkAccess_STATUS `json:"publicNetworkAccess,omitempty"`

	// RestrictOutboundNetworkAccess: If true, egress from IotHub will be restricted to only the allowed FQDNs that are
	// configured via allowedFqdnList.
	RestrictOutboundNetworkAccess *bool `json:"restrictOutboundNetworkAccess,omitempty"`

	// Routing: The routing related properties of the IoT hub. See:
	// https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-messaging
	Routing *RoutingProperties_STATUS `json:"routing,omitempty"`

	// State: The hub state.
	State *string `json:"state,omitempty"`

	// StorageEndpoints: The list of Azure Storage endpoints where you can upload files. Currently you can configure only one
	// Azure Storage account and that MUST have its key as $default. Specifying more than one storage account causes an error
	// to be thrown. Not specifying a value for this property when the enableFileUploadNotifications property is set to True,
	// causes an error to be thrown.
	StorageEndpoints map[string]StorageEndpointProperties_STATUS `json:"storageEndpoints,omitempty"`
}

var _ genruntime.FromARMConverter = &IotHubProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *IotHubProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IotHubProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *IotHubProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IotHubProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IotHubProperties_STATUS, got %T", armInput)
	}

	// Set property "AllowedFqdnList":
	for _, item := range typedInput.AllowedFqdnList {
		properties.AllowedFqdnList = append(properties.AllowedFqdnList, item)
	}

	// Set property "AuthorizationPolicies":
	for _, item := range typedInput.AuthorizationPolicies {
		var item1 SharedAccessSignatureAuthorizationRule_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.AuthorizationPolicies = append(properties.AuthorizationPolicies, item1)
	}

	// Set property "CloudToDevice":
	if typedInput.CloudToDevice != nil {
		var cloudToDevice1 CloudToDeviceProperties_STATUS
		err := cloudToDevice1.PopulateFromARM(owner, *typedInput.CloudToDevice)
		if err != nil {
			return err
		}
		cloudToDevice := cloudToDevice1
		properties.CloudToDevice = &cloudToDevice
	}

	// Set property "Comments":
	if typedInput.Comments != nil {
		comments := *typedInput.Comments
		properties.Comments = &comments
	}

	// Set property "DisableDeviceSAS":
	if typedInput.DisableDeviceSAS != nil {
		disableDeviceSAS := *typedInput.DisableDeviceSAS
		properties.DisableDeviceSAS = &disableDeviceSAS
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		properties.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "DisableModuleSAS":
	if typedInput.DisableModuleSAS != nil {
		disableModuleSAS := *typedInput.DisableModuleSAS
		properties.DisableModuleSAS = &disableModuleSAS
	}

	// Set property "EnableDataResidency":
	if typedInput.EnableDataResidency != nil {
		enableDataResidency := *typedInput.EnableDataResidency
		properties.EnableDataResidency = &enableDataResidency
	}

	// Set property "EnableFileUploadNotifications":
	if typedInput.EnableFileUploadNotifications != nil {
		enableFileUploadNotifications := *typedInput.EnableFileUploadNotifications
		properties.EnableFileUploadNotifications = &enableFileUploadNotifications
	}

	// Set property "EventHubEndpoints":
	if typedInput.EventHubEndpoints != nil {
		properties.EventHubEndpoints = make(map[string]EventHubProperties_STATUS, len(typedInput.EventHubEndpoints))
		for key, value := range typedInput.EventHubEndpoints {
			var value1 EventHubProperties_STATUS
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			properties.EventHubEndpoints[key] = value1
		}
	}

	// Set property "Features":
	if typedInput.Features != nil {
		var temp string
		temp = string(*typedInput.Features)
		features := IotHubProperties_Features_STATUS(temp)
		properties.Features = &features
	}

	// Set property "HostName":
	if typedInput.HostName != nil {
		hostName := *typedInput.HostName
		properties.HostName = &hostName
	}

	// Set property "IpFilterRules":
	for _, item := range typedInput.IpFilterRules {
		var item1 IpFilterRule_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.IpFilterRules = append(properties.IpFilterRules, item1)
	}

	// Set property "Locations":
	for _, item := range typedInput.Locations {
		var item1 IotHubLocationDescription_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.Locations = append(properties.Locations, item1)
	}

	// Set property "MessagingEndpoints":
	if typedInput.MessagingEndpoints != nil {
		properties.MessagingEndpoints = make(map[string]MessagingEndpointProperties_STATUS, len(typedInput.MessagingEndpoints))
		for key, value := range typedInput.MessagingEndpoints {
			var value1 MessagingEndpointProperties_STATUS
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			properties.MessagingEndpoints[key] = value1
		}
	}

	// Set property "MinTlsVersion":
	if typedInput.MinTlsVersion != nil {
		minTlsVersion := *typedInput.MinTlsVersion
		properties.MinTlsVersion = &minTlsVersion
	}

	// Set property "NetworkRuleSets":
	if typedInput.NetworkRuleSets != nil {
		var networkRuleSets1 NetworkRuleSetProperties_STATUS
		err := networkRuleSets1.PopulateFromARM(owner, *typedInput.NetworkRuleSets)
		if err != nil {
			return err
		}
		networkRuleSets := networkRuleSets1
		properties.NetworkRuleSets = &networkRuleSets
	}

	// Set property "PrivateEndpointConnections":
	for _, item := range typedInput.PrivateEndpointConnections {
		var item1 PrivateEndpointConnection_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.PrivateEndpointConnections = append(properties.PrivateEndpointConnections, item1)
	}

	// Set property "ProvisioningState":
	if typedInput.ProvisioningState != nil {
		provisioningState := *typedInput.ProvisioningState
		properties.ProvisioningState = &provisioningState
	}

	// Set property "PublicNetworkAccess":
	if typedInput.PublicNetworkAccess != nil {
		var temp string
		temp = string(*typedInput.PublicNetworkAccess)
		publicNetworkAccess := IotHubProperties_PublicNetworkAccess_STATUS(temp)
		properties.PublicNetworkAccess = &publicNetworkAccess
	}

	// Set property "RestrictOutboundNetworkAccess":
	if typedInput.RestrictOutboundNetworkAccess != nil {
		restrictOutboundNetworkAccess := *typedInput.RestrictOutboundNetworkAccess
		properties.RestrictOutboundNetworkAccess = &restrictOutboundNetworkAccess
	}

	// Set property "Routing":
	if typedInput.Routing != nil {
		var routing1 RoutingProperties_STATUS
		err := routing1.PopulateFromARM(owner, *typedInput.Routing)
		if err != nil {
			return err
		}
		routing := routing1
		properties.Routing = &routing
	}

	// Set property "State":
	if typedInput.State != nil {
		state := *typedInput.State
		properties.State = &state
	}

	// Set property "StorageEndpoints":
	if typedInput.StorageEndpoints != nil {
		properties.StorageEndpoints = make(map[string]StorageEndpointProperties_STATUS, len(typedInput.StorageEndpoints))
		for key, value := range typedInput.StorageEndpoints {
			var value1 StorageEndpointProperties_STATUS
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			properties.StorageEndpoints[key] = value1
		}
	}

	// No error
	return nil
}

// AssignProperties_From_IotHubProperties_STATUS populates our IotHubProperties_STATUS from the provided source IotHubProperties_STATUS
func (properties *IotHubProperties_STATUS) AssignProperties_From_IotHubProperties_STATUS(source *storage.IotHubProperties_STATUS) error {

	// AllowedFqdnList
	properties.AllowedFqdnList = genruntime.CloneSliceOfString(source.AllowedFqdnList)

	// AuthorizationPolicies
	if source.AuthorizationPolicies != nil {
		authorizationPolicyList := make([]SharedAccessSignatureAuthorizationRule_STATUS, len(source.AuthorizationPolicies))
		for authorizationPolicyIndex, authorizationPolicyItem := range source.AuthorizationPolicies {
			// Shadow the loop variable to avoid aliasing
			authorizationPolicyItem := authorizationPolicyItem
			var authorizationPolicy SharedAccessSignatureAuthorizationRule_STATUS
			err := authorizationPolicy.AssignProperties_From_SharedAccessSignatureAuthorizationRule_STATUS(&authorizationPolicyItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_SharedAccessSignatureAuthorizationRule_STATUS() to populate field AuthorizationPolicies")
			}
			authorizationPolicyList[authorizationPolicyIndex] = authorizationPolicy
		}
		properties.AuthorizationPolicies = authorizationPolicyList
	} else {
		properties.AuthorizationPolicies = nil
	}

	// CloudToDevice
	if source.CloudToDevice != nil {
		var cloudToDevice CloudToDeviceProperties_STATUS
		err := cloudToDevice.AssignProperties_From_CloudToDeviceProperties_STATUS(source.CloudToDevice)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CloudToDeviceProperties_STATUS() to populate field CloudToDevice")
		}
		properties.CloudToDevice = &cloudToDevice
	} else {
		properties.CloudToDevice = nil
	}

	// Comments
	properties.Comments = genruntime.ClonePointerToString(source.Comments)

	// DisableDeviceSAS
	if source.DisableDeviceSAS != nil {
		disableDeviceSAS := *source.DisableDeviceSAS
		properties.DisableDeviceSAS = &disableDeviceSAS
	} else {
		properties.DisableDeviceSAS = nil
	}

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		properties.DisableLocalAuth = &disableLocalAuth
	} else {
		properties.DisableLocalAuth = nil
	}

	// DisableModuleSAS
	if source.DisableModuleSAS != nil {
		disableModuleSAS := *source.DisableModuleSAS
		properties.DisableModuleSAS = &disableModuleSAS
	} else {
		properties.DisableModuleSAS = nil
	}

	// EnableDataResidency
	if source.EnableDataResidency != nil {
		enableDataResidency := *source.EnableDataResidency
		properties.EnableDataResidency = &enableDataResidency
	} else {
		properties.EnableDataResidency = nil
	}

	// EnableFileUploadNotifications
	if source.EnableFileUploadNotifications != nil {
		enableFileUploadNotification := *source.EnableFileUploadNotifications
		properties.EnableFileUploadNotifications = &enableFileUploadNotification
	} else {
		properties.EnableFileUploadNotifications = nil
	}

	// EventHubEndpoints
	if source.EventHubEndpoints != nil {
		eventHubEndpointMap := make(map[string]EventHubProperties_STATUS, len(source.EventHubEndpoints))
		for eventHubEndpointKey, eventHubEndpointValue := range source.EventHubEndpoints {
			// Shadow the loop variable to avoid aliasing
			eventHubEndpointValue := eventHubEndpointValue
			var eventHubEndpoint EventHubProperties_STATUS
			err := eventHubEndpoint.AssignProperties_From_EventHubProperties_STATUS(&eventHubEndpointValue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_EventHubProperties_STATUS() to populate field EventHubEndpoints")
			}
			eventHubEndpointMap[eventHubEndpointKey] = eventHubEndpoint
		}
		properties.EventHubEndpoints = eventHubEndpointMap
	} else {
		properties.EventHubEndpoints = nil
	}

	// Features
	if source.Features != nil {
		feature := *source.Features
		featureTemp := genruntime.ToEnum(feature, iotHubProperties_Features_STATUS_Values)
		properties.Features = &featureTemp
	} else {
		properties.Features = nil
	}

	// HostName
	properties.HostName = genruntime.ClonePointerToString(source.HostName)

	// IpFilterRules
	if source.IpFilterRules != nil {
		ipFilterRuleList := make([]IpFilterRule_STATUS, len(source.IpFilterRules))
		for ipFilterRuleIndex, ipFilterRuleItem := range source.IpFilterRules {
			// Shadow the loop variable to avoid aliasing
			ipFilterRuleItem := ipFilterRuleItem
			var ipFilterRule IpFilterRule_STATUS
			err := ipFilterRule.AssignProperties_From_IpFilterRule_STATUS(&ipFilterRuleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_IpFilterRule_STATUS() to populate field IpFilterRules")
			}
			ipFilterRuleList[ipFilterRuleIndex] = ipFilterRule
		}
		properties.IpFilterRules = ipFilterRuleList
	} else {
		properties.IpFilterRules = nil
	}

	// Locations
	if source.Locations != nil {
		locationList := make([]IotHubLocationDescription_STATUS, len(source.Locations))
		for locationIndex, locationItem := range source.Locations {
			// Shadow the loop variable to avoid aliasing
			locationItem := locationItem
			var location IotHubLocationDescription_STATUS
			err := location.AssignProperties_From_IotHubLocationDescription_STATUS(&locationItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_IotHubLocationDescription_STATUS() to populate field Locations")
			}
			locationList[locationIndex] = location
		}
		properties.Locations = locationList
	} else {
		properties.Locations = nil
	}

	// MessagingEndpoints
	if source.MessagingEndpoints != nil {
		messagingEndpointMap := make(map[string]MessagingEndpointProperties_STATUS, len(source.MessagingEndpoints))
		for messagingEndpointKey, messagingEndpointValue := range source.MessagingEndpoints {
			// Shadow the loop variable to avoid aliasing
			messagingEndpointValue := messagingEndpointValue
			var messagingEndpoint MessagingEndpointProperties_STATUS
			err := messagingEndpoint.AssignProperties_From_MessagingEndpointProperties_STATUS(&messagingEndpointValue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_MessagingEndpointProperties_STATUS() to populate field MessagingEndpoints")
			}
			messagingEndpointMap[messagingEndpointKey] = messagingEndpoint
		}
		properties.MessagingEndpoints = messagingEndpointMap
	} else {
		properties.MessagingEndpoints = nil
	}

	// MinTlsVersion
	properties.MinTlsVersion = genruntime.ClonePointerToString(source.MinTlsVersion)

	// NetworkRuleSets
	if source.NetworkRuleSets != nil {
		var networkRuleSet NetworkRuleSetProperties_STATUS
		err := networkRuleSet.AssignProperties_From_NetworkRuleSetProperties_STATUS(source.NetworkRuleSets)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_NetworkRuleSetProperties_STATUS() to populate field NetworkRuleSets")
		}
		properties.NetworkRuleSets = &networkRuleSet
	} else {
		properties.NetworkRuleSets = nil
	}

	// PrivateEndpointConnections
	if source.PrivateEndpointConnections != nil {
		privateEndpointConnectionList := make([]PrivateEndpointConnection_STATUS, len(source.PrivateEndpointConnections))
		for privateEndpointConnectionIndex, privateEndpointConnectionItem := range source.PrivateEndpointConnections {
			// Shadow the loop variable to avoid aliasing
			privateEndpointConnectionItem := privateEndpointConnectionItem
			var privateEndpointConnection PrivateEndpointConnection_STATUS
			err := privateEndpointConnection.AssignProperties_From_PrivateEndpointConnection_STATUS(&privateEndpointConnectionItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_PrivateEndpointConnection_STATUS() to populate field PrivateEndpointConnections")
			}
			privateEndpointConnectionList[privateEndpointConnectionIndex] = privateEndpointConnection
		}
		properties.PrivateEndpointConnections = privateEndpointConnectionList
	} else {
		properties.PrivateEndpointConnections = nil
	}

	// ProvisioningState
	properties.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := *source.PublicNetworkAccess
		publicNetworkAccessTemp := genruntime.ToEnum(publicNetworkAccess, iotHubProperties_PublicNetworkAccess_STATUS_Values)
		properties.PublicNetworkAccess = &publicNetworkAccessTemp
	} else {
		properties.PublicNetworkAccess = nil
	}

	// RestrictOutboundNetworkAccess
	if source.RestrictOutboundNetworkAccess != nil {
		restrictOutboundNetworkAccess := *source.RestrictOutboundNetworkAccess
		properties.RestrictOutboundNetworkAccess = &restrictOutboundNetworkAccess
	} else {
		properties.RestrictOutboundNetworkAccess = nil
	}

	// Routing
	if source.Routing != nil {
		var routing RoutingProperties_STATUS
		err := routing.AssignProperties_From_RoutingProperties_STATUS(source.Routing)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_RoutingProperties_STATUS() to populate field Routing")
		}
		properties.Routing = &routing
	} else {
		properties.Routing = nil
	}

	// State
	properties.State = genruntime.ClonePointerToString(source.State)

	// StorageEndpoints
	if source.StorageEndpoints != nil {
		storageEndpointMap := make(map[string]StorageEndpointProperties_STATUS, len(source.StorageEndpoints))
		for storageEndpointKey, storageEndpointValue := range source.StorageEndpoints {
			// Shadow the loop variable to avoid aliasing
			storageEndpointValue := storageEndpointValue
			var storageEndpoint StorageEndpointProperties_STATUS
			err := storageEndpoint.AssignProperties_From_StorageEndpointProperties_STATUS(&storageEndpointValue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_StorageEndpointProperties_STATUS() to populate field StorageEndpoints")
			}
			storageEndpointMap[storageEndpointKey] = storageEndpoint
		}
		properties.StorageEndpoints = storageEndpointMap
	} else {
		properties.StorageEndpoints = nil
	}

	// No error
	return nil
}

// AssignProperties_To_IotHubProperties_STATUS populates the provided destination IotHubProperties_STATUS from our IotHubProperties_STATUS
func (properties *IotHubProperties_STATUS) AssignProperties_To_IotHubProperties_STATUS(destination *storage.IotHubProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowedFqdnList
	destination.AllowedFqdnList = genruntime.CloneSliceOfString(properties.AllowedFqdnList)

	// AuthorizationPolicies
	if properties.AuthorizationPolicies != nil {
		authorizationPolicyList := make([]storage.SharedAccessSignatureAuthorizationRule_STATUS, len(properties.AuthorizationPolicies))
		for authorizationPolicyIndex, authorizationPolicyItem := range properties.AuthorizationPolicies {
			// Shadow the loop variable to avoid aliasing
			authorizationPolicyItem := authorizationPolicyItem
			var authorizationPolicy storage.SharedAccessSignatureAuthorizationRule_STATUS
			err := authorizationPolicyItem.AssignProperties_To_SharedAccessSignatureAuthorizationRule_STATUS(&authorizationPolicy)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_SharedAccessSignatureAuthorizationRule_STATUS() to populate field AuthorizationPolicies")
			}
			authorizationPolicyList[authorizationPolicyIndex] = authorizationPolicy
		}
		destination.AuthorizationPolicies = authorizationPolicyList
	} else {
		destination.AuthorizationPolicies = nil
	}

	// CloudToDevice
	if properties.CloudToDevice != nil {
		var cloudToDevice storage.CloudToDeviceProperties_STATUS
		err := properties.CloudToDevice.AssignProperties_To_CloudToDeviceProperties_STATUS(&cloudToDevice)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CloudToDeviceProperties_STATUS() to populate field CloudToDevice")
		}
		destination.CloudToDevice = &cloudToDevice
	} else {
		destination.CloudToDevice = nil
	}

	// Comments
	destination.Comments = genruntime.ClonePointerToString(properties.Comments)

	// DisableDeviceSAS
	if properties.DisableDeviceSAS != nil {
		disableDeviceSAS := *properties.DisableDeviceSAS
		destination.DisableDeviceSAS = &disableDeviceSAS
	} else {
		destination.DisableDeviceSAS = nil
	}

	// DisableLocalAuth
	if properties.DisableLocalAuth != nil {
		disableLocalAuth := *properties.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// DisableModuleSAS
	if properties.DisableModuleSAS != nil {
		disableModuleSAS := *properties.DisableModuleSAS
		destination.DisableModuleSAS = &disableModuleSAS
	} else {
		destination.DisableModuleSAS = nil
	}

	// EnableDataResidency
	if properties.EnableDataResidency != nil {
		enableDataResidency := *properties.EnableDataResidency
		destination.EnableDataResidency = &enableDataResidency
	} else {
		destination.EnableDataResidency = nil
	}

	// EnableFileUploadNotifications
	if properties.EnableFileUploadNotifications != nil {
		enableFileUploadNotification := *properties.EnableFileUploadNotifications
		destination.EnableFileUploadNotifications = &enableFileUploadNotification
	} else {
		destination.EnableFileUploadNotifications = nil
	}

	// EventHubEndpoints
	if properties.EventHubEndpoints != nil {
		eventHubEndpointMap := make(map[string]storage.EventHubProperties_STATUS, len(properties.EventHubEndpoints))
		for eventHubEndpointKey, eventHubEndpointValue := range properties.EventHubEndpoints {
			// Shadow the loop variable to avoid aliasing
			eventHubEndpointValue := eventHubEndpointValue
			var eventHubEndpoint storage.EventHubProperties_STATUS
			err := eventHubEndpointValue.AssignProperties_To_EventHubProperties_STATUS(&eventHubEndpoint)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_EventHubProperties_STATUS() to populate field EventHubEndpoints")
			}
			eventHubEndpointMap[eventHubEndpointKey] = eventHubEndpoint
		}
		destination.EventHubEndpoints = eventHubEndpointMap
	} else {
		destination.EventHubEndpoints = nil
	}

	// Features
	if properties.Features != nil {
		feature := string(*properties.Features)
		destination.Features = &feature
	} else {
		destination.Features = nil
	}

	// HostName
	destination.HostName = genruntime.ClonePointerToString(properties.HostName)

	// IpFilterRules
	if properties.IpFilterRules != nil {
		ipFilterRuleList := make([]storage.IpFilterRule_STATUS, len(properties.IpFilterRules))
		for ipFilterRuleIndex, ipFilterRuleItem := range properties.IpFilterRules {
			// Shadow the loop variable to avoid aliasing
			ipFilterRuleItem := ipFilterRuleItem
			var ipFilterRule storage.IpFilterRule_STATUS
			err := ipFilterRuleItem.AssignProperties_To_IpFilterRule_STATUS(&ipFilterRule)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_IpFilterRule_STATUS() to populate field IpFilterRules")
			}
			ipFilterRuleList[ipFilterRuleIndex] = ipFilterRule
		}
		destination.IpFilterRules = ipFilterRuleList
	} else {
		destination.IpFilterRules = nil
	}

	// Locations
	if properties.Locations != nil {
		locationList := make([]storage.IotHubLocationDescription_STATUS, len(properties.Locations))
		for locationIndex, locationItem := range properties.Locations {
			// Shadow the loop variable to avoid aliasing
			locationItem := locationItem
			var location storage.IotHubLocationDescription_STATUS
			err := locationItem.AssignProperties_To_IotHubLocationDescription_STATUS(&location)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_IotHubLocationDescription_STATUS() to populate field Locations")
			}
			locationList[locationIndex] = location
		}
		destination.Locations = locationList
	} else {
		destination.Locations = nil
	}

	// MessagingEndpoints
	if properties.MessagingEndpoints != nil {
		messagingEndpointMap := make(map[string]storage.MessagingEndpointProperties_STATUS, len(properties.MessagingEndpoints))
		for messagingEndpointKey, messagingEndpointValue := range properties.MessagingEndpoints {
			// Shadow the loop variable to avoid aliasing
			messagingEndpointValue := messagingEndpointValue
			var messagingEndpoint storage.MessagingEndpointProperties_STATUS
			err := messagingEndpointValue.AssignProperties_To_MessagingEndpointProperties_STATUS(&messagingEndpoint)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_MessagingEndpointProperties_STATUS() to populate field MessagingEndpoints")
			}
			messagingEndpointMap[messagingEndpointKey] = messagingEndpoint
		}
		destination.MessagingEndpoints = messagingEndpointMap
	} else {
		destination.MessagingEndpoints = nil
	}

	// MinTlsVersion
	destination.MinTlsVersion = genruntime.ClonePointerToString(properties.MinTlsVersion)

	// NetworkRuleSets
	if properties.NetworkRuleSets != nil {
		var networkRuleSet storage.NetworkRuleSetProperties_STATUS
		err := properties.NetworkRuleSets.AssignProperties_To_NetworkRuleSetProperties_STATUS(&networkRuleSet)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_NetworkRuleSetProperties_STATUS() to populate field NetworkRuleSets")
		}
		destination.NetworkRuleSets = &networkRuleSet
	} else {
		destination.NetworkRuleSets = nil
	}

	// PrivateEndpointConnections
	if properties.PrivateEndpointConnections != nil {
		privateEndpointConnectionList := make([]storage.PrivateEndpointConnection_STATUS, len(properties.PrivateEndpointConnections))
		for privateEndpointConnectionIndex, privateEndpointConnectionItem := range properties.PrivateEndpointConnections {
			// Shadow the loop variable to avoid aliasing
			privateEndpointConnectionItem := privateEndpointConnectionItem
			var privateEndpointConnection storage.PrivateEndpointConnection_STATUS
			err := privateEndpointConnectionItem.AssignProperties_To_PrivateEndpointConnection_STATUS(&privateEndpointConnection)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_PrivateEndpointConnection_STATUS() to populate field PrivateEndpointConnections")
			}
			privateEndpointConnectionList[privateEndpointConnectionIndex] = privateEndpointConnection
		}
		destination.PrivateEndpointConnections = privateEndpointConnectionList
	} else {
		destination.PrivateEndpointConnections = nil
	}

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(properties.ProvisioningState)

	// PublicNetworkAccess
	if properties.PublicNetworkAccess != nil {
		publicNetworkAccess := string(*properties.PublicNetworkAccess)
		destination.PublicNetworkAccess = &publicNetworkAccess
	} else {
		destination.PublicNetworkAccess = nil
	}

	// RestrictOutboundNetworkAccess
	if properties.RestrictOutboundNetworkAccess != nil {
		restrictOutboundNetworkAccess := *properties.RestrictOutboundNetworkAccess
		destination.RestrictOutboundNetworkAccess = &restrictOutboundNetworkAccess
	} else {
		destination.RestrictOutboundNetworkAccess = nil
	}

	// Routing
	if properties.Routing != nil {
		var routing storage.RoutingProperties_STATUS
		err := properties.Routing.AssignProperties_To_RoutingProperties_STATUS(&routing)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_RoutingProperties_STATUS() to populate field Routing")
		}
		destination.Routing = &routing
	} else {
		destination.Routing = nil
	}

	// State
	destination.State = genruntime.ClonePointerToString(properties.State)

	// StorageEndpoints
	if properties.StorageEndpoints != nil {
		storageEndpointMap := make(map[string]storage.StorageEndpointProperties_STATUS, len(properties.StorageEndpoints))
		for storageEndpointKey, storageEndpointValue := range properties.StorageEndpoints {
			// Shadow the loop variable to avoid aliasing
			storageEndpointValue := storageEndpointValue
			var storageEndpoint storage.StorageEndpointProperties_STATUS
			err := storageEndpointValue.AssignProperties_To_StorageEndpointProperties_STATUS(&storageEndpoint)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_StorageEndpointProperties_STATUS() to populate field StorageEndpoints")
			}
			storageEndpointMap[storageEndpointKey] = storageEndpoint
		}
		destination.StorageEndpoints = storageEndpointMap
	} else {
		destination.StorageEndpoints = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Information about the SKU of the IoT hub.
type IotHubSkuInfo struct {
	// Capacity: The number of provisioned IoT Hub units. See:
	// https://docs.microsoft.com/azure/azure-subscription-service-limits#iot-hub-limits.
	Capacity *int `json:"capacity,omitempty"`

	// +kubebuilder:validation:Required
	// Name: The name of the SKU.
	Name *IotHubSkuInfo_Name `json:"name,omitempty"`
}

var _ genruntime.ARMTransformer = &IotHubSkuInfo{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (info *IotHubSkuInfo) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if info == nil {
		return nil, nil
	}
	result := &arm.IotHubSkuInfo{}

	// Set property "Capacity":
	if info.Capacity != nil {
		capacity := *info.Capacity
		result.Capacity = &capacity
	}

	// Set property "Name":
	if info.Name != nil {
		var temp string
		temp = string(*info.Name)
		name := arm.IotHubSkuInfo_Name(temp)
		result.Name = &name
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (info *IotHubSkuInfo) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IotHubSkuInfo{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (info *IotHubSkuInfo) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IotHubSkuInfo)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IotHubSkuInfo, got %T", armInput)
	}

	// Set property "Capacity":
	if typedInput.Capacity != nil {
		capacity := *typedInput.Capacity
		info.Capacity = &capacity
	}

	// Set property "Name":
	if typedInput.Name != nil {
		var temp string
		temp = string(*typedInput.Name)
		name := IotHubSkuInfo_Name(temp)
		info.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_IotHubSkuInfo populates our IotHubSkuInfo from the provided source IotHubSkuInfo
func (info *IotHubSkuInfo) AssignProperties_From_IotHubSkuInfo(source *storage.IotHubSkuInfo) error {

	// Capacity
	info.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, iotHubSkuInfo_Name_Values)
		info.Name = &nameTemp
	} else {
		info.Name = nil
	}

	// No error
	return nil
}

// AssignProperties_To_IotHubSkuInfo populates the provided destination IotHubSkuInfo from our IotHubSkuInfo
func (info *IotHubSkuInfo) AssignProperties_To_IotHubSkuInfo(destination *storage.IotHubSkuInfo) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Capacity
	destination.Capacity = genruntime.ClonePointerToInt(info.Capacity)

	// Name
	if info.Name != nil {
		name := string(*info.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_IotHubSkuInfo_STATUS populates our IotHubSkuInfo from the provided source IotHubSkuInfo_STATUS
func (info *IotHubSkuInfo) Initialize_From_IotHubSkuInfo_STATUS(source *IotHubSkuInfo_STATUS) error {

	// Capacity
	info.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), iotHubSkuInfo_Name_Values)
		info.Name = &name
	} else {
		info.Name = nil
	}

	// No error
	return nil
}

// Information about the SKU of the IoT hub.
type IotHubSkuInfo_STATUS struct {
	// Capacity: The number of provisioned IoT Hub units. See:
	// https://docs.microsoft.com/azure/azure-subscription-service-limits#iot-hub-limits.
	Capacity *int `json:"capacity,omitempty"`

	// Name: The name of the SKU.
	Name *IotHubSkuInfo_Name_STATUS `json:"name,omitempty"`

	// Tier: The billing tier for the IoT hub.
	Tier *IotHubSkuInfo_Tier_STATUS `json:"tier,omitempty"`
}

var _ genruntime.FromARMConverter = &IotHubSkuInfo_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (info *IotHubSkuInfo_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IotHubSkuInfo_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (info *IotHubSkuInfo_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IotHubSkuInfo_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IotHubSkuInfo_STATUS, got %T", armInput)
	}

	// Set property "Capacity":
	if typedInput.Capacity != nil {
		capacity := *typedInput.Capacity
		info.Capacity = &capacity
	}

	// Set property "Name":
	if typedInput.Name != nil {
		var temp string
		temp = string(*typedInput.Name)
		name := IotHubSkuInfo_Name_STATUS(temp)
		info.Name = &name
	}

	// Set property "Tier":
	if typedInput.Tier != nil {
		var temp string
		temp = string(*typedInput.Tier)
		tier := IotHubSkuInfo_Tier_STATUS(temp)
		info.Tier = &tier
	}

	// No error
	return nil
}

// AssignProperties_From_IotHubSkuInfo_STATUS populates our IotHubSkuInfo_STATUS from the provided source IotHubSkuInfo_STATUS
func (info *IotHubSkuInfo_STATUS) AssignProperties_From_IotHubSkuInfo_STATUS(source *storage.IotHubSkuInfo_STATUS) error {

	// Capacity
	info.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, iotHubSkuInfo_Name_STATUS_Values)
		info.Name = &nameTemp
	} else {
		info.Name = nil
	}

	// Tier
	if source.Tier != nil {
		tier := *source.Tier
		tierTemp := genruntime.ToEnum(tier, iotHubSkuInfo_Tier_STATUS_Values)
		info.Tier = &tierTemp
	} else {
		info.Tier = nil
	}

	// No error
	return nil
}

// AssignProperties_To_IotHubSkuInfo_STATUS populates the provided destination IotHubSkuInfo_STATUS from our IotHubSkuInfo_STATUS
func (info *IotHubSkuInfo_STATUS) AssignProperties_To_IotHubSkuInfo_STATUS(destination *storage.IotHubSkuInfo_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Capacity
	destination.Capacity = genruntime.ClonePointerToInt(info.Capacity)

	// Name
	if info.Name != nil {
		name := string(*info.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Tier
	if info.Tier != nil {
		tier := string(*info.Tier)
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Metadata pertaining to creation and last modification of the resource.
type SystemData_STATUS struct {
	// CreatedAt: The timestamp of resource creation (UTC).
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy: The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`

	// CreatedByType: The type of identity that created the resource.
	CreatedByType *SystemData_CreatedByType_STATUS `json:"createdByType,omitempty"`

	// LastModifiedAt: The timestamp of resource last modification (UTC)
	LastModifiedAt *string `json:"lastModifiedAt,omitempty"`

	// LastModifiedBy: The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`

	// LastModifiedByType: The type of identity that last modified the resource.
	LastModifiedByType *SystemData_LastModifiedByType_STATUS `json:"lastModifiedByType,omitempty"`
}

var _ genruntime.FromARMConverter = &SystemData_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (data *SystemData_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SystemData_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (data *SystemData_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SystemData_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SystemData_STATUS, got %T", armInput)
	}

	// Set property "CreatedAt":
	if typedInput.CreatedAt != nil {
		createdAt := *typedInput.CreatedAt
		data.CreatedAt = &createdAt
	}

	// Set property "CreatedBy":
	if typedInput.CreatedBy != nil {
		createdBy := *typedInput.CreatedBy
		data.CreatedBy = &createdBy
	}

	// Set property "CreatedByType":
	if typedInput.CreatedByType != nil {
		var temp string
		temp = string(*typedInput.CreatedByType)
		createdByType := SystemData_CreatedByType_STATUS(temp)
		data.CreatedByType = &createdByType
	}

	// Set property "LastModifiedAt":
	if typedInput.LastModifiedAt != nil {
		lastModifiedAt := *typedInput.LastModifiedAt
		data.LastModifiedAt = &lastModifiedAt
	}

	// Set property "LastModifiedBy":
	if typedInput.LastModifiedBy != nil {
		lastModifiedBy := *typedInput.LastModifiedBy
		data.LastModifiedBy = &lastModifiedBy
	}

	// Set property "LastModifiedByType":
	if typedInput.LastModifiedByType != nil {
		var temp string
		temp = string(*typedInput.LastModifiedByType)
		lastModifiedByType := SystemData_LastModifiedByType_STATUS(temp)
		data.LastModifiedByType = &lastModifiedByType
	}

	// No error
	return nil
}

// AssignProperties_From_SystemData_STATUS populates our SystemData_STATUS from the provided source SystemData_STATUS
func (data *SystemData_STATUS) AssignProperties_From_SystemData_STATUS(source *storage.SystemData_STATUS) error {

	// CreatedAt
	data.CreatedAt = genruntime.ClonePointerToString(source.CreatedAt)

	// CreatedBy
	data.CreatedBy = genruntime.ClonePointerToString(source.CreatedBy)

	// CreatedByType
	if source.CreatedByType != nil {
		createdByType := *source.CreatedByType
		createdByTypeTemp := genruntime.ToEnum(createdByType, systemData_CreatedByType_STATUS_Values)
		data.CreatedByType = &createdByTypeTemp
	} else {
		data.CreatedByType = nil
	}

	// LastModifiedAt
	data.LastModifiedAt = genruntime.ClonePointerToString(source.LastModifiedAt)

	// LastModifiedBy
	data.LastModifiedBy = genruntime.ClonePointerToString(source.LastModifiedBy)

	// LastModifiedByType
	if source.LastModifiedByType != nil {
		lastModifiedByType := *source.LastModifiedByType
		lastModifiedByTypeTemp := genruntime.ToEnum(lastModifiedByType, systemData_LastModifiedByType_STATUS_Values)
		data.LastModifiedByType = &lastModifiedByTypeTemp
	} else {
		data.LastModifiedByType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SystemData_STATUS populates the provided destination SystemData_STATUS from our SystemData_STATUS
func (data *SystemData_STATUS) AssignProperties_To_SystemData_STATUS(destination *storage.SystemData_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CreatedAt
	destination.CreatedAt = genruntime.ClonePointerToString(data.CreatedAt)

	// CreatedBy
	destination.CreatedBy = genruntime.ClonePointerToString(data.CreatedBy)

	// CreatedByType
	if data.CreatedByType != nil {
		createdByType := string(*data.CreatedByType)
		destination.CreatedByType = &createdByType
	} else {
		destination.CreatedByType = nil
	}

	// LastModifiedAt
	destination.LastModifiedAt = genruntime.ClonePointerToString(data.LastModifiedAt)

	// LastModifiedBy
	destination.LastModifiedBy = genruntime.ClonePointerToString(data.LastModifiedBy)

	// LastModifiedByType
	if data.LastModifiedByType != nil {
		lastModifiedByType := string(*data.LastModifiedByType)
		destination.LastModifiedByType = &lastModifiedByType
	} else {
		destination.LastModifiedByType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"None","SystemAssigned","SystemAssigned, UserAssigned","UserAssigned"}
type ArmIdentity_Type string

const (
	ArmIdentity_Type_None                       = ArmIdentity_Type("None")
	ArmIdentity_Type_SystemAssigned             = ArmIdentity_Type("SystemAssigned")
	ArmIdentity_Type_SystemAssignedUserAssigned = ArmIdentity_Type("SystemAssigned, UserAssigned")
	ArmIdentity_Type_UserAssigned               = ArmIdentity_Type("UserAssigned")
)

// Mapping from string to ArmIdentity_Type
var armIdentity_Type_Values = map[string]ArmIdentity_Type{
	"none":                         ArmIdentity_Type_None,
	"systemassigned":               ArmIdentity_Type_SystemAssigned,
	"systemassigned, userassigned": ArmIdentity_Type_SystemAssignedUserAssigned,
	"userassigned":                 ArmIdentity_Type_UserAssigned,
}

type ArmIdentity_Type_STATUS string

const (
	ArmIdentity_Type_STATUS_None                       = ArmIdentity_Type_STATUS("None")
	ArmIdentity_Type_STATUS_SystemAssigned             = ArmIdentity_Type_STATUS("SystemAssigned")
	ArmIdentity_Type_STATUS_SystemAssignedUserAssigned = ArmIdentity_Type_STATUS("SystemAssigned, UserAssigned")
	ArmIdentity_Type_STATUS_UserAssigned               = ArmIdentity_Type_STATUS("UserAssigned")
)

// Mapping from string to ArmIdentity_Type_STATUS
var armIdentity_Type_STATUS_Values = map[string]ArmIdentity_Type_STATUS{
	"none":                         ArmIdentity_Type_STATUS_None,
	"systemassigned":               ArmIdentity_Type_STATUS_SystemAssigned,
	"systemassigned, userassigned": ArmIdentity_Type_STATUS_SystemAssignedUserAssigned,
	"userassigned":                 ArmIdentity_Type_STATUS_UserAssigned,
}

type ArmUserIdentity_STATUS struct {
	ClientId    *string `json:"clientId,omitempty"`
	PrincipalId *string `json:"principalId,omitempty"`
}

var _ genruntime.FromARMConverter = &ArmUserIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ArmUserIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ArmUserIdentity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ArmUserIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ArmUserIdentity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ArmUserIdentity_STATUS, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		identity.ClientId = &clientId
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// No error
	return nil
}

// AssignProperties_From_ArmUserIdentity_STATUS populates our ArmUserIdentity_STATUS from the provided source ArmUserIdentity_STATUS
func (identity *ArmUserIdentity_STATUS) AssignProperties_From_ArmUserIdentity_STATUS(source *storage.ArmUserIdentity_STATUS) error {

	// ClientId
	identity.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// No error
	return nil
}

// AssignProperties_To_ArmUserIdentity_STATUS populates the provided destination ArmUserIdentity_STATUS from our ArmUserIdentity_STATUS
func (identity *ArmUserIdentity_STATUS) AssignProperties_To_ArmUserIdentity_STATUS(destination *storage.ArmUserIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identity.ClientId)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The IoT hub cloud-to-device messaging properties.
type CloudToDeviceProperties struct {
	// DefaultTtlAsIso8601: The default time to live for cloud-to-device messages in the device queue. See:
	// https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-messaging#cloud-to-device-messages.
	DefaultTtlAsIso8601 *string `json:"defaultTtlAsIso8601,omitempty"`

	// Feedback: The properties of the feedback queue for cloud-to-device messages.
	Feedback *FeedbackProperties `json:"feedback,omitempty"`

	// +kubebuilder:validation:Maximum=100
	// +kubebuilder:validation:Minimum=1
	// MaxDeliveryCount: The max delivery count for cloud-to-device messages in the device queue. See:
	// https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-messaging#cloud-to-device-messages.
	MaxDeliveryCount *int `json:"maxDeliveryCount,omitempty"`
}

var _ genruntime.ARMTransformer = &CloudToDeviceProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *CloudToDeviceProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.CloudToDeviceProperties{}

	// Set property "DefaultTtlAsIso8601":
	if properties.DefaultTtlAsIso8601 != nil {
		defaultTtlAsIso8601 := *properties.DefaultTtlAsIso8601
		result.DefaultTtlAsIso8601 = &defaultTtlAsIso8601
	}

	// Set property "Feedback":
	if properties.Feedback != nil {
		feedback_ARM, err := (*properties.Feedback).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		feedback := *feedback_ARM.(*arm.FeedbackProperties)
		result.Feedback = &feedback
	}

	// Set property "MaxDeliveryCount":
	if properties.MaxDeliveryCount != nil {
		maxDeliveryCount := *properties.MaxDeliveryCount
		result.MaxDeliveryCount = &maxDeliveryCount
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *CloudToDeviceProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CloudToDeviceProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *CloudToDeviceProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CloudToDeviceProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CloudToDeviceProperties, got %T", armInput)
	}

	// Set property "DefaultTtlAsIso8601":
	if typedInput.DefaultTtlAsIso8601 != nil {
		defaultTtlAsIso8601 := *typedInput.DefaultTtlAsIso8601
		properties.DefaultTtlAsIso8601 = &defaultTtlAsIso8601
	}

	// Set property "Feedback":
	if typedInput.Feedback != nil {
		var feedback1 FeedbackProperties
		err := feedback1.PopulateFromARM(owner, *typedInput.Feedback)
		if err != nil {
			return err
		}
		feedback := feedback1
		properties.Feedback = &feedback
	}

	// Set property "MaxDeliveryCount":
	if typedInput.MaxDeliveryCount != nil {
		maxDeliveryCount := *typedInput.MaxDeliveryCount
		properties.MaxDeliveryCount = &maxDeliveryCount
	}

	// No error
	return nil
}

// AssignProperties_From_CloudToDeviceProperties populates our CloudToDeviceProperties from the provided source CloudToDeviceProperties
func (properties *CloudToDeviceProperties) AssignProperties_From_CloudToDeviceProperties(source *storage.CloudToDeviceProperties) error {

	// DefaultTtlAsIso8601
	properties.DefaultTtlAsIso8601 = genruntime.ClonePointerToString(source.DefaultTtlAsIso8601)

	// Feedback
	if source.Feedback != nil {
		var feedback FeedbackProperties
		err := feedback.AssignProperties_From_FeedbackProperties(source.Feedback)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_FeedbackProperties() to populate field Feedback")
		}
		properties.Feedback = &feedback
	} else {
		properties.Feedback = nil
	}

	// MaxDeliveryCount
	properties.MaxDeliveryCount = genruntime.ClonePointerToInt(source.MaxDeliveryCount)

	// No error
	return nil
}

// AssignProperties_To_CloudToDeviceProperties populates the provided destination CloudToDeviceProperties from our CloudToDeviceProperties
func (properties *CloudToDeviceProperties) AssignProperties_To_CloudToDeviceProperties(destination *storage.CloudToDeviceProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DefaultTtlAsIso8601
	destination.DefaultTtlAsIso8601 = genruntime.ClonePointerToString(properties.DefaultTtlAsIso8601)

	// Feedback
	if properties.Feedback != nil {
		var feedback storage.FeedbackProperties
		err := properties.Feedback.AssignProperties_To_FeedbackProperties(&feedback)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_FeedbackProperties() to populate field Feedback")
		}
		destination.Feedback = &feedback
	} else {
		destination.Feedback = nil
	}

	// MaxDeliveryCount
	destination.MaxDeliveryCount = genruntime.ClonePointerToInt(properties.MaxDeliveryCount)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_CloudToDeviceProperties_STATUS populates our CloudToDeviceProperties from the provided source CloudToDeviceProperties_STATUS
func (properties *CloudToDeviceProperties) Initialize_From_CloudToDeviceProperties_STATUS(source *CloudToDeviceProperties_STATUS) error {

	// DefaultTtlAsIso8601
	properties.DefaultTtlAsIso8601 = genruntime.ClonePointerToString(source.DefaultTtlAsIso8601)

	// Feedback
	if source.Feedback != nil {
		var feedback FeedbackProperties
		err := feedback.Initialize_From_FeedbackProperties_STATUS(source.Feedback)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_FeedbackProperties_STATUS() to populate field Feedback")
		}
		properties.Feedback = &feedback
	} else {
		properties.Feedback = nil
	}

	// MaxDeliveryCount
	properties.MaxDeliveryCount = genruntime.ClonePointerToInt(source.MaxDeliveryCount)

	// No error
	return nil
}

// The IoT hub cloud-to-device messaging properties.
type CloudToDeviceProperties_STATUS struct {
	// DefaultTtlAsIso8601: The default time to live for cloud-to-device messages in the device queue. See:
	// https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-messaging#cloud-to-device-messages.
	DefaultTtlAsIso8601 *string `json:"defaultTtlAsIso8601,omitempty"`

	// Feedback: The properties of the feedback queue for cloud-to-device messages.
	Feedback *FeedbackProperties_STATUS `json:"feedback,omitempty"`

	// MaxDeliveryCount: The max delivery count for cloud-to-device messages in the device queue. See:
	// https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-messaging#cloud-to-device-messages.
	MaxDeliveryCount *int `json:"maxDeliveryCount,omitempty"`
}

var _ genruntime.FromARMConverter = &CloudToDeviceProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *CloudToDeviceProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CloudToDeviceProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *CloudToDeviceProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CloudToDeviceProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CloudToDeviceProperties_STATUS, got %T", armInput)
	}

	// Set property "DefaultTtlAsIso8601":
	if typedInput.DefaultTtlAsIso8601 != nil {
		defaultTtlAsIso8601 := *typedInput.DefaultTtlAsIso8601
		properties.DefaultTtlAsIso8601 = &defaultTtlAsIso8601
	}

	// Set property "Feedback":
	if typedInput.Feedback != nil {
		var feedback1 FeedbackProperties_STATUS
		err := feedback1.PopulateFromARM(owner, *typedInput.Feedback)
		if err != nil {
			return err
		}
		feedback := feedback1
		properties.Feedback = &feedback
	}

	// Set property "MaxDeliveryCount":
	if typedInput.MaxDeliveryCount != nil {
		maxDeliveryCount := *typedInput.MaxDeliveryCount
		properties.MaxDeliveryCount = &maxDeliveryCount
	}

	// No error
	return nil
}

// AssignProperties_From_CloudToDeviceProperties_STATUS populates our CloudToDeviceProperties_STATUS from the provided source CloudToDeviceProperties_STATUS
func (properties *CloudToDeviceProperties_STATUS) AssignProperties_From_CloudToDeviceProperties_STATUS(source *storage.CloudToDeviceProperties_STATUS) error {

	// DefaultTtlAsIso8601
	properties.DefaultTtlAsIso8601 = genruntime.ClonePointerToString(source.DefaultTtlAsIso8601)

	// Feedback
	if source.Feedback != nil {
		var feedback FeedbackProperties_STATUS
		err := feedback.AssignProperties_From_FeedbackProperties_STATUS(source.Feedback)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_FeedbackProperties_STATUS() to populate field Feedback")
		}
		properties.Feedback = &feedback
	} else {
		properties.Feedback = nil
	}

	// MaxDeliveryCount
	properties.MaxDeliveryCount = genruntime.ClonePointerToInt(source.MaxDeliveryCount)

	// No error
	return nil
}

// AssignProperties_To_CloudToDeviceProperties_STATUS populates the provided destination CloudToDeviceProperties_STATUS from our CloudToDeviceProperties_STATUS
func (properties *CloudToDeviceProperties_STATUS) AssignProperties_To_CloudToDeviceProperties_STATUS(destination *storage.CloudToDeviceProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DefaultTtlAsIso8601
	destination.DefaultTtlAsIso8601 = genruntime.ClonePointerToString(properties.DefaultTtlAsIso8601)

	// Feedback
	if properties.Feedback != nil {
		var feedback storage.FeedbackProperties_STATUS
		err := properties.Feedback.AssignProperties_To_FeedbackProperties_STATUS(&feedback)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_FeedbackProperties_STATUS() to populate field Feedback")
		}
		destination.Feedback = &feedback
	} else {
		destination.Feedback = nil
	}

	// MaxDeliveryCount
	destination.MaxDeliveryCount = genruntime.ClonePointerToInt(properties.MaxDeliveryCount)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The properties of the provisioned Event Hub-compatible endpoint used by the IoT hub.
type EventHubProperties struct {
	// PartitionCount: The number of partitions for receiving device-to-cloud messages in the Event Hub-compatible endpoint.
	// See: https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-messaging#device-to-cloud-messages.
	PartitionCount *int `json:"partitionCount,omitempty"`

	// RetentionTimeInDays: The retention time for device-to-cloud messages in days. See:
	// https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-messaging#device-to-cloud-messages
	RetentionTimeInDays *int `json:"retentionTimeInDays,omitempty"`
}

var _ genruntime.ARMTransformer = &EventHubProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *EventHubProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.EventHubProperties{}

	// Set property "PartitionCount":
	if properties.PartitionCount != nil {
		partitionCount := *properties.PartitionCount
		result.PartitionCount = &partitionCount
	}

	// Set property "RetentionTimeInDays":
	if properties.RetentionTimeInDays != nil {
		retentionTimeInDays := *properties.RetentionTimeInDays
		result.RetentionTimeInDays = &retentionTimeInDays
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *EventHubProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EventHubProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *EventHubProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EventHubProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EventHubProperties, got %T", armInput)
	}

	// Set property "PartitionCount":
	if typedInput.PartitionCount != nil {
		partitionCount := *typedInput.PartitionCount
		properties.PartitionCount = &partitionCount
	}

	// Set property "RetentionTimeInDays":
	if typedInput.RetentionTimeInDays != nil {
		retentionTimeInDays := *typedInput.RetentionTimeInDays
		properties.RetentionTimeInDays = &retentionTimeInDays
	}

	// No error
	return nil
}

// AssignProperties_From_EventHubProperties populates our EventHubProperties from the provided source EventHubProperties
func (properties *EventHubProperties) AssignProperties_From_EventHubProperties(source *storage.EventHubProperties) error {

	// PartitionCount
	properties.PartitionCount = genruntime.ClonePointerToInt(source.PartitionCount)

	// RetentionTimeInDays
	properties.RetentionTimeInDays = genruntime.ClonePointerToInt(source.RetentionTimeInDays)

	// No error
	return nil
}

// AssignProperties_To_EventHubProperties populates the provided destination EventHubProperties from our EventHubProperties
func (properties *EventHubProperties) AssignProperties_To_EventHubProperties(destination *storage.EventHubProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PartitionCount
	destination.PartitionCount = genruntime.ClonePointerToInt(properties.PartitionCount)

	// RetentionTimeInDays
	destination.RetentionTimeInDays = genruntime.ClonePointerToInt(properties.RetentionTimeInDays)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_EventHubProperties_STATUS populates our EventHubProperties from the provided source EventHubProperties_STATUS
func (properties *EventHubProperties) Initialize_From_EventHubProperties_STATUS(source *EventHubProperties_STATUS) error {

	// PartitionCount
	properties.PartitionCount = genruntime.ClonePointerToInt(source.PartitionCount)

	// RetentionTimeInDays
	properties.RetentionTimeInDays = genruntime.ClonePointerToInt(source.RetentionTimeInDays)

	// No error
	return nil
}

// The properties of the provisioned Event Hub-compatible endpoint used by the IoT hub.
type EventHubProperties_STATUS struct {
	// Endpoint: The Event Hub-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`

	// PartitionCount: The number of partitions for receiving device-to-cloud messages in the Event Hub-compatible endpoint.
	// See: https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-messaging#device-to-cloud-messages.
	PartitionCount *int `json:"partitionCount,omitempty"`

	// PartitionIds: The partition ids in the Event Hub-compatible endpoint.
	PartitionIds []string `json:"partitionIds,omitempty"`

	// Path: The Event Hub-compatible name.
	Path *string `json:"path,omitempty"`

	// RetentionTimeInDays: The retention time for device-to-cloud messages in days. See:
	// https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-messaging#device-to-cloud-messages
	RetentionTimeInDays *int `json:"retentionTimeInDays,omitempty"`
}

var _ genruntime.FromARMConverter = &EventHubProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *EventHubProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EventHubProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *EventHubProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EventHubProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EventHubProperties_STATUS, got %T", armInput)
	}

	// Set property "Endpoint":
	if typedInput.Endpoint != nil {
		endpoint := *typedInput.Endpoint
		properties.Endpoint = &endpoint
	}

	// Set property "PartitionCount":
	if typedInput.PartitionCount != nil {
		partitionCount := *typedInput.PartitionCount
		properties.PartitionCount = &partitionCount
	}

	// Set property "PartitionIds":
	for _, item := range typedInput.PartitionIds {
		properties.PartitionIds = append(properties.PartitionIds, item)
	}

	// Set property "Path":
	if typedInput.Path != nil {
		path := *typedInput.Path
		properties.Path = &path
	}

	// Set property "RetentionTimeInDays":
	if typedInput.RetentionTimeInDays != nil {
		retentionTimeInDays := *typedInput.RetentionTimeInDays
		properties.RetentionTimeInDays = &retentionTimeInDays
	}

	// No error
	return nil
}

// AssignProperties_From_EventHubProperties_STATUS populates our EventHubProperties_STATUS from the provided source EventHubProperties_STATUS
func (properties *EventHubProperties_STATUS) AssignProperties_From_EventHubProperties_STATUS(source *storage.EventHubProperties_STATUS) error {

	// Endpoint
	properties.Endpoint = genruntime.ClonePointerToString(source.Endpoint)

	// PartitionCount
	properties.PartitionCount = genruntime.ClonePointerToInt(source.PartitionCount)

	// PartitionIds
	properties.PartitionIds = genruntime.CloneSliceOfString(source.PartitionIds)

	// Path
	properties.Path = genruntime.ClonePointerToString(source.Path)

	// RetentionTimeInDays
	properties.RetentionTimeInDays = genruntime.ClonePointerToInt(source.RetentionTimeInDays)

	// No error
	return nil
}

// AssignProperties_To_EventHubProperties_STATUS populates the provided destination EventHubProperties_STATUS from our EventHubProperties_STATUS
func (properties *EventHubProperties_STATUS) AssignProperties_To_EventHubProperties_STATUS(destination *storage.EventHubProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Endpoint
	destination.Endpoint = genruntime.ClonePointerToString(properties.Endpoint)

	// PartitionCount
	destination.PartitionCount = genruntime.ClonePointerToInt(properties.PartitionCount)

	// PartitionIds
	destination.PartitionIds = genruntime.CloneSliceOfString(properties.PartitionIds)

	// Path
	destination.Path = genruntime.ClonePointerToString(properties.Path)

	// RetentionTimeInDays
	destination.RetentionTimeInDays = genruntime.ClonePointerToInt(properties.RetentionTimeInDays)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Public representation of one of the locations where a resource is provisioned.
type IotHubLocationDescription_STATUS struct {
	// Location: The name of the Azure region
	Location *string `json:"location,omitempty"`

	// Role: The role of the region, can be either primary or secondary. The primary region is where the IoT hub is currently
	// provisioned. The secondary region is the Azure disaster recovery (DR) paired region and also the region where the IoT
	// hub can failover to.
	Role *IotHubLocationDescription_Role_STATUS `json:"role,omitempty"`
}

var _ genruntime.FromARMConverter = &IotHubLocationDescription_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (description *IotHubLocationDescription_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IotHubLocationDescription_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (description *IotHubLocationDescription_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IotHubLocationDescription_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IotHubLocationDescription_STATUS, got %T", armInput)
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		description.Location = &location
	}

	// Set property "Role":
	if typedInput.Role != nil {
		var temp string
		temp = string(*typedInput.Role)
		role := IotHubLocationDescription_Role_STATUS(temp)
		description.Role = &role
	}

	// No error
	return nil
}

// AssignProperties_From_IotHubLocationDescription_STATUS populates our IotHubLocationDescription_STATUS from the provided source IotHubLocationDescription_STATUS
func (description *IotHubLocationDescription_STATUS) AssignProperties_From_IotHubLocationDescription_STATUS(source *storage.IotHubLocationDescription_STATUS) error {

	// Location
	description.Location = genruntime.ClonePointerToString(source.Location)

	// Role
	if source.Role != nil {
		role := *source.Role
		roleTemp := genruntime.ToEnum(role, iotHubLocationDescription_Role_STATUS_Values)
		description.Role = &roleTemp
	} else {
		description.Role = nil
	}

	// No error
	return nil
}

// AssignProperties_To_IotHubLocationDescription_STATUS populates the provided destination IotHubLocationDescription_STATUS from our IotHubLocationDescription_STATUS
func (description *IotHubLocationDescription_STATUS) AssignProperties_To_IotHubLocationDescription_STATUS(destination *storage.IotHubLocationDescription_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Location
	destination.Location = genruntime.ClonePointerToString(description.Location)

	// Role
	if description.Role != nil {
		role := string(*description.Role)
		destination.Role = &role
	} else {
		destination.Role = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type IotHubOperatorSecrets struct {
	// DevicePrimaryKey: indicates where the DevicePrimaryKey secret should be placed. If omitted, the secret will not be
	// retrieved from Azure.
	DevicePrimaryKey *genruntime.SecretDestination `json:"devicePrimaryKey,omitempty"`

	// DeviceSecondaryKey: indicates where the DeviceSecondaryKey secret should be placed. If omitted, the secret will not be
	// retrieved from Azure.
	DeviceSecondaryKey *genruntime.SecretDestination `json:"deviceSecondaryKey,omitempty"`

	// IotHubOwnerPrimaryKey: indicates where the IotHubOwnerPrimaryKey secret should be placed. If omitted, the secret will
	// not be retrieved from Azure.
	IotHubOwnerPrimaryKey *genruntime.SecretDestination `json:"iotHubOwnerPrimaryKey,omitempty"`

	// IotHubOwnerSecondaryKey: indicates where the IotHubOwnerSecondaryKey secret should be placed. If omitted, the secret
	// will not be retrieved from Azure.
	IotHubOwnerSecondaryKey *genruntime.SecretDestination `json:"iotHubOwnerSecondaryKey,omitempty"`

	// RegistryReadPrimaryKey: indicates where the RegistryReadPrimaryKey secret should be placed. If omitted, the secret will
	// not be retrieved from Azure.
	RegistryReadPrimaryKey *genruntime.SecretDestination `json:"registryReadPrimaryKey,omitempty"`

	// RegistryReadSecondaryKey: indicates where the RegistryReadSecondaryKey secret should be placed. If omitted, the secret
	// will not be retrieved from Azure.
	RegistryReadSecondaryKey *genruntime.SecretDestination `json:"registryReadSecondaryKey,omitempty"`

	// RegistryReadWritePrimaryKey: indicates where the RegistryReadWritePrimaryKey secret should be placed. If omitted, the
	// secret will not be retrieved from Azure.
	RegistryReadWritePrimaryKey *genruntime.SecretDestination `json:"registryReadWritePrimaryKey,omitempty"`

	// RegistryReadWriteSecondaryKey: indicates where the RegistryReadWriteSecondaryKey secret should be placed. If omitted,
	// the secret will not be retrieved from Azure.
	RegistryReadWriteSecondaryKey *genruntime.SecretDestination `json:"registryReadWriteSecondaryKey,omitempty"`

	// ServicePrimaryKey: indicates where the ServicePrimaryKey secret should be placed. If omitted, the secret will not be
	// retrieved from Azure.
	ServicePrimaryKey *genruntime.SecretDestination `json:"servicePrimaryKey,omitempty"`

	// ServiceSecondaryKey: indicates where the ServiceSecondaryKey secret should be placed. If omitted, the secret will not be
	// retrieved from Azure.
	ServiceSecondaryKey *genruntime.SecretDestination `json:"serviceSecondaryKey,omitempty"`
}

// AssignProperties_From_IotHubOperatorSecrets populates our IotHubOperatorSecrets from the provided source IotHubOperatorSecrets
func (secrets *IotHubOperatorSecrets) AssignProperties_From_IotHubOperatorSecrets(source *storage.IotHubOperatorSecrets) error {

	// DevicePrimaryKey
	if source.DevicePrimaryKey != nil {
		devicePrimaryKey := source.DevicePrimaryKey.Copy()
		secrets.DevicePrimaryKey = &devicePrimaryKey
	} else {
		secrets.DevicePrimaryKey = nil
	}

	// DeviceSecondaryKey
	if source.DeviceSecondaryKey != nil {
		deviceSecondaryKey := source.DeviceSecondaryKey.Copy()
		secrets.DeviceSecondaryKey = &deviceSecondaryKey
	} else {
		secrets.DeviceSecondaryKey = nil
	}

	// IotHubOwnerPrimaryKey
	if source.IotHubOwnerPrimaryKey != nil {
		iotHubOwnerPrimaryKey := source.IotHubOwnerPrimaryKey.Copy()
		secrets.IotHubOwnerPrimaryKey = &iotHubOwnerPrimaryKey
	} else {
		secrets.IotHubOwnerPrimaryKey = nil
	}

	// IotHubOwnerSecondaryKey
	if source.IotHubOwnerSecondaryKey != nil {
		iotHubOwnerSecondaryKey := source.IotHubOwnerSecondaryKey.Copy()
		secrets.IotHubOwnerSecondaryKey = &iotHubOwnerSecondaryKey
	} else {
		secrets.IotHubOwnerSecondaryKey = nil
	}

	// RegistryReadPrimaryKey
	if source.RegistryReadPrimaryKey != nil {
		registryReadPrimaryKey := source.RegistryReadPrimaryKey.Copy()
		secrets.RegistryReadPrimaryKey = &registryReadPrimaryKey
	} else {
		secrets.RegistryReadPrimaryKey = nil
	}

	// RegistryReadSecondaryKey
	if source.RegistryReadSecondaryKey != nil {
		registryReadSecondaryKey := source.RegistryReadSecondaryKey.Copy()
		secrets.RegistryReadSecondaryKey = &registryReadSecondaryKey
	} else {
		secrets.RegistryReadSecondaryKey = nil
	}

	// RegistryReadWritePrimaryKey
	if source.RegistryReadWritePrimaryKey != nil {
		registryReadWritePrimaryKey := source.RegistryReadWritePrimaryKey.Copy()
		secrets.RegistryReadWritePrimaryKey = &registryReadWritePrimaryKey
	} else {
		secrets.RegistryReadWritePrimaryKey = nil
	}

	// RegistryReadWriteSecondaryKey
	if source.RegistryReadWriteSecondaryKey != nil {
		registryReadWriteSecondaryKey := source.RegistryReadWriteSecondaryKey.Copy()
		secrets.RegistryReadWriteSecondaryKey = &registryReadWriteSecondaryKey
	} else {
		secrets.RegistryReadWriteSecondaryKey = nil
	}

	// ServicePrimaryKey
	if source.ServicePrimaryKey != nil {
		servicePrimaryKey := source.ServicePrimaryKey.Copy()
		secrets.ServicePrimaryKey = &servicePrimaryKey
	} else {
		secrets.ServicePrimaryKey = nil
	}

	// ServiceSecondaryKey
	if source.ServiceSecondaryKey != nil {
		serviceSecondaryKey := source.ServiceSecondaryKey.Copy()
		secrets.ServiceSecondaryKey = &serviceSecondaryKey
	} else {
		secrets.ServiceSecondaryKey = nil
	}

	// No error
	return nil
}

// AssignProperties_To_IotHubOperatorSecrets populates the provided destination IotHubOperatorSecrets from our IotHubOperatorSecrets
func (secrets *IotHubOperatorSecrets) AssignProperties_To_IotHubOperatorSecrets(destination *storage.IotHubOperatorSecrets) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DevicePrimaryKey
	if secrets.DevicePrimaryKey != nil {
		devicePrimaryKey := secrets.DevicePrimaryKey.Copy()
		destination.DevicePrimaryKey = &devicePrimaryKey
	} else {
		destination.DevicePrimaryKey = nil
	}

	// DeviceSecondaryKey
	if secrets.DeviceSecondaryKey != nil {
		deviceSecondaryKey := secrets.DeviceSecondaryKey.Copy()
		destination.DeviceSecondaryKey = &deviceSecondaryKey
	} else {
		destination.DeviceSecondaryKey = nil
	}

	// IotHubOwnerPrimaryKey
	if secrets.IotHubOwnerPrimaryKey != nil {
		iotHubOwnerPrimaryKey := secrets.IotHubOwnerPrimaryKey.Copy()
		destination.IotHubOwnerPrimaryKey = &iotHubOwnerPrimaryKey
	} else {
		destination.IotHubOwnerPrimaryKey = nil
	}

	// IotHubOwnerSecondaryKey
	if secrets.IotHubOwnerSecondaryKey != nil {
		iotHubOwnerSecondaryKey := secrets.IotHubOwnerSecondaryKey.Copy()
		destination.IotHubOwnerSecondaryKey = &iotHubOwnerSecondaryKey
	} else {
		destination.IotHubOwnerSecondaryKey = nil
	}

	// RegistryReadPrimaryKey
	if secrets.RegistryReadPrimaryKey != nil {
		registryReadPrimaryKey := secrets.RegistryReadPrimaryKey.Copy()
		destination.RegistryReadPrimaryKey = &registryReadPrimaryKey
	} else {
		destination.RegistryReadPrimaryKey = nil
	}

	// RegistryReadSecondaryKey
	if secrets.RegistryReadSecondaryKey != nil {
		registryReadSecondaryKey := secrets.RegistryReadSecondaryKey.Copy()
		destination.RegistryReadSecondaryKey = &registryReadSecondaryKey
	} else {
		destination.RegistryReadSecondaryKey = nil
	}

	// RegistryReadWritePrimaryKey
	if secrets.RegistryReadWritePrimaryKey != nil {
		registryReadWritePrimaryKey := secrets.RegistryReadWritePrimaryKey.Copy()
		destination.RegistryReadWritePrimaryKey = &registryReadWritePrimaryKey
	} else {
		destination.RegistryReadWritePrimaryKey = nil
	}

	// RegistryReadWriteSecondaryKey
	if secrets.RegistryReadWriteSecondaryKey != nil {
		registryReadWriteSecondaryKey := secrets.RegistryReadWriteSecondaryKey.Copy()
		destination.RegistryReadWriteSecondaryKey = &registryReadWriteSecondaryKey
	} else {
		destination.RegistryReadWriteSecondaryKey = nil
	}

	// ServicePrimaryKey
	if secrets.ServicePrimaryKey != nil {
		servicePrimaryKey := secrets.ServicePrimaryKey.Copy()
		destination.ServicePrimaryKey = &servicePrimaryKey
	} else {
		destination.ServicePrimaryKey = nil
	}

	// ServiceSecondaryKey
	if secrets.ServiceSecondaryKey != nil {
		serviceSecondaryKey := secrets.ServiceSecondaryKey.Copy()
		destination.ServiceSecondaryKey = &serviceSecondaryKey
	} else {
		destination.ServiceSecondaryKey = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"DeviceManagement","None"}
type IotHubProperties_Features string

const (
	IotHubProperties_Features_DeviceManagement = IotHubProperties_Features("DeviceManagement")
	IotHubProperties_Features_None             = IotHubProperties_Features("None")
)

// Mapping from string to IotHubProperties_Features
var iotHubProperties_Features_Values = map[string]IotHubProperties_Features{
	"devicemanagement": IotHubProperties_Features_DeviceManagement,
	"none":             IotHubProperties_Features_None,
}

type IotHubProperties_Features_STATUS string

const (
	IotHubProperties_Features_STATUS_DeviceManagement = IotHubProperties_Features_STATUS("DeviceManagement")
	IotHubProperties_Features_STATUS_None             = IotHubProperties_Features_STATUS("None")
)

// Mapping from string to IotHubProperties_Features_STATUS
var iotHubProperties_Features_STATUS_Values = map[string]IotHubProperties_Features_STATUS{
	"devicemanagement": IotHubProperties_Features_STATUS_DeviceManagement,
	"none":             IotHubProperties_Features_STATUS_None,
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type IotHubProperties_PublicNetworkAccess string

const (
	IotHubProperties_PublicNetworkAccess_Disabled = IotHubProperties_PublicNetworkAccess("Disabled")
	IotHubProperties_PublicNetworkAccess_Enabled  = IotHubProperties_PublicNetworkAccess("Enabled")
)

// Mapping from string to IotHubProperties_PublicNetworkAccess
var iotHubProperties_PublicNetworkAccess_Values = map[string]IotHubProperties_PublicNetworkAccess{
	"disabled": IotHubProperties_PublicNetworkAccess_Disabled,
	"enabled":  IotHubProperties_PublicNetworkAccess_Enabled,
}

type IotHubProperties_PublicNetworkAccess_STATUS string

const (
	IotHubProperties_PublicNetworkAccess_STATUS_Disabled = IotHubProperties_PublicNetworkAccess_STATUS("Disabled")
	IotHubProperties_PublicNetworkAccess_STATUS_Enabled  = IotHubProperties_PublicNetworkAccess_STATUS("Enabled")
)

// Mapping from string to IotHubProperties_PublicNetworkAccess_STATUS
var iotHubProperties_PublicNetworkAccess_STATUS_Values = map[string]IotHubProperties_PublicNetworkAccess_STATUS{
	"disabled": IotHubProperties_PublicNetworkAccess_STATUS_Disabled,
	"enabled":  IotHubProperties_PublicNetworkAccess_STATUS_Enabled,
}

// +kubebuilder:validation:Enum={"B1","B2","B3","F1","S1","S2","S3"}
type IotHubSkuInfo_Name string

const (
	IotHubSkuInfo_Name_B1 = IotHubSkuInfo_Name("B1")
	IotHubSkuInfo_Name_B2 = IotHubSkuInfo_Name("B2")
	IotHubSkuInfo_Name_B3 = IotHubSkuInfo_Name("B3")
	IotHubSkuInfo_Name_F1 = IotHubSkuInfo_Name("F1")
	IotHubSkuInfo_Name_S1 = IotHubSkuInfo_Name("S1")
	IotHubSkuInfo_Name_S2 = IotHubSkuInfo_Name("S2")
	IotHubSkuInfo_Name_S3 = IotHubSkuInfo_Name("S3")
)

// Mapping from string to IotHubSkuInfo_Name
var iotHubSkuInfo_Name_Values = map[string]IotHubSkuInfo_Name{
	"b1": IotHubSkuInfo_Name_B1,
	"b2": IotHubSkuInfo_Name_B2,
	"b3": IotHubSkuInfo_Name_B3,
	"f1": IotHubSkuInfo_Name_F1,
	"s1": IotHubSkuInfo_Name_S1,
	"s2": IotHubSkuInfo_Name_S2,
	"s3": IotHubSkuInfo_Name_S3,
}

type IotHubSkuInfo_Name_STATUS string

const (
	IotHubSkuInfo_Name_STATUS_B1 = IotHubSkuInfo_Name_STATUS("B1")
	IotHubSkuInfo_Name_STATUS_B2 = IotHubSkuInfo_Name_STATUS("B2")
	IotHubSkuInfo_Name_STATUS_B3 = IotHubSkuInfo_Name_STATUS("B3")
	IotHubSkuInfo_Name_STATUS_F1 = IotHubSkuInfo_Name_STATUS("F1")
	IotHubSkuInfo_Name_STATUS_S1 = IotHubSkuInfo_Name_STATUS("S1")
	IotHubSkuInfo_Name_STATUS_S2 = IotHubSkuInfo_Name_STATUS("S2")
	IotHubSkuInfo_Name_STATUS_S3 = IotHubSkuInfo_Name_STATUS("S3")
)

// Mapping from string to IotHubSkuInfo_Name_STATUS
var iotHubSkuInfo_Name_STATUS_Values = map[string]IotHubSkuInfo_Name_STATUS{
	"b1": IotHubSkuInfo_Name_STATUS_B1,
	"b2": IotHubSkuInfo_Name_STATUS_B2,
	"b3": IotHubSkuInfo_Name_STATUS_B3,
	"f1": IotHubSkuInfo_Name_STATUS_F1,
	"s1": IotHubSkuInfo_Name_STATUS_S1,
	"s2": IotHubSkuInfo_Name_STATUS_S2,
	"s3": IotHubSkuInfo_Name_STATUS_S3,
}

type IotHubSkuInfo_Tier_STATUS string

const (
	IotHubSkuInfo_Tier_STATUS_Basic    = IotHubSkuInfo_Tier_STATUS("Basic")
	IotHubSkuInfo_Tier_STATUS_Free     = IotHubSkuInfo_Tier_STATUS("Free")
	IotHubSkuInfo_Tier_STATUS_Standard = IotHubSkuInfo_Tier_STATUS("Standard")
)

// Mapping from string to IotHubSkuInfo_Tier_STATUS
var iotHubSkuInfo_Tier_STATUS_Values = map[string]IotHubSkuInfo_Tier_STATUS{
	"basic":    IotHubSkuInfo_Tier_STATUS_Basic,
	"free":     IotHubSkuInfo_Tier_STATUS_Free,
	"standard": IotHubSkuInfo_Tier_STATUS_Standard,
}

// The IP filter rules for the IoT hub.
type IpFilterRule struct {
	// +kubebuilder:validation:Required
	// Action: The desired action for requests captured by this rule.
	Action *IpFilterRule_Action `json:"action,omitempty"`

	// +kubebuilder:validation:Required
	// FilterName: The name of the IP filter rule.
	FilterName *string `json:"filterName,omitempty"`

	// +kubebuilder:validation:Required
	// IpMask: A string that contains the IP address range in CIDR notation for the rule.
	IpMask *string `json:"ipMask,omitempty"`
}

var _ genruntime.ARMTransformer = &IpFilterRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *IpFilterRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.IpFilterRule{}

	// Set property "Action":
	if rule.Action != nil {
		var temp string
		temp = string(*rule.Action)
		action := arm.IpFilterRule_Action(temp)
		result.Action = &action
	}

	// Set property "FilterName":
	if rule.FilterName != nil {
		filterName := *rule.FilterName
		result.FilterName = &filterName
	}

	// Set property "IpMask":
	if rule.IpMask != nil {
		ipMask := *rule.IpMask
		result.IpMask = &ipMask
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *IpFilterRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IpFilterRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *IpFilterRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IpFilterRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IpFilterRule, got %T", armInput)
	}

	// Set property "Action":
	if typedInput.Action != nil {
		var temp string
		temp = string(*typedInput.Action)
		action := IpFilterRule_Action(temp)
		rule.Action = &action
	}

	// Set property "FilterName":
	if typedInput.FilterName != nil {
		filterName := *typedInput.FilterName
		rule.FilterName = &filterName
	}

	// Set property "IpMask":
	if typedInput.IpMask != nil {
		ipMask := *typedInput.IpMask
		rule.IpMask = &ipMask
	}

	// No error
	return nil
}

// AssignProperties_From_IpFilterRule populates our IpFilterRule from the provided source IpFilterRule
func (rule *IpFilterRule) AssignProperties_From_IpFilterRule(source *storage.IpFilterRule) error {

	// Action
	if source.Action != nil {
		action := *source.Action
		actionTemp := genruntime.ToEnum(action, ipFilterRule_Action_Values)
		rule.Action = &actionTemp
	} else {
		rule.Action = nil
	}

	// FilterName
	rule.FilterName = genruntime.ClonePointerToString(source.FilterName)

	// IpMask
	rule.IpMask = genruntime.ClonePointerToString(source.IpMask)

	// No error
	return nil
}

// AssignProperties_To_IpFilterRule populates the provided destination IpFilterRule from our IpFilterRule
func (rule *IpFilterRule) AssignProperties_To_IpFilterRule(destination *storage.IpFilterRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	if rule.Action != nil {
		action := string(*rule.Action)
		destination.Action = &action
	} else {
		destination.Action = nil
	}

	// FilterName
	destination.FilterName = genruntime.ClonePointerToString(rule.FilterName)

	// IpMask
	destination.IpMask = genruntime.ClonePointerToString(rule.IpMask)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_IpFilterRule_STATUS populates our IpFilterRule from the provided source IpFilterRule_STATUS
func (rule *IpFilterRule) Initialize_From_IpFilterRule_STATUS(source *IpFilterRule_STATUS) error {

	// Action
	if source.Action != nil {
		action := genruntime.ToEnum(string(*source.Action), ipFilterRule_Action_Values)
		rule.Action = &action
	} else {
		rule.Action = nil
	}

	// FilterName
	rule.FilterName = genruntime.ClonePointerToString(source.FilterName)

	// IpMask
	rule.IpMask = genruntime.ClonePointerToString(source.IpMask)

	// No error
	return nil
}

// The IP filter rules for the IoT hub.
type IpFilterRule_STATUS struct {
	// Action: The desired action for requests captured by this rule.
	Action *IpFilterRule_Action_STATUS `json:"action,omitempty"`

	// FilterName: The name of the IP filter rule.
	FilterName *string `json:"filterName,omitempty"`

	// IpMask: A string that contains the IP address range in CIDR notation for the rule.
	IpMask *string `json:"ipMask,omitempty"`
}

var _ genruntime.FromARMConverter = &IpFilterRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *IpFilterRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IpFilterRule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *IpFilterRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IpFilterRule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IpFilterRule_STATUS, got %T", armInput)
	}

	// Set property "Action":
	if typedInput.Action != nil {
		var temp string
		temp = string(*typedInput.Action)
		action := IpFilterRule_Action_STATUS(temp)
		rule.Action = &action
	}

	// Set property "FilterName":
	if typedInput.FilterName != nil {
		filterName := *typedInput.FilterName
		rule.FilterName = &filterName
	}

	// Set property "IpMask":
	if typedInput.IpMask != nil {
		ipMask := *typedInput.IpMask
		rule.IpMask = &ipMask
	}

	// No error
	return nil
}

// AssignProperties_From_IpFilterRule_STATUS populates our IpFilterRule_STATUS from the provided source IpFilterRule_STATUS
func (rule *IpFilterRule_STATUS) AssignProperties_From_IpFilterRule_STATUS(source *storage.IpFilterRule_STATUS) error {

	// Action
	if source.Action != nil {
		action := *source.Action
		actionTemp := genruntime.ToEnum(action, ipFilterRule_Action_STATUS_Values)
		rule.Action = &actionTemp
	} else {
		rule.Action = nil
	}

	// FilterName
	rule.FilterName = genruntime.ClonePointerToString(source.FilterName)

	// IpMask
	rule.IpMask = genruntime.ClonePointerToString(source.IpMask)

	// No error
	return nil
}

// AssignProperties_To_IpFilterRule_STATUS populates the provided destination IpFilterRule_STATUS from our IpFilterRule_STATUS
func (rule *IpFilterRule_STATUS) AssignProperties_To_IpFilterRule_STATUS(destination *storage.IpFilterRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	if rule.Action != nil {
		action := string(*rule.Action)
		destination.Action = &action
	} else {
		destination.Action = nil
	}

	// FilterName
	destination.FilterName = genruntime.ClonePointerToString(rule.FilterName)

	// IpMask
	destination.IpMask = genruntime.ClonePointerToString(rule.IpMask)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The properties of the messaging endpoints used by this IoT hub.
type MessagingEndpointProperties struct {
	// LockDurationAsIso8601: The lock duration. See: https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-file-upload.
	LockDurationAsIso8601 *string `json:"lockDurationAsIso8601,omitempty"`

	// +kubebuilder:validation:Maximum=100
	// +kubebuilder:validation:Minimum=1
	// MaxDeliveryCount: The number of times the IoT hub attempts to deliver a message. See:
	// https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-file-upload.
	MaxDeliveryCount *int `json:"maxDeliveryCount,omitempty"`

	// TtlAsIso8601: The period of time for which a message is available to consume before it is expired by the IoT hub. See:
	// https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-file-upload.
	TtlAsIso8601 *string `json:"ttlAsIso8601,omitempty"`
}

var _ genruntime.ARMTransformer = &MessagingEndpointProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *MessagingEndpointProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.MessagingEndpointProperties{}

	// Set property "LockDurationAsIso8601":
	if properties.LockDurationAsIso8601 != nil {
		lockDurationAsIso8601 := *properties.LockDurationAsIso8601
		result.LockDurationAsIso8601 = &lockDurationAsIso8601
	}

	// Set property "MaxDeliveryCount":
	if properties.MaxDeliveryCount != nil {
		maxDeliveryCount := *properties.MaxDeliveryCount
		result.MaxDeliveryCount = &maxDeliveryCount
	}

	// Set property "TtlAsIso8601":
	if properties.TtlAsIso8601 != nil {
		ttlAsIso8601 := *properties.TtlAsIso8601
		result.TtlAsIso8601 = &ttlAsIso8601
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *MessagingEndpointProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.MessagingEndpointProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *MessagingEndpointProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.MessagingEndpointProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.MessagingEndpointProperties, got %T", armInput)
	}

	// Set property "LockDurationAsIso8601":
	if typedInput.LockDurationAsIso8601 != nil {
		lockDurationAsIso8601 := *typedInput.LockDurationAsIso8601
		properties.LockDurationAsIso8601 = &lockDurationAsIso8601
	}

	// Set property "MaxDeliveryCount":
	if typedInput.MaxDeliveryCount != nil {
		maxDeliveryCount := *typedInput.MaxDeliveryCount
		properties.MaxDeliveryCount = &maxDeliveryCount
	}

	// Set property "TtlAsIso8601":
	if typedInput.TtlAsIso8601 != nil {
		ttlAsIso8601 := *typedInput.TtlAsIso8601
		properties.TtlAsIso8601 = &ttlAsIso8601
	}

	// No error
	return nil
}

// AssignProperties_From_MessagingEndpointProperties populates our MessagingEndpointProperties from the provided source MessagingEndpointProperties
func (properties *MessagingEndpointProperties) AssignProperties_From_MessagingEndpointProperties(source *storage.MessagingEndpointProperties) error {

	// LockDurationAsIso8601
	properties.LockDurationAsIso8601 = genruntime.ClonePointerToString(source.LockDurationAsIso8601)

	// MaxDeliveryCount
	properties.MaxDeliveryCount = genruntime.ClonePointerToInt(source.MaxDeliveryCount)

	// TtlAsIso8601
	properties.TtlAsIso8601 = genruntime.ClonePointerToString(source.TtlAsIso8601)

	// No error
	return nil
}

// AssignProperties_To_MessagingEndpointProperties populates the provided destination MessagingEndpointProperties from our MessagingEndpointProperties
func (properties *MessagingEndpointProperties) AssignProperties_To_MessagingEndpointProperties(destination *storage.MessagingEndpointProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// LockDurationAsIso8601
	destination.LockDurationAsIso8601 = genruntime.ClonePointerToString(properties.LockDurationAsIso8601)

	// MaxDeliveryCount
	destination.MaxDeliveryCount = genruntime.ClonePointerToInt(properties.MaxDeliveryCount)

	// TtlAsIso8601
	destination.TtlAsIso8601 = genruntime.ClonePointerToString(properties.TtlAsIso8601)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_MessagingEndpointProperties_STATUS populates our MessagingEndpointProperties from the provided source MessagingEndpointProperties_STATUS
func (properties *MessagingEndpointProperties) Initialize_From_MessagingEndpointProperties_STATUS(source *MessagingEndpointProperties_STATUS) error {

	// LockDurationAsIso8601
	properties.LockDurationAsIso8601 = genruntime.ClonePointerToString(source.LockDurationAsIso8601)

	// MaxDeliveryCount
	properties.MaxDeliveryCount = genruntime.ClonePointerToInt(source.MaxDeliveryCount)

	// TtlAsIso8601
	properties.TtlAsIso8601 = genruntime.ClonePointerToString(source.TtlAsIso8601)

	// No error
	return nil
}

// The properties of the messaging endpoints used by this IoT hub.
type MessagingEndpointProperties_STATUS struct {
	// LockDurationAsIso8601: The lock duration. See: https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-file-upload.
	LockDurationAsIso8601 *string `json:"lockDurationAsIso8601,omitempty"`

	// MaxDeliveryCount: The number of times the IoT hub attempts to deliver a message. See:
	// https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-file-upload.
	MaxDeliveryCount *int `json:"maxDeliveryCount,omitempty"`

	// TtlAsIso8601: The period of time for which a message is available to consume before it is expired by the IoT hub. See:
	// https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-file-upload.
	TtlAsIso8601 *string `json:"ttlAsIso8601,omitempty"`
}

var _ genruntime.FromARMConverter = &MessagingEndpointProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *MessagingEndpointProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.MessagingEndpointProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *MessagingEndpointProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.MessagingEndpointProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.MessagingEndpointProperties_STATUS, got %T", armInput)
	}

	// Set property "LockDurationAsIso8601":
	if typedInput.LockDurationAsIso8601 != nil {
		lockDurationAsIso8601 := *typedInput.LockDurationAsIso8601
		properties.LockDurationAsIso8601 = &lockDurationAsIso8601
	}

	// Set property "MaxDeliveryCount":
	if typedInput.MaxDeliveryCount != nil {
		maxDeliveryCount := *typedInput.MaxDeliveryCount
		properties.MaxDeliveryCount = &maxDeliveryCount
	}

	// Set property "TtlAsIso8601":
	if typedInput.TtlAsIso8601 != nil {
		ttlAsIso8601 := *typedInput.TtlAsIso8601
		properties.TtlAsIso8601 = &ttlAsIso8601
	}

	// No error
	return nil
}

// AssignProperties_From_MessagingEndpointProperties_STATUS populates our MessagingEndpointProperties_STATUS from the provided source MessagingEndpointProperties_STATUS
func (properties *MessagingEndpointProperties_STATUS) AssignProperties_From_MessagingEndpointProperties_STATUS(source *storage.MessagingEndpointProperties_STATUS) error {

	// LockDurationAsIso8601
	properties.LockDurationAsIso8601 = genruntime.ClonePointerToString(source.LockDurationAsIso8601)

	// MaxDeliveryCount
	properties.MaxDeliveryCount = genruntime.ClonePointerToInt(source.MaxDeliveryCount)

	// TtlAsIso8601
	properties.TtlAsIso8601 = genruntime.ClonePointerToString(source.TtlAsIso8601)

	// No error
	return nil
}

// AssignProperties_To_MessagingEndpointProperties_STATUS populates the provided destination MessagingEndpointProperties_STATUS from our MessagingEndpointProperties_STATUS
func (properties *MessagingEndpointProperties_STATUS) AssignProperties_To_MessagingEndpointProperties_STATUS(destination *storage.MessagingEndpointProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// LockDurationAsIso8601
	destination.LockDurationAsIso8601 = genruntime.ClonePointerToString(properties.LockDurationAsIso8601)

	// MaxDeliveryCount
	destination.MaxDeliveryCount = genruntime.ClonePointerToInt(properties.MaxDeliveryCount)

	// TtlAsIso8601
	destination.TtlAsIso8601 = genruntime.ClonePointerToString(properties.TtlAsIso8601)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Network Rule Set Properties of IotHub
type NetworkRuleSetProperties struct {
	// +kubebuilder:validation:Required
	// ApplyToBuiltInEventHubEndpoint: If True, then Network Rule Set is also applied to BuiltIn EventHub EndPoint of IotHub
	ApplyToBuiltInEventHubEndpoint *bool `json:"applyToBuiltInEventHubEndpoint,omitempty"`

	// DefaultAction: Default Action for Network Rule Set
	DefaultAction *NetworkRuleSetProperties_DefaultAction `json:"defaultAction,omitempty"`

	// +kubebuilder:validation:Required
	// IpRules: List of IP Rules
	IpRules []NetworkRuleSetIpRule `json:"ipRules,omitempty"`
}

var _ genruntime.ARMTransformer = &NetworkRuleSetProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *NetworkRuleSetProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.NetworkRuleSetProperties{}

	// Set property "ApplyToBuiltInEventHubEndpoint":
	if properties.ApplyToBuiltInEventHubEndpoint != nil {
		applyToBuiltInEventHubEndpoint := *properties.ApplyToBuiltInEventHubEndpoint
		result.ApplyToBuiltInEventHubEndpoint = &applyToBuiltInEventHubEndpoint
	}

	// Set property "DefaultAction":
	if properties.DefaultAction != nil {
		var temp string
		temp = string(*properties.DefaultAction)
		defaultAction := arm.NetworkRuleSetProperties_DefaultAction(temp)
		result.DefaultAction = &defaultAction
	}

	// Set property "IpRules":
	for _, item := range properties.IpRules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.IpRules = append(result.IpRules, *item_ARM.(*arm.NetworkRuleSetIpRule))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *NetworkRuleSetProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NetworkRuleSetProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *NetworkRuleSetProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NetworkRuleSetProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NetworkRuleSetProperties, got %T", armInput)
	}

	// Set property "ApplyToBuiltInEventHubEndpoint":
	if typedInput.ApplyToBuiltInEventHubEndpoint != nil {
		applyToBuiltInEventHubEndpoint := *typedInput.ApplyToBuiltInEventHubEndpoint
		properties.ApplyToBuiltInEventHubEndpoint = &applyToBuiltInEventHubEndpoint
	}

	// Set property "DefaultAction":
	if typedInput.DefaultAction != nil {
		var temp string
		temp = string(*typedInput.DefaultAction)
		defaultAction := NetworkRuleSetProperties_DefaultAction(temp)
		properties.DefaultAction = &defaultAction
	}

	// Set property "IpRules":
	for _, item := range typedInput.IpRules {
		var item1 NetworkRuleSetIpRule
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.IpRules = append(properties.IpRules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_NetworkRuleSetProperties populates our NetworkRuleSetProperties from the provided source NetworkRuleSetProperties
func (properties *NetworkRuleSetProperties) AssignProperties_From_NetworkRuleSetProperties(source *storage.NetworkRuleSetProperties) error {

	// ApplyToBuiltInEventHubEndpoint
	if source.ApplyToBuiltInEventHubEndpoint != nil {
		applyToBuiltInEventHubEndpoint := *source.ApplyToBuiltInEventHubEndpoint
		properties.ApplyToBuiltInEventHubEndpoint = &applyToBuiltInEventHubEndpoint
	} else {
		properties.ApplyToBuiltInEventHubEndpoint = nil
	}

	// DefaultAction
	if source.DefaultAction != nil {
		defaultAction := *source.DefaultAction
		defaultActionTemp := genruntime.ToEnum(defaultAction, networkRuleSetProperties_DefaultAction_Values)
		properties.DefaultAction = &defaultActionTemp
	} else {
		properties.DefaultAction = nil
	}

	// IpRules
	if source.IpRules != nil {
		ipRuleList := make([]NetworkRuleSetIpRule, len(source.IpRules))
		for ipRuleIndex, ipRuleItem := range source.IpRules {
			// Shadow the loop variable to avoid aliasing
			ipRuleItem := ipRuleItem
			var ipRule NetworkRuleSetIpRule
			err := ipRule.AssignProperties_From_NetworkRuleSetIpRule(&ipRuleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_NetworkRuleSetIpRule() to populate field IpRules")
			}
			ipRuleList[ipRuleIndex] = ipRule
		}
		properties.IpRules = ipRuleList
	} else {
		properties.IpRules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_NetworkRuleSetProperties populates the provided destination NetworkRuleSetProperties from our NetworkRuleSetProperties
func (properties *NetworkRuleSetProperties) AssignProperties_To_NetworkRuleSetProperties(destination *storage.NetworkRuleSetProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ApplyToBuiltInEventHubEndpoint
	if properties.ApplyToBuiltInEventHubEndpoint != nil {
		applyToBuiltInEventHubEndpoint := *properties.ApplyToBuiltInEventHubEndpoint
		destination.ApplyToBuiltInEventHubEndpoint = &applyToBuiltInEventHubEndpoint
	} else {
		destination.ApplyToBuiltInEventHubEndpoint = nil
	}

	// DefaultAction
	if properties.DefaultAction != nil {
		defaultAction := string(*properties.DefaultAction)
		destination.DefaultAction = &defaultAction
	} else {
		destination.DefaultAction = nil
	}

	// IpRules
	if properties.IpRules != nil {
		ipRuleList := make([]storage.NetworkRuleSetIpRule, len(properties.IpRules))
		for ipRuleIndex, ipRuleItem := range properties.IpRules {
			// Shadow the loop variable to avoid aliasing
			ipRuleItem := ipRuleItem
			var ipRule storage.NetworkRuleSetIpRule
			err := ipRuleItem.AssignProperties_To_NetworkRuleSetIpRule(&ipRule)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_NetworkRuleSetIpRule() to populate field IpRules")
			}
			ipRuleList[ipRuleIndex] = ipRule
		}
		destination.IpRules = ipRuleList
	} else {
		destination.IpRules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_NetworkRuleSetProperties_STATUS populates our NetworkRuleSetProperties from the provided source NetworkRuleSetProperties_STATUS
func (properties *NetworkRuleSetProperties) Initialize_From_NetworkRuleSetProperties_STATUS(source *NetworkRuleSetProperties_STATUS) error {

	// ApplyToBuiltInEventHubEndpoint
	if source.ApplyToBuiltInEventHubEndpoint != nil {
		applyToBuiltInEventHubEndpoint := *source.ApplyToBuiltInEventHubEndpoint
		properties.ApplyToBuiltInEventHubEndpoint = &applyToBuiltInEventHubEndpoint
	} else {
		properties.ApplyToBuiltInEventHubEndpoint = nil
	}

	// DefaultAction
	if source.DefaultAction != nil {
		defaultAction := genruntime.ToEnum(string(*source.DefaultAction), networkRuleSetProperties_DefaultAction_Values)
		properties.DefaultAction = &defaultAction
	} else {
		properties.DefaultAction = nil
	}

	// IpRules
	if source.IpRules != nil {
		ipRuleList := make([]NetworkRuleSetIpRule, len(source.IpRules))
		for ipRuleIndex, ipRuleItem := range source.IpRules {
			// Shadow the loop variable to avoid aliasing
			ipRuleItem := ipRuleItem
			var ipRule NetworkRuleSetIpRule
			err := ipRule.Initialize_From_NetworkRuleSetIpRule_STATUS(&ipRuleItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_NetworkRuleSetIpRule_STATUS() to populate field IpRules")
			}
			ipRuleList[ipRuleIndex] = ipRule
		}
		properties.IpRules = ipRuleList
	} else {
		properties.IpRules = nil
	}

	// No error
	return nil
}

// Network Rule Set Properties of IotHub
type NetworkRuleSetProperties_STATUS struct {
	// ApplyToBuiltInEventHubEndpoint: If True, then Network Rule Set is also applied to BuiltIn EventHub EndPoint of IotHub
	ApplyToBuiltInEventHubEndpoint *bool `json:"applyToBuiltInEventHubEndpoint,omitempty"`

	// DefaultAction: Default Action for Network Rule Set
	DefaultAction *NetworkRuleSetProperties_DefaultAction_STATUS `json:"defaultAction,omitempty"`

	// IpRules: List of IP Rules
	IpRules []NetworkRuleSetIpRule_STATUS `json:"ipRules,omitempty"`
}

var _ genruntime.FromARMConverter = &NetworkRuleSetProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *NetworkRuleSetProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NetworkRuleSetProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *NetworkRuleSetProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NetworkRuleSetProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NetworkRuleSetProperties_STATUS, got %T", armInput)
	}

	// Set property "ApplyToBuiltInEventHubEndpoint":
	if typedInput.ApplyToBuiltInEventHubEndpoint != nil {
		applyToBuiltInEventHubEndpoint := *typedInput.ApplyToBuiltInEventHubEndpoint
		properties.ApplyToBuiltInEventHubEndpoint = &applyToBuiltInEventHubEndpoint
	}

	// Set property "DefaultAction":
	if typedInput.DefaultAction != nil {
		var temp string
		temp = string(*typedInput.DefaultAction)
		defaultAction := NetworkRuleSetProperties_DefaultAction_STATUS(temp)
		properties.DefaultAction = &defaultAction
	}

	// Set property "IpRules":
	for _, item := range typedInput.IpRules {
		var item1 NetworkRuleSetIpRule_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.IpRules = append(properties.IpRules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_NetworkRuleSetProperties_STATUS populates our NetworkRuleSetProperties_STATUS from the provided source NetworkRuleSetProperties_STATUS
func (properties *NetworkRuleSetProperties_STATUS) AssignProperties_From_NetworkRuleSetProperties_STATUS(source *storage.NetworkRuleSetProperties_STATUS) error {

	// ApplyToBuiltInEventHubEndpoint
	if source.ApplyToBuiltInEventHubEndpoint != nil {
		applyToBuiltInEventHubEndpoint := *source.ApplyToBuiltInEventHubEndpoint
		properties.ApplyToBuiltInEventHubEndpoint = &applyToBuiltInEventHubEndpoint
	} else {
		properties.ApplyToBuiltInEventHubEndpoint = nil
	}

	// DefaultAction
	if source.DefaultAction != nil {
		defaultAction := *source.DefaultAction
		defaultActionTemp := genruntime.ToEnum(defaultAction, networkRuleSetProperties_DefaultAction_STATUS_Values)
		properties.DefaultAction = &defaultActionTemp
	} else {
		properties.DefaultAction = nil
	}

	// IpRules
	if source.IpRules != nil {
		ipRuleList := make([]NetworkRuleSetIpRule_STATUS, len(source.IpRules))
		for ipRuleIndex, ipRuleItem := range source.IpRules {
			// Shadow the loop variable to avoid aliasing
			ipRuleItem := ipRuleItem
			var ipRule NetworkRuleSetIpRule_STATUS
			err := ipRule.AssignProperties_From_NetworkRuleSetIpRule_STATUS(&ipRuleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_NetworkRuleSetIpRule_STATUS() to populate field IpRules")
			}
			ipRuleList[ipRuleIndex] = ipRule
		}
		properties.IpRules = ipRuleList
	} else {
		properties.IpRules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_NetworkRuleSetProperties_STATUS populates the provided destination NetworkRuleSetProperties_STATUS from our NetworkRuleSetProperties_STATUS
func (properties *NetworkRuleSetProperties_STATUS) AssignProperties_To_NetworkRuleSetProperties_STATUS(destination *storage.NetworkRuleSetProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ApplyToBuiltInEventHubEndpoint
	if properties.ApplyToBuiltInEventHubEndpoint != nil {
		applyToBuiltInEventHubEndpoint := *properties.ApplyToBuiltInEventHubEndpoint
		destination.ApplyToBuiltInEventHubEndpoint = &applyToBuiltInEventHubEndpoint
	} else {
		destination.ApplyToBuiltInEventHubEndpoint = nil
	}

	// DefaultAction
	if properties.DefaultAction != nil {
		defaultAction := string(*properties.DefaultAction)
		destination.DefaultAction = &defaultAction
	} else {
		destination.DefaultAction = nil
	}

	// IpRules
	if properties.IpRules != nil {
		ipRuleList := make([]storage.NetworkRuleSetIpRule_STATUS, len(properties.IpRules))
		for ipRuleIndex, ipRuleItem := range properties.IpRules {
			// Shadow the loop variable to avoid aliasing
			ipRuleItem := ipRuleItem
			var ipRule storage.NetworkRuleSetIpRule_STATUS
			err := ipRuleItem.AssignProperties_To_NetworkRuleSetIpRule_STATUS(&ipRule)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_NetworkRuleSetIpRule_STATUS() to populate field IpRules")
			}
			ipRuleList[ipRuleIndex] = ipRule
		}
		destination.IpRules = ipRuleList
	} else {
		destination.IpRules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The private endpoint connection of an IotHub
type PrivateEndpointConnection_STATUS struct {
	// Id: The resource identifier.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &PrivateEndpointConnection_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (connection *PrivateEndpointConnection_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PrivateEndpointConnection_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (connection *PrivateEndpointConnection_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PrivateEndpointConnection_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PrivateEndpointConnection_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		connection.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_PrivateEndpointConnection_STATUS populates our PrivateEndpointConnection_STATUS from the provided source PrivateEndpointConnection_STATUS
func (connection *PrivateEndpointConnection_STATUS) AssignProperties_From_PrivateEndpointConnection_STATUS(source *storage.PrivateEndpointConnection_STATUS) error {

	// Id
	connection.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_PrivateEndpointConnection_STATUS populates the provided destination PrivateEndpointConnection_STATUS from our PrivateEndpointConnection_STATUS
func (connection *PrivateEndpointConnection_STATUS) AssignProperties_To_PrivateEndpointConnection_STATUS(destination *storage.PrivateEndpointConnection_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(connection.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The routing related properties of the IoT hub. See: https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-messaging
type RoutingProperties struct {
	// Endpoints: The properties related to the custom endpoints to which your IoT hub routes messages based on the routing
	// rules. A  maximum of 10 custom endpoints are allowed across all endpoint types for paid hubs and only 1 custom endpoint
	// is allowed  across all endpoint types for free hubs.
	Endpoints *RoutingEndpoints `json:"endpoints,omitempty"`

	// Enrichments: The list of user-provided enrichments that the IoT hub applies to messages to be delivered to built-in and
	// custom endpoints. See: https://aka.ms/telemetryoneventgrid
	Enrichments []EnrichmentProperties `json:"enrichments,omitempty"`

	// FallbackRoute: The properties of the route that is used as a fall-back route when none of the conditions specified in
	// the 'routes' section are met. This is an optional parameter. When this property is not present in the template, the
	// fallback route is disabled by default.
	FallbackRoute *FallbackRouteProperties `json:"fallbackRoute,omitempty"`

	// Routes: The list of user-provided routing rules that the IoT hub uses to route messages to built-in and custom
	// endpoints. A maximum of 100 routing rules are allowed for paid hubs and a maximum of 5 routing rules are allowed for
	// free hubs.
	Routes []RouteProperties `json:"routes,omitempty"`
}

var _ genruntime.ARMTransformer = &RoutingProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *RoutingProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.RoutingProperties{}

	// Set property "Endpoints":
	if properties.Endpoints != nil {
		endpoints_ARM, err := (*properties.Endpoints).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		endpoints := *endpoints_ARM.(*arm.RoutingEndpoints)
		result.Endpoints = &endpoints
	}

	// Set property "Enrichments":
	for _, item := range properties.Enrichments {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Enrichments = append(result.Enrichments, *item_ARM.(*arm.EnrichmentProperties))
	}

	// Set property "FallbackRoute":
	if properties.FallbackRoute != nil {
		fallbackRoute_ARM, err := (*properties.FallbackRoute).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		fallbackRoute := *fallbackRoute_ARM.(*arm.FallbackRouteProperties)
		result.FallbackRoute = &fallbackRoute
	}

	// Set property "Routes":
	for _, item := range properties.Routes {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Routes = append(result.Routes, *item_ARM.(*arm.RouteProperties))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *RoutingProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RoutingProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *RoutingProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RoutingProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RoutingProperties, got %T", armInput)
	}

	// Set property "Endpoints":
	if typedInput.Endpoints != nil {
		var endpoints1 RoutingEndpoints
		err := endpoints1.PopulateFromARM(owner, *typedInput.Endpoints)
		if err != nil {
			return err
		}
		endpoints := endpoints1
		properties.Endpoints = &endpoints
	}

	// Set property "Enrichments":
	for _, item := range typedInput.Enrichments {
		var item1 EnrichmentProperties
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.Enrichments = append(properties.Enrichments, item1)
	}

	// Set property "FallbackRoute":
	if typedInput.FallbackRoute != nil {
		var fallbackRoute1 FallbackRouteProperties
		err := fallbackRoute1.PopulateFromARM(owner, *typedInput.FallbackRoute)
		if err != nil {
			return err
		}
		fallbackRoute := fallbackRoute1
		properties.FallbackRoute = &fallbackRoute
	}

	// Set property "Routes":
	for _, item := range typedInput.Routes {
		var item1 RouteProperties
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.Routes = append(properties.Routes, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_RoutingProperties populates our RoutingProperties from the provided source RoutingProperties
func (properties *RoutingProperties) AssignProperties_From_RoutingProperties(source *storage.RoutingProperties) error {

	// Endpoints
	if source.Endpoints != nil {
		var endpoint RoutingEndpoints
		err := endpoint.AssignProperties_From_RoutingEndpoints(source.Endpoints)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_RoutingEndpoints() to populate field Endpoints")
		}
		properties.Endpoints = &endpoint
	} else {
		properties.Endpoints = nil
	}

	// Enrichments
	if source.Enrichments != nil {
		enrichmentList := make([]EnrichmentProperties, len(source.Enrichments))
		for enrichmentIndex, enrichmentItem := range source.Enrichments {
			// Shadow the loop variable to avoid aliasing
			enrichmentItem := enrichmentItem
			var enrichment EnrichmentProperties
			err := enrichment.AssignProperties_From_EnrichmentProperties(&enrichmentItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_EnrichmentProperties() to populate field Enrichments")
			}
			enrichmentList[enrichmentIndex] = enrichment
		}
		properties.Enrichments = enrichmentList
	} else {
		properties.Enrichments = nil
	}

	// FallbackRoute
	if source.FallbackRoute != nil {
		var fallbackRoute FallbackRouteProperties
		err := fallbackRoute.AssignProperties_From_FallbackRouteProperties(source.FallbackRoute)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_FallbackRouteProperties() to populate field FallbackRoute")
		}
		properties.FallbackRoute = &fallbackRoute
	} else {
		properties.FallbackRoute = nil
	}

	// Routes
	if source.Routes != nil {
		routeList := make([]RouteProperties, len(source.Routes))
		for routeIndex, routeItem := range source.Routes {
			// Shadow the loop variable to avoid aliasing
			routeItem := routeItem
			var route RouteProperties
			err := route.AssignProperties_From_RouteProperties(&routeItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_RouteProperties() to populate field Routes")
			}
			routeList[routeIndex] = route
		}
		properties.Routes = routeList
	} else {
		properties.Routes = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RoutingProperties populates the provided destination RoutingProperties from our RoutingProperties
func (properties *RoutingProperties) AssignProperties_To_RoutingProperties(destination *storage.RoutingProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Endpoints
	if properties.Endpoints != nil {
		var endpoint storage.RoutingEndpoints
		err := properties.Endpoints.AssignProperties_To_RoutingEndpoints(&endpoint)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_RoutingEndpoints() to populate field Endpoints")
		}
		destination.Endpoints = &endpoint
	} else {
		destination.Endpoints = nil
	}

	// Enrichments
	if properties.Enrichments != nil {
		enrichmentList := make([]storage.EnrichmentProperties, len(properties.Enrichments))
		for enrichmentIndex, enrichmentItem := range properties.Enrichments {
			// Shadow the loop variable to avoid aliasing
			enrichmentItem := enrichmentItem
			var enrichment storage.EnrichmentProperties
			err := enrichmentItem.AssignProperties_To_EnrichmentProperties(&enrichment)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_EnrichmentProperties() to populate field Enrichments")
			}
			enrichmentList[enrichmentIndex] = enrichment
		}
		destination.Enrichments = enrichmentList
	} else {
		destination.Enrichments = nil
	}

	// FallbackRoute
	if properties.FallbackRoute != nil {
		var fallbackRoute storage.FallbackRouteProperties
		err := properties.FallbackRoute.AssignProperties_To_FallbackRouteProperties(&fallbackRoute)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_FallbackRouteProperties() to populate field FallbackRoute")
		}
		destination.FallbackRoute = &fallbackRoute
	} else {
		destination.FallbackRoute = nil
	}

	// Routes
	if properties.Routes != nil {
		routeList := make([]storage.RouteProperties, len(properties.Routes))
		for routeIndex, routeItem := range properties.Routes {
			// Shadow the loop variable to avoid aliasing
			routeItem := routeItem
			var route storage.RouteProperties
			err := routeItem.AssignProperties_To_RouteProperties(&route)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_RouteProperties() to populate field Routes")
			}
			routeList[routeIndex] = route
		}
		destination.Routes = routeList
	} else {
		destination.Routes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RoutingProperties_STATUS populates our RoutingProperties from the provided source RoutingProperties_STATUS
func (properties *RoutingProperties) Initialize_From_RoutingProperties_STATUS(source *RoutingProperties_STATUS) error {

	// Endpoints
	if source.Endpoints != nil {
		var endpoint RoutingEndpoints
		err := endpoint.Initialize_From_RoutingEndpoints_STATUS(source.Endpoints)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_RoutingEndpoints_STATUS() to populate field Endpoints")
		}
		properties.Endpoints = &endpoint
	} else {
		properties.Endpoints = nil
	}

	// Enrichments
	if source.Enrichments != nil {
		enrichmentList := make([]EnrichmentProperties, len(source.Enrichments))
		for enrichmentIndex, enrichmentItem := range source.Enrichments {
			// Shadow the loop variable to avoid aliasing
			enrichmentItem := enrichmentItem
			var enrichment EnrichmentProperties
			err := enrichment.Initialize_From_EnrichmentProperties_STATUS(&enrichmentItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_EnrichmentProperties_STATUS() to populate field Enrichments")
			}
			enrichmentList[enrichmentIndex] = enrichment
		}
		properties.Enrichments = enrichmentList
	} else {
		properties.Enrichments = nil
	}

	// FallbackRoute
	if source.FallbackRoute != nil {
		var fallbackRoute FallbackRouteProperties
		err := fallbackRoute.Initialize_From_FallbackRouteProperties_STATUS(source.FallbackRoute)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_FallbackRouteProperties_STATUS() to populate field FallbackRoute")
		}
		properties.FallbackRoute = &fallbackRoute
	} else {
		properties.FallbackRoute = nil
	}

	// Routes
	if source.Routes != nil {
		routeList := make([]RouteProperties, len(source.Routes))
		for routeIndex, routeItem := range source.Routes {
			// Shadow the loop variable to avoid aliasing
			routeItem := routeItem
			var route RouteProperties
			err := route.Initialize_From_RouteProperties_STATUS(&routeItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_RouteProperties_STATUS() to populate field Routes")
			}
			routeList[routeIndex] = route
		}
		properties.Routes = routeList
	} else {
		properties.Routes = nil
	}

	// No error
	return nil
}

// The routing related properties of the IoT hub. See: https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-messaging
type RoutingProperties_STATUS struct {
	// Endpoints: The properties related to the custom endpoints to which your IoT hub routes messages based on the routing
	// rules. A  maximum of 10 custom endpoints are allowed across all endpoint types for paid hubs and only 1 custom endpoint
	// is allowed  across all endpoint types for free hubs.
	Endpoints *RoutingEndpoints_STATUS `json:"endpoints,omitempty"`

	// Enrichments: The list of user-provided enrichments that the IoT hub applies to messages to be delivered to built-in and
	// custom endpoints. See: https://aka.ms/telemetryoneventgrid
	Enrichments []EnrichmentProperties_STATUS `json:"enrichments,omitempty"`

	// FallbackRoute: The properties of the route that is used as a fall-back route when none of the conditions specified in
	// the 'routes' section are met. This is an optional parameter. When this property is not present in the template, the
	// fallback route is disabled by default.
	FallbackRoute *FallbackRouteProperties_STATUS `json:"fallbackRoute,omitempty"`

	// Routes: The list of user-provided routing rules that the IoT hub uses to route messages to built-in and custom
	// endpoints. A maximum of 100 routing rules are allowed for paid hubs and a maximum of 5 routing rules are allowed for
	// free hubs.
	Routes []RouteProperties_STATUS `json:"routes,omitempty"`
}

var _ genruntime.FromARMConverter = &RoutingProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *RoutingProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RoutingProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *RoutingProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RoutingProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RoutingProperties_STATUS, got %T", armInput)
	}

	// Set property "Endpoints":
	if typedInput.Endpoints != nil {
		var endpoints1 RoutingEndpoints_STATUS
		err := endpoints1.PopulateFromARM(owner, *typedInput.Endpoints)
		if err != nil {
			return err
		}
		endpoints := endpoints1
		properties.Endpoints = &endpoints
	}

	// Set property "Enrichments":
	for _, item := range typedInput.Enrichments {
		var item1 EnrichmentProperties_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.Enrichments = append(properties.Enrichments, item1)
	}

	// Set property "FallbackRoute":
	if typedInput.FallbackRoute != nil {
		var fallbackRoute1 FallbackRouteProperties_STATUS
		err := fallbackRoute1.PopulateFromARM(owner, *typedInput.FallbackRoute)
		if err != nil {
			return err
		}
		fallbackRoute := fallbackRoute1
		properties.FallbackRoute = &fallbackRoute
	}

	// Set property "Routes":
	for _, item := range typedInput.Routes {
		var item1 RouteProperties_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.Routes = append(properties.Routes, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_RoutingProperties_STATUS populates our RoutingProperties_STATUS from the provided source RoutingProperties_STATUS
func (properties *RoutingProperties_STATUS) AssignProperties_From_RoutingProperties_STATUS(source *storage.RoutingProperties_STATUS) error {

	// Endpoints
	if source.Endpoints != nil {
		var endpoint RoutingEndpoints_STATUS
		err := endpoint.AssignProperties_From_RoutingEndpoints_STATUS(source.Endpoints)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_RoutingEndpoints_STATUS() to populate field Endpoints")
		}
		properties.Endpoints = &endpoint
	} else {
		properties.Endpoints = nil
	}

	// Enrichments
	if source.Enrichments != nil {
		enrichmentList := make([]EnrichmentProperties_STATUS, len(source.Enrichments))
		for enrichmentIndex, enrichmentItem := range source.Enrichments {
			// Shadow the loop variable to avoid aliasing
			enrichmentItem := enrichmentItem
			var enrichment EnrichmentProperties_STATUS
			err := enrichment.AssignProperties_From_EnrichmentProperties_STATUS(&enrichmentItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_EnrichmentProperties_STATUS() to populate field Enrichments")
			}
			enrichmentList[enrichmentIndex] = enrichment
		}
		properties.Enrichments = enrichmentList
	} else {
		properties.Enrichments = nil
	}

	// FallbackRoute
	if source.FallbackRoute != nil {
		var fallbackRoute FallbackRouteProperties_STATUS
		err := fallbackRoute.AssignProperties_From_FallbackRouteProperties_STATUS(source.FallbackRoute)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_FallbackRouteProperties_STATUS() to populate field FallbackRoute")
		}
		properties.FallbackRoute = &fallbackRoute
	} else {
		properties.FallbackRoute = nil
	}

	// Routes
	if source.Routes != nil {
		routeList := make([]RouteProperties_STATUS, len(source.Routes))
		for routeIndex, routeItem := range source.Routes {
			// Shadow the loop variable to avoid aliasing
			routeItem := routeItem
			var route RouteProperties_STATUS
			err := route.AssignProperties_From_RouteProperties_STATUS(&routeItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_RouteProperties_STATUS() to populate field Routes")
			}
			routeList[routeIndex] = route
		}
		properties.Routes = routeList
	} else {
		properties.Routes = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RoutingProperties_STATUS populates the provided destination RoutingProperties_STATUS from our RoutingProperties_STATUS
func (properties *RoutingProperties_STATUS) AssignProperties_To_RoutingProperties_STATUS(destination *storage.RoutingProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Endpoints
	if properties.Endpoints != nil {
		var endpoint storage.RoutingEndpoints_STATUS
		err := properties.Endpoints.AssignProperties_To_RoutingEndpoints_STATUS(&endpoint)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_RoutingEndpoints_STATUS() to populate field Endpoints")
		}
		destination.Endpoints = &endpoint
	} else {
		destination.Endpoints = nil
	}

	// Enrichments
	if properties.Enrichments != nil {
		enrichmentList := make([]storage.EnrichmentProperties_STATUS, len(properties.Enrichments))
		for enrichmentIndex, enrichmentItem := range properties.Enrichments {
			// Shadow the loop variable to avoid aliasing
			enrichmentItem := enrichmentItem
			var enrichment storage.EnrichmentProperties_STATUS
			err := enrichmentItem.AssignProperties_To_EnrichmentProperties_STATUS(&enrichment)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_EnrichmentProperties_STATUS() to populate field Enrichments")
			}
			enrichmentList[enrichmentIndex] = enrichment
		}
		destination.Enrichments = enrichmentList
	} else {
		destination.Enrichments = nil
	}

	// FallbackRoute
	if properties.FallbackRoute != nil {
		var fallbackRoute storage.FallbackRouteProperties_STATUS
		err := properties.FallbackRoute.AssignProperties_To_FallbackRouteProperties_STATUS(&fallbackRoute)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_FallbackRouteProperties_STATUS() to populate field FallbackRoute")
		}
		destination.FallbackRoute = &fallbackRoute
	} else {
		destination.FallbackRoute = nil
	}

	// Routes
	if properties.Routes != nil {
		routeList := make([]storage.RouteProperties_STATUS, len(properties.Routes))
		for routeIndex, routeItem := range properties.Routes {
			// Shadow the loop variable to avoid aliasing
			routeItem := routeItem
			var route storage.RouteProperties_STATUS
			err := routeItem.AssignProperties_To_RouteProperties_STATUS(&route)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_RouteProperties_STATUS() to populate field Routes")
			}
			routeList[routeIndex] = route
		}
		destination.Routes = routeList
	} else {
		destination.Routes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The properties of an IoT hub shared access policy.
type SharedAccessSignatureAuthorizationRule struct {
	// +kubebuilder:validation:Required
	// KeyName: The name of the shared access policy.
	KeyName *string `json:"keyName,omitempty"`

	// +kubebuilder:validation:Required
	// Rights: The permissions assigned to the shared access policy.
	Rights *SharedAccessSignatureAuthorizationRule_Rights `json:"rights,omitempty"`
}

var _ genruntime.ARMTransformer = &SharedAccessSignatureAuthorizationRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *SharedAccessSignatureAuthorizationRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.SharedAccessSignatureAuthorizationRule{}

	// Set property "KeyName":
	if rule.KeyName != nil {
		keyName := *rule.KeyName
		result.KeyName = &keyName
	}

	// Set property "Rights":
	if rule.Rights != nil {
		var temp string
		temp = string(*rule.Rights)
		rights := arm.SharedAccessSignatureAuthorizationRule_Rights(temp)
		result.Rights = &rights
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *SharedAccessSignatureAuthorizationRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SharedAccessSignatureAuthorizationRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *SharedAccessSignatureAuthorizationRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SharedAccessSignatureAuthorizationRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SharedAccessSignatureAuthorizationRule, got %T", armInput)
	}

	// Set property "KeyName":
	if typedInput.KeyName != nil {
		keyName := *typedInput.KeyName
		rule.KeyName = &keyName
	}

	// Set property "Rights":
	if typedInput.Rights != nil {
		var temp string
		temp = string(*typedInput.Rights)
		rights := SharedAccessSignatureAuthorizationRule_Rights(temp)
		rule.Rights = &rights
	}

	// No error
	return nil
}

// AssignProperties_From_SharedAccessSignatureAuthorizationRule populates our SharedAccessSignatureAuthorizationRule from the provided source SharedAccessSignatureAuthorizationRule
func (rule *SharedAccessSignatureAuthorizationRule) AssignProperties_From_SharedAccessSignatureAuthorizationRule(source *storage.SharedAccessSignatureAuthorizationRule) error {

	// KeyName
	rule.KeyName = genruntime.ClonePointerToString(source.KeyName)

	// Rights
	if source.Rights != nil {
		right := *source.Rights
		rightTemp := genruntime.ToEnum(right, sharedAccessSignatureAuthorizationRule_Rights_Values)
		rule.Rights = &rightTemp
	} else {
		rule.Rights = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SharedAccessSignatureAuthorizationRule populates the provided destination SharedAccessSignatureAuthorizationRule from our SharedAccessSignatureAuthorizationRule
func (rule *SharedAccessSignatureAuthorizationRule) AssignProperties_To_SharedAccessSignatureAuthorizationRule(destination *storage.SharedAccessSignatureAuthorizationRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyName
	destination.KeyName = genruntime.ClonePointerToString(rule.KeyName)

	// Rights
	if rule.Rights != nil {
		right := string(*rule.Rights)
		destination.Rights = &right
	} else {
		destination.Rights = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_SharedAccessSignatureAuthorizationRule_STATUS populates our SharedAccessSignatureAuthorizationRule from the provided source SharedAccessSignatureAuthorizationRule_STATUS
func (rule *SharedAccessSignatureAuthorizationRule) Initialize_From_SharedAccessSignatureAuthorizationRule_STATUS(source *SharedAccessSignatureAuthorizationRule_STATUS) error {

	// KeyName
	rule.KeyName = genruntime.ClonePointerToString(source.KeyName)

	// Rights
	if source.Rights != nil {
		right := genruntime.ToEnum(string(*source.Rights), sharedAccessSignatureAuthorizationRule_Rights_Values)
		rule.Rights = &right
	} else {
		rule.Rights = nil
	}

	// No error
	return nil
}

// The properties of an IoT hub shared access policy.
type SharedAccessSignatureAuthorizationRule_STATUS struct {
	// KeyName: The name of the shared access policy.
	KeyName *string `json:"keyName,omitempty"`

	// Rights: The permissions assigned to the shared access policy.
	Rights *SharedAccessSignatureAuthorizationRule_Rights_STATUS `json:"rights,omitempty"`
}

var _ genruntime.FromARMConverter = &SharedAccessSignatureAuthorizationRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *SharedAccessSignatureAuthorizationRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SharedAccessSignatureAuthorizationRule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *SharedAccessSignatureAuthorizationRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SharedAccessSignatureAuthorizationRule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SharedAccessSignatureAuthorizationRule_STATUS, got %T", armInput)
	}

	// Set property "KeyName":
	if typedInput.KeyName != nil {
		keyName := *typedInput.KeyName
		rule.KeyName = &keyName
	}

	// Set property "Rights":
	if typedInput.Rights != nil {
		var temp string
		temp = string(*typedInput.Rights)
		rights := SharedAccessSignatureAuthorizationRule_Rights_STATUS(temp)
		rule.Rights = &rights
	}

	// No error
	return nil
}

// AssignProperties_From_SharedAccessSignatureAuthorizationRule_STATUS populates our SharedAccessSignatureAuthorizationRule_STATUS from the provided source SharedAccessSignatureAuthorizationRule_STATUS
func (rule *SharedAccessSignatureAuthorizationRule_STATUS) AssignProperties_From_SharedAccessSignatureAuthorizationRule_STATUS(source *storage.SharedAccessSignatureAuthorizationRule_STATUS) error {

	// KeyName
	rule.KeyName = genruntime.ClonePointerToString(source.KeyName)

	// Rights
	if source.Rights != nil {
		right := *source.Rights
		rightTemp := genruntime.ToEnum(right, sharedAccessSignatureAuthorizationRule_Rights_STATUS_Values)
		rule.Rights = &rightTemp
	} else {
		rule.Rights = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SharedAccessSignatureAuthorizationRule_STATUS populates the provided destination SharedAccessSignatureAuthorizationRule_STATUS from our SharedAccessSignatureAuthorizationRule_STATUS
func (rule *SharedAccessSignatureAuthorizationRule_STATUS) AssignProperties_To_SharedAccessSignatureAuthorizationRule_STATUS(destination *storage.SharedAccessSignatureAuthorizationRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyName
	destination.KeyName = genruntime.ClonePointerToString(rule.KeyName)

	// Rights
	if rule.Rights != nil {
		right := string(*rule.Rights)
		destination.Rights = &right
	} else {
		destination.Rights = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The properties of the Azure Storage endpoint for file upload.
type StorageEndpointProperties struct {
	// AuthenticationType: Specifies authentication type being used for connecting to the storage account.
	AuthenticationType *StorageEndpointProperties_AuthenticationType `json:"authenticationType,omitempty"`

	// +kubebuilder:validation:Required
	// ConnectionString: The connection string for the Azure Storage account to which files are uploaded.
	ConnectionString *genruntime.SecretReference `json:"connectionString,omitempty"`

	// +kubebuilder:validation:Required
	// ContainerName: The name of the root container where you upload files. The container need not exist but should be
	// creatable using the connectionString specified.
	ContainerName *string `json:"containerName,omitempty"`

	// Identity: Managed identity properties of storage endpoint for file upload.
	Identity *ManagedIdentity `json:"identity,omitempty"`

	// SasTtlAsIso8601: The period of time for which the SAS URI generated by IoT Hub for file upload is valid. See:
	// https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-file-upload#file-upload-notification-configuration-options.
	SasTtlAsIso8601 *string `json:"sasTtlAsIso8601,omitempty"`
}

var _ genruntime.ARMTransformer = &StorageEndpointProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *StorageEndpointProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.StorageEndpointProperties{}

	// Set property "AuthenticationType":
	if properties.AuthenticationType != nil {
		var temp string
		temp = string(*properties.AuthenticationType)
		authenticationType := arm.StorageEndpointProperties_AuthenticationType(temp)
		result.AuthenticationType = &authenticationType
	}

	// Set property "ConnectionString":
	if properties.ConnectionString != nil {
		connectionStringSecret, err := resolved.ResolvedSecrets.Lookup(*properties.ConnectionString)
		if err != nil {
			return nil, eris.Wrap(err, "looking up secret for property ConnectionString")
		}
		connectionString := connectionStringSecret
		result.ConnectionString = &connectionString
	}

	// Set property "ContainerName":
	if properties.ContainerName != nil {
		containerName := *properties.ContainerName
		result.ContainerName = &containerName
	}

	// Set property "Identity":
	if properties.Identity != nil {
		identity_ARM, err := (*properties.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*arm.ManagedIdentity)
		result.Identity = &identity
	}

	// Set property "SasTtlAsIso8601":
	if properties.SasTtlAsIso8601 != nil {
		sasTtlAsIso8601 := *properties.SasTtlAsIso8601
		result.SasTtlAsIso8601 = &sasTtlAsIso8601
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *StorageEndpointProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.StorageEndpointProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *StorageEndpointProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.StorageEndpointProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.StorageEndpointProperties, got %T", armInput)
	}

	// Set property "AuthenticationType":
	if typedInput.AuthenticationType != nil {
		var temp string
		temp = string(*typedInput.AuthenticationType)
		authenticationType := StorageEndpointProperties_AuthenticationType(temp)
		properties.AuthenticationType = &authenticationType
	}

	// no assignment for property "ConnectionString"

	// Set property "ContainerName":
	if typedInput.ContainerName != nil {
		containerName := *typedInput.ContainerName
		properties.ContainerName = &containerName
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		properties.Identity = &identity
	}

	// Set property "SasTtlAsIso8601":
	if typedInput.SasTtlAsIso8601 != nil {
		sasTtlAsIso8601 := *typedInput.SasTtlAsIso8601
		properties.SasTtlAsIso8601 = &sasTtlAsIso8601
	}

	// No error
	return nil
}

// AssignProperties_From_StorageEndpointProperties populates our StorageEndpointProperties from the provided source StorageEndpointProperties
func (properties *StorageEndpointProperties) AssignProperties_From_StorageEndpointProperties(source *storage.StorageEndpointProperties) error {

	// AuthenticationType
	if source.AuthenticationType != nil {
		authenticationType := *source.AuthenticationType
		authenticationTypeTemp := genruntime.ToEnum(authenticationType, storageEndpointProperties_AuthenticationType_Values)
		properties.AuthenticationType = &authenticationTypeTemp
	} else {
		properties.AuthenticationType = nil
	}

	// ConnectionString
	if source.ConnectionString != nil {
		connectionString := source.ConnectionString.Copy()
		properties.ConnectionString = &connectionString
	} else {
		properties.ConnectionString = nil
	}

	// ContainerName
	properties.ContainerName = genruntime.ClonePointerToString(source.ContainerName)

	// Identity
	if source.Identity != nil {
		var identity ManagedIdentity
		err := identity.AssignProperties_From_ManagedIdentity(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedIdentity() to populate field Identity")
		}
		properties.Identity = &identity
	} else {
		properties.Identity = nil
	}

	// SasTtlAsIso8601
	properties.SasTtlAsIso8601 = genruntime.ClonePointerToString(source.SasTtlAsIso8601)

	// No error
	return nil
}

// AssignProperties_To_StorageEndpointProperties populates the provided destination StorageEndpointProperties from our StorageEndpointProperties
func (properties *StorageEndpointProperties) AssignProperties_To_StorageEndpointProperties(destination *storage.StorageEndpointProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthenticationType
	if properties.AuthenticationType != nil {
		authenticationType := string(*properties.AuthenticationType)
		destination.AuthenticationType = &authenticationType
	} else {
		destination.AuthenticationType = nil
	}

	// ConnectionString
	if properties.ConnectionString != nil {
		connectionString := properties.ConnectionString.Copy()
		destination.ConnectionString = &connectionString
	} else {
		destination.ConnectionString = nil
	}

	// ContainerName
	destination.ContainerName = genruntime.ClonePointerToString(properties.ContainerName)

	// Identity
	if properties.Identity != nil {
		var identity storage.ManagedIdentity
		err := properties.Identity.AssignProperties_To_ManagedIdentity(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// SasTtlAsIso8601
	destination.SasTtlAsIso8601 = genruntime.ClonePointerToString(properties.SasTtlAsIso8601)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_StorageEndpointProperties_STATUS populates our StorageEndpointProperties from the provided source StorageEndpointProperties_STATUS
func (properties *StorageEndpointProperties) Initialize_From_StorageEndpointProperties_STATUS(source *StorageEndpointProperties_STATUS) error {

	// AuthenticationType
	if source.AuthenticationType != nil {
		authenticationType := genruntime.ToEnum(string(*source.AuthenticationType), storageEndpointProperties_AuthenticationType_Values)
		properties.AuthenticationType = &authenticationType
	} else {
		properties.AuthenticationType = nil
	}

	// ContainerName
	properties.ContainerName = genruntime.ClonePointerToString(source.ContainerName)

	// Identity
	if source.Identity != nil {
		var identity ManagedIdentity
		err := identity.Initialize_From_ManagedIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ManagedIdentity_STATUS() to populate field Identity")
		}
		properties.Identity = &identity
	} else {
		properties.Identity = nil
	}

	// SasTtlAsIso8601
	properties.SasTtlAsIso8601 = genruntime.ClonePointerToString(source.SasTtlAsIso8601)

	// No error
	return nil
}

// The properties of the Azure Storage endpoint for file upload.
type StorageEndpointProperties_STATUS struct {
	// AuthenticationType: Specifies authentication type being used for connecting to the storage account.
	AuthenticationType *StorageEndpointProperties_AuthenticationType_STATUS `json:"authenticationType,omitempty"`

	// ContainerName: The name of the root container where you upload files. The container need not exist but should be
	// creatable using the connectionString specified.
	ContainerName *string `json:"containerName,omitempty"`

	// Identity: Managed identity properties of storage endpoint for file upload.
	Identity *ManagedIdentity_STATUS `json:"identity,omitempty"`

	// SasTtlAsIso8601: The period of time for which the SAS URI generated by IoT Hub for file upload is valid. See:
	// https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-file-upload#file-upload-notification-configuration-options.
	SasTtlAsIso8601 *string `json:"sasTtlAsIso8601,omitempty"`
}

var _ genruntime.FromARMConverter = &StorageEndpointProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *StorageEndpointProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.StorageEndpointProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *StorageEndpointProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.StorageEndpointProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.StorageEndpointProperties_STATUS, got %T", armInput)
	}

	// Set property "AuthenticationType":
	if typedInput.AuthenticationType != nil {
		var temp string
		temp = string(*typedInput.AuthenticationType)
		authenticationType := StorageEndpointProperties_AuthenticationType_STATUS(temp)
		properties.AuthenticationType = &authenticationType
	}

	// Set property "ContainerName":
	if typedInput.ContainerName != nil {
		containerName := *typedInput.ContainerName
		properties.ContainerName = &containerName
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		properties.Identity = &identity
	}

	// Set property "SasTtlAsIso8601":
	if typedInput.SasTtlAsIso8601 != nil {
		sasTtlAsIso8601 := *typedInput.SasTtlAsIso8601
		properties.SasTtlAsIso8601 = &sasTtlAsIso8601
	}

	// No error
	return nil
}

// AssignProperties_From_StorageEndpointProperties_STATUS populates our StorageEndpointProperties_STATUS from the provided source StorageEndpointProperties_STATUS
func (properties *StorageEndpointProperties_STATUS) AssignProperties_From_StorageEndpointProperties_STATUS(source *storage.StorageEndpointProperties_STATUS) error {

	// AuthenticationType
	if source.AuthenticationType != nil {
		authenticationType := *source.AuthenticationType
		authenticationTypeTemp := genruntime.ToEnum(authenticationType, storageEndpointProperties_AuthenticationType_STATUS_Values)
		properties.AuthenticationType = &authenticationTypeTemp
	} else {
		properties.AuthenticationType = nil
	}

	// ContainerName
	properties.ContainerName = genruntime.ClonePointerToString(source.ContainerName)

	// Identity
	if source.Identity != nil {
		var identity ManagedIdentity_STATUS
		err := identity.AssignProperties_From_ManagedIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedIdentity_STATUS() to populate field Identity")
		}
		properties.Identity = &identity
	} else {
		properties.Identity = nil
	}

	// SasTtlAsIso8601
	properties.SasTtlAsIso8601 = genruntime.ClonePointerToString(source.SasTtlAsIso8601)

	// No error
	return nil
}

// AssignProperties_To_StorageEndpointProperties_STATUS populates the provided destination StorageEndpointProperties_STATUS from our StorageEndpointProperties_STATUS
func (properties *StorageEndpointProperties_STATUS) AssignProperties_To_StorageEndpointProperties_STATUS(destination *storage.StorageEndpointProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthenticationType
	if properties.AuthenticationType != nil {
		authenticationType := string(*properties.AuthenticationType)
		destination.AuthenticationType = &authenticationType
	} else {
		destination.AuthenticationType = nil
	}

	// ContainerName
	destination.ContainerName = genruntime.ClonePointerToString(properties.ContainerName)

	// Identity
	if properties.Identity != nil {
		var identity storage.ManagedIdentity_STATUS
		err := properties.Identity.AssignProperties_To_ManagedIdentity_STATUS(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// SasTtlAsIso8601
	destination.SasTtlAsIso8601 = genruntime.ClonePointerToString(properties.SasTtlAsIso8601)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type SystemData_CreatedByType_STATUS string

const (
	SystemData_CreatedByType_STATUS_Application     = SystemData_CreatedByType_STATUS("Application")
	SystemData_CreatedByType_STATUS_Key             = SystemData_CreatedByType_STATUS("Key")
	SystemData_CreatedByType_STATUS_ManagedIdentity = SystemData_CreatedByType_STATUS("ManagedIdentity")
	SystemData_CreatedByType_STATUS_User            = SystemData_CreatedByType_STATUS("User")
)

// Mapping from string to SystemData_CreatedByType_STATUS
var systemData_CreatedByType_STATUS_Values = map[string]SystemData_CreatedByType_STATUS{
	"application":     SystemData_CreatedByType_STATUS_Application,
	"key":             SystemData_CreatedByType_STATUS_Key,
	"managedidentity": SystemData_CreatedByType_STATUS_ManagedIdentity,
	"user":            SystemData_CreatedByType_STATUS_User,
}

type SystemData_LastModifiedByType_STATUS string

const (
	SystemData_LastModifiedByType_STATUS_Application     = SystemData_LastModifiedByType_STATUS("Application")
	SystemData_LastModifiedByType_STATUS_Key             = SystemData_LastModifiedByType_STATUS("Key")
	SystemData_LastModifiedByType_STATUS_ManagedIdentity = SystemData_LastModifiedByType_STATUS("ManagedIdentity")
	SystemData_LastModifiedByType_STATUS_User            = SystemData_LastModifiedByType_STATUS("User")
)

// Mapping from string to SystemData_LastModifiedByType_STATUS
var systemData_LastModifiedByType_STATUS_Values = map[string]SystemData_LastModifiedByType_STATUS{
	"application":     SystemData_LastModifiedByType_STATUS_Application,
	"key":             SystemData_LastModifiedByType_STATUS_Key,
	"managedidentity": SystemData_LastModifiedByType_STATUS_ManagedIdentity,
	"user":            SystemData_LastModifiedByType_STATUS_User,
}

// Information about the user assigned identity for the resource
type UserAssignedIdentityDetails struct {
	Reference genruntime.ResourceReference `armReference:"Reference" json:"reference,omitempty"`
}

// AssignProperties_From_UserAssignedIdentityDetails populates our UserAssignedIdentityDetails from the provided source UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_From_UserAssignedIdentityDetails(source *storage.UserAssignedIdentityDetails) error {

	// Reference
	details.Reference = source.Reference.Copy()

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentityDetails populates the provided destination UserAssignedIdentityDetails from our UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_To_UserAssignedIdentityDetails(destination *storage.UserAssignedIdentityDetails) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	destination.Reference = details.Reference.Copy()

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The properties of an enrichment that your IoT hub applies to messages delivered to endpoints.
type EnrichmentProperties struct {
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:MinItems=1
	// EndpointNames: The list of endpoints for which the enrichment is applied to the message.
	EndpointNames []string `json:"endpointNames,omitempty"`

	// +kubebuilder:validation:Required
	// Key: The key or name for the enrichment property.
	Key *string `json:"key,omitempty"`

	// +kubebuilder:validation:Required
	// Value: The value for the enrichment property.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &EnrichmentProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *EnrichmentProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.EnrichmentProperties{}

	// Set property "EndpointNames":
	for _, item := range properties.EndpointNames {
		result.EndpointNames = append(result.EndpointNames, item)
	}

	// Set property "Key":
	if properties.Key != nil {
		key := *properties.Key
		result.Key = &key
	}

	// Set property "Value":
	if properties.Value != nil {
		value := *properties.Value
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *EnrichmentProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EnrichmentProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *EnrichmentProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EnrichmentProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EnrichmentProperties, got %T", armInput)
	}

	// Set property "EndpointNames":
	for _, item := range typedInput.EndpointNames {
		properties.EndpointNames = append(properties.EndpointNames, item)
	}

	// Set property "Key":
	if typedInput.Key != nil {
		key := *typedInput.Key
		properties.Key = &key
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		properties.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_EnrichmentProperties populates our EnrichmentProperties from the provided source EnrichmentProperties
func (properties *EnrichmentProperties) AssignProperties_From_EnrichmentProperties(source *storage.EnrichmentProperties) error {

	// EndpointNames
	properties.EndpointNames = genruntime.CloneSliceOfString(source.EndpointNames)

	// Key
	properties.Key = genruntime.ClonePointerToString(source.Key)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_EnrichmentProperties populates the provided destination EnrichmentProperties from our EnrichmentProperties
func (properties *EnrichmentProperties) AssignProperties_To_EnrichmentProperties(destination *storage.EnrichmentProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EndpointNames
	destination.EndpointNames = genruntime.CloneSliceOfString(properties.EndpointNames)

	// Key
	destination.Key = genruntime.ClonePointerToString(properties.Key)

	// Value
	destination.Value = genruntime.ClonePointerToString(properties.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_EnrichmentProperties_STATUS populates our EnrichmentProperties from the provided source EnrichmentProperties_STATUS
func (properties *EnrichmentProperties) Initialize_From_EnrichmentProperties_STATUS(source *EnrichmentProperties_STATUS) error {

	// EndpointNames
	properties.EndpointNames = genruntime.CloneSliceOfString(source.EndpointNames)

	// Key
	properties.Key = genruntime.ClonePointerToString(source.Key)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// The properties of an enrichment that your IoT hub applies to messages delivered to endpoints.
type EnrichmentProperties_STATUS struct {
	// EndpointNames: The list of endpoints for which the enrichment is applied to the message.
	EndpointNames []string `json:"endpointNames,omitempty"`

	// Key: The key or name for the enrichment property.
	Key *string `json:"key,omitempty"`

	// Value: The value for the enrichment property.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &EnrichmentProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *EnrichmentProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EnrichmentProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *EnrichmentProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EnrichmentProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EnrichmentProperties_STATUS, got %T", armInput)
	}

	// Set property "EndpointNames":
	for _, item := range typedInput.EndpointNames {
		properties.EndpointNames = append(properties.EndpointNames, item)
	}

	// Set property "Key":
	if typedInput.Key != nil {
		key := *typedInput.Key
		properties.Key = &key
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		properties.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_EnrichmentProperties_STATUS populates our EnrichmentProperties_STATUS from the provided source EnrichmentProperties_STATUS
func (properties *EnrichmentProperties_STATUS) AssignProperties_From_EnrichmentProperties_STATUS(source *storage.EnrichmentProperties_STATUS) error {

	// EndpointNames
	properties.EndpointNames = genruntime.CloneSliceOfString(source.EndpointNames)

	// Key
	properties.Key = genruntime.ClonePointerToString(source.Key)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_EnrichmentProperties_STATUS populates the provided destination EnrichmentProperties_STATUS from our EnrichmentProperties_STATUS
func (properties *EnrichmentProperties_STATUS) AssignProperties_To_EnrichmentProperties_STATUS(destination *storage.EnrichmentProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EndpointNames
	destination.EndpointNames = genruntime.CloneSliceOfString(properties.EndpointNames)

	// Key
	destination.Key = genruntime.ClonePointerToString(properties.Key)

	// Value
	destination.Value = genruntime.ClonePointerToString(properties.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The properties of the fallback route. IoT Hub uses these properties when it routes messages to the fallback endpoint.
type FallbackRouteProperties struct {
	// Condition: The condition which is evaluated in order to apply the fallback route. If the condition is not provided it
	// will evaluate to true by default. For grammar, See:
	// https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-query-language
	Condition *string `json:"condition,omitempty"`

	// +kubebuilder:validation:Required
	// +kubebuilder:validation:MaxItems=1
	// +kubebuilder:validation:MinItems=1
	// EndpointNames: The list of endpoints to which the messages that satisfy the condition are routed to. Currently only 1
	// endpoint is allowed.
	EndpointNames []string `json:"endpointNames,omitempty"`

	// +kubebuilder:validation:Required
	// IsEnabled: Used to specify whether the fallback route is enabled.
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Name: The name of the route. The name can only include alphanumeric characters, periods, underscores, hyphens, has a
	// maximum length of 64 characters, and must be unique.
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Source: The source to which the routing rule is to be applied to. For example, DeviceMessages
	Source *FallbackRouteProperties_Source `json:"source,omitempty"`
}

var _ genruntime.ARMTransformer = &FallbackRouteProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *FallbackRouteProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.FallbackRouteProperties{}

	// Set property "Condition":
	if properties.Condition != nil {
		condition := *properties.Condition
		result.Condition = &condition
	}

	// Set property "EndpointNames":
	for _, item := range properties.EndpointNames {
		result.EndpointNames = append(result.EndpointNames, item)
	}

	// Set property "IsEnabled":
	if properties.IsEnabled != nil {
		isEnabled := *properties.IsEnabled
		result.IsEnabled = &isEnabled
	}

	// Set property "Name":
	if properties.Name != nil {
		name := *properties.Name
		result.Name = &name
	}

	// Set property "Source":
	if properties.Source != nil {
		var temp string
		temp = string(*properties.Source)
		source := arm.FallbackRouteProperties_Source(temp)
		result.Source = &source
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *FallbackRouteProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FallbackRouteProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *FallbackRouteProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FallbackRouteProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FallbackRouteProperties, got %T", armInput)
	}

	// Set property "Condition":
	if typedInput.Condition != nil {
		condition := *typedInput.Condition
		properties.Condition = &condition
	}

	// Set property "EndpointNames":
	for _, item := range typedInput.EndpointNames {
		properties.EndpointNames = append(properties.EndpointNames, item)
	}

	// Set property "IsEnabled":
	if typedInput.IsEnabled != nil {
		isEnabled := *typedInput.IsEnabled
		properties.IsEnabled = &isEnabled
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		properties.Name = &name
	}

	// Set property "Source":
	if typedInput.Source != nil {
		var temp string
		temp = string(*typedInput.Source)
		source := FallbackRouteProperties_Source(temp)
		properties.Source = &source
	}

	// No error
	return nil
}

// AssignProperties_From_FallbackRouteProperties populates our FallbackRouteProperties from the provided source FallbackRouteProperties
func (properties *FallbackRouteProperties) AssignProperties_From_FallbackRouteProperties(source *storage.FallbackRouteProperties) error {

	// Condition
	properties.Condition = genruntime.ClonePointerToString(source.Condition)

	// EndpointNames
	properties.EndpointNames = genruntime.CloneSliceOfString(source.EndpointNames)

	// IsEnabled
	if source.IsEnabled != nil {
		isEnabled := *source.IsEnabled
		properties.IsEnabled = &isEnabled
	} else {
		properties.IsEnabled = nil
	}

	// Name
	properties.Name = genruntime.ClonePointerToString(source.Name)

	// Source
	if source.Source != nil {
		sourceValue := *source.Source
		sourceTemp := genruntime.ToEnum(sourceValue, fallbackRouteProperties_Source_Values)
		properties.Source = &sourceTemp
	} else {
		properties.Source = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FallbackRouteProperties populates the provided destination FallbackRouteProperties from our FallbackRouteProperties
func (properties *FallbackRouteProperties) AssignProperties_To_FallbackRouteProperties(destination *storage.FallbackRouteProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Condition
	destination.Condition = genruntime.ClonePointerToString(properties.Condition)

	// EndpointNames
	destination.EndpointNames = genruntime.CloneSliceOfString(properties.EndpointNames)

	// IsEnabled
	if properties.IsEnabled != nil {
		isEnabled := *properties.IsEnabled
		destination.IsEnabled = &isEnabled
	} else {
		destination.IsEnabled = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(properties.Name)

	// Source
	if properties.Source != nil {
		source := string(*properties.Source)
		destination.Source = &source
	} else {
		destination.Source = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_FallbackRouteProperties_STATUS populates our FallbackRouteProperties from the provided source FallbackRouteProperties_STATUS
func (properties *FallbackRouteProperties) Initialize_From_FallbackRouteProperties_STATUS(source *FallbackRouteProperties_STATUS) error {

	// Condition
	properties.Condition = genruntime.ClonePointerToString(source.Condition)

	// EndpointNames
	properties.EndpointNames = genruntime.CloneSliceOfString(source.EndpointNames)

	// IsEnabled
	if source.IsEnabled != nil {
		isEnabled := *source.IsEnabled
		properties.IsEnabled = &isEnabled
	} else {
		properties.IsEnabled = nil
	}

	// Name
	properties.Name = genruntime.ClonePointerToString(source.Name)

	// Source
	if source.Source != nil {
		sourceAsFallbackRouteProperties_Source := genruntime.ToEnum(string(*source.Source), fallbackRouteProperties_Source_Values)
		properties.Source = &sourceAsFallbackRouteProperties_Source
	} else {
		properties.Source = nil
	}

	// No error
	return nil
}

// The properties of the fallback route. IoT Hub uses these properties when it routes messages to the fallback endpoint.
type FallbackRouteProperties_STATUS struct {
	// Condition: The condition which is evaluated in order to apply the fallback route. If the condition is not provided it
	// will evaluate to true by default. For grammar, See:
	// https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-query-language
	Condition *string `json:"condition,omitempty"`

	// EndpointNames: The list of endpoints to which the messages that satisfy the condition are routed to. Currently only 1
	// endpoint is allowed.
	EndpointNames []string `json:"endpointNames,omitempty"`

	// IsEnabled: Used to specify whether the fallback route is enabled.
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Name: The name of the route. The name can only include alphanumeric characters, periods, underscores, hyphens, has a
	// maximum length of 64 characters, and must be unique.
	Name *string `json:"name,omitempty"`

	// Source: The source to which the routing rule is to be applied to. For example, DeviceMessages
	Source *FallbackRouteProperties_Source_STATUS `json:"source,omitempty"`
}

var _ genruntime.FromARMConverter = &FallbackRouteProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *FallbackRouteProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FallbackRouteProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *FallbackRouteProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FallbackRouteProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FallbackRouteProperties_STATUS, got %T", armInput)
	}

	// Set property "Condition":
	if typedInput.Condition != nil {
		condition := *typedInput.Condition
		properties.Condition = &condition
	}

	// Set property "EndpointNames":
	for _, item := range typedInput.EndpointNames {
		properties.EndpointNames = append(properties.EndpointNames, item)
	}

	// Set property "IsEnabled":
	if typedInput.IsEnabled != nil {
		isEnabled := *typedInput.IsEnabled
		properties.IsEnabled = &isEnabled
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		properties.Name = &name
	}

	// Set property "Source":
	if typedInput.Source != nil {
		var temp string
		temp = string(*typedInput.Source)
		source := FallbackRouteProperties_Source_STATUS(temp)
		properties.Source = &source
	}

	// No error
	return nil
}

// AssignProperties_From_FallbackRouteProperties_STATUS populates our FallbackRouteProperties_STATUS from the provided source FallbackRouteProperties_STATUS
func (properties *FallbackRouteProperties_STATUS) AssignProperties_From_FallbackRouteProperties_STATUS(source *storage.FallbackRouteProperties_STATUS) error {

	// Condition
	properties.Condition = genruntime.ClonePointerToString(source.Condition)

	// EndpointNames
	properties.EndpointNames = genruntime.CloneSliceOfString(source.EndpointNames)

	// IsEnabled
	if source.IsEnabled != nil {
		isEnabled := *source.IsEnabled
		properties.IsEnabled = &isEnabled
	} else {
		properties.IsEnabled = nil
	}

	// Name
	properties.Name = genruntime.ClonePointerToString(source.Name)

	// Source
	if source.Source != nil {
		sourceValue := *source.Source
		sourceTemp := genruntime.ToEnum(sourceValue, fallbackRouteProperties_Source_STATUS_Values)
		properties.Source = &sourceTemp
	} else {
		properties.Source = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FallbackRouteProperties_STATUS populates the provided destination FallbackRouteProperties_STATUS from our FallbackRouteProperties_STATUS
func (properties *FallbackRouteProperties_STATUS) AssignProperties_To_FallbackRouteProperties_STATUS(destination *storage.FallbackRouteProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Condition
	destination.Condition = genruntime.ClonePointerToString(properties.Condition)

	// EndpointNames
	destination.EndpointNames = genruntime.CloneSliceOfString(properties.EndpointNames)

	// IsEnabled
	if properties.IsEnabled != nil {
		isEnabled := *properties.IsEnabled
		destination.IsEnabled = &isEnabled
	} else {
		destination.IsEnabled = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(properties.Name)

	// Source
	if properties.Source != nil {
		source := string(*properties.Source)
		destination.Source = &source
	} else {
		destination.Source = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The properties of the feedback queue for cloud-to-device messages.
type FeedbackProperties struct {
	// LockDurationAsIso8601: The lock duration for the feedback queue. See:
	// https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-messaging#cloud-to-device-messages.
	LockDurationAsIso8601 *string `json:"lockDurationAsIso8601,omitempty"`

	// +kubebuilder:validation:Maximum=100
	// +kubebuilder:validation:Minimum=1
	// MaxDeliveryCount: The number of times the IoT hub attempts to deliver a message on the feedback queue. See:
	// https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-messaging#cloud-to-device-messages.
	MaxDeliveryCount *int `json:"maxDeliveryCount,omitempty"`

	// TtlAsIso8601: The period of time for which a message is available to consume before it is expired by the IoT hub. See:
	// https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-messaging#cloud-to-device-messages.
	TtlAsIso8601 *string `json:"ttlAsIso8601,omitempty"`
}

var _ genruntime.ARMTransformer = &FeedbackProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *FeedbackProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.FeedbackProperties{}

	// Set property "LockDurationAsIso8601":
	if properties.LockDurationAsIso8601 != nil {
		lockDurationAsIso8601 := *properties.LockDurationAsIso8601
		result.LockDurationAsIso8601 = &lockDurationAsIso8601
	}

	// Set property "MaxDeliveryCount":
	if properties.MaxDeliveryCount != nil {
		maxDeliveryCount := *properties.MaxDeliveryCount
		result.MaxDeliveryCount = &maxDeliveryCount
	}

	// Set property "TtlAsIso8601":
	if properties.TtlAsIso8601 != nil {
		ttlAsIso8601 := *properties.TtlAsIso8601
		result.TtlAsIso8601 = &ttlAsIso8601
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *FeedbackProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FeedbackProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *FeedbackProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FeedbackProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FeedbackProperties, got %T", armInput)
	}

	// Set property "LockDurationAsIso8601":
	if typedInput.LockDurationAsIso8601 != nil {
		lockDurationAsIso8601 := *typedInput.LockDurationAsIso8601
		properties.LockDurationAsIso8601 = &lockDurationAsIso8601
	}

	// Set property "MaxDeliveryCount":
	if typedInput.MaxDeliveryCount != nil {
		maxDeliveryCount := *typedInput.MaxDeliveryCount
		properties.MaxDeliveryCount = &maxDeliveryCount
	}

	// Set property "TtlAsIso8601":
	if typedInput.TtlAsIso8601 != nil {
		ttlAsIso8601 := *typedInput.TtlAsIso8601
		properties.TtlAsIso8601 = &ttlAsIso8601
	}

	// No error
	return nil
}

// AssignProperties_From_FeedbackProperties populates our FeedbackProperties from the provided source FeedbackProperties
func (properties *FeedbackProperties) AssignProperties_From_FeedbackProperties(source *storage.FeedbackProperties) error {

	// LockDurationAsIso8601
	properties.LockDurationAsIso8601 = genruntime.ClonePointerToString(source.LockDurationAsIso8601)

	// MaxDeliveryCount
	properties.MaxDeliveryCount = genruntime.ClonePointerToInt(source.MaxDeliveryCount)

	// TtlAsIso8601
	properties.TtlAsIso8601 = genruntime.ClonePointerToString(source.TtlAsIso8601)

	// No error
	return nil
}

// AssignProperties_To_FeedbackProperties populates the provided destination FeedbackProperties from our FeedbackProperties
func (properties *FeedbackProperties) AssignProperties_To_FeedbackProperties(destination *storage.FeedbackProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// LockDurationAsIso8601
	destination.LockDurationAsIso8601 = genruntime.ClonePointerToString(properties.LockDurationAsIso8601)

	// MaxDeliveryCount
	destination.MaxDeliveryCount = genruntime.ClonePointerToInt(properties.MaxDeliveryCount)

	// TtlAsIso8601
	destination.TtlAsIso8601 = genruntime.ClonePointerToString(properties.TtlAsIso8601)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_FeedbackProperties_STATUS populates our FeedbackProperties from the provided source FeedbackProperties_STATUS
func (properties *FeedbackProperties) Initialize_From_FeedbackProperties_STATUS(source *FeedbackProperties_STATUS) error {

	// LockDurationAsIso8601
	properties.LockDurationAsIso8601 = genruntime.ClonePointerToString(source.LockDurationAsIso8601)

	// MaxDeliveryCount
	properties.MaxDeliveryCount = genruntime.ClonePointerToInt(source.MaxDeliveryCount)

	// TtlAsIso8601
	properties.TtlAsIso8601 = genruntime.ClonePointerToString(source.TtlAsIso8601)

	// No error
	return nil
}

// The properties of the feedback queue for cloud-to-device messages.
type FeedbackProperties_STATUS struct {
	// LockDurationAsIso8601: The lock duration for the feedback queue. See:
	// https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-messaging#cloud-to-device-messages.
	LockDurationAsIso8601 *string `json:"lockDurationAsIso8601,omitempty"`

	// MaxDeliveryCount: The number of times the IoT hub attempts to deliver a message on the feedback queue. See:
	// https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-messaging#cloud-to-device-messages.
	MaxDeliveryCount *int `json:"maxDeliveryCount,omitempty"`

	// TtlAsIso8601: The period of time for which a message is available to consume before it is expired by the IoT hub. See:
	// https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-messaging#cloud-to-device-messages.
	TtlAsIso8601 *string `json:"ttlAsIso8601,omitempty"`
}

var _ genruntime.FromARMConverter = &FeedbackProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *FeedbackProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FeedbackProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *FeedbackProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FeedbackProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FeedbackProperties_STATUS, got %T", armInput)
	}

	// Set property "LockDurationAsIso8601":
	if typedInput.LockDurationAsIso8601 != nil {
		lockDurationAsIso8601 := *typedInput.LockDurationAsIso8601
		properties.LockDurationAsIso8601 = &lockDurationAsIso8601
	}

	// Set property "MaxDeliveryCount":
	if typedInput.MaxDeliveryCount != nil {
		maxDeliveryCount := *typedInput.MaxDeliveryCount
		properties.MaxDeliveryCount = &maxDeliveryCount
	}

	// Set property "TtlAsIso8601":
	if typedInput.TtlAsIso8601 != nil {
		ttlAsIso8601 := *typedInput.TtlAsIso8601
		properties.TtlAsIso8601 = &ttlAsIso8601
	}

	// No error
	return nil
}

// AssignProperties_From_FeedbackProperties_STATUS populates our FeedbackProperties_STATUS from the provided source FeedbackProperties_STATUS
func (properties *FeedbackProperties_STATUS) AssignProperties_From_FeedbackProperties_STATUS(source *storage.FeedbackProperties_STATUS) error {

	// LockDurationAsIso8601
	properties.LockDurationAsIso8601 = genruntime.ClonePointerToString(source.LockDurationAsIso8601)

	// MaxDeliveryCount
	properties.MaxDeliveryCount = genruntime.ClonePointerToInt(source.MaxDeliveryCount)

	// TtlAsIso8601
	properties.TtlAsIso8601 = genruntime.ClonePointerToString(source.TtlAsIso8601)

	// No error
	return nil
}

// AssignProperties_To_FeedbackProperties_STATUS populates the provided destination FeedbackProperties_STATUS from our FeedbackProperties_STATUS
func (properties *FeedbackProperties_STATUS) AssignProperties_To_FeedbackProperties_STATUS(destination *storage.FeedbackProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// LockDurationAsIso8601
	destination.LockDurationAsIso8601 = genruntime.ClonePointerToString(properties.LockDurationAsIso8601)

	// MaxDeliveryCount
	destination.MaxDeliveryCount = genruntime.ClonePointerToInt(properties.MaxDeliveryCount)

	// TtlAsIso8601
	destination.TtlAsIso8601 = genruntime.ClonePointerToString(properties.TtlAsIso8601)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type IotHubLocationDescription_Role_STATUS string

const (
	IotHubLocationDescription_Role_STATUS_Primary   = IotHubLocationDescription_Role_STATUS("primary")
	IotHubLocationDescription_Role_STATUS_Secondary = IotHubLocationDescription_Role_STATUS("secondary")
)

// Mapping from string to IotHubLocationDescription_Role_STATUS
var iotHubLocationDescription_Role_STATUS_Values = map[string]IotHubLocationDescription_Role_STATUS{
	"primary":   IotHubLocationDescription_Role_STATUS_Primary,
	"secondary": IotHubLocationDescription_Role_STATUS_Secondary,
}

// +kubebuilder:validation:Enum={"Accept","Reject"}
type IpFilterRule_Action string

const (
	IpFilterRule_Action_Accept = IpFilterRule_Action("Accept")
	IpFilterRule_Action_Reject = IpFilterRule_Action("Reject")
)

// Mapping from string to IpFilterRule_Action
var ipFilterRule_Action_Values = map[string]IpFilterRule_Action{
	"accept": IpFilterRule_Action_Accept,
	"reject": IpFilterRule_Action_Reject,
}

type IpFilterRule_Action_STATUS string

const (
	IpFilterRule_Action_STATUS_Accept = IpFilterRule_Action_STATUS("Accept")
	IpFilterRule_Action_STATUS_Reject = IpFilterRule_Action_STATUS("Reject")
)

// Mapping from string to IpFilterRule_Action_STATUS
var ipFilterRule_Action_STATUS_Values = map[string]IpFilterRule_Action_STATUS{
	"accept": IpFilterRule_Action_STATUS_Accept,
	"reject": IpFilterRule_Action_STATUS_Reject,
}

// The properties of the Managed identity.
type ManagedIdentity struct {
	// UserAssignedIdentity: The user assigned identity.
	UserAssignedIdentity *string `json:"userAssignedIdentity,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *ManagedIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &arm.ManagedIdentity{}

	// Set property "UserAssignedIdentity":
	if identity.UserAssignedIdentity != nil {
		userAssignedIdentity := *identity.UserAssignedIdentity
		result.UserAssignedIdentity = &userAssignedIdentity
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedIdentity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedIdentity{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedIdentity)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedIdentity, got %T", armInput)
	}

	// Set property "UserAssignedIdentity":
	if typedInput.UserAssignedIdentity != nil {
		userAssignedIdentity := *typedInput.UserAssignedIdentity
		identity.UserAssignedIdentity = &userAssignedIdentity
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedIdentity populates our ManagedIdentity from the provided source ManagedIdentity
func (identity *ManagedIdentity) AssignProperties_From_ManagedIdentity(source *storage.ManagedIdentity) error {

	// UserAssignedIdentity
	identity.UserAssignedIdentity = genruntime.ClonePointerToString(source.UserAssignedIdentity)

	// No error
	return nil
}

// AssignProperties_To_ManagedIdentity populates the provided destination ManagedIdentity from our ManagedIdentity
func (identity *ManagedIdentity) AssignProperties_To_ManagedIdentity(destination *storage.ManagedIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// UserAssignedIdentity
	destination.UserAssignedIdentity = genruntime.ClonePointerToString(identity.UserAssignedIdentity)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ManagedIdentity_STATUS populates our ManagedIdentity from the provided source ManagedIdentity_STATUS
func (identity *ManagedIdentity) Initialize_From_ManagedIdentity_STATUS(source *ManagedIdentity_STATUS) error {

	// UserAssignedIdentity
	identity.UserAssignedIdentity = genruntime.ClonePointerToString(source.UserAssignedIdentity)

	// No error
	return nil
}

// The properties of the Managed identity.
type ManagedIdentity_STATUS struct {
	// UserAssignedIdentity: The user assigned identity.
	UserAssignedIdentity *string `json:"userAssignedIdentity,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedIdentity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedIdentity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedIdentity_STATUS, got %T", armInput)
	}

	// Set property "UserAssignedIdentity":
	if typedInput.UserAssignedIdentity != nil {
		userAssignedIdentity := *typedInput.UserAssignedIdentity
		identity.UserAssignedIdentity = &userAssignedIdentity
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedIdentity_STATUS populates our ManagedIdentity_STATUS from the provided source ManagedIdentity_STATUS
func (identity *ManagedIdentity_STATUS) AssignProperties_From_ManagedIdentity_STATUS(source *storage.ManagedIdentity_STATUS) error {

	// UserAssignedIdentity
	identity.UserAssignedIdentity = genruntime.ClonePointerToString(source.UserAssignedIdentity)

	// No error
	return nil
}

// AssignProperties_To_ManagedIdentity_STATUS populates the provided destination ManagedIdentity_STATUS from our ManagedIdentity_STATUS
func (identity *ManagedIdentity_STATUS) AssignProperties_To_ManagedIdentity_STATUS(destination *storage.ManagedIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// UserAssignedIdentity
	destination.UserAssignedIdentity = genruntime.ClonePointerToString(identity.UserAssignedIdentity)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// IP Rule to be applied as part of Network Rule Set
type NetworkRuleSetIpRule struct {
	// Action: IP Filter Action
	Action *NetworkRuleSetIpRule_Action `json:"action,omitempty"`

	// +kubebuilder:validation:Required
	// FilterName: Name of the IP filter rule.
	FilterName *string `json:"filterName,omitempty"`

	// +kubebuilder:validation:Required
	// IpMask: A string that contains the IP address range in CIDR notation for the rule.
	IpMask *string `json:"ipMask,omitempty"`
}

var _ genruntime.ARMTransformer = &NetworkRuleSetIpRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *NetworkRuleSetIpRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.NetworkRuleSetIpRule{}

	// Set property "Action":
	if rule.Action != nil {
		var temp string
		temp = string(*rule.Action)
		action := arm.NetworkRuleSetIpRule_Action(temp)
		result.Action = &action
	}

	// Set property "FilterName":
	if rule.FilterName != nil {
		filterName := *rule.FilterName
		result.FilterName = &filterName
	}

	// Set property "IpMask":
	if rule.IpMask != nil {
		ipMask := *rule.IpMask
		result.IpMask = &ipMask
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *NetworkRuleSetIpRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NetworkRuleSetIpRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *NetworkRuleSetIpRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NetworkRuleSetIpRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NetworkRuleSetIpRule, got %T", armInput)
	}

	// Set property "Action":
	if typedInput.Action != nil {
		var temp string
		temp = string(*typedInput.Action)
		action := NetworkRuleSetIpRule_Action(temp)
		rule.Action = &action
	}

	// Set property "FilterName":
	if typedInput.FilterName != nil {
		filterName := *typedInput.FilterName
		rule.FilterName = &filterName
	}

	// Set property "IpMask":
	if typedInput.IpMask != nil {
		ipMask := *typedInput.IpMask
		rule.IpMask = &ipMask
	}

	// No error
	return nil
}

// AssignProperties_From_NetworkRuleSetIpRule populates our NetworkRuleSetIpRule from the provided source NetworkRuleSetIpRule
func (rule *NetworkRuleSetIpRule) AssignProperties_From_NetworkRuleSetIpRule(source *storage.NetworkRuleSetIpRule) error {

	// Action
	if source.Action != nil {
		action := *source.Action
		actionTemp := genruntime.ToEnum(action, networkRuleSetIpRule_Action_Values)
		rule.Action = &actionTemp
	} else {
		rule.Action = nil
	}

	// FilterName
	rule.FilterName = genruntime.ClonePointerToString(source.FilterName)

	// IpMask
	rule.IpMask = genruntime.ClonePointerToString(source.IpMask)

	// No error
	return nil
}

// AssignProperties_To_NetworkRuleSetIpRule populates the provided destination NetworkRuleSetIpRule from our NetworkRuleSetIpRule
func (rule *NetworkRuleSetIpRule) AssignProperties_To_NetworkRuleSetIpRule(destination *storage.NetworkRuleSetIpRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	if rule.Action != nil {
		action := string(*rule.Action)
		destination.Action = &action
	} else {
		destination.Action = nil
	}

	// FilterName
	destination.FilterName = genruntime.ClonePointerToString(rule.FilterName)

	// IpMask
	destination.IpMask = genruntime.ClonePointerToString(rule.IpMask)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_NetworkRuleSetIpRule_STATUS populates our NetworkRuleSetIpRule from the provided source NetworkRuleSetIpRule_STATUS
func (rule *NetworkRuleSetIpRule) Initialize_From_NetworkRuleSetIpRule_STATUS(source *NetworkRuleSetIpRule_STATUS) error {

	// Action
	if source.Action != nil {
		action := genruntime.ToEnum(string(*source.Action), networkRuleSetIpRule_Action_Values)
		rule.Action = &action
	} else {
		rule.Action = nil
	}

	// FilterName
	rule.FilterName = genruntime.ClonePointerToString(source.FilterName)

	// IpMask
	rule.IpMask = genruntime.ClonePointerToString(source.IpMask)

	// No error
	return nil
}

// IP Rule to be applied as part of Network Rule Set
type NetworkRuleSetIpRule_STATUS struct {
	// Action: IP Filter Action
	Action *NetworkRuleSetIpRule_Action_STATUS `json:"action,omitempty"`

	// FilterName: Name of the IP filter rule.
	FilterName *string `json:"filterName,omitempty"`

	// IpMask: A string that contains the IP address range in CIDR notation for the rule.
	IpMask *string `json:"ipMask,omitempty"`
}

var _ genruntime.FromARMConverter = &NetworkRuleSetIpRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *NetworkRuleSetIpRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NetworkRuleSetIpRule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *NetworkRuleSetIpRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NetworkRuleSetIpRule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NetworkRuleSetIpRule_STATUS, got %T", armInput)
	}

	// Set property "Action":
	if typedInput.Action != nil {
		var temp string
		temp = string(*typedInput.Action)
		action := NetworkRuleSetIpRule_Action_STATUS(temp)
		rule.Action = &action
	}

	// Set property "FilterName":
	if typedInput.FilterName != nil {
		filterName := *typedInput.FilterName
		rule.FilterName = &filterName
	}

	// Set property "IpMask":
	if typedInput.IpMask != nil {
		ipMask := *typedInput.IpMask
		rule.IpMask = &ipMask
	}

	// No error
	return nil
}

// AssignProperties_From_NetworkRuleSetIpRule_STATUS populates our NetworkRuleSetIpRule_STATUS from the provided source NetworkRuleSetIpRule_STATUS
func (rule *NetworkRuleSetIpRule_STATUS) AssignProperties_From_NetworkRuleSetIpRule_STATUS(source *storage.NetworkRuleSetIpRule_STATUS) error {

	// Action
	if source.Action != nil {
		action := *source.Action
		actionTemp := genruntime.ToEnum(action, networkRuleSetIpRule_Action_STATUS_Values)
		rule.Action = &actionTemp
	} else {
		rule.Action = nil
	}

	// FilterName
	rule.FilterName = genruntime.ClonePointerToString(source.FilterName)

	// IpMask
	rule.IpMask = genruntime.ClonePointerToString(source.IpMask)

	// No error
	return nil
}

// AssignProperties_To_NetworkRuleSetIpRule_STATUS populates the provided destination NetworkRuleSetIpRule_STATUS from our NetworkRuleSetIpRule_STATUS
func (rule *NetworkRuleSetIpRule_STATUS) AssignProperties_To_NetworkRuleSetIpRule_STATUS(destination *storage.NetworkRuleSetIpRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	if rule.Action != nil {
		action := string(*rule.Action)
		destination.Action = &action
	} else {
		destination.Action = nil
	}

	// FilterName
	destination.FilterName = genruntime.ClonePointerToString(rule.FilterName)

	// IpMask
	destination.IpMask = genruntime.ClonePointerToString(rule.IpMask)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Allow","Deny"}
type NetworkRuleSetProperties_DefaultAction string

const (
	NetworkRuleSetProperties_DefaultAction_Allow = NetworkRuleSetProperties_DefaultAction("Allow")
	NetworkRuleSetProperties_DefaultAction_Deny  = NetworkRuleSetProperties_DefaultAction("Deny")
)

// Mapping from string to NetworkRuleSetProperties_DefaultAction
var networkRuleSetProperties_DefaultAction_Values = map[string]NetworkRuleSetProperties_DefaultAction{
	"allow": NetworkRuleSetProperties_DefaultAction_Allow,
	"deny":  NetworkRuleSetProperties_DefaultAction_Deny,
}

type NetworkRuleSetProperties_DefaultAction_STATUS string

const (
	NetworkRuleSetProperties_DefaultAction_STATUS_Allow = NetworkRuleSetProperties_DefaultAction_STATUS("Allow")
	NetworkRuleSetProperties_DefaultAction_STATUS_Deny  = NetworkRuleSetProperties_DefaultAction_STATUS("Deny")
)

// Mapping from string to NetworkRuleSetProperties_DefaultAction_STATUS
var networkRuleSetProperties_DefaultAction_STATUS_Values = map[string]NetworkRuleSetProperties_DefaultAction_STATUS{
	"allow": NetworkRuleSetProperties_DefaultAction_STATUS_Allow,
	"deny":  NetworkRuleSetProperties_DefaultAction_STATUS_Deny,
}

// The properties of a routing rule that your IoT hub uses to route messages to endpoints.
type RouteProperties struct {
	// Condition: The condition that is evaluated to apply the routing rule. If no condition is provided, it evaluates to true
	// by default. For grammar, see: https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-query-language
	Condition *string `json:"condition,omitempty"`

	// +kubebuilder:validation:Required
	// +kubebuilder:validation:MaxItems=1
	// +kubebuilder:validation:MinItems=1
	// EndpointNames: The list of endpoints to which messages that satisfy the condition are routed. Currently only one
	// endpoint is allowed.
	EndpointNames []string `json:"endpointNames,omitempty"`

	// +kubebuilder:validation:Required
	// IsEnabled: Used to specify whether a route is enabled.
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// +kubebuilder:validation:Required
	// +kubebuilder:validation:Pattern="^[A-Za-z0-9-._]{1,64}$"
	// Name: The name of the route. The name can only include alphanumeric characters, periods, underscores, hyphens, has a
	// maximum length of 64 characters, and must be unique.
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Source: The source that the routing rule is to be applied to, such as DeviceMessages.
	Source *RouteProperties_Source `json:"source,omitempty"`
}

var _ genruntime.ARMTransformer = &RouteProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *RouteProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.RouteProperties{}

	// Set property "Condition":
	if properties.Condition != nil {
		condition := *properties.Condition
		result.Condition = &condition
	}

	// Set property "EndpointNames":
	for _, item := range properties.EndpointNames {
		result.EndpointNames = append(result.EndpointNames, item)
	}

	// Set property "IsEnabled":
	if properties.IsEnabled != nil {
		isEnabled := *properties.IsEnabled
		result.IsEnabled = &isEnabled
	}

	// Set property "Name":
	if properties.Name != nil {
		name := *properties.Name
		result.Name = &name
	}

	// Set property "Source":
	if properties.Source != nil {
		var temp string
		temp = string(*properties.Source)
		source := arm.RouteProperties_Source(temp)
		result.Source = &source
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *RouteProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RouteProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *RouteProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RouteProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RouteProperties, got %T", armInput)
	}

	// Set property "Condition":
	if typedInput.Condition != nil {
		condition := *typedInput.Condition
		properties.Condition = &condition
	}

	// Set property "EndpointNames":
	for _, item := range typedInput.EndpointNames {
		properties.EndpointNames = append(properties.EndpointNames, item)
	}

	// Set property "IsEnabled":
	if typedInput.IsEnabled != nil {
		isEnabled := *typedInput.IsEnabled
		properties.IsEnabled = &isEnabled
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		properties.Name = &name
	}

	// Set property "Source":
	if typedInput.Source != nil {
		var temp string
		temp = string(*typedInput.Source)
		source := RouteProperties_Source(temp)
		properties.Source = &source
	}

	// No error
	return nil
}

// AssignProperties_From_RouteProperties populates our RouteProperties from the provided source RouteProperties
func (properties *RouteProperties) AssignProperties_From_RouteProperties(source *storage.RouteProperties) error {

	// Condition
	properties.Condition = genruntime.ClonePointerToString(source.Condition)

	// EndpointNames
	properties.EndpointNames = genruntime.CloneSliceOfString(source.EndpointNames)

	// IsEnabled
	if source.IsEnabled != nil {
		isEnabled := *source.IsEnabled
		properties.IsEnabled = &isEnabled
	} else {
		properties.IsEnabled = nil
	}

	// Name
	properties.Name = genruntime.ClonePointerToString(source.Name)

	// Source
	if source.Source != nil {
		sourceValue := *source.Source
		sourceTemp := genruntime.ToEnum(sourceValue, routeProperties_Source_Values)
		properties.Source = &sourceTemp
	} else {
		properties.Source = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RouteProperties populates the provided destination RouteProperties from our RouteProperties
func (properties *RouteProperties) AssignProperties_To_RouteProperties(destination *storage.RouteProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Condition
	destination.Condition = genruntime.ClonePointerToString(properties.Condition)

	// EndpointNames
	destination.EndpointNames = genruntime.CloneSliceOfString(properties.EndpointNames)

	// IsEnabled
	if properties.IsEnabled != nil {
		isEnabled := *properties.IsEnabled
		destination.IsEnabled = &isEnabled
	} else {
		destination.IsEnabled = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(properties.Name)

	// Source
	if properties.Source != nil {
		source := string(*properties.Source)
		destination.Source = &source
	} else {
		destination.Source = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RouteProperties_STATUS populates our RouteProperties from the provided source RouteProperties_STATUS
func (properties *RouteProperties) Initialize_From_RouteProperties_STATUS(source *RouteProperties_STATUS) error {

	// Condition
	properties.Condition = genruntime.ClonePointerToString(source.Condition)

	// EndpointNames
	properties.EndpointNames = genruntime.CloneSliceOfString(source.EndpointNames)

	// IsEnabled
	if source.IsEnabled != nil {
		isEnabled := *source.IsEnabled
		properties.IsEnabled = &isEnabled
	} else {
		properties.IsEnabled = nil
	}

	// Name
	properties.Name = genruntime.ClonePointerToString(source.Name)

	// Source
	if source.Source != nil {
		sourceAsRouteProperties_Source := genruntime.ToEnum(string(*source.Source), routeProperties_Source_Values)
		properties.Source = &sourceAsRouteProperties_Source
	} else {
		properties.Source = nil
	}

	// No error
	return nil
}

// The properties of a routing rule that your IoT hub uses to route messages to endpoints.
type RouteProperties_STATUS struct {
	// Condition: The condition that is evaluated to apply the routing rule. If no condition is provided, it evaluates to true
	// by default. For grammar, see: https://docs.microsoft.com/azure/iot-hub/iot-hub-devguide-query-language
	Condition *string `json:"condition,omitempty"`

	// EndpointNames: The list of endpoints to which messages that satisfy the condition are routed. Currently only one
	// endpoint is allowed.
	EndpointNames []string `json:"endpointNames,omitempty"`

	// IsEnabled: Used to specify whether a route is enabled.
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Name: The name of the route. The name can only include alphanumeric characters, periods, underscores, hyphens, has a
	// maximum length of 64 characters, and must be unique.
	Name *string `json:"name,omitempty"`

	// Source: The source that the routing rule is to be applied to, such as DeviceMessages.
	Source *RouteProperties_Source_STATUS `json:"source,omitempty"`
}

var _ genruntime.FromARMConverter = &RouteProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *RouteProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RouteProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *RouteProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RouteProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RouteProperties_STATUS, got %T", armInput)
	}

	// Set property "Condition":
	if typedInput.Condition != nil {
		condition := *typedInput.Condition
		properties.Condition = &condition
	}

	// Set property "EndpointNames":
	for _, item := range typedInput.EndpointNames {
		properties.EndpointNames = append(properties.EndpointNames, item)
	}

	// Set property "IsEnabled":
	if typedInput.IsEnabled != nil {
		isEnabled := *typedInput.IsEnabled
		properties.IsEnabled = &isEnabled
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		properties.Name = &name
	}

	// Set property "Source":
	if typedInput.Source != nil {
		var temp string
		temp = string(*typedInput.Source)
		source := RouteProperties_Source_STATUS(temp)
		properties.Source = &source
	}

	// No error
	return nil
}

// AssignProperties_From_RouteProperties_STATUS populates our RouteProperties_STATUS from the provided source RouteProperties_STATUS
func (properties *RouteProperties_STATUS) AssignProperties_From_RouteProperties_STATUS(source *storage.RouteProperties_STATUS) error {

	// Condition
	properties.Condition = genruntime.ClonePointerToString(source.Condition)

	// EndpointNames
	properties.EndpointNames = genruntime.CloneSliceOfString(source.EndpointNames)

	// IsEnabled
	if source.IsEnabled != nil {
		isEnabled := *source.IsEnabled
		properties.IsEnabled = &isEnabled
	} else {
		properties.IsEnabled = nil
	}

	// Name
	properties.Name = genruntime.ClonePointerToString(source.Name)

	// Source
	if source.Source != nil {
		sourceValue := *source.Source
		sourceTemp := genruntime.ToEnum(sourceValue, routeProperties_Source_STATUS_Values)
		properties.Source = &sourceTemp
	} else {
		properties.Source = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RouteProperties_STATUS populates the provided destination RouteProperties_STATUS from our RouteProperties_STATUS
func (properties *RouteProperties_STATUS) AssignProperties_To_RouteProperties_STATUS(destination *storage.RouteProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Condition
	destination.Condition = genruntime.ClonePointerToString(properties.Condition)

	// EndpointNames
	destination.EndpointNames = genruntime.CloneSliceOfString(properties.EndpointNames)

	// IsEnabled
	if properties.IsEnabled != nil {
		isEnabled := *properties.IsEnabled
		destination.IsEnabled = &isEnabled
	} else {
		destination.IsEnabled = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(properties.Name)

	// Source
	if properties.Source != nil {
		source := string(*properties.Source)
		destination.Source = &source
	} else {
		destination.Source = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The properties related to the custom endpoints to which your IoT hub routes messages based on the routing rules. A
// maximum of 10 custom endpoints are allowed across all endpoint types for paid hubs and only 1 custom endpoint is allowed
// across all endpoint types for free hubs.
type RoutingEndpoints struct {
	// EventHubs: The list of Event Hubs endpoints that IoT hub routes messages to, based on the routing rules. This list does
	// not include the built-in Event Hubs endpoint.
	EventHubs []RoutingEventHubProperties `json:"eventHubs,omitempty"`

	// ServiceBusQueues: The list of Service Bus queue endpoints that IoT hub routes the messages to, based on the routing
	// rules.
	ServiceBusQueues []RoutingServiceBusQueueEndpointProperties `json:"serviceBusQueues,omitempty"`

	// ServiceBusTopics: The list of Service Bus topic endpoints that the IoT hub routes the messages to, based on the routing
	// rules.
	ServiceBusTopics []RoutingServiceBusTopicEndpointProperties `json:"serviceBusTopics,omitempty"`

	// StorageContainers: The list of storage container endpoints that IoT hub routes messages to, based on the routing rules.
	StorageContainers []RoutingStorageContainerProperties `json:"storageContainers,omitempty"`
}

var _ genruntime.ARMTransformer = &RoutingEndpoints{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (endpoints *RoutingEndpoints) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if endpoints == nil {
		return nil, nil
	}
	result := &arm.RoutingEndpoints{}

	// Set property "EventHubs":
	for _, item := range endpoints.EventHubs {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.EventHubs = append(result.EventHubs, *item_ARM.(*arm.RoutingEventHubProperties))
	}

	// Set property "ServiceBusQueues":
	for _, item := range endpoints.ServiceBusQueues {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.ServiceBusQueues = append(result.ServiceBusQueues, *item_ARM.(*arm.RoutingServiceBusQueueEndpointProperties))
	}

	// Set property "ServiceBusTopics":
	for _, item := range endpoints.ServiceBusTopics {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.ServiceBusTopics = append(result.ServiceBusTopics, *item_ARM.(*arm.RoutingServiceBusTopicEndpointProperties))
	}

	// Set property "StorageContainers":
	for _, item := range endpoints.StorageContainers {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.StorageContainers = append(result.StorageContainers, *item_ARM.(*arm.RoutingStorageContainerProperties))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (endpoints *RoutingEndpoints) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RoutingEndpoints{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (endpoints *RoutingEndpoints) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RoutingEndpoints)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RoutingEndpoints, got %T", armInput)
	}

	// Set property "EventHubs":
	for _, item := range typedInput.EventHubs {
		var item1 RoutingEventHubProperties
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		endpoints.EventHubs = append(endpoints.EventHubs, item1)
	}

	// Set property "ServiceBusQueues":
	for _, item := range typedInput.ServiceBusQueues {
		var item1 RoutingServiceBusQueueEndpointProperties
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		endpoints.ServiceBusQueues = append(endpoints.ServiceBusQueues, item1)
	}

	// Set property "ServiceBusTopics":
	for _, item := range typedInput.ServiceBusTopics {
		var item1 RoutingServiceBusTopicEndpointProperties
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		endpoints.ServiceBusTopics = append(endpoints.ServiceBusTopics, item1)
	}

	// Set property "StorageContainers":
	for _, item := range typedInput.StorageContainers {
		var item1 RoutingStorageContainerProperties
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		endpoints.StorageContainers = append(endpoints.StorageContainers, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_RoutingEndpoints populates our RoutingEndpoints from the provided source RoutingEndpoints
func (endpoints *RoutingEndpoints) AssignProperties_From_RoutingEndpoints(source *storage.RoutingEndpoints) error {

	// EventHubs
	if source.EventHubs != nil {
		eventHubList := make([]RoutingEventHubProperties, len(source.EventHubs))
		for eventHubIndex, eventHubItem := range source.EventHubs {
			// Shadow the loop variable to avoid aliasing
			eventHubItem := eventHubItem
			var eventHub RoutingEventHubProperties
			err := eventHub.AssignProperties_From_RoutingEventHubProperties(&eventHubItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_RoutingEventHubProperties() to populate field EventHubs")
			}
			eventHubList[eventHubIndex] = eventHub
		}
		endpoints.EventHubs = eventHubList
	} else {
		endpoints.EventHubs = nil
	}

	// ServiceBusQueues
	if source.ServiceBusQueues != nil {
		serviceBusQueueList := make([]RoutingServiceBusQueueEndpointProperties, len(source.ServiceBusQueues))
		for serviceBusQueueIndex, serviceBusQueueItem := range source.ServiceBusQueues {
			// Shadow the loop variable to avoid aliasing
			serviceBusQueueItem := serviceBusQueueItem
			var serviceBusQueue RoutingServiceBusQueueEndpointProperties
			err := serviceBusQueue.AssignProperties_From_RoutingServiceBusQueueEndpointProperties(&serviceBusQueueItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_RoutingServiceBusQueueEndpointProperties() to populate field ServiceBusQueues")
			}
			serviceBusQueueList[serviceBusQueueIndex] = serviceBusQueue
		}
		endpoints.ServiceBusQueues = serviceBusQueueList
	} else {
		endpoints.ServiceBusQueues = nil
	}

	// ServiceBusTopics
	if source.ServiceBusTopics != nil {
		serviceBusTopicList := make([]RoutingServiceBusTopicEndpointProperties, len(source.ServiceBusTopics))
		for serviceBusTopicIndex, serviceBusTopicItem := range source.ServiceBusTopics {
			// Shadow the loop variable to avoid aliasing
			serviceBusTopicItem := serviceBusTopicItem
			var serviceBusTopic RoutingServiceBusTopicEndpointProperties
			err := serviceBusTopic.AssignProperties_From_RoutingServiceBusTopicEndpointProperties(&serviceBusTopicItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_RoutingServiceBusTopicEndpointProperties() to populate field ServiceBusTopics")
			}
			serviceBusTopicList[serviceBusTopicIndex] = serviceBusTopic
		}
		endpoints.ServiceBusTopics = serviceBusTopicList
	} else {
		endpoints.ServiceBusTopics = nil
	}

	// StorageContainers
	if source.StorageContainers != nil {
		storageContainerList := make([]RoutingStorageContainerProperties, len(source.StorageContainers))
		for storageContainerIndex, storageContainerItem := range source.StorageContainers {
			// Shadow the loop variable to avoid aliasing
			storageContainerItem := storageContainerItem
			var storageContainer RoutingStorageContainerProperties
			err := storageContainer.AssignProperties_From_RoutingStorageContainerProperties(&storageContainerItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_RoutingStorageContainerProperties() to populate field StorageContainers")
			}
			storageContainerList[storageContainerIndex] = storageContainer
		}
		endpoints.StorageContainers = storageContainerList
	} else {
		endpoints.StorageContainers = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RoutingEndpoints populates the provided destination RoutingEndpoints from our RoutingEndpoints
func (endpoints *RoutingEndpoints) AssignProperties_To_RoutingEndpoints(destination *storage.RoutingEndpoints) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EventHubs
	if endpoints.EventHubs != nil {
		eventHubList := make([]storage.RoutingEventHubProperties, len(endpoints.EventHubs))
		for eventHubIndex, eventHubItem := range endpoints.EventHubs {
			// Shadow the loop variable to avoid aliasing
			eventHubItem := eventHubItem
			var eventHub storage.RoutingEventHubProperties
			err := eventHubItem.AssignProperties_To_RoutingEventHubProperties(&eventHub)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_RoutingEventHubProperties() to populate field EventHubs")
			}
			eventHubList[eventHubIndex] = eventHub
		}
		destination.EventHubs = eventHubList
	} else {
		destination.EventHubs = nil
	}

	// ServiceBusQueues
	if endpoints.ServiceBusQueues != nil {
		serviceBusQueueList := make([]storage.RoutingServiceBusQueueEndpointProperties, len(endpoints.ServiceBusQueues))
		for serviceBusQueueIndex, serviceBusQueueItem := range endpoints.ServiceBusQueues {
			// Shadow the loop variable to avoid aliasing
			serviceBusQueueItem := serviceBusQueueItem
			var serviceBusQueue storage.RoutingServiceBusQueueEndpointProperties
			err := serviceBusQueueItem.AssignProperties_To_RoutingServiceBusQueueEndpointProperties(&serviceBusQueue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_RoutingServiceBusQueueEndpointProperties() to populate field ServiceBusQueues")
			}
			serviceBusQueueList[serviceBusQueueIndex] = serviceBusQueue
		}
		destination.ServiceBusQueues = serviceBusQueueList
	} else {
		destination.ServiceBusQueues = nil
	}

	// ServiceBusTopics
	if endpoints.ServiceBusTopics != nil {
		serviceBusTopicList := make([]storage.RoutingServiceBusTopicEndpointProperties, len(endpoints.ServiceBusTopics))
		for serviceBusTopicIndex, serviceBusTopicItem := range endpoints.ServiceBusTopics {
			// Shadow the loop variable to avoid aliasing
			serviceBusTopicItem := serviceBusTopicItem
			var serviceBusTopic storage.RoutingServiceBusTopicEndpointProperties
			err := serviceBusTopicItem.AssignProperties_To_RoutingServiceBusTopicEndpointProperties(&serviceBusTopic)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_RoutingServiceBusTopicEndpointProperties() to populate field ServiceBusTopics")
			}
			serviceBusTopicList[serviceBusTopicIndex] = serviceBusTopic
		}
		destination.ServiceBusTopics = serviceBusTopicList
	} else {
		destination.ServiceBusTopics = nil
	}

	// StorageContainers
	if endpoints.StorageContainers != nil {
		storageContainerList := make([]storage.RoutingStorageContainerProperties, len(endpoints.StorageContainers))
		for storageContainerIndex, storageContainerItem := range endpoints.StorageContainers {
			// Shadow the loop variable to avoid aliasing
			storageContainerItem := storageContainerItem
			var storageContainer storage.RoutingStorageContainerProperties
			err := storageContainerItem.AssignProperties_To_RoutingStorageContainerProperties(&storageContainer)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_RoutingStorageContainerProperties() to populate field StorageContainers")
			}
			storageContainerList[storageContainerIndex] = storageContainer
		}
		destination.StorageContainers = storageContainerList
	} else {
		destination.StorageContainers = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RoutingEndpoints_STATUS populates our RoutingEndpoints from the provided source RoutingEndpoints_STATUS
func (endpoints *RoutingEndpoints) Initialize_From_RoutingEndpoints_STATUS(source *RoutingEndpoints_STATUS) error {

	// EventHubs
	if source.EventHubs != nil {
		eventHubList := make([]RoutingEventHubProperties, len(source.EventHubs))
		for eventHubIndex, eventHubItem := range source.EventHubs {
			// Shadow the loop variable to avoid aliasing
			eventHubItem := eventHubItem
			var eventHub RoutingEventHubProperties
			err := eventHub.Initialize_From_RoutingEventHubProperties_STATUS(&eventHubItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_RoutingEventHubProperties_STATUS() to populate field EventHubs")
			}
			eventHubList[eventHubIndex] = eventHub
		}
		endpoints.EventHubs = eventHubList
	} else {
		endpoints.EventHubs = nil
	}

	// ServiceBusQueues
	if source.ServiceBusQueues != nil {
		serviceBusQueueList := make([]RoutingServiceBusQueueEndpointProperties, len(source.ServiceBusQueues))
		for serviceBusQueueIndex, serviceBusQueueItem := range source.ServiceBusQueues {
			// Shadow the loop variable to avoid aliasing
			serviceBusQueueItem := serviceBusQueueItem
			var serviceBusQueue RoutingServiceBusQueueEndpointProperties
			err := serviceBusQueue.Initialize_From_RoutingServiceBusQueueEndpointProperties_STATUS(&serviceBusQueueItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_RoutingServiceBusQueueEndpointProperties_STATUS() to populate field ServiceBusQueues")
			}
			serviceBusQueueList[serviceBusQueueIndex] = serviceBusQueue
		}
		endpoints.ServiceBusQueues = serviceBusQueueList
	} else {
		endpoints.ServiceBusQueues = nil
	}

	// ServiceBusTopics
	if source.ServiceBusTopics != nil {
		serviceBusTopicList := make([]RoutingServiceBusTopicEndpointProperties, len(source.ServiceBusTopics))
		for serviceBusTopicIndex, serviceBusTopicItem := range source.ServiceBusTopics {
			// Shadow the loop variable to avoid aliasing
			serviceBusTopicItem := serviceBusTopicItem
			var serviceBusTopic RoutingServiceBusTopicEndpointProperties
			err := serviceBusTopic.Initialize_From_RoutingServiceBusTopicEndpointProperties_STATUS(&serviceBusTopicItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_RoutingServiceBusTopicEndpointProperties_STATUS() to populate field ServiceBusTopics")
			}
			serviceBusTopicList[serviceBusTopicIndex] = serviceBusTopic
		}
		endpoints.ServiceBusTopics = serviceBusTopicList
	} else {
		endpoints.ServiceBusTopics = nil
	}

	// StorageContainers
	if source.StorageContainers != nil {
		storageContainerList := make([]RoutingStorageContainerProperties, len(source.StorageContainers))
		for storageContainerIndex, storageContainerItem := range source.StorageContainers {
			// Shadow the loop variable to avoid aliasing
			storageContainerItem := storageContainerItem
			var storageContainer RoutingStorageContainerProperties
			err := storageContainer.Initialize_From_RoutingStorageContainerProperties_STATUS(&storageContainerItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_RoutingStorageContainerProperties_STATUS() to populate field StorageContainers")
			}
			storageContainerList[storageContainerIndex] = storageContainer
		}
		endpoints.StorageContainers = storageContainerList
	} else {
		endpoints.StorageContainers = nil
	}

	// No error
	return nil
}

// The properties related to the custom endpoints to which your IoT hub routes messages based on the routing rules. A
// maximum of 10 custom endpoints are allowed across all endpoint types for paid hubs and only 1 custom endpoint is allowed
// across all endpoint types for free hubs.
type RoutingEndpoints_STATUS struct {
	// EventHubs: The list of Event Hubs endpoints that IoT hub routes messages to, based on the routing rules. This list does
	// not include the built-in Event Hubs endpoint.
	EventHubs []RoutingEventHubProperties_STATUS `json:"eventHubs,omitempty"`

	// ServiceBusQueues: The list of Service Bus queue endpoints that IoT hub routes the messages to, based on the routing
	// rules.
	ServiceBusQueues []RoutingServiceBusQueueEndpointProperties_STATUS `json:"serviceBusQueues,omitempty"`

	// ServiceBusTopics: The list of Service Bus topic endpoints that the IoT hub routes the messages to, based on the routing
	// rules.
	ServiceBusTopics []RoutingServiceBusTopicEndpointProperties_STATUS `json:"serviceBusTopics,omitempty"`

	// StorageContainers: The list of storage container endpoints that IoT hub routes messages to, based on the routing rules.
	StorageContainers []RoutingStorageContainerProperties_STATUS `json:"storageContainers,omitempty"`
}

var _ genruntime.FromARMConverter = &RoutingEndpoints_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (endpoints *RoutingEndpoints_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RoutingEndpoints_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (endpoints *RoutingEndpoints_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RoutingEndpoints_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RoutingEndpoints_STATUS, got %T", armInput)
	}

	// Set property "EventHubs":
	for _, item := range typedInput.EventHubs {
		var item1 RoutingEventHubProperties_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		endpoints.EventHubs = append(endpoints.EventHubs, item1)
	}

	// Set property "ServiceBusQueues":
	for _, item := range typedInput.ServiceBusQueues {
		var item1 RoutingServiceBusQueueEndpointProperties_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		endpoints.ServiceBusQueues = append(endpoints.ServiceBusQueues, item1)
	}

	// Set property "ServiceBusTopics":
	for _, item := range typedInput.ServiceBusTopics {
		var item1 RoutingServiceBusTopicEndpointProperties_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		endpoints.ServiceBusTopics = append(endpoints.ServiceBusTopics, item1)
	}

	// Set property "StorageContainers":
	for _, item := range typedInput.StorageContainers {
		var item1 RoutingStorageContainerProperties_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		endpoints.StorageContainers = append(endpoints.StorageContainers, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_RoutingEndpoints_STATUS populates our RoutingEndpoints_STATUS from the provided source RoutingEndpoints_STATUS
func (endpoints *RoutingEndpoints_STATUS) AssignProperties_From_RoutingEndpoints_STATUS(source *storage.RoutingEndpoints_STATUS) error {

	// EventHubs
	if source.EventHubs != nil {
		eventHubList := make([]RoutingEventHubProperties_STATUS, len(source.EventHubs))
		for eventHubIndex, eventHubItem := range source.EventHubs {
			// Shadow the loop variable to avoid aliasing
			eventHubItem := eventHubItem
			var eventHub RoutingEventHubProperties_STATUS
			err := eventHub.AssignProperties_From_RoutingEventHubProperties_STATUS(&eventHubItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_RoutingEventHubProperties_STATUS() to populate field EventHubs")
			}
			eventHubList[eventHubIndex] = eventHub
		}
		endpoints.EventHubs = eventHubList
	} else {
		endpoints.EventHubs = nil
	}

	// ServiceBusQueues
	if source.ServiceBusQueues != nil {
		serviceBusQueueList := make([]RoutingServiceBusQueueEndpointProperties_STATUS, len(source.ServiceBusQueues))
		for serviceBusQueueIndex, serviceBusQueueItem := range source.ServiceBusQueues {
			// Shadow the loop variable to avoid aliasing
			serviceBusQueueItem := serviceBusQueueItem
			var serviceBusQueue RoutingServiceBusQueueEndpointProperties_STATUS
			err := serviceBusQueue.AssignProperties_From_RoutingServiceBusQueueEndpointProperties_STATUS(&serviceBusQueueItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_RoutingServiceBusQueueEndpointProperties_STATUS() to populate field ServiceBusQueues")
			}
			serviceBusQueueList[serviceBusQueueIndex] = serviceBusQueue
		}
		endpoints.ServiceBusQueues = serviceBusQueueList
	} else {
		endpoints.ServiceBusQueues = nil
	}

	// ServiceBusTopics
	if source.ServiceBusTopics != nil {
		serviceBusTopicList := make([]RoutingServiceBusTopicEndpointProperties_STATUS, len(source.ServiceBusTopics))
		for serviceBusTopicIndex, serviceBusTopicItem := range source.ServiceBusTopics {
			// Shadow the loop variable to avoid aliasing
			serviceBusTopicItem := serviceBusTopicItem
			var serviceBusTopic RoutingServiceBusTopicEndpointProperties_STATUS
			err := serviceBusTopic.AssignProperties_From_RoutingServiceBusTopicEndpointProperties_STATUS(&serviceBusTopicItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_RoutingServiceBusTopicEndpointProperties_STATUS() to populate field ServiceBusTopics")
			}
			serviceBusTopicList[serviceBusTopicIndex] = serviceBusTopic
		}
		endpoints.ServiceBusTopics = serviceBusTopicList
	} else {
		endpoints.ServiceBusTopics = nil
	}

	// StorageContainers
	if source.StorageContainers != nil {
		storageContainerList := make([]RoutingStorageContainerProperties_STATUS, len(source.StorageContainers))
		for storageContainerIndex, storageContainerItem := range source.StorageContainers {
			// Shadow the loop variable to avoid aliasing
			storageContainerItem := storageContainerItem
			var storageContainer RoutingStorageContainerProperties_STATUS
			err := storageContainer.AssignProperties_From_RoutingStorageContainerProperties_STATUS(&storageContainerItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_RoutingStorageContainerProperties_STATUS() to populate field StorageContainers")
			}
			storageContainerList[storageContainerIndex] = storageContainer
		}
		endpoints.StorageContainers = storageContainerList
	} else {
		endpoints.StorageContainers = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RoutingEndpoints_STATUS populates the provided destination RoutingEndpoints_STATUS from our RoutingEndpoints_STATUS
func (endpoints *RoutingEndpoints_STATUS) AssignProperties_To_RoutingEndpoints_STATUS(destination *storage.RoutingEndpoints_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EventHubs
	if endpoints.EventHubs != nil {
		eventHubList := make([]storage.RoutingEventHubProperties_STATUS, len(endpoints.EventHubs))
		for eventHubIndex, eventHubItem := range endpoints.EventHubs {
			// Shadow the loop variable to avoid aliasing
			eventHubItem := eventHubItem
			var eventHub storage.RoutingEventHubProperties_STATUS
			err := eventHubItem.AssignProperties_To_RoutingEventHubProperties_STATUS(&eventHub)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_RoutingEventHubProperties_STATUS() to populate field EventHubs")
			}
			eventHubList[eventHubIndex] = eventHub
		}
		destination.EventHubs = eventHubList
	} else {
		destination.EventHubs = nil
	}

	// ServiceBusQueues
	if endpoints.ServiceBusQueues != nil {
		serviceBusQueueList := make([]storage.RoutingServiceBusQueueEndpointProperties_STATUS, len(endpoints.ServiceBusQueues))
		for serviceBusQueueIndex, serviceBusQueueItem := range endpoints.ServiceBusQueues {
			// Shadow the loop variable to avoid aliasing
			serviceBusQueueItem := serviceBusQueueItem
			var serviceBusQueue storage.RoutingServiceBusQueueEndpointProperties_STATUS
			err := serviceBusQueueItem.AssignProperties_To_RoutingServiceBusQueueEndpointProperties_STATUS(&serviceBusQueue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_RoutingServiceBusQueueEndpointProperties_STATUS() to populate field ServiceBusQueues")
			}
			serviceBusQueueList[serviceBusQueueIndex] = serviceBusQueue
		}
		destination.ServiceBusQueues = serviceBusQueueList
	} else {
		destination.ServiceBusQueues = nil
	}

	// ServiceBusTopics
	if endpoints.ServiceBusTopics != nil {
		serviceBusTopicList := make([]storage.RoutingServiceBusTopicEndpointProperties_STATUS, len(endpoints.ServiceBusTopics))
		for serviceBusTopicIndex, serviceBusTopicItem := range endpoints.ServiceBusTopics {
			// Shadow the loop variable to avoid aliasing
			serviceBusTopicItem := serviceBusTopicItem
			var serviceBusTopic storage.RoutingServiceBusTopicEndpointProperties_STATUS
			err := serviceBusTopicItem.AssignProperties_To_RoutingServiceBusTopicEndpointProperties_STATUS(&serviceBusTopic)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_RoutingServiceBusTopicEndpointProperties_STATUS() to populate field ServiceBusTopics")
			}
			serviceBusTopicList[serviceBusTopicIndex] = serviceBusTopic
		}
		destination.ServiceBusTopics = serviceBusTopicList
	} else {
		destination.ServiceBusTopics = nil
	}

	// StorageContainers
	if endpoints.StorageContainers != nil {
		storageContainerList := make([]storage.RoutingStorageContainerProperties_STATUS, len(endpoints.StorageContainers))
		for storageContainerIndex, storageContainerItem := range endpoints.StorageContainers {
			// Shadow the loop variable to avoid aliasing
			storageContainerItem := storageContainerItem
			var storageContainer storage.RoutingStorageContainerProperties_STATUS
			err := storageContainerItem.AssignProperties_To_RoutingStorageContainerProperties_STATUS(&storageContainer)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_RoutingStorageContainerProperties_STATUS() to populate field StorageContainers")
			}
			storageContainerList[storageContainerIndex] = storageContainer
		}
		destination.StorageContainers = storageContainerList
	} else {
		destination.StorageContainers = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"DeviceConnect","RegistryRead","RegistryRead, DeviceConnect","RegistryRead, RegistryWrite","RegistryRead, RegistryWrite, DeviceConnect","RegistryRead, RegistryWrite, ServiceConnect","RegistryRead, RegistryWrite, ServiceConnect, DeviceConnect","RegistryRead, ServiceConnect","RegistryRead, ServiceConnect, DeviceConnect","RegistryWrite","RegistryWrite, DeviceConnect","RegistryWrite, ServiceConnect","RegistryWrite, ServiceConnect, DeviceConnect","ServiceConnect","ServiceConnect, DeviceConnect"}
type SharedAccessSignatureAuthorizationRule_Rights string

const (
	SharedAccessSignatureAuthorizationRule_Rights_DeviceConnect                                        = SharedAccessSignatureAuthorizationRule_Rights("DeviceConnect")
	SharedAccessSignatureAuthorizationRule_Rights_RegistryRead                                         = SharedAccessSignatureAuthorizationRule_Rights("RegistryRead")
	SharedAccessSignatureAuthorizationRule_Rights_RegistryReadDeviceConnect                            = SharedAccessSignatureAuthorizationRule_Rights("RegistryRead, DeviceConnect")
	SharedAccessSignatureAuthorizationRule_Rights_RegistryReadRegistryWrite                            = SharedAccessSignatureAuthorizationRule_Rights("RegistryRead, RegistryWrite")
	SharedAccessSignatureAuthorizationRule_Rights_RegistryReadRegistryWriteDeviceConnect               = SharedAccessSignatureAuthorizationRule_Rights("RegistryRead, RegistryWrite, DeviceConnect")
	SharedAccessSignatureAuthorizationRule_Rights_RegistryReadRegistryWriteServiceConnect              = SharedAccessSignatureAuthorizationRule_Rights("RegistryRead, RegistryWrite, ServiceConnect")
	SharedAccessSignatureAuthorizationRule_Rights_RegistryReadRegistryWriteServiceConnectDeviceConnect = SharedAccessSignatureAuthorizationRule_Rights("RegistryRead, RegistryWrite, ServiceConnect, DeviceConnect")
	SharedAccessSignatureAuthorizationRule_Rights_RegistryReadServiceConnect                           = SharedAccessSignatureAuthorizationRule_Rights("RegistryRead, ServiceConnect")
	SharedAccessSignatureAuthorizationRule_Rights_RegistryReadServiceConnectDeviceConnect              = SharedAccessSignatureAuthorizationRule_Rights("RegistryRead, ServiceConnect, DeviceConnect")
	SharedAccessSignatureAuthorizationRule_Rights_RegistryWrite                                        = SharedAccessSignatureAuthorizationRule_Rights("RegistryWrite")
	SharedAccessSignatureAuthorizationRule_Rights_RegistryWriteDeviceConnect                           = SharedAccessSignatureAuthorizationRule_Rights("RegistryWrite, DeviceConnect")
	SharedAccessSignatureAuthorizationRule_Rights_RegistryWriteServiceConnect                          = SharedAccessSignatureAuthorizationRule_Rights("RegistryWrite, ServiceConnect")
	SharedAccessSignatureAuthorizationRule_Rights_RegistryWriteServiceConnectDeviceConnect             = SharedAccessSignatureAuthorizationRule_Rights("RegistryWrite, ServiceConnect, DeviceConnect")
	SharedAccessSignatureAuthorizationRule_Rights_ServiceConnect                                       = SharedAccessSignatureAuthorizationRule_Rights("ServiceConnect")
	SharedAccessSignatureAuthorizationRule_Rights_ServiceConnectDeviceConnect                          = SharedAccessSignatureAuthorizationRule_Rights("ServiceConnect, DeviceConnect")
)

// Mapping from string to SharedAccessSignatureAuthorizationRule_Rights
var sharedAccessSignatureAuthorizationRule_Rights_Values = map[string]SharedAccessSignatureAuthorizationRule_Rights{
	"deviceconnect":                                              SharedAccessSignatureAuthorizationRule_Rights_DeviceConnect,
	"registryread":                                               SharedAccessSignatureAuthorizationRule_Rights_RegistryRead,
	"registryread, deviceconnect":                                SharedAccessSignatureAuthorizationRule_Rights_RegistryReadDeviceConnect,
	"registryread, registrywrite":                                SharedAccessSignatureAuthorizationRule_Rights_RegistryReadRegistryWrite,
	"registryread, registrywrite, deviceconnect":                 SharedAccessSignatureAuthorizationRule_Rights_RegistryReadRegistryWriteDeviceConnect,
	"registryread, registrywrite, serviceconnect":                SharedAccessSignatureAuthorizationRule_Rights_RegistryReadRegistryWriteServiceConnect,
	"registryread, registrywrite, serviceconnect, deviceconnect": SharedAccessSignatureAuthorizationRule_Rights_RegistryReadRegistryWriteServiceConnectDeviceConnect,
	"registryread, serviceconnect":                               SharedAccessSignatureAuthorizationRule_Rights_RegistryReadServiceConnect,
	"registryread, serviceconnect, deviceconnect":                SharedAccessSignatureAuthorizationRule_Rights_RegistryReadServiceConnectDeviceConnect,
	"registrywrite":                                              SharedAccessSignatureAuthorizationRule_Rights_RegistryWrite,
	"registrywrite, deviceconnect":                               SharedAccessSignatureAuthorizationRule_Rights_RegistryWriteDeviceConnect,
	"registrywrite, serviceconnect":                              SharedAccessSignatureAuthorizationRule_Rights_RegistryWriteServiceConnect,
	"registrywrite, serviceconnect, deviceconnect":               SharedAccessSignatureAuthorizationRule_Rights_RegistryWriteServiceConnectDeviceConnect,
	"serviceconnect":                                             SharedAccessSignatureAuthorizationRule_Rights_ServiceConnect,
	"serviceconnect, deviceconnect":                              SharedAccessSignatureAuthorizationRule_Rights_ServiceConnectDeviceConnect,
}

type SharedAccessSignatureAuthorizationRule_Rights_STATUS string

const (
	SharedAccessSignatureAuthorizationRule_Rights_STATUS_DeviceConnect                                        = SharedAccessSignatureAuthorizationRule_Rights_STATUS("DeviceConnect")
	SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryRead                                         = SharedAccessSignatureAuthorizationRule_Rights_STATUS("RegistryRead")
	SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryReadDeviceConnect                            = SharedAccessSignatureAuthorizationRule_Rights_STATUS("RegistryRead, DeviceConnect")
	SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryReadRegistryWrite                            = SharedAccessSignatureAuthorizationRule_Rights_STATUS("RegistryRead, RegistryWrite")
	SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryReadRegistryWriteDeviceConnect               = SharedAccessSignatureAuthorizationRule_Rights_STATUS("RegistryRead, RegistryWrite, DeviceConnect")
	SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryReadRegistryWriteServiceConnect              = SharedAccessSignatureAuthorizationRule_Rights_STATUS("RegistryRead, RegistryWrite, ServiceConnect")
	SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryReadRegistryWriteServiceConnectDeviceConnect = SharedAccessSignatureAuthorizationRule_Rights_STATUS("RegistryRead, RegistryWrite, ServiceConnect, DeviceConnect")
	SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryReadServiceConnect                           = SharedAccessSignatureAuthorizationRule_Rights_STATUS("RegistryRead, ServiceConnect")
	SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryReadServiceConnectDeviceConnect              = SharedAccessSignatureAuthorizationRule_Rights_STATUS("RegistryRead, ServiceConnect, DeviceConnect")
	SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryWrite                                        = SharedAccessSignatureAuthorizationRule_Rights_STATUS("RegistryWrite")
	SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryWriteDeviceConnect                           = SharedAccessSignatureAuthorizationRule_Rights_STATUS("RegistryWrite, DeviceConnect")
	SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryWriteServiceConnect                          = SharedAccessSignatureAuthorizationRule_Rights_STATUS("RegistryWrite, ServiceConnect")
	SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryWriteServiceConnectDeviceConnect             = SharedAccessSignatureAuthorizationRule_Rights_STATUS("RegistryWrite, ServiceConnect, DeviceConnect")
	SharedAccessSignatureAuthorizationRule_Rights_STATUS_ServiceConnect                                       = SharedAccessSignatureAuthorizationRule_Rights_STATUS("ServiceConnect")
	SharedAccessSignatureAuthorizationRule_Rights_STATUS_ServiceConnectDeviceConnect                          = SharedAccessSignatureAuthorizationRule_Rights_STATUS("ServiceConnect, DeviceConnect")
)

// Mapping from string to SharedAccessSignatureAuthorizationRule_Rights_STATUS
var sharedAccessSignatureAuthorizationRule_Rights_STATUS_Values = map[string]SharedAccessSignatureAuthorizationRule_Rights_STATUS{
	"deviceconnect":                                              SharedAccessSignatureAuthorizationRule_Rights_STATUS_DeviceConnect,
	"registryread":                                               SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryRead,
	"registryread, deviceconnect":                                SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryReadDeviceConnect,
	"registryread, registrywrite":                                SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryReadRegistryWrite,
	"registryread, registrywrite, deviceconnect":                 SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryReadRegistryWriteDeviceConnect,
	"registryread, registrywrite, serviceconnect":                SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryReadRegistryWriteServiceConnect,
	"registryread, registrywrite, serviceconnect, deviceconnect": SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryReadRegistryWriteServiceConnectDeviceConnect,
	"registryread, serviceconnect":                               SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryReadServiceConnect,
	"registryread, serviceconnect, deviceconnect":                SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryReadServiceConnectDeviceConnect,
	"registrywrite":                                              SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryWrite,
	"registrywrite, deviceconnect":                               SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryWriteDeviceConnect,
	"registrywrite, serviceconnect":                              SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryWriteServiceConnect,
	"registrywrite, serviceconnect, deviceconnect":               SharedAccessSignatureAuthorizationRule_Rights_STATUS_RegistryWriteServiceConnectDeviceConnect,
	"serviceconnect":                                             SharedAccessSignatureAuthorizationRule_Rights_STATUS_ServiceConnect,
	"serviceconnect, deviceconnect":                              SharedAccessSignatureAuthorizationRule_Rights_STATUS_ServiceConnectDeviceConnect,
}

// +kubebuilder:validation:Enum={"identityBased","keyBased"}
type StorageEndpointProperties_AuthenticationType string

const (
	StorageEndpointProperties_AuthenticationType_IdentityBased = StorageEndpointProperties_AuthenticationType("identityBased")
	StorageEndpointProperties_AuthenticationType_KeyBased      = StorageEndpointProperties_AuthenticationType("keyBased")
)

// Mapping from string to StorageEndpointProperties_AuthenticationType
var storageEndpointProperties_AuthenticationType_Values = map[string]StorageEndpointProperties_AuthenticationType{
	"identitybased": StorageEndpointProperties_AuthenticationType_IdentityBased,
	"keybased":      StorageEndpointProperties_AuthenticationType_KeyBased,
}

type StorageEndpointProperties_AuthenticationType_STATUS string

const (
	StorageEndpointProperties_AuthenticationType_STATUS_IdentityBased = StorageEndpointProperties_AuthenticationType_STATUS("identityBased")
	StorageEndpointProperties_AuthenticationType_STATUS_KeyBased      = StorageEndpointProperties_AuthenticationType_STATUS("keyBased")
)

// Mapping from string to StorageEndpointProperties_AuthenticationType_STATUS
var storageEndpointProperties_AuthenticationType_STATUS_Values = map[string]StorageEndpointProperties_AuthenticationType_STATUS{
	"identitybased": StorageEndpointProperties_AuthenticationType_STATUS_IdentityBased,
	"keybased":      StorageEndpointProperties_AuthenticationType_STATUS_KeyBased,
}

// +kubebuilder:validation:Enum={"DeviceMessages"}
type FallbackRouteProperties_Source string

const FallbackRouteProperties_Source_DeviceMessages = FallbackRouteProperties_Source("DeviceMessages")

// Mapping from string to FallbackRouteProperties_Source
var fallbackRouteProperties_Source_Values = map[string]FallbackRouteProperties_Source{
	"devicemessages": FallbackRouteProperties_Source_DeviceMessages,
}

type FallbackRouteProperties_Source_STATUS string

const FallbackRouteProperties_Source_STATUS_DeviceMessages = FallbackRouteProperties_Source_STATUS("DeviceMessages")

// Mapping from string to FallbackRouteProperties_Source_STATUS
var fallbackRouteProperties_Source_STATUS_Values = map[string]FallbackRouteProperties_Source_STATUS{
	"devicemessages": FallbackRouteProperties_Source_STATUS_DeviceMessages,
}

// +kubebuilder:validation:Enum={"Allow"}
type NetworkRuleSetIpRule_Action string

const NetworkRuleSetIpRule_Action_Allow = NetworkRuleSetIpRule_Action("Allow")

// Mapping from string to NetworkRuleSetIpRule_Action
var networkRuleSetIpRule_Action_Values = map[string]NetworkRuleSetIpRule_Action{
	"allow": NetworkRuleSetIpRule_Action_Allow,
}

type NetworkRuleSetIpRule_Action_STATUS string

const NetworkRuleSetIpRule_Action_STATUS_Allow = NetworkRuleSetIpRule_Action_STATUS("Allow")

// Mapping from string to NetworkRuleSetIpRule_Action_STATUS
var networkRuleSetIpRule_Action_STATUS_Values = map[string]NetworkRuleSetIpRule_Action_STATUS{
	"allow": NetworkRuleSetIpRule_Action_STATUS_Allow,
}

// +kubebuilder:validation:Enum={"DeviceConnectionStateEvents","DeviceJobLifecycleEvents","DeviceLifecycleEvents","DeviceMessages","Invalid","TwinChangeEvents"}
type RouteProperties_Source string

const (
	RouteProperties_Source_DeviceConnectionStateEvents = RouteProperties_Source("DeviceConnectionStateEvents")
	RouteProperties_Source_DeviceJobLifecycleEvents    = RouteProperties_Source("DeviceJobLifecycleEvents")
	RouteProperties_Source_DeviceLifecycleEvents       = RouteProperties_Source("DeviceLifecycleEvents")
	RouteProperties_Source_DeviceMessages              = RouteProperties_Source("DeviceMessages")
	RouteProperties_Source_Invalid                     = RouteProperties_Source("Invalid")
	RouteProperties_Source_TwinChangeEvents            = RouteProperties_Source("TwinChangeEvents")
)

// Mapping from string to RouteProperties_Source
var routeProperties_Source_Values = map[string]RouteProperties_Source{
	"deviceconnectionstateevents": RouteProperties_Source_DeviceConnectionStateEvents,
	"devicejoblifecycleevents":    RouteProperties_Source_DeviceJobLifecycleEvents,
	"devicelifecycleevents":       RouteProperties_Source_DeviceLifecycleEvents,
	"devicemessages":              RouteProperties_Source_DeviceMessages,
	"invalid":                     RouteProperties_Source_Invalid,
	"twinchangeevents":            RouteProperties_Source_TwinChangeEvents,
}

type RouteProperties_Source_STATUS string

const (
	RouteProperties_Source_STATUS_DeviceConnectionStateEvents = RouteProperties_Source_STATUS("DeviceConnectionStateEvents")
	RouteProperties_Source_STATUS_DeviceJobLifecycleEvents    = RouteProperties_Source_STATUS("DeviceJobLifecycleEvents")
	RouteProperties_Source_STATUS_DeviceLifecycleEvents       = RouteProperties_Source_STATUS("DeviceLifecycleEvents")
	RouteProperties_Source_STATUS_DeviceMessages              = RouteProperties_Source_STATUS("DeviceMessages")
	RouteProperties_Source_STATUS_Invalid                     = RouteProperties_Source_STATUS("Invalid")
	RouteProperties_Source_STATUS_TwinChangeEvents            = RouteProperties_Source_STATUS("TwinChangeEvents")
)

// Mapping from string to RouteProperties_Source_STATUS
var routeProperties_Source_STATUS_Values = map[string]RouteProperties_Source_STATUS{
	"deviceconnectionstateevents": RouteProperties_Source_STATUS_DeviceConnectionStateEvents,
	"devicejoblifecycleevents":    RouteProperties_Source_STATUS_DeviceJobLifecycleEvents,
	"devicelifecycleevents":       RouteProperties_Source_STATUS_DeviceLifecycleEvents,
	"devicemessages":              RouteProperties_Source_STATUS_DeviceMessages,
	"invalid":                     RouteProperties_Source_STATUS_Invalid,
	"twinchangeevents":            RouteProperties_Source_STATUS_TwinChangeEvents,
}

// The properties related to an event hub endpoint.
type RoutingEventHubProperties struct {
	// AuthenticationType: Method used to authenticate against the event hub endpoint
	AuthenticationType *RoutingEventHubProperties_AuthenticationType `json:"authenticationType,omitempty"`

	// ConnectionString: The connection string of the event hub endpoint.
	ConnectionString *genruntime.SecretReference `json:"connectionString,omitempty"`

	// EndpointUri: The url of the event hub endpoint. It must include the protocol sb://
	EndpointUri *string `json:"endpointUri,omitempty"`

	// EntityPath: Event hub name on the event hub namespace
	EntityPath *string `json:"entityPath,omitempty"`

	// Identity: Managed identity properties of routing event hub endpoint.
	Identity *ManagedIdentity `json:"identity,omitempty"`

	// +kubebuilder:validation:Required
	// +kubebuilder:validation:Pattern="^[A-Za-z0-9-._]{1,64}$"
	// Name: The name that identifies this endpoint. The name can only include alphanumeric characters, periods, underscores,
	// hyphens and has a maximum length of 64 characters. The following names are reserved:  events, fileNotifications,
	// $default. Endpoint names must be unique across endpoint types.
	Name *string `json:"name,omitempty"`

	// Reference: Id of the event hub endpoint
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`

	// ResourceGroup: The name of the resource group of the event hub endpoint.
	ResourceGroup *string `json:"resourceGroup,omitempty"`

	// SubscriptionId: The subscription identifier of the event hub endpoint.
	SubscriptionId *string `json:"subscriptionId,omitempty"`
}

var _ genruntime.ARMTransformer = &RoutingEventHubProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *RoutingEventHubProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.RoutingEventHubProperties{}

	// Set property "AuthenticationType":
	if properties.AuthenticationType != nil {
		var temp string
		temp = string(*properties.AuthenticationType)
		authenticationType := arm.RoutingEventHubProperties_AuthenticationType(temp)
		result.AuthenticationType = &authenticationType
	}

	// Set property "ConnectionString":
	if properties.ConnectionString != nil {
		connectionStringSecret, err := resolved.ResolvedSecrets.Lookup(*properties.ConnectionString)
		if err != nil {
			return nil, eris.Wrap(err, "looking up secret for property ConnectionString")
		}
		connectionString := connectionStringSecret
		result.ConnectionString = &connectionString
	}

	// Set property "EndpointUri":
	if properties.EndpointUri != nil {
		endpointUri := *properties.EndpointUri
		result.EndpointUri = &endpointUri
	}

	// Set property "EntityPath":
	if properties.EntityPath != nil {
		entityPath := *properties.EntityPath
		result.EntityPath = &entityPath
	}

	// Set property "Id":
	if properties.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*properties.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property "Identity":
	if properties.Identity != nil {
		identity_ARM, err := (*properties.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*arm.ManagedIdentity)
		result.Identity = &identity
	}

	// Set property "Name":
	if properties.Name != nil {
		name := *properties.Name
		result.Name = &name
	}

	// Set property "ResourceGroup":
	if properties.ResourceGroup != nil {
		resourceGroup := *properties.ResourceGroup
		result.ResourceGroup = &resourceGroup
	}

	// Set property "SubscriptionId":
	if properties.SubscriptionId != nil {
		subscriptionId := *properties.SubscriptionId
		result.SubscriptionId = &subscriptionId
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *RoutingEventHubProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RoutingEventHubProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *RoutingEventHubProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RoutingEventHubProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RoutingEventHubProperties, got %T", armInput)
	}

	// Set property "AuthenticationType":
	if typedInput.AuthenticationType != nil {
		var temp string
		temp = string(*typedInput.AuthenticationType)
		authenticationType := RoutingEventHubProperties_AuthenticationType(temp)
		properties.AuthenticationType = &authenticationType
	}

	// no assignment for property "ConnectionString"

	// Set property "EndpointUri":
	if typedInput.EndpointUri != nil {
		endpointUri := *typedInput.EndpointUri
		properties.EndpointUri = &endpointUri
	}

	// Set property "EntityPath":
	if typedInput.EntityPath != nil {
		entityPath := *typedInput.EntityPath
		properties.EntityPath = &entityPath
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		properties.Identity = &identity
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		properties.Name = &name
	}

	// no assignment for property "Reference"

	// Set property "ResourceGroup":
	if typedInput.ResourceGroup != nil {
		resourceGroup := *typedInput.ResourceGroup
		properties.ResourceGroup = &resourceGroup
	}

	// Set property "SubscriptionId":
	if typedInput.SubscriptionId != nil {
		subscriptionId := *typedInput.SubscriptionId
		properties.SubscriptionId = &subscriptionId
	}

	// No error
	return nil
}

// AssignProperties_From_RoutingEventHubProperties populates our RoutingEventHubProperties from the provided source RoutingEventHubProperties
func (properties *RoutingEventHubProperties) AssignProperties_From_RoutingEventHubProperties(source *storage.RoutingEventHubProperties) error {

	// AuthenticationType
	if source.AuthenticationType != nil {
		authenticationType := *source.AuthenticationType
		authenticationTypeTemp := genruntime.ToEnum(authenticationType, routingEventHubProperties_AuthenticationType_Values)
		properties.AuthenticationType = &authenticationTypeTemp
	} else {
		properties.AuthenticationType = nil
	}

	// ConnectionString
	if source.ConnectionString != nil {
		connectionString := source.ConnectionString.Copy()
		properties.ConnectionString = &connectionString
	} else {
		properties.ConnectionString = nil
	}

	// EndpointUri
	properties.EndpointUri = genruntime.ClonePointerToString(source.EndpointUri)

	// EntityPath
	properties.EntityPath = genruntime.ClonePointerToString(source.EntityPath)

	// Identity
	if source.Identity != nil {
		var identity ManagedIdentity
		err := identity.AssignProperties_From_ManagedIdentity(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedIdentity() to populate field Identity")
		}
		properties.Identity = &identity
	} else {
		properties.Identity = nil
	}

	// Name
	properties.Name = genruntime.ClonePointerToString(source.Name)

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		properties.Reference = &reference
	} else {
		properties.Reference = nil
	}

	// ResourceGroup
	properties.ResourceGroup = genruntime.ClonePointerToString(source.ResourceGroup)

	// SubscriptionId
	properties.SubscriptionId = genruntime.ClonePointerToString(source.SubscriptionId)

	// No error
	return nil
}

// AssignProperties_To_RoutingEventHubProperties populates the provided destination RoutingEventHubProperties from our RoutingEventHubProperties
func (properties *RoutingEventHubProperties) AssignProperties_To_RoutingEventHubProperties(destination *storage.RoutingEventHubProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthenticationType
	if properties.AuthenticationType != nil {
		authenticationType := string(*properties.AuthenticationType)
		destination.AuthenticationType = &authenticationType
	} else {
		destination.AuthenticationType = nil
	}

	// ConnectionString
	if properties.ConnectionString != nil {
		connectionString := properties.ConnectionString.Copy()
		destination.ConnectionString = &connectionString
	} else {
		destination.ConnectionString = nil
	}

	// EndpointUri
	destination.EndpointUri = genruntime.ClonePointerToString(properties.EndpointUri)

	// EntityPath
	destination.EntityPath = genruntime.ClonePointerToString(properties.EntityPath)

	// Identity
	if properties.Identity != nil {
		var identity storage.ManagedIdentity
		err := properties.Identity.AssignProperties_To_ManagedIdentity(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(properties.Name)

	// Reference
	if properties.Reference != nil {
		reference := properties.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// ResourceGroup
	destination.ResourceGroup = genruntime.ClonePointerToString(properties.ResourceGroup)

	// SubscriptionId
	destination.SubscriptionId = genruntime.ClonePointerToString(properties.SubscriptionId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RoutingEventHubProperties_STATUS populates our RoutingEventHubProperties from the provided source RoutingEventHubProperties_STATUS
func (properties *RoutingEventHubProperties) Initialize_From_RoutingEventHubProperties_STATUS(source *RoutingEventHubProperties_STATUS) error {

	// AuthenticationType
	if source.AuthenticationType != nil {
		authenticationType := genruntime.ToEnum(string(*source.AuthenticationType), routingEventHubProperties_AuthenticationType_Values)
		properties.AuthenticationType = &authenticationType
	} else {
		properties.AuthenticationType = nil
	}

	// EndpointUri
	properties.EndpointUri = genruntime.ClonePointerToString(source.EndpointUri)

	// EntityPath
	properties.EntityPath = genruntime.ClonePointerToString(source.EntityPath)

	// Identity
	if source.Identity != nil {
		var identity ManagedIdentity
		err := identity.Initialize_From_ManagedIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ManagedIdentity_STATUS() to populate field Identity")
		}
		properties.Identity = &identity
	} else {
		properties.Identity = nil
	}

	// Name
	properties.Name = genruntime.ClonePointerToString(source.Name)

	// Reference
	if source.Id != nil {
		reference := genruntime.CreateResourceReferenceFromARMID(*source.Id)
		properties.Reference = &reference
	} else {
		properties.Reference = nil
	}

	// ResourceGroup
	properties.ResourceGroup = genruntime.ClonePointerToString(source.ResourceGroup)

	// SubscriptionId
	properties.SubscriptionId = genruntime.ClonePointerToString(source.SubscriptionId)

	// No error
	return nil
}

// The properties related to an event hub endpoint.
type RoutingEventHubProperties_STATUS struct {
	// AuthenticationType: Method used to authenticate against the event hub endpoint
	AuthenticationType *RoutingEventHubProperties_AuthenticationType_STATUS `json:"authenticationType,omitempty"`

	// EndpointUri: The url of the event hub endpoint. It must include the protocol sb://
	EndpointUri *string `json:"endpointUri,omitempty"`

	// EntityPath: Event hub name on the event hub namespace
	EntityPath *string `json:"entityPath,omitempty"`

	// Id: Id of the event hub endpoint
	Id *string `json:"id,omitempty"`

	// Identity: Managed identity properties of routing event hub endpoint.
	Identity *ManagedIdentity_STATUS `json:"identity,omitempty"`

	// Name: The name that identifies this endpoint. The name can only include alphanumeric characters, periods, underscores,
	// hyphens and has a maximum length of 64 characters. The following names are reserved:  events, fileNotifications,
	// $default. Endpoint names must be unique across endpoint types.
	Name *string `json:"name,omitempty"`

	// ResourceGroup: The name of the resource group of the event hub endpoint.
	ResourceGroup *string `json:"resourceGroup,omitempty"`

	// SubscriptionId: The subscription identifier of the event hub endpoint.
	SubscriptionId *string `json:"subscriptionId,omitempty"`
}

var _ genruntime.FromARMConverter = &RoutingEventHubProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *RoutingEventHubProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RoutingEventHubProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *RoutingEventHubProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RoutingEventHubProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RoutingEventHubProperties_STATUS, got %T", armInput)
	}

	// Set property "AuthenticationType":
	if typedInput.AuthenticationType != nil {
		var temp string
		temp = string(*typedInput.AuthenticationType)
		authenticationType := RoutingEventHubProperties_AuthenticationType_STATUS(temp)
		properties.AuthenticationType = &authenticationType
	}

	// Set property "EndpointUri":
	if typedInput.EndpointUri != nil {
		endpointUri := *typedInput.EndpointUri
		properties.EndpointUri = &endpointUri
	}

	// Set property "EntityPath":
	if typedInput.EntityPath != nil {
		entityPath := *typedInput.EntityPath
		properties.EntityPath = &entityPath
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		properties.Id = &id
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		properties.Identity = &identity
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		properties.Name = &name
	}

	// Set property "ResourceGroup":
	if typedInput.ResourceGroup != nil {
		resourceGroup := *typedInput.ResourceGroup
		properties.ResourceGroup = &resourceGroup
	}

	// Set property "SubscriptionId":
	if typedInput.SubscriptionId != nil {
		subscriptionId := *typedInput.SubscriptionId
		properties.SubscriptionId = &subscriptionId
	}

	// No error
	return nil
}

// AssignProperties_From_RoutingEventHubProperties_STATUS populates our RoutingEventHubProperties_STATUS from the provided source RoutingEventHubProperties_STATUS
func (properties *RoutingEventHubProperties_STATUS) AssignProperties_From_RoutingEventHubProperties_STATUS(source *storage.RoutingEventHubProperties_STATUS) error {

	// AuthenticationType
	if source.AuthenticationType != nil {
		authenticationType := *source.AuthenticationType
		authenticationTypeTemp := genruntime.ToEnum(authenticationType, routingEventHubProperties_AuthenticationType_STATUS_Values)
		properties.AuthenticationType = &authenticationTypeTemp
	} else {
		properties.AuthenticationType = nil
	}

	// EndpointUri
	properties.EndpointUri = genruntime.ClonePointerToString(source.EndpointUri)

	// EntityPath
	properties.EntityPath = genruntime.ClonePointerToString(source.EntityPath)

	// Id
	properties.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity ManagedIdentity_STATUS
		err := identity.AssignProperties_From_ManagedIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedIdentity_STATUS() to populate field Identity")
		}
		properties.Identity = &identity
	} else {
		properties.Identity = nil
	}

	// Name
	properties.Name = genruntime.ClonePointerToString(source.Name)

	// ResourceGroup
	properties.ResourceGroup = genruntime.ClonePointerToString(source.ResourceGroup)

	// SubscriptionId
	properties.SubscriptionId = genruntime.ClonePointerToString(source.SubscriptionId)

	// No error
	return nil
}

// AssignProperties_To_RoutingEventHubProperties_STATUS populates the provided destination RoutingEventHubProperties_STATUS from our RoutingEventHubProperties_STATUS
func (properties *RoutingEventHubProperties_STATUS) AssignProperties_To_RoutingEventHubProperties_STATUS(destination *storage.RoutingEventHubProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthenticationType
	if properties.AuthenticationType != nil {
		authenticationType := string(*properties.AuthenticationType)
		destination.AuthenticationType = &authenticationType
	} else {
		destination.AuthenticationType = nil
	}

	// EndpointUri
	destination.EndpointUri = genruntime.ClonePointerToString(properties.EndpointUri)

	// EntityPath
	destination.EntityPath = genruntime.ClonePointerToString(properties.EntityPath)

	// Id
	destination.Id = genruntime.ClonePointerToString(properties.Id)

	// Identity
	if properties.Identity != nil {
		var identity storage.ManagedIdentity_STATUS
		err := properties.Identity.AssignProperties_To_ManagedIdentity_STATUS(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(properties.Name)

	// ResourceGroup
	destination.ResourceGroup = genruntime.ClonePointerToString(properties.ResourceGroup)

	// SubscriptionId
	destination.SubscriptionId = genruntime.ClonePointerToString(properties.SubscriptionId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The properties related to service bus queue endpoint types.
type RoutingServiceBusQueueEndpointProperties struct {
	// AuthenticationType: Method used to authenticate against the service bus queue endpoint
	AuthenticationType *RoutingServiceBusQueueEndpointProperties_AuthenticationType `json:"authenticationType,omitempty"`

	// ConnectionString: The connection string of the service bus queue endpoint.
	ConnectionString *genruntime.SecretReference `json:"connectionString,omitempty"`

	// EndpointUri: The url of the service bus queue endpoint. It must include the protocol sb://
	EndpointUri *string `json:"endpointUri,omitempty"`

	// EntityPath: Queue name on the service bus namespace
	EntityPath *string `json:"entityPath,omitempty"`

	// Identity: Managed identity properties of routing service bus queue endpoint.
	Identity *ManagedIdentity `json:"identity,omitempty"`

	// +kubebuilder:validation:Required
	// +kubebuilder:validation:Pattern="^[A-Za-z0-9-._]{1,64}$"
	// Name: The name that identifies this endpoint. The name can only include alphanumeric characters, periods, underscores,
	// hyphens and has a maximum length of 64 characters. The following names are reserved:  events, fileNotifications,
	// $default. Endpoint names must be unique across endpoint types. The name need not be the same as the actual queue name.
	Name *string `json:"name,omitempty"`

	// Reference: Id of the service bus queue endpoint
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`

	// ResourceGroup: The name of the resource group of the service bus queue endpoint.
	ResourceGroup *string `json:"resourceGroup,omitempty"`

	// SubscriptionId: The subscription identifier of the service bus queue endpoint.
	SubscriptionId *string `json:"subscriptionId,omitempty"`
}

var _ genruntime.ARMTransformer = &RoutingServiceBusQueueEndpointProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *RoutingServiceBusQueueEndpointProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.RoutingServiceBusQueueEndpointProperties{}

	// Set property "AuthenticationType":
	if properties.AuthenticationType != nil {
		var temp string
		temp = string(*properties.AuthenticationType)
		authenticationType := arm.RoutingServiceBusQueueEndpointProperties_AuthenticationType(temp)
		result.AuthenticationType = &authenticationType
	}

	// Set property "ConnectionString":
	if properties.ConnectionString != nil {
		connectionStringSecret, err := resolved.ResolvedSecrets.Lookup(*properties.ConnectionString)
		if err != nil {
			return nil, eris.Wrap(err, "looking up secret for property ConnectionString")
		}
		connectionString := connectionStringSecret
		result.ConnectionString = &connectionString
	}

	// Set property "EndpointUri":
	if properties.EndpointUri != nil {
		endpointUri := *properties.EndpointUri
		result.EndpointUri = &endpointUri
	}

	// Set property "EntityPath":
	if properties.EntityPath != nil {
		entityPath := *properties.EntityPath
		result.EntityPath = &entityPath
	}

	// Set property "Id":
	if properties.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*properties.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property "Identity":
	if properties.Identity != nil {
		identity_ARM, err := (*properties.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*arm.ManagedIdentity)
		result.Identity = &identity
	}

	// Set property "Name":
	if properties.Name != nil {
		name := *properties.Name
		result.Name = &name
	}

	// Set property "ResourceGroup":
	if properties.ResourceGroup != nil {
		resourceGroup := *properties.ResourceGroup
		result.ResourceGroup = &resourceGroup
	}

	// Set property "SubscriptionId":
	if properties.SubscriptionId != nil {
		subscriptionId := *properties.SubscriptionId
		result.SubscriptionId = &subscriptionId
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *RoutingServiceBusQueueEndpointProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RoutingServiceBusQueueEndpointProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *RoutingServiceBusQueueEndpointProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RoutingServiceBusQueueEndpointProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RoutingServiceBusQueueEndpointProperties, got %T", armInput)
	}

	// Set property "AuthenticationType":
	if typedInput.AuthenticationType != nil {
		var temp string
		temp = string(*typedInput.AuthenticationType)
		authenticationType := RoutingServiceBusQueueEndpointProperties_AuthenticationType(temp)
		properties.AuthenticationType = &authenticationType
	}

	// no assignment for property "ConnectionString"

	// Set property "EndpointUri":
	if typedInput.EndpointUri != nil {
		endpointUri := *typedInput.EndpointUri
		properties.EndpointUri = &endpointUri
	}

	// Set property "EntityPath":
	if typedInput.EntityPath != nil {
		entityPath := *typedInput.EntityPath
		properties.EntityPath = &entityPath
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		properties.Identity = &identity
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		properties.Name = &name
	}

	// no assignment for property "Reference"

	// Set property "ResourceGroup":
	if typedInput.ResourceGroup != nil {
		resourceGroup := *typedInput.ResourceGroup
		properties.ResourceGroup = &resourceGroup
	}

	// Set property "SubscriptionId":
	if typedInput.SubscriptionId != nil {
		subscriptionId := *typedInput.SubscriptionId
		properties.SubscriptionId = &subscriptionId
	}

	// No error
	return nil
}

// AssignProperties_From_RoutingServiceBusQueueEndpointProperties populates our RoutingServiceBusQueueEndpointProperties from the provided source RoutingServiceBusQueueEndpointProperties
func (properties *RoutingServiceBusQueueEndpointProperties) AssignProperties_From_RoutingServiceBusQueueEndpointProperties(source *storage.RoutingServiceBusQueueEndpointProperties) error {

	// AuthenticationType
	if source.AuthenticationType != nil {
		authenticationType := *source.AuthenticationType
		authenticationTypeTemp := genruntime.ToEnum(authenticationType, routingServiceBusQueueEndpointProperties_AuthenticationType_Values)
		properties.AuthenticationType = &authenticationTypeTemp
	} else {
		properties.AuthenticationType = nil
	}

	// ConnectionString
	if source.ConnectionString != nil {
		connectionString := source.ConnectionString.Copy()
		properties.ConnectionString = &connectionString
	} else {
		properties.ConnectionString = nil
	}

	// EndpointUri
	properties.EndpointUri = genruntime.ClonePointerToString(source.EndpointUri)

	// EntityPath
	properties.EntityPath = genruntime.ClonePointerToString(source.EntityPath)

	// Identity
	if source.Identity != nil {
		var identity ManagedIdentity
		err := identity.AssignProperties_From_ManagedIdentity(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedIdentity() to populate field Identity")
		}
		properties.Identity = &identity
	} else {
		properties.Identity = nil
	}

	// Name
	properties.Name = genruntime.ClonePointerToString(source.Name)

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		properties.Reference = &reference
	} else {
		properties.Reference = nil
	}

	// ResourceGroup
	properties.ResourceGroup = genruntime.ClonePointerToString(source.ResourceGroup)

	// SubscriptionId
	properties.SubscriptionId = genruntime.ClonePointerToString(source.SubscriptionId)

	// No error
	return nil
}

// AssignProperties_To_RoutingServiceBusQueueEndpointProperties populates the provided destination RoutingServiceBusQueueEndpointProperties from our RoutingServiceBusQueueEndpointProperties
func (properties *RoutingServiceBusQueueEndpointProperties) AssignProperties_To_RoutingServiceBusQueueEndpointProperties(destination *storage.RoutingServiceBusQueueEndpointProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthenticationType
	if properties.AuthenticationType != nil {
		authenticationType := string(*properties.AuthenticationType)
		destination.AuthenticationType = &authenticationType
	} else {
		destination.AuthenticationType = nil
	}

	// ConnectionString
	if properties.ConnectionString != nil {
		connectionString := properties.ConnectionString.Copy()
		destination.ConnectionString = &connectionString
	} else {
		destination.ConnectionString = nil
	}

	// EndpointUri
	destination.EndpointUri = genruntime.ClonePointerToString(properties.EndpointUri)

	// EntityPath
	destination.EntityPath = genruntime.ClonePointerToString(properties.EntityPath)

	// Identity
	if properties.Identity != nil {
		var identity storage.ManagedIdentity
		err := properties.Identity.AssignProperties_To_ManagedIdentity(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(properties.Name)

	// Reference
	if properties.Reference != nil {
		reference := properties.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// ResourceGroup
	destination.ResourceGroup = genruntime.ClonePointerToString(properties.ResourceGroup)

	// SubscriptionId
	destination.SubscriptionId = genruntime.ClonePointerToString(properties.SubscriptionId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RoutingServiceBusQueueEndpointProperties_STATUS populates our RoutingServiceBusQueueEndpointProperties from the provided source RoutingServiceBusQueueEndpointProperties_STATUS
func (properties *RoutingServiceBusQueueEndpointProperties) Initialize_From_RoutingServiceBusQueueEndpointProperties_STATUS(source *RoutingServiceBusQueueEndpointProperties_STATUS) error {

	// AuthenticationType
	if source.AuthenticationType != nil {
		authenticationType := genruntime.ToEnum(string(*source.AuthenticationType), routingServiceBusQueueEndpointProperties_AuthenticationType_Values)
		properties.AuthenticationType = &authenticationType
	} else {
		properties.AuthenticationType = nil
	}

	// EndpointUri
	properties.EndpointUri = genruntime.ClonePointerToString(source.EndpointUri)

	// EntityPath
	properties.EntityPath = genruntime.ClonePointerToString(source.EntityPath)

	// Identity
	if source.Identity != nil {
		var identity ManagedIdentity
		err := identity.Initialize_From_ManagedIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ManagedIdentity_STATUS() to populate field Identity")
		}
		properties.Identity = &identity
	} else {
		properties.Identity = nil
	}

	// Name
	properties.Name = genruntime.ClonePointerToString(source.Name)

	// Reference
	if source.Id != nil {
		reference := genruntime.CreateResourceReferenceFromARMID(*source.Id)
		properties.Reference = &reference
	} else {
		properties.Reference = nil
	}

	// ResourceGroup
	properties.ResourceGroup = genruntime.ClonePointerToString(source.ResourceGroup)

	// SubscriptionId
	properties.SubscriptionId = genruntime.ClonePointerToString(source.SubscriptionId)

	// No error
	return nil
}

// The properties related to service bus queue endpoint types.
type RoutingServiceBusQueueEndpointProperties_STATUS struct {
	// AuthenticationType: Method used to authenticate against the service bus queue endpoint
	AuthenticationType *RoutingServiceBusQueueEndpointProperties_AuthenticationType_STATUS `json:"authenticationType,omitempty"`

	// EndpointUri: The url of the service bus queue endpoint. It must include the protocol sb://
	EndpointUri *string `json:"endpointUri,omitempty"`

	// EntityPath: Queue name on the service bus namespace
	EntityPath *string `json:"entityPath,omitempty"`

	// Id: Id of the service bus queue endpoint
	Id *string `json:"id,omitempty"`

	// Identity: Managed identity properties of routing service bus queue endpoint.
	Identity *ManagedIdentity_STATUS `json:"identity,omitempty"`

	// Name: The name that identifies this endpoint. The name can only include alphanumeric characters, periods, underscores,
	// hyphens and has a maximum length of 64 characters. The following names are reserved:  events, fileNotifications,
	// $default. Endpoint names must be unique across endpoint types. The name need not be the same as the actual queue name.
	Name *string `json:"name,omitempty"`

	// ResourceGroup: The name of the resource group of the service bus queue endpoint.
	ResourceGroup *string `json:"resourceGroup,omitempty"`

	// SubscriptionId: The subscription identifier of the service bus queue endpoint.
	SubscriptionId *string `json:"subscriptionId,omitempty"`
}

var _ genruntime.FromARMConverter = &RoutingServiceBusQueueEndpointProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *RoutingServiceBusQueueEndpointProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RoutingServiceBusQueueEndpointProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *RoutingServiceBusQueueEndpointProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RoutingServiceBusQueueEndpointProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RoutingServiceBusQueueEndpointProperties_STATUS, got %T", armInput)
	}

	// Set property "AuthenticationType":
	if typedInput.AuthenticationType != nil {
		var temp string
		temp = string(*typedInput.AuthenticationType)
		authenticationType := RoutingServiceBusQueueEndpointProperties_AuthenticationType_STATUS(temp)
		properties.AuthenticationType = &authenticationType
	}

	// Set property "EndpointUri":
	if typedInput.EndpointUri != nil {
		endpointUri := *typedInput.EndpointUri
		properties.EndpointUri = &endpointUri
	}

	// Set property "EntityPath":
	if typedInput.EntityPath != nil {
		entityPath := *typedInput.EntityPath
		properties.EntityPath = &entityPath
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		properties.Id = &id
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		properties.Identity = &identity
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		properties.Name = &name
	}

	// Set property "ResourceGroup":
	if typedInput.ResourceGroup != nil {
		resourceGroup := *typedInput.ResourceGroup
		properties.ResourceGroup = &resourceGroup
	}

	// Set property "SubscriptionId":
	if typedInput.SubscriptionId != nil {
		subscriptionId := *typedInput.SubscriptionId
		properties.SubscriptionId = &subscriptionId
	}

	// No error
	return nil
}

// AssignProperties_From_RoutingServiceBusQueueEndpointProperties_STATUS populates our RoutingServiceBusQueueEndpointProperties_STATUS from the provided source RoutingServiceBusQueueEndpointProperties_STATUS
func (properties *RoutingServiceBusQueueEndpointProperties_STATUS) AssignProperties_From_RoutingServiceBusQueueEndpointProperties_STATUS(source *storage.RoutingServiceBusQueueEndpointProperties_STATUS) error {

	// AuthenticationType
	if source.AuthenticationType != nil {
		authenticationType := *source.AuthenticationType
		authenticationTypeTemp := genruntime.ToEnum(authenticationType, routingServiceBusQueueEndpointProperties_AuthenticationType_STATUS_Values)
		properties.AuthenticationType = &authenticationTypeTemp
	} else {
		properties.AuthenticationType = nil
	}

	// EndpointUri
	properties.EndpointUri = genruntime.ClonePointerToString(source.EndpointUri)

	// EntityPath
	properties.EntityPath = genruntime.ClonePointerToString(source.EntityPath)

	// Id
	properties.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity ManagedIdentity_STATUS
		err := identity.AssignProperties_From_ManagedIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedIdentity_STATUS() to populate field Identity")
		}
		properties.Identity = &identity
	} else {
		properties.Identity = nil
	}

	// Name
	properties.Name = genruntime.ClonePointerToString(source.Name)

	// ResourceGroup
	properties.ResourceGroup = genruntime.ClonePointerToString(source.ResourceGroup)

	// SubscriptionId
	properties.SubscriptionId = genruntime.ClonePointerToString(source.SubscriptionId)

	// No error
	return nil
}

// AssignProperties_To_RoutingServiceBusQueueEndpointProperties_STATUS populates the provided destination RoutingServiceBusQueueEndpointProperties_STATUS from our RoutingServiceBusQueueEndpointProperties_STATUS
func (properties *RoutingServiceBusQueueEndpointProperties_STATUS) AssignProperties_To_RoutingServiceBusQueueEndpointProperties_STATUS(destination *storage.RoutingServiceBusQueueEndpointProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthenticationType
	if properties.AuthenticationType != nil {
		authenticationType := string(*properties.AuthenticationType)
		destination.AuthenticationType = &authenticationType
	} else {
		destination.AuthenticationType = nil
	}

	// EndpointUri
	destination.EndpointUri = genruntime.ClonePointerToString(properties.EndpointUri)

	// EntityPath
	destination.EntityPath = genruntime.ClonePointerToString(properties.EntityPath)

	// Id
	destination.Id = genruntime.ClonePointerToString(properties.Id)

	// Identity
	if properties.Identity != nil {
		var identity storage.ManagedIdentity_STATUS
		err := properties.Identity.AssignProperties_To_ManagedIdentity_STATUS(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(properties.Name)

	// ResourceGroup
	destination.ResourceGroup = genruntime.ClonePointerToString(properties.ResourceGroup)

	// SubscriptionId
	destination.SubscriptionId = genruntime.ClonePointerToString(properties.SubscriptionId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The properties related to service bus topic endpoint types.
type RoutingServiceBusTopicEndpointProperties struct {
	// AuthenticationType: Method used to authenticate against the service bus topic endpoint
	AuthenticationType *RoutingServiceBusTopicEndpointProperties_AuthenticationType `json:"authenticationType,omitempty"`

	// ConnectionString: The connection string of the service bus topic endpoint.
	ConnectionString *genruntime.SecretReference `json:"connectionString,omitempty"`

	// EndpointUri: The url of the service bus topic endpoint. It must include the protocol sb://
	EndpointUri *string `json:"endpointUri,omitempty"`

	// EntityPath: Queue name on the service bus topic
	EntityPath *string `json:"entityPath,omitempty"`

	// Identity: Managed identity properties of routing service bus topic endpoint.
	Identity *ManagedIdentity `json:"identity,omitempty"`

	// +kubebuilder:validation:Required
	// +kubebuilder:validation:Pattern="^[A-Za-z0-9-._]{1,64}$"
	// Name: The name that identifies this endpoint. The name can only include alphanumeric characters, periods, underscores,
	// hyphens and has a maximum length of 64 characters. The following names are reserved:  events, fileNotifications,
	// $default. Endpoint names must be unique across endpoint types.  The name need not be the same as the actual topic name.
	Name *string `json:"name,omitempty"`

	// Reference: Id of the service bus topic endpoint
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`

	// ResourceGroup: The name of the resource group of the service bus topic endpoint.
	ResourceGroup *string `json:"resourceGroup,omitempty"`

	// SubscriptionId: The subscription identifier of the service bus topic endpoint.
	SubscriptionId *string `json:"subscriptionId,omitempty"`
}

var _ genruntime.ARMTransformer = &RoutingServiceBusTopicEndpointProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *RoutingServiceBusTopicEndpointProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.RoutingServiceBusTopicEndpointProperties{}

	// Set property "AuthenticationType":
	if properties.AuthenticationType != nil {
		var temp string
		temp = string(*properties.AuthenticationType)
		authenticationType := arm.RoutingServiceBusTopicEndpointProperties_AuthenticationType(temp)
		result.AuthenticationType = &authenticationType
	}

	// Set property "ConnectionString":
	if properties.ConnectionString != nil {
		connectionStringSecret, err := resolved.ResolvedSecrets.Lookup(*properties.ConnectionString)
		if err != nil {
			return nil, eris.Wrap(err, "looking up secret for property ConnectionString")
		}
		connectionString := connectionStringSecret
		result.ConnectionString = &connectionString
	}

	// Set property "EndpointUri":
	if properties.EndpointUri != nil {
		endpointUri := *properties.EndpointUri
		result.EndpointUri = &endpointUri
	}

	// Set property "EntityPath":
	if properties.EntityPath != nil {
		entityPath := *properties.EntityPath
		result.EntityPath = &entityPath
	}

	// Set property "Id":
	if properties.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*properties.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property "Identity":
	if properties.Identity != nil {
		identity_ARM, err := (*properties.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*arm.ManagedIdentity)
		result.Identity = &identity
	}

	// Set property "Name":
	if properties.Name != nil {
		name := *properties.Name
		result.Name = &name
	}

	// Set property "ResourceGroup":
	if properties.ResourceGroup != nil {
		resourceGroup := *properties.ResourceGroup
		result.ResourceGroup = &resourceGroup
	}

	// Set property "SubscriptionId":
	if properties.SubscriptionId != nil {
		subscriptionId := *properties.SubscriptionId
		result.SubscriptionId = &subscriptionId
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *RoutingServiceBusTopicEndpointProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RoutingServiceBusTopicEndpointProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *RoutingServiceBusTopicEndpointProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RoutingServiceBusTopicEndpointProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RoutingServiceBusTopicEndpointProperties, got %T", armInput)
	}

	// Set property "AuthenticationType":
	if typedInput.AuthenticationType != nil {
		var temp string
		temp = string(*typedInput.AuthenticationType)
		authenticationType := RoutingServiceBusTopicEndpointProperties_AuthenticationType(temp)
		properties.AuthenticationType = &authenticationType
	}

	// no assignment for property "ConnectionString"

	// Set property "EndpointUri":
	if typedInput.EndpointUri != nil {
		endpointUri := *typedInput.EndpointUri
		properties.EndpointUri = &endpointUri
	}

	// Set property "EntityPath":
	if typedInput.EntityPath != nil {
		entityPath := *typedInput.EntityPath
		properties.EntityPath = &entityPath
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		properties.Identity = &identity
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		properties.Name = &name
	}

	// no assignment for property "Reference"

	// Set property "ResourceGroup":
	if typedInput.ResourceGroup != nil {
		resourceGroup := *typedInput.ResourceGroup
		properties.ResourceGroup = &resourceGroup
	}

	// Set property "SubscriptionId":
	if typedInput.SubscriptionId != nil {
		subscriptionId := *typedInput.SubscriptionId
		properties.SubscriptionId = &subscriptionId
	}

	// No error
	return nil
}

// AssignProperties_From_RoutingServiceBusTopicEndpointProperties populates our RoutingServiceBusTopicEndpointProperties from the provided source RoutingServiceBusTopicEndpointProperties
func (properties *RoutingServiceBusTopicEndpointProperties) AssignProperties_From_RoutingServiceBusTopicEndpointProperties(source *storage.RoutingServiceBusTopicEndpointProperties) error {

	// AuthenticationType
	if source.AuthenticationType != nil {
		authenticationType := *source.AuthenticationType
		authenticationTypeTemp := genruntime.ToEnum(authenticationType, routingServiceBusTopicEndpointProperties_AuthenticationType_Values)
		properties.AuthenticationType = &authenticationTypeTemp
	} else {
		properties.AuthenticationType = nil
	}

	// ConnectionString
	if source.ConnectionString != nil {
		connectionString := source.ConnectionString.Copy()
		properties.ConnectionString = &connectionString
	} else {
		properties.ConnectionString = nil
	}

	// EndpointUri
	properties.EndpointUri = genruntime.ClonePointerToString(source.EndpointUri)

	// EntityPath
	properties.EntityPath = genruntime.ClonePointerToString(source.EntityPath)

	// Identity
	if source.Identity != nil {
		var identity ManagedIdentity
		err := identity.AssignProperties_From_ManagedIdentity(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedIdentity() to populate field Identity")
		}
		properties.Identity = &identity
	} else {
		properties.Identity = nil
	}

	// Name
	properties.Name = genruntime.ClonePointerToString(source.Name)

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		properties.Reference = &reference
	} else {
		properties.Reference = nil
	}

	// ResourceGroup
	properties.ResourceGroup = genruntime.ClonePointerToString(source.ResourceGroup)

	// SubscriptionId
	properties.SubscriptionId = genruntime.ClonePointerToString(source.SubscriptionId)

	// No error
	return nil
}

// AssignProperties_To_RoutingServiceBusTopicEndpointProperties populates the provided destination RoutingServiceBusTopicEndpointProperties from our RoutingServiceBusTopicEndpointProperties
func (properties *RoutingServiceBusTopicEndpointProperties) AssignProperties_To_RoutingServiceBusTopicEndpointProperties(destination *storage.RoutingServiceBusTopicEndpointProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthenticationType
	if properties.AuthenticationType != nil {
		authenticationType := string(*properties.AuthenticationType)
		destination.AuthenticationType = &authenticationType
	} else {
		destination.AuthenticationType = nil
	}

	// ConnectionString
	if properties.ConnectionString != nil {
		connectionString := properties.ConnectionString.Copy()
		destination.ConnectionString = &connectionString
	} else {
		destination.ConnectionString = nil
	}

	// EndpointUri
	destination.EndpointUri = genruntime.ClonePointerToString(properties.EndpointUri)

	// EntityPath
	destination.EntityPath = genruntime.ClonePointerToString(properties.EntityPath)

	// Identity
	if properties.Identity != nil {
		var identity storage.ManagedIdentity
		err := properties.Identity.AssignProperties_To_ManagedIdentity(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(properties.Name)

	// Reference
	if properties.Reference != nil {
		reference := properties.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// ResourceGroup
	destination.ResourceGroup = genruntime.ClonePointerToString(properties.ResourceGroup)

	// SubscriptionId
	destination.SubscriptionId = genruntime.ClonePointerToString(properties.SubscriptionId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RoutingServiceBusTopicEndpointProperties_STATUS populates our RoutingServiceBusTopicEndpointProperties from the provided source RoutingServiceBusTopicEndpointProperties_STATUS
func (properties *RoutingServiceBusTopicEndpointProperties) Initialize_From_RoutingServiceBusTopicEndpointProperties_STATUS(source *RoutingServiceBusTopicEndpointProperties_STATUS) error {

	// AuthenticationType
	if source.AuthenticationType != nil {
		authenticationType := genruntime.ToEnum(string(*source.AuthenticationType), routingServiceBusTopicEndpointProperties_AuthenticationType_Values)
		properties.AuthenticationType = &authenticationType
	} else {
		properties.AuthenticationType = nil
	}

	// EndpointUri
	properties.EndpointUri = genruntime.ClonePointerToString(source.EndpointUri)

	// EntityPath
	properties.EntityPath = genruntime.ClonePointerToString(source.EntityPath)

	// Identity
	if source.Identity != nil {
		var identity ManagedIdentity
		err := identity.Initialize_From_ManagedIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ManagedIdentity_STATUS() to populate field Identity")
		}
		properties.Identity = &identity
	} else {
		properties.Identity = nil
	}

	// Name
	properties.Name = genruntime.ClonePointerToString(source.Name)

	// Reference
	if source.Id != nil {
		reference := genruntime.CreateResourceReferenceFromARMID(*source.Id)
		properties.Reference = &reference
	} else {
		properties.Reference = nil
	}

	// ResourceGroup
	properties.ResourceGroup = genruntime.ClonePointerToString(source.ResourceGroup)

	// SubscriptionId
	properties.SubscriptionId = genruntime.ClonePointerToString(source.SubscriptionId)

	// No error
	return nil
}

// The properties related to service bus topic endpoint types.
type RoutingServiceBusTopicEndpointProperties_STATUS struct {
	// AuthenticationType: Method used to authenticate against the service bus topic endpoint
	AuthenticationType *RoutingServiceBusTopicEndpointProperties_AuthenticationType_STATUS `json:"authenticationType,omitempty"`

	// EndpointUri: The url of the service bus topic endpoint. It must include the protocol sb://
	EndpointUri *string `json:"endpointUri,omitempty"`

	// EntityPath: Queue name on the service bus topic
	EntityPath *string `json:"entityPath,omitempty"`

	// Id: Id of the service bus topic endpoint
	Id *string `json:"id,omitempty"`

	// Identity: Managed identity properties of routing service bus topic endpoint.
	Identity *ManagedIdentity_STATUS `json:"identity,omitempty"`

	// Name: The name that identifies this endpoint. The name can only include alphanumeric characters, periods, underscores,
	// hyphens and has a maximum length of 64 characters. The following names are reserved:  events, fileNotifications,
	// $default. Endpoint names must be unique across endpoint types.  The name need not be the same as the actual topic name.
	Name *string `json:"name,omitempty"`

	// ResourceGroup: The name of the resource group of the service bus topic endpoint.
	ResourceGroup *string `json:"resourceGroup,omitempty"`

	// SubscriptionId: The subscription identifier of the service bus topic endpoint.
	SubscriptionId *string `json:"subscriptionId,omitempty"`
}

var _ genruntime.FromARMConverter = &RoutingServiceBusTopicEndpointProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *RoutingServiceBusTopicEndpointProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RoutingServiceBusTopicEndpointProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *RoutingServiceBusTopicEndpointProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RoutingServiceBusTopicEndpointProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RoutingServiceBusTopicEndpointProperties_STATUS, got %T", armInput)
	}

	// Set property "AuthenticationType":
	if typedInput.AuthenticationType != nil {
		var temp string
		temp = string(*typedInput.AuthenticationType)
		authenticationType := RoutingServiceBusTopicEndpointProperties_AuthenticationType_STATUS(temp)
		properties.AuthenticationType = &authenticationType
	}

	// Set property "EndpointUri":
	if typedInput.EndpointUri != nil {
		endpointUri := *typedInput.EndpointUri
		properties.EndpointUri = &endpointUri
	}

	// Set property "EntityPath":
	if typedInput.EntityPath != nil {
		entityPath := *typedInput.EntityPath
		properties.EntityPath = &entityPath
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		properties.Id = &id
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		properties.Identity = &identity
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		properties.Name = &name
	}

	// Set property "ResourceGroup":
	if typedInput.ResourceGroup != nil {
		resourceGroup := *typedInput.ResourceGroup
		properties.ResourceGroup = &resourceGroup
	}

	// Set property "SubscriptionId":
	if typedInput.SubscriptionId != nil {
		subscriptionId := *typedInput.SubscriptionId
		properties.SubscriptionId = &subscriptionId
	}

	// No error
	return nil
}

// AssignProperties_From_RoutingServiceBusTopicEndpointProperties_STATUS populates our RoutingServiceBusTopicEndpointProperties_STATUS from the provided source RoutingServiceBusTopicEndpointProperties_STATUS
func (properties *RoutingServiceBusTopicEndpointProperties_STATUS) AssignProperties_From_RoutingServiceBusTopicEndpointProperties_STATUS(source *storage.RoutingServiceBusTopicEndpointProperties_STATUS) error {

	// AuthenticationType
	if source.AuthenticationType != nil {
		authenticationType := *source.AuthenticationType
		authenticationTypeTemp := genruntime.ToEnum(authenticationType, routingServiceBusTopicEndpointProperties_AuthenticationType_STATUS_Values)
		properties.AuthenticationType = &authenticationTypeTemp
	} else {
		properties.AuthenticationType = nil
	}

	// EndpointUri
	properties.EndpointUri = genruntime.ClonePointerToString(source.EndpointUri)

	// EntityPath
	properties.EntityPath = genruntime.ClonePointerToString(source.EntityPath)

	// Id
	properties.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity ManagedIdentity_STATUS
		err := identity.AssignProperties_From_ManagedIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedIdentity_STATUS() to populate field Identity")
		}
		properties.Identity = &identity
	} else {
		properties.Identity = nil
	}

	// Name
	properties.Name = genruntime.ClonePointerToString(source.Name)

	// ResourceGroup
	properties.ResourceGroup = genruntime.ClonePointerToString(source.ResourceGroup)

	// SubscriptionId
	properties.SubscriptionId = genruntime.ClonePointerToString(source.SubscriptionId)

	// No error
	return nil
}

// AssignProperties_To_RoutingServiceBusTopicEndpointProperties_STATUS populates the provided destination RoutingServiceBusTopicEndpointProperties_STATUS from our RoutingServiceBusTopicEndpointProperties_STATUS
func (properties *RoutingServiceBusTopicEndpointProperties_STATUS) AssignProperties_To_RoutingServiceBusTopicEndpointProperties_STATUS(destination *storage.RoutingServiceBusTopicEndpointProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthenticationType
	if properties.AuthenticationType != nil {
		authenticationType := string(*properties.AuthenticationType)
		destination.AuthenticationType = &authenticationType
	} else {
		destination.AuthenticationType = nil
	}

	// EndpointUri
	destination.EndpointUri = genruntime.ClonePointerToString(properties.EndpointUri)

	// EntityPath
	destination.EntityPath = genruntime.ClonePointerToString(properties.EntityPath)

	// Id
	destination.Id = genruntime.ClonePointerToString(properties.Id)

	// Identity
	if properties.Identity != nil {
		var identity storage.ManagedIdentity_STATUS
		err := properties.Identity.AssignProperties_To_ManagedIdentity_STATUS(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(properties.Name)

	// ResourceGroup
	destination.ResourceGroup = genruntime.ClonePointerToString(properties.ResourceGroup)

	// SubscriptionId
	destination.SubscriptionId = genruntime.ClonePointerToString(properties.SubscriptionId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The properties related to a storage container endpoint.
type RoutingStorageContainerProperties struct {
	// AuthenticationType: Method used to authenticate against the storage endpoint
	AuthenticationType *RoutingStorageContainerProperties_AuthenticationType `json:"authenticationType,omitempty"`

	// +kubebuilder:validation:Maximum=720
	// +kubebuilder:validation:Minimum=60
	// BatchFrequencyInSeconds: Time interval at which blobs are written to storage. Value should be between 60 and 720
	// seconds. Default value is 300 seconds.
	BatchFrequencyInSeconds *int `json:"batchFrequencyInSeconds,omitempty"`

	// ConnectionString: The connection string of the storage account.
	ConnectionString *genruntime.SecretReference `json:"connectionString,omitempty"`

	// +kubebuilder:validation:Required
	// ContainerName: The name of storage container in the storage account.
	ContainerName *string `json:"containerName,omitempty"`

	// Encoding: Encoding that is used to serialize messages to blobs. Supported values are 'avro', 'avrodeflate', and 'JSON'.
	// Default value is 'avro'.
	Encoding *RoutingStorageContainerProperties_Encoding `json:"encoding,omitempty"`

	// EndpointUri: The url of the storage endpoint. It must include the protocol https://
	EndpointUri *string `json:"endpointUri,omitempty"`

	// FileNameFormat: File name format for the blob. Default format is {iothub}/{partition}/{YYYY}/{MM}/{DD}/{HH}/{mm}. All
	// parameters are mandatory but can be reordered.
	FileNameFormat *string `json:"fileNameFormat,omitempty"`

	// Identity: Managed identity properties of routing storage endpoint.
	Identity *ManagedIdentity `json:"identity,omitempty"`

	// +kubebuilder:validation:Maximum=524288000
	// +kubebuilder:validation:Minimum=10485760
	// MaxChunkSizeInBytes: Maximum number of bytes for each blob written to storage. Value should be between 10485760(10MB)
	// and 524288000(500MB). Default value is 314572800(300MB).
	MaxChunkSizeInBytes *int `json:"maxChunkSizeInBytes,omitempty"`

	// +kubebuilder:validation:Required
	// +kubebuilder:validation:Pattern="^[A-Za-z0-9-._]{1,64}$"
	// Name: The name that identifies this endpoint. The name can only include alphanumeric characters, periods, underscores,
	// hyphens and has a maximum length of 64 characters. The following names are reserved:  events, fileNotifications,
	// $default. Endpoint names must be unique across endpoint types.
	Name *string `json:"name,omitempty"`

	// Reference: Id of the storage container endpoint
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`

	// ResourceGroup: The name of the resource group of the storage account.
	ResourceGroup *string `json:"resourceGroup,omitempty"`

	// SubscriptionId: The subscription identifier of the storage account.
	SubscriptionId *string `json:"subscriptionId,omitempty"`
}

var _ genruntime.ARMTransformer = &RoutingStorageContainerProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *RoutingStorageContainerProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.RoutingStorageContainerProperties{}

	// Set property "AuthenticationType":
	if properties.AuthenticationType != nil {
		var temp string
		temp = string(*properties.AuthenticationType)
		authenticationType := arm.RoutingStorageContainerProperties_AuthenticationType(temp)
		result.AuthenticationType = &authenticationType
	}

	// Set property "BatchFrequencyInSeconds":
	if properties.BatchFrequencyInSeconds != nil {
		batchFrequencyInSeconds := *properties.BatchFrequencyInSeconds
		result.BatchFrequencyInSeconds = &batchFrequencyInSeconds
	}

	// Set property "ConnectionString":
	if properties.ConnectionString != nil {
		connectionStringSecret, err := resolved.ResolvedSecrets.Lookup(*properties.ConnectionString)
		if err != nil {
			return nil, eris.Wrap(err, "looking up secret for property ConnectionString")
		}
		connectionString := connectionStringSecret
		result.ConnectionString = &connectionString
	}

	// Set property "ContainerName":
	if properties.ContainerName != nil {
		containerName := *properties.ContainerName
		result.ContainerName = &containerName
	}

	// Set property "Encoding":
	if properties.Encoding != nil {
		var temp string
		temp = string(*properties.Encoding)
		encoding := arm.RoutingStorageContainerProperties_Encoding(temp)
		result.Encoding = &encoding
	}

	// Set property "EndpointUri":
	if properties.EndpointUri != nil {
		endpointUri := *properties.EndpointUri
		result.EndpointUri = &endpointUri
	}

	// Set property "FileNameFormat":
	if properties.FileNameFormat != nil {
		fileNameFormat := *properties.FileNameFormat
		result.FileNameFormat = &fileNameFormat
	}

	// Set property "Id":
	if properties.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*properties.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property "Identity":
	if properties.Identity != nil {
		identity_ARM, err := (*properties.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*arm.ManagedIdentity)
		result.Identity = &identity
	}

	// Set property "MaxChunkSizeInBytes":
	if properties.MaxChunkSizeInBytes != nil {
		maxChunkSizeInBytes := *properties.MaxChunkSizeInBytes
		result.MaxChunkSizeInBytes = &maxChunkSizeInBytes
	}

	// Set property "Name":
	if properties.Name != nil {
		name := *properties.Name
		result.Name = &name
	}

	// Set property "ResourceGroup":
	if properties.ResourceGroup != nil {
		resourceGroup := *properties.ResourceGroup
		result.ResourceGroup = &resourceGroup
	}

	// Set property "SubscriptionId":
	if properties.SubscriptionId != nil {
		subscriptionId := *properties.SubscriptionId
		result.SubscriptionId = &subscriptionId
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *RoutingStorageContainerProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RoutingStorageContainerProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *RoutingStorageContainerProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RoutingStorageContainerProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RoutingStorageContainerProperties, got %T", armInput)
	}

	// Set property "AuthenticationType":
	if typedInput.AuthenticationType != nil {
		var temp string
		temp = string(*typedInput.AuthenticationType)
		authenticationType := RoutingStorageContainerProperties_AuthenticationType(temp)
		properties.AuthenticationType = &authenticationType
	}

	// Set property "BatchFrequencyInSeconds":
	if typedInput.BatchFrequencyInSeconds != nil {
		batchFrequencyInSeconds := *typedInput.BatchFrequencyInSeconds
		properties.BatchFrequencyInSeconds = &batchFrequencyInSeconds
	}

	// no assignment for property "ConnectionString"

	// Set property "ContainerName":
	if typedInput.ContainerName != nil {
		containerName := *typedInput.ContainerName
		properties.ContainerName = &containerName
	}

	// Set property "Encoding":
	if typedInput.Encoding != nil {
		var temp string
		temp = string(*typedInput.Encoding)
		encoding := RoutingStorageContainerProperties_Encoding(temp)
		properties.Encoding = &encoding
	}

	// Set property "EndpointUri":
	if typedInput.EndpointUri != nil {
		endpointUri := *typedInput.EndpointUri
		properties.EndpointUri = &endpointUri
	}

	// Set property "FileNameFormat":
	if typedInput.FileNameFormat != nil {
		fileNameFormat := *typedInput.FileNameFormat
		properties.FileNameFormat = &fileNameFormat
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		properties.Identity = &identity
	}

	// Set property "MaxChunkSizeInBytes":
	if typedInput.MaxChunkSizeInBytes != nil {
		maxChunkSizeInBytes := *typedInput.MaxChunkSizeInBytes
		properties.MaxChunkSizeInBytes = &maxChunkSizeInBytes
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		properties.Name = &name
	}

	// no assignment for property "Reference"

	// Set property "ResourceGroup":
	if typedInput.ResourceGroup != nil {
		resourceGroup := *typedInput.ResourceGroup
		properties.ResourceGroup = &resourceGroup
	}

	// Set property "SubscriptionId":
	if typedInput.SubscriptionId != nil {
		subscriptionId := *typedInput.SubscriptionId
		properties.SubscriptionId = &subscriptionId
	}

	// No error
	return nil
}

// AssignProperties_From_RoutingStorageContainerProperties populates our RoutingStorageContainerProperties from the provided source RoutingStorageContainerProperties
func (properties *RoutingStorageContainerProperties) AssignProperties_From_RoutingStorageContainerProperties(source *storage.RoutingStorageContainerProperties) error {

	// AuthenticationType
	if source.AuthenticationType != nil {
		authenticationType := *source.AuthenticationType
		authenticationTypeTemp := genruntime.ToEnum(authenticationType, routingStorageContainerProperties_AuthenticationType_Values)
		properties.AuthenticationType = &authenticationTypeTemp
	} else {
		properties.AuthenticationType = nil
	}

	// BatchFrequencyInSeconds
	properties.BatchFrequencyInSeconds = genruntime.ClonePointerToInt(source.BatchFrequencyInSeconds)

	// ConnectionString
	if source.ConnectionString != nil {
		connectionString := source.ConnectionString.Copy()
		properties.ConnectionString = &connectionString
	} else {
		properties.ConnectionString = nil
	}

	// ContainerName
	properties.ContainerName = genruntime.ClonePointerToString(source.ContainerName)

	// Encoding
	if source.Encoding != nil {
		encoding := *source.Encoding
		encodingTemp := genruntime.ToEnum(encoding, routingStorageContainerProperties_Encoding_Values)
		properties.Encoding = &encodingTemp
	} else {
		properties.Encoding = nil
	}

	// EndpointUri
	properties.EndpointUri = genruntime.ClonePointerToString(source.EndpointUri)

	// FileNameFormat
	properties.FileNameFormat = genruntime.ClonePointerToString(source.FileNameFormat)

	// Identity
	if source.Identity != nil {
		var identity ManagedIdentity
		err := identity.AssignProperties_From_ManagedIdentity(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedIdentity() to populate field Identity")
		}
		properties.Identity = &identity
	} else {
		properties.Identity = nil
	}

	// MaxChunkSizeInBytes
	properties.MaxChunkSizeInBytes = genruntime.ClonePointerToInt(source.MaxChunkSizeInBytes)

	// Name
	properties.Name = genruntime.ClonePointerToString(source.Name)

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		properties.Reference = &reference
	} else {
		properties.Reference = nil
	}

	// ResourceGroup
	properties.ResourceGroup = genruntime.ClonePointerToString(source.ResourceGroup)

	// SubscriptionId
	properties.SubscriptionId = genruntime.ClonePointerToString(source.SubscriptionId)

	// No error
	return nil
}

// AssignProperties_To_RoutingStorageContainerProperties populates the provided destination RoutingStorageContainerProperties from our RoutingStorageContainerProperties
func (properties *RoutingStorageContainerProperties) AssignProperties_To_RoutingStorageContainerProperties(destination *storage.RoutingStorageContainerProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthenticationType
	if properties.AuthenticationType != nil {
		authenticationType := string(*properties.AuthenticationType)
		destination.AuthenticationType = &authenticationType
	} else {
		destination.AuthenticationType = nil
	}

	// BatchFrequencyInSeconds
	destination.BatchFrequencyInSeconds = genruntime.ClonePointerToInt(properties.BatchFrequencyInSeconds)

	// ConnectionString
	if properties.ConnectionString != nil {
		connectionString := properties.ConnectionString.Copy()
		destination.ConnectionString = &connectionString
	} else {
		destination.ConnectionString = nil
	}

	// ContainerName
	destination.ContainerName = genruntime.ClonePointerToString(properties.ContainerName)

	// Encoding
	if properties.Encoding != nil {
		encoding := string(*properties.Encoding)
		destination.Encoding = &encoding
	} else {
		destination.Encoding = nil
	}

	// EndpointUri
	destination.EndpointUri = genruntime.ClonePointerToString(properties.EndpointUri)

	// FileNameFormat
	destination.FileNameFormat = genruntime.ClonePointerToString(properties.FileNameFormat)

	// Identity
	if properties.Identity != nil {
		var identity storage.ManagedIdentity
		err := properties.Identity.AssignProperties_To_ManagedIdentity(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// MaxChunkSizeInBytes
	destination.MaxChunkSizeInBytes = genruntime.ClonePointerToInt(properties.MaxChunkSizeInBytes)

	// Name
	destination.Name = genruntime.ClonePointerToString(properties.Name)

	// Reference
	if properties.Reference != nil {
		reference := properties.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// ResourceGroup
	destination.ResourceGroup = genruntime.ClonePointerToString(properties.ResourceGroup)

	// SubscriptionId
	destination.SubscriptionId = genruntime.ClonePointerToString(properties.SubscriptionId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RoutingStorageContainerProperties_STATUS populates our RoutingStorageContainerProperties from the provided source RoutingStorageContainerProperties_STATUS
func (properties *RoutingStorageContainerProperties) Initialize_From_RoutingStorageContainerProperties_STATUS(source *RoutingStorageContainerProperties_STATUS) error {

	// AuthenticationType
	if source.AuthenticationType != nil {
		authenticationType := genruntime.ToEnum(string(*source.AuthenticationType), routingStorageContainerProperties_AuthenticationType_Values)
		properties.AuthenticationType = &authenticationType
	} else {
		properties.AuthenticationType = nil
	}

	// BatchFrequencyInSeconds
	properties.BatchFrequencyInSeconds = genruntime.ClonePointerToInt(source.BatchFrequencyInSeconds)

	// ContainerName
	properties.ContainerName = genruntime.ClonePointerToString(source.ContainerName)

	// Encoding
	if source.Encoding != nil {
		encoding := genruntime.ToEnum(string(*source.Encoding), routingStorageContainerProperties_Encoding_Values)
		properties.Encoding = &encoding
	} else {
		properties.Encoding = nil
	}

	// EndpointUri
	properties.EndpointUri = genruntime.ClonePointerToString(source.EndpointUri)

	// FileNameFormat
	properties.FileNameFormat = genruntime.ClonePointerToString(source.FileNameFormat)

	// Identity
	if source.Identity != nil {
		var identity ManagedIdentity
		err := identity.Initialize_From_ManagedIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ManagedIdentity_STATUS() to populate field Identity")
		}
		properties.Identity = &identity
	} else {
		properties.Identity = nil
	}

	// MaxChunkSizeInBytes
	properties.MaxChunkSizeInBytes = genruntime.ClonePointerToInt(source.MaxChunkSizeInBytes)

	// Name
	properties.Name = genruntime.ClonePointerToString(source.Name)

	// Reference
	if source.Id != nil {
		reference := genruntime.CreateResourceReferenceFromARMID(*source.Id)
		properties.Reference = &reference
	} else {
		properties.Reference = nil
	}

	// ResourceGroup
	properties.ResourceGroup = genruntime.ClonePointerToString(source.ResourceGroup)

	// SubscriptionId
	properties.SubscriptionId = genruntime.ClonePointerToString(source.SubscriptionId)

	// No error
	return nil
}

// The properties related to a storage container endpoint.
type RoutingStorageContainerProperties_STATUS struct {
	// AuthenticationType: Method used to authenticate against the storage endpoint
	AuthenticationType *RoutingStorageContainerProperties_AuthenticationType_STATUS `json:"authenticationType,omitempty"`

	// BatchFrequencyInSeconds: Time interval at which blobs are written to storage. Value should be between 60 and 720
	// seconds. Default value is 300 seconds.
	BatchFrequencyInSeconds *int `json:"batchFrequencyInSeconds,omitempty"`

	// ContainerName: The name of storage container in the storage account.
	ContainerName *string `json:"containerName,omitempty"`

	// Encoding: Encoding that is used to serialize messages to blobs. Supported values are 'avro', 'avrodeflate', and 'JSON'.
	// Default value is 'avro'.
	Encoding *RoutingStorageContainerProperties_Encoding_STATUS `json:"encoding,omitempty"`

	// EndpointUri: The url of the storage endpoint. It must include the protocol https://
	EndpointUri *string `json:"endpointUri,omitempty"`

	// FileNameFormat: File name format for the blob. Default format is {iothub}/{partition}/{YYYY}/{MM}/{DD}/{HH}/{mm}. All
	// parameters are mandatory but can be reordered.
	FileNameFormat *string `json:"fileNameFormat,omitempty"`

	// Id: Id of the storage container endpoint
	Id *string `json:"id,omitempty"`

	// Identity: Managed identity properties of routing storage endpoint.
	Identity *ManagedIdentity_STATUS `json:"identity,omitempty"`

	// MaxChunkSizeInBytes: Maximum number of bytes for each blob written to storage. Value should be between 10485760(10MB)
	// and 524288000(500MB). Default value is 314572800(300MB).
	MaxChunkSizeInBytes *int `json:"maxChunkSizeInBytes,omitempty"`

	// Name: The name that identifies this endpoint. The name can only include alphanumeric characters, periods, underscores,
	// hyphens and has a maximum length of 64 characters. The following names are reserved:  events, fileNotifications,
	// $default. Endpoint names must be unique across endpoint types.
	Name *string `json:"name,omitempty"`

	// ResourceGroup: The name of the resource group of the storage account.
	ResourceGroup *string `json:"resourceGroup,omitempty"`

	// SubscriptionId: The subscription identifier of the storage account.
	SubscriptionId *string `json:"subscriptionId,omitempty"`
}

var _ genruntime.FromARMConverter = &RoutingStorageContainerProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *RoutingStorageContainerProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RoutingStorageContainerProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *RoutingStorageContainerProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RoutingStorageContainerProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RoutingStorageContainerProperties_STATUS, got %T", armInput)
	}

	// Set property "AuthenticationType":
	if typedInput.AuthenticationType != nil {
		var temp string
		temp = string(*typedInput.AuthenticationType)
		authenticationType := RoutingStorageContainerProperties_AuthenticationType_STATUS(temp)
		properties.AuthenticationType = &authenticationType
	}

	// Set property "BatchFrequencyInSeconds":
	if typedInput.BatchFrequencyInSeconds != nil {
		batchFrequencyInSeconds := *typedInput.BatchFrequencyInSeconds
		properties.BatchFrequencyInSeconds = &batchFrequencyInSeconds
	}

	// Set property "ContainerName":
	if typedInput.ContainerName != nil {
		containerName := *typedInput.ContainerName
		properties.ContainerName = &containerName
	}

	// Set property "Encoding":
	if typedInput.Encoding != nil {
		var temp string
		temp = string(*typedInput.Encoding)
		encoding := RoutingStorageContainerProperties_Encoding_STATUS(temp)
		properties.Encoding = &encoding
	}

	// Set property "EndpointUri":
	if typedInput.EndpointUri != nil {
		endpointUri := *typedInput.EndpointUri
		properties.EndpointUri = &endpointUri
	}

	// Set property "FileNameFormat":
	if typedInput.FileNameFormat != nil {
		fileNameFormat := *typedInput.FileNameFormat
		properties.FileNameFormat = &fileNameFormat
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		properties.Id = &id
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		properties.Identity = &identity
	}

	// Set property "MaxChunkSizeInBytes":
	if typedInput.MaxChunkSizeInBytes != nil {
		maxChunkSizeInBytes := *typedInput.MaxChunkSizeInBytes
		properties.MaxChunkSizeInBytes = &maxChunkSizeInBytes
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		properties.Name = &name
	}

	// Set property "ResourceGroup":
	if typedInput.ResourceGroup != nil {
		resourceGroup := *typedInput.ResourceGroup
		properties.ResourceGroup = &resourceGroup
	}

	// Set property "SubscriptionId":
	if typedInput.SubscriptionId != nil {
		subscriptionId := *typedInput.SubscriptionId
		properties.SubscriptionId = &subscriptionId
	}

	// No error
	return nil
}

// AssignProperties_From_RoutingStorageContainerProperties_STATUS populates our RoutingStorageContainerProperties_STATUS from the provided source RoutingStorageContainerProperties_STATUS
func (properties *RoutingStorageContainerProperties_STATUS) AssignProperties_From_RoutingStorageContainerProperties_STATUS(source *storage.RoutingStorageContainerProperties_STATUS) error {

	// AuthenticationType
	if source.AuthenticationType != nil {
		authenticationType := *source.AuthenticationType
		authenticationTypeTemp := genruntime.ToEnum(authenticationType, routingStorageContainerProperties_AuthenticationType_STATUS_Values)
		properties.AuthenticationType = &authenticationTypeTemp
	} else {
		properties.AuthenticationType = nil
	}

	// BatchFrequencyInSeconds
	properties.BatchFrequencyInSeconds = genruntime.ClonePointerToInt(source.BatchFrequencyInSeconds)

	// ContainerName
	properties.ContainerName = genruntime.ClonePointerToString(source.ContainerName)

	// Encoding
	if source.Encoding != nil {
		encoding := *source.Encoding
		encodingTemp := genruntime.ToEnum(encoding, routingStorageContainerProperties_Encoding_STATUS_Values)
		properties.Encoding = &encodingTemp
	} else {
		properties.Encoding = nil
	}

	// EndpointUri
	properties.EndpointUri = genruntime.ClonePointerToString(source.EndpointUri)

	// FileNameFormat
	properties.FileNameFormat = genruntime.ClonePointerToString(source.FileNameFormat)

	// Id
	properties.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity ManagedIdentity_STATUS
		err := identity.AssignProperties_From_ManagedIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedIdentity_STATUS() to populate field Identity")
		}
		properties.Identity = &identity
	} else {
		properties.Identity = nil
	}

	// MaxChunkSizeInBytes
	properties.MaxChunkSizeInBytes = genruntime.ClonePointerToInt(source.MaxChunkSizeInBytes)

	// Name
	properties.Name = genruntime.ClonePointerToString(source.Name)

	// ResourceGroup
	properties.ResourceGroup = genruntime.ClonePointerToString(source.ResourceGroup)

	// SubscriptionId
	properties.SubscriptionId = genruntime.ClonePointerToString(source.SubscriptionId)

	// No error
	return nil
}

// AssignProperties_To_RoutingStorageContainerProperties_STATUS populates the provided destination RoutingStorageContainerProperties_STATUS from our RoutingStorageContainerProperties_STATUS
func (properties *RoutingStorageContainerProperties_STATUS) AssignProperties_To_RoutingStorageContainerProperties_STATUS(destination *storage.RoutingStorageContainerProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthenticationType
	if properties.AuthenticationType != nil {
		authenticationType := string(*properties.AuthenticationType)
		destination.AuthenticationType = &authenticationType
	} else {
		destination.AuthenticationType = nil
	}

	// BatchFrequencyInSeconds
	destination.BatchFrequencyInSeconds = genruntime.ClonePointerToInt(properties.BatchFrequencyInSeconds)

	// ContainerName
	destination.ContainerName = genruntime.ClonePointerToString(properties.ContainerName)

	// Encoding
	if properties.Encoding != nil {
		encoding := string(*properties.Encoding)
		destination.Encoding = &encoding
	} else {
		destination.Encoding = nil
	}

	// EndpointUri
	destination.EndpointUri = genruntime.ClonePointerToString(properties.EndpointUri)

	// FileNameFormat
	destination.FileNameFormat = genruntime.ClonePointerToString(properties.FileNameFormat)

	// Id
	destination.Id = genruntime.ClonePointerToString(properties.Id)

	// Identity
	if properties.Identity != nil {
		var identity storage.ManagedIdentity_STATUS
		err := properties.Identity.AssignProperties_To_ManagedIdentity_STATUS(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// MaxChunkSizeInBytes
	destination.MaxChunkSizeInBytes = genruntime.ClonePointerToInt(properties.MaxChunkSizeInBytes)

	// Name
	destination.Name = genruntime.ClonePointerToString(properties.Name)

	// ResourceGroup
	destination.ResourceGroup = genruntime.ClonePointerToString(properties.ResourceGroup)

	// SubscriptionId
	destination.SubscriptionId = genruntime.ClonePointerToString(properties.SubscriptionId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"identityBased","keyBased"}
type RoutingEventHubProperties_AuthenticationType string

const (
	RoutingEventHubProperties_AuthenticationType_IdentityBased = RoutingEventHubProperties_AuthenticationType("identityBased")
	RoutingEventHubProperties_AuthenticationType_KeyBased      = RoutingEventHubProperties_AuthenticationType("keyBased")
)

// Mapping from string to RoutingEventHubProperties_AuthenticationType
var routingEventHubProperties_AuthenticationType_Values = map[string]RoutingEventHubProperties_AuthenticationType{
	"identitybased": RoutingEventHubProperties_AuthenticationType_IdentityBased,
	"keybased":      RoutingEventHubProperties_AuthenticationType_KeyBased,
}

type RoutingEventHubProperties_AuthenticationType_STATUS string

const (
	RoutingEventHubProperties_AuthenticationType_STATUS_IdentityBased = RoutingEventHubProperties_AuthenticationType_STATUS("identityBased")
	RoutingEventHubProperties_AuthenticationType_STATUS_KeyBased      = RoutingEventHubProperties_AuthenticationType_STATUS("keyBased")
)

// Mapping from string to RoutingEventHubProperties_AuthenticationType_STATUS
var routingEventHubProperties_AuthenticationType_STATUS_Values = map[string]RoutingEventHubProperties_AuthenticationType_STATUS{
	"identitybased": RoutingEventHubProperties_AuthenticationType_STATUS_IdentityBased,
	"keybased":      RoutingEventHubProperties_AuthenticationType_STATUS_KeyBased,
}

// +kubebuilder:validation:Enum={"identityBased","keyBased"}
type RoutingServiceBusQueueEndpointProperties_AuthenticationType string

const (
	RoutingServiceBusQueueEndpointProperties_AuthenticationType_IdentityBased = RoutingServiceBusQueueEndpointProperties_AuthenticationType("identityBased")
	RoutingServiceBusQueueEndpointProperties_AuthenticationType_KeyBased      = RoutingServiceBusQueueEndpointProperties_AuthenticationType("keyBased")
)

// Mapping from string to RoutingServiceBusQueueEndpointProperties_AuthenticationType
var routingServiceBusQueueEndpointProperties_AuthenticationType_Values = map[string]RoutingServiceBusQueueEndpointProperties_AuthenticationType{
	"identitybased": RoutingServiceBusQueueEndpointProperties_AuthenticationType_IdentityBased,
	"keybased":      RoutingServiceBusQueueEndpointProperties_AuthenticationType_KeyBased,
}

type RoutingServiceBusQueueEndpointProperties_AuthenticationType_STATUS string

const (
	RoutingServiceBusQueueEndpointProperties_AuthenticationType_STATUS_IdentityBased = RoutingServiceBusQueueEndpointProperties_AuthenticationType_STATUS("identityBased")
	RoutingServiceBusQueueEndpointProperties_AuthenticationType_STATUS_KeyBased      = RoutingServiceBusQueueEndpointProperties_AuthenticationType_STATUS("keyBased")
)

// Mapping from string to RoutingServiceBusQueueEndpointProperties_AuthenticationType_STATUS
var routingServiceBusQueueEndpointProperties_AuthenticationType_STATUS_Values = map[string]RoutingServiceBusQueueEndpointProperties_AuthenticationType_STATUS{
	"identitybased": RoutingServiceBusQueueEndpointProperties_AuthenticationType_STATUS_IdentityBased,
	"keybased":      RoutingServiceBusQueueEndpointProperties_AuthenticationType_STATUS_KeyBased,
}

// +kubebuilder:validation:Enum={"identityBased","keyBased"}
type RoutingServiceBusTopicEndpointProperties_AuthenticationType string

const (
	RoutingServiceBusTopicEndpointProperties_AuthenticationType_IdentityBased = RoutingServiceBusTopicEndpointProperties_AuthenticationType("identityBased")
	RoutingServiceBusTopicEndpointProperties_AuthenticationType_KeyBased      = RoutingServiceBusTopicEndpointProperties_AuthenticationType("keyBased")
)

// Mapping from string to RoutingServiceBusTopicEndpointProperties_AuthenticationType
var routingServiceBusTopicEndpointProperties_AuthenticationType_Values = map[string]RoutingServiceBusTopicEndpointProperties_AuthenticationType{
	"identitybased": RoutingServiceBusTopicEndpointProperties_AuthenticationType_IdentityBased,
	"keybased":      RoutingServiceBusTopicEndpointProperties_AuthenticationType_KeyBased,
}

type RoutingServiceBusTopicEndpointProperties_AuthenticationType_STATUS string

const (
	RoutingServiceBusTopicEndpointProperties_AuthenticationType_STATUS_IdentityBased = RoutingServiceBusTopicEndpointProperties_AuthenticationType_STATUS("identityBased")
	RoutingServiceBusTopicEndpointProperties_AuthenticationType_STATUS_KeyBased      = RoutingServiceBusTopicEndpointProperties_AuthenticationType_STATUS("keyBased")
)

// Mapping from string to RoutingServiceBusTopicEndpointProperties_AuthenticationType_STATUS
var routingServiceBusTopicEndpointProperties_AuthenticationType_STATUS_Values = map[string]RoutingServiceBusTopicEndpointProperties_AuthenticationType_STATUS{
	"identitybased": RoutingServiceBusTopicEndpointProperties_AuthenticationType_STATUS_IdentityBased,
	"keybased":      RoutingServiceBusTopicEndpointProperties_AuthenticationType_STATUS_KeyBased,
}

// +kubebuilder:validation:Enum={"identityBased","keyBased"}
type RoutingStorageContainerProperties_AuthenticationType string

const (
	RoutingStorageContainerProperties_AuthenticationType_IdentityBased = RoutingStorageContainerProperties_AuthenticationType("identityBased")
	RoutingStorageContainerProperties_AuthenticationType_KeyBased      = RoutingStorageContainerProperties_AuthenticationType("keyBased")
)

// Mapping from string to RoutingStorageContainerProperties_AuthenticationType
var routingStorageContainerProperties_AuthenticationType_Values = map[string]RoutingStorageContainerProperties_AuthenticationType{
	"identitybased": RoutingStorageContainerProperties_AuthenticationType_IdentityBased,
	"keybased":      RoutingStorageContainerProperties_AuthenticationType_KeyBased,
}

type RoutingStorageContainerProperties_AuthenticationType_STATUS string

const (
	RoutingStorageContainerProperties_AuthenticationType_STATUS_IdentityBased = RoutingStorageContainerProperties_AuthenticationType_STATUS("identityBased")
	RoutingStorageContainerProperties_AuthenticationType_STATUS_KeyBased      = RoutingStorageContainerProperties_AuthenticationType_STATUS("keyBased")
)

// Mapping from string to RoutingStorageContainerProperties_AuthenticationType_STATUS
var routingStorageContainerProperties_AuthenticationType_STATUS_Values = map[string]RoutingStorageContainerProperties_AuthenticationType_STATUS{
	"identitybased": RoutingStorageContainerProperties_AuthenticationType_STATUS_IdentityBased,
	"keybased":      RoutingStorageContainerProperties_AuthenticationType_STATUS_KeyBased,
}

// +kubebuilder:validation:Enum={"Avro","AvroDeflate","JSON"}
type RoutingStorageContainerProperties_Encoding string

const (
	RoutingStorageContainerProperties_Encoding_Avro        = RoutingStorageContainerProperties_Encoding("Avro")
	RoutingStorageContainerProperties_Encoding_AvroDeflate = RoutingStorageContainerProperties_Encoding("AvroDeflate")
	RoutingStorageContainerProperties_Encoding_JSON        = RoutingStorageContainerProperties_Encoding("JSON")
)

// Mapping from string to RoutingStorageContainerProperties_Encoding
var routingStorageContainerProperties_Encoding_Values = map[string]RoutingStorageContainerProperties_Encoding{
	"avro":        RoutingStorageContainerProperties_Encoding_Avro,
	"avrodeflate": RoutingStorageContainerProperties_Encoding_AvroDeflate,
	"json":        RoutingStorageContainerProperties_Encoding_JSON,
}

type RoutingStorageContainerProperties_Encoding_STATUS string

const (
	RoutingStorageContainerProperties_Encoding_STATUS_Avro        = RoutingStorageContainerProperties_Encoding_STATUS("Avro")
	RoutingStorageContainerProperties_Encoding_STATUS_AvroDeflate = RoutingStorageContainerProperties_Encoding_STATUS("AvroDeflate")
	RoutingStorageContainerProperties_Encoding_STATUS_JSON        = RoutingStorageContainerProperties_Encoding_STATUS("JSON")
)

// Mapping from string to RoutingStorageContainerProperties_Encoding_STATUS
var routingStorageContainerProperties_Encoding_STATUS_Values = map[string]RoutingStorageContainerProperties_Encoding_STATUS{
	"avro":        RoutingStorageContainerProperties_Encoding_STATUS_Avro,
	"avrodeflate": RoutingStorageContainerProperties_Encoding_STATUS_AvroDeflate,
	"json":        RoutingStorageContainerProperties_Encoding_STATUS_JSON,
}

func init() {
	SchemeBuilder.Register(&IotHub{}, &IotHubList{})
}
