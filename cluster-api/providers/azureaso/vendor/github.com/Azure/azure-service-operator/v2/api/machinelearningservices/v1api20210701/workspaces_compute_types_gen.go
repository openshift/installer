// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20210701

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/machinelearningservices/v1api20210701/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/machinelearningservices/v1api20210701/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/rotisserie/eris"
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /machinelearningservices/resource-manager/Microsoft.MachineLearningServices/stable/2021-07-01/machineLearningServices.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/computes/{computeName}
type WorkspacesCompute struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              WorkspacesCompute_Spec   `json:"spec,omitempty"`
	Status            WorkspacesCompute_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &WorkspacesCompute{}

// GetConditions returns the conditions of the resource
func (compute *WorkspacesCompute) GetConditions() conditions.Conditions {
	return compute.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (compute *WorkspacesCompute) SetConditions(conditions conditions.Conditions) {
	compute.Status.Conditions = conditions
}

var _ conversion.Convertible = &WorkspacesCompute{}

// ConvertFrom populates our WorkspacesCompute from the provided hub WorkspacesCompute
func (compute *WorkspacesCompute) ConvertFrom(hub conversion.Hub) error {
	// intermediate variable for conversion
	var source storage.WorkspacesCompute

	err := source.ConvertFrom(hub)
	if err != nil {
		return eris.Wrap(err, "converting from hub to source")
	}

	err = compute.AssignProperties_From_WorkspacesCompute(&source)
	if err != nil {
		return eris.Wrap(err, "converting from source to compute")
	}

	return nil
}

// ConvertTo populates the provided hub WorkspacesCompute from our WorkspacesCompute
func (compute *WorkspacesCompute) ConvertTo(hub conversion.Hub) error {
	// intermediate variable for conversion
	var destination storage.WorkspacesCompute
	err := compute.AssignProperties_To_WorkspacesCompute(&destination)
	if err != nil {
		return eris.Wrap(err, "converting to destination from compute")
	}
	err = destination.ConvertTo(hub)
	if err != nil {
		return eris.Wrap(err, "converting from destination to hub")
	}

	return nil
}

var _ configmaps.Exporter = &WorkspacesCompute{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (compute *WorkspacesCompute) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if compute.Spec.OperatorSpec == nil {
		return nil
	}
	return compute.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &WorkspacesCompute{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (compute *WorkspacesCompute) SecretDestinationExpressions() []*core.DestinationExpression {
	if compute.Spec.OperatorSpec == nil {
		return nil
	}
	return compute.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.KubernetesResource = &WorkspacesCompute{}

// AzureName returns the Azure name of the resource
func (compute *WorkspacesCompute) AzureName() string {
	return compute.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2021-07-01"
func (compute WorkspacesCompute) GetAPIVersion() string {
	return "2021-07-01"
}

// GetResourceScope returns the scope of the resource
func (compute *WorkspacesCompute) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (compute *WorkspacesCompute) GetSpec() genruntime.ConvertibleSpec {
	return &compute.Spec
}

// GetStatus returns the status of this resource
func (compute *WorkspacesCompute) GetStatus() genruntime.ConvertibleStatus {
	return &compute.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (compute *WorkspacesCompute) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.MachineLearningServices/workspaces/computes"
func (compute *WorkspacesCompute) GetType() string {
	return "Microsoft.MachineLearningServices/workspaces/computes"
}

// NewEmptyStatus returns a new empty (blank) status
func (compute *WorkspacesCompute) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &WorkspacesCompute_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (compute *WorkspacesCompute) Owner() *genruntime.ResourceReference {
	if compute.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(compute.Spec)
	return compute.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (compute *WorkspacesCompute) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*WorkspacesCompute_STATUS); ok {
		compute.Status = *st
		return nil
	}

	// Convert status to required version
	var st WorkspacesCompute_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	compute.Status = st
	return nil
}

// AssignProperties_From_WorkspacesCompute populates our WorkspacesCompute from the provided source WorkspacesCompute
func (compute *WorkspacesCompute) AssignProperties_From_WorkspacesCompute(source *storage.WorkspacesCompute) error {

	// ObjectMeta
	compute.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec WorkspacesCompute_Spec
	err := spec.AssignProperties_From_WorkspacesCompute_Spec(&source.Spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_WorkspacesCompute_Spec() to populate field Spec")
	}
	compute.Spec = spec

	// Status
	var status WorkspacesCompute_STATUS
	err = status.AssignProperties_From_WorkspacesCompute_STATUS(&source.Status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_WorkspacesCompute_STATUS() to populate field Status")
	}
	compute.Status = status

	// No error
	return nil
}

// AssignProperties_To_WorkspacesCompute populates the provided destination WorkspacesCompute from our WorkspacesCompute
func (compute *WorkspacesCompute) AssignProperties_To_WorkspacesCompute(destination *storage.WorkspacesCompute) error {

	// ObjectMeta
	destination.ObjectMeta = *compute.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.WorkspacesCompute_Spec
	err := compute.Spec.AssignProperties_To_WorkspacesCompute_Spec(&spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_WorkspacesCompute_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.WorkspacesCompute_STATUS
	err = compute.Status.AssignProperties_To_WorkspacesCompute_STATUS(&status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_WorkspacesCompute_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (compute *WorkspacesCompute) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: compute.Spec.OriginalVersion(),
		Kind:    "WorkspacesCompute",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /machinelearningservices/resource-manager/Microsoft.MachineLearningServices/stable/2021-07-01/machineLearningServices.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/computes/{computeName}
type WorkspacesComputeList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []WorkspacesCompute `json:"items"`
}

type WorkspacesCompute_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// Identity: The identity of the resource.
	Identity *Identity `json:"identity,omitempty"`

	// Location: Specifies the location of the resource.
	Location *string `json:"location,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *WorkspacesComputeOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a machinelearningservices.azure.com/Workspace resource
	Owner *genruntime.KnownResourceReference `group:"machinelearningservices.azure.com" json:"owner,omitempty" kind:"Workspace"`

	// Properties: Compute properties
	Properties *Compute `json:"properties,omitempty"`

	// Sku: The sku of the workspace.
	Sku *Sku `json:"sku,omitempty"`

	// SystemData: System data
	SystemData *SystemData `json:"systemData,omitempty"`

	// Tags: Contains resource tags defined as key/value pairs.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &WorkspacesCompute_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (compute *WorkspacesCompute_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if compute == nil {
		return nil, nil
	}
	result := &arm.WorkspacesCompute_Spec{}

	// Set property "Identity":
	if compute.Identity != nil {
		identity_ARM, err := (*compute.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*arm.Identity)
		result.Identity = &identity
	}

	// Set property "Location":
	if compute.Location != nil {
		location := *compute.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if compute.Properties != nil {
		properties_ARM, err := (*compute.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*arm.Compute)
		result.Properties = &properties
	}

	// Set property "Sku":
	if compute.Sku != nil {
		sku_ARM, err := (*compute.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := *sku_ARM.(*arm.Sku)
		result.Sku = &sku
	}

	// Set property "SystemData":
	if compute.SystemData != nil {
		systemData_ARM, err := (*compute.SystemData).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		systemData := *systemData_ARM.(*arm.SystemData)
		result.SystemData = &systemData
	}

	// Set property "Tags":
	if compute.Tags != nil {
		result.Tags = make(map[string]string, len(compute.Tags))
		for key, value := range compute.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (compute *WorkspacesCompute_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspacesCompute_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (compute *WorkspacesCompute_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspacesCompute_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspacesCompute_Spec, got %T", armInput)
	}

	// Set property "AzureName":
	compute.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 Identity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		compute.Identity = &identity
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		compute.Location = &location
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	compute.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 Compute
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		compute.Properties = &properties
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 Sku
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		compute.Sku = &sku
	}

	// Set property "SystemData":
	if typedInput.SystemData != nil {
		var systemData1 SystemData
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		compute.SystemData = &systemData
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		compute.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			compute.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &WorkspacesCompute_Spec{}

// ConvertSpecFrom populates our WorkspacesCompute_Spec from the provided source
func (compute *WorkspacesCompute_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.WorkspacesCompute_Spec)
	if ok {
		// Populate our instance from source
		return compute.AssignProperties_From_WorkspacesCompute_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.WorkspacesCompute_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = compute.AssignProperties_From_WorkspacesCompute_Spec(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our WorkspacesCompute_Spec
func (compute *WorkspacesCompute_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.WorkspacesCompute_Spec)
	if ok {
		// Populate destination from our instance
		return compute.AssignProperties_To_WorkspacesCompute_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.WorkspacesCompute_Spec{}
	err := compute.AssignProperties_To_WorkspacesCompute_Spec(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_WorkspacesCompute_Spec populates our WorkspacesCompute_Spec from the provided source WorkspacesCompute_Spec
func (compute *WorkspacesCompute_Spec) AssignProperties_From_WorkspacesCompute_Spec(source *storage.WorkspacesCompute_Spec) error {

	// AzureName
	compute.AzureName = source.AzureName

	// Identity
	if source.Identity != nil {
		var identity Identity
		err := identity.AssignProperties_From_Identity(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Identity() to populate field Identity")
		}
		compute.Identity = &identity
	} else {
		compute.Identity = nil
	}

	// Location
	compute.Location = genruntime.ClonePointerToString(source.Location)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec WorkspacesComputeOperatorSpec
		err := operatorSpec.AssignProperties_From_WorkspacesComputeOperatorSpec(source.OperatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspacesComputeOperatorSpec() to populate field OperatorSpec")
		}
		compute.OperatorSpec = &operatorSpec
	} else {
		compute.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		compute.Owner = &owner
	} else {
		compute.Owner = nil
	}

	// Properties
	if source.Properties != nil {
		var property Compute
		err := property.AssignProperties_From_Compute(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Compute() to populate field Properties")
		}
		compute.Properties = &property
	} else {
		compute.Properties = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.AssignProperties_From_Sku(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Sku() to populate field Sku")
		}
		compute.Sku = &sku
	} else {
		compute.Sku = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData
		err := systemDatum.AssignProperties_From_SystemData(source.SystemData)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SystemData() to populate field SystemData")
		}
		compute.SystemData = &systemDatum
	} else {
		compute.SystemData = nil
	}

	// Tags
	compute.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// AssignProperties_To_WorkspacesCompute_Spec populates the provided destination WorkspacesCompute_Spec from our WorkspacesCompute_Spec
func (compute *WorkspacesCompute_Spec) AssignProperties_To_WorkspacesCompute_Spec(destination *storage.WorkspacesCompute_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = compute.AzureName

	// Identity
	if compute.Identity != nil {
		var identity storage.Identity
		err := compute.Identity.AssignProperties_To_Identity(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Identity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(compute.Location)

	// OperatorSpec
	if compute.OperatorSpec != nil {
		var operatorSpec storage.WorkspacesComputeOperatorSpec
		err := compute.OperatorSpec.AssignProperties_To_WorkspacesComputeOperatorSpec(&operatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspacesComputeOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = compute.OriginalVersion()

	// Owner
	if compute.Owner != nil {
		owner := compute.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Properties
	if compute.Properties != nil {
		var property storage.Compute
		err := compute.Properties.AssignProperties_To_Compute(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Compute() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// Sku
	if compute.Sku != nil {
		var sku storage.Sku
		err := compute.Sku.AssignProperties_To_Sku(&sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Sku() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// SystemData
	if compute.SystemData != nil {
		var systemDatum storage.SystemData
		err := compute.SystemData.AssignProperties_To_SystemData(&systemDatum)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SystemData() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(compute.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (compute *WorkspacesCompute_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (compute *WorkspacesCompute_Spec) SetAzureName(azureName string) { compute.AzureName = azureName }

type WorkspacesCompute_STATUS struct {
	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// Id: Fully qualified resource ID for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`

	// Identity: The identity of the resource.
	Identity *Identity_STATUS `json:"identity,omitempty"`

	// Location: Specifies the location of the resource.
	Location *string `json:"location,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// Properties: Compute properties
	Properties *Compute_STATUS `json:"properties,omitempty"`

	// Sku: The sku of the workspace.
	Sku *Sku_STATUS `json:"sku,omitempty"`

	// SystemData: System data
	SystemData *SystemData_STATUS `json:"systemData,omitempty"`

	// Tags: Contains resource tags defined as key/value pairs.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &WorkspacesCompute_STATUS{}

// ConvertStatusFrom populates our WorkspacesCompute_STATUS from the provided source
func (compute *WorkspacesCompute_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.WorkspacesCompute_STATUS)
	if ok {
		// Populate our instance from source
		return compute.AssignProperties_From_WorkspacesCompute_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.WorkspacesCompute_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = compute.AssignProperties_From_WorkspacesCompute_STATUS(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our WorkspacesCompute_STATUS
func (compute *WorkspacesCompute_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.WorkspacesCompute_STATUS)
	if ok {
		// Populate destination from our instance
		return compute.AssignProperties_To_WorkspacesCompute_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.WorkspacesCompute_STATUS{}
	err := compute.AssignProperties_To_WorkspacesCompute_STATUS(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &WorkspacesCompute_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (compute *WorkspacesCompute_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspacesCompute_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (compute *WorkspacesCompute_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspacesCompute_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspacesCompute_STATUS, got %T", armInput)
	}

	// no assignment for property "Conditions"

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		compute.Id = &id
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 Identity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		compute.Identity = &identity
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		compute.Location = &location
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		compute.Name = &name
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 Compute_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		compute.Properties = &properties
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 Sku_STATUS
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		compute.Sku = &sku
	}

	// Set property "SystemData":
	if typedInput.SystemData != nil {
		var systemData1 SystemData_STATUS
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		compute.SystemData = &systemData
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		compute.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			compute.Tags[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		compute.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_WorkspacesCompute_STATUS populates our WorkspacesCompute_STATUS from the provided source WorkspacesCompute_STATUS
func (compute *WorkspacesCompute_STATUS) AssignProperties_From_WorkspacesCompute_STATUS(source *storage.WorkspacesCompute_STATUS) error {

	// Conditions
	compute.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// Id
	compute.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity Identity_STATUS
		err := identity.AssignProperties_From_Identity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Identity_STATUS() to populate field Identity")
		}
		compute.Identity = &identity
	} else {
		compute.Identity = nil
	}

	// Location
	compute.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	compute.Name = genruntime.ClonePointerToString(source.Name)

	// Properties
	if source.Properties != nil {
		var property Compute_STATUS
		err := property.AssignProperties_From_Compute_STATUS(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Compute_STATUS() to populate field Properties")
		}
		compute.Properties = &property
	} else {
		compute.Properties = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku_STATUS
		err := sku.AssignProperties_From_Sku_STATUS(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Sku_STATUS() to populate field Sku")
		}
		compute.Sku = &sku
	} else {
		compute.Sku = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		compute.SystemData = &systemDatum
	} else {
		compute.SystemData = nil
	}

	// Tags
	compute.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	compute.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_WorkspacesCompute_STATUS populates the provided destination WorkspacesCompute_STATUS from our WorkspacesCompute_STATUS
func (compute *WorkspacesCompute_STATUS) AssignProperties_To_WorkspacesCompute_STATUS(destination *storage.WorkspacesCompute_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(compute.Conditions)

	// Id
	destination.Id = genruntime.ClonePointerToString(compute.Id)

	// Identity
	if compute.Identity != nil {
		var identity storage.Identity_STATUS
		err := compute.Identity.AssignProperties_To_Identity_STATUS(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Identity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(compute.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(compute.Name)

	// Properties
	if compute.Properties != nil {
		var property storage.Compute_STATUS
		err := compute.Properties.AssignProperties_To_Compute_STATUS(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Compute_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// Sku
	if compute.Sku != nil {
		var sku storage.Sku_STATUS
		err := compute.Sku.AssignProperties_To_Sku_STATUS(&sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Sku_STATUS() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// SystemData
	if compute.SystemData != nil {
		var systemDatum storage.SystemData_STATUS
		err := compute.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(compute.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(compute.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Compute struct {
	// AKS: Mutually exclusive with all other properties
	AKS *AKS `json:"aks,omitempty"`

	// AmlCompute: Mutually exclusive with all other properties
	AmlCompute *AmlCompute `json:"amlCompute,omitempty"`

	// ComputeInstance: Mutually exclusive with all other properties
	ComputeInstance *ComputeInstance `json:"computeInstance,omitempty"`

	// DataFactory: Mutually exclusive with all other properties
	DataFactory *DataFactory `json:"dataFactory,omitempty"`

	// DataLakeAnalytics: Mutually exclusive with all other properties
	DataLakeAnalytics *DataLakeAnalytics `json:"dataLakeAnalytics,omitempty"`

	// Databricks: Mutually exclusive with all other properties
	Databricks *Databricks `json:"databricks,omitempty"`

	// HDInsight: Mutually exclusive with all other properties
	HDInsight *HDInsight `json:"hdInsight,omitempty"`

	// Kubernetes: Mutually exclusive with all other properties
	Kubernetes *Kubernetes `json:"kubernetes,omitempty"`

	// SynapseSpark: Mutually exclusive with all other properties
	SynapseSpark *SynapseSpark `json:"synapseSpark,omitempty"`

	// VirtualMachine: Mutually exclusive with all other properties
	VirtualMachine *VirtualMachine `json:"virtualMachine,omitempty"`
}

var _ genruntime.ARMTransformer = &Compute{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (compute *Compute) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if compute == nil {
		return nil, nil
	}
	result := &arm.Compute{}

	// Set property "AKS":
	if compute.AKS != nil {
		aks_ARM, err := (*compute.AKS).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		aks := *aks_ARM.(*arm.AKS)
		result.AKS = &aks
	}

	// Set property "AmlCompute":
	if compute.AmlCompute != nil {
		amlCompute_ARM, err := (*compute.AmlCompute).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		amlCompute := *amlCompute_ARM.(*arm.AmlCompute)
		result.AmlCompute = &amlCompute
	}

	// Set property "ComputeInstance":
	if compute.ComputeInstance != nil {
		computeInstance_ARM, err := (*compute.ComputeInstance).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		computeInstance := *computeInstance_ARM.(*arm.ComputeInstance)
		result.ComputeInstance = &computeInstance
	}

	// Set property "DataFactory":
	if compute.DataFactory != nil {
		dataFactory_ARM, err := (*compute.DataFactory).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dataFactory := *dataFactory_ARM.(*arm.DataFactory)
		result.DataFactory = &dataFactory
	}

	// Set property "DataLakeAnalytics":
	if compute.DataLakeAnalytics != nil {
		dataLakeAnalytics_ARM, err := (*compute.DataLakeAnalytics).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dataLakeAnalytics := *dataLakeAnalytics_ARM.(*arm.DataLakeAnalytics)
		result.DataLakeAnalytics = &dataLakeAnalytics
	}

	// Set property "Databricks":
	if compute.Databricks != nil {
		databricks_ARM, err := (*compute.Databricks).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		databricks := *databricks_ARM.(*arm.Databricks)
		result.Databricks = &databricks
	}

	// Set property "HDInsight":
	if compute.HDInsight != nil {
		hdInsight_ARM, err := (*compute.HDInsight).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		hdInsight := *hdInsight_ARM.(*arm.HDInsight)
		result.HDInsight = &hdInsight
	}

	// Set property "Kubernetes":
	if compute.Kubernetes != nil {
		kubernetes_ARM, err := (*compute.Kubernetes).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		kubernetes := *kubernetes_ARM.(*arm.Kubernetes)
		result.Kubernetes = &kubernetes
	}

	// Set property "SynapseSpark":
	if compute.SynapseSpark != nil {
		synapseSpark_ARM, err := (*compute.SynapseSpark).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		synapseSpark := *synapseSpark_ARM.(*arm.SynapseSpark)
		result.SynapseSpark = &synapseSpark
	}

	// Set property "VirtualMachine":
	if compute.VirtualMachine != nil {
		virtualMachine_ARM, err := (*compute.VirtualMachine).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		virtualMachine := *virtualMachine_ARM.(*arm.VirtualMachine)
		result.VirtualMachine = &virtualMachine
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (compute *Compute) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Compute{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (compute *Compute) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Compute)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Compute, got %T", armInput)
	}

	// Set property "AKS":
	if typedInput.AKS != nil {
		var aks1 AKS
		err := aks1.PopulateFromARM(owner, *typedInput.AKS)
		if err != nil {
			return err
		}
		aks := aks1
		compute.AKS = &aks
	}

	// Set property "AmlCompute":
	if typedInput.AmlCompute != nil {
		var amlCompute1 AmlCompute
		err := amlCompute1.PopulateFromARM(owner, *typedInput.AmlCompute)
		if err != nil {
			return err
		}
		amlCompute := amlCompute1
		compute.AmlCompute = &amlCompute
	}

	// Set property "ComputeInstance":
	if typedInput.ComputeInstance != nil {
		var computeInstance1 ComputeInstance
		err := computeInstance1.PopulateFromARM(owner, *typedInput.ComputeInstance)
		if err != nil {
			return err
		}
		computeInstance := computeInstance1
		compute.ComputeInstance = &computeInstance
	}

	// Set property "DataFactory":
	if typedInput.DataFactory != nil {
		var dataFactory1 DataFactory
		err := dataFactory1.PopulateFromARM(owner, *typedInput.DataFactory)
		if err != nil {
			return err
		}
		dataFactory := dataFactory1
		compute.DataFactory = &dataFactory
	}

	// Set property "DataLakeAnalytics":
	if typedInput.DataLakeAnalytics != nil {
		var dataLakeAnalytics1 DataLakeAnalytics
		err := dataLakeAnalytics1.PopulateFromARM(owner, *typedInput.DataLakeAnalytics)
		if err != nil {
			return err
		}
		dataLakeAnalytics := dataLakeAnalytics1
		compute.DataLakeAnalytics = &dataLakeAnalytics
	}

	// Set property "Databricks":
	if typedInput.Databricks != nil {
		var databricks1 Databricks
		err := databricks1.PopulateFromARM(owner, *typedInput.Databricks)
		if err != nil {
			return err
		}
		databricks := databricks1
		compute.Databricks = &databricks
	}

	// Set property "HDInsight":
	if typedInput.HDInsight != nil {
		var hdInsight1 HDInsight
		err := hdInsight1.PopulateFromARM(owner, *typedInput.HDInsight)
		if err != nil {
			return err
		}
		hdInsight := hdInsight1
		compute.HDInsight = &hdInsight
	}

	// Set property "Kubernetes":
	if typedInput.Kubernetes != nil {
		var kubernetes1 Kubernetes
		err := kubernetes1.PopulateFromARM(owner, *typedInput.Kubernetes)
		if err != nil {
			return err
		}
		kubernetes := kubernetes1
		compute.Kubernetes = &kubernetes
	}

	// Set property "SynapseSpark":
	if typedInput.SynapseSpark != nil {
		var synapseSpark1 SynapseSpark
		err := synapseSpark1.PopulateFromARM(owner, *typedInput.SynapseSpark)
		if err != nil {
			return err
		}
		synapseSpark := synapseSpark1
		compute.SynapseSpark = &synapseSpark
	}

	// Set property "VirtualMachine":
	if typedInput.VirtualMachine != nil {
		var virtualMachine1 VirtualMachine
		err := virtualMachine1.PopulateFromARM(owner, *typedInput.VirtualMachine)
		if err != nil {
			return err
		}
		virtualMachine := virtualMachine1
		compute.VirtualMachine = &virtualMachine
	}

	// No error
	return nil
}

// AssignProperties_From_Compute populates our Compute from the provided source Compute
func (compute *Compute) AssignProperties_From_Compute(source *storage.Compute) error {

	// AKS
	if source.AKS != nil {
		var aks AKS
		err := aks.AssignProperties_From_AKS(source.AKS)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AKS() to populate field AKS")
		}
		compute.AKS = &aks
	} else {
		compute.AKS = nil
	}

	// AmlCompute
	if source.AmlCompute != nil {
		var amlCompute AmlCompute
		err := amlCompute.AssignProperties_From_AmlCompute(source.AmlCompute)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AmlCompute() to populate field AmlCompute")
		}
		compute.AmlCompute = &amlCompute
	} else {
		compute.AmlCompute = nil
	}

	// ComputeInstance
	if source.ComputeInstance != nil {
		var computeInstance ComputeInstance
		err := computeInstance.AssignProperties_From_ComputeInstance(source.ComputeInstance)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ComputeInstance() to populate field ComputeInstance")
		}
		compute.ComputeInstance = &computeInstance
	} else {
		compute.ComputeInstance = nil
	}

	// DataFactory
	if source.DataFactory != nil {
		var dataFactory DataFactory
		err := dataFactory.AssignProperties_From_DataFactory(source.DataFactory)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DataFactory() to populate field DataFactory")
		}
		compute.DataFactory = &dataFactory
	} else {
		compute.DataFactory = nil
	}

	// DataLakeAnalytics
	if source.DataLakeAnalytics != nil {
		var dataLakeAnalytic DataLakeAnalytics
		err := dataLakeAnalytic.AssignProperties_From_DataLakeAnalytics(source.DataLakeAnalytics)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DataLakeAnalytics() to populate field DataLakeAnalytics")
		}
		compute.DataLakeAnalytics = &dataLakeAnalytic
	} else {
		compute.DataLakeAnalytics = nil
	}

	// Databricks
	if source.Databricks != nil {
		var databrick Databricks
		err := databrick.AssignProperties_From_Databricks(source.Databricks)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Databricks() to populate field Databricks")
		}
		compute.Databricks = &databrick
	} else {
		compute.Databricks = nil
	}

	// HDInsight
	if source.HDInsight != nil {
		var hdInsight HDInsight
		err := hdInsight.AssignProperties_From_HDInsight(source.HDInsight)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_HDInsight() to populate field HDInsight")
		}
		compute.HDInsight = &hdInsight
	} else {
		compute.HDInsight = nil
	}

	// Kubernetes
	if source.Kubernetes != nil {
		var kubernete Kubernetes
		err := kubernete.AssignProperties_From_Kubernetes(source.Kubernetes)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Kubernetes() to populate field Kubernetes")
		}
		compute.Kubernetes = &kubernete
	} else {
		compute.Kubernetes = nil
	}

	// SynapseSpark
	if source.SynapseSpark != nil {
		var synapseSpark SynapseSpark
		err := synapseSpark.AssignProperties_From_SynapseSpark(source.SynapseSpark)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SynapseSpark() to populate field SynapseSpark")
		}
		compute.SynapseSpark = &synapseSpark
	} else {
		compute.SynapseSpark = nil
	}

	// VirtualMachine
	if source.VirtualMachine != nil {
		var virtualMachine VirtualMachine
		err := virtualMachine.AssignProperties_From_VirtualMachine(source.VirtualMachine)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachine() to populate field VirtualMachine")
		}
		compute.VirtualMachine = &virtualMachine
	} else {
		compute.VirtualMachine = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Compute populates the provided destination Compute from our Compute
func (compute *Compute) AssignProperties_To_Compute(destination *storage.Compute) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AKS
	if compute.AKS != nil {
		var aks storage.AKS
		err := compute.AKS.AssignProperties_To_AKS(&aks)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AKS() to populate field AKS")
		}
		destination.AKS = &aks
	} else {
		destination.AKS = nil
	}

	// AmlCompute
	if compute.AmlCompute != nil {
		var amlCompute storage.AmlCompute
		err := compute.AmlCompute.AssignProperties_To_AmlCompute(&amlCompute)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AmlCompute() to populate field AmlCompute")
		}
		destination.AmlCompute = &amlCompute
	} else {
		destination.AmlCompute = nil
	}

	// ComputeInstance
	if compute.ComputeInstance != nil {
		var computeInstance storage.ComputeInstance
		err := compute.ComputeInstance.AssignProperties_To_ComputeInstance(&computeInstance)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ComputeInstance() to populate field ComputeInstance")
		}
		destination.ComputeInstance = &computeInstance
	} else {
		destination.ComputeInstance = nil
	}

	// DataFactory
	if compute.DataFactory != nil {
		var dataFactory storage.DataFactory
		err := compute.DataFactory.AssignProperties_To_DataFactory(&dataFactory)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DataFactory() to populate field DataFactory")
		}
		destination.DataFactory = &dataFactory
	} else {
		destination.DataFactory = nil
	}

	// DataLakeAnalytics
	if compute.DataLakeAnalytics != nil {
		var dataLakeAnalytic storage.DataLakeAnalytics
		err := compute.DataLakeAnalytics.AssignProperties_To_DataLakeAnalytics(&dataLakeAnalytic)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DataLakeAnalytics() to populate field DataLakeAnalytics")
		}
		destination.DataLakeAnalytics = &dataLakeAnalytic
	} else {
		destination.DataLakeAnalytics = nil
	}

	// Databricks
	if compute.Databricks != nil {
		var databrick storage.Databricks
		err := compute.Databricks.AssignProperties_To_Databricks(&databrick)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Databricks() to populate field Databricks")
		}
		destination.Databricks = &databrick
	} else {
		destination.Databricks = nil
	}

	// HDInsight
	if compute.HDInsight != nil {
		var hdInsight storage.HDInsight
		err := compute.HDInsight.AssignProperties_To_HDInsight(&hdInsight)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_HDInsight() to populate field HDInsight")
		}
		destination.HDInsight = &hdInsight
	} else {
		destination.HDInsight = nil
	}

	// Kubernetes
	if compute.Kubernetes != nil {
		var kubernete storage.Kubernetes
		err := compute.Kubernetes.AssignProperties_To_Kubernetes(&kubernete)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Kubernetes() to populate field Kubernetes")
		}
		destination.Kubernetes = &kubernete
	} else {
		destination.Kubernetes = nil
	}

	// SynapseSpark
	if compute.SynapseSpark != nil {
		var synapseSpark storage.SynapseSpark
		err := compute.SynapseSpark.AssignProperties_To_SynapseSpark(&synapseSpark)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SynapseSpark() to populate field SynapseSpark")
		}
		destination.SynapseSpark = &synapseSpark
	} else {
		destination.SynapseSpark = nil
	}

	// VirtualMachine
	if compute.VirtualMachine != nil {
		var virtualMachine storage.VirtualMachine
		err := compute.VirtualMachine.AssignProperties_To_VirtualMachine(&virtualMachine)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachine() to populate field VirtualMachine")
		}
		destination.VirtualMachine = &virtualMachine
	} else {
		destination.VirtualMachine = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Compute_STATUS struct {
	// AKS: Mutually exclusive with all other properties
	AKS *AKS_STATUS `json:"aks,omitempty"`

	// AmlCompute: Mutually exclusive with all other properties
	AmlCompute *AmlCompute_STATUS `json:"amlCompute,omitempty"`

	// ComputeInstance: Mutually exclusive with all other properties
	ComputeInstance *ComputeInstance_STATUS `json:"computeInstance,omitempty"`

	// DataFactory: Mutually exclusive with all other properties
	DataFactory *DataFactory_STATUS `json:"dataFactory,omitempty"`

	// DataLakeAnalytics: Mutually exclusive with all other properties
	DataLakeAnalytics *DataLakeAnalytics_STATUS `json:"dataLakeAnalytics,omitempty"`

	// Databricks: Mutually exclusive with all other properties
	Databricks *Databricks_STATUS `json:"databricks,omitempty"`

	// HDInsight: Mutually exclusive with all other properties
	HDInsight *HDInsight_STATUS `json:"hdInsight,omitempty"`

	// Kubernetes: Mutually exclusive with all other properties
	Kubernetes *Kubernetes_STATUS `json:"kubernetes,omitempty"`

	// SynapseSpark: Mutually exclusive with all other properties
	SynapseSpark *SynapseSpark_STATUS `json:"synapseSpark,omitempty"`

	// VirtualMachine: Mutually exclusive with all other properties
	VirtualMachine *VirtualMachine_STATUS `json:"virtualMachine,omitempty"`
}

var _ genruntime.FromARMConverter = &Compute_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (compute *Compute_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Compute_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (compute *Compute_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Compute_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Compute_STATUS, got %T", armInput)
	}

	// Set property "AKS":
	if typedInput.AKS != nil {
		var aks1 AKS_STATUS
		err := aks1.PopulateFromARM(owner, *typedInput.AKS)
		if err != nil {
			return err
		}
		aks := aks1
		compute.AKS = &aks
	}

	// Set property "AmlCompute":
	if typedInput.AmlCompute != nil {
		var amlCompute1 AmlCompute_STATUS
		err := amlCompute1.PopulateFromARM(owner, *typedInput.AmlCompute)
		if err != nil {
			return err
		}
		amlCompute := amlCompute1
		compute.AmlCompute = &amlCompute
	}

	// Set property "ComputeInstance":
	if typedInput.ComputeInstance != nil {
		var computeInstance1 ComputeInstance_STATUS
		err := computeInstance1.PopulateFromARM(owner, *typedInput.ComputeInstance)
		if err != nil {
			return err
		}
		computeInstance := computeInstance1
		compute.ComputeInstance = &computeInstance
	}

	// Set property "DataFactory":
	if typedInput.DataFactory != nil {
		var dataFactory1 DataFactory_STATUS
		err := dataFactory1.PopulateFromARM(owner, *typedInput.DataFactory)
		if err != nil {
			return err
		}
		dataFactory := dataFactory1
		compute.DataFactory = &dataFactory
	}

	// Set property "DataLakeAnalytics":
	if typedInput.DataLakeAnalytics != nil {
		var dataLakeAnalytics1 DataLakeAnalytics_STATUS
		err := dataLakeAnalytics1.PopulateFromARM(owner, *typedInput.DataLakeAnalytics)
		if err != nil {
			return err
		}
		dataLakeAnalytics := dataLakeAnalytics1
		compute.DataLakeAnalytics = &dataLakeAnalytics
	}

	// Set property "Databricks":
	if typedInput.Databricks != nil {
		var databricks1 Databricks_STATUS
		err := databricks1.PopulateFromARM(owner, *typedInput.Databricks)
		if err != nil {
			return err
		}
		databricks := databricks1
		compute.Databricks = &databricks
	}

	// Set property "HDInsight":
	if typedInput.HDInsight != nil {
		var hdInsight1 HDInsight_STATUS
		err := hdInsight1.PopulateFromARM(owner, *typedInput.HDInsight)
		if err != nil {
			return err
		}
		hdInsight := hdInsight1
		compute.HDInsight = &hdInsight
	}

	// Set property "Kubernetes":
	if typedInput.Kubernetes != nil {
		var kubernetes1 Kubernetes_STATUS
		err := kubernetes1.PopulateFromARM(owner, *typedInput.Kubernetes)
		if err != nil {
			return err
		}
		kubernetes := kubernetes1
		compute.Kubernetes = &kubernetes
	}

	// Set property "SynapseSpark":
	if typedInput.SynapseSpark != nil {
		var synapseSpark1 SynapseSpark_STATUS
		err := synapseSpark1.PopulateFromARM(owner, *typedInput.SynapseSpark)
		if err != nil {
			return err
		}
		synapseSpark := synapseSpark1
		compute.SynapseSpark = &synapseSpark
	}

	// Set property "VirtualMachine":
	if typedInput.VirtualMachine != nil {
		var virtualMachine1 VirtualMachine_STATUS
		err := virtualMachine1.PopulateFromARM(owner, *typedInput.VirtualMachine)
		if err != nil {
			return err
		}
		virtualMachine := virtualMachine1
		compute.VirtualMachine = &virtualMachine
	}

	// No error
	return nil
}

// AssignProperties_From_Compute_STATUS populates our Compute_STATUS from the provided source Compute_STATUS
func (compute *Compute_STATUS) AssignProperties_From_Compute_STATUS(source *storage.Compute_STATUS) error {

	// AKS
	if source.AKS != nil {
		var aks AKS_STATUS
		err := aks.AssignProperties_From_AKS_STATUS(source.AKS)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AKS_STATUS() to populate field AKS")
		}
		compute.AKS = &aks
	} else {
		compute.AKS = nil
	}

	// AmlCompute
	if source.AmlCompute != nil {
		var amlCompute AmlCompute_STATUS
		err := amlCompute.AssignProperties_From_AmlCompute_STATUS(source.AmlCompute)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AmlCompute_STATUS() to populate field AmlCompute")
		}
		compute.AmlCompute = &amlCompute
	} else {
		compute.AmlCompute = nil
	}

	// ComputeInstance
	if source.ComputeInstance != nil {
		var computeInstance ComputeInstance_STATUS
		err := computeInstance.AssignProperties_From_ComputeInstance_STATUS(source.ComputeInstance)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ComputeInstance_STATUS() to populate field ComputeInstance")
		}
		compute.ComputeInstance = &computeInstance
	} else {
		compute.ComputeInstance = nil
	}

	// DataFactory
	if source.DataFactory != nil {
		var dataFactory DataFactory_STATUS
		err := dataFactory.AssignProperties_From_DataFactory_STATUS(source.DataFactory)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DataFactory_STATUS() to populate field DataFactory")
		}
		compute.DataFactory = &dataFactory
	} else {
		compute.DataFactory = nil
	}

	// DataLakeAnalytics
	if source.DataLakeAnalytics != nil {
		var dataLakeAnalytic DataLakeAnalytics_STATUS
		err := dataLakeAnalytic.AssignProperties_From_DataLakeAnalytics_STATUS(source.DataLakeAnalytics)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DataLakeAnalytics_STATUS() to populate field DataLakeAnalytics")
		}
		compute.DataLakeAnalytics = &dataLakeAnalytic
	} else {
		compute.DataLakeAnalytics = nil
	}

	// Databricks
	if source.Databricks != nil {
		var databrick Databricks_STATUS
		err := databrick.AssignProperties_From_Databricks_STATUS(source.Databricks)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Databricks_STATUS() to populate field Databricks")
		}
		compute.Databricks = &databrick
	} else {
		compute.Databricks = nil
	}

	// HDInsight
	if source.HDInsight != nil {
		var hdInsight HDInsight_STATUS
		err := hdInsight.AssignProperties_From_HDInsight_STATUS(source.HDInsight)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_HDInsight_STATUS() to populate field HDInsight")
		}
		compute.HDInsight = &hdInsight
	} else {
		compute.HDInsight = nil
	}

	// Kubernetes
	if source.Kubernetes != nil {
		var kubernete Kubernetes_STATUS
		err := kubernete.AssignProperties_From_Kubernetes_STATUS(source.Kubernetes)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Kubernetes_STATUS() to populate field Kubernetes")
		}
		compute.Kubernetes = &kubernete
	} else {
		compute.Kubernetes = nil
	}

	// SynapseSpark
	if source.SynapseSpark != nil {
		var synapseSpark SynapseSpark_STATUS
		err := synapseSpark.AssignProperties_From_SynapseSpark_STATUS(source.SynapseSpark)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SynapseSpark_STATUS() to populate field SynapseSpark")
		}
		compute.SynapseSpark = &synapseSpark
	} else {
		compute.SynapseSpark = nil
	}

	// VirtualMachine
	if source.VirtualMachine != nil {
		var virtualMachine VirtualMachine_STATUS
		err := virtualMachine.AssignProperties_From_VirtualMachine_STATUS(source.VirtualMachine)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachine_STATUS() to populate field VirtualMachine")
		}
		compute.VirtualMachine = &virtualMachine
	} else {
		compute.VirtualMachine = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Compute_STATUS populates the provided destination Compute_STATUS from our Compute_STATUS
func (compute *Compute_STATUS) AssignProperties_To_Compute_STATUS(destination *storage.Compute_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AKS
	if compute.AKS != nil {
		var aks storage.AKS_STATUS
		err := compute.AKS.AssignProperties_To_AKS_STATUS(&aks)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AKS_STATUS() to populate field AKS")
		}
		destination.AKS = &aks
	} else {
		destination.AKS = nil
	}

	// AmlCompute
	if compute.AmlCompute != nil {
		var amlCompute storage.AmlCompute_STATUS
		err := compute.AmlCompute.AssignProperties_To_AmlCompute_STATUS(&amlCompute)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AmlCompute_STATUS() to populate field AmlCompute")
		}
		destination.AmlCompute = &amlCompute
	} else {
		destination.AmlCompute = nil
	}

	// ComputeInstance
	if compute.ComputeInstance != nil {
		var computeInstance storage.ComputeInstance_STATUS
		err := compute.ComputeInstance.AssignProperties_To_ComputeInstance_STATUS(&computeInstance)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ComputeInstance_STATUS() to populate field ComputeInstance")
		}
		destination.ComputeInstance = &computeInstance
	} else {
		destination.ComputeInstance = nil
	}

	// DataFactory
	if compute.DataFactory != nil {
		var dataFactory storage.DataFactory_STATUS
		err := compute.DataFactory.AssignProperties_To_DataFactory_STATUS(&dataFactory)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DataFactory_STATUS() to populate field DataFactory")
		}
		destination.DataFactory = &dataFactory
	} else {
		destination.DataFactory = nil
	}

	// DataLakeAnalytics
	if compute.DataLakeAnalytics != nil {
		var dataLakeAnalytic storage.DataLakeAnalytics_STATUS
		err := compute.DataLakeAnalytics.AssignProperties_To_DataLakeAnalytics_STATUS(&dataLakeAnalytic)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DataLakeAnalytics_STATUS() to populate field DataLakeAnalytics")
		}
		destination.DataLakeAnalytics = &dataLakeAnalytic
	} else {
		destination.DataLakeAnalytics = nil
	}

	// Databricks
	if compute.Databricks != nil {
		var databrick storage.Databricks_STATUS
		err := compute.Databricks.AssignProperties_To_Databricks_STATUS(&databrick)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Databricks_STATUS() to populate field Databricks")
		}
		destination.Databricks = &databrick
	} else {
		destination.Databricks = nil
	}

	// HDInsight
	if compute.HDInsight != nil {
		var hdInsight storage.HDInsight_STATUS
		err := compute.HDInsight.AssignProperties_To_HDInsight_STATUS(&hdInsight)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_HDInsight_STATUS() to populate field HDInsight")
		}
		destination.HDInsight = &hdInsight
	} else {
		destination.HDInsight = nil
	}

	// Kubernetes
	if compute.Kubernetes != nil {
		var kubernete storage.Kubernetes_STATUS
		err := compute.Kubernetes.AssignProperties_To_Kubernetes_STATUS(&kubernete)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Kubernetes_STATUS() to populate field Kubernetes")
		}
		destination.Kubernetes = &kubernete
	} else {
		destination.Kubernetes = nil
	}

	// SynapseSpark
	if compute.SynapseSpark != nil {
		var synapseSpark storage.SynapseSpark_STATUS
		err := compute.SynapseSpark.AssignProperties_To_SynapseSpark_STATUS(&synapseSpark)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SynapseSpark_STATUS() to populate field SynapseSpark")
		}
		destination.SynapseSpark = &synapseSpark
	} else {
		destination.SynapseSpark = nil
	}

	// VirtualMachine
	if compute.VirtualMachine != nil {
		var virtualMachine storage.VirtualMachine_STATUS
		err := compute.VirtualMachine.AssignProperties_To_VirtualMachine_STATUS(&virtualMachine)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachine_STATUS() to populate field VirtualMachine")
		}
		destination.VirtualMachine = &virtualMachine
	} else {
		destination.VirtualMachine = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type WorkspacesComputeOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_WorkspacesComputeOperatorSpec populates our WorkspacesComputeOperatorSpec from the provided source WorkspacesComputeOperatorSpec
func (operator *WorkspacesComputeOperatorSpec) AssignProperties_From_WorkspacesComputeOperatorSpec(source *storage.WorkspacesComputeOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WorkspacesComputeOperatorSpec populates the provided destination WorkspacesComputeOperatorSpec from our WorkspacesComputeOperatorSpec
func (operator *WorkspacesComputeOperatorSpec) AssignProperties_To_WorkspacesComputeOperatorSpec(destination *storage.WorkspacesComputeOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AKS struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// +kubebuilder:validation:Required
	// ComputeType: The type of compute
	ComputeType *AKS_ComputeType `json:"computeType,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// Properties: AKS properties
	Properties *AKS_Properties `json:"properties,omitempty"`

	// ResourceReference: ARM resource id of the underlying compute
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &AKS{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (aks *AKS) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if aks == nil {
		return nil, nil
	}
	result := &arm.AKS{}

	// Set property "ComputeLocation":
	if aks.ComputeLocation != nil {
		computeLocation := *aks.ComputeLocation
		result.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	if aks.ComputeType != nil {
		var temp arm.AKS_ComputeType
		var temp1 string
		temp1 = string(*aks.ComputeType)
		temp = arm.AKS_ComputeType(temp1)
		result.ComputeType = temp
	}

	// Set property "Description":
	if aks.Description != nil {
		description := *aks.Description
		result.Description = &description
	}

	// Set property "DisableLocalAuth":
	if aks.DisableLocalAuth != nil {
		disableLocalAuth := *aks.DisableLocalAuth
		result.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if aks.Properties != nil {
		properties_ARM, err := (*aks.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*arm.AKS_Properties)
		result.Properties = &properties
	}

	// Set property "ResourceId":
	if aks.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*aks.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (aks *AKS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AKS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (aks *AKS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AKS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AKS, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		aks.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp AKS_ComputeType
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = AKS_ComputeType(temp1)
	aks.ComputeType = &temp

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		aks.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		aks.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 AKS_Properties
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		aks.Properties = &properties
	}

	// no assignment for property "ResourceReference"

	// No error
	return nil
}

// AssignProperties_From_AKS populates our AKS from the provided source AKS
func (aks *AKS) AssignProperties_From_AKS(source *storage.AKS) error {

	// ComputeLocation
	aks.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, aKS_ComputeType_Values)
		aks.ComputeType = &computeTypeTemp
	} else {
		aks.ComputeType = nil
	}

	// Description
	aks.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		aks.DisableLocalAuth = &disableLocalAuth
	} else {
		aks.DisableLocalAuth = nil
	}

	// Properties
	if source.Properties != nil {
		var property AKS_Properties
		err := property.AssignProperties_From_AKS_Properties(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AKS_Properties() to populate field Properties")
		}
		aks.Properties = &property
	} else {
		aks.Properties = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		aks.ResourceReference = &resourceReference
	} else {
		aks.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AKS populates the provided destination AKS from our AKS
func (aks *AKS) AssignProperties_To_AKS(destination *storage.AKS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(aks.ComputeLocation)

	// ComputeType
	if aks.ComputeType != nil {
		computeType := string(*aks.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(aks.Description)

	// DisableLocalAuth
	if aks.DisableLocalAuth != nil {
		disableLocalAuth := *aks.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// Properties
	if aks.Properties != nil {
		var property storage.AKS_Properties
		err := aks.Properties.AssignProperties_To_AKS_Properties(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AKS_Properties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ResourceReference
	if aks.ResourceReference != nil {
		resourceReference := aks.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AKS_STATUS struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// ComputeType: The type of compute
	ComputeType *AKS_ComputeType_STATUS `json:"computeType,omitempty"`

	// CreatedOn: The time at which the compute was created.
	CreatedOn *string `json:"createdOn,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// IsAttachedCompute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine
	// learning service provisioned it if false.
	IsAttachedCompute *bool `json:"isAttachedCompute,omitempty"`

	// ModifiedOn: The time at which the compute was last modified.
	ModifiedOn *string `json:"modifiedOn,omitempty"`

	// Properties: AKS properties
	Properties *AKS_Properties_STATUS `json:"properties,omitempty"`

	// ProvisioningErrors: Errors during provisioning
	ProvisioningErrors []ErrorResponse_STATUS `json:"provisioningErrors,omitempty"`

	// ProvisioningState: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and
	// Failed.
	ProvisioningState *AKS_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// ResourceId: ARM resource id of the underlying compute
	ResourceId *string `json:"resourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &AKS_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (aks *AKS_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AKS_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (aks *AKS_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AKS_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AKS_STATUS, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		aks.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp AKS_ComputeType_STATUS
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = AKS_ComputeType_STATUS(temp1)
	aks.ComputeType = &temp

	// Set property "CreatedOn":
	if typedInput.CreatedOn != nil {
		createdOn := *typedInput.CreatedOn
		aks.CreatedOn = &createdOn
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		aks.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		aks.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "IsAttachedCompute":
	if typedInput.IsAttachedCompute != nil {
		isAttachedCompute := *typedInput.IsAttachedCompute
		aks.IsAttachedCompute = &isAttachedCompute
	}

	// Set property "ModifiedOn":
	if typedInput.ModifiedOn != nil {
		modifiedOn := *typedInput.ModifiedOn
		aks.ModifiedOn = &modifiedOn
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 AKS_Properties_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		aks.Properties = &properties
	}

	// Set property "ProvisioningErrors":
	for _, item := range typedInput.ProvisioningErrors {
		var item1 ErrorResponse_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		aks.ProvisioningErrors = append(aks.ProvisioningErrors, item1)
	}

	// Set property "ProvisioningState":
	if typedInput.ProvisioningState != nil {
		var provisioningStateTemp string
		provisioningStateTemp = string(*typedInput.ProvisioningState)
		provisioningState := AKS_ProvisioningState_STATUS(provisioningStateTemp)
		aks.ProvisioningState = &provisioningState
	}

	// Set property "ResourceId":
	if typedInput.ResourceId != nil {
		resourceId := *typedInput.ResourceId
		aks.ResourceId = &resourceId
	}

	// No error
	return nil
}

// AssignProperties_From_AKS_STATUS populates our AKS_STATUS from the provided source AKS_STATUS
func (aks *AKS_STATUS) AssignProperties_From_AKS_STATUS(source *storage.AKS_STATUS) error {

	// ComputeLocation
	aks.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, aKS_ComputeType_STATUS_Values)
		aks.ComputeType = &computeTypeTemp
	} else {
		aks.ComputeType = nil
	}

	// CreatedOn
	aks.CreatedOn = genruntime.ClonePointerToString(source.CreatedOn)

	// Description
	aks.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		aks.DisableLocalAuth = &disableLocalAuth
	} else {
		aks.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if source.IsAttachedCompute != nil {
		isAttachedCompute := *source.IsAttachedCompute
		aks.IsAttachedCompute = &isAttachedCompute
	} else {
		aks.IsAttachedCompute = nil
	}

	// ModifiedOn
	aks.ModifiedOn = genruntime.ClonePointerToString(source.ModifiedOn)

	// Properties
	if source.Properties != nil {
		var property AKS_Properties_STATUS
		err := property.AssignProperties_From_AKS_Properties_STATUS(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AKS_Properties_STATUS() to populate field Properties")
		}
		aks.Properties = &property
	} else {
		aks.Properties = nil
	}

	// ProvisioningErrors
	if source.ProvisioningErrors != nil {
		provisioningErrorList := make([]ErrorResponse_STATUS, len(source.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range source.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError ErrorResponse_STATUS
			err := provisioningError.AssignProperties_From_ErrorResponse_STATUS(&provisioningErrorItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		aks.ProvisioningErrors = provisioningErrorList
	} else {
		aks.ProvisioningErrors = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, aKS_ProvisioningState_STATUS_Values)
		aks.ProvisioningState = &provisioningStateTemp
	} else {
		aks.ProvisioningState = nil
	}

	// ResourceId
	aks.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// No error
	return nil
}

// AssignProperties_To_AKS_STATUS populates the provided destination AKS_STATUS from our AKS_STATUS
func (aks *AKS_STATUS) AssignProperties_To_AKS_STATUS(destination *storage.AKS_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(aks.ComputeLocation)

	// ComputeType
	if aks.ComputeType != nil {
		computeType := string(*aks.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// CreatedOn
	destination.CreatedOn = genruntime.ClonePointerToString(aks.CreatedOn)

	// Description
	destination.Description = genruntime.ClonePointerToString(aks.Description)

	// DisableLocalAuth
	if aks.DisableLocalAuth != nil {
		disableLocalAuth := *aks.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if aks.IsAttachedCompute != nil {
		isAttachedCompute := *aks.IsAttachedCompute
		destination.IsAttachedCompute = &isAttachedCompute
	} else {
		destination.IsAttachedCompute = nil
	}

	// ModifiedOn
	destination.ModifiedOn = genruntime.ClonePointerToString(aks.ModifiedOn)

	// Properties
	if aks.Properties != nil {
		var property storage.AKS_Properties_STATUS
		err := aks.Properties.AssignProperties_To_AKS_Properties_STATUS(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AKS_Properties_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ProvisioningErrors
	if aks.ProvisioningErrors != nil {
		provisioningErrorList := make([]storage.ErrorResponse_STATUS, len(aks.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range aks.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError storage.ErrorResponse_STATUS
			err := provisioningErrorItem.AssignProperties_To_ErrorResponse_STATUS(&provisioningError)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		destination.ProvisioningErrors = provisioningErrorList
	} else {
		destination.ProvisioningErrors = nil
	}

	// ProvisioningState
	if aks.ProvisioningState != nil {
		provisioningState := string(*aks.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(aks.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AmlCompute struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// +kubebuilder:validation:Required
	// ComputeType: The type of compute
	ComputeType *AmlCompute_ComputeType `json:"computeType,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// Properties: Properties of AmlCompute
	Properties *AmlComputeProperties `json:"properties,omitempty"`

	// ResourceReference: ARM resource id of the underlying compute
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &AmlCompute{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (compute *AmlCompute) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if compute == nil {
		return nil, nil
	}
	result := &arm.AmlCompute{}

	// Set property "ComputeLocation":
	if compute.ComputeLocation != nil {
		computeLocation := *compute.ComputeLocation
		result.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	if compute.ComputeType != nil {
		var temp arm.AmlCompute_ComputeType
		var temp1 string
		temp1 = string(*compute.ComputeType)
		temp = arm.AmlCompute_ComputeType(temp1)
		result.ComputeType = temp
	}

	// Set property "Description":
	if compute.Description != nil {
		description := *compute.Description
		result.Description = &description
	}

	// Set property "DisableLocalAuth":
	if compute.DisableLocalAuth != nil {
		disableLocalAuth := *compute.DisableLocalAuth
		result.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if compute.Properties != nil {
		properties_ARM, err := (*compute.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*arm.AmlComputeProperties)
		result.Properties = &properties
	}

	// Set property "ResourceId":
	if compute.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*compute.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (compute *AmlCompute) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AmlCompute{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (compute *AmlCompute) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AmlCompute)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AmlCompute, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		compute.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp AmlCompute_ComputeType
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = AmlCompute_ComputeType(temp1)
	compute.ComputeType = &temp

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		compute.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		compute.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 AmlComputeProperties
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		compute.Properties = &properties
	}

	// no assignment for property "ResourceReference"

	// No error
	return nil
}

// AssignProperties_From_AmlCompute populates our AmlCompute from the provided source AmlCompute
func (compute *AmlCompute) AssignProperties_From_AmlCompute(source *storage.AmlCompute) error {

	// ComputeLocation
	compute.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, amlCompute_ComputeType_Values)
		compute.ComputeType = &computeTypeTemp
	} else {
		compute.ComputeType = nil
	}

	// Description
	compute.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		compute.DisableLocalAuth = &disableLocalAuth
	} else {
		compute.DisableLocalAuth = nil
	}

	// Properties
	if source.Properties != nil {
		var property AmlComputeProperties
		err := property.AssignProperties_From_AmlComputeProperties(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AmlComputeProperties() to populate field Properties")
		}
		compute.Properties = &property
	} else {
		compute.Properties = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		compute.ResourceReference = &resourceReference
	} else {
		compute.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AmlCompute populates the provided destination AmlCompute from our AmlCompute
func (compute *AmlCompute) AssignProperties_To_AmlCompute(destination *storage.AmlCompute) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(compute.ComputeLocation)

	// ComputeType
	if compute.ComputeType != nil {
		computeType := string(*compute.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(compute.Description)

	// DisableLocalAuth
	if compute.DisableLocalAuth != nil {
		disableLocalAuth := *compute.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// Properties
	if compute.Properties != nil {
		var property storage.AmlComputeProperties
		err := compute.Properties.AssignProperties_To_AmlComputeProperties(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AmlComputeProperties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ResourceReference
	if compute.ResourceReference != nil {
		resourceReference := compute.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AmlCompute_STATUS struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// ComputeType: The type of compute
	ComputeType *AmlCompute_ComputeType_STATUS `json:"computeType,omitempty"`

	// CreatedOn: The time at which the compute was created.
	CreatedOn *string `json:"createdOn,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// IsAttachedCompute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine
	// learning service provisioned it if false.
	IsAttachedCompute *bool `json:"isAttachedCompute,omitempty"`

	// ModifiedOn: The time at which the compute was last modified.
	ModifiedOn *string `json:"modifiedOn,omitempty"`

	// Properties: Properties of AmlCompute
	Properties *AmlComputeProperties_STATUS `json:"properties,omitempty"`

	// ProvisioningErrors: Errors during provisioning
	ProvisioningErrors []ErrorResponse_STATUS `json:"provisioningErrors,omitempty"`

	// ProvisioningState: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and
	// Failed.
	ProvisioningState *AmlCompute_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// ResourceId: ARM resource id of the underlying compute
	ResourceId *string `json:"resourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &AmlCompute_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (compute *AmlCompute_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AmlCompute_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (compute *AmlCompute_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AmlCompute_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AmlCompute_STATUS, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		compute.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp AmlCompute_ComputeType_STATUS
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = AmlCompute_ComputeType_STATUS(temp1)
	compute.ComputeType = &temp

	// Set property "CreatedOn":
	if typedInput.CreatedOn != nil {
		createdOn := *typedInput.CreatedOn
		compute.CreatedOn = &createdOn
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		compute.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		compute.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "IsAttachedCompute":
	if typedInput.IsAttachedCompute != nil {
		isAttachedCompute := *typedInput.IsAttachedCompute
		compute.IsAttachedCompute = &isAttachedCompute
	}

	// Set property "ModifiedOn":
	if typedInput.ModifiedOn != nil {
		modifiedOn := *typedInput.ModifiedOn
		compute.ModifiedOn = &modifiedOn
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 AmlComputeProperties_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		compute.Properties = &properties
	}

	// Set property "ProvisioningErrors":
	for _, item := range typedInput.ProvisioningErrors {
		var item1 ErrorResponse_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		compute.ProvisioningErrors = append(compute.ProvisioningErrors, item1)
	}

	// Set property "ProvisioningState":
	if typedInput.ProvisioningState != nil {
		var provisioningStateTemp string
		provisioningStateTemp = string(*typedInput.ProvisioningState)
		provisioningState := AmlCompute_ProvisioningState_STATUS(provisioningStateTemp)
		compute.ProvisioningState = &provisioningState
	}

	// Set property "ResourceId":
	if typedInput.ResourceId != nil {
		resourceId := *typedInput.ResourceId
		compute.ResourceId = &resourceId
	}

	// No error
	return nil
}

// AssignProperties_From_AmlCompute_STATUS populates our AmlCompute_STATUS from the provided source AmlCompute_STATUS
func (compute *AmlCompute_STATUS) AssignProperties_From_AmlCompute_STATUS(source *storage.AmlCompute_STATUS) error {

	// ComputeLocation
	compute.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, amlCompute_ComputeType_STATUS_Values)
		compute.ComputeType = &computeTypeTemp
	} else {
		compute.ComputeType = nil
	}

	// CreatedOn
	compute.CreatedOn = genruntime.ClonePointerToString(source.CreatedOn)

	// Description
	compute.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		compute.DisableLocalAuth = &disableLocalAuth
	} else {
		compute.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if source.IsAttachedCompute != nil {
		isAttachedCompute := *source.IsAttachedCompute
		compute.IsAttachedCompute = &isAttachedCompute
	} else {
		compute.IsAttachedCompute = nil
	}

	// ModifiedOn
	compute.ModifiedOn = genruntime.ClonePointerToString(source.ModifiedOn)

	// Properties
	if source.Properties != nil {
		var property AmlComputeProperties_STATUS
		err := property.AssignProperties_From_AmlComputeProperties_STATUS(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AmlComputeProperties_STATUS() to populate field Properties")
		}
		compute.Properties = &property
	} else {
		compute.Properties = nil
	}

	// ProvisioningErrors
	if source.ProvisioningErrors != nil {
		provisioningErrorList := make([]ErrorResponse_STATUS, len(source.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range source.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError ErrorResponse_STATUS
			err := provisioningError.AssignProperties_From_ErrorResponse_STATUS(&provisioningErrorItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		compute.ProvisioningErrors = provisioningErrorList
	} else {
		compute.ProvisioningErrors = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, amlCompute_ProvisioningState_STATUS_Values)
		compute.ProvisioningState = &provisioningStateTemp
	} else {
		compute.ProvisioningState = nil
	}

	// ResourceId
	compute.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// No error
	return nil
}

// AssignProperties_To_AmlCompute_STATUS populates the provided destination AmlCompute_STATUS from our AmlCompute_STATUS
func (compute *AmlCompute_STATUS) AssignProperties_To_AmlCompute_STATUS(destination *storage.AmlCompute_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(compute.ComputeLocation)

	// ComputeType
	if compute.ComputeType != nil {
		computeType := string(*compute.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// CreatedOn
	destination.CreatedOn = genruntime.ClonePointerToString(compute.CreatedOn)

	// Description
	destination.Description = genruntime.ClonePointerToString(compute.Description)

	// DisableLocalAuth
	if compute.DisableLocalAuth != nil {
		disableLocalAuth := *compute.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if compute.IsAttachedCompute != nil {
		isAttachedCompute := *compute.IsAttachedCompute
		destination.IsAttachedCompute = &isAttachedCompute
	} else {
		destination.IsAttachedCompute = nil
	}

	// ModifiedOn
	destination.ModifiedOn = genruntime.ClonePointerToString(compute.ModifiedOn)

	// Properties
	if compute.Properties != nil {
		var property storage.AmlComputeProperties_STATUS
		err := compute.Properties.AssignProperties_To_AmlComputeProperties_STATUS(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AmlComputeProperties_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ProvisioningErrors
	if compute.ProvisioningErrors != nil {
		provisioningErrorList := make([]storage.ErrorResponse_STATUS, len(compute.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range compute.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError storage.ErrorResponse_STATUS
			err := provisioningErrorItem.AssignProperties_To_ErrorResponse_STATUS(&provisioningError)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		destination.ProvisioningErrors = provisioningErrorList
	} else {
		destination.ProvisioningErrors = nil
	}

	// ProvisioningState
	if compute.ProvisioningState != nil {
		provisioningState := string(*compute.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(compute.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ComputeInstance struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// +kubebuilder:validation:Required
	// ComputeType: The type of compute
	ComputeType *ComputeInstance_ComputeType `json:"computeType,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// Properties: Properties of ComputeInstance
	Properties *ComputeInstanceProperties `json:"properties,omitempty"`

	// ResourceReference: ARM resource id of the underlying compute
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &ComputeInstance{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (instance *ComputeInstance) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if instance == nil {
		return nil, nil
	}
	result := &arm.ComputeInstance{}

	// Set property "ComputeLocation":
	if instance.ComputeLocation != nil {
		computeLocation := *instance.ComputeLocation
		result.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	if instance.ComputeType != nil {
		var temp arm.ComputeInstance_ComputeType
		var temp1 string
		temp1 = string(*instance.ComputeType)
		temp = arm.ComputeInstance_ComputeType(temp1)
		result.ComputeType = temp
	}

	// Set property "Description":
	if instance.Description != nil {
		description := *instance.Description
		result.Description = &description
	}

	// Set property "DisableLocalAuth":
	if instance.DisableLocalAuth != nil {
		disableLocalAuth := *instance.DisableLocalAuth
		result.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if instance.Properties != nil {
		properties_ARM, err := (*instance.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*arm.ComputeInstanceProperties)
		result.Properties = &properties
	}

	// Set property "ResourceId":
	if instance.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*instance.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (instance *ComputeInstance) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComputeInstance{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (instance *ComputeInstance) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComputeInstance)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComputeInstance, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		instance.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp ComputeInstance_ComputeType
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = ComputeInstance_ComputeType(temp1)
	instance.ComputeType = &temp

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		instance.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		instance.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 ComputeInstanceProperties
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		instance.Properties = &properties
	}

	// no assignment for property "ResourceReference"

	// No error
	return nil
}

// AssignProperties_From_ComputeInstance populates our ComputeInstance from the provided source ComputeInstance
func (instance *ComputeInstance) AssignProperties_From_ComputeInstance(source *storage.ComputeInstance) error {

	// ComputeLocation
	instance.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, computeInstance_ComputeType_Values)
		instance.ComputeType = &computeTypeTemp
	} else {
		instance.ComputeType = nil
	}

	// Description
	instance.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		instance.DisableLocalAuth = &disableLocalAuth
	} else {
		instance.DisableLocalAuth = nil
	}

	// Properties
	if source.Properties != nil {
		var property ComputeInstanceProperties
		err := property.AssignProperties_From_ComputeInstanceProperties(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ComputeInstanceProperties() to populate field Properties")
		}
		instance.Properties = &property
	} else {
		instance.Properties = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		instance.ResourceReference = &resourceReference
	} else {
		instance.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ComputeInstance populates the provided destination ComputeInstance from our ComputeInstance
func (instance *ComputeInstance) AssignProperties_To_ComputeInstance(destination *storage.ComputeInstance) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(instance.ComputeLocation)

	// ComputeType
	if instance.ComputeType != nil {
		computeType := string(*instance.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(instance.Description)

	// DisableLocalAuth
	if instance.DisableLocalAuth != nil {
		disableLocalAuth := *instance.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// Properties
	if instance.Properties != nil {
		var property storage.ComputeInstanceProperties
		err := instance.Properties.AssignProperties_To_ComputeInstanceProperties(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ComputeInstanceProperties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ResourceReference
	if instance.ResourceReference != nil {
		resourceReference := instance.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ComputeInstance_STATUS struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// ComputeType: The type of compute
	ComputeType *ComputeInstance_ComputeType_STATUS `json:"computeType,omitempty"`

	// CreatedOn: The time at which the compute was created.
	CreatedOn *string `json:"createdOn,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// IsAttachedCompute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine
	// learning service provisioned it if false.
	IsAttachedCompute *bool `json:"isAttachedCompute,omitempty"`

	// ModifiedOn: The time at which the compute was last modified.
	ModifiedOn *string `json:"modifiedOn,omitempty"`

	// Properties: Properties of ComputeInstance
	Properties *ComputeInstanceProperties_STATUS `json:"properties,omitempty"`

	// ProvisioningErrors: Errors during provisioning
	ProvisioningErrors []ErrorResponse_STATUS `json:"provisioningErrors,omitempty"`

	// ProvisioningState: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and
	// Failed.
	ProvisioningState *ComputeInstance_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// ResourceId: ARM resource id of the underlying compute
	ResourceId *string `json:"resourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &ComputeInstance_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (instance *ComputeInstance_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComputeInstance_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (instance *ComputeInstance_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComputeInstance_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComputeInstance_STATUS, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		instance.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp ComputeInstance_ComputeType_STATUS
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = ComputeInstance_ComputeType_STATUS(temp1)
	instance.ComputeType = &temp

	// Set property "CreatedOn":
	if typedInput.CreatedOn != nil {
		createdOn := *typedInput.CreatedOn
		instance.CreatedOn = &createdOn
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		instance.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		instance.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "IsAttachedCompute":
	if typedInput.IsAttachedCompute != nil {
		isAttachedCompute := *typedInput.IsAttachedCompute
		instance.IsAttachedCompute = &isAttachedCompute
	}

	// Set property "ModifiedOn":
	if typedInput.ModifiedOn != nil {
		modifiedOn := *typedInput.ModifiedOn
		instance.ModifiedOn = &modifiedOn
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 ComputeInstanceProperties_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		instance.Properties = &properties
	}

	// Set property "ProvisioningErrors":
	for _, item := range typedInput.ProvisioningErrors {
		var item1 ErrorResponse_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		instance.ProvisioningErrors = append(instance.ProvisioningErrors, item1)
	}

	// Set property "ProvisioningState":
	if typedInput.ProvisioningState != nil {
		var provisioningStateTemp string
		provisioningStateTemp = string(*typedInput.ProvisioningState)
		provisioningState := ComputeInstance_ProvisioningState_STATUS(provisioningStateTemp)
		instance.ProvisioningState = &provisioningState
	}

	// Set property "ResourceId":
	if typedInput.ResourceId != nil {
		resourceId := *typedInput.ResourceId
		instance.ResourceId = &resourceId
	}

	// No error
	return nil
}

// AssignProperties_From_ComputeInstance_STATUS populates our ComputeInstance_STATUS from the provided source ComputeInstance_STATUS
func (instance *ComputeInstance_STATUS) AssignProperties_From_ComputeInstance_STATUS(source *storage.ComputeInstance_STATUS) error {

	// ComputeLocation
	instance.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, computeInstance_ComputeType_STATUS_Values)
		instance.ComputeType = &computeTypeTemp
	} else {
		instance.ComputeType = nil
	}

	// CreatedOn
	instance.CreatedOn = genruntime.ClonePointerToString(source.CreatedOn)

	// Description
	instance.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		instance.DisableLocalAuth = &disableLocalAuth
	} else {
		instance.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if source.IsAttachedCompute != nil {
		isAttachedCompute := *source.IsAttachedCompute
		instance.IsAttachedCompute = &isAttachedCompute
	} else {
		instance.IsAttachedCompute = nil
	}

	// ModifiedOn
	instance.ModifiedOn = genruntime.ClonePointerToString(source.ModifiedOn)

	// Properties
	if source.Properties != nil {
		var property ComputeInstanceProperties_STATUS
		err := property.AssignProperties_From_ComputeInstanceProperties_STATUS(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ComputeInstanceProperties_STATUS() to populate field Properties")
		}
		instance.Properties = &property
	} else {
		instance.Properties = nil
	}

	// ProvisioningErrors
	if source.ProvisioningErrors != nil {
		provisioningErrorList := make([]ErrorResponse_STATUS, len(source.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range source.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError ErrorResponse_STATUS
			err := provisioningError.AssignProperties_From_ErrorResponse_STATUS(&provisioningErrorItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		instance.ProvisioningErrors = provisioningErrorList
	} else {
		instance.ProvisioningErrors = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, computeInstance_ProvisioningState_STATUS_Values)
		instance.ProvisioningState = &provisioningStateTemp
	} else {
		instance.ProvisioningState = nil
	}

	// ResourceId
	instance.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// No error
	return nil
}

// AssignProperties_To_ComputeInstance_STATUS populates the provided destination ComputeInstance_STATUS from our ComputeInstance_STATUS
func (instance *ComputeInstance_STATUS) AssignProperties_To_ComputeInstance_STATUS(destination *storage.ComputeInstance_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(instance.ComputeLocation)

	// ComputeType
	if instance.ComputeType != nil {
		computeType := string(*instance.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// CreatedOn
	destination.CreatedOn = genruntime.ClonePointerToString(instance.CreatedOn)

	// Description
	destination.Description = genruntime.ClonePointerToString(instance.Description)

	// DisableLocalAuth
	if instance.DisableLocalAuth != nil {
		disableLocalAuth := *instance.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if instance.IsAttachedCompute != nil {
		isAttachedCompute := *instance.IsAttachedCompute
		destination.IsAttachedCompute = &isAttachedCompute
	} else {
		destination.IsAttachedCompute = nil
	}

	// ModifiedOn
	destination.ModifiedOn = genruntime.ClonePointerToString(instance.ModifiedOn)

	// Properties
	if instance.Properties != nil {
		var property storage.ComputeInstanceProperties_STATUS
		err := instance.Properties.AssignProperties_To_ComputeInstanceProperties_STATUS(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ComputeInstanceProperties_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ProvisioningErrors
	if instance.ProvisioningErrors != nil {
		provisioningErrorList := make([]storage.ErrorResponse_STATUS, len(instance.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range instance.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError storage.ErrorResponse_STATUS
			err := provisioningErrorItem.AssignProperties_To_ErrorResponse_STATUS(&provisioningError)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		destination.ProvisioningErrors = provisioningErrorList
	} else {
		destination.ProvisioningErrors = nil
	}

	// ProvisioningState
	if instance.ProvisioningState != nil {
		provisioningState := string(*instance.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(instance.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Databricks struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// +kubebuilder:validation:Required
	// ComputeType: The type of compute
	ComputeType *Databricks_ComputeType `json:"computeType,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// Properties: Properties of Databricks
	Properties *DatabricksProperties `json:"properties,omitempty"`

	// ResourceReference: ARM resource id of the underlying compute
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &Databricks{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (databricks *Databricks) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if databricks == nil {
		return nil, nil
	}
	result := &arm.Databricks{}

	// Set property "ComputeLocation":
	if databricks.ComputeLocation != nil {
		computeLocation := *databricks.ComputeLocation
		result.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	if databricks.ComputeType != nil {
		var temp arm.Databricks_ComputeType
		var temp1 string
		temp1 = string(*databricks.ComputeType)
		temp = arm.Databricks_ComputeType(temp1)
		result.ComputeType = temp
	}

	// Set property "Description":
	if databricks.Description != nil {
		description := *databricks.Description
		result.Description = &description
	}

	// Set property "DisableLocalAuth":
	if databricks.DisableLocalAuth != nil {
		disableLocalAuth := *databricks.DisableLocalAuth
		result.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if databricks.Properties != nil {
		properties_ARM, err := (*databricks.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*arm.DatabricksProperties)
		result.Properties = &properties
	}

	// Set property "ResourceId":
	if databricks.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*databricks.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (databricks *Databricks) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Databricks{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (databricks *Databricks) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Databricks)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Databricks, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		databricks.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp Databricks_ComputeType
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = Databricks_ComputeType(temp1)
	databricks.ComputeType = &temp

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		databricks.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		databricks.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 DatabricksProperties
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		databricks.Properties = &properties
	}

	// no assignment for property "ResourceReference"

	// No error
	return nil
}

// AssignProperties_From_Databricks populates our Databricks from the provided source Databricks
func (databricks *Databricks) AssignProperties_From_Databricks(source *storage.Databricks) error {

	// ComputeLocation
	databricks.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, databricks_ComputeType_Values)
		databricks.ComputeType = &computeTypeTemp
	} else {
		databricks.ComputeType = nil
	}

	// Description
	databricks.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		databricks.DisableLocalAuth = &disableLocalAuth
	} else {
		databricks.DisableLocalAuth = nil
	}

	// Properties
	if source.Properties != nil {
		var property DatabricksProperties
		err := property.AssignProperties_From_DatabricksProperties(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DatabricksProperties() to populate field Properties")
		}
		databricks.Properties = &property
	} else {
		databricks.Properties = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		databricks.ResourceReference = &resourceReference
	} else {
		databricks.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Databricks populates the provided destination Databricks from our Databricks
func (databricks *Databricks) AssignProperties_To_Databricks(destination *storage.Databricks) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(databricks.ComputeLocation)

	// ComputeType
	if databricks.ComputeType != nil {
		computeType := string(*databricks.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(databricks.Description)

	// DisableLocalAuth
	if databricks.DisableLocalAuth != nil {
		disableLocalAuth := *databricks.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// Properties
	if databricks.Properties != nil {
		var property storage.DatabricksProperties
		err := databricks.Properties.AssignProperties_To_DatabricksProperties(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DatabricksProperties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ResourceReference
	if databricks.ResourceReference != nil {
		resourceReference := databricks.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Databricks_STATUS struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// ComputeType: The type of compute
	ComputeType *Databricks_ComputeType_STATUS `json:"computeType,omitempty"`

	// CreatedOn: The time at which the compute was created.
	CreatedOn *string `json:"createdOn,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// IsAttachedCompute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine
	// learning service provisioned it if false.
	IsAttachedCompute *bool `json:"isAttachedCompute,omitempty"`

	// ModifiedOn: The time at which the compute was last modified.
	ModifiedOn *string `json:"modifiedOn,omitempty"`

	// Properties: Properties of Databricks
	Properties *DatabricksProperties_STATUS `json:"properties,omitempty"`

	// ProvisioningErrors: Errors during provisioning
	ProvisioningErrors []ErrorResponse_STATUS `json:"provisioningErrors,omitempty"`

	// ProvisioningState: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and
	// Failed.
	ProvisioningState *Databricks_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// ResourceId: ARM resource id of the underlying compute
	ResourceId *string `json:"resourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &Databricks_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (databricks *Databricks_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Databricks_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (databricks *Databricks_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Databricks_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Databricks_STATUS, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		databricks.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp Databricks_ComputeType_STATUS
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = Databricks_ComputeType_STATUS(temp1)
	databricks.ComputeType = &temp

	// Set property "CreatedOn":
	if typedInput.CreatedOn != nil {
		createdOn := *typedInput.CreatedOn
		databricks.CreatedOn = &createdOn
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		databricks.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		databricks.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "IsAttachedCompute":
	if typedInput.IsAttachedCompute != nil {
		isAttachedCompute := *typedInput.IsAttachedCompute
		databricks.IsAttachedCompute = &isAttachedCompute
	}

	// Set property "ModifiedOn":
	if typedInput.ModifiedOn != nil {
		modifiedOn := *typedInput.ModifiedOn
		databricks.ModifiedOn = &modifiedOn
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 DatabricksProperties_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		databricks.Properties = &properties
	}

	// Set property "ProvisioningErrors":
	for _, item := range typedInput.ProvisioningErrors {
		var item1 ErrorResponse_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		databricks.ProvisioningErrors = append(databricks.ProvisioningErrors, item1)
	}

	// Set property "ProvisioningState":
	if typedInput.ProvisioningState != nil {
		var provisioningStateTemp string
		provisioningStateTemp = string(*typedInput.ProvisioningState)
		provisioningState := Databricks_ProvisioningState_STATUS(provisioningStateTemp)
		databricks.ProvisioningState = &provisioningState
	}

	// Set property "ResourceId":
	if typedInput.ResourceId != nil {
		resourceId := *typedInput.ResourceId
		databricks.ResourceId = &resourceId
	}

	// No error
	return nil
}

// AssignProperties_From_Databricks_STATUS populates our Databricks_STATUS from the provided source Databricks_STATUS
func (databricks *Databricks_STATUS) AssignProperties_From_Databricks_STATUS(source *storage.Databricks_STATUS) error {

	// ComputeLocation
	databricks.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, databricks_ComputeType_STATUS_Values)
		databricks.ComputeType = &computeTypeTemp
	} else {
		databricks.ComputeType = nil
	}

	// CreatedOn
	databricks.CreatedOn = genruntime.ClonePointerToString(source.CreatedOn)

	// Description
	databricks.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		databricks.DisableLocalAuth = &disableLocalAuth
	} else {
		databricks.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if source.IsAttachedCompute != nil {
		isAttachedCompute := *source.IsAttachedCompute
		databricks.IsAttachedCompute = &isAttachedCompute
	} else {
		databricks.IsAttachedCompute = nil
	}

	// ModifiedOn
	databricks.ModifiedOn = genruntime.ClonePointerToString(source.ModifiedOn)

	// Properties
	if source.Properties != nil {
		var property DatabricksProperties_STATUS
		err := property.AssignProperties_From_DatabricksProperties_STATUS(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DatabricksProperties_STATUS() to populate field Properties")
		}
		databricks.Properties = &property
	} else {
		databricks.Properties = nil
	}

	// ProvisioningErrors
	if source.ProvisioningErrors != nil {
		provisioningErrorList := make([]ErrorResponse_STATUS, len(source.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range source.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError ErrorResponse_STATUS
			err := provisioningError.AssignProperties_From_ErrorResponse_STATUS(&provisioningErrorItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		databricks.ProvisioningErrors = provisioningErrorList
	} else {
		databricks.ProvisioningErrors = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, databricks_ProvisioningState_STATUS_Values)
		databricks.ProvisioningState = &provisioningStateTemp
	} else {
		databricks.ProvisioningState = nil
	}

	// ResourceId
	databricks.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// No error
	return nil
}

// AssignProperties_To_Databricks_STATUS populates the provided destination Databricks_STATUS from our Databricks_STATUS
func (databricks *Databricks_STATUS) AssignProperties_To_Databricks_STATUS(destination *storage.Databricks_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(databricks.ComputeLocation)

	// ComputeType
	if databricks.ComputeType != nil {
		computeType := string(*databricks.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// CreatedOn
	destination.CreatedOn = genruntime.ClonePointerToString(databricks.CreatedOn)

	// Description
	destination.Description = genruntime.ClonePointerToString(databricks.Description)

	// DisableLocalAuth
	if databricks.DisableLocalAuth != nil {
		disableLocalAuth := *databricks.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if databricks.IsAttachedCompute != nil {
		isAttachedCompute := *databricks.IsAttachedCompute
		destination.IsAttachedCompute = &isAttachedCompute
	} else {
		destination.IsAttachedCompute = nil
	}

	// ModifiedOn
	destination.ModifiedOn = genruntime.ClonePointerToString(databricks.ModifiedOn)

	// Properties
	if databricks.Properties != nil {
		var property storage.DatabricksProperties_STATUS
		err := databricks.Properties.AssignProperties_To_DatabricksProperties_STATUS(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DatabricksProperties_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ProvisioningErrors
	if databricks.ProvisioningErrors != nil {
		provisioningErrorList := make([]storage.ErrorResponse_STATUS, len(databricks.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range databricks.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError storage.ErrorResponse_STATUS
			err := provisioningErrorItem.AssignProperties_To_ErrorResponse_STATUS(&provisioningError)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		destination.ProvisioningErrors = provisioningErrorList
	} else {
		destination.ProvisioningErrors = nil
	}

	// ProvisioningState
	if databricks.ProvisioningState != nil {
		provisioningState := string(*databricks.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(databricks.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DataFactory struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// +kubebuilder:validation:Required
	// ComputeType: The type of compute
	ComputeType *DataFactory_ComputeType `json:"computeType,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// ResourceReference: ARM resource id of the underlying compute
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &DataFactory{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (factory *DataFactory) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if factory == nil {
		return nil, nil
	}
	result := &arm.DataFactory{}

	// Set property "ComputeLocation":
	if factory.ComputeLocation != nil {
		computeLocation := *factory.ComputeLocation
		result.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	if factory.ComputeType != nil {
		var temp arm.DataFactory_ComputeType
		var temp1 string
		temp1 = string(*factory.ComputeType)
		temp = arm.DataFactory_ComputeType(temp1)
		result.ComputeType = temp
	}

	// Set property "Description":
	if factory.Description != nil {
		description := *factory.Description
		result.Description = &description
	}

	// Set property "DisableLocalAuth":
	if factory.DisableLocalAuth != nil {
		disableLocalAuth := *factory.DisableLocalAuth
		result.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "ResourceId":
	if factory.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*factory.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (factory *DataFactory) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DataFactory{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (factory *DataFactory) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DataFactory)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DataFactory, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		factory.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp DataFactory_ComputeType
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = DataFactory_ComputeType(temp1)
	factory.ComputeType = &temp

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		factory.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		factory.DisableLocalAuth = &disableLocalAuth
	}

	// no assignment for property "ResourceReference"

	// No error
	return nil
}

// AssignProperties_From_DataFactory populates our DataFactory from the provided source DataFactory
func (factory *DataFactory) AssignProperties_From_DataFactory(source *storage.DataFactory) error {

	// ComputeLocation
	factory.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, dataFactory_ComputeType_Values)
		factory.ComputeType = &computeTypeTemp
	} else {
		factory.ComputeType = nil
	}

	// Description
	factory.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		factory.DisableLocalAuth = &disableLocalAuth
	} else {
		factory.DisableLocalAuth = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		factory.ResourceReference = &resourceReference
	} else {
		factory.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DataFactory populates the provided destination DataFactory from our DataFactory
func (factory *DataFactory) AssignProperties_To_DataFactory(destination *storage.DataFactory) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(factory.ComputeLocation)

	// ComputeType
	if factory.ComputeType != nil {
		computeType := string(*factory.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(factory.Description)

	// DisableLocalAuth
	if factory.DisableLocalAuth != nil {
		disableLocalAuth := *factory.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// ResourceReference
	if factory.ResourceReference != nil {
		resourceReference := factory.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DataFactory_STATUS struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// ComputeType: The type of compute
	ComputeType *DataFactory_ComputeType_STATUS `json:"computeType,omitempty"`

	// CreatedOn: The time at which the compute was created.
	CreatedOn *string `json:"createdOn,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// IsAttachedCompute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine
	// learning service provisioned it if false.
	IsAttachedCompute *bool `json:"isAttachedCompute,omitempty"`

	// ModifiedOn: The time at which the compute was last modified.
	ModifiedOn *string `json:"modifiedOn,omitempty"`

	// ProvisioningErrors: Errors during provisioning
	ProvisioningErrors []ErrorResponse_STATUS `json:"provisioningErrors,omitempty"`

	// ProvisioningState: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and
	// Failed.
	ProvisioningState *DataFactory_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// ResourceId: ARM resource id of the underlying compute
	ResourceId *string `json:"resourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &DataFactory_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (factory *DataFactory_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DataFactory_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (factory *DataFactory_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DataFactory_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DataFactory_STATUS, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		factory.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp DataFactory_ComputeType_STATUS
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = DataFactory_ComputeType_STATUS(temp1)
	factory.ComputeType = &temp

	// Set property "CreatedOn":
	if typedInput.CreatedOn != nil {
		createdOn := *typedInput.CreatedOn
		factory.CreatedOn = &createdOn
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		factory.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		factory.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "IsAttachedCompute":
	if typedInput.IsAttachedCompute != nil {
		isAttachedCompute := *typedInput.IsAttachedCompute
		factory.IsAttachedCompute = &isAttachedCompute
	}

	// Set property "ModifiedOn":
	if typedInput.ModifiedOn != nil {
		modifiedOn := *typedInput.ModifiedOn
		factory.ModifiedOn = &modifiedOn
	}

	// Set property "ProvisioningErrors":
	for _, item := range typedInput.ProvisioningErrors {
		var item1 ErrorResponse_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		factory.ProvisioningErrors = append(factory.ProvisioningErrors, item1)
	}

	// Set property "ProvisioningState":
	if typedInput.ProvisioningState != nil {
		var provisioningStateTemp string
		provisioningStateTemp = string(*typedInput.ProvisioningState)
		provisioningState := DataFactory_ProvisioningState_STATUS(provisioningStateTemp)
		factory.ProvisioningState = &provisioningState
	}

	// Set property "ResourceId":
	if typedInput.ResourceId != nil {
		resourceId := *typedInput.ResourceId
		factory.ResourceId = &resourceId
	}

	// No error
	return nil
}

// AssignProperties_From_DataFactory_STATUS populates our DataFactory_STATUS from the provided source DataFactory_STATUS
func (factory *DataFactory_STATUS) AssignProperties_From_DataFactory_STATUS(source *storage.DataFactory_STATUS) error {

	// ComputeLocation
	factory.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, dataFactory_ComputeType_STATUS_Values)
		factory.ComputeType = &computeTypeTemp
	} else {
		factory.ComputeType = nil
	}

	// CreatedOn
	factory.CreatedOn = genruntime.ClonePointerToString(source.CreatedOn)

	// Description
	factory.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		factory.DisableLocalAuth = &disableLocalAuth
	} else {
		factory.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if source.IsAttachedCompute != nil {
		isAttachedCompute := *source.IsAttachedCompute
		factory.IsAttachedCompute = &isAttachedCompute
	} else {
		factory.IsAttachedCompute = nil
	}

	// ModifiedOn
	factory.ModifiedOn = genruntime.ClonePointerToString(source.ModifiedOn)

	// ProvisioningErrors
	if source.ProvisioningErrors != nil {
		provisioningErrorList := make([]ErrorResponse_STATUS, len(source.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range source.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError ErrorResponse_STATUS
			err := provisioningError.AssignProperties_From_ErrorResponse_STATUS(&provisioningErrorItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		factory.ProvisioningErrors = provisioningErrorList
	} else {
		factory.ProvisioningErrors = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, dataFactory_ProvisioningState_STATUS_Values)
		factory.ProvisioningState = &provisioningStateTemp
	} else {
		factory.ProvisioningState = nil
	}

	// ResourceId
	factory.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// No error
	return nil
}

// AssignProperties_To_DataFactory_STATUS populates the provided destination DataFactory_STATUS from our DataFactory_STATUS
func (factory *DataFactory_STATUS) AssignProperties_To_DataFactory_STATUS(destination *storage.DataFactory_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(factory.ComputeLocation)

	// ComputeType
	if factory.ComputeType != nil {
		computeType := string(*factory.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// CreatedOn
	destination.CreatedOn = genruntime.ClonePointerToString(factory.CreatedOn)

	// Description
	destination.Description = genruntime.ClonePointerToString(factory.Description)

	// DisableLocalAuth
	if factory.DisableLocalAuth != nil {
		disableLocalAuth := *factory.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if factory.IsAttachedCompute != nil {
		isAttachedCompute := *factory.IsAttachedCompute
		destination.IsAttachedCompute = &isAttachedCompute
	} else {
		destination.IsAttachedCompute = nil
	}

	// ModifiedOn
	destination.ModifiedOn = genruntime.ClonePointerToString(factory.ModifiedOn)

	// ProvisioningErrors
	if factory.ProvisioningErrors != nil {
		provisioningErrorList := make([]storage.ErrorResponse_STATUS, len(factory.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range factory.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError storage.ErrorResponse_STATUS
			err := provisioningErrorItem.AssignProperties_To_ErrorResponse_STATUS(&provisioningError)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		destination.ProvisioningErrors = provisioningErrorList
	} else {
		destination.ProvisioningErrors = nil
	}

	// ProvisioningState
	if factory.ProvisioningState != nil {
		provisioningState := string(*factory.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(factory.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DataLakeAnalytics struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// +kubebuilder:validation:Required
	// ComputeType: The type of compute
	ComputeType *DataLakeAnalytics_ComputeType `json:"computeType,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool                         `json:"disableLocalAuth,omitempty"`
	Properties       *DataLakeAnalytics_Properties `json:"properties,omitempty"`

	// ResourceReference: ARM resource id of the underlying compute
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &DataLakeAnalytics{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (analytics *DataLakeAnalytics) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if analytics == nil {
		return nil, nil
	}
	result := &arm.DataLakeAnalytics{}

	// Set property "ComputeLocation":
	if analytics.ComputeLocation != nil {
		computeLocation := *analytics.ComputeLocation
		result.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	if analytics.ComputeType != nil {
		var temp arm.DataLakeAnalytics_ComputeType
		var temp1 string
		temp1 = string(*analytics.ComputeType)
		temp = arm.DataLakeAnalytics_ComputeType(temp1)
		result.ComputeType = temp
	}

	// Set property "Description":
	if analytics.Description != nil {
		description := *analytics.Description
		result.Description = &description
	}

	// Set property "DisableLocalAuth":
	if analytics.DisableLocalAuth != nil {
		disableLocalAuth := *analytics.DisableLocalAuth
		result.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if analytics.Properties != nil {
		properties_ARM, err := (*analytics.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*arm.DataLakeAnalytics_Properties)
		result.Properties = &properties
	}

	// Set property "ResourceId":
	if analytics.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*analytics.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (analytics *DataLakeAnalytics) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DataLakeAnalytics{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (analytics *DataLakeAnalytics) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DataLakeAnalytics)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DataLakeAnalytics, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		analytics.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp DataLakeAnalytics_ComputeType
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = DataLakeAnalytics_ComputeType(temp1)
	analytics.ComputeType = &temp

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		analytics.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		analytics.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 DataLakeAnalytics_Properties
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		analytics.Properties = &properties
	}

	// no assignment for property "ResourceReference"

	// No error
	return nil
}

// AssignProperties_From_DataLakeAnalytics populates our DataLakeAnalytics from the provided source DataLakeAnalytics
func (analytics *DataLakeAnalytics) AssignProperties_From_DataLakeAnalytics(source *storage.DataLakeAnalytics) error {

	// ComputeLocation
	analytics.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, dataLakeAnalytics_ComputeType_Values)
		analytics.ComputeType = &computeTypeTemp
	} else {
		analytics.ComputeType = nil
	}

	// Description
	analytics.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		analytics.DisableLocalAuth = &disableLocalAuth
	} else {
		analytics.DisableLocalAuth = nil
	}

	// Properties
	if source.Properties != nil {
		var property DataLakeAnalytics_Properties
		err := property.AssignProperties_From_DataLakeAnalytics_Properties(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DataLakeAnalytics_Properties() to populate field Properties")
		}
		analytics.Properties = &property
	} else {
		analytics.Properties = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		analytics.ResourceReference = &resourceReference
	} else {
		analytics.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DataLakeAnalytics populates the provided destination DataLakeAnalytics from our DataLakeAnalytics
func (analytics *DataLakeAnalytics) AssignProperties_To_DataLakeAnalytics(destination *storage.DataLakeAnalytics) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(analytics.ComputeLocation)

	// ComputeType
	if analytics.ComputeType != nil {
		computeType := string(*analytics.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(analytics.Description)

	// DisableLocalAuth
	if analytics.DisableLocalAuth != nil {
		disableLocalAuth := *analytics.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// Properties
	if analytics.Properties != nil {
		var property storage.DataLakeAnalytics_Properties
		err := analytics.Properties.AssignProperties_To_DataLakeAnalytics_Properties(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DataLakeAnalytics_Properties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ResourceReference
	if analytics.ResourceReference != nil {
		resourceReference := analytics.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DataLakeAnalytics_STATUS struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// ComputeType: The type of compute
	ComputeType *DataLakeAnalytics_ComputeType_STATUS `json:"computeType,omitempty"`

	// CreatedOn: The time at which the compute was created.
	CreatedOn *string `json:"createdOn,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// IsAttachedCompute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine
	// learning service provisioned it if false.
	IsAttachedCompute *bool `json:"isAttachedCompute,omitempty"`

	// ModifiedOn: The time at which the compute was last modified.
	ModifiedOn *string                              `json:"modifiedOn,omitempty"`
	Properties *DataLakeAnalytics_Properties_STATUS `json:"properties,omitempty"`

	// ProvisioningErrors: Errors during provisioning
	ProvisioningErrors []ErrorResponse_STATUS `json:"provisioningErrors,omitempty"`

	// ProvisioningState: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and
	// Failed.
	ProvisioningState *DataLakeAnalytics_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// ResourceId: ARM resource id of the underlying compute
	ResourceId *string `json:"resourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &DataLakeAnalytics_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (analytics *DataLakeAnalytics_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DataLakeAnalytics_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (analytics *DataLakeAnalytics_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DataLakeAnalytics_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DataLakeAnalytics_STATUS, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		analytics.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp DataLakeAnalytics_ComputeType_STATUS
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = DataLakeAnalytics_ComputeType_STATUS(temp1)
	analytics.ComputeType = &temp

	// Set property "CreatedOn":
	if typedInput.CreatedOn != nil {
		createdOn := *typedInput.CreatedOn
		analytics.CreatedOn = &createdOn
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		analytics.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		analytics.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "IsAttachedCompute":
	if typedInput.IsAttachedCompute != nil {
		isAttachedCompute := *typedInput.IsAttachedCompute
		analytics.IsAttachedCompute = &isAttachedCompute
	}

	// Set property "ModifiedOn":
	if typedInput.ModifiedOn != nil {
		modifiedOn := *typedInput.ModifiedOn
		analytics.ModifiedOn = &modifiedOn
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 DataLakeAnalytics_Properties_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		analytics.Properties = &properties
	}

	// Set property "ProvisioningErrors":
	for _, item := range typedInput.ProvisioningErrors {
		var item1 ErrorResponse_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		analytics.ProvisioningErrors = append(analytics.ProvisioningErrors, item1)
	}

	// Set property "ProvisioningState":
	if typedInput.ProvisioningState != nil {
		var provisioningStateTemp string
		provisioningStateTemp = string(*typedInput.ProvisioningState)
		provisioningState := DataLakeAnalytics_ProvisioningState_STATUS(provisioningStateTemp)
		analytics.ProvisioningState = &provisioningState
	}

	// Set property "ResourceId":
	if typedInput.ResourceId != nil {
		resourceId := *typedInput.ResourceId
		analytics.ResourceId = &resourceId
	}

	// No error
	return nil
}

// AssignProperties_From_DataLakeAnalytics_STATUS populates our DataLakeAnalytics_STATUS from the provided source DataLakeAnalytics_STATUS
func (analytics *DataLakeAnalytics_STATUS) AssignProperties_From_DataLakeAnalytics_STATUS(source *storage.DataLakeAnalytics_STATUS) error {

	// ComputeLocation
	analytics.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, dataLakeAnalytics_ComputeType_STATUS_Values)
		analytics.ComputeType = &computeTypeTemp
	} else {
		analytics.ComputeType = nil
	}

	// CreatedOn
	analytics.CreatedOn = genruntime.ClonePointerToString(source.CreatedOn)

	// Description
	analytics.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		analytics.DisableLocalAuth = &disableLocalAuth
	} else {
		analytics.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if source.IsAttachedCompute != nil {
		isAttachedCompute := *source.IsAttachedCompute
		analytics.IsAttachedCompute = &isAttachedCompute
	} else {
		analytics.IsAttachedCompute = nil
	}

	// ModifiedOn
	analytics.ModifiedOn = genruntime.ClonePointerToString(source.ModifiedOn)

	// Properties
	if source.Properties != nil {
		var property DataLakeAnalytics_Properties_STATUS
		err := property.AssignProperties_From_DataLakeAnalytics_Properties_STATUS(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DataLakeAnalytics_Properties_STATUS() to populate field Properties")
		}
		analytics.Properties = &property
	} else {
		analytics.Properties = nil
	}

	// ProvisioningErrors
	if source.ProvisioningErrors != nil {
		provisioningErrorList := make([]ErrorResponse_STATUS, len(source.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range source.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError ErrorResponse_STATUS
			err := provisioningError.AssignProperties_From_ErrorResponse_STATUS(&provisioningErrorItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		analytics.ProvisioningErrors = provisioningErrorList
	} else {
		analytics.ProvisioningErrors = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, dataLakeAnalytics_ProvisioningState_STATUS_Values)
		analytics.ProvisioningState = &provisioningStateTemp
	} else {
		analytics.ProvisioningState = nil
	}

	// ResourceId
	analytics.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// No error
	return nil
}

// AssignProperties_To_DataLakeAnalytics_STATUS populates the provided destination DataLakeAnalytics_STATUS from our DataLakeAnalytics_STATUS
func (analytics *DataLakeAnalytics_STATUS) AssignProperties_To_DataLakeAnalytics_STATUS(destination *storage.DataLakeAnalytics_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(analytics.ComputeLocation)

	// ComputeType
	if analytics.ComputeType != nil {
		computeType := string(*analytics.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// CreatedOn
	destination.CreatedOn = genruntime.ClonePointerToString(analytics.CreatedOn)

	// Description
	destination.Description = genruntime.ClonePointerToString(analytics.Description)

	// DisableLocalAuth
	if analytics.DisableLocalAuth != nil {
		disableLocalAuth := *analytics.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if analytics.IsAttachedCompute != nil {
		isAttachedCompute := *analytics.IsAttachedCompute
		destination.IsAttachedCompute = &isAttachedCompute
	} else {
		destination.IsAttachedCompute = nil
	}

	// ModifiedOn
	destination.ModifiedOn = genruntime.ClonePointerToString(analytics.ModifiedOn)

	// Properties
	if analytics.Properties != nil {
		var property storage.DataLakeAnalytics_Properties_STATUS
		err := analytics.Properties.AssignProperties_To_DataLakeAnalytics_Properties_STATUS(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DataLakeAnalytics_Properties_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ProvisioningErrors
	if analytics.ProvisioningErrors != nil {
		provisioningErrorList := make([]storage.ErrorResponse_STATUS, len(analytics.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range analytics.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError storage.ErrorResponse_STATUS
			err := provisioningErrorItem.AssignProperties_To_ErrorResponse_STATUS(&provisioningError)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		destination.ProvisioningErrors = provisioningErrorList
	} else {
		destination.ProvisioningErrors = nil
	}

	// ProvisioningState
	if analytics.ProvisioningState != nil {
		provisioningState := string(*analytics.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(analytics.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type HDInsight struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// +kubebuilder:validation:Required
	// ComputeType: The type of compute
	ComputeType *HDInsight_ComputeType `json:"computeType,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// Properties: HDInsight compute properties
	Properties *HDInsightProperties `json:"properties,omitempty"`

	// ResourceReference: ARM resource id of the underlying compute
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &HDInsight{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (insight *HDInsight) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if insight == nil {
		return nil, nil
	}
	result := &arm.HDInsight{}

	// Set property "ComputeLocation":
	if insight.ComputeLocation != nil {
		computeLocation := *insight.ComputeLocation
		result.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	if insight.ComputeType != nil {
		var temp arm.HDInsight_ComputeType
		var temp1 string
		temp1 = string(*insight.ComputeType)
		temp = arm.HDInsight_ComputeType(temp1)
		result.ComputeType = temp
	}

	// Set property "Description":
	if insight.Description != nil {
		description := *insight.Description
		result.Description = &description
	}

	// Set property "DisableLocalAuth":
	if insight.DisableLocalAuth != nil {
		disableLocalAuth := *insight.DisableLocalAuth
		result.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if insight.Properties != nil {
		properties_ARM, err := (*insight.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*arm.HDInsightProperties)
		result.Properties = &properties
	}

	// Set property "ResourceId":
	if insight.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*insight.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (insight *HDInsight) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HDInsight{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (insight *HDInsight) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HDInsight)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HDInsight, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		insight.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp HDInsight_ComputeType
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = HDInsight_ComputeType(temp1)
	insight.ComputeType = &temp

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		insight.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		insight.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 HDInsightProperties
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		insight.Properties = &properties
	}

	// no assignment for property "ResourceReference"

	// No error
	return nil
}

// AssignProperties_From_HDInsight populates our HDInsight from the provided source HDInsight
func (insight *HDInsight) AssignProperties_From_HDInsight(source *storage.HDInsight) error {

	// ComputeLocation
	insight.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, hDInsight_ComputeType_Values)
		insight.ComputeType = &computeTypeTemp
	} else {
		insight.ComputeType = nil
	}

	// Description
	insight.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		insight.DisableLocalAuth = &disableLocalAuth
	} else {
		insight.DisableLocalAuth = nil
	}

	// Properties
	if source.Properties != nil {
		var property HDInsightProperties
		err := property.AssignProperties_From_HDInsightProperties(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_HDInsightProperties() to populate field Properties")
		}
		insight.Properties = &property
	} else {
		insight.Properties = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		insight.ResourceReference = &resourceReference
	} else {
		insight.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_HDInsight populates the provided destination HDInsight from our HDInsight
func (insight *HDInsight) AssignProperties_To_HDInsight(destination *storage.HDInsight) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(insight.ComputeLocation)

	// ComputeType
	if insight.ComputeType != nil {
		computeType := string(*insight.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(insight.Description)

	// DisableLocalAuth
	if insight.DisableLocalAuth != nil {
		disableLocalAuth := *insight.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// Properties
	if insight.Properties != nil {
		var property storage.HDInsightProperties
		err := insight.Properties.AssignProperties_To_HDInsightProperties(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_HDInsightProperties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ResourceReference
	if insight.ResourceReference != nil {
		resourceReference := insight.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type HDInsight_STATUS struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// ComputeType: The type of compute
	ComputeType *HDInsight_ComputeType_STATUS `json:"computeType,omitempty"`

	// CreatedOn: The time at which the compute was created.
	CreatedOn *string `json:"createdOn,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// IsAttachedCompute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine
	// learning service provisioned it if false.
	IsAttachedCompute *bool `json:"isAttachedCompute,omitempty"`

	// ModifiedOn: The time at which the compute was last modified.
	ModifiedOn *string `json:"modifiedOn,omitempty"`

	// Properties: HDInsight compute properties
	Properties *HDInsightProperties_STATUS `json:"properties,omitempty"`

	// ProvisioningErrors: Errors during provisioning
	ProvisioningErrors []ErrorResponse_STATUS `json:"provisioningErrors,omitempty"`

	// ProvisioningState: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and
	// Failed.
	ProvisioningState *HDInsight_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// ResourceId: ARM resource id of the underlying compute
	ResourceId *string `json:"resourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &HDInsight_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (insight *HDInsight_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HDInsight_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (insight *HDInsight_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HDInsight_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HDInsight_STATUS, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		insight.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp HDInsight_ComputeType_STATUS
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = HDInsight_ComputeType_STATUS(temp1)
	insight.ComputeType = &temp

	// Set property "CreatedOn":
	if typedInput.CreatedOn != nil {
		createdOn := *typedInput.CreatedOn
		insight.CreatedOn = &createdOn
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		insight.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		insight.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "IsAttachedCompute":
	if typedInput.IsAttachedCompute != nil {
		isAttachedCompute := *typedInput.IsAttachedCompute
		insight.IsAttachedCompute = &isAttachedCompute
	}

	// Set property "ModifiedOn":
	if typedInput.ModifiedOn != nil {
		modifiedOn := *typedInput.ModifiedOn
		insight.ModifiedOn = &modifiedOn
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 HDInsightProperties_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		insight.Properties = &properties
	}

	// Set property "ProvisioningErrors":
	for _, item := range typedInput.ProvisioningErrors {
		var item1 ErrorResponse_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		insight.ProvisioningErrors = append(insight.ProvisioningErrors, item1)
	}

	// Set property "ProvisioningState":
	if typedInput.ProvisioningState != nil {
		var provisioningStateTemp string
		provisioningStateTemp = string(*typedInput.ProvisioningState)
		provisioningState := HDInsight_ProvisioningState_STATUS(provisioningStateTemp)
		insight.ProvisioningState = &provisioningState
	}

	// Set property "ResourceId":
	if typedInput.ResourceId != nil {
		resourceId := *typedInput.ResourceId
		insight.ResourceId = &resourceId
	}

	// No error
	return nil
}

// AssignProperties_From_HDInsight_STATUS populates our HDInsight_STATUS from the provided source HDInsight_STATUS
func (insight *HDInsight_STATUS) AssignProperties_From_HDInsight_STATUS(source *storage.HDInsight_STATUS) error {

	// ComputeLocation
	insight.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, hDInsight_ComputeType_STATUS_Values)
		insight.ComputeType = &computeTypeTemp
	} else {
		insight.ComputeType = nil
	}

	// CreatedOn
	insight.CreatedOn = genruntime.ClonePointerToString(source.CreatedOn)

	// Description
	insight.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		insight.DisableLocalAuth = &disableLocalAuth
	} else {
		insight.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if source.IsAttachedCompute != nil {
		isAttachedCompute := *source.IsAttachedCompute
		insight.IsAttachedCompute = &isAttachedCompute
	} else {
		insight.IsAttachedCompute = nil
	}

	// ModifiedOn
	insight.ModifiedOn = genruntime.ClonePointerToString(source.ModifiedOn)

	// Properties
	if source.Properties != nil {
		var property HDInsightProperties_STATUS
		err := property.AssignProperties_From_HDInsightProperties_STATUS(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_HDInsightProperties_STATUS() to populate field Properties")
		}
		insight.Properties = &property
	} else {
		insight.Properties = nil
	}

	// ProvisioningErrors
	if source.ProvisioningErrors != nil {
		provisioningErrorList := make([]ErrorResponse_STATUS, len(source.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range source.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError ErrorResponse_STATUS
			err := provisioningError.AssignProperties_From_ErrorResponse_STATUS(&provisioningErrorItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		insight.ProvisioningErrors = provisioningErrorList
	} else {
		insight.ProvisioningErrors = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, hDInsight_ProvisioningState_STATUS_Values)
		insight.ProvisioningState = &provisioningStateTemp
	} else {
		insight.ProvisioningState = nil
	}

	// ResourceId
	insight.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// No error
	return nil
}

// AssignProperties_To_HDInsight_STATUS populates the provided destination HDInsight_STATUS from our HDInsight_STATUS
func (insight *HDInsight_STATUS) AssignProperties_To_HDInsight_STATUS(destination *storage.HDInsight_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(insight.ComputeLocation)

	// ComputeType
	if insight.ComputeType != nil {
		computeType := string(*insight.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// CreatedOn
	destination.CreatedOn = genruntime.ClonePointerToString(insight.CreatedOn)

	// Description
	destination.Description = genruntime.ClonePointerToString(insight.Description)

	// DisableLocalAuth
	if insight.DisableLocalAuth != nil {
		disableLocalAuth := *insight.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if insight.IsAttachedCompute != nil {
		isAttachedCompute := *insight.IsAttachedCompute
		destination.IsAttachedCompute = &isAttachedCompute
	} else {
		destination.IsAttachedCompute = nil
	}

	// ModifiedOn
	destination.ModifiedOn = genruntime.ClonePointerToString(insight.ModifiedOn)

	// Properties
	if insight.Properties != nil {
		var property storage.HDInsightProperties_STATUS
		err := insight.Properties.AssignProperties_To_HDInsightProperties_STATUS(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_HDInsightProperties_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ProvisioningErrors
	if insight.ProvisioningErrors != nil {
		provisioningErrorList := make([]storage.ErrorResponse_STATUS, len(insight.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range insight.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError storage.ErrorResponse_STATUS
			err := provisioningErrorItem.AssignProperties_To_ErrorResponse_STATUS(&provisioningError)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		destination.ProvisioningErrors = provisioningErrorList
	} else {
		destination.ProvisioningErrors = nil
	}

	// ProvisioningState
	if insight.ProvisioningState != nil {
		provisioningState := string(*insight.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(insight.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Kubernetes struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// +kubebuilder:validation:Required
	// ComputeType: The type of compute
	ComputeType *Kubernetes_ComputeType `json:"computeType,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// Properties: Properties of Kubernetes
	Properties *KubernetesProperties `json:"properties,omitempty"`

	// ResourceReference: ARM resource id of the underlying compute
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &Kubernetes{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (kubernetes *Kubernetes) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if kubernetes == nil {
		return nil, nil
	}
	result := &arm.Kubernetes{}

	// Set property "ComputeLocation":
	if kubernetes.ComputeLocation != nil {
		computeLocation := *kubernetes.ComputeLocation
		result.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	if kubernetes.ComputeType != nil {
		var temp arm.Kubernetes_ComputeType
		var temp1 string
		temp1 = string(*kubernetes.ComputeType)
		temp = arm.Kubernetes_ComputeType(temp1)
		result.ComputeType = temp
	}

	// Set property "Description":
	if kubernetes.Description != nil {
		description := *kubernetes.Description
		result.Description = &description
	}

	// Set property "DisableLocalAuth":
	if kubernetes.DisableLocalAuth != nil {
		disableLocalAuth := *kubernetes.DisableLocalAuth
		result.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if kubernetes.Properties != nil {
		properties_ARM, err := (*kubernetes.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*arm.KubernetesProperties)
		result.Properties = &properties
	}

	// Set property "ResourceId":
	if kubernetes.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*kubernetes.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (kubernetes *Kubernetes) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Kubernetes{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (kubernetes *Kubernetes) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Kubernetes)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Kubernetes, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		kubernetes.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp Kubernetes_ComputeType
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = Kubernetes_ComputeType(temp1)
	kubernetes.ComputeType = &temp

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		kubernetes.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		kubernetes.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 KubernetesProperties
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		kubernetes.Properties = &properties
	}

	// no assignment for property "ResourceReference"

	// No error
	return nil
}

// AssignProperties_From_Kubernetes populates our Kubernetes from the provided source Kubernetes
func (kubernetes *Kubernetes) AssignProperties_From_Kubernetes(source *storage.Kubernetes) error {

	// ComputeLocation
	kubernetes.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, kubernetes_ComputeType_Values)
		kubernetes.ComputeType = &computeTypeTemp
	} else {
		kubernetes.ComputeType = nil
	}

	// Description
	kubernetes.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		kubernetes.DisableLocalAuth = &disableLocalAuth
	} else {
		kubernetes.DisableLocalAuth = nil
	}

	// Properties
	if source.Properties != nil {
		var property KubernetesProperties
		err := property.AssignProperties_From_KubernetesProperties(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_KubernetesProperties() to populate field Properties")
		}
		kubernetes.Properties = &property
	} else {
		kubernetes.Properties = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		kubernetes.ResourceReference = &resourceReference
	} else {
		kubernetes.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Kubernetes populates the provided destination Kubernetes from our Kubernetes
func (kubernetes *Kubernetes) AssignProperties_To_Kubernetes(destination *storage.Kubernetes) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(kubernetes.ComputeLocation)

	// ComputeType
	if kubernetes.ComputeType != nil {
		computeType := string(*kubernetes.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(kubernetes.Description)

	// DisableLocalAuth
	if kubernetes.DisableLocalAuth != nil {
		disableLocalAuth := *kubernetes.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// Properties
	if kubernetes.Properties != nil {
		var property storage.KubernetesProperties
		err := kubernetes.Properties.AssignProperties_To_KubernetesProperties(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_KubernetesProperties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ResourceReference
	if kubernetes.ResourceReference != nil {
		resourceReference := kubernetes.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Kubernetes_STATUS struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// ComputeType: The type of compute
	ComputeType *Kubernetes_ComputeType_STATUS `json:"computeType,omitempty"`

	// CreatedOn: The time at which the compute was created.
	CreatedOn *string `json:"createdOn,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// IsAttachedCompute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine
	// learning service provisioned it if false.
	IsAttachedCompute *bool `json:"isAttachedCompute,omitempty"`

	// ModifiedOn: The time at which the compute was last modified.
	ModifiedOn *string `json:"modifiedOn,omitempty"`

	// Properties: Properties of Kubernetes
	Properties *KubernetesProperties_STATUS `json:"properties,omitempty"`

	// ProvisioningErrors: Errors during provisioning
	ProvisioningErrors []ErrorResponse_STATUS `json:"provisioningErrors,omitempty"`

	// ProvisioningState: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and
	// Failed.
	ProvisioningState *Kubernetes_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// ResourceId: ARM resource id of the underlying compute
	ResourceId *string `json:"resourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &Kubernetes_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (kubernetes *Kubernetes_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Kubernetes_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (kubernetes *Kubernetes_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Kubernetes_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Kubernetes_STATUS, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		kubernetes.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp Kubernetes_ComputeType_STATUS
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = Kubernetes_ComputeType_STATUS(temp1)
	kubernetes.ComputeType = &temp

	// Set property "CreatedOn":
	if typedInput.CreatedOn != nil {
		createdOn := *typedInput.CreatedOn
		kubernetes.CreatedOn = &createdOn
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		kubernetes.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		kubernetes.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "IsAttachedCompute":
	if typedInput.IsAttachedCompute != nil {
		isAttachedCompute := *typedInput.IsAttachedCompute
		kubernetes.IsAttachedCompute = &isAttachedCompute
	}

	// Set property "ModifiedOn":
	if typedInput.ModifiedOn != nil {
		modifiedOn := *typedInput.ModifiedOn
		kubernetes.ModifiedOn = &modifiedOn
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 KubernetesProperties_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		kubernetes.Properties = &properties
	}

	// Set property "ProvisioningErrors":
	for _, item := range typedInput.ProvisioningErrors {
		var item1 ErrorResponse_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		kubernetes.ProvisioningErrors = append(kubernetes.ProvisioningErrors, item1)
	}

	// Set property "ProvisioningState":
	if typedInput.ProvisioningState != nil {
		var provisioningStateTemp string
		provisioningStateTemp = string(*typedInput.ProvisioningState)
		provisioningState := Kubernetes_ProvisioningState_STATUS(provisioningStateTemp)
		kubernetes.ProvisioningState = &provisioningState
	}

	// Set property "ResourceId":
	if typedInput.ResourceId != nil {
		resourceId := *typedInput.ResourceId
		kubernetes.ResourceId = &resourceId
	}

	// No error
	return nil
}

// AssignProperties_From_Kubernetes_STATUS populates our Kubernetes_STATUS from the provided source Kubernetes_STATUS
func (kubernetes *Kubernetes_STATUS) AssignProperties_From_Kubernetes_STATUS(source *storage.Kubernetes_STATUS) error {

	// ComputeLocation
	kubernetes.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, kubernetes_ComputeType_STATUS_Values)
		kubernetes.ComputeType = &computeTypeTemp
	} else {
		kubernetes.ComputeType = nil
	}

	// CreatedOn
	kubernetes.CreatedOn = genruntime.ClonePointerToString(source.CreatedOn)

	// Description
	kubernetes.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		kubernetes.DisableLocalAuth = &disableLocalAuth
	} else {
		kubernetes.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if source.IsAttachedCompute != nil {
		isAttachedCompute := *source.IsAttachedCompute
		kubernetes.IsAttachedCompute = &isAttachedCompute
	} else {
		kubernetes.IsAttachedCompute = nil
	}

	// ModifiedOn
	kubernetes.ModifiedOn = genruntime.ClonePointerToString(source.ModifiedOn)

	// Properties
	if source.Properties != nil {
		var property KubernetesProperties_STATUS
		err := property.AssignProperties_From_KubernetesProperties_STATUS(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_KubernetesProperties_STATUS() to populate field Properties")
		}
		kubernetes.Properties = &property
	} else {
		kubernetes.Properties = nil
	}

	// ProvisioningErrors
	if source.ProvisioningErrors != nil {
		provisioningErrorList := make([]ErrorResponse_STATUS, len(source.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range source.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError ErrorResponse_STATUS
			err := provisioningError.AssignProperties_From_ErrorResponse_STATUS(&provisioningErrorItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		kubernetes.ProvisioningErrors = provisioningErrorList
	} else {
		kubernetes.ProvisioningErrors = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, kubernetes_ProvisioningState_STATUS_Values)
		kubernetes.ProvisioningState = &provisioningStateTemp
	} else {
		kubernetes.ProvisioningState = nil
	}

	// ResourceId
	kubernetes.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// No error
	return nil
}

// AssignProperties_To_Kubernetes_STATUS populates the provided destination Kubernetes_STATUS from our Kubernetes_STATUS
func (kubernetes *Kubernetes_STATUS) AssignProperties_To_Kubernetes_STATUS(destination *storage.Kubernetes_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(kubernetes.ComputeLocation)

	// ComputeType
	if kubernetes.ComputeType != nil {
		computeType := string(*kubernetes.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// CreatedOn
	destination.CreatedOn = genruntime.ClonePointerToString(kubernetes.CreatedOn)

	// Description
	destination.Description = genruntime.ClonePointerToString(kubernetes.Description)

	// DisableLocalAuth
	if kubernetes.DisableLocalAuth != nil {
		disableLocalAuth := *kubernetes.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if kubernetes.IsAttachedCompute != nil {
		isAttachedCompute := *kubernetes.IsAttachedCompute
		destination.IsAttachedCompute = &isAttachedCompute
	} else {
		destination.IsAttachedCompute = nil
	}

	// ModifiedOn
	destination.ModifiedOn = genruntime.ClonePointerToString(kubernetes.ModifiedOn)

	// Properties
	if kubernetes.Properties != nil {
		var property storage.KubernetesProperties_STATUS
		err := kubernetes.Properties.AssignProperties_To_KubernetesProperties_STATUS(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_KubernetesProperties_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ProvisioningErrors
	if kubernetes.ProvisioningErrors != nil {
		provisioningErrorList := make([]storage.ErrorResponse_STATUS, len(kubernetes.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range kubernetes.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError storage.ErrorResponse_STATUS
			err := provisioningErrorItem.AssignProperties_To_ErrorResponse_STATUS(&provisioningError)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		destination.ProvisioningErrors = provisioningErrorList
	} else {
		destination.ProvisioningErrors = nil
	}

	// ProvisioningState
	if kubernetes.ProvisioningState != nil {
		provisioningState := string(*kubernetes.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(kubernetes.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type SynapseSpark struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// +kubebuilder:validation:Required
	// ComputeType: The type of compute
	ComputeType *SynapseSpark_ComputeType `json:"computeType,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool                    `json:"disableLocalAuth,omitempty"`
	Properties       *SynapseSpark_Properties `json:"properties,omitempty"`

	// ResourceReference: ARM resource id of the underlying compute
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &SynapseSpark{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (spark *SynapseSpark) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if spark == nil {
		return nil, nil
	}
	result := &arm.SynapseSpark{}

	// Set property "ComputeLocation":
	if spark.ComputeLocation != nil {
		computeLocation := *spark.ComputeLocation
		result.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	if spark.ComputeType != nil {
		var temp arm.SynapseSpark_ComputeType
		var temp1 string
		temp1 = string(*spark.ComputeType)
		temp = arm.SynapseSpark_ComputeType(temp1)
		result.ComputeType = temp
	}

	// Set property "Description":
	if spark.Description != nil {
		description := *spark.Description
		result.Description = &description
	}

	// Set property "DisableLocalAuth":
	if spark.DisableLocalAuth != nil {
		disableLocalAuth := *spark.DisableLocalAuth
		result.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if spark.Properties != nil {
		properties_ARM, err := (*spark.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*arm.SynapseSpark_Properties)
		result.Properties = &properties
	}

	// Set property "ResourceId":
	if spark.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*spark.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (spark *SynapseSpark) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SynapseSpark{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (spark *SynapseSpark) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SynapseSpark)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SynapseSpark, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		spark.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp SynapseSpark_ComputeType
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = SynapseSpark_ComputeType(temp1)
	spark.ComputeType = &temp

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		spark.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		spark.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 SynapseSpark_Properties
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		spark.Properties = &properties
	}

	// no assignment for property "ResourceReference"

	// No error
	return nil
}

// AssignProperties_From_SynapseSpark populates our SynapseSpark from the provided source SynapseSpark
func (spark *SynapseSpark) AssignProperties_From_SynapseSpark(source *storage.SynapseSpark) error {

	// ComputeLocation
	spark.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, synapseSpark_ComputeType_Values)
		spark.ComputeType = &computeTypeTemp
	} else {
		spark.ComputeType = nil
	}

	// Description
	spark.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		spark.DisableLocalAuth = &disableLocalAuth
	} else {
		spark.DisableLocalAuth = nil
	}

	// Properties
	if source.Properties != nil {
		var property SynapseSpark_Properties
		err := property.AssignProperties_From_SynapseSpark_Properties(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SynapseSpark_Properties() to populate field Properties")
		}
		spark.Properties = &property
	} else {
		spark.Properties = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		spark.ResourceReference = &resourceReference
	} else {
		spark.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SynapseSpark populates the provided destination SynapseSpark from our SynapseSpark
func (spark *SynapseSpark) AssignProperties_To_SynapseSpark(destination *storage.SynapseSpark) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(spark.ComputeLocation)

	// ComputeType
	if spark.ComputeType != nil {
		computeType := string(*spark.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(spark.Description)

	// DisableLocalAuth
	if spark.DisableLocalAuth != nil {
		disableLocalAuth := *spark.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// Properties
	if spark.Properties != nil {
		var property storage.SynapseSpark_Properties
		err := spark.Properties.AssignProperties_To_SynapseSpark_Properties(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SynapseSpark_Properties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ResourceReference
	if spark.ResourceReference != nil {
		resourceReference := spark.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type SynapseSpark_STATUS struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// ComputeType: The type of compute
	ComputeType *SynapseSpark_ComputeType_STATUS `json:"computeType,omitempty"`

	// CreatedOn: The time at which the compute was created.
	CreatedOn *string `json:"createdOn,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// IsAttachedCompute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine
	// learning service provisioned it if false.
	IsAttachedCompute *bool `json:"isAttachedCompute,omitempty"`

	// ModifiedOn: The time at which the compute was last modified.
	ModifiedOn *string                         `json:"modifiedOn,omitempty"`
	Properties *SynapseSpark_Properties_STATUS `json:"properties,omitempty"`

	// ProvisioningErrors: Errors during provisioning
	ProvisioningErrors []ErrorResponse_STATUS `json:"provisioningErrors,omitempty"`

	// ProvisioningState: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and
	// Failed.
	ProvisioningState *SynapseSpark_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// ResourceId: ARM resource id of the underlying compute
	ResourceId *string `json:"resourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &SynapseSpark_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (spark *SynapseSpark_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SynapseSpark_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (spark *SynapseSpark_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SynapseSpark_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SynapseSpark_STATUS, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		spark.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp SynapseSpark_ComputeType_STATUS
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = SynapseSpark_ComputeType_STATUS(temp1)
	spark.ComputeType = &temp

	// Set property "CreatedOn":
	if typedInput.CreatedOn != nil {
		createdOn := *typedInput.CreatedOn
		spark.CreatedOn = &createdOn
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		spark.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		spark.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "IsAttachedCompute":
	if typedInput.IsAttachedCompute != nil {
		isAttachedCompute := *typedInput.IsAttachedCompute
		spark.IsAttachedCompute = &isAttachedCompute
	}

	// Set property "ModifiedOn":
	if typedInput.ModifiedOn != nil {
		modifiedOn := *typedInput.ModifiedOn
		spark.ModifiedOn = &modifiedOn
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 SynapseSpark_Properties_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		spark.Properties = &properties
	}

	// Set property "ProvisioningErrors":
	for _, item := range typedInput.ProvisioningErrors {
		var item1 ErrorResponse_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		spark.ProvisioningErrors = append(spark.ProvisioningErrors, item1)
	}

	// Set property "ProvisioningState":
	if typedInput.ProvisioningState != nil {
		var provisioningStateTemp string
		provisioningStateTemp = string(*typedInput.ProvisioningState)
		provisioningState := SynapseSpark_ProvisioningState_STATUS(provisioningStateTemp)
		spark.ProvisioningState = &provisioningState
	}

	// Set property "ResourceId":
	if typedInput.ResourceId != nil {
		resourceId := *typedInput.ResourceId
		spark.ResourceId = &resourceId
	}

	// No error
	return nil
}

// AssignProperties_From_SynapseSpark_STATUS populates our SynapseSpark_STATUS from the provided source SynapseSpark_STATUS
func (spark *SynapseSpark_STATUS) AssignProperties_From_SynapseSpark_STATUS(source *storage.SynapseSpark_STATUS) error {

	// ComputeLocation
	spark.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, synapseSpark_ComputeType_STATUS_Values)
		spark.ComputeType = &computeTypeTemp
	} else {
		spark.ComputeType = nil
	}

	// CreatedOn
	spark.CreatedOn = genruntime.ClonePointerToString(source.CreatedOn)

	// Description
	spark.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		spark.DisableLocalAuth = &disableLocalAuth
	} else {
		spark.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if source.IsAttachedCompute != nil {
		isAttachedCompute := *source.IsAttachedCompute
		spark.IsAttachedCompute = &isAttachedCompute
	} else {
		spark.IsAttachedCompute = nil
	}

	// ModifiedOn
	spark.ModifiedOn = genruntime.ClonePointerToString(source.ModifiedOn)

	// Properties
	if source.Properties != nil {
		var property SynapseSpark_Properties_STATUS
		err := property.AssignProperties_From_SynapseSpark_Properties_STATUS(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SynapseSpark_Properties_STATUS() to populate field Properties")
		}
		spark.Properties = &property
	} else {
		spark.Properties = nil
	}

	// ProvisioningErrors
	if source.ProvisioningErrors != nil {
		provisioningErrorList := make([]ErrorResponse_STATUS, len(source.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range source.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError ErrorResponse_STATUS
			err := provisioningError.AssignProperties_From_ErrorResponse_STATUS(&provisioningErrorItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		spark.ProvisioningErrors = provisioningErrorList
	} else {
		spark.ProvisioningErrors = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, synapseSpark_ProvisioningState_STATUS_Values)
		spark.ProvisioningState = &provisioningStateTemp
	} else {
		spark.ProvisioningState = nil
	}

	// ResourceId
	spark.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// No error
	return nil
}

// AssignProperties_To_SynapseSpark_STATUS populates the provided destination SynapseSpark_STATUS from our SynapseSpark_STATUS
func (spark *SynapseSpark_STATUS) AssignProperties_To_SynapseSpark_STATUS(destination *storage.SynapseSpark_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(spark.ComputeLocation)

	// ComputeType
	if spark.ComputeType != nil {
		computeType := string(*spark.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// CreatedOn
	destination.CreatedOn = genruntime.ClonePointerToString(spark.CreatedOn)

	// Description
	destination.Description = genruntime.ClonePointerToString(spark.Description)

	// DisableLocalAuth
	if spark.DisableLocalAuth != nil {
		disableLocalAuth := *spark.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if spark.IsAttachedCompute != nil {
		isAttachedCompute := *spark.IsAttachedCompute
		destination.IsAttachedCompute = &isAttachedCompute
	} else {
		destination.IsAttachedCompute = nil
	}

	// ModifiedOn
	destination.ModifiedOn = genruntime.ClonePointerToString(spark.ModifiedOn)

	// Properties
	if spark.Properties != nil {
		var property storage.SynapseSpark_Properties_STATUS
		err := spark.Properties.AssignProperties_To_SynapseSpark_Properties_STATUS(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SynapseSpark_Properties_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ProvisioningErrors
	if spark.ProvisioningErrors != nil {
		provisioningErrorList := make([]storage.ErrorResponse_STATUS, len(spark.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range spark.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError storage.ErrorResponse_STATUS
			err := provisioningErrorItem.AssignProperties_To_ErrorResponse_STATUS(&provisioningError)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		destination.ProvisioningErrors = provisioningErrorList
	} else {
		destination.ProvisioningErrors = nil
	}

	// ProvisioningState
	if spark.ProvisioningState != nil {
		provisioningState := string(*spark.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(spark.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachine struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// +kubebuilder:validation:Required
	// ComputeType: The type of compute
	ComputeType *VirtualMachine_ComputeType `json:"computeType,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool                      `json:"disableLocalAuth,omitempty"`
	Properties       *VirtualMachine_Properties `json:"properties,omitempty"`

	// ResourceReference: ARM resource id of the underlying compute
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachine{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (machine *VirtualMachine) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if machine == nil {
		return nil, nil
	}
	result := &arm.VirtualMachine{}

	// Set property "ComputeLocation":
	if machine.ComputeLocation != nil {
		computeLocation := *machine.ComputeLocation
		result.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	if machine.ComputeType != nil {
		var temp arm.VirtualMachine_ComputeType
		var temp1 string
		temp1 = string(*machine.ComputeType)
		temp = arm.VirtualMachine_ComputeType(temp1)
		result.ComputeType = temp
	}

	// Set property "Description":
	if machine.Description != nil {
		description := *machine.Description
		result.Description = &description
	}

	// Set property "DisableLocalAuth":
	if machine.DisableLocalAuth != nil {
		disableLocalAuth := *machine.DisableLocalAuth
		result.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if machine.Properties != nil {
		properties_ARM, err := (*machine.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*arm.VirtualMachine_Properties)
		result.Properties = &properties
	}

	// Set property "ResourceId":
	if machine.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*machine.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (machine *VirtualMachine) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachine{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (machine *VirtualMachine) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachine)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachine, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		machine.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp VirtualMachine_ComputeType
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = VirtualMachine_ComputeType(temp1)
	machine.ComputeType = &temp

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		machine.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		machine.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 VirtualMachine_Properties
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		machine.Properties = &properties
	}

	// no assignment for property "ResourceReference"

	// No error
	return nil
}

// AssignProperties_From_VirtualMachine populates our VirtualMachine from the provided source VirtualMachine
func (machine *VirtualMachine) AssignProperties_From_VirtualMachine(source *storage.VirtualMachine) error {

	// ComputeLocation
	machine.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, virtualMachine_ComputeType_Values)
		machine.ComputeType = &computeTypeTemp
	} else {
		machine.ComputeType = nil
	}

	// Description
	machine.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		machine.DisableLocalAuth = &disableLocalAuth
	} else {
		machine.DisableLocalAuth = nil
	}

	// Properties
	if source.Properties != nil {
		var property VirtualMachine_Properties
		err := property.AssignProperties_From_VirtualMachine_Properties(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachine_Properties() to populate field Properties")
		}
		machine.Properties = &property
	} else {
		machine.Properties = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		machine.ResourceReference = &resourceReference
	} else {
		machine.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachine populates the provided destination VirtualMachine from our VirtualMachine
func (machine *VirtualMachine) AssignProperties_To_VirtualMachine(destination *storage.VirtualMachine) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(machine.ComputeLocation)

	// ComputeType
	if machine.ComputeType != nil {
		computeType := string(*machine.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(machine.Description)

	// DisableLocalAuth
	if machine.DisableLocalAuth != nil {
		disableLocalAuth := *machine.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// Properties
	if machine.Properties != nil {
		var property storage.VirtualMachine_Properties
		err := machine.Properties.AssignProperties_To_VirtualMachine_Properties(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachine_Properties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ResourceReference
	if machine.ResourceReference != nil {
		resourceReference := machine.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachine_STATUS struct {
	// ComputeLocation: Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`

	// ComputeType: The type of compute
	ComputeType *VirtualMachine_ComputeType_STATUS `json:"computeType,omitempty"`

	// CreatedOn: The time at which the compute was created.
	CreatedOn *string `json:"createdOn,omitempty"`

	// Description: The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`

	// DisableLocalAuth: Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for
	// authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// IsAttachedCompute: Indicating whether the compute was provisioned by user and brought from outside if true, or machine
	// learning service provisioned it if false.
	IsAttachedCompute *bool `json:"isAttachedCompute,omitempty"`

	// ModifiedOn: The time at which the compute was last modified.
	ModifiedOn *string                           `json:"modifiedOn,omitempty"`
	Properties *VirtualMachine_Properties_STATUS `json:"properties,omitempty"`

	// ProvisioningErrors: Errors during provisioning
	ProvisioningErrors []ErrorResponse_STATUS `json:"provisioningErrors,omitempty"`

	// ProvisioningState: The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and
	// Failed.
	ProvisioningState *VirtualMachine_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// ResourceId: ARM resource id of the underlying compute
	ResourceId *string `json:"resourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachine_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (machine *VirtualMachine_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachine_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (machine *VirtualMachine_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachine_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachine_STATUS, got %T", armInput)
	}

	// Set property "ComputeLocation":
	if typedInput.ComputeLocation != nil {
		computeLocation := *typedInput.ComputeLocation
		machine.ComputeLocation = &computeLocation
	}

	// Set property "ComputeType":
	var temp VirtualMachine_ComputeType_STATUS
	var temp1 string
	temp1 = string(typedInput.ComputeType)
	temp = VirtualMachine_ComputeType_STATUS(temp1)
	machine.ComputeType = &temp

	// Set property "CreatedOn":
	if typedInput.CreatedOn != nil {
		createdOn := *typedInput.CreatedOn
		machine.CreatedOn = &createdOn
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		machine.Description = &description
	}

	// Set property "DisableLocalAuth":
	if typedInput.DisableLocalAuth != nil {
		disableLocalAuth := *typedInput.DisableLocalAuth
		machine.DisableLocalAuth = &disableLocalAuth
	}

	// Set property "IsAttachedCompute":
	if typedInput.IsAttachedCompute != nil {
		isAttachedCompute := *typedInput.IsAttachedCompute
		machine.IsAttachedCompute = &isAttachedCompute
	}

	// Set property "ModifiedOn":
	if typedInput.ModifiedOn != nil {
		modifiedOn := *typedInput.ModifiedOn
		machine.ModifiedOn = &modifiedOn
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 VirtualMachine_Properties_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		machine.Properties = &properties
	}

	// Set property "ProvisioningErrors":
	for _, item := range typedInput.ProvisioningErrors {
		var item1 ErrorResponse_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		machine.ProvisioningErrors = append(machine.ProvisioningErrors, item1)
	}

	// Set property "ProvisioningState":
	if typedInput.ProvisioningState != nil {
		var provisioningStateTemp string
		provisioningStateTemp = string(*typedInput.ProvisioningState)
		provisioningState := VirtualMachine_ProvisioningState_STATUS(provisioningStateTemp)
		machine.ProvisioningState = &provisioningState
	}

	// Set property "ResourceId":
	if typedInput.ResourceId != nil {
		resourceId := *typedInput.ResourceId
		machine.ResourceId = &resourceId
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachine_STATUS populates our VirtualMachine_STATUS from the provided source VirtualMachine_STATUS
func (machine *VirtualMachine_STATUS) AssignProperties_From_VirtualMachine_STATUS(source *storage.VirtualMachine_STATUS) error {

	// ComputeLocation
	machine.ComputeLocation = genruntime.ClonePointerToString(source.ComputeLocation)

	// ComputeType
	if source.ComputeType != nil {
		computeType := *source.ComputeType
		computeTypeTemp := genruntime.ToEnum(computeType, virtualMachine_ComputeType_STATUS_Values)
		machine.ComputeType = &computeTypeTemp
	} else {
		machine.ComputeType = nil
	}

	// CreatedOn
	machine.CreatedOn = genruntime.ClonePointerToString(source.CreatedOn)

	// Description
	machine.Description = genruntime.ClonePointerToString(source.Description)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		machine.DisableLocalAuth = &disableLocalAuth
	} else {
		machine.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if source.IsAttachedCompute != nil {
		isAttachedCompute := *source.IsAttachedCompute
		machine.IsAttachedCompute = &isAttachedCompute
	} else {
		machine.IsAttachedCompute = nil
	}

	// ModifiedOn
	machine.ModifiedOn = genruntime.ClonePointerToString(source.ModifiedOn)

	// Properties
	if source.Properties != nil {
		var property VirtualMachine_Properties_STATUS
		err := property.AssignProperties_From_VirtualMachine_Properties_STATUS(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachine_Properties_STATUS() to populate field Properties")
		}
		machine.Properties = &property
	} else {
		machine.Properties = nil
	}

	// ProvisioningErrors
	if source.ProvisioningErrors != nil {
		provisioningErrorList := make([]ErrorResponse_STATUS, len(source.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range source.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError ErrorResponse_STATUS
			err := provisioningError.AssignProperties_From_ErrorResponse_STATUS(&provisioningErrorItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		machine.ProvisioningErrors = provisioningErrorList
	} else {
		machine.ProvisioningErrors = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, virtualMachine_ProvisioningState_STATUS_Values)
		machine.ProvisioningState = &provisioningStateTemp
	} else {
		machine.ProvisioningState = nil
	}

	// ResourceId
	machine.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachine_STATUS populates the provided destination VirtualMachine_STATUS from our VirtualMachine_STATUS
func (machine *VirtualMachine_STATUS) AssignProperties_To_VirtualMachine_STATUS(destination *storage.VirtualMachine_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeLocation
	destination.ComputeLocation = genruntime.ClonePointerToString(machine.ComputeLocation)

	// ComputeType
	if machine.ComputeType != nil {
		computeType := string(*machine.ComputeType)
		destination.ComputeType = &computeType
	} else {
		destination.ComputeType = nil
	}

	// CreatedOn
	destination.CreatedOn = genruntime.ClonePointerToString(machine.CreatedOn)

	// Description
	destination.Description = genruntime.ClonePointerToString(machine.Description)

	// DisableLocalAuth
	if machine.DisableLocalAuth != nil {
		disableLocalAuth := *machine.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// IsAttachedCompute
	if machine.IsAttachedCompute != nil {
		isAttachedCompute := *machine.IsAttachedCompute
		destination.IsAttachedCompute = &isAttachedCompute
	} else {
		destination.IsAttachedCompute = nil
	}

	// ModifiedOn
	destination.ModifiedOn = genruntime.ClonePointerToString(machine.ModifiedOn)

	// Properties
	if machine.Properties != nil {
		var property storage.VirtualMachine_Properties_STATUS
		err := machine.Properties.AssignProperties_To_VirtualMachine_Properties_STATUS(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachine_Properties_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// ProvisioningErrors
	if machine.ProvisioningErrors != nil {
		provisioningErrorList := make([]storage.ErrorResponse_STATUS, len(machine.ProvisioningErrors))
		for provisioningErrorIndex, provisioningErrorItem := range machine.ProvisioningErrors {
			// Shadow the loop variable to avoid aliasing
			provisioningErrorItem := provisioningErrorItem
			var provisioningError storage.ErrorResponse_STATUS
			err := provisioningErrorItem.AssignProperties_To_ErrorResponse_STATUS(&provisioningError)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ErrorResponse_STATUS() to populate field ProvisioningErrors")
			}
			provisioningErrorList[provisioningErrorIndex] = provisioningError
		}
		destination.ProvisioningErrors = provisioningErrorList
	} else {
		destination.ProvisioningErrors = nil
	}

	// ProvisioningState
	if machine.ProvisioningState != nil {
		provisioningState := string(*machine.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(machine.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"AKS"}
type AKS_ComputeType string

const AKS_ComputeType_AKS = AKS_ComputeType("AKS")

// Mapping from string to AKS_ComputeType
var aKS_ComputeType_Values = map[string]AKS_ComputeType{
	"aks": AKS_ComputeType_AKS,
}

type AKS_ComputeType_STATUS string

const AKS_ComputeType_STATUS_AKS = AKS_ComputeType_STATUS("AKS")

// Mapping from string to AKS_ComputeType_STATUS
var aKS_ComputeType_STATUS_Values = map[string]AKS_ComputeType_STATUS{
	"aks": AKS_ComputeType_STATUS_AKS,
}

type AKS_Properties struct {
	// +kubebuilder:validation:Minimum=0
	// AgentCount: Number of agents
	AgentCount *int `json:"agentCount,omitempty"`

	// AgentVmSize: Agent virtual machine size
	AgentVmSize *string `json:"agentVmSize,omitempty"`

	// AksNetworkingConfiguration: AKS networking configuration for vnet
	AksNetworkingConfiguration *AksNetworkingConfiguration `json:"aksNetworkingConfiguration,omitempty"`

	// ClusterFqdn: Cluster full qualified domain name
	ClusterFqdn *string `json:"clusterFqdn,omitempty"`

	// ClusterPurpose: Intended usage of the cluster
	ClusterPurpose *AKS_Properties_ClusterPurpose `json:"clusterPurpose,omitempty"`

	// LoadBalancerSubnet: Load Balancer Subnet
	LoadBalancerSubnet *string `json:"loadBalancerSubnet,omitempty"`

	// LoadBalancerType: Load Balancer Type
	LoadBalancerType *AKS_Properties_LoadBalancerType `json:"loadBalancerType,omitempty"`

	// SslConfiguration: SSL configuration
	SslConfiguration *SslConfiguration `json:"sslConfiguration,omitempty"`
}

var _ genruntime.ARMTransformer = &AKS_Properties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *AKS_Properties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.AKS_Properties{}

	// Set property "AgentCount":
	if properties.AgentCount != nil {
		agentCount := *properties.AgentCount
		result.AgentCount = &agentCount
	}

	// Set property "AgentVmSize":
	if properties.AgentVmSize != nil {
		agentVmSize := *properties.AgentVmSize
		result.AgentVmSize = &agentVmSize
	}

	// Set property "AksNetworkingConfiguration":
	if properties.AksNetworkingConfiguration != nil {
		aksNetworkingConfiguration_ARM, err := (*properties.AksNetworkingConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		aksNetworkingConfiguration := *aksNetworkingConfiguration_ARM.(*arm.AksNetworkingConfiguration)
		result.AksNetworkingConfiguration = &aksNetworkingConfiguration
	}

	// Set property "ClusterFqdn":
	if properties.ClusterFqdn != nil {
		clusterFqdn := *properties.ClusterFqdn
		result.ClusterFqdn = &clusterFqdn
	}

	// Set property "ClusterPurpose":
	if properties.ClusterPurpose != nil {
		var temp string
		temp = string(*properties.ClusterPurpose)
		clusterPurpose := arm.AKS_Properties_ClusterPurpose(temp)
		result.ClusterPurpose = &clusterPurpose
	}

	// Set property "LoadBalancerSubnet":
	if properties.LoadBalancerSubnet != nil {
		loadBalancerSubnet := *properties.LoadBalancerSubnet
		result.LoadBalancerSubnet = &loadBalancerSubnet
	}

	// Set property "LoadBalancerType":
	if properties.LoadBalancerType != nil {
		var temp string
		temp = string(*properties.LoadBalancerType)
		loadBalancerType := arm.AKS_Properties_LoadBalancerType(temp)
		result.LoadBalancerType = &loadBalancerType
	}

	// Set property "SslConfiguration":
	if properties.SslConfiguration != nil {
		sslConfiguration_ARM, err := (*properties.SslConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sslConfiguration := *sslConfiguration_ARM.(*arm.SslConfiguration)
		result.SslConfiguration = &sslConfiguration
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *AKS_Properties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AKS_Properties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *AKS_Properties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AKS_Properties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AKS_Properties, got %T", armInput)
	}

	// Set property "AgentCount":
	if typedInput.AgentCount != nil {
		agentCount := *typedInput.AgentCount
		properties.AgentCount = &agentCount
	}

	// Set property "AgentVmSize":
	if typedInput.AgentVmSize != nil {
		agentVmSize := *typedInput.AgentVmSize
		properties.AgentVmSize = &agentVmSize
	}

	// Set property "AksNetworkingConfiguration":
	if typedInput.AksNetworkingConfiguration != nil {
		var aksNetworkingConfiguration1 AksNetworkingConfiguration
		err := aksNetworkingConfiguration1.PopulateFromARM(owner, *typedInput.AksNetworkingConfiguration)
		if err != nil {
			return err
		}
		aksNetworkingConfiguration := aksNetworkingConfiguration1
		properties.AksNetworkingConfiguration = &aksNetworkingConfiguration
	}

	// Set property "ClusterFqdn":
	if typedInput.ClusterFqdn != nil {
		clusterFqdn := *typedInput.ClusterFqdn
		properties.ClusterFqdn = &clusterFqdn
	}

	// Set property "ClusterPurpose":
	if typedInput.ClusterPurpose != nil {
		var temp string
		temp = string(*typedInput.ClusterPurpose)
		clusterPurpose := AKS_Properties_ClusterPurpose(temp)
		properties.ClusterPurpose = &clusterPurpose
	}

	// Set property "LoadBalancerSubnet":
	if typedInput.LoadBalancerSubnet != nil {
		loadBalancerSubnet := *typedInput.LoadBalancerSubnet
		properties.LoadBalancerSubnet = &loadBalancerSubnet
	}

	// Set property "LoadBalancerType":
	if typedInput.LoadBalancerType != nil {
		var temp string
		temp = string(*typedInput.LoadBalancerType)
		loadBalancerType := AKS_Properties_LoadBalancerType(temp)
		properties.LoadBalancerType = &loadBalancerType
	}

	// Set property "SslConfiguration":
	if typedInput.SslConfiguration != nil {
		var sslConfiguration1 SslConfiguration
		err := sslConfiguration1.PopulateFromARM(owner, *typedInput.SslConfiguration)
		if err != nil {
			return err
		}
		sslConfiguration := sslConfiguration1
		properties.SslConfiguration = &sslConfiguration
	}

	// No error
	return nil
}

// AssignProperties_From_AKS_Properties populates our AKS_Properties from the provided source AKS_Properties
func (properties *AKS_Properties) AssignProperties_From_AKS_Properties(source *storage.AKS_Properties) error {

	// AgentCount
	properties.AgentCount = genruntime.ClonePointerToInt(source.AgentCount)

	// AgentVmSize
	properties.AgentVmSize = genruntime.ClonePointerToString(source.AgentVmSize)

	// AksNetworkingConfiguration
	if source.AksNetworkingConfiguration != nil {
		var aksNetworkingConfiguration AksNetworkingConfiguration
		err := aksNetworkingConfiguration.AssignProperties_From_AksNetworkingConfiguration(source.AksNetworkingConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AksNetworkingConfiguration() to populate field AksNetworkingConfiguration")
		}
		properties.AksNetworkingConfiguration = &aksNetworkingConfiguration
	} else {
		properties.AksNetworkingConfiguration = nil
	}

	// ClusterFqdn
	properties.ClusterFqdn = genruntime.ClonePointerToString(source.ClusterFqdn)

	// ClusterPurpose
	if source.ClusterPurpose != nil {
		clusterPurpose := *source.ClusterPurpose
		clusterPurposeTemp := genruntime.ToEnum(clusterPurpose, aKS_Properties_ClusterPurpose_Values)
		properties.ClusterPurpose = &clusterPurposeTemp
	} else {
		properties.ClusterPurpose = nil
	}

	// LoadBalancerSubnet
	properties.LoadBalancerSubnet = genruntime.ClonePointerToString(source.LoadBalancerSubnet)

	// LoadBalancerType
	if source.LoadBalancerType != nil {
		loadBalancerType := *source.LoadBalancerType
		loadBalancerTypeTemp := genruntime.ToEnum(loadBalancerType, aKS_Properties_LoadBalancerType_Values)
		properties.LoadBalancerType = &loadBalancerTypeTemp
	} else {
		properties.LoadBalancerType = nil
	}

	// SslConfiguration
	if source.SslConfiguration != nil {
		var sslConfiguration SslConfiguration
		err := sslConfiguration.AssignProperties_From_SslConfiguration(source.SslConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SslConfiguration() to populate field SslConfiguration")
		}
		properties.SslConfiguration = &sslConfiguration
	} else {
		properties.SslConfiguration = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AKS_Properties populates the provided destination AKS_Properties from our AKS_Properties
func (properties *AKS_Properties) AssignProperties_To_AKS_Properties(destination *storage.AKS_Properties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AgentCount
	destination.AgentCount = genruntime.ClonePointerToInt(properties.AgentCount)

	// AgentVmSize
	destination.AgentVmSize = genruntime.ClonePointerToString(properties.AgentVmSize)

	// AksNetworkingConfiguration
	if properties.AksNetworkingConfiguration != nil {
		var aksNetworkingConfiguration storage.AksNetworkingConfiguration
		err := properties.AksNetworkingConfiguration.AssignProperties_To_AksNetworkingConfiguration(&aksNetworkingConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AksNetworkingConfiguration() to populate field AksNetworkingConfiguration")
		}
		destination.AksNetworkingConfiguration = &aksNetworkingConfiguration
	} else {
		destination.AksNetworkingConfiguration = nil
	}

	// ClusterFqdn
	destination.ClusterFqdn = genruntime.ClonePointerToString(properties.ClusterFqdn)

	// ClusterPurpose
	if properties.ClusterPurpose != nil {
		clusterPurpose := string(*properties.ClusterPurpose)
		destination.ClusterPurpose = &clusterPurpose
	} else {
		destination.ClusterPurpose = nil
	}

	// LoadBalancerSubnet
	destination.LoadBalancerSubnet = genruntime.ClonePointerToString(properties.LoadBalancerSubnet)

	// LoadBalancerType
	if properties.LoadBalancerType != nil {
		loadBalancerType := string(*properties.LoadBalancerType)
		destination.LoadBalancerType = &loadBalancerType
	} else {
		destination.LoadBalancerType = nil
	}

	// SslConfiguration
	if properties.SslConfiguration != nil {
		var sslConfiguration storage.SslConfiguration
		err := properties.SslConfiguration.AssignProperties_To_SslConfiguration(&sslConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SslConfiguration() to populate field SslConfiguration")
		}
		destination.SslConfiguration = &sslConfiguration
	} else {
		destination.SslConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AKS_Properties_STATUS struct {
	// AgentCount: Number of agents
	AgentCount *int `json:"agentCount,omitempty"`

	// AgentVmSize: Agent virtual machine size
	AgentVmSize *string `json:"agentVmSize,omitempty"`

	// AksNetworkingConfiguration: AKS networking configuration for vnet
	AksNetworkingConfiguration *AksNetworkingConfiguration_STATUS `json:"aksNetworkingConfiguration,omitempty"`

	// ClusterFqdn: Cluster full qualified domain name
	ClusterFqdn *string `json:"clusterFqdn,omitempty"`

	// ClusterPurpose: Intended usage of the cluster
	ClusterPurpose *AKS_Properties_ClusterPurpose_STATUS `json:"clusterPurpose,omitempty"`

	// LoadBalancerSubnet: Load Balancer Subnet
	LoadBalancerSubnet *string `json:"loadBalancerSubnet,omitempty"`

	// LoadBalancerType: Load Balancer Type
	LoadBalancerType *AKS_Properties_LoadBalancerType_STATUS `json:"loadBalancerType,omitempty"`

	// SslConfiguration: SSL configuration
	SslConfiguration *SslConfiguration_STATUS `json:"sslConfiguration,omitempty"`

	// SystemServices: System services
	SystemServices []SystemService_STATUS `json:"systemServices,omitempty"`
}

var _ genruntime.FromARMConverter = &AKS_Properties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *AKS_Properties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AKS_Properties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *AKS_Properties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AKS_Properties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AKS_Properties_STATUS, got %T", armInput)
	}

	// Set property "AgentCount":
	if typedInput.AgentCount != nil {
		agentCount := *typedInput.AgentCount
		properties.AgentCount = &agentCount
	}

	// Set property "AgentVmSize":
	if typedInput.AgentVmSize != nil {
		agentVmSize := *typedInput.AgentVmSize
		properties.AgentVmSize = &agentVmSize
	}

	// Set property "AksNetworkingConfiguration":
	if typedInput.AksNetworkingConfiguration != nil {
		var aksNetworkingConfiguration1 AksNetworkingConfiguration_STATUS
		err := aksNetworkingConfiguration1.PopulateFromARM(owner, *typedInput.AksNetworkingConfiguration)
		if err != nil {
			return err
		}
		aksNetworkingConfiguration := aksNetworkingConfiguration1
		properties.AksNetworkingConfiguration = &aksNetworkingConfiguration
	}

	// Set property "ClusterFqdn":
	if typedInput.ClusterFqdn != nil {
		clusterFqdn := *typedInput.ClusterFqdn
		properties.ClusterFqdn = &clusterFqdn
	}

	// Set property "ClusterPurpose":
	if typedInput.ClusterPurpose != nil {
		var temp string
		temp = string(*typedInput.ClusterPurpose)
		clusterPurpose := AKS_Properties_ClusterPurpose_STATUS(temp)
		properties.ClusterPurpose = &clusterPurpose
	}

	// Set property "LoadBalancerSubnet":
	if typedInput.LoadBalancerSubnet != nil {
		loadBalancerSubnet := *typedInput.LoadBalancerSubnet
		properties.LoadBalancerSubnet = &loadBalancerSubnet
	}

	// Set property "LoadBalancerType":
	if typedInput.LoadBalancerType != nil {
		var temp string
		temp = string(*typedInput.LoadBalancerType)
		loadBalancerType := AKS_Properties_LoadBalancerType_STATUS(temp)
		properties.LoadBalancerType = &loadBalancerType
	}

	// Set property "SslConfiguration":
	if typedInput.SslConfiguration != nil {
		var sslConfiguration1 SslConfiguration_STATUS
		err := sslConfiguration1.PopulateFromARM(owner, *typedInput.SslConfiguration)
		if err != nil {
			return err
		}
		sslConfiguration := sslConfiguration1
		properties.SslConfiguration = &sslConfiguration
	}

	// Set property "SystemServices":
	for _, item := range typedInput.SystemServices {
		var item1 SystemService_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.SystemServices = append(properties.SystemServices, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_AKS_Properties_STATUS populates our AKS_Properties_STATUS from the provided source AKS_Properties_STATUS
func (properties *AKS_Properties_STATUS) AssignProperties_From_AKS_Properties_STATUS(source *storage.AKS_Properties_STATUS) error {

	// AgentCount
	properties.AgentCount = genruntime.ClonePointerToInt(source.AgentCount)

	// AgentVmSize
	properties.AgentVmSize = genruntime.ClonePointerToString(source.AgentVmSize)

	// AksNetworkingConfiguration
	if source.AksNetworkingConfiguration != nil {
		var aksNetworkingConfiguration AksNetworkingConfiguration_STATUS
		err := aksNetworkingConfiguration.AssignProperties_From_AksNetworkingConfiguration_STATUS(source.AksNetworkingConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AksNetworkingConfiguration_STATUS() to populate field AksNetworkingConfiguration")
		}
		properties.AksNetworkingConfiguration = &aksNetworkingConfiguration
	} else {
		properties.AksNetworkingConfiguration = nil
	}

	// ClusterFqdn
	properties.ClusterFqdn = genruntime.ClonePointerToString(source.ClusterFqdn)

	// ClusterPurpose
	if source.ClusterPurpose != nil {
		clusterPurpose := *source.ClusterPurpose
		clusterPurposeTemp := genruntime.ToEnum(clusterPurpose, aKS_Properties_ClusterPurpose_STATUS_Values)
		properties.ClusterPurpose = &clusterPurposeTemp
	} else {
		properties.ClusterPurpose = nil
	}

	// LoadBalancerSubnet
	properties.LoadBalancerSubnet = genruntime.ClonePointerToString(source.LoadBalancerSubnet)

	// LoadBalancerType
	if source.LoadBalancerType != nil {
		loadBalancerType := *source.LoadBalancerType
		loadBalancerTypeTemp := genruntime.ToEnum(loadBalancerType, aKS_Properties_LoadBalancerType_STATUS_Values)
		properties.LoadBalancerType = &loadBalancerTypeTemp
	} else {
		properties.LoadBalancerType = nil
	}

	// SslConfiguration
	if source.SslConfiguration != nil {
		var sslConfiguration SslConfiguration_STATUS
		err := sslConfiguration.AssignProperties_From_SslConfiguration_STATUS(source.SslConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SslConfiguration_STATUS() to populate field SslConfiguration")
		}
		properties.SslConfiguration = &sslConfiguration
	} else {
		properties.SslConfiguration = nil
	}

	// SystemServices
	if source.SystemServices != nil {
		systemServiceList := make([]SystemService_STATUS, len(source.SystemServices))
		for systemServiceIndex, systemServiceItem := range source.SystemServices {
			// Shadow the loop variable to avoid aliasing
			systemServiceItem := systemServiceItem
			var systemService SystemService_STATUS
			err := systemService.AssignProperties_From_SystemService_STATUS(&systemServiceItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_SystemService_STATUS() to populate field SystemServices")
			}
			systemServiceList[systemServiceIndex] = systemService
		}
		properties.SystemServices = systemServiceList
	} else {
		properties.SystemServices = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AKS_Properties_STATUS populates the provided destination AKS_Properties_STATUS from our AKS_Properties_STATUS
func (properties *AKS_Properties_STATUS) AssignProperties_To_AKS_Properties_STATUS(destination *storage.AKS_Properties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AgentCount
	destination.AgentCount = genruntime.ClonePointerToInt(properties.AgentCount)

	// AgentVmSize
	destination.AgentVmSize = genruntime.ClonePointerToString(properties.AgentVmSize)

	// AksNetworkingConfiguration
	if properties.AksNetworkingConfiguration != nil {
		var aksNetworkingConfiguration storage.AksNetworkingConfiguration_STATUS
		err := properties.AksNetworkingConfiguration.AssignProperties_To_AksNetworkingConfiguration_STATUS(&aksNetworkingConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AksNetworkingConfiguration_STATUS() to populate field AksNetworkingConfiguration")
		}
		destination.AksNetworkingConfiguration = &aksNetworkingConfiguration
	} else {
		destination.AksNetworkingConfiguration = nil
	}

	// ClusterFqdn
	destination.ClusterFqdn = genruntime.ClonePointerToString(properties.ClusterFqdn)

	// ClusterPurpose
	if properties.ClusterPurpose != nil {
		clusterPurpose := string(*properties.ClusterPurpose)
		destination.ClusterPurpose = &clusterPurpose
	} else {
		destination.ClusterPurpose = nil
	}

	// LoadBalancerSubnet
	destination.LoadBalancerSubnet = genruntime.ClonePointerToString(properties.LoadBalancerSubnet)

	// LoadBalancerType
	if properties.LoadBalancerType != nil {
		loadBalancerType := string(*properties.LoadBalancerType)
		destination.LoadBalancerType = &loadBalancerType
	} else {
		destination.LoadBalancerType = nil
	}

	// SslConfiguration
	if properties.SslConfiguration != nil {
		var sslConfiguration storage.SslConfiguration_STATUS
		err := properties.SslConfiguration.AssignProperties_To_SslConfiguration_STATUS(&sslConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SslConfiguration_STATUS() to populate field SslConfiguration")
		}
		destination.SslConfiguration = &sslConfiguration
	} else {
		destination.SslConfiguration = nil
	}

	// SystemServices
	if properties.SystemServices != nil {
		systemServiceList := make([]storage.SystemService_STATUS, len(properties.SystemServices))
		for systemServiceIndex, systemServiceItem := range properties.SystemServices {
			// Shadow the loop variable to avoid aliasing
			systemServiceItem := systemServiceItem
			var systemService storage.SystemService_STATUS
			err := systemServiceItem.AssignProperties_To_SystemService_STATUS(&systemService)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_SystemService_STATUS() to populate field SystemServices")
			}
			systemServiceList[systemServiceIndex] = systemService
		}
		destination.SystemServices = systemServiceList
	} else {
		destination.SystemServices = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AKS_ProvisioningState_STATUS string

const (
	AKS_ProvisioningState_STATUS_Canceled  = AKS_ProvisioningState_STATUS("Canceled")
	AKS_ProvisioningState_STATUS_Creating  = AKS_ProvisioningState_STATUS("Creating")
	AKS_ProvisioningState_STATUS_Deleting  = AKS_ProvisioningState_STATUS("Deleting")
	AKS_ProvisioningState_STATUS_Failed    = AKS_ProvisioningState_STATUS("Failed")
	AKS_ProvisioningState_STATUS_Succeeded = AKS_ProvisioningState_STATUS("Succeeded")
	AKS_ProvisioningState_STATUS_Unknown   = AKS_ProvisioningState_STATUS("Unknown")
	AKS_ProvisioningState_STATUS_Updating  = AKS_ProvisioningState_STATUS("Updating")
)

// Mapping from string to AKS_ProvisioningState_STATUS
var aKS_ProvisioningState_STATUS_Values = map[string]AKS_ProvisioningState_STATUS{
	"canceled":  AKS_ProvisioningState_STATUS_Canceled,
	"creating":  AKS_ProvisioningState_STATUS_Creating,
	"deleting":  AKS_ProvisioningState_STATUS_Deleting,
	"failed":    AKS_ProvisioningState_STATUS_Failed,
	"succeeded": AKS_ProvisioningState_STATUS_Succeeded,
	"unknown":   AKS_ProvisioningState_STATUS_Unknown,
	"updating":  AKS_ProvisioningState_STATUS_Updating,
}

// +kubebuilder:validation:Enum={"AmlCompute"}
type AmlCompute_ComputeType string

const AmlCompute_ComputeType_AmlCompute = AmlCompute_ComputeType("AmlCompute")

// Mapping from string to AmlCompute_ComputeType
var amlCompute_ComputeType_Values = map[string]AmlCompute_ComputeType{
	"amlcompute": AmlCompute_ComputeType_AmlCompute,
}

type AmlCompute_ComputeType_STATUS string

const AmlCompute_ComputeType_STATUS_AmlCompute = AmlCompute_ComputeType_STATUS("AmlCompute")

// Mapping from string to AmlCompute_ComputeType_STATUS
var amlCompute_ComputeType_STATUS_Values = map[string]AmlCompute_ComputeType_STATUS{
	"amlcompute": AmlCompute_ComputeType_STATUS_AmlCompute,
}

type AmlCompute_ProvisioningState_STATUS string

const (
	AmlCompute_ProvisioningState_STATUS_Canceled  = AmlCompute_ProvisioningState_STATUS("Canceled")
	AmlCompute_ProvisioningState_STATUS_Creating  = AmlCompute_ProvisioningState_STATUS("Creating")
	AmlCompute_ProvisioningState_STATUS_Deleting  = AmlCompute_ProvisioningState_STATUS("Deleting")
	AmlCompute_ProvisioningState_STATUS_Failed    = AmlCompute_ProvisioningState_STATUS("Failed")
	AmlCompute_ProvisioningState_STATUS_Succeeded = AmlCompute_ProvisioningState_STATUS("Succeeded")
	AmlCompute_ProvisioningState_STATUS_Unknown   = AmlCompute_ProvisioningState_STATUS("Unknown")
	AmlCompute_ProvisioningState_STATUS_Updating  = AmlCompute_ProvisioningState_STATUS("Updating")
)

// Mapping from string to AmlCompute_ProvisioningState_STATUS
var amlCompute_ProvisioningState_STATUS_Values = map[string]AmlCompute_ProvisioningState_STATUS{
	"canceled":  AmlCompute_ProvisioningState_STATUS_Canceled,
	"creating":  AmlCompute_ProvisioningState_STATUS_Creating,
	"deleting":  AmlCompute_ProvisioningState_STATUS_Deleting,
	"failed":    AmlCompute_ProvisioningState_STATUS_Failed,
	"succeeded": AmlCompute_ProvisioningState_STATUS_Succeeded,
	"unknown":   AmlCompute_ProvisioningState_STATUS_Unknown,
	"updating":  AmlCompute_ProvisioningState_STATUS_Updating,
}

// AML Compute properties
type AmlComputeProperties struct {
	// EnableNodePublicIp: Enable or disable node public IP address provisioning. Possible values are: Possible values are:
	// true - Indicates that the compute nodes will have public IPs provisioned. false - Indicates that the compute nodes will
	// have a private endpoint and no public IPs.
	EnableNodePublicIp *bool `json:"enableNodePublicIp,omitempty"`

	// IsolatedNetwork: Network is isolated or not
	IsolatedNetwork *bool `json:"isolatedNetwork,omitempty"`

	// OsType: Compute OS Type
	OsType *AmlComputeProperties_OsType `json:"osType,omitempty"`

	// RemoteLoginPortPublicAccess: State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh
	// port is closed on all nodes of the cluster. Enabled - Indicates that the public ssh port is open on all nodes of the
	// cluster. NotSpecified - Indicates that the public ssh port is closed on all nodes of the cluster if VNet is defined,
	// else is open all public nodes. It can be default only during cluster creation time, after creation it will be either
	// enabled or disabled.
	RemoteLoginPortPublicAccess *AmlComputeProperties_RemoteLoginPortPublicAccess `json:"remoteLoginPortPublicAccess,omitempty"`

	// ScaleSettings: Scale settings for AML Compute
	ScaleSettings *ScaleSettings `json:"scaleSettings,omitempty"`

	// Subnet: Virtual network subnet resource ID the compute nodes belong to.
	Subnet *ResourceId `json:"subnet,omitempty"`

	// UserAccountCredentials: Credentials for an administrator user account that will be created on each compute node.
	UserAccountCredentials *UserAccountCredentials `json:"userAccountCredentials,omitempty"`

	// VirtualMachineImage: Virtual Machine image for AML Compute - windows only
	VirtualMachineImage *VirtualMachineImage `json:"virtualMachineImage,omitempty"`

	// VmPriority: Virtual Machine priority
	VmPriority *AmlComputeProperties_VmPriority `json:"vmPriority,omitempty"`

	// VmSize: Virtual Machine Size
	VmSize *string `json:"vmSize,omitempty"`
}

var _ genruntime.ARMTransformer = &AmlComputeProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *AmlComputeProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.AmlComputeProperties{}

	// Set property "EnableNodePublicIp":
	if properties.EnableNodePublicIp != nil {
		enableNodePublicIp := *properties.EnableNodePublicIp
		result.EnableNodePublicIp = &enableNodePublicIp
	}

	// Set property "IsolatedNetwork":
	if properties.IsolatedNetwork != nil {
		isolatedNetwork := *properties.IsolatedNetwork
		result.IsolatedNetwork = &isolatedNetwork
	}

	// Set property "OsType":
	if properties.OsType != nil {
		var temp string
		temp = string(*properties.OsType)
		osType := arm.AmlComputeProperties_OsType(temp)
		result.OsType = &osType
	}

	// Set property "RemoteLoginPortPublicAccess":
	if properties.RemoteLoginPortPublicAccess != nil {
		var temp string
		temp = string(*properties.RemoteLoginPortPublicAccess)
		remoteLoginPortPublicAccess := arm.AmlComputeProperties_RemoteLoginPortPublicAccess(temp)
		result.RemoteLoginPortPublicAccess = &remoteLoginPortPublicAccess
	}

	// Set property "ScaleSettings":
	if properties.ScaleSettings != nil {
		scaleSettings_ARM, err := (*properties.ScaleSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		scaleSettings := *scaleSettings_ARM.(*arm.ScaleSettings)
		result.ScaleSettings = &scaleSettings
	}

	// Set property "Subnet":
	if properties.Subnet != nil {
		subnet_ARM, err := (*properties.Subnet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		subnet := *subnet_ARM.(*arm.ResourceId)
		result.Subnet = &subnet
	}

	// Set property "UserAccountCredentials":
	if properties.UserAccountCredentials != nil {
		userAccountCredentials_ARM, err := (*properties.UserAccountCredentials).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		userAccountCredentials := *userAccountCredentials_ARM.(*arm.UserAccountCredentials)
		result.UserAccountCredentials = &userAccountCredentials
	}

	// Set property "VirtualMachineImage":
	if properties.VirtualMachineImage != nil {
		virtualMachineImage_ARM, err := (*properties.VirtualMachineImage).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		virtualMachineImage := *virtualMachineImage_ARM.(*arm.VirtualMachineImage)
		result.VirtualMachineImage = &virtualMachineImage
	}

	// Set property "VmPriority":
	if properties.VmPriority != nil {
		var temp string
		temp = string(*properties.VmPriority)
		vmPriority := arm.AmlComputeProperties_VmPriority(temp)
		result.VmPriority = &vmPriority
	}

	// Set property "VmSize":
	if properties.VmSize != nil {
		vmSize := *properties.VmSize
		result.VmSize = &vmSize
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *AmlComputeProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AmlComputeProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *AmlComputeProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AmlComputeProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AmlComputeProperties, got %T", armInput)
	}

	// Set property "EnableNodePublicIp":
	if typedInput.EnableNodePublicIp != nil {
		enableNodePublicIp := *typedInput.EnableNodePublicIp
		properties.EnableNodePublicIp = &enableNodePublicIp
	}

	// Set property "IsolatedNetwork":
	if typedInput.IsolatedNetwork != nil {
		isolatedNetwork := *typedInput.IsolatedNetwork
		properties.IsolatedNetwork = &isolatedNetwork
	}

	// Set property "OsType":
	if typedInput.OsType != nil {
		var temp string
		temp = string(*typedInput.OsType)
		osType := AmlComputeProperties_OsType(temp)
		properties.OsType = &osType
	}

	// Set property "RemoteLoginPortPublicAccess":
	if typedInput.RemoteLoginPortPublicAccess != nil {
		var temp string
		temp = string(*typedInput.RemoteLoginPortPublicAccess)
		remoteLoginPortPublicAccess := AmlComputeProperties_RemoteLoginPortPublicAccess(temp)
		properties.RemoteLoginPortPublicAccess = &remoteLoginPortPublicAccess
	}

	// Set property "ScaleSettings":
	if typedInput.ScaleSettings != nil {
		var scaleSettings1 ScaleSettings
		err := scaleSettings1.PopulateFromARM(owner, *typedInput.ScaleSettings)
		if err != nil {
			return err
		}
		scaleSettings := scaleSettings1
		properties.ScaleSettings = &scaleSettings
	}

	// Set property "Subnet":
	if typedInput.Subnet != nil {
		var subnet1 ResourceId
		err := subnet1.PopulateFromARM(owner, *typedInput.Subnet)
		if err != nil {
			return err
		}
		subnet := subnet1
		properties.Subnet = &subnet
	}

	// Set property "UserAccountCredentials":
	if typedInput.UserAccountCredentials != nil {
		var userAccountCredentials1 UserAccountCredentials
		err := userAccountCredentials1.PopulateFromARM(owner, *typedInput.UserAccountCredentials)
		if err != nil {
			return err
		}
		userAccountCredentials := userAccountCredentials1
		properties.UserAccountCredentials = &userAccountCredentials
	}

	// Set property "VirtualMachineImage":
	if typedInput.VirtualMachineImage != nil {
		var virtualMachineImage1 VirtualMachineImage
		err := virtualMachineImage1.PopulateFromARM(owner, *typedInput.VirtualMachineImage)
		if err != nil {
			return err
		}
		virtualMachineImage := virtualMachineImage1
		properties.VirtualMachineImage = &virtualMachineImage
	}

	// Set property "VmPriority":
	if typedInput.VmPriority != nil {
		var temp string
		temp = string(*typedInput.VmPriority)
		vmPriority := AmlComputeProperties_VmPriority(temp)
		properties.VmPriority = &vmPriority
	}

	// Set property "VmSize":
	if typedInput.VmSize != nil {
		vmSize := *typedInput.VmSize
		properties.VmSize = &vmSize
	}

	// No error
	return nil
}

// AssignProperties_From_AmlComputeProperties populates our AmlComputeProperties from the provided source AmlComputeProperties
func (properties *AmlComputeProperties) AssignProperties_From_AmlComputeProperties(source *storage.AmlComputeProperties) error {

	// EnableNodePublicIp
	if source.EnableNodePublicIp != nil {
		enableNodePublicIp := *source.EnableNodePublicIp
		properties.EnableNodePublicIp = &enableNodePublicIp
	} else {
		properties.EnableNodePublicIp = nil
	}

	// IsolatedNetwork
	if source.IsolatedNetwork != nil {
		isolatedNetwork := *source.IsolatedNetwork
		properties.IsolatedNetwork = &isolatedNetwork
	} else {
		properties.IsolatedNetwork = nil
	}

	// OsType
	if source.OsType != nil {
		osType := *source.OsType
		osTypeTemp := genruntime.ToEnum(osType, amlComputeProperties_OsType_Values)
		properties.OsType = &osTypeTemp
	} else {
		properties.OsType = nil
	}

	// RemoteLoginPortPublicAccess
	if source.RemoteLoginPortPublicAccess != nil {
		remoteLoginPortPublicAccess := *source.RemoteLoginPortPublicAccess
		remoteLoginPortPublicAccessTemp := genruntime.ToEnum(remoteLoginPortPublicAccess, amlComputeProperties_RemoteLoginPortPublicAccess_Values)
		properties.RemoteLoginPortPublicAccess = &remoteLoginPortPublicAccessTemp
	} else {
		properties.RemoteLoginPortPublicAccess = nil
	}

	// ScaleSettings
	if source.ScaleSettings != nil {
		var scaleSetting ScaleSettings
		err := scaleSetting.AssignProperties_From_ScaleSettings(source.ScaleSettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ScaleSettings() to populate field ScaleSettings")
		}
		properties.ScaleSettings = &scaleSetting
	} else {
		properties.ScaleSettings = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet ResourceId
		err := subnet.AssignProperties_From_ResourceId(source.Subnet)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ResourceId() to populate field Subnet")
		}
		properties.Subnet = &subnet
	} else {
		properties.Subnet = nil
	}

	// UserAccountCredentials
	if source.UserAccountCredentials != nil {
		var userAccountCredential UserAccountCredentials
		err := userAccountCredential.AssignProperties_From_UserAccountCredentials(source.UserAccountCredentials)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_UserAccountCredentials() to populate field UserAccountCredentials")
		}
		properties.UserAccountCredentials = &userAccountCredential
	} else {
		properties.UserAccountCredentials = nil
	}

	// VirtualMachineImage
	if source.VirtualMachineImage != nil {
		var virtualMachineImage VirtualMachineImage
		err := virtualMachineImage.AssignProperties_From_VirtualMachineImage(source.VirtualMachineImage)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineImage() to populate field VirtualMachineImage")
		}
		properties.VirtualMachineImage = &virtualMachineImage
	} else {
		properties.VirtualMachineImage = nil
	}

	// VmPriority
	if source.VmPriority != nil {
		vmPriority := *source.VmPriority
		vmPriorityTemp := genruntime.ToEnum(vmPriority, amlComputeProperties_VmPriority_Values)
		properties.VmPriority = &vmPriorityTemp
	} else {
		properties.VmPriority = nil
	}

	// VmSize
	properties.VmSize = genruntime.ClonePointerToString(source.VmSize)

	// No error
	return nil
}

// AssignProperties_To_AmlComputeProperties populates the provided destination AmlComputeProperties from our AmlComputeProperties
func (properties *AmlComputeProperties) AssignProperties_To_AmlComputeProperties(destination *storage.AmlComputeProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EnableNodePublicIp
	if properties.EnableNodePublicIp != nil {
		enableNodePublicIp := *properties.EnableNodePublicIp
		destination.EnableNodePublicIp = &enableNodePublicIp
	} else {
		destination.EnableNodePublicIp = nil
	}

	// IsolatedNetwork
	if properties.IsolatedNetwork != nil {
		isolatedNetwork := *properties.IsolatedNetwork
		destination.IsolatedNetwork = &isolatedNetwork
	} else {
		destination.IsolatedNetwork = nil
	}

	// OsType
	if properties.OsType != nil {
		osType := string(*properties.OsType)
		destination.OsType = &osType
	} else {
		destination.OsType = nil
	}

	// RemoteLoginPortPublicAccess
	if properties.RemoteLoginPortPublicAccess != nil {
		remoteLoginPortPublicAccess := string(*properties.RemoteLoginPortPublicAccess)
		destination.RemoteLoginPortPublicAccess = &remoteLoginPortPublicAccess
	} else {
		destination.RemoteLoginPortPublicAccess = nil
	}

	// ScaleSettings
	if properties.ScaleSettings != nil {
		var scaleSetting storage.ScaleSettings
		err := properties.ScaleSettings.AssignProperties_To_ScaleSettings(&scaleSetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ScaleSettings() to populate field ScaleSettings")
		}
		destination.ScaleSettings = &scaleSetting
	} else {
		destination.ScaleSettings = nil
	}

	// Subnet
	if properties.Subnet != nil {
		var subnet storage.ResourceId
		err := properties.Subnet.AssignProperties_To_ResourceId(&subnet)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ResourceId() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// UserAccountCredentials
	if properties.UserAccountCredentials != nil {
		var userAccountCredential storage.UserAccountCredentials
		err := properties.UserAccountCredentials.AssignProperties_To_UserAccountCredentials(&userAccountCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_UserAccountCredentials() to populate field UserAccountCredentials")
		}
		destination.UserAccountCredentials = &userAccountCredential
	} else {
		destination.UserAccountCredentials = nil
	}

	// VirtualMachineImage
	if properties.VirtualMachineImage != nil {
		var virtualMachineImage storage.VirtualMachineImage
		err := properties.VirtualMachineImage.AssignProperties_To_VirtualMachineImage(&virtualMachineImage)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineImage() to populate field VirtualMachineImage")
		}
		destination.VirtualMachineImage = &virtualMachineImage
	} else {
		destination.VirtualMachineImage = nil
	}

	// VmPriority
	if properties.VmPriority != nil {
		vmPriority := string(*properties.VmPriority)
		destination.VmPriority = &vmPriority
	} else {
		destination.VmPriority = nil
	}

	// VmSize
	destination.VmSize = genruntime.ClonePointerToString(properties.VmSize)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// AML Compute properties
type AmlComputeProperties_STATUS struct {
	// AllocationState: Allocation state of the compute. Possible values are: steady - Indicates that the compute is not
	// resizing. There are no changes to the number of compute nodes in the compute in progress. A compute enters this state
	// when it is created and when no operations are being performed on the compute to change the number of compute nodes.
	// resizing - Indicates that the compute is resizing; that is, compute nodes are being added to or removed from the compute.
	AllocationState *AmlComputeProperties_AllocationState_STATUS `json:"allocationState,omitempty"`

	// AllocationStateTransitionTime: The time at which the compute entered its current allocation state.
	AllocationStateTransitionTime *string `json:"allocationStateTransitionTime,omitempty"`

	// CurrentNodeCount: The number of compute nodes currently assigned to the compute.
	CurrentNodeCount *int `json:"currentNodeCount,omitempty"`

	// EnableNodePublicIp: Enable or disable node public IP address provisioning. Possible values are: Possible values are:
	// true - Indicates that the compute nodes will have public IPs provisioned. false - Indicates that the compute nodes will
	// have a private endpoint and no public IPs.
	EnableNodePublicIp *bool `json:"enableNodePublicIp,omitempty"`

	// Errors: Collection of errors encountered by various compute nodes during node setup.
	Errors []ErrorResponse_STATUS `json:"errors,omitempty"`

	// IsolatedNetwork: Network is isolated or not
	IsolatedNetwork *bool `json:"isolatedNetwork,omitempty"`

	// NodeStateCounts: Counts of various node states on the compute.
	NodeStateCounts *NodeStateCounts_STATUS `json:"nodeStateCounts,omitempty"`

	// OsType: Compute OS Type
	OsType *AmlComputeProperties_OsType_STATUS `json:"osType,omitempty"`

	// RemoteLoginPortPublicAccess: State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh
	// port is closed on all nodes of the cluster. Enabled - Indicates that the public ssh port is open on all nodes of the
	// cluster. NotSpecified - Indicates that the public ssh port is closed on all nodes of the cluster if VNet is defined,
	// else is open all public nodes. It can be default only during cluster creation time, after creation it will be either
	// enabled or disabled.
	RemoteLoginPortPublicAccess *AmlComputeProperties_RemoteLoginPortPublicAccess_STATUS `json:"remoteLoginPortPublicAccess,omitempty"`

	// ScaleSettings: Scale settings for AML Compute
	ScaleSettings *ScaleSettings_STATUS `json:"scaleSettings,omitempty"`

	// Subnet: Virtual network subnet resource ID the compute nodes belong to.
	Subnet *ResourceId_STATUS `json:"subnet,omitempty"`

	// TargetNodeCount: The target number of compute nodes for the compute. If the allocationState is resizing, this property
	// denotes the target node count for the ongoing resize operation. If the allocationState is steady, this property denotes
	// the target node count for the previous resize operation.
	TargetNodeCount *int `json:"targetNodeCount,omitempty"`

	// UserAccountCredentials: Credentials for an administrator user account that will be created on each compute node.
	UserAccountCredentials *UserAccountCredentials_STATUS `json:"userAccountCredentials,omitempty"`

	// VirtualMachineImage: Virtual Machine image for AML Compute - windows only
	VirtualMachineImage *VirtualMachineImage_STATUS `json:"virtualMachineImage,omitempty"`

	// VmPriority: Virtual Machine priority
	VmPriority *AmlComputeProperties_VmPriority_STATUS `json:"vmPriority,omitempty"`

	// VmSize: Virtual Machine Size
	VmSize *string `json:"vmSize,omitempty"`
}

var _ genruntime.FromARMConverter = &AmlComputeProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *AmlComputeProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AmlComputeProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *AmlComputeProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AmlComputeProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AmlComputeProperties_STATUS, got %T", armInput)
	}

	// Set property "AllocationState":
	if typedInput.AllocationState != nil {
		var temp string
		temp = string(*typedInput.AllocationState)
		allocationState := AmlComputeProperties_AllocationState_STATUS(temp)
		properties.AllocationState = &allocationState
	}

	// Set property "AllocationStateTransitionTime":
	if typedInput.AllocationStateTransitionTime != nil {
		allocationStateTransitionTime := *typedInput.AllocationStateTransitionTime
		properties.AllocationStateTransitionTime = &allocationStateTransitionTime
	}

	// Set property "CurrentNodeCount":
	if typedInput.CurrentNodeCount != nil {
		currentNodeCount := *typedInput.CurrentNodeCount
		properties.CurrentNodeCount = &currentNodeCount
	}

	// Set property "EnableNodePublicIp":
	if typedInput.EnableNodePublicIp != nil {
		enableNodePublicIp := *typedInput.EnableNodePublicIp
		properties.EnableNodePublicIp = &enableNodePublicIp
	}

	// Set property "Errors":
	for _, item := range typedInput.Errors {
		var item1 ErrorResponse_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.Errors = append(properties.Errors, item1)
	}

	// Set property "IsolatedNetwork":
	if typedInput.IsolatedNetwork != nil {
		isolatedNetwork := *typedInput.IsolatedNetwork
		properties.IsolatedNetwork = &isolatedNetwork
	}

	// Set property "NodeStateCounts":
	if typedInput.NodeStateCounts != nil {
		var nodeStateCounts1 NodeStateCounts_STATUS
		err := nodeStateCounts1.PopulateFromARM(owner, *typedInput.NodeStateCounts)
		if err != nil {
			return err
		}
		nodeStateCounts := nodeStateCounts1
		properties.NodeStateCounts = &nodeStateCounts
	}

	// Set property "OsType":
	if typedInput.OsType != nil {
		var temp string
		temp = string(*typedInput.OsType)
		osType := AmlComputeProperties_OsType_STATUS(temp)
		properties.OsType = &osType
	}

	// Set property "RemoteLoginPortPublicAccess":
	if typedInput.RemoteLoginPortPublicAccess != nil {
		var temp string
		temp = string(*typedInput.RemoteLoginPortPublicAccess)
		remoteLoginPortPublicAccess := AmlComputeProperties_RemoteLoginPortPublicAccess_STATUS(temp)
		properties.RemoteLoginPortPublicAccess = &remoteLoginPortPublicAccess
	}

	// Set property "ScaleSettings":
	if typedInput.ScaleSettings != nil {
		var scaleSettings1 ScaleSettings_STATUS
		err := scaleSettings1.PopulateFromARM(owner, *typedInput.ScaleSettings)
		if err != nil {
			return err
		}
		scaleSettings := scaleSettings1
		properties.ScaleSettings = &scaleSettings
	}

	// Set property "Subnet":
	if typedInput.Subnet != nil {
		var subnet1 ResourceId_STATUS
		err := subnet1.PopulateFromARM(owner, *typedInput.Subnet)
		if err != nil {
			return err
		}
		subnet := subnet1
		properties.Subnet = &subnet
	}

	// Set property "TargetNodeCount":
	if typedInput.TargetNodeCount != nil {
		targetNodeCount := *typedInput.TargetNodeCount
		properties.TargetNodeCount = &targetNodeCount
	}

	// Set property "UserAccountCredentials":
	if typedInput.UserAccountCredentials != nil {
		var userAccountCredentials1 UserAccountCredentials_STATUS
		err := userAccountCredentials1.PopulateFromARM(owner, *typedInput.UserAccountCredentials)
		if err != nil {
			return err
		}
		userAccountCredentials := userAccountCredentials1
		properties.UserAccountCredentials = &userAccountCredentials
	}

	// Set property "VirtualMachineImage":
	if typedInput.VirtualMachineImage != nil {
		var virtualMachineImage1 VirtualMachineImage_STATUS
		err := virtualMachineImage1.PopulateFromARM(owner, *typedInput.VirtualMachineImage)
		if err != nil {
			return err
		}
		virtualMachineImage := virtualMachineImage1
		properties.VirtualMachineImage = &virtualMachineImage
	}

	// Set property "VmPriority":
	if typedInput.VmPriority != nil {
		var temp string
		temp = string(*typedInput.VmPriority)
		vmPriority := AmlComputeProperties_VmPriority_STATUS(temp)
		properties.VmPriority = &vmPriority
	}

	// Set property "VmSize":
	if typedInput.VmSize != nil {
		vmSize := *typedInput.VmSize
		properties.VmSize = &vmSize
	}

	// No error
	return nil
}

// AssignProperties_From_AmlComputeProperties_STATUS populates our AmlComputeProperties_STATUS from the provided source AmlComputeProperties_STATUS
func (properties *AmlComputeProperties_STATUS) AssignProperties_From_AmlComputeProperties_STATUS(source *storage.AmlComputeProperties_STATUS) error {

	// AllocationState
	if source.AllocationState != nil {
		allocationState := *source.AllocationState
		allocationStateTemp := genruntime.ToEnum(allocationState, amlComputeProperties_AllocationState_STATUS_Values)
		properties.AllocationState = &allocationStateTemp
	} else {
		properties.AllocationState = nil
	}

	// AllocationStateTransitionTime
	properties.AllocationStateTransitionTime = genruntime.ClonePointerToString(source.AllocationStateTransitionTime)

	// CurrentNodeCount
	properties.CurrentNodeCount = genruntime.ClonePointerToInt(source.CurrentNodeCount)

	// EnableNodePublicIp
	if source.EnableNodePublicIp != nil {
		enableNodePublicIp := *source.EnableNodePublicIp
		properties.EnableNodePublicIp = &enableNodePublicIp
	} else {
		properties.EnableNodePublicIp = nil
	}

	// Errors
	if source.Errors != nil {
		errorList := make([]ErrorResponse_STATUS, len(source.Errors))
		for errorIndex, errorItem := range source.Errors {
			// Shadow the loop variable to avoid aliasing
			errorItem := errorItem
			var error ErrorResponse_STATUS
			err := error.AssignProperties_From_ErrorResponse_STATUS(&errorItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ErrorResponse_STATUS() to populate field Errors")
			}
			errorList[errorIndex] = error
		}
		properties.Errors = errorList
	} else {
		properties.Errors = nil
	}

	// IsolatedNetwork
	if source.IsolatedNetwork != nil {
		isolatedNetwork := *source.IsolatedNetwork
		properties.IsolatedNetwork = &isolatedNetwork
	} else {
		properties.IsolatedNetwork = nil
	}

	// NodeStateCounts
	if source.NodeStateCounts != nil {
		var nodeStateCount NodeStateCounts_STATUS
		err := nodeStateCount.AssignProperties_From_NodeStateCounts_STATUS(source.NodeStateCounts)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_NodeStateCounts_STATUS() to populate field NodeStateCounts")
		}
		properties.NodeStateCounts = &nodeStateCount
	} else {
		properties.NodeStateCounts = nil
	}

	// OsType
	if source.OsType != nil {
		osType := *source.OsType
		osTypeTemp := genruntime.ToEnum(osType, amlComputeProperties_OsType_STATUS_Values)
		properties.OsType = &osTypeTemp
	} else {
		properties.OsType = nil
	}

	// RemoteLoginPortPublicAccess
	if source.RemoteLoginPortPublicAccess != nil {
		remoteLoginPortPublicAccess := *source.RemoteLoginPortPublicAccess
		remoteLoginPortPublicAccessTemp := genruntime.ToEnum(remoteLoginPortPublicAccess, amlComputeProperties_RemoteLoginPortPublicAccess_STATUS_Values)
		properties.RemoteLoginPortPublicAccess = &remoteLoginPortPublicAccessTemp
	} else {
		properties.RemoteLoginPortPublicAccess = nil
	}

	// ScaleSettings
	if source.ScaleSettings != nil {
		var scaleSetting ScaleSettings_STATUS
		err := scaleSetting.AssignProperties_From_ScaleSettings_STATUS(source.ScaleSettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ScaleSettings_STATUS() to populate field ScaleSettings")
		}
		properties.ScaleSettings = &scaleSetting
	} else {
		properties.ScaleSettings = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet ResourceId_STATUS
		err := subnet.AssignProperties_From_ResourceId_STATUS(source.Subnet)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ResourceId_STATUS() to populate field Subnet")
		}
		properties.Subnet = &subnet
	} else {
		properties.Subnet = nil
	}

	// TargetNodeCount
	properties.TargetNodeCount = genruntime.ClonePointerToInt(source.TargetNodeCount)

	// UserAccountCredentials
	if source.UserAccountCredentials != nil {
		var userAccountCredential UserAccountCredentials_STATUS
		err := userAccountCredential.AssignProperties_From_UserAccountCredentials_STATUS(source.UserAccountCredentials)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_UserAccountCredentials_STATUS() to populate field UserAccountCredentials")
		}
		properties.UserAccountCredentials = &userAccountCredential
	} else {
		properties.UserAccountCredentials = nil
	}

	// VirtualMachineImage
	if source.VirtualMachineImage != nil {
		var virtualMachineImage VirtualMachineImage_STATUS
		err := virtualMachineImage.AssignProperties_From_VirtualMachineImage_STATUS(source.VirtualMachineImage)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineImage_STATUS() to populate field VirtualMachineImage")
		}
		properties.VirtualMachineImage = &virtualMachineImage
	} else {
		properties.VirtualMachineImage = nil
	}

	// VmPriority
	if source.VmPriority != nil {
		vmPriority := *source.VmPriority
		vmPriorityTemp := genruntime.ToEnum(vmPriority, amlComputeProperties_VmPriority_STATUS_Values)
		properties.VmPriority = &vmPriorityTemp
	} else {
		properties.VmPriority = nil
	}

	// VmSize
	properties.VmSize = genruntime.ClonePointerToString(source.VmSize)

	// No error
	return nil
}

// AssignProperties_To_AmlComputeProperties_STATUS populates the provided destination AmlComputeProperties_STATUS from our AmlComputeProperties_STATUS
func (properties *AmlComputeProperties_STATUS) AssignProperties_To_AmlComputeProperties_STATUS(destination *storage.AmlComputeProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllocationState
	if properties.AllocationState != nil {
		allocationState := string(*properties.AllocationState)
		destination.AllocationState = &allocationState
	} else {
		destination.AllocationState = nil
	}

	// AllocationStateTransitionTime
	destination.AllocationStateTransitionTime = genruntime.ClonePointerToString(properties.AllocationStateTransitionTime)

	// CurrentNodeCount
	destination.CurrentNodeCount = genruntime.ClonePointerToInt(properties.CurrentNodeCount)

	// EnableNodePublicIp
	if properties.EnableNodePublicIp != nil {
		enableNodePublicIp := *properties.EnableNodePublicIp
		destination.EnableNodePublicIp = &enableNodePublicIp
	} else {
		destination.EnableNodePublicIp = nil
	}

	// Errors
	if properties.Errors != nil {
		errorList := make([]storage.ErrorResponse_STATUS, len(properties.Errors))
		for errorIndex, errorItem := range properties.Errors {
			// Shadow the loop variable to avoid aliasing
			errorItem := errorItem
			var error storage.ErrorResponse_STATUS
			err := errorItem.AssignProperties_To_ErrorResponse_STATUS(&error)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ErrorResponse_STATUS() to populate field Errors")
			}
			errorList[errorIndex] = error
		}
		destination.Errors = errorList
	} else {
		destination.Errors = nil
	}

	// IsolatedNetwork
	if properties.IsolatedNetwork != nil {
		isolatedNetwork := *properties.IsolatedNetwork
		destination.IsolatedNetwork = &isolatedNetwork
	} else {
		destination.IsolatedNetwork = nil
	}

	// NodeStateCounts
	if properties.NodeStateCounts != nil {
		var nodeStateCount storage.NodeStateCounts_STATUS
		err := properties.NodeStateCounts.AssignProperties_To_NodeStateCounts_STATUS(&nodeStateCount)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_NodeStateCounts_STATUS() to populate field NodeStateCounts")
		}
		destination.NodeStateCounts = &nodeStateCount
	} else {
		destination.NodeStateCounts = nil
	}

	// OsType
	if properties.OsType != nil {
		osType := string(*properties.OsType)
		destination.OsType = &osType
	} else {
		destination.OsType = nil
	}

	// RemoteLoginPortPublicAccess
	if properties.RemoteLoginPortPublicAccess != nil {
		remoteLoginPortPublicAccess := string(*properties.RemoteLoginPortPublicAccess)
		destination.RemoteLoginPortPublicAccess = &remoteLoginPortPublicAccess
	} else {
		destination.RemoteLoginPortPublicAccess = nil
	}

	// ScaleSettings
	if properties.ScaleSettings != nil {
		var scaleSetting storage.ScaleSettings_STATUS
		err := properties.ScaleSettings.AssignProperties_To_ScaleSettings_STATUS(&scaleSetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ScaleSettings_STATUS() to populate field ScaleSettings")
		}
		destination.ScaleSettings = &scaleSetting
	} else {
		destination.ScaleSettings = nil
	}

	// Subnet
	if properties.Subnet != nil {
		var subnet storage.ResourceId_STATUS
		err := properties.Subnet.AssignProperties_To_ResourceId_STATUS(&subnet)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ResourceId_STATUS() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// TargetNodeCount
	destination.TargetNodeCount = genruntime.ClonePointerToInt(properties.TargetNodeCount)

	// UserAccountCredentials
	if properties.UserAccountCredentials != nil {
		var userAccountCredential storage.UserAccountCredentials_STATUS
		err := properties.UserAccountCredentials.AssignProperties_To_UserAccountCredentials_STATUS(&userAccountCredential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_UserAccountCredentials_STATUS() to populate field UserAccountCredentials")
		}
		destination.UserAccountCredentials = &userAccountCredential
	} else {
		destination.UserAccountCredentials = nil
	}

	// VirtualMachineImage
	if properties.VirtualMachineImage != nil {
		var virtualMachineImage storage.VirtualMachineImage_STATUS
		err := properties.VirtualMachineImage.AssignProperties_To_VirtualMachineImage_STATUS(&virtualMachineImage)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineImage_STATUS() to populate field VirtualMachineImage")
		}
		destination.VirtualMachineImage = &virtualMachineImage
	} else {
		destination.VirtualMachineImage = nil
	}

	// VmPriority
	if properties.VmPriority != nil {
		vmPriority := string(*properties.VmPriority)
		destination.VmPriority = &vmPriority
	} else {
		destination.VmPriority = nil
	}

	// VmSize
	destination.VmSize = genruntime.ClonePointerToString(properties.VmSize)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"ComputeInstance"}
type ComputeInstance_ComputeType string

const ComputeInstance_ComputeType_ComputeInstance = ComputeInstance_ComputeType("ComputeInstance")

// Mapping from string to ComputeInstance_ComputeType
var computeInstance_ComputeType_Values = map[string]ComputeInstance_ComputeType{
	"computeinstance": ComputeInstance_ComputeType_ComputeInstance,
}

type ComputeInstance_ComputeType_STATUS string

const ComputeInstance_ComputeType_STATUS_ComputeInstance = ComputeInstance_ComputeType_STATUS("ComputeInstance")

// Mapping from string to ComputeInstance_ComputeType_STATUS
var computeInstance_ComputeType_STATUS_Values = map[string]ComputeInstance_ComputeType_STATUS{
	"computeinstance": ComputeInstance_ComputeType_STATUS_ComputeInstance,
}

type ComputeInstance_ProvisioningState_STATUS string

const (
	ComputeInstance_ProvisioningState_STATUS_Canceled  = ComputeInstance_ProvisioningState_STATUS("Canceled")
	ComputeInstance_ProvisioningState_STATUS_Creating  = ComputeInstance_ProvisioningState_STATUS("Creating")
	ComputeInstance_ProvisioningState_STATUS_Deleting  = ComputeInstance_ProvisioningState_STATUS("Deleting")
	ComputeInstance_ProvisioningState_STATUS_Failed    = ComputeInstance_ProvisioningState_STATUS("Failed")
	ComputeInstance_ProvisioningState_STATUS_Succeeded = ComputeInstance_ProvisioningState_STATUS("Succeeded")
	ComputeInstance_ProvisioningState_STATUS_Unknown   = ComputeInstance_ProvisioningState_STATUS("Unknown")
	ComputeInstance_ProvisioningState_STATUS_Updating  = ComputeInstance_ProvisioningState_STATUS("Updating")
)

// Mapping from string to ComputeInstance_ProvisioningState_STATUS
var computeInstance_ProvisioningState_STATUS_Values = map[string]ComputeInstance_ProvisioningState_STATUS{
	"canceled":  ComputeInstance_ProvisioningState_STATUS_Canceled,
	"creating":  ComputeInstance_ProvisioningState_STATUS_Creating,
	"deleting":  ComputeInstance_ProvisioningState_STATUS_Deleting,
	"failed":    ComputeInstance_ProvisioningState_STATUS_Failed,
	"succeeded": ComputeInstance_ProvisioningState_STATUS_Succeeded,
	"unknown":   ComputeInstance_ProvisioningState_STATUS_Unknown,
	"updating":  ComputeInstance_ProvisioningState_STATUS_Updating,
}

// Compute Instance properties
type ComputeInstanceProperties struct {
	// ApplicationSharingPolicy: Policy for sharing applications on this compute instance among users of parent workspace. If
	// Personal, only the creator can access applications on this compute instance. When Shared, any workspace user can access
	// applications on this instance depending on his/her assigned role.
	ApplicationSharingPolicy *ComputeInstanceProperties_ApplicationSharingPolicy `json:"applicationSharingPolicy,omitempty"`

	// ComputeInstanceAuthorizationType: The Compute Instance Authorization type. Available values are personal (default).
	ComputeInstanceAuthorizationType *ComputeInstanceProperties_ComputeInstanceAuthorizationType `json:"computeInstanceAuthorizationType,omitempty"`

	// PersonalComputeInstanceSettings: Settings for a personal compute instance.
	PersonalComputeInstanceSettings *PersonalComputeInstanceSettings `json:"personalComputeInstanceSettings,omitempty"`

	// SetupScripts: Details of customized scripts to execute for setting up the cluster.
	SetupScripts *SetupScripts `json:"setupScripts,omitempty"`

	// SshSettings: Specifies policy and settings for SSH access.
	SshSettings *ComputeInstanceSshSettings `json:"sshSettings,omitempty"`

	// Subnet: Virtual network subnet resource ID the compute nodes belong to.
	Subnet *ResourceId `json:"subnet,omitempty"`

	// VmSize: Virtual Machine Size
	VmSize *string `json:"vmSize,omitempty"`
}

var _ genruntime.ARMTransformer = &ComputeInstanceProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *ComputeInstanceProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.ComputeInstanceProperties{}

	// Set property "ApplicationSharingPolicy":
	if properties.ApplicationSharingPolicy != nil {
		var temp string
		temp = string(*properties.ApplicationSharingPolicy)
		applicationSharingPolicy := arm.ComputeInstanceProperties_ApplicationSharingPolicy(temp)
		result.ApplicationSharingPolicy = &applicationSharingPolicy
	}

	// Set property "ComputeInstanceAuthorizationType":
	if properties.ComputeInstanceAuthorizationType != nil {
		var temp string
		temp = string(*properties.ComputeInstanceAuthorizationType)
		computeInstanceAuthorizationType := arm.ComputeInstanceProperties_ComputeInstanceAuthorizationType(temp)
		result.ComputeInstanceAuthorizationType = &computeInstanceAuthorizationType
	}

	// Set property "PersonalComputeInstanceSettings":
	if properties.PersonalComputeInstanceSettings != nil {
		personalComputeInstanceSettings_ARM, err := (*properties.PersonalComputeInstanceSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		personalComputeInstanceSettings := *personalComputeInstanceSettings_ARM.(*arm.PersonalComputeInstanceSettings)
		result.PersonalComputeInstanceSettings = &personalComputeInstanceSettings
	}

	// Set property "SetupScripts":
	if properties.SetupScripts != nil {
		setupScripts_ARM, err := (*properties.SetupScripts).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		setupScripts := *setupScripts_ARM.(*arm.SetupScripts)
		result.SetupScripts = &setupScripts
	}

	// Set property "SshSettings":
	if properties.SshSettings != nil {
		sshSettings_ARM, err := (*properties.SshSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sshSettings := *sshSettings_ARM.(*arm.ComputeInstanceSshSettings)
		result.SshSettings = &sshSettings
	}

	// Set property "Subnet":
	if properties.Subnet != nil {
		subnet_ARM, err := (*properties.Subnet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		subnet := *subnet_ARM.(*arm.ResourceId)
		result.Subnet = &subnet
	}

	// Set property "VmSize":
	if properties.VmSize != nil {
		vmSize := *properties.VmSize
		result.VmSize = &vmSize
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *ComputeInstanceProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComputeInstanceProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *ComputeInstanceProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComputeInstanceProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComputeInstanceProperties, got %T", armInput)
	}

	// Set property "ApplicationSharingPolicy":
	if typedInput.ApplicationSharingPolicy != nil {
		var temp string
		temp = string(*typedInput.ApplicationSharingPolicy)
		applicationSharingPolicy := ComputeInstanceProperties_ApplicationSharingPolicy(temp)
		properties.ApplicationSharingPolicy = &applicationSharingPolicy
	}

	// Set property "ComputeInstanceAuthorizationType":
	if typedInput.ComputeInstanceAuthorizationType != nil {
		var temp string
		temp = string(*typedInput.ComputeInstanceAuthorizationType)
		computeInstanceAuthorizationType := ComputeInstanceProperties_ComputeInstanceAuthorizationType(temp)
		properties.ComputeInstanceAuthorizationType = &computeInstanceAuthorizationType
	}

	// Set property "PersonalComputeInstanceSettings":
	if typedInput.PersonalComputeInstanceSettings != nil {
		var personalComputeInstanceSettings1 PersonalComputeInstanceSettings
		err := personalComputeInstanceSettings1.PopulateFromARM(owner, *typedInput.PersonalComputeInstanceSettings)
		if err != nil {
			return err
		}
		personalComputeInstanceSettings := personalComputeInstanceSettings1
		properties.PersonalComputeInstanceSettings = &personalComputeInstanceSettings
	}

	// Set property "SetupScripts":
	if typedInput.SetupScripts != nil {
		var setupScripts1 SetupScripts
		err := setupScripts1.PopulateFromARM(owner, *typedInput.SetupScripts)
		if err != nil {
			return err
		}
		setupScripts := setupScripts1
		properties.SetupScripts = &setupScripts
	}

	// Set property "SshSettings":
	if typedInput.SshSettings != nil {
		var sshSettings1 ComputeInstanceSshSettings
		err := sshSettings1.PopulateFromARM(owner, *typedInput.SshSettings)
		if err != nil {
			return err
		}
		sshSettings := sshSettings1
		properties.SshSettings = &sshSettings
	}

	// Set property "Subnet":
	if typedInput.Subnet != nil {
		var subnet1 ResourceId
		err := subnet1.PopulateFromARM(owner, *typedInput.Subnet)
		if err != nil {
			return err
		}
		subnet := subnet1
		properties.Subnet = &subnet
	}

	// Set property "VmSize":
	if typedInput.VmSize != nil {
		vmSize := *typedInput.VmSize
		properties.VmSize = &vmSize
	}

	// No error
	return nil
}

// AssignProperties_From_ComputeInstanceProperties populates our ComputeInstanceProperties from the provided source ComputeInstanceProperties
func (properties *ComputeInstanceProperties) AssignProperties_From_ComputeInstanceProperties(source *storage.ComputeInstanceProperties) error {

	// ApplicationSharingPolicy
	if source.ApplicationSharingPolicy != nil {
		applicationSharingPolicy := *source.ApplicationSharingPolicy
		applicationSharingPolicyTemp := genruntime.ToEnum(applicationSharingPolicy, computeInstanceProperties_ApplicationSharingPolicy_Values)
		properties.ApplicationSharingPolicy = &applicationSharingPolicyTemp
	} else {
		properties.ApplicationSharingPolicy = nil
	}

	// ComputeInstanceAuthorizationType
	if source.ComputeInstanceAuthorizationType != nil {
		computeInstanceAuthorizationType := *source.ComputeInstanceAuthorizationType
		computeInstanceAuthorizationTypeTemp := genruntime.ToEnum(computeInstanceAuthorizationType, computeInstanceProperties_ComputeInstanceAuthorizationType_Values)
		properties.ComputeInstanceAuthorizationType = &computeInstanceAuthorizationTypeTemp
	} else {
		properties.ComputeInstanceAuthorizationType = nil
	}

	// PersonalComputeInstanceSettings
	if source.PersonalComputeInstanceSettings != nil {
		var personalComputeInstanceSetting PersonalComputeInstanceSettings
		err := personalComputeInstanceSetting.AssignProperties_From_PersonalComputeInstanceSettings(source.PersonalComputeInstanceSettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_PersonalComputeInstanceSettings() to populate field PersonalComputeInstanceSettings")
		}
		properties.PersonalComputeInstanceSettings = &personalComputeInstanceSetting
	} else {
		properties.PersonalComputeInstanceSettings = nil
	}

	// SetupScripts
	if source.SetupScripts != nil {
		var setupScript SetupScripts
		err := setupScript.AssignProperties_From_SetupScripts(source.SetupScripts)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SetupScripts() to populate field SetupScripts")
		}
		properties.SetupScripts = &setupScript
	} else {
		properties.SetupScripts = nil
	}

	// SshSettings
	if source.SshSettings != nil {
		var sshSetting ComputeInstanceSshSettings
		err := sshSetting.AssignProperties_From_ComputeInstanceSshSettings(source.SshSettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ComputeInstanceSshSettings() to populate field SshSettings")
		}
		properties.SshSettings = &sshSetting
	} else {
		properties.SshSettings = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet ResourceId
		err := subnet.AssignProperties_From_ResourceId(source.Subnet)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ResourceId() to populate field Subnet")
		}
		properties.Subnet = &subnet
	} else {
		properties.Subnet = nil
	}

	// VmSize
	properties.VmSize = genruntime.ClonePointerToString(source.VmSize)

	// No error
	return nil
}

// AssignProperties_To_ComputeInstanceProperties populates the provided destination ComputeInstanceProperties from our ComputeInstanceProperties
func (properties *ComputeInstanceProperties) AssignProperties_To_ComputeInstanceProperties(destination *storage.ComputeInstanceProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ApplicationSharingPolicy
	if properties.ApplicationSharingPolicy != nil {
		applicationSharingPolicy := string(*properties.ApplicationSharingPolicy)
		destination.ApplicationSharingPolicy = &applicationSharingPolicy
	} else {
		destination.ApplicationSharingPolicy = nil
	}

	// ComputeInstanceAuthorizationType
	if properties.ComputeInstanceAuthorizationType != nil {
		computeInstanceAuthorizationType := string(*properties.ComputeInstanceAuthorizationType)
		destination.ComputeInstanceAuthorizationType = &computeInstanceAuthorizationType
	} else {
		destination.ComputeInstanceAuthorizationType = nil
	}

	// PersonalComputeInstanceSettings
	if properties.PersonalComputeInstanceSettings != nil {
		var personalComputeInstanceSetting storage.PersonalComputeInstanceSettings
		err := properties.PersonalComputeInstanceSettings.AssignProperties_To_PersonalComputeInstanceSettings(&personalComputeInstanceSetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_PersonalComputeInstanceSettings() to populate field PersonalComputeInstanceSettings")
		}
		destination.PersonalComputeInstanceSettings = &personalComputeInstanceSetting
	} else {
		destination.PersonalComputeInstanceSettings = nil
	}

	// SetupScripts
	if properties.SetupScripts != nil {
		var setupScript storage.SetupScripts
		err := properties.SetupScripts.AssignProperties_To_SetupScripts(&setupScript)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SetupScripts() to populate field SetupScripts")
		}
		destination.SetupScripts = &setupScript
	} else {
		destination.SetupScripts = nil
	}

	// SshSettings
	if properties.SshSettings != nil {
		var sshSetting storage.ComputeInstanceSshSettings
		err := properties.SshSettings.AssignProperties_To_ComputeInstanceSshSettings(&sshSetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ComputeInstanceSshSettings() to populate field SshSettings")
		}
		destination.SshSettings = &sshSetting
	} else {
		destination.SshSettings = nil
	}

	// Subnet
	if properties.Subnet != nil {
		var subnet storage.ResourceId
		err := properties.Subnet.AssignProperties_To_ResourceId(&subnet)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ResourceId() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// VmSize
	destination.VmSize = genruntime.ClonePointerToString(properties.VmSize)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Compute Instance properties
type ComputeInstanceProperties_STATUS struct {
	// ApplicationSharingPolicy: Policy for sharing applications on this compute instance among users of parent workspace. If
	// Personal, only the creator can access applications on this compute instance. When Shared, any workspace user can access
	// applications on this instance depending on his/her assigned role.
	ApplicationSharingPolicy *ComputeInstanceProperties_ApplicationSharingPolicy_STATUS `json:"applicationSharingPolicy,omitempty"`

	// Applications: Describes available applications and their endpoints on this ComputeInstance.
	Applications []ComputeInstanceApplication_STATUS `json:"applications,omitempty"`

	// ComputeInstanceAuthorizationType: The Compute Instance Authorization type. Available values are personal (default).
	ComputeInstanceAuthorizationType *ComputeInstanceProperties_ComputeInstanceAuthorizationType_STATUS `json:"computeInstanceAuthorizationType,omitempty"`

	// ConnectivityEndpoints: Describes all connectivity endpoints available for this ComputeInstance.
	ConnectivityEndpoints *ComputeInstanceConnectivityEndpoints_STATUS `json:"connectivityEndpoints,omitempty"`

	// CreatedBy: Describes information on user who created this ComputeInstance.
	CreatedBy *ComputeInstanceCreatedBy_STATUS `json:"createdBy,omitempty"`

	// Errors: Collection of errors encountered on this ComputeInstance.
	Errors []ErrorResponse_STATUS `json:"errors,omitempty"`

	// LastOperation: The last operation on ComputeInstance.
	LastOperation *ComputeInstanceLastOperation_STATUS `json:"lastOperation,omitempty"`

	// PersonalComputeInstanceSettings: Settings for a personal compute instance.
	PersonalComputeInstanceSettings *PersonalComputeInstanceSettings_STATUS `json:"personalComputeInstanceSettings,omitempty"`

	// SetupScripts: Details of customized scripts to execute for setting up the cluster.
	SetupScripts *SetupScripts_STATUS `json:"setupScripts,omitempty"`

	// SshSettings: Specifies policy and settings for SSH access.
	SshSettings *ComputeInstanceSshSettings_STATUS `json:"sshSettings,omitempty"`

	// State: The current state of this ComputeInstance.
	State *ComputeInstanceState_STATUS `json:"state,omitempty"`

	// Subnet: Virtual network subnet resource ID the compute nodes belong to.
	Subnet *ResourceId_STATUS `json:"subnet,omitempty"`

	// VmSize: Virtual Machine Size
	VmSize *string `json:"vmSize,omitempty"`
}

var _ genruntime.FromARMConverter = &ComputeInstanceProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *ComputeInstanceProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComputeInstanceProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *ComputeInstanceProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComputeInstanceProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComputeInstanceProperties_STATUS, got %T", armInput)
	}

	// Set property "ApplicationSharingPolicy":
	if typedInput.ApplicationSharingPolicy != nil {
		var temp string
		temp = string(*typedInput.ApplicationSharingPolicy)
		applicationSharingPolicy := ComputeInstanceProperties_ApplicationSharingPolicy_STATUS(temp)
		properties.ApplicationSharingPolicy = &applicationSharingPolicy
	}

	// Set property "Applications":
	for _, item := range typedInput.Applications {
		var item1 ComputeInstanceApplication_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.Applications = append(properties.Applications, item1)
	}

	// Set property "ComputeInstanceAuthorizationType":
	if typedInput.ComputeInstanceAuthorizationType != nil {
		var temp string
		temp = string(*typedInput.ComputeInstanceAuthorizationType)
		computeInstanceAuthorizationType := ComputeInstanceProperties_ComputeInstanceAuthorizationType_STATUS(temp)
		properties.ComputeInstanceAuthorizationType = &computeInstanceAuthorizationType
	}

	// Set property "ConnectivityEndpoints":
	if typedInput.ConnectivityEndpoints != nil {
		var connectivityEndpoints1 ComputeInstanceConnectivityEndpoints_STATUS
		err := connectivityEndpoints1.PopulateFromARM(owner, *typedInput.ConnectivityEndpoints)
		if err != nil {
			return err
		}
		connectivityEndpoints := connectivityEndpoints1
		properties.ConnectivityEndpoints = &connectivityEndpoints
	}

	// Set property "CreatedBy":
	if typedInput.CreatedBy != nil {
		var createdBy1 ComputeInstanceCreatedBy_STATUS
		err := createdBy1.PopulateFromARM(owner, *typedInput.CreatedBy)
		if err != nil {
			return err
		}
		createdBy := createdBy1
		properties.CreatedBy = &createdBy
	}

	// Set property "Errors":
	for _, item := range typedInput.Errors {
		var item1 ErrorResponse_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.Errors = append(properties.Errors, item1)
	}

	// Set property "LastOperation":
	if typedInput.LastOperation != nil {
		var lastOperation1 ComputeInstanceLastOperation_STATUS
		err := lastOperation1.PopulateFromARM(owner, *typedInput.LastOperation)
		if err != nil {
			return err
		}
		lastOperation := lastOperation1
		properties.LastOperation = &lastOperation
	}

	// Set property "PersonalComputeInstanceSettings":
	if typedInput.PersonalComputeInstanceSettings != nil {
		var personalComputeInstanceSettings1 PersonalComputeInstanceSettings_STATUS
		err := personalComputeInstanceSettings1.PopulateFromARM(owner, *typedInput.PersonalComputeInstanceSettings)
		if err != nil {
			return err
		}
		personalComputeInstanceSettings := personalComputeInstanceSettings1
		properties.PersonalComputeInstanceSettings = &personalComputeInstanceSettings
	}

	// Set property "SetupScripts":
	if typedInput.SetupScripts != nil {
		var setupScripts1 SetupScripts_STATUS
		err := setupScripts1.PopulateFromARM(owner, *typedInput.SetupScripts)
		if err != nil {
			return err
		}
		setupScripts := setupScripts1
		properties.SetupScripts = &setupScripts
	}

	// Set property "SshSettings":
	if typedInput.SshSettings != nil {
		var sshSettings1 ComputeInstanceSshSettings_STATUS
		err := sshSettings1.PopulateFromARM(owner, *typedInput.SshSettings)
		if err != nil {
			return err
		}
		sshSettings := sshSettings1
		properties.SshSettings = &sshSettings
	}

	// Set property "State":
	if typedInput.State != nil {
		var temp string
		temp = string(*typedInput.State)
		state := ComputeInstanceState_STATUS(temp)
		properties.State = &state
	}

	// Set property "Subnet":
	if typedInput.Subnet != nil {
		var subnet1 ResourceId_STATUS
		err := subnet1.PopulateFromARM(owner, *typedInput.Subnet)
		if err != nil {
			return err
		}
		subnet := subnet1
		properties.Subnet = &subnet
	}

	// Set property "VmSize":
	if typedInput.VmSize != nil {
		vmSize := *typedInput.VmSize
		properties.VmSize = &vmSize
	}

	// No error
	return nil
}

// AssignProperties_From_ComputeInstanceProperties_STATUS populates our ComputeInstanceProperties_STATUS from the provided source ComputeInstanceProperties_STATUS
func (properties *ComputeInstanceProperties_STATUS) AssignProperties_From_ComputeInstanceProperties_STATUS(source *storage.ComputeInstanceProperties_STATUS) error {

	// ApplicationSharingPolicy
	if source.ApplicationSharingPolicy != nil {
		applicationSharingPolicy := *source.ApplicationSharingPolicy
		applicationSharingPolicyTemp := genruntime.ToEnum(applicationSharingPolicy, computeInstanceProperties_ApplicationSharingPolicy_STATUS_Values)
		properties.ApplicationSharingPolicy = &applicationSharingPolicyTemp
	} else {
		properties.ApplicationSharingPolicy = nil
	}

	// Applications
	if source.Applications != nil {
		applicationList := make([]ComputeInstanceApplication_STATUS, len(source.Applications))
		for applicationIndex, applicationItem := range source.Applications {
			// Shadow the loop variable to avoid aliasing
			applicationItem := applicationItem
			var application ComputeInstanceApplication_STATUS
			err := application.AssignProperties_From_ComputeInstanceApplication_STATUS(&applicationItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ComputeInstanceApplication_STATUS() to populate field Applications")
			}
			applicationList[applicationIndex] = application
		}
		properties.Applications = applicationList
	} else {
		properties.Applications = nil
	}

	// ComputeInstanceAuthorizationType
	if source.ComputeInstanceAuthorizationType != nil {
		computeInstanceAuthorizationType := *source.ComputeInstanceAuthorizationType
		computeInstanceAuthorizationTypeTemp := genruntime.ToEnum(computeInstanceAuthorizationType, computeInstanceProperties_ComputeInstanceAuthorizationType_STATUS_Values)
		properties.ComputeInstanceAuthorizationType = &computeInstanceAuthorizationTypeTemp
	} else {
		properties.ComputeInstanceAuthorizationType = nil
	}

	// ConnectivityEndpoints
	if source.ConnectivityEndpoints != nil {
		var connectivityEndpoint ComputeInstanceConnectivityEndpoints_STATUS
		err := connectivityEndpoint.AssignProperties_From_ComputeInstanceConnectivityEndpoints_STATUS(source.ConnectivityEndpoints)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ComputeInstanceConnectivityEndpoints_STATUS() to populate field ConnectivityEndpoints")
		}
		properties.ConnectivityEndpoints = &connectivityEndpoint
	} else {
		properties.ConnectivityEndpoints = nil
	}

	// CreatedBy
	if source.CreatedBy != nil {
		var createdBy ComputeInstanceCreatedBy_STATUS
		err := createdBy.AssignProperties_From_ComputeInstanceCreatedBy_STATUS(source.CreatedBy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ComputeInstanceCreatedBy_STATUS() to populate field CreatedBy")
		}
		properties.CreatedBy = &createdBy
	} else {
		properties.CreatedBy = nil
	}

	// Errors
	if source.Errors != nil {
		errorList := make([]ErrorResponse_STATUS, len(source.Errors))
		for errorIndex, errorItem := range source.Errors {
			// Shadow the loop variable to avoid aliasing
			errorItem := errorItem
			var error ErrorResponse_STATUS
			err := error.AssignProperties_From_ErrorResponse_STATUS(&errorItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ErrorResponse_STATUS() to populate field Errors")
			}
			errorList[errorIndex] = error
		}
		properties.Errors = errorList
	} else {
		properties.Errors = nil
	}

	// LastOperation
	if source.LastOperation != nil {
		var lastOperation ComputeInstanceLastOperation_STATUS
		err := lastOperation.AssignProperties_From_ComputeInstanceLastOperation_STATUS(source.LastOperation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ComputeInstanceLastOperation_STATUS() to populate field LastOperation")
		}
		properties.LastOperation = &lastOperation
	} else {
		properties.LastOperation = nil
	}

	// PersonalComputeInstanceSettings
	if source.PersonalComputeInstanceSettings != nil {
		var personalComputeInstanceSetting PersonalComputeInstanceSettings_STATUS
		err := personalComputeInstanceSetting.AssignProperties_From_PersonalComputeInstanceSettings_STATUS(source.PersonalComputeInstanceSettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_PersonalComputeInstanceSettings_STATUS() to populate field PersonalComputeInstanceSettings")
		}
		properties.PersonalComputeInstanceSettings = &personalComputeInstanceSetting
	} else {
		properties.PersonalComputeInstanceSettings = nil
	}

	// SetupScripts
	if source.SetupScripts != nil {
		var setupScript SetupScripts_STATUS
		err := setupScript.AssignProperties_From_SetupScripts_STATUS(source.SetupScripts)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SetupScripts_STATUS() to populate field SetupScripts")
		}
		properties.SetupScripts = &setupScript
	} else {
		properties.SetupScripts = nil
	}

	// SshSettings
	if source.SshSettings != nil {
		var sshSetting ComputeInstanceSshSettings_STATUS
		err := sshSetting.AssignProperties_From_ComputeInstanceSshSettings_STATUS(source.SshSettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ComputeInstanceSshSettings_STATUS() to populate field SshSettings")
		}
		properties.SshSettings = &sshSetting
	} else {
		properties.SshSettings = nil
	}

	// State
	if source.State != nil {
		state := *source.State
		stateTemp := genruntime.ToEnum(state, computeInstanceState_STATUS_Values)
		properties.State = &stateTemp
	} else {
		properties.State = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet ResourceId_STATUS
		err := subnet.AssignProperties_From_ResourceId_STATUS(source.Subnet)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ResourceId_STATUS() to populate field Subnet")
		}
		properties.Subnet = &subnet
	} else {
		properties.Subnet = nil
	}

	// VmSize
	properties.VmSize = genruntime.ClonePointerToString(source.VmSize)

	// No error
	return nil
}

// AssignProperties_To_ComputeInstanceProperties_STATUS populates the provided destination ComputeInstanceProperties_STATUS from our ComputeInstanceProperties_STATUS
func (properties *ComputeInstanceProperties_STATUS) AssignProperties_To_ComputeInstanceProperties_STATUS(destination *storage.ComputeInstanceProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ApplicationSharingPolicy
	if properties.ApplicationSharingPolicy != nil {
		applicationSharingPolicy := string(*properties.ApplicationSharingPolicy)
		destination.ApplicationSharingPolicy = &applicationSharingPolicy
	} else {
		destination.ApplicationSharingPolicy = nil
	}

	// Applications
	if properties.Applications != nil {
		applicationList := make([]storage.ComputeInstanceApplication_STATUS, len(properties.Applications))
		for applicationIndex, applicationItem := range properties.Applications {
			// Shadow the loop variable to avoid aliasing
			applicationItem := applicationItem
			var application storage.ComputeInstanceApplication_STATUS
			err := applicationItem.AssignProperties_To_ComputeInstanceApplication_STATUS(&application)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ComputeInstanceApplication_STATUS() to populate field Applications")
			}
			applicationList[applicationIndex] = application
		}
		destination.Applications = applicationList
	} else {
		destination.Applications = nil
	}

	// ComputeInstanceAuthorizationType
	if properties.ComputeInstanceAuthorizationType != nil {
		computeInstanceAuthorizationType := string(*properties.ComputeInstanceAuthorizationType)
		destination.ComputeInstanceAuthorizationType = &computeInstanceAuthorizationType
	} else {
		destination.ComputeInstanceAuthorizationType = nil
	}

	// ConnectivityEndpoints
	if properties.ConnectivityEndpoints != nil {
		var connectivityEndpoint storage.ComputeInstanceConnectivityEndpoints_STATUS
		err := properties.ConnectivityEndpoints.AssignProperties_To_ComputeInstanceConnectivityEndpoints_STATUS(&connectivityEndpoint)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ComputeInstanceConnectivityEndpoints_STATUS() to populate field ConnectivityEndpoints")
		}
		destination.ConnectivityEndpoints = &connectivityEndpoint
	} else {
		destination.ConnectivityEndpoints = nil
	}

	// CreatedBy
	if properties.CreatedBy != nil {
		var createdBy storage.ComputeInstanceCreatedBy_STATUS
		err := properties.CreatedBy.AssignProperties_To_ComputeInstanceCreatedBy_STATUS(&createdBy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ComputeInstanceCreatedBy_STATUS() to populate field CreatedBy")
		}
		destination.CreatedBy = &createdBy
	} else {
		destination.CreatedBy = nil
	}

	// Errors
	if properties.Errors != nil {
		errorList := make([]storage.ErrorResponse_STATUS, len(properties.Errors))
		for errorIndex, errorItem := range properties.Errors {
			// Shadow the loop variable to avoid aliasing
			errorItem := errorItem
			var error storage.ErrorResponse_STATUS
			err := errorItem.AssignProperties_To_ErrorResponse_STATUS(&error)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ErrorResponse_STATUS() to populate field Errors")
			}
			errorList[errorIndex] = error
		}
		destination.Errors = errorList
	} else {
		destination.Errors = nil
	}

	// LastOperation
	if properties.LastOperation != nil {
		var lastOperation storage.ComputeInstanceLastOperation_STATUS
		err := properties.LastOperation.AssignProperties_To_ComputeInstanceLastOperation_STATUS(&lastOperation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ComputeInstanceLastOperation_STATUS() to populate field LastOperation")
		}
		destination.LastOperation = &lastOperation
	} else {
		destination.LastOperation = nil
	}

	// PersonalComputeInstanceSettings
	if properties.PersonalComputeInstanceSettings != nil {
		var personalComputeInstanceSetting storage.PersonalComputeInstanceSettings_STATUS
		err := properties.PersonalComputeInstanceSettings.AssignProperties_To_PersonalComputeInstanceSettings_STATUS(&personalComputeInstanceSetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_PersonalComputeInstanceSettings_STATUS() to populate field PersonalComputeInstanceSettings")
		}
		destination.PersonalComputeInstanceSettings = &personalComputeInstanceSetting
	} else {
		destination.PersonalComputeInstanceSettings = nil
	}

	// SetupScripts
	if properties.SetupScripts != nil {
		var setupScript storage.SetupScripts_STATUS
		err := properties.SetupScripts.AssignProperties_To_SetupScripts_STATUS(&setupScript)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SetupScripts_STATUS() to populate field SetupScripts")
		}
		destination.SetupScripts = &setupScript
	} else {
		destination.SetupScripts = nil
	}

	// SshSettings
	if properties.SshSettings != nil {
		var sshSetting storage.ComputeInstanceSshSettings_STATUS
		err := properties.SshSettings.AssignProperties_To_ComputeInstanceSshSettings_STATUS(&sshSetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ComputeInstanceSshSettings_STATUS() to populate field SshSettings")
		}
		destination.SshSettings = &sshSetting
	} else {
		destination.SshSettings = nil
	}

	// State
	if properties.State != nil {
		state := string(*properties.State)
		destination.State = &state
	} else {
		destination.State = nil
	}

	// Subnet
	if properties.Subnet != nil {
		var subnet storage.ResourceId_STATUS
		err := properties.Subnet.AssignProperties_To_ResourceId_STATUS(&subnet)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ResourceId_STATUS() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// VmSize
	destination.VmSize = genruntime.ClonePointerToString(properties.VmSize)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Databricks"}
type Databricks_ComputeType string

const Databricks_ComputeType_Databricks = Databricks_ComputeType("Databricks")

// Mapping from string to Databricks_ComputeType
var databricks_ComputeType_Values = map[string]Databricks_ComputeType{
	"databricks": Databricks_ComputeType_Databricks,
}

type Databricks_ComputeType_STATUS string

const Databricks_ComputeType_STATUS_Databricks = Databricks_ComputeType_STATUS("Databricks")

// Mapping from string to Databricks_ComputeType_STATUS
var databricks_ComputeType_STATUS_Values = map[string]Databricks_ComputeType_STATUS{
	"databricks": Databricks_ComputeType_STATUS_Databricks,
}

type Databricks_ProvisioningState_STATUS string

const (
	Databricks_ProvisioningState_STATUS_Canceled  = Databricks_ProvisioningState_STATUS("Canceled")
	Databricks_ProvisioningState_STATUS_Creating  = Databricks_ProvisioningState_STATUS("Creating")
	Databricks_ProvisioningState_STATUS_Deleting  = Databricks_ProvisioningState_STATUS("Deleting")
	Databricks_ProvisioningState_STATUS_Failed    = Databricks_ProvisioningState_STATUS("Failed")
	Databricks_ProvisioningState_STATUS_Succeeded = Databricks_ProvisioningState_STATUS("Succeeded")
	Databricks_ProvisioningState_STATUS_Unknown   = Databricks_ProvisioningState_STATUS("Unknown")
	Databricks_ProvisioningState_STATUS_Updating  = Databricks_ProvisioningState_STATUS("Updating")
)

// Mapping from string to Databricks_ProvisioningState_STATUS
var databricks_ProvisioningState_STATUS_Values = map[string]Databricks_ProvisioningState_STATUS{
	"canceled":  Databricks_ProvisioningState_STATUS_Canceled,
	"creating":  Databricks_ProvisioningState_STATUS_Creating,
	"deleting":  Databricks_ProvisioningState_STATUS_Deleting,
	"failed":    Databricks_ProvisioningState_STATUS_Failed,
	"succeeded": Databricks_ProvisioningState_STATUS_Succeeded,
	"unknown":   Databricks_ProvisioningState_STATUS_Unknown,
	"updating":  Databricks_ProvisioningState_STATUS_Updating,
}

// Properties of Databricks
type DatabricksProperties struct {
	// DatabricksAccessToken: Databricks access token
	DatabricksAccessToken *genruntime.SecretReference `json:"databricksAccessToken,omitempty"`

	// WorkspaceUrl: Workspace Url
	WorkspaceUrl *string `json:"workspaceUrl,omitempty"`
}

var _ genruntime.ARMTransformer = &DatabricksProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *DatabricksProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.DatabricksProperties{}

	// Set property "DatabricksAccessToken":
	if properties.DatabricksAccessToken != nil {
		databricksAccessTokenSecret, err := resolved.ResolvedSecrets.Lookup(*properties.DatabricksAccessToken)
		if err != nil {
			return nil, eris.Wrap(err, "looking up secret for property DatabricksAccessToken")
		}
		databricksAccessToken := databricksAccessTokenSecret
		result.DatabricksAccessToken = &databricksAccessToken
	}

	// Set property "WorkspaceUrl":
	if properties.WorkspaceUrl != nil {
		workspaceUrl := *properties.WorkspaceUrl
		result.WorkspaceUrl = &workspaceUrl
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *DatabricksProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DatabricksProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *DatabricksProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DatabricksProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DatabricksProperties, got %T", armInput)
	}

	// no assignment for property "DatabricksAccessToken"

	// Set property "WorkspaceUrl":
	if typedInput.WorkspaceUrl != nil {
		workspaceUrl := *typedInput.WorkspaceUrl
		properties.WorkspaceUrl = &workspaceUrl
	}

	// No error
	return nil
}

// AssignProperties_From_DatabricksProperties populates our DatabricksProperties from the provided source DatabricksProperties
func (properties *DatabricksProperties) AssignProperties_From_DatabricksProperties(source *storage.DatabricksProperties) error {

	// DatabricksAccessToken
	if source.DatabricksAccessToken != nil {
		databricksAccessToken := source.DatabricksAccessToken.Copy()
		properties.DatabricksAccessToken = &databricksAccessToken
	} else {
		properties.DatabricksAccessToken = nil
	}

	// WorkspaceUrl
	properties.WorkspaceUrl = genruntime.ClonePointerToString(source.WorkspaceUrl)

	// No error
	return nil
}

// AssignProperties_To_DatabricksProperties populates the provided destination DatabricksProperties from our DatabricksProperties
func (properties *DatabricksProperties) AssignProperties_To_DatabricksProperties(destination *storage.DatabricksProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DatabricksAccessToken
	if properties.DatabricksAccessToken != nil {
		databricksAccessToken := properties.DatabricksAccessToken.Copy()
		destination.DatabricksAccessToken = &databricksAccessToken
	} else {
		destination.DatabricksAccessToken = nil
	}

	// WorkspaceUrl
	destination.WorkspaceUrl = genruntime.ClonePointerToString(properties.WorkspaceUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Properties of Databricks
type DatabricksProperties_STATUS struct {
	// WorkspaceUrl: Workspace Url
	WorkspaceUrl *string `json:"workspaceUrl,omitempty"`
}

var _ genruntime.FromARMConverter = &DatabricksProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *DatabricksProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DatabricksProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *DatabricksProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DatabricksProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DatabricksProperties_STATUS, got %T", armInput)
	}

	// Set property "WorkspaceUrl":
	if typedInput.WorkspaceUrl != nil {
		workspaceUrl := *typedInput.WorkspaceUrl
		properties.WorkspaceUrl = &workspaceUrl
	}

	// No error
	return nil
}

// AssignProperties_From_DatabricksProperties_STATUS populates our DatabricksProperties_STATUS from the provided source DatabricksProperties_STATUS
func (properties *DatabricksProperties_STATUS) AssignProperties_From_DatabricksProperties_STATUS(source *storage.DatabricksProperties_STATUS) error {

	// WorkspaceUrl
	properties.WorkspaceUrl = genruntime.ClonePointerToString(source.WorkspaceUrl)

	// No error
	return nil
}

// AssignProperties_To_DatabricksProperties_STATUS populates the provided destination DatabricksProperties_STATUS from our DatabricksProperties_STATUS
func (properties *DatabricksProperties_STATUS) AssignProperties_To_DatabricksProperties_STATUS(destination *storage.DatabricksProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// WorkspaceUrl
	destination.WorkspaceUrl = genruntime.ClonePointerToString(properties.WorkspaceUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"DataFactory"}
type DataFactory_ComputeType string

const DataFactory_ComputeType_DataFactory = DataFactory_ComputeType("DataFactory")

// Mapping from string to DataFactory_ComputeType
var dataFactory_ComputeType_Values = map[string]DataFactory_ComputeType{
	"datafactory": DataFactory_ComputeType_DataFactory,
}

type DataFactory_ComputeType_STATUS string

const DataFactory_ComputeType_STATUS_DataFactory = DataFactory_ComputeType_STATUS("DataFactory")

// Mapping from string to DataFactory_ComputeType_STATUS
var dataFactory_ComputeType_STATUS_Values = map[string]DataFactory_ComputeType_STATUS{
	"datafactory": DataFactory_ComputeType_STATUS_DataFactory,
}

type DataFactory_ProvisioningState_STATUS string

const (
	DataFactory_ProvisioningState_STATUS_Canceled  = DataFactory_ProvisioningState_STATUS("Canceled")
	DataFactory_ProvisioningState_STATUS_Creating  = DataFactory_ProvisioningState_STATUS("Creating")
	DataFactory_ProvisioningState_STATUS_Deleting  = DataFactory_ProvisioningState_STATUS("Deleting")
	DataFactory_ProvisioningState_STATUS_Failed    = DataFactory_ProvisioningState_STATUS("Failed")
	DataFactory_ProvisioningState_STATUS_Succeeded = DataFactory_ProvisioningState_STATUS("Succeeded")
	DataFactory_ProvisioningState_STATUS_Unknown   = DataFactory_ProvisioningState_STATUS("Unknown")
	DataFactory_ProvisioningState_STATUS_Updating  = DataFactory_ProvisioningState_STATUS("Updating")
)

// Mapping from string to DataFactory_ProvisioningState_STATUS
var dataFactory_ProvisioningState_STATUS_Values = map[string]DataFactory_ProvisioningState_STATUS{
	"canceled":  DataFactory_ProvisioningState_STATUS_Canceled,
	"creating":  DataFactory_ProvisioningState_STATUS_Creating,
	"deleting":  DataFactory_ProvisioningState_STATUS_Deleting,
	"failed":    DataFactory_ProvisioningState_STATUS_Failed,
	"succeeded": DataFactory_ProvisioningState_STATUS_Succeeded,
	"unknown":   DataFactory_ProvisioningState_STATUS_Unknown,
	"updating":  DataFactory_ProvisioningState_STATUS_Updating,
}

// +kubebuilder:validation:Enum={"DataLakeAnalytics"}
type DataLakeAnalytics_ComputeType string

const DataLakeAnalytics_ComputeType_DataLakeAnalytics = DataLakeAnalytics_ComputeType("DataLakeAnalytics")

// Mapping from string to DataLakeAnalytics_ComputeType
var dataLakeAnalytics_ComputeType_Values = map[string]DataLakeAnalytics_ComputeType{
	"datalakeanalytics": DataLakeAnalytics_ComputeType_DataLakeAnalytics,
}

type DataLakeAnalytics_ComputeType_STATUS string

const DataLakeAnalytics_ComputeType_STATUS_DataLakeAnalytics = DataLakeAnalytics_ComputeType_STATUS("DataLakeAnalytics")

// Mapping from string to DataLakeAnalytics_ComputeType_STATUS
var dataLakeAnalytics_ComputeType_STATUS_Values = map[string]DataLakeAnalytics_ComputeType_STATUS{
	"datalakeanalytics": DataLakeAnalytics_ComputeType_STATUS_DataLakeAnalytics,
}

type DataLakeAnalytics_Properties struct {
	// DataLakeStoreAccountName: DataLake Store Account Name
	DataLakeStoreAccountName *string `json:"dataLakeStoreAccountName,omitempty"`
}

var _ genruntime.ARMTransformer = &DataLakeAnalytics_Properties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *DataLakeAnalytics_Properties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.DataLakeAnalytics_Properties{}

	// Set property "DataLakeStoreAccountName":
	if properties.DataLakeStoreAccountName != nil {
		dataLakeStoreAccountName := *properties.DataLakeStoreAccountName
		result.DataLakeStoreAccountName = &dataLakeStoreAccountName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *DataLakeAnalytics_Properties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DataLakeAnalytics_Properties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *DataLakeAnalytics_Properties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DataLakeAnalytics_Properties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DataLakeAnalytics_Properties, got %T", armInput)
	}

	// Set property "DataLakeStoreAccountName":
	if typedInput.DataLakeStoreAccountName != nil {
		dataLakeStoreAccountName := *typedInput.DataLakeStoreAccountName
		properties.DataLakeStoreAccountName = &dataLakeStoreAccountName
	}

	// No error
	return nil
}

// AssignProperties_From_DataLakeAnalytics_Properties populates our DataLakeAnalytics_Properties from the provided source DataLakeAnalytics_Properties
func (properties *DataLakeAnalytics_Properties) AssignProperties_From_DataLakeAnalytics_Properties(source *storage.DataLakeAnalytics_Properties) error {

	// DataLakeStoreAccountName
	properties.DataLakeStoreAccountName = genruntime.ClonePointerToString(source.DataLakeStoreAccountName)

	// No error
	return nil
}

// AssignProperties_To_DataLakeAnalytics_Properties populates the provided destination DataLakeAnalytics_Properties from our DataLakeAnalytics_Properties
func (properties *DataLakeAnalytics_Properties) AssignProperties_To_DataLakeAnalytics_Properties(destination *storage.DataLakeAnalytics_Properties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataLakeStoreAccountName
	destination.DataLakeStoreAccountName = genruntime.ClonePointerToString(properties.DataLakeStoreAccountName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DataLakeAnalytics_Properties_STATUS struct {
	// DataLakeStoreAccountName: DataLake Store Account Name
	DataLakeStoreAccountName *string `json:"dataLakeStoreAccountName,omitempty"`
}

var _ genruntime.FromARMConverter = &DataLakeAnalytics_Properties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *DataLakeAnalytics_Properties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DataLakeAnalytics_Properties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *DataLakeAnalytics_Properties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DataLakeAnalytics_Properties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DataLakeAnalytics_Properties_STATUS, got %T", armInput)
	}

	// Set property "DataLakeStoreAccountName":
	if typedInput.DataLakeStoreAccountName != nil {
		dataLakeStoreAccountName := *typedInput.DataLakeStoreAccountName
		properties.DataLakeStoreAccountName = &dataLakeStoreAccountName
	}

	// No error
	return nil
}

// AssignProperties_From_DataLakeAnalytics_Properties_STATUS populates our DataLakeAnalytics_Properties_STATUS from the provided source DataLakeAnalytics_Properties_STATUS
func (properties *DataLakeAnalytics_Properties_STATUS) AssignProperties_From_DataLakeAnalytics_Properties_STATUS(source *storage.DataLakeAnalytics_Properties_STATUS) error {

	// DataLakeStoreAccountName
	properties.DataLakeStoreAccountName = genruntime.ClonePointerToString(source.DataLakeStoreAccountName)

	// No error
	return nil
}

// AssignProperties_To_DataLakeAnalytics_Properties_STATUS populates the provided destination DataLakeAnalytics_Properties_STATUS from our DataLakeAnalytics_Properties_STATUS
func (properties *DataLakeAnalytics_Properties_STATUS) AssignProperties_To_DataLakeAnalytics_Properties_STATUS(destination *storage.DataLakeAnalytics_Properties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataLakeStoreAccountName
	destination.DataLakeStoreAccountName = genruntime.ClonePointerToString(properties.DataLakeStoreAccountName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DataLakeAnalytics_ProvisioningState_STATUS string

const (
	DataLakeAnalytics_ProvisioningState_STATUS_Canceled  = DataLakeAnalytics_ProvisioningState_STATUS("Canceled")
	DataLakeAnalytics_ProvisioningState_STATUS_Creating  = DataLakeAnalytics_ProvisioningState_STATUS("Creating")
	DataLakeAnalytics_ProvisioningState_STATUS_Deleting  = DataLakeAnalytics_ProvisioningState_STATUS("Deleting")
	DataLakeAnalytics_ProvisioningState_STATUS_Failed    = DataLakeAnalytics_ProvisioningState_STATUS("Failed")
	DataLakeAnalytics_ProvisioningState_STATUS_Succeeded = DataLakeAnalytics_ProvisioningState_STATUS("Succeeded")
	DataLakeAnalytics_ProvisioningState_STATUS_Unknown   = DataLakeAnalytics_ProvisioningState_STATUS("Unknown")
	DataLakeAnalytics_ProvisioningState_STATUS_Updating  = DataLakeAnalytics_ProvisioningState_STATUS("Updating")
)

// Mapping from string to DataLakeAnalytics_ProvisioningState_STATUS
var dataLakeAnalytics_ProvisioningState_STATUS_Values = map[string]DataLakeAnalytics_ProvisioningState_STATUS{
	"canceled":  DataLakeAnalytics_ProvisioningState_STATUS_Canceled,
	"creating":  DataLakeAnalytics_ProvisioningState_STATUS_Creating,
	"deleting":  DataLakeAnalytics_ProvisioningState_STATUS_Deleting,
	"failed":    DataLakeAnalytics_ProvisioningState_STATUS_Failed,
	"succeeded": DataLakeAnalytics_ProvisioningState_STATUS_Succeeded,
	"unknown":   DataLakeAnalytics_ProvisioningState_STATUS_Unknown,
	"updating":  DataLakeAnalytics_ProvisioningState_STATUS_Updating,
}

// Common error response for all Azure Resource Manager APIs to return error details for failed operations. (This also
// follows the OData error response format.).
type ErrorResponse_STATUS struct {
	// Error: The error object.
	Error *ErrorDetail_STATUS `json:"error,omitempty"`
}

var _ genruntime.FromARMConverter = &ErrorResponse_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (response *ErrorResponse_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ErrorResponse_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (response *ErrorResponse_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ErrorResponse_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ErrorResponse_STATUS, got %T", armInput)
	}

	// Set property "Error":
	if typedInput.Error != nil {
		var error1 ErrorDetail_STATUS
		err := error1.PopulateFromARM(owner, *typedInput.Error)
		if err != nil {
			return err
		}
		error := error1
		response.Error = &error
	}

	// No error
	return nil
}

// AssignProperties_From_ErrorResponse_STATUS populates our ErrorResponse_STATUS from the provided source ErrorResponse_STATUS
func (response *ErrorResponse_STATUS) AssignProperties_From_ErrorResponse_STATUS(source *storage.ErrorResponse_STATUS) error {

	// Error
	if source.Error != nil {
		var error ErrorDetail_STATUS
		err := error.AssignProperties_From_ErrorDetail_STATUS(source.Error)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ErrorDetail_STATUS() to populate field Error")
		}
		response.Error = &error
	} else {
		response.Error = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ErrorResponse_STATUS populates the provided destination ErrorResponse_STATUS from our ErrorResponse_STATUS
func (response *ErrorResponse_STATUS) AssignProperties_To_ErrorResponse_STATUS(destination *storage.ErrorResponse_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Error
	if response.Error != nil {
		var error storage.ErrorDetail_STATUS
		err := response.Error.AssignProperties_To_ErrorDetail_STATUS(&error)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ErrorDetail_STATUS() to populate field Error")
		}
		destination.Error = &error
	} else {
		destination.Error = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"HDInsight"}
type HDInsight_ComputeType string

const HDInsight_ComputeType_HDInsight = HDInsight_ComputeType("HDInsight")

// Mapping from string to HDInsight_ComputeType
var hDInsight_ComputeType_Values = map[string]HDInsight_ComputeType{
	"hdinsight": HDInsight_ComputeType_HDInsight,
}

type HDInsight_ComputeType_STATUS string

const HDInsight_ComputeType_STATUS_HDInsight = HDInsight_ComputeType_STATUS("HDInsight")

// Mapping from string to HDInsight_ComputeType_STATUS
var hDInsight_ComputeType_STATUS_Values = map[string]HDInsight_ComputeType_STATUS{
	"hdinsight": HDInsight_ComputeType_STATUS_HDInsight,
}

type HDInsight_ProvisioningState_STATUS string

const (
	HDInsight_ProvisioningState_STATUS_Canceled  = HDInsight_ProvisioningState_STATUS("Canceled")
	HDInsight_ProvisioningState_STATUS_Creating  = HDInsight_ProvisioningState_STATUS("Creating")
	HDInsight_ProvisioningState_STATUS_Deleting  = HDInsight_ProvisioningState_STATUS("Deleting")
	HDInsight_ProvisioningState_STATUS_Failed    = HDInsight_ProvisioningState_STATUS("Failed")
	HDInsight_ProvisioningState_STATUS_Succeeded = HDInsight_ProvisioningState_STATUS("Succeeded")
	HDInsight_ProvisioningState_STATUS_Unknown   = HDInsight_ProvisioningState_STATUS("Unknown")
	HDInsight_ProvisioningState_STATUS_Updating  = HDInsight_ProvisioningState_STATUS("Updating")
)

// Mapping from string to HDInsight_ProvisioningState_STATUS
var hDInsight_ProvisioningState_STATUS_Values = map[string]HDInsight_ProvisioningState_STATUS{
	"canceled":  HDInsight_ProvisioningState_STATUS_Canceled,
	"creating":  HDInsight_ProvisioningState_STATUS_Creating,
	"deleting":  HDInsight_ProvisioningState_STATUS_Deleting,
	"failed":    HDInsight_ProvisioningState_STATUS_Failed,
	"succeeded": HDInsight_ProvisioningState_STATUS_Succeeded,
	"unknown":   HDInsight_ProvisioningState_STATUS_Unknown,
	"updating":  HDInsight_ProvisioningState_STATUS_Updating,
}

// HDInsight compute properties
type HDInsightProperties struct {
	// Address: Public IP address of the master node of the cluster.
	Address *string `json:"address,omitempty"`

	// AdministratorAccount: Admin credentials for master node of the cluster
	AdministratorAccount *VirtualMachineSshCredentials `json:"administratorAccount,omitempty"`

	// SshPort: Port open for ssh connections on the master node of the cluster.
	SshPort *int `json:"sshPort,omitempty"`
}

var _ genruntime.ARMTransformer = &HDInsightProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *HDInsightProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.HDInsightProperties{}

	// Set property "Address":
	if properties.Address != nil {
		address := *properties.Address
		result.Address = &address
	}

	// Set property "AdministratorAccount":
	if properties.AdministratorAccount != nil {
		administratorAccount_ARM, err := (*properties.AdministratorAccount).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		administratorAccount := *administratorAccount_ARM.(*arm.VirtualMachineSshCredentials)
		result.AdministratorAccount = &administratorAccount
	}

	// Set property "SshPort":
	if properties.SshPort != nil {
		sshPort := *properties.SshPort
		result.SshPort = &sshPort
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *HDInsightProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HDInsightProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *HDInsightProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HDInsightProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HDInsightProperties, got %T", armInput)
	}

	// Set property "Address":
	if typedInput.Address != nil {
		address := *typedInput.Address
		properties.Address = &address
	}

	// Set property "AdministratorAccount":
	if typedInput.AdministratorAccount != nil {
		var administratorAccount1 VirtualMachineSshCredentials
		err := administratorAccount1.PopulateFromARM(owner, *typedInput.AdministratorAccount)
		if err != nil {
			return err
		}
		administratorAccount := administratorAccount1
		properties.AdministratorAccount = &administratorAccount
	}

	// Set property "SshPort":
	if typedInput.SshPort != nil {
		sshPort := *typedInput.SshPort
		properties.SshPort = &sshPort
	}

	// No error
	return nil
}

// AssignProperties_From_HDInsightProperties populates our HDInsightProperties from the provided source HDInsightProperties
func (properties *HDInsightProperties) AssignProperties_From_HDInsightProperties(source *storage.HDInsightProperties) error {

	// Address
	properties.Address = genruntime.ClonePointerToString(source.Address)

	// AdministratorAccount
	if source.AdministratorAccount != nil {
		var administratorAccount VirtualMachineSshCredentials
		err := administratorAccount.AssignProperties_From_VirtualMachineSshCredentials(source.AdministratorAccount)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineSshCredentials() to populate field AdministratorAccount")
		}
		properties.AdministratorAccount = &administratorAccount
	} else {
		properties.AdministratorAccount = nil
	}

	// SshPort
	properties.SshPort = genruntime.ClonePointerToInt(source.SshPort)

	// No error
	return nil
}

// AssignProperties_To_HDInsightProperties populates the provided destination HDInsightProperties from our HDInsightProperties
func (properties *HDInsightProperties) AssignProperties_To_HDInsightProperties(destination *storage.HDInsightProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Address
	destination.Address = genruntime.ClonePointerToString(properties.Address)

	// AdministratorAccount
	if properties.AdministratorAccount != nil {
		var administratorAccount storage.VirtualMachineSshCredentials
		err := properties.AdministratorAccount.AssignProperties_To_VirtualMachineSshCredentials(&administratorAccount)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineSshCredentials() to populate field AdministratorAccount")
		}
		destination.AdministratorAccount = &administratorAccount
	} else {
		destination.AdministratorAccount = nil
	}

	// SshPort
	destination.SshPort = genruntime.ClonePointerToInt(properties.SshPort)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// HDInsight compute properties
type HDInsightProperties_STATUS struct {
	// Address: Public IP address of the master node of the cluster.
	Address *string `json:"address,omitempty"`

	// AdministratorAccount: Admin credentials for master node of the cluster
	AdministratorAccount *VirtualMachineSshCredentials_STATUS `json:"administratorAccount,omitempty"`

	// SshPort: Port open for ssh connections on the master node of the cluster.
	SshPort *int `json:"sshPort,omitempty"`
}

var _ genruntime.FromARMConverter = &HDInsightProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *HDInsightProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HDInsightProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *HDInsightProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HDInsightProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HDInsightProperties_STATUS, got %T", armInput)
	}

	// Set property "Address":
	if typedInput.Address != nil {
		address := *typedInput.Address
		properties.Address = &address
	}

	// Set property "AdministratorAccount":
	if typedInput.AdministratorAccount != nil {
		var administratorAccount1 VirtualMachineSshCredentials_STATUS
		err := administratorAccount1.PopulateFromARM(owner, *typedInput.AdministratorAccount)
		if err != nil {
			return err
		}
		administratorAccount := administratorAccount1
		properties.AdministratorAccount = &administratorAccount
	}

	// Set property "SshPort":
	if typedInput.SshPort != nil {
		sshPort := *typedInput.SshPort
		properties.SshPort = &sshPort
	}

	// No error
	return nil
}

// AssignProperties_From_HDInsightProperties_STATUS populates our HDInsightProperties_STATUS from the provided source HDInsightProperties_STATUS
func (properties *HDInsightProperties_STATUS) AssignProperties_From_HDInsightProperties_STATUS(source *storage.HDInsightProperties_STATUS) error {

	// Address
	properties.Address = genruntime.ClonePointerToString(source.Address)

	// AdministratorAccount
	if source.AdministratorAccount != nil {
		var administratorAccount VirtualMachineSshCredentials_STATUS
		err := administratorAccount.AssignProperties_From_VirtualMachineSshCredentials_STATUS(source.AdministratorAccount)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineSshCredentials_STATUS() to populate field AdministratorAccount")
		}
		properties.AdministratorAccount = &administratorAccount
	} else {
		properties.AdministratorAccount = nil
	}

	// SshPort
	properties.SshPort = genruntime.ClonePointerToInt(source.SshPort)

	// No error
	return nil
}

// AssignProperties_To_HDInsightProperties_STATUS populates the provided destination HDInsightProperties_STATUS from our HDInsightProperties_STATUS
func (properties *HDInsightProperties_STATUS) AssignProperties_To_HDInsightProperties_STATUS(destination *storage.HDInsightProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Address
	destination.Address = genruntime.ClonePointerToString(properties.Address)

	// AdministratorAccount
	if properties.AdministratorAccount != nil {
		var administratorAccount storage.VirtualMachineSshCredentials_STATUS
		err := properties.AdministratorAccount.AssignProperties_To_VirtualMachineSshCredentials_STATUS(&administratorAccount)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineSshCredentials_STATUS() to populate field AdministratorAccount")
		}
		destination.AdministratorAccount = &administratorAccount
	} else {
		destination.AdministratorAccount = nil
	}

	// SshPort
	destination.SshPort = genruntime.ClonePointerToInt(properties.SshPort)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Kubernetes"}
type Kubernetes_ComputeType string

const Kubernetes_ComputeType_Kubernetes = Kubernetes_ComputeType("Kubernetes")

// Mapping from string to Kubernetes_ComputeType
var kubernetes_ComputeType_Values = map[string]Kubernetes_ComputeType{
	"kubernetes": Kubernetes_ComputeType_Kubernetes,
}

type Kubernetes_ComputeType_STATUS string

const Kubernetes_ComputeType_STATUS_Kubernetes = Kubernetes_ComputeType_STATUS("Kubernetes")

// Mapping from string to Kubernetes_ComputeType_STATUS
var kubernetes_ComputeType_STATUS_Values = map[string]Kubernetes_ComputeType_STATUS{
	"kubernetes": Kubernetes_ComputeType_STATUS_Kubernetes,
}

type Kubernetes_ProvisioningState_STATUS string

const (
	Kubernetes_ProvisioningState_STATUS_Canceled  = Kubernetes_ProvisioningState_STATUS("Canceled")
	Kubernetes_ProvisioningState_STATUS_Creating  = Kubernetes_ProvisioningState_STATUS("Creating")
	Kubernetes_ProvisioningState_STATUS_Deleting  = Kubernetes_ProvisioningState_STATUS("Deleting")
	Kubernetes_ProvisioningState_STATUS_Failed    = Kubernetes_ProvisioningState_STATUS("Failed")
	Kubernetes_ProvisioningState_STATUS_Succeeded = Kubernetes_ProvisioningState_STATUS("Succeeded")
	Kubernetes_ProvisioningState_STATUS_Unknown   = Kubernetes_ProvisioningState_STATUS("Unknown")
	Kubernetes_ProvisioningState_STATUS_Updating  = Kubernetes_ProvisioningState_STATUS("Updating")
)

// Mapping from string to Kubernetes_ProvisioningState_STATUS
var kubernetes_ProvisioningState_STATUS_Values = map[string]Kubernetes_ProvisioningState_STATUS{
	"canceled":  Kubernetes_ProvisioningState_STATUS_Canceled,
	"creating":  Kubernetes_ProvisioningState_STATUS_Creating,
	"deleting":  Kubernetes_ProvisioningState_STATUS_Deleting,
	"failed":    Kubernetes_ProvisioningState_STATUS_Failed,
	"succeeded": Kubernetes_ProvisioningState_STATUS_Succeeded,
	"unknown":   Kubernetes_ProvisioningState_STATUS_Unknown,
	"updating":  Kubernetes_ProvisioningState_STATUS_Updating,
}

// Kubernetes properties
type KubernetesProperties struct {
	// DefaultInstanceType: Default instance type
	DefaultInstanceType *string `json:"defaultInstanceType,omitempty"`

	// ExtensionInstanceReleaseTrain: Extension instance release train.
	ExtensionInstanceReleaseTrain *string `json:"extensionInstanceReleaseTrain,omitempty"`

	// ExtensionPrincipalId: Extension principal-id.
	ExtensionPrincipalId *string `json:"extensionPrincipalId,omitempty"`

	// InstanceTypes: Instance Type Schema
	InstanceTypes map[string]InstanceTypeSchema `json:"instanceTypes,omitempty"`

	// Namespace: Compute namespace
	Namespace *string `json:"namespace,omitempty"`

	// RelayConnectionString: Relay connection string.
	RelayConnectionString *genruntime.SecretReference `json:"relayConnectionString,omitempty"`

	// ServiceBusConnectionString: ServiceBus connection string.
	ServiceBusConnectionString *genruntime.SecretReference `json:"serviceBusConnectionString,omitempty"`

	// VcName: VC name.
	VcName *string `json:"vcName,omitempty"`
}

var _ genruntime.ARMTransformer = &KubernetesProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *KubernetesProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.KubernetesProperties{}

	// Set property "DefaultInstanceType":
	if properties.DefaultInstanceType != nil {
		defaultInstanceType := *properties.DefaultInstanceType
		result.DefaultInstanceType = &defaultInstanceType
	}

	// Set property "ExtensionInstanceReleaseTrain":
	if properties.ExtensionInstanceReleaseTrain != nil {
		extensionInstanceReleaseTrain := *properties.ExtensionInstanceReleaseTrain
		result.ExtensionInstanceReleaseTrain = &extensionInstanceReleaseTrain
	}

	// Set property "ExtensionPrincipalId":
	if properties.ExtensionPrincipalId != nil {
		extensionPrincipalId := *properties.ExtensionPrincipalId
		result.ExtensionPrincipalId = &extensionPrincipalId
	}

	// Set property "InstanceTypes":
	if properties.InstanceTypes != nil {
		result.InstanceTypes = make(map[string]arm.InstanceTypeSchema, len(properties.InstanceTypes))
		for key, value := range properties.InstanceTypes {
			value_ARM, err := value.ConvertToARM(resolved)
			if err != nil {
				return nil, err
			}
			result.InstanceTypes[key] = *value_ARM.(*arm.InstanceTypeSchema)
		}
	}

	// Set property "Namespace":
	if properties.Namespace != nil {
		namespace := *properties.Namespace
		result.Namespace = &namespace
	}

	// Set property "RelayConnectionString":
	if properties.RelayConnectionString != nil {
		relayConnectionStringSecret, err := resolved.ResolvedSecrets.Lookup(*properties.RelayConnectionString)
		if err != nil {
			return nil, eris.Wrap(err, "looking up secret for property RelayConnectionString")
		}
		relayConnectionString := relayConnectionStringSecret
		result.RelayConnectionString = &relayConnectionString
	}

	// Set property "ServiceBusConnectionString":
	if properties.ServiceBusConnectionString != nil {
		serviceBusConnectionStringSecret, err := resolved.ResolvedSecrets.Lookup(*properties.ServiceBusConnectionString)
		if err != nil {
			return nil, eris.Wrap(err, "looking up secret for property ServiceBusConnectionString")
		}
		serviceBusConnectionString := serviceBusConnectionStringSecret
		result.ServiceBusConnectionString = &serviceBusConnectionString
	}

	// Set property "VcName":
	if properties.VcName != nil {
		vcName := *properties.VcName
		result.VcName = &vcName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *KubernetesProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KubernetesProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *KubernetesProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KubernetesProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KubernetesProperties, got %T", armInput)
	}

	// Set property "DefaultInstanceType":
	if typedInput.DefaultInstanceType != nil {
		defaultInstanceType := *typedInput.DefaultInstanceType
		properties.DefaultInstanceType = &defaultInstanceType
	}

	// Set property "ExtensionInstanceReleaseTrain":
	if typedInput.ExtensionInstanceReleaseTrain != nil {
		extensionInstanceReleaseTrain := *typedInput.ExtensionInstanceReleaseTrain
		properties.ExtensionInstanceReleaseTrain = &extensionInstanceReleaseTrain
	}

	// Set property "ExtensionPrincipalId":
	if typedInput.ExtensionPrincipalId != nil {
		extensionPrincipalId := *typedInput.ExtensionPrincipalId
		properties.ExtensionPrincipalId = &extensionPrincipalId
	}

	// Set property "InstanceTypes":
	if typedInput.InstanceTypes != nil {
		properties.InstanceTypes = make(map[string]InstanceTypeSchema, len(typedInput.InstanceTypes))
		for key, value := range typedInput.InstanceTypes {
			var value1 InstanceTypeSchema
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			properties.InstanceTypes[key] = value1
		}
	}

	// Set property "Namespace":
	if typedInput.Namespace != nil {
		namespace := *typedInput.Namespace
		properties.Namespace = &namespace
	}

	// no assignment for property "RelayConnectionString"

	// no assignment for property "ServiceBusConnectionString"

	// Set property "VcName":
	if typedInput.VcName != nil {
		vcName := *typedInput.VcName
		properties.VcName = &vcName
	}

	// No error
	return nil
}

// AssignProperties_From_KubernetesProperties populates our KubernetesProperties from the provided source KubernetesProperties
func (properties *KubernetesProperties) AssignProperties_From_KubernetesProperties(source *storage.KubernetesProperties) error {

	// DefaultInstanceType
	properties.DefaultInstanceType = genruntime.ClonePointerToString(source.DefaultInstanceType)

	// ExtensionInstanceReleaseTrain
	properties.ExtensionInstanceReleaseTrain = genruntime.ClonePointerToString(source.ExtensionInstanceReleaseTrain)

	// ExtensionPrincipalId
	properties.ExtensionPrincipalId = genruntime.ClonePointerToString(source.ExtensionPrincipalId)

	// InstanceTypes
	if source.InstanceTypes != nil {
		instanceTypeMap := make(map[string]InstanceTypeSchema, len(source.InstanceTypes))
		for instanceTypeKey, instanceTypeValue := range source.InstanceTypes {
			// Shadow the loop variable to avoid aliasing
			instanceTypeValue := instanceTypeValue
			var instanceType InstanceTypeSchema
			err := instanceType.AssignProperties_From_InstanceTypeSchema(&instanceTypeValue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_InstanceTypeSchema() to populate field InstanceTypes")
			}
			instanceTypeMap[instanceTypeKey] = instanceType
		}
		properties.InstanceTypes = instanceTypeMap
	} else {
		properties.InstanceTypes = nil
	}

	// Namespace
	properties.Namespace = genruntime.ClonePointerToString(source.Namespace)

	// RelayConnectionString
	if source.RelayConnectionString != nil {
		relayConnectionString := source.RelayConnectionString.Copy()
		properties.RelayConnectionString = &relayConnectionString
	} else {
		properties.RelayConnectionString = nil
	}

	// ServiceBusConnectionString
	if source.ServiceBusConnectionString != nil {
		serviceBusConnectionString := source.ServiceBusConnectionString.Copy()
		properties.ServiceBusConnectionString = &serviceBusConnectionString
	} else {
		properties.ServiceBusConnectionString = nil
	}

	// VcName
	properties.VcName = genruntime.ClonePointerToString(source.VcName)

	// No error
	return nil
}

// AssignProperties_To_KubernetesProperties populates the provided destination KubernetesProperties from our KubernetesProperties
func (properties *KubernetesProperties) AssignProperties_To_KubernetesProperties(destination *storage.KubernetesProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DefaultInstanceType
	destination.DefaultInstanceType = genruntime.ClonePointerToString(properties.DefaultInstanceType)

	// ExtensionInstanceReleaseTrain
	destination.ExtensionInstanceReleaseTrain = genruntime.ClonePointerToString(properties.ExtensionInstanceReleaseTrain)

	// ExtensionPrincipalId
	destination.ExtensionPrincipalId = genruntime.ClonePointerToString(properties.ExtensionPrincipalId)

	// InstanceTypes
	if properties.InstanceTypes != nil {
		instanceTypeMap := make(map[string]storage.InstanceTypeSchema, len(properties.InstanceTypes))
		for instanceTypeKey, instanceTypeValue := range properties.InstanceTypes {
			// Shadow the loop variable to avoid aliasing
			instanceTypeValue := instanceTypeValue
			var instanceType storage.InstanceTypeSchema
			err := instanceTypeValue.AssignProperties_To_InstanceTypeSchema(&instanceType)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_InstanceTypeSchema() to populate field InstanceTypes")
			}
			instanceTypeMap[instanceTypeKey] = instanceType
		}
		destination.InstanceTypes = instanceTypeMap
	} else {
		destination.InstanceTypes = nil
	}

	// Namespace
	destination.Namespace = genruntime.ClonePointerToString(properties.Namespace)

	// RelayConnectionString
	if properties.RelayConnectionString != nil {
		relayConnectionString := properties.RelayConnectionString.Copy()
		destination.RelayConnectionString = &relayConnectionString
	} else {
		destination.RelayConnectionString = nil
	}

	// ServiceBusConnectionString
	if properties.ServiceBusConnectionString != nil {
		serviceBusConnectionString := properties.ServiceBusConnectionString.Copy()
		destination.ServiceBusConnectionString = &serviceBusConnectionString
	} else {
		destination.ServiceBusConnectionString = nil
	}

	// VcName
	destination.VcName = genruntime.ClonePointerToString(properties.VcName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Kubernetes properties
type KubernetesProperties_STATUS struct {
	// DefaultInstanceType: Default instance type
	DefaultInstanceType *string `json:"defaultInstanceType,omitempty"`

	// ExtensionInstanceReleaseTrain: Extension instance release train.
	ExtensionInstanceReleaseTrain *string `json:"extensionInstanceReleaseTrain,omitempty"`

	// ExtensionPrincipalId: Extension principal-id.
	ExtensionPrincipalId *string `json:"extensionPrincipalId,omitempty"`

	// InstanceTypes: Instance Type Schema
	InstanceTypes map[string]InstanceTypeSchema_STATUS `json:"instanceTypes,omitempty"`

	// Namespace: Compute namespace
	Namespace *string `json:"namespace,omitempty"`

	// VcName: VC name.
	VcName *string `json:"vcName,omitempty"`
}

var _ genruntime.FromARMConverter = &KubernetesProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *KubernetesProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KubernetesProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *KubernetesProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KubernetesProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KubernetesProperties_STATUS, got %T", armInput)
	}

	// Set property "DefaultInstanceType":
	if typedInput.DefaultInstanceType != nil {
		defaultInstanceType := *typedInput.DefaultInstanceType
		properties.DefaultInstanceType = &defaultInstanceType
	}

	// Set property "ExtensionInstanceReleaseTrain":
	if typedInput.ExtensionInstanceReleaseTrain != nil {
		extensionInstanceReleaseTrain := *typedInput.ExtensionInstanceReleaseTrain
		properties.ExtensionInstanceReleaseTrain = &extensionInstanceReleaseTrain
	}

	// Set property "ExtensionPrincipalId":
	if typedInput.ExtensionPrincipalId != nil {
		extensionPrincipalId := *typedInput.ExtensionPrincipalId
		properties.ExtensionPrincipalId = &extensionPrincipalId
	}

	// Set property "InstanceTypes":
	if typedInput.InstanceTypes != nil {
		properties.InstanceTypes = make(map[string]InstanceTypeSchema_STATUS, len(typedInput.InstanceTypes))
		for key, value := range typedInput.InstanceTypes {
			var value1 InstanceTypeSchema_STATUS
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			properties.InstanceTypes[key] = value1
		}
	}

	// Set property "Namespace":
	if typedInput.Namespace != nil {
		namespace := *typedInput.Namespace
		properties.Namespace = &namespace
	}

	// Set property "VcName":
	if typedInput.VcName != nil {
		vcName := *typedInput.VcName
		properties.VcName = &vcName
	}

	// No error
	return nil
}

// AssignProperties_From_KubernetesProperties_STATUS populates our KubernetesProperties_STATUS from the provided source KubernetesProperties_STATUS
func (properties *KubernetesProperties_STATUS) AssignProperties_From_KubernetesProperties_STATUS(source *storage.KubernetesProperties_STATUS) error {

	// DefaultInstanceType
	properties.DefaultInstanceType = genruntime.ClonePointerToString(source.DefaultInstanceType)

	// ExtensionInstanceReleaseTrain
	properties.ExtensionInstanceReleaseTrain = genruntime.ClonePointerToString(source.ExtensionInstanceReleaseTrain)

	// ExtensionPrincipalId
	properties.ExtensionPrincipalId = genruntime.ClonePointerToString(source.ExtensionPrincipalId)

	// InstanceTypes
	if source.InstanceTypes != nil {
		instanceTypeMap := make(map[string]InstanceTypeSchema_STATUS, len(source.InstanceTypes))
		for instanceTypeKey, instanceTypeValue := range source.InstanceTypes {
			// Shadow the loop variable to avoid aliasing
			instanceTypeValue := instanceTypeValue
			var instanceType InstanceTypeSchema_STATUS
			err := instanceType.AssignProperties_From_InstanceTypeSchema_STATUS(&instanceTypeValue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_InstanceTypeSchema_STATUS() to populate field InstanceTypes")
			}
			instanceTypeMap[instanceTypeKey] = instanceType
		}
		properties.InstanceTypes = instanceTypeMap
	} else {
		properties.InstanceTypes = nil
	}

	// Namespace
	properties.Namespace = genruntime.ClonePointerToString(source.Namespace)

	// VcName
	properties.VcName = genruntime.ClonePointerToString(source.VcName)

	// No error
	return nil
}

// AssignProperties_To_KubernetesProperties_STATUS populates the provided destination KubernetesProperties_STATUS from our KubernetesProperties_STATUS
func (properties *KubernetesProperties_STATUS) AssignProperties_To_KubernetesProperties_STATUS(destination *storage.KubernetesProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DefaultInstanceType
	destination.DefaultInstanceType = genruntime.ClonePointerToString(properties.DefaultInstanceType)

	// ExtensionInstanceReleaseTrain
	destination.ExtensionInstanceReleaseTrain = genruntime.ClonePointerToString(properties.ExtensionInstanceReleaseTrain)

	// ExtensionPrincipalId
	destination.ExtensionPrincipalId = genruntime.ClonePointerToString(properties.ExtensionPrincipalId)

	// InstanceTypes
	if properties.InstanceTypes != nil {
		instanceTypeMap := make(map[string]storage.InstanceTypeSchema_STATUS, len(properties.InstanceTypes))
		for instanceTypeKey, instanceTypeValue := range properties.InstanceTypes {
			// Shadow the loop variable to avoid aliasing
			instanceTypeValue := instanceTypeValue
			var instanceType storage.InstanceTypeSchema_STATUS
			err := instanceTypeValue.AssignProperties_To_InstanceTypeSchema_STATUS(&instanceType)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_InstanceTypeSchema_STATUS() to populate field InstanceTypes")
			}
			instanceTypeMap[instanceTypeKey] = instanceType
		}
		destination.InstanceTypes = instanceTypeMap
	} else {
		destination.InstanceTypes = nil
	}

	// Namespace
	destination.Namespace = genruntime.ClonePointerToString(properties.Namespace)

	// VcName
	destination.VcName = genruntime.ClonePointerToString(properties.VcName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"SynapseSpark"}
type SynapseSpark_ComputeType string

const SynapseSpark_ComputeType_SynapseSpark = SynapseSpark_ComputeType("SynapseSpark")

// Mapping from string to SynapseSpark_ComputeType
var synapseSpark_ComputeType_Values = map[string]SynapseSpark_ComputeType{
	"synapsespark": SynapseSpark_ComputeType_SynapseSpark,
}

type SynapseSpark_ComputeType_STATUS string

const SynapseSpark_ComputeType_STATUS_SynapseSpark = SynapseSpark_ComputeType_STATUS("SynapseSpark")

// Mapping from string to SynapseSpark_ComputeType_STATUS
var synapseSpark_ComputeType_STATUS_Values = map[string]SynapseSpark_ComputeType_STATUS{
	"synapsespark": SynapseSpark_ComputeType_STATUS_SynapseSpark,
}

type SynapseSpark_Properties struct {
	// AutoPauseProperties: Auto pause properties.
	AutoPauseProperties *AutoPauseProperties `json:"autoPauseProperties,omitempty"`

	// AutoScaleProperties: Auto scale properties.
	AutoScaleProperties *AutoScaleProperties `json:"autoScaleProperties,omitempty"`

	// NodeCount: The number of compute nodes currently assigned to the compute.
	NodeCount *int `json:"nodeCount,omitempty"`

	// NodeSize: Node size.
	NodeSize *string `json:"nodeSize,omitempty"`

	// NodeSizeFamily: Node size family.
	NodeSizeFamily *string `json:"nodeSizeFamily,omitempty"`

	// PoolName: Pool name.
	PoolName *string `json:"poolName,omitempty"`

	// ResourceGroup: Name of the resource group in which workspace is located.
	ResourceGroup *string `json:"resourceGroup,omitempty"`

	// SparkVersion: Spark version.
	SparkVersion *string `json:"sparkVersion,omitempty"`

	// SubscriptionId: Azure subscription identifier.
	SubscriptionId *string `json:"subscriptionId,omitempty"`

	// WorkspaceName: Name of Azure Machine Learning workspace.
	WorkspaceName *string `json:"workspaceName,omitempty"`
}

var _ genruntime.ARMTransformer = &SynapseSpark_Properties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *SynapseSpark_Properties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.SynapseSpark_Properties{}

	// Set property "AutoPauseProperties":
	if properties.AutoPauseProperties != nil {
		autoPauseProperties_ARM, err := (*properties.AutoPauseProperties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		autoPauseProperties := *autoPauseProperties_ARM.(*arm.AutoPauseProperties)
		result.AutoPauseProperties = &autoPauseProperties
	}

	// Set property "AutoScaleProperties":
	if properties.AutoScaleProperties != nil {
		autoScaleProperties_ARM, err := (*properties.AutoScaleProperties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		autoScaleProperties := *autoScaleProperties_ARM.(*arm.AutoScaleProperties)
		result.AutoScaleProperties = &autoScaleProperties
	}

	// Set property "NodeCount":
	if properties.NodeCount != nil {
		nodeCount := *properties.NodeCount
		result.NodeCount = &nodeCount
	}

	// Set property "NodeSize":
	if properties.NodeSize != nil {
		nodeSize := *properties.NodeSize
		result.NodeSize = &nodeSize
	}

	// Set property "NodeSizeFamily":
	if properties.NodeSizeFamily != nil {
		nodeSizeFamily := *properties.NodeSizeFamily
		result.NodeSizeFamily = &nodeSizeFamily
	}

	// Set property "PoolName":
	if properties.PoolName != nil {
		poolName := *properties.PoolName
		result.PoolName = &poolName
	}

	// Set property "ResourceGroup":
	if properties.ResourceGroup != nil {
		resourceGroup := *properties.ResourceGroup
		result.ResourceGroup = &resourceGroup
	}

	// Set property "SparkVersion":
	if properties.SparkVersion != nil {
		sparkVersion := *properties.SparkVersion
		result.SparkVersion = &sparkVersion
	}

	// Set property "SubscriptionId":
	if properties.SubscriptionId != nil {
		subscriptionId := *properties.SubscriptionId
		result.SubscriptionId = &subscriptionId
	}

	// Set property "WorkspaceName":
	if properties.WorkspaceName != nil {
		workspaceName := *properties.WorkspaceName
		result.WorkspaceName = &workspaceName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *SynapseSpark_Properties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SynapseSpark_Properties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *SynapseSpark_Properties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SynapseSpark_Properties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SynapseSpark_Properties, got %T", armInput)
	}

	// Set property "AutoPauseProperties":
	if typedInput.AutoPauseProperties != nil {
		var autoPauseProperties1 AutoPauseProperties
		err := autoPauseProperties1.PopulateFromARM(owner, *typedInput.AutoPauseProperties)
		if err != nil {
			return err
		}
		autoPauseProperties := autoPauseProperties1
		properties.AutoPauseProperties = &autoPauseProperties
	}

	// Set property "AutoScaleProperties":
	if typedInput.AutoScaleProperties != nil {
		var autoScaleProperties1 AutoScaleProperties
		err := autoScaleProperties1.PopulateFromARM(owner, *typedInput.AutoScaleProperties)
		if err != nil {
			return err
		}
		autoScaleProperties := autoScaleProperties1
		properties.AutoScaleProperties = &autoScaleProperties
	}

	// Set property "NodeCount":
	if typedInput.NodeCount != nil {
		nodeCount := *typedInput.NodeCount
		properties.NodeCount = &nodeCount
	}

	// Set property "NodeSize":
	if typedInput.NodeSize != nil {
		nodeSize := *typedInput.NodeSize
		properties.NodeSize = &nodeSize
	}

	// Set property "NodeSizeFamily":
	if typedInput.NodeSizeFamily != nil {
		nodeSizeFamily := *typedInput.NodeSizeFamily
		properties.NodeSizeFamily = &nodeSizeFamily
	}

	// Set property "PoolName":
	if typedInput.PoolName != nil {
		poolName := *typedInput.PoolName
		properties.PoolName = &poolName
	}

	// Set property "ResourceGroup":
	if typedInput.ResourceGroup != nil {
		resourceGroup := *typedInput.ResourceGroup
		properties.ResourceGroup = &resourceGroup
	}

	// Set property "SparkVersion":
	if typedInput.SparkVersion != nil {
		sparkVersion := *typedInput.SparkVersion
		properties.SparkVersion = &sparkVersion
	}

	// Set property "SubscriptionId":
	if typedInput.SubscriptionId != nil {
		subscriptionId := *typedInput.SubscriptionId
		properties.SubscriptionId = &subscriptionId
	}

	// Set property "WorkspaceName":
	if typedInput.WorkspaceName != nil {
		workspaceName := *typedInput.WorkspaceName
		properties.WorkspaceName = &workspaceName
	}

	// No error
	return nil
}

// AssignProperties_From_SynapseSpark_Properties populates our SynapseSpark_Properties from the provided source SynapseSpark_Properties
func (properties *SynapseSpark_Properties) AssignProperties_From_SynapseSpark_Properties(source *storage.SynapseSpark_Properties) error {

	// AutoPauseProperties
	if source.AutoPauseProperties != nil {
		var autoPauseProperty AutoPauseProperties
		err := autoPauseProperty.AssignProperties_From_AutoPauseProperties(source.AutoPauseProperties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AutoPauseProperties() to populate field AutoPauseProperties")
		}
		properties.AutoPauseProperties = &autoPauseProperty
	} else {
		properties.AutoPauseProperties = nil
	}

	// AutoScaleProperties
	if source.AutoScaleProperties != nil {
		var autoScaleProperty AutoScaleProperties
		err := autoScaleProperty.AssignProperties_From_AutoScaleProperties(source.AutoScaleProperties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AutoScaleProperties() to populate field AutoScaleProperties")
		}
		properties.AutoScaleProperties = &autoScaleProperty
	} else {
		properties.AutoScaleProperties = nil
	}

	// NodeCount
	properties.NodeCount = genruntime.ClonePointerToInt(source.NodeCount)

	// NodeSize
	properties.NodeSize = genruntime.ClonePointerToString(source.NodeSize)

	// NodeSizeFamily
	properties.NodeSizeFamily = genruntime.ClonePointerToString(source.NodeSizeFamily)

	// PoolName
	properties.PoolName = genruntime.ClonePointerToString(source.PoolName)

	// ResourceGroup
	properties.ResourceGroup = genruntime.ClonePointerToString(source.ResourceGroup)

	// SparkVersion
	properties.SparkVersion = genruntime.ClonePointerToString(source.SparkVersion)

	// SubscriptionId
	properties.SubscriptionId = genruntime.ClonePointerToString(source.SubscriptionId)

	// WorkspaceName
	properties.WorkspaceName = genruntime.ClonePointerToString(source.WorkspaceName)

	// No error
	return nil
}

// AssignProperties_To_SynapseSpark_Properties populates the provided destination SynapseSpark_Properties from our SynapseSpark_Properties
func (properties *SynapseSpark_Properties) AssignProperties_To_SynapseSpark_Properties(destination *storage.SynapseSpark_Properties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AutoPauseProperties
	if properties.AutoPauseProperties != nil {
		var autoPauseProperty storage.AutoPauseProperties
		err := properties.AutoPauseProperties.AssignProperties_To_AutoPauseProperties(&autoPauseProperty)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AutoPauseProperties() to populate field AutoPauseProperties")
		}
		destination.AutoPauseProperties = &autoPauseProperty
	} else {
		destination.AutoPauseProperties = nil
	}

	// AutoScaleProperties
	if properties.AutoScaleProperties != nil {
		var autoScaleProperty storage.AutoScaleProperties
		err := properties.AutoScaleProperties.AssignProperties_To_AutoScaleProperties(&autoScaleProperty)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AutoScaleProperties() to populate field AutoScaleProperties")
		}
		destination.AutoScaleProperties = &autoScaleProperty
	} else {
		destination.AutoScaleProperties = nil
	}

	// NodeCount
	destination.NodeCount = genruntime.ClonePointerToInt(properties.NodeCount)

	// NodeSize
	destination.NodeSize = genruntime.ClonePointerToString(properties.NodeSize)

	// NodeSizeFamily
	destination.NodeSizeFamily = genruntime.ClonePointerToString(properties.NodeSizeFamily)

	// PoolName
	destination.PoolName = genruntime.ClonePointerToString(properties.PoolName)

	// ResourceGroup
	destination.ResourceGroup = genruntime.ClonePointerToString(properties.ResourceGroup)

	// SparkVersion
	destination.SparkVersion = genruntime.ClonePointerToString(properties.SparkVersion)

	// SubscriptionId
	destination.SubscriptionId = genruntime.ClonePointerToString(properties.SubscriptionId)

	// WorkspaceName
	destination.WorkspaceName = genruntime.ClonePointerToString(properties.WorkspaceName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type SynapseSpark_Properties_STATUS struct {
	// AutoPauseProperties: Auto pause properties.
	AutoPauseProperties *AutoPauseProperties_STATUS `json:"autoPauseProperties,omitempty"`

	// AutoScaleProperties: Auto scale properties.
	AutoScaleProperties *AutoScaleProperties_STATUS `json:"autoScaleProperties,omitempty"`

	// NodeCount: The number of compute nodes currently assigned to the compute.
	NodeCount *int `json:"nodeCount,omitempty"`

	// NodeSize: Node size.
	NodeSize *string `json:"nodeSize,omitempty"`

	// NodeSizeFamily: Node size family.
	NodeSizeFamily *string `json:"nodeSizeFamily,omitempty"`

	// PoolName: Pool name.
	PoolName *string `json:"poolName,omitempty"`

	// ResourceGroup: Name of the resource group in which workspace is located.
	ResourceGroup *string `json:"resourceGroup,omitempty"`

	// SparkVersion: Spark version.
	SparkVersion *string `json:"sparkVersion,omitempty"`

	// SubscriptionId: Azure subscription identifier.
	SubscriptionId *string `json:"subscriptionId,omitempty"`

	// WorkspaceName: Name of Azure Machine Learning workspace.
	WorkspaceName *string `json:"workspaceName,omitempty"`
}

var _ genruntime.FromARMConverter = &SynapseSpark_Properties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *SynapseSpark_Properties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SynapseSpark_Properties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *SynapseSpark_Properties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SynapseSpark_Properties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SynapseSpark_Properties_STATUS, got %T", armInput)
	}

	// Set property "AutoPauseProperties":
	if typedInput.AutoPauseProperties != nil {
		var autoPauseProperties1 AutoPauseProperties_STATUS
		err := autoPauseProperties1.PopulateFromARM(owner, *typedInput.AutoPauseProperties)
		if err != nil {
			return err
		}
		autoPauseProperties := autoPauseProperties1
		properties.AutoPauseProperties = &autoPauseProperties
	}

	// Set property "AutoScaleProperties":
	if typedInput.AutoScaleProperties != nil {
		var autoScaleProperties1 AutoScaleProperties_STATUS
		err := autoScaleProperties1.PopulateFromARM(owner, *typedInput.AutoScaleProperties)
		if err != nil {
			return err
		}
		autoScaleProperties := autoScaleProperties1
		properties.AutoScaleProperties = &autoScaleProperties
	}

	// Set property "NodeCount":
	if typedInput.NodeCount != nil {
		nodeCount := *typedInput.NodeCount
		properties.NodeCount = &nodeCount
	}

	// Set property "NodeSize":
	if typedInput.NodeSize != nil {
		nodeSize := *typedInput.NodeSize
		properties.NodeSize = &nodeSize
	}

	// Set property "NodeSizeFamily":
	if typedInput.NodeSizeFamily != nil {
		nodeSizeFamily := *typedInput.NodeSizeFamily
		properties.NodeSizeFamily = &nodeSizeFamily
	}

	// Set property "PoolName":
	if typedInput.PoolName != nil {
		poolName := *typedInput.PoolName
		properties.PoolName = &poolName
	}

	// Set property "ResourceGroup":
	if typedInput.ResourceGroup != nil {
		resourceGroup := *typedInput.ResourceGroup
		properties.ResourceGroup = &resourceGroup
	}

	// Set property "SparkVersion":
	if typedInput.SparkVersion != nil {
		sparkVersion := *typedInput.SparkVersion
		properties.SparkVersion = &sparkVersion
	}

	// Set property "SubscriptionId":
	if typedInput.SubscriptionId != nil {
		subscriptionId := *typedInput.SubscriptionId
		properties.SubscriptionId = &subscriptionId
	}

	// Set property "WorkspaceName":
	if typedInput.WorkspaceName != nil {
		workspaceName := *typedInput.WorkspaceName
		properties.WorkspaceName = &workspaceName
	}

	// No error
	return nil
}

// AssignProperties_From_SynapseSpark_Properties_STATUS populates our SynapseSpark_Properties_STATUS from the provided source SynapseSpark_Properties_STATUS
func (properties *SynapseSpark_Properties_STATUS) AssignProperties_From_SynapseSpark_Properties_STATUS(source *storage.SynapseSpark_Properties_STATUS) error {

	// AutoPauseProperties
	if source.AutoPauseProperties != nil {
		var autoPauseProperty AutoPauseProperties_STATUS
		err := autoPauseProperty.AssignProperties_From_AutoPauseProperties_STATUS(source.AutoPauseProperties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AutoPauseProperties_STATUS() to populate field AutoPauseProperties")
		}
		properties.AutoPauseProperties = &autoPauseProperty
	} else {
		properties.AutoPauseProperties = nil
	}

	// AutoScaleProperties
	if source.AutoScaleProperties != nil {
		var autoScaleProperty AutoScaleProperties_STATUS
		err := autoScaleProperty.AssignProperties_From_AutoScaleProperties_STATUS(source.AutoScaleProperties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AutoScaleProperties_STATUS() to populate field AutoScaleProperties")
		}
		properties.AutoScaleProperties = &autoScaleProperty
	} else {
		properties.AutoScaleProperties = nil
	}

	// NodeCount
	properties.NodeCount = genruntime.ClonePointerToInt(source.NodeCount)

	// NodeSize
	properties.NodeSize = genruntime.ClonePointerToString(source.NodeSize)

	// NodeSizeFamily
	properties.NodeSizeFamily = genruntime.ClonePointerToString(source.NodeSizeFamily)

	// PoolName
	properties.PoolName = genruntime.ClonePointerToString(source.PoolName)

	// ResourceGroup
	properties.ResourceGroup = genruntime.ClonePointerToString(source.ResourceGroup)

	// SparkVersion
	properties.SparkVersion = genruntime.ClonePointerToString(source.SparkVersion)

	// SubscriptionId
	properties.SubscriptionId = genruntime.ClonePointerToString(source.SubscriptionId)

	// WorkspaceName
	properties.WorkspaceName = genruntime.ClonePointerToString(source.WorkspaceName)

	// No error
	return nil
}

// AssignProperties_To_SynapseSpark_Properties_STATUS populates the provided destination SynapseSpark_Properties_STATUS from our SynapseSpark_Properties_STATUS
func (properties *SynapseSpark_Properties_STATUS) AssignProperties_To_SynapseSpark_Properties_STATUS(destination *storage.SynapseSpark_Properties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AutoPauseProperties
	if properties.AutoPauseProperties != nil {
		var autoPauseProperty storage.AutoPauseProperties_STATUS
		err := properties.AutoPauseProperties.AssignProperties_To_AutoPauseProperties_STATUS(&autoPauseProperty)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AutoPauseProperties_STATUS() to populate field AutoPauseProperties")
		}
		destination.AutoPauseProperties = &autoPauseProperty
	} else {
		destination.AutoPauseProperties = nil
	}

	// AutoScaleProperties
	if properties.AutoScaleProperties != nil {
		var autoScaleProperty storage.AutoScaleProperties_STATUS
		err := properties.AutoScaleProperties.AssignProperties_To_AutoScaleProperties_STATUS(&autoScaleProperty)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AutoScaleProperties_STATUS() to populate field AutoScaleProperties")
		}
		destination.AutoScaleProperties = &autoScaleProperty
	} else {
		destination.AutoScaleProperties = nil
	}

	// NodeCount
	destination.NodeCount = genruntime.ClonePointerToInt(properties.NodeCount)

	// NodeSize
	destination.NodeSize = genruntime.ClonePointerToString(properties.NodeSize)

	// NodeSizeFamily
	destination.NodeSizeFamily = genruntime.ClonePointerToString(properties.NodeSizeFamily)

	// PoolName
	destination.PoolName = genruntime.ClonePointerToString(properties.PoolName)

	// ResourceGroup
	destination.ResourceGroup = genruntime.ClonePointerToString(properties.ResourceGroup)

	// SparkVersion
	destination.SparkVersion = genruntime.ClonePointerToString(properties.SparkVersion)

	// SubscriptionId
	destination.SubscriptionId = genruntime.ClonePointerToString(properties.SubscriptionId)

	// WorkspaceName
	destination.WorkspaceName = genruntime.ClonePointerToString(properties.WorkspaceName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type SynapseSpark_ProvisioningState_STATUS string

const (
	SynapseSpark_ProvisioningState_STATUS_Canceled  = SynapseSpark_ProvisioningState_STATUS("Canceled")
	SynapseSpark_ProvisioningState_STATUS_Creating  = SynapseSpark_ProvisioningState_STATUS("Creating")
	SynapseSpark_ProvisioningState_STATUS_Deleting  = SynapseSpark_ProvisioningState_STATUS("Deleting")
	SynapseSpark_ProvisioningState_STATUS_Failed    = SynapseSpark_ProvisioningState_STATUS("Failed")
	SynapseSpark_ProvisioningState_STATUS_Succeeded = SynapseSpark_ProvisioningState_STATUS("Succeeded")
	SynapseSpark_ProvisioningState_STATUS_Unknown   = SynapseSpark_ProvisioningState_STATUS("Unknown")
	SynapseSpark_ProvisioningState_STATUS_Updating  = SynapseSpark_ProvisioningState_STATUS("Updating")
)

// Mapping from string to SynapseSpark_ProvisioningState_STATUS
var synapseSpark_ProvisioningState_STATUS_Values = map[string]SynapseSpark_ProvisioningState_STATUS{
	"canceled":  SynapseSpark_ProvisioningState_STATUS_Canceled,
	"creating":  SynapseSpark_ProvisioningState_STATUS_Creating,
	"deleting":  SynapseSpark_ProvisioningState_STATUS_Deleting,
	"failed":    SynapseSpark_ProvisioningState_STATUS_Failed,
	"succeeded": SynapseSpark_ProvisioningState_STATUS_Succeeded,
	"unknown":   SynapseSpark_ProvisioningState_STATUS_Unknown,
	"updating":  SynapseSpark_ProvisioningState_STATUS_Updating,
}

// +kubebuilder:validation:Enum={"VirtualMachine"}
type VirtualMachine_ComputeType string

const VirtualMachine_ComputeType_VirtualMachine = VirtualMachine_ComputeType("VirtualMachine")

// Mapping from string to VirtualMachine_ComputeType
var virtualMachine_ComputeType_Values = map[string]VirtualMachine_ComputeType{
	"virtualmachine": VirtualMachine_ComputeType_VirtualMachine,
}

type VirtualMachine_ComputeType_STATUS string

const VirtualMachine_ComputeType_STATUS_VirtualMachine = VirtualMachine_ComputeType_STATUS("VirtualMachine")

// Mapping from string to VirtualMachine_ComputeType_STATUS
var virtualMachine_ComputeType_STATUS_Values = map[string]VirtualMachine_ComputeType_STATUS{
	"virtualmachine": VirtualMachine_ComputeType_STATUS_VirtualMachine,
}

type VirtualMachine_Properties struct {
	// Address: Public IP address of the virtual machine.
	Address *string `json:"address,omitempty"`

	// AdministratorAccount: Admin credentials for virtual machine
	AdministratorAccount *VirtualMachineSshCredentials `json:"administratorAccount,omitempty"`

	// IsNotebookInstanceCompute: Indicates whether this compute will be used for running notebooks.
	IsNotebookInstanceCompute *bool `json:"isNotebookInstanceCompute,omitempty"`

	// SshPort: Port open for ssh connections.
	SshPort *int `json:"sshPort,omitempty"`

	// VirtualMachineSize: Virtual Machine size
	VirtualMachineSize *string `json:"virtualMachineSize,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachine_Properties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *VirtualMachine_Properties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.VirtualMachine_Properties{}

	// Set property "Address":
	if properties.Address != nil {
		address := *properties.Address
		result.Address = &address
	}

	// Set property "AdministratorAccount":
	if properties.AdministratorAccount != nil {
		administratorAccount_ARM, err := (*properties.AdministratorAccount).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		administratorAccount := *administratorAccount_ARM.(*arm.VirtualMachineSshCredentials)
		result.AdministratorAccount = &administratorAccount
	}

	// Set property "IsNotebookInstanceCompute":
	if properties.IsNotebookInstanceCompute != nil {
		isNotebookInstanceCompute := *properties.IsNotebookInstanceCompute
		result.IsNotebookInstanceCompute = &isNotebookInstanceCompute
	}

	// Set property "SshPort":
	if properties.SshPort != nil {
		sshPort := *properties.SshPort
		result.SshPort = &sshPort
	}

	// Set property "VirtualMachineSize":
	if properties.VirtualMachineSize != nil {
		virtualMachineSize := *properties.VirtualMachineSize
		result.VirtualMachineSize = &virtualMachineSize
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *VirtualMachine_Properties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachine_Properties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *VirtualMachine_Properties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachine_Properties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachine_Properties, got %T", armInput)
	}

	// Set property "Address":
	if typedInput.Address != nil {
		address := *typedInput.Address
		properties.Address = &address
	}

	// Set property "AdministratorAccount":
	if typedInput.AdministratorAccount != nil {
		var administratorAccount1 VirtualMachineSshCredentials
		err := administratorAccount1.PopulateFromARM(owner, *typedInput.AdministratorAccount)
		if err != nil {
			return err
		}
		administratorAccount := administratorAccount1
		properties.AdministratorAccount = &administratorAccount
	}

	// Set property "IsNotebookInstanceCompute":
	if typedInput.IsNotebookInstanceCompute != nil {
		isNotebookInstanceCompute := *typedInput.IsNotebookInstanceCompute
		properties.IsNotebookInstanceCompute = &isNotebookInstanceCompute
	}

	// Set property "SshPort":
	if typedInput.SshPort != nil {
		sshPort := *typedInput.SshPort
		properties.SshPort = &sshPort
	}

	// Set property "VirtualMachineSize":
	if typedInput.VirtualMachineSize != nil {
		virtualMachineSize := *typedInput.VirtualMachineSize
		properties.VirtualMachineSize = &virtualMachineSize
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachine_Properties populates our VirtualMachine_Properties from the provided source VirtualMachine_Properties
func (properties *VirtualMachine_Properties) AssignProperties_From_VirtualMachine_Properties(source *storage.VirtualMachine_Properties) error {

	// Address
	properties.Address = genruntime.ClonePointerToString(source.Address)

	// AdministratorAccount
	if source.AdministratorAccount != nil {
		var administratorAccount VirtualMachineSshCredentials
		err := administratorAccount.AssignProperties_From_VirtualMachineSshCredentials(source.AdministratorAccount)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineSshCredentials() to populate field AdministratorAccount")
		}
		properties.AdministratorAccount = &administratorAccount
	} else {
		properties.AdministratorAccount = nil
	}

	// IsNotebookInstanceCompute
	if source.IsNotebookInstanceCompute != nil {
		isNotebookInstanceCompute := *source.IsNotebookInstanceCompute
		properties.IsNotebookInstanceCompute = &isNotebookInstanceCompute
	} else {
		properties.IsNotebookInstanceCompute = nil
	}

	// SshPort
	properties.SshPort = genruntime.ClonePointerToInt(source.SshPort)

	// VirtualMachineSize
	properties.VirtualMachineSize = genruntime.ClonePointerToString(source.VirtualMachineSize)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachine_Properties populates the provided destination VirtualMachine_Properties from our VirtualMachine_Properties
func (properties *VirtualMachine_Properties) AssignProperties_To_VirtualMachine_Properties(destination *storage.VirtualMachine_Properties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Address
	destination.Address = genruntime.ClonePointerToString(properties.Address)

	// AdministratorAccount
	if properties.AdministratorAccount != nil {
		var administratorAccount storage.VirtualMachineSshCredentials
		err := properties.AdministratorAccount.AssignProperties_To_VirtualMachineSshCredentials(&administratorAccount)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineSshCredentials() to populate field AdministratorAccount")
		}
		destination.AdministratorAccount = &administratorAccount
	} else {
		destination.AdministratorAccount = nil
	}

	// IsNotebookInstanceCompute
	if properties.IsNotebookInstanceCompute != nil {
		isNotebookInstanceCompute := *properties.IsNotebookInstanceCompute
		destination.IsNotebookInstanceCompute = &isNotebookInstanceCompute
	} else {
		destination.IsNotebookInstanceCompute = nil
	}

	// SshPort
	destination.SshPort = genruntime.ClonePointerToInt(properties.SshPort)

	// VirtualMachineSize
	destination.VirtualMachineSize = genruntime.ClonePointerToString(properties.VirtualMachineSize)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachine_Properties_STATUS struct {
	// Address: Public IP address of the virtual machine.
	Address *string `json:"address,omitempty"`

	// AdministratorAccount: Admin credentials for virtual machine
	AdministratorAccount *VirtualMachineSshCredentials_STATUS `json:"administratorAccount,omitempty"`

	// IsNotebookInstanceCompute: Indicates whether this compute will be used for running notebooks.
	IsNotebookInstanceCompute *bool `json:"isNotebookInstanceCompute,omitempty"`

	// SshPort: Port open for ssh connections.
	SshPort *int `json:"sshPort,omitempty"`

	// VirtualMachineSize: Virtual Machine size
	VirtualMachineSize *string `json:"virtualMachineSize,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachine_Properties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *VirtualMachine_Properties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachine_Properties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *VirtualMachine_Properties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachine_Properties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachine_Properties_STATUS, got %T", armInput)
	}

	// Set property "Address":
	if typedInput.Address != nil {
		address := *typedInput.Address
		properties.Address = &address
	}

	// Set property "AdministratorAccount":
	if typedInput.AdministratorAccount != nil {
		var administratorAccount1 VirtualMachineSshCredentials_STATUS
		err := administratorAccount1.PopulateFromARM(owner, *typedInput.AdministratorAccount)
		if err != nil {
			return err
		}
		administratorAccount := administratorAccount1
		properties.AdministratorAccount = &administratorAccount
	}

	// Set property "IsNotebookInstanceCompute":
	if typedInput.IsNotebookInstanceCompute != nil {
		isNotebookInstanceCompute := *typedInput.IsNotebookInstanceCompute
		properties.IsNotebookInstanceCompute = &isNotebookInstanceCompute
	}

	// Set property "SshPort":
	if typedInput.SshPort != nil {
		sshPort := *typedInput.SshPort
		properties.SshPort = &sshPort
	}

	// Set property "VirtualMachineSize":
	if typedInput.VirtualMachineSize != nil {
		virtualMachineSize := *typedInput.VirtualMachineSize
		properties.VirtualMachineSize = &virtualMachineSize
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachine_Properties_STATUS populates our VirtualMachine_Properties_STATUS from the provided source VirtualMachine_Properties_STATUS
func (properties *VirtualMachine_Properties_STATUS) AssignProperties_From_VirtualMachine_Properties_STATUS(source *storage.VirtualMachine_Properties_STATUS) error {

	// Address
	properties.Address = genruntime.ClonePointerToString(source.Address)

	// AdministratorAccount
	if source.AdministratorAccount != nil {
		var administratorAccount VirtualMachineSshCredentials_STATUS
		err := administratorAccount.AssignProperties_From_VirtualMachineSshCredentials_STATUS(source.AdministratorAccount)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineSshCredentials_STATUS() to populate field AdministratorAccount")
		}
		properties.AdministratorAccount = &administratorAccount
	} else {
		properties.AdministratorAccount = nil
	}

	// IsNotebookInstanceCompute
	if source.IsNotebookInstanceCompute != nil {
		isNotebookInstanceCompute := *source.IsNotebookInstanceCompute
		properties.IsNotebookInstanceCompute = &isNotebookInstanceCompute
	} else {
		properties.IsNotebookInstanceCompute = nil
	}

	// SshPort
	properties.SshPort = genruntime.ClonePointerToInt(source.SshPort)

	// VirtualMachineSize
	properties.VirtualMachineSize = genruntime.ClonePointerToString(source.VirtualMachineSize)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachine_Properties_STATUS populates the provided destination VirtualMachine_Properties_STATUS from our VirtualMachine_Properties_STATUS
func (properties *VirtualMachine_Properties_STATUS) AssignProperties_To_VirtualMachine_Properties_STATUS(destination *storage.VirtualMachine_Properties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Address
	destination.Address = genruntime.ClonePointerToString(properties.Address)

	// AdministratorAccount
	if properties.AdministratorAccount != nil {
		var administratorAccount storage.VirtualMachineSshCredentials_STATUS
		err := properties.AdministratorAccount.AssignProperties_To_VirtualMachineSshCredentials_STATUS(&administratorAccount)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineSshCredentials_STATUS() to populate field AdministratorAccount")
		}
		destination.AdministratorAccount = &administratorAccount
	} else {
		destination.AdministratorAccount = nil
	}

	// IsNotebookInstanceCompute
	if properties.IsNotebookInstanceCompute != nil {
		isNotebookInstanceCompute := *properties.IsNotebookInstanceCompute
		destination.IsNotebookInstanceCompute = &isNotebookInstanceCompute
	} else {
		destination.IsNotebookInstanceCompute = nil
	}

	// SshPort
	destination.SshPort = genruntime.ClonePointerToInt(properties.SshPort)

	// VirtualMachineSize
	destination.VirtualMachineSize = genruntime.ClonePointerToString(properties.VirtualMachineSize)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachine_ProvisioningState_STATUS string

const (
	VirtualMachine_ProvisioningState_STATUS_Canceled  = VirtualMachine_ProvisioningState_STATUS("Canceled")
	VirtualMachine_ProvisioningState_STATUS_Creating  = VirtualMachine_ProvisioningState_STATUS("Creating")
	VirtualMachine_ProvisioningState_STATUS_Deleting  = VirtualMachine_ProvisioningState_STATUS("Deleting")
	VirtualMachine_ProvisioningState_STATUS_Failed    = VirtualMachine_ProvisioningState_STATUS("Failed")
	VirtualMachine_ProvisioningState_STATUS_Succeeded = VirtualMachine_ProvisioningState_STATUS("Succeeded")
	VirtualMachine_ProvisioningState_STATUS_Unknown   = VirtualMachine_ProvisioningState_STATUS("Unknown")
	VirtualMachine_ProvisioningState_STATUS_Updating  = VirtualMachine_ProvisioningState_STATUS("Updating")
)

// Mapping from string to VirtualMachine_ProvisioningState_STATUS
var virtualMachine_ProvisioningState_STATUS_Values = map[string]VirtualMachine_ProvisioningState_STATUS{
	"canceled":  VirtualMachine_ProvisioningState_STATUS_Canceled,
	"creating":  VirtualMachine_ProvisioningState_STATUS_Creating,
	"deleting":  VirtualMachine_ProvisioningState_STATUS_Deleting,
	"failed":    VirtualMachine_ProvisioningState_STATUS_Failed,
	"succeeded": VirtualMachine_ProvisioningState_STATUS_Succeeded,
	"unknown":   VirtualMachine_ProvisioningState_STATUS_Unknown,
	"updating":  VirtualMachine_ProvisioningState_STATUS_Updating,
}

// +kubebuilder:validation:Enum={"DenseProd","DevTest","FastProd"}
type AKS_Properties_ClusterPurpose string

const (
	AKS_Properties_ClusterPurpose_DenseProd = AKS_Properties_ClusterPurpose("DenseProd")
	AKS_Properties_ClusterPurpose_DevTest   = AKS_Properties_ClusterPurpose("DevTest")
	AKS_Properties_ClusterPurpose_FastProd  = AKS_Properties_ClusterPurpose("FastProd")
)

// Mapping from string to AKS_Properties_ClusterPurpose
var aKS_Properties_ClusterPurpose_Values = map[string]AKS_Properties_ClusterPurpose{
	"denseprod": AKS_Properties_ClusterPurpose_DenseProd,
	"devtest":   AKS_Properties_ClusterPurpose_DevTest,
	"fastprod":  AKS_Properties_ClusterPurpose_FastProd,
}

type AKS_Properties_ClusterPurpose_STATUS string

const (
	AKS_Properties_ClusterPurpose_STATUS_DenseProd = AKS_Properties_ClusterPurpose_STATUS("DenseProd")
	AKS_Properties_ClusterPurpose_STATUS_DevTest   = AKS_Properties_ClusterPurpose_STATUS("DevTest")
	AKS_Properties_ClusterPurpose_STATUS_FastProd  = AKS_Properties_ClusterPurpose_STATUS("FastProd")
)

// Mapping from string to AKS_Properties_ClusterPurpose_STATUS
var aKS_Properties_ClusterPurpose_STATUS_Values = map[string]AKS_Properties_ClusterPurpose_STATUS{
	"denseprod": AKS_Properties_ClusterPurpose_STATUS_DenseProd,
	"devtest":   AKS_Properties_ClusterPurpose_STATUS_DevTest,
	"fastprod":  AKS_Properties_ClusterPurpose_STATUS_FastProd,
}

// +kubebuilder:validation:Enum={"InternalLoadBalancer","PublicIp"}
type AKS_Properties_LoadBalancerType string

const (
	AKS_Properties_LoadBalancerType_InternalLoadBalancer = AKS_Properties_LoadBalancerType("InternalLoadBalancer")
	AKS_Properties_LoadBalancerType_PublicIp             = AKS_Properties_LoadBalancerType("PublicIp")
)

// Mapping from string to AKS_Properties_LoadBalancerType
var aKS_Properties_LoadBalancerType_Values = map[string]AKS_Properties_LoadBalancerType{
	"internalloadbalancer": AKS_Properties_LoadBalancerType_InternalLoadBalancer,
	"publicip":             AKS_Properties_LoadBalancerType_PublicIp,
}

type AKS_Properties_LoadBalancerType_STATUS string

const (
	AKS_Properties_LoadBalancerType_STATUS_InternalLoadBalancer = AKS_Properties_LoadBalancerType_STATUS("InternalLoadBalancer")
	AKS_Properties_LoadBalancerType_STATUS_PublicIp             = AKS_Properties_LoadBalancerType_STATUS("PublicIp")
)

// Mapping from string to AKS_Properties_LoadBalancerType_STATUS
var aKS_Properties_LoadBalancerType_STATUS_Values = map[string]AKS_Properties_LoadBalancerType_STATUS{
	"internalloadbalancer": AKS_Properties_LoadBalancerType_STATUS_InternalLoadBalancer,
	"publicip":             AKS_Properties_LoadBalancerType_STATUS_PublicIp,
}

// Advance configuration for AKS networking
type AksNetworkingConfiguration struct {
	// +kubebuilder:validation:Pattern="^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$"
	// DnsServiceIP: An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes service address
	// range specified in serviceCidr.
	DnsServiceIP *string `json:"dnsServiceIP,omitempty"`

	// +kubebuilder:validation:Pattern="^([0-9]{1,3}\\.){3}[0-9]{1,3}(\\/([0-9]|[1-2][0-9]|3[0-2]))?$"
	// DockerBridgeCidr: A CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP
	// ranges or the Kubernetes service address range.
	DockerBridgeCidr *string `json:"dockerBridgeCidr,omitempty"`

	// +kubebuilder:validation:Pattern="^([0-9]{1,3}\\.){3}[0-9]{1,3}(\\/([0-9]|[1-2][0-9]|3[0-2]))?$"
	// ServiceCidr: A CIDR notation IP range from which to assign service cluster IPs. It must not overlap with any Subnet IP
	// ranges.
	ServiceCidr *string `json:"serviceCidr,omitempty"`

	// SubnetReference: Virtual network subnet resource ID the compute nodes belong to
	SubnetReference *genruntime.ResourceReference `armReference:"SubnetId" json:"subnetReference,omitempty"`
}

var _ genruntime.ARMTransformer = &AksNetworkingConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *AksNetworkingConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.AksNetworkingConfiguration{}

	// Set property "DnsServiceIP":
	if configuration.DnsServiceIP != nil {
		dnsServiceIP := *configuration.DnsServiceIP
		result.DnsServiceIP = &dnsServiceIP
	}

	// Set property "DockerBridgeCidr":
	if configuration.DockerBridgeCidr != nil {
		dockerBridgeCidr := *configuration.DockerBridgeCidr
		result.DockerBridgeCidr = &dockerBridgeCidr
	}

	// Set property "ServiceCidr":
	if configuration.ServiceCidr != nil {
		serviceCidr := *configuration.ServiceCidr
		result.ServiceCidr = &serviceCidr
	}

	// Set property "SubnetId":
	if configuration.SubnetReference != nil {
		subnetReferenceARMID, err := resolved.ResolvedReferences.Lookup(*configuration.SubnetReference)
		if err != nil {
			return nil, err
		}
		subnetReference := subnetReferenceARMID
		result.SubnetId = &subnetReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *AksNetworkingConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AksNetworkingConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *AksNetworkingConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AksNetworkingConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AksNetworkingConfiguration, got %T", armInput)
	}

	// Set property "DnsServiceIP":
	if typedInput.DnsServiceIP != nil {
		dnsServiceIP := *typedInput.DnsServiceIP
		configuration.DnsServiceIP = &dnsServiceIP
	}

	// Set property "DockerBridgeCidr":
	if typedInput.DockerBridgeCidr != nil {
		dockerBridgeCidr := *typedInput.DockerBridgeCidr
		configuration.DockerBridgeCidr = &dockerBridgeCidr
	}

	// Set property "ServiceCidr":
	if typedInput.ServiceCidr != nil {
		serviceCidr := *typedInput.ServiceCidr
		configuration.ServiceCidr = &serviceCidr
	}

	// no assignment for property "SubnetReference"

	// No error
	return nil
}

// AssignProperties_From_AksNetworkingConfiguration populates our AksNetworkingConfiguration from the provided source AksNetworkingConfiguration
func (configuration *AksNetworkingConfiguration) AssignProperties_From_AksNetworkingConfiguration(source *storage.AksNetworkingConfiguration) error {

	// DnsServiceIP
	configuration.DnsServiceIP = genruntime.ClonePointerToString(source.DnsServiceIP)

	// DockerBridgeCidr
	configuration.DockerBridgeCidr = genruntime.ClonePointerToString(source.DockerBridgeCidr)

	// ServiceCidr
	configuration.ServiceCidr = genruntime.ClonePointerToString(source.ServiceCidr)

	// SubnetReference
	if source.SubnetReference != nil {
		subnetReference := source.SubnetReference.Copy()
		configuration.SubnetReference = &subnetReference
	} else {
		configuration.SubnetReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AksNetworkingConfiguration populates the provided destination AksNetworkingConfiguration from our AksNetworkingConfiguration
func (configuration *AksNetworkingConfiguration) AssignProperties_To_AksNetworkingConfiguration(destination *storage.AksNetworkingConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsServiceIP
	destination.DnsServiceIP = genruntime.ClonePointerToString(configuration.DnsServiceIP)

	// DockerBridgeCidr
	destination.DockerBridgeCidr = genruntime.ClonePointerToString(configuration.DockerBridgeCidr)

	// ServiceCidr
	destination.ServiceCidr = genruntime.ClonePointerToString(configuration.ServiceCidr)

	// SubnetReference
	if configuration.SubnetReference != nil {
		subnetReference := configuration.SubnetReference.Copy()
		destination.SubnetReference = &subnetReference
	} else {
		destination.SubnetReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Advance configuration for AKS networking
type AksNetworkingConfiguration_STATUS struct {
	// DnsServiceIP: An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes service address
	// range specified in serviceCidr.
	DnsServiceIP *string `json:"dnsServiceIP,omitempty"`

	// DockerBridgeCidr: A CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP
	// ranges or the Kubernetes service address range.
	DockerBridgeCidr *string `json:"dockerBridgeCidr,omitempty"`

	// ServiceCidr: A CIDR notation IP range from which to assign service cluster IPs. It must not overlap with any Subnet IP
	// ranges.
	ServiceCidr *string `json:"serviceCidr,omitempty"`

	// SubnetId: Virtual network subnet resource ID the compute nodes belong to
	SubnetId *string `json:"subnetId,omitempty"`
}

var _ genruntime.FromARMConverter = &AksNetworkingConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *AksNetworkingConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AksNetworkingConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *AksNetworkingConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AksNetworkingConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AksNetworkingConfiguration_STATUS, got %T", armInput)
	}

	// Set property "DnsServiceIP":
	if typedInput.DnsServiceIP != nil {
		dnsServiceIP := *typedInput.DnsServiceIP
		configuration.DnsServiceIP = &dnsServiceIP
	}

	// Set property "DockerBridgeCidr":
	if typedInput.DockerBridgeCidr != nil {
		dockerBridgeCidr := *typedInput.DockerBridgeCidr
		configuration.DockerBridgeCidr = &dockerBridgeCidr
	}

	// Set property "ServiceCidr":
	if typedInput.ServiceCidr != nil {
		serviceCidr := *typedInput.ServiceCidr
		configuration.ServiceCidr = &serviceCidr
	}

	// Set property "SubnetId":
	if typedInput.SubnetId != nil {
		subnetId := *typedInput.SubnetId
		configuration.SubnetId = &subnetId
	}

	// No error
	return nil
}

// AssignProperties_From_AksNetworkingConfiguration_STATUS populates our AksNetworkingConfiguration_STATUS from the provided source AksNetworkingConfiguration_STATUS
func (configuration *AksNetworkingConfiguration_STATUS) AssignProperties_From_AksNetworkingConfiguration_STATUS(source *storage.AksNetworkingConfiguration_STATUS) error {

	// DnsServiceIP
	configuration.DnsServiceIP = genruntime.ClonePointerToString(source.DnsServiceIP)

	// DockerBridgeCidr
	configuration.DockerBridgeCidr = genruntime.ClonePointerToString(source.DockerBridgeCidr)

	// ServiceCidr
	configuration.ServiceCidr = genruntime.ClonePointerToString(source.ServiceCidr)

	// SubnetId
	configuration.SubnetId = genruntime.ClonePointerToString(source.SubnetId)

	// No error
	return nil
}

// AssignProperties_To_AksNetworkingConfiguration_STATUS populates the provided destination AksNetworkingConfiguration_STATUS from our AksNetworkingConfiguration_STATUS
func (configuration *AksNetworkingConfiguration_STATUS) AssignProperties_To_AksNetworkingConfiguration_STATUS(destination *storage.AksNetworkingConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsServiceIP
	destination.DnsServiceIP = genruntime.ClonePointerToString(configuration.DnsServiceIP)

	// DockerBridgeCidr
	destination.DockerBridgeCidr = genruntime.ClonePointerToString(configuration.DockerBridgeCidr)

	// ServiceCidr
	destination.ServiceCidr = genruntime.ClonePointerToString(configuration.ServiceCidr)

	// SubnetId
	destination.SubnetId = genruntime.ClonePointerToString(configuration.SubnetId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AmlComputeProperties_AllocationState_STATUS string

const (
	AmlComputeProperties_AllocationState_STATUS_Resizing = AmlComputeProperties_AllocationState_STATUS("Resizing")
	AmlComputeProperties_AllocationState_STATUS_Steady   = AmlComputeProperties_AllocationState_STATUS("Steady")
)

// Mapping from string to AmlComputeProperties_AllocationState_STATUS
var amlComputeProperties_AllocationState_STATUS_Values = map[string]AmlComputeProperties_AllocationState_STATUS{
	"resizing": AmlComputeProperties_AllocationState_STATUS_Resizing,
	"steady":   AmlComputeProperties_AllocationState_STATUS_Steady,
}

// +kubebuilder:validation:Enum={"Linux","Windows"}
type AmlComputeProperties_OsType string

const (
	AmlComputeProperties_OsType_Linux   = AmlComputeProperties_OsType("Linux")
	AmlComputeProperties_OsType_Windows = AmlComputeProperties_OsType("Windows")
)

// Mapping from string to AmlComputeProperties_OsType
var amlComputeProperties_OsType_Values = map[string]AmlComputeProperties_OsType{
	"linux":   AmlComputeProperties_OsType_Linux,
	"windows": AmlComputeProperties_OsType_Windows,
}

type AmlComputeProperties_OsType_STATUS string

const (
	AmlComputeProperties_OsType_STATUS_Linux   = AmlComputeProperties_OsType_STATUS("Linux")
	AmlComputeProperties_OsType_STATUS_Windows = AmlComputeProperties_OsType_STATUS("Windows")
)

// Mapping from string to AmlComputeProperties_OsType_STATUS
var amlComputeProperties_OsType_STATUS_Values = map[string]AmlComputeProperties_OsType_STATUS{
	"linux":   AmlComputeProperties_OsType_STATUS_Linux,
	"windows": AmlComputeProperties_OsType_STATUS_Windows,
}

// +kubebuilder:validation:Enum={"Disabled","Enabled","NotSpecified"}
type AmlComputeProperties_RemoteLoginPortPublicAccess string

const (
	AmlComputeProperties_RemoteLoginPortPublicAccess_Disabled     = AmlComputeProperties_RemoteLoginPortPublicAccess("Disabled")
	AmlComputeProperties_RemoteLoginPortPublicAccess_Enabled      = AmlComputeProperties_RemoteLoginPortPublicAccess("Enabled")
	AmlComputeProperties_RemoteLoginPortPublicAccess_NotSpecified = AmlComputeProperties_RemoteLoginPortPublicAccess("NotSpecified")
)

// Mapping from string to AmlComputeProperties_RemoteLoginPortPublicAccess
var amlComputeProperties_RemoteLoginPortPublicAccess_Values = map[string]AmlComputeProperties_RemoteLoginPortPublicAccess{
	"disabled":     AmlComputeProperties_RemoteLoginPortPublicAccess_Disabled,
	"enabled":      AmlComputeProperties_RemoteLoginPortPublicAccess_Enabled,
	"notspecified": AmlComputeProperties_RemoteLoginPortPublicAccess_NotSpecified,
}

type AmlComputeProperties_RemoteLoginPortPublicAccess_STATUS string

const (
	AmlComputeProperties_RemoteLoginPortPublicAccess_STATUS_Disabled     = AmlComputeProperties_RemoteLoginPortPublicAccess_STATUS("Disabled")
	AmlComputeProperties_RemoteLoginPortPublicAccess_STATUS_Enabled      = AmlComputeProperties_RemoteLoginPortPublicAccess_STATUS("Enabled")
	AmlComputeProperties_RemoteLoginPortPublicAccess_STATUS_NotSpecified = AmlComputeProperties_RemoteLoginPortPublicAccess_STATUS("NotSpecified")
)

// Mapping from string to AmlComputeProperties_RemoteLoginPortPublicAccess_STATUS
var amlComputeProperties_RemoteLoginPortPublicAccess_STATUS_Values = map[string]AmlComputeProperties_RemoteLoginPortPublicAccess_STATUS{
	"disabled":     AmlComputeProperties_RemoteLoginPortPublicAccess_STATUS_Disabled,
	"enabled":      AmlComputeProperties_RemoteLoginPortPublicAccess_STATUS_Enabled,
	"notspecified": AmlComputeProperties_RemoteLoginPortPublicAccess_STATUS_NotSpecified,
}

// +kubebuilder:validation:Enum={"Dedicated","LowPriority"}
type AmlComputeProperties_VmPriority string

const (
	AmlComputeProperties_VmPriority_Dedicated   = AmlComputeProperties_VmPriority("Dedicated")
	AmlComputeProperties_VmPriority_LowPriority = AmlComputeProperties_VmPriority("LowPriority")
)

// Mapping from string to AmlComputeProperties_VmPriority
var amlComputeProperties_VmPriority_Values = map[string]AmlComputeProperties_VmPriority{
	"dedicated":   AmlComputeProperties_VmPriority_Dedicated,
	"lowpriority": AmlComputeProperties_VmPriority_LowPriority,
}

type AmlComputeProperties_VmPriority_STATUS string

const (
	AmlComputeProperties_VmPriority_STATUS_Dedicated   = AmlComputeProperties_VmPriority_STATUS("Dedicated")
	AmlComputeProperties_VmPriority_STATUS_LowPriority = AmlComputeProperties_VmPriority_STATUS("LowPriority")
)

// Mapping from string to AmlComputeProperties_VmPriority_STATUS
var amlComputeProperties_VmPriority_STATUS_Values = map[string]AmlComputeProperties_VmPriority_STATUS{
	"dedicated":   AmlComputeProperties_VmPriority_STATUS_Dedicated,
	"lowpriority": AmlComputeProperties_VmPriority_STATUS_LowPriority,
}

// Auto pause properties
type AutoPauseProperties struct {
	DelayInMinutes *int  `json:"delayInMinutes,omitempty"`
	Enabled        *bool `json:"enabled,omitempty"`
}

var _ genruntime.ARMTransformer = &AutoPauseProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *AutoPauseProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.AutoPauseProperties{}

	// Set property "DelayInMinutes":
	if properties.DelayInMinutes != nil {
		delayInMinutes := *properties.DelayInMinutes
		result.DelayInMinutes = &delayInMinutes
	}

	// Set property "Enabled":
	if properties.Enabled != nil {
		enabled := *properties.Enabled
		result.Enabled = &enabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *AutoPauseProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AutoPauseProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *AutoPauseProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AutoPauseProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AutoPauseProperties, got %T", armInput)
	}

	// Set property "DelayInMinutes":
	if typedInput.DelayInMinutes != nil {
		delayInMinutes := *typedInput.DelayInMinutes
		properties.DelayInMinutes = &delayInMinutes
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		properties.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_AutoPauseProperties populates our AutoPauseProperties from the provided source AutoPauseProperties
func (properties *AutoPauseProperties) AssignProperties_From_AutoPauseProperties(source *storage.AutoPauseProperties) error {

	// DelayInMinutes
	properties.DelayInMinutes = genruntime.ClonePointerToInt(source.DelayInMinutes)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		properties.Enabled = &enabled
	} else {
		properties.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AutoPauseProperties populates the provided destination AutoPauseProperties from our AutoPauseProperties
func (properties *AutoPauseProperties) AssignProperties_To_AutoPauseProperties(destination *storage.AutoPauseProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DelayInMinutes
	destination.DelayInMinutes = genruntime.ClonePointerToInt(properties.DelayInMinutes)

	// Enabled
	if properties.Enabled != nil {
		enabled := *properties.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Auto pause properties
type AutoPauseProperties_STATUS struct {
	DelayInMinutes *int  `json:"delayInMinutes,omitempty"`
	Enabled        *bool `json:"enabled,omitempty"`
}

var _ genruntime.FromARMConverter = &AutoPauseProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *AutoPauseProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AutoPauseProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *AutoPauseProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AutoPauseProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AutoPauseProperties_STATUS, got %T", armInput)
	}

	// Set property "DelayInMinutes":
	if typedInput.DelayInMinutes != nil {
		delayInMinutes := *typedInput.DelayInMinutes
		properties.DelayInMinutes = &delayInMinutes
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		properties.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_AutoPauseProperties_STATUS populates our AutoPauseProperties_STATUS from the provided source AutoPauseProperties_STATUS
func (properties *AutoPauseProperties_STATUS) AssignProperties_From_AutoPauseProperties_STATUS(source *storage.AutoPauseProperties_STATUS) error {

	// DelayInMinutes
	properties.DelayInMinutes = genruntime.ClonePointerToInt(source.DelayInMinutes)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		properties.Enabled = &enabled
	} else {
		properties.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AutoPauseProperties_STATUS populates the provided destination AutoPauseProperties_STATUS from our AutoPauseProperties_STATUS
func (properties *AutoPauseProperties_STATUS) AssignProperties_To_AutoPauseProperties_STATUS(destination *storage.AutoPauseProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DelayInMinutes
	destination.DelayInMinutes = genruntime.ClonePointerToInt(properties.DelayInMinutes)

	// Enabled
	if properties.Enabled != nil {
		enabled := *properties.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Auto scale properties
type AutoScaleProperties struct {
	Enabled      *bool `json:"enabled,omitempty"`
	MaxNodeCount *int  `json:"maxNodeCount,omitempty"`
	MinNodeCount *int  `json:"minNodeCount,omitempty"`
}

var _ genruntime.ARMTransformer = &AutoScaleProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *AutoScaleProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.AutoScaleProperties{}

	// Set property "Enabled":
	if properties.Enabled != nil {
		enabled := *properties.Enabled
		result.Enabled = &enabled
	}

	// Set property "MaxNodeCount":
	if properties.MaxNodeCount != nil {
		maxNodeCount := *properties.MaxNodeCount
		result.MaxNodeCount = &maxNodeCount
	}

	// Set property "MinNodeCount":
	if properties.MinNodeCount != nil {
		minNodeCount := *properties.MinNodeCount
		result.MinNodeCount = &minNodeCount
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *AutoScaleProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AutoScaleProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *AutoScaleProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AutoScaleProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AutoScaleProperties, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		properties.Enabled = &enabled
	}

	// Set property "MaxNodeCount":
	if typedInput.MaxNodeCount != nil {
		maxNodeCount := *typedInput.MaxNodeCount
		properties.MaxNodeCount = &maxNodeCount
	}

	// Set property "MinNodeCount":
	if typedInput.MinNodeCount != nil {
		minNodeCount := *typedInput.MinNodeCount
		properties.MinNodeCount = &minNodeCount
	}

	// No error
	return nil
}

// AssignProperties_From_AutoScaleProperties populates our AutoScaleProperties from the provided source AutoScaleProperties
func (properties *AutoScaleProperties) AssignProperties_From_AutoScaleProperties(source *storage.AutoScaleProperties) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		properties.Enabled = &enabled
	} else {
		properties.Enabled = nil
	}

	// MaxNodeCount
	properties.MaxNodeCount = genruntime.ClonePointerToInt(source.MaxNodeCount)

	// MinNodeCount
	properties.MinNodeCount = genruntime.ClonePointerToInt(source.MinNodeCount)

	// No error
	return nil
}

// AssignProperties_To_AutoScaleProperties populates the provided destination AutoScaleProperties from our AutoScaleProperties
func (properties *AutoScaleProperties) AssignProperties_To_AutoScaleProperties(destination *storage.AutoScaleProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if properties.Enabled != nil {
		enabled := *properties.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// MaxNodeCount
	destination.MaxNodeCount = genruntime.ClonePointerToInt(properties.MaxNodeCount)

	// MinNodeCount
	destination.MinNodeCount = genruntime.ClonePointerToInt(properties.MinNodeCount)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Auto scale properties
type AutoScaleProperties_STATUS struct {
	Enabled      *bool `json:"enabled,omitempty"`
	MaxNodeCount *int  `json:"maxNodeCount,omitempty"`
	MinNodeCount *int  `json:"minNodeCount,omitempty"`
}

var _ genruntime.FromARMConverter = &AutoScaleProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *AutoScaleProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AutoScaleProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *AutoScaleProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AutoScaleProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AutoScaleProperties_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		properties.Enabled = &enabled
	}

	// Set property "MaxNodeCount":
	if typedInput.MaxNodeCount != nil {
		maxNodeCount := *typedInput.MaxNodeCount
		properties.MaxNodeCount = &maxNodeCount
	}

	// Set property "MinNodeCount":
	if typedInput.MinNodeCount != nil {
		minNodeCount := *typedInput.MinNodeCount
		properties.MinNodeCount = &minNodeCount
	}

	// No error
	return nil
}

// AssignProperties_From_AutoScaleProperties_STATUS populates our AutoScaleProperties_STATUS from the provided source AutoScaleProperties_STATUS
func (properties *AutoScaleProperties_STATUS) AssignProperties_From_AutoScaleProperties_STATUS(source *storage.AutoScaleProperties_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		properties.Enabled = &enabled
	} else {
		properties.Enabled = nil
	}

	// MaxNodeCount
	properties.MaxNodeCount = genruntime.ClonePointerToInt(source.MaxNodeCount)

	// MinNodeCount
	properties.MinNodeCount = genruntime.ClonePointerToInt(source.MinNodeCount)

	// No error
	return nil
}

// AssignProperties_To_AutoScaleProperties_STATUS populates the provided destination AutoScaleProperties_STATUS from our AutoScaleProperties_STATUS
func (properties *AutoScaleProperties_STATUS) AssignProperties_To_AutoScaleProperties_STATUS(destination *storage.AutoScaleProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if properties.Enabled != nil {
		enabled := *properties.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// MaxNodeCount
	destination.MaxNodeCount = genruntime.ClonePointerToInt(properties.MaxNodeCount)

	// MinNodeCount
	destination.MinNodeCount = genruntime.ClonePointerToInt(properties.MinNodeCount)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines an Aml Instance application and its connectivity endpoint URI.
type ComputeInstanceApplication_STATUS struct {
	// DisplayName: Name of the ComputeInstance application.
	DisplayName *string `json:"displayName,omitempty"`

	// EndpointUri: Application' endpoint URI.
	EndpointUri *string `json:"endpointUri,omitempty"`
}

var _ genruntime.FromARMConverter = &ComputeInstanceApplication_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (application *ComputeInstanceApplication_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComputeInstanceApplication_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (application *ComputeInstanceApplication_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComputeInstanceApplication_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComputeInstanceApplication_STATUS, got %T", armInput)
	}

	// Set property "DisplayName":
	if typedInput.DisplayName != nil {
		displayName := *typedInput.DisplayName
		application.DisplayName = &displayName
	}

	// Set property "EndpointUri":
	if typedInput.EndpointUri != nil {
		endpointUri := *typedInput.EndpointUri
		application.EndpointUri = &endpointUri
	}

	// No error
	return nil
}

// AssignProperties_From_ComputeInstanceApplication_STATUS populates our ComputeInstanceApplication_STATUS from the provided source ComputeInstanceApplication_STATUS
func (application *ComputeInstanceApplication_STATUS) AssignProperties_From_ComputeInstanceApplication_STATUS(source *storage.ComputeInstanceApplication_STATUS) error {

	// DisplayName
	application.DisplayName = genruntime.ClonePointerToString(source.DisplayName)

	// EndpointUri
	application.EndpointUri = genruntime.ClonePointerToString(source.EndpointUri)

	// No error
	return nil
}

// AssignProperties_To_ComputeInstanceApplication_STATUS populates the provided destination ComputeInstanceApplication_STATUS from our ComputeInstanceApplication_STATUS
func (application *ComputeInstanceApplication_STATUS) AssignProperties_To_ComputeInstanceApplication_STATUS(destination *storage.ComputeInstanceApplication_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DisplayName
	destination.DisplayName = genruntime.ClonePointerToString(application.DisplayName)

	// EndpointUri
	destination.EndpointUri = genruntime.ClonePointerToString(application.EndpointUri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines all connectivity endpoints and properties for an ComputeInstance.
type ComputeInstanceConnectivityEndpoints_STATUS struct {
	// PrivateIpAddress: Private IP Address of this ComputeInstance (local to the VNET in which the compute instance is
	// deployed).
	PrivateIpAddress *string `json:"privateIpAddress,omitempty"`

	// PublicIpAddress: Public IP Address of this ComputeInstance.
	PublicIpAddress *string `json:"publicIpAddress,omitempty"`
}

var _ genruntime.FromARMConverter = &ComputeInstanceConnectivityEndpoints_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (endpoints *ComputeInstanceConnectivityEndpoints_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComputeInstanceConnectivityEndpoints_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (endpoints *ComputeInstanceConnectivityEndpoints_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComputeInstanceConnectivityEndpoints_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComputeInstanceConnectivityEndpoints_STATUS, got %T", armInput)
	}

	// Set property "PrivateIpAddress":
	if typedInput.PrivateIpAddress != nil {
		privateIpAddress := *typedInput.PrivateIpAddress
		endpoints.PrivateIpAddress = &privateIpAddress
	}

	// Set property "PublicIpAddress":
	if typedInput.PublicIpAddress != nil {
		publicIpAddress := *typedInput.PublicIpAddress
		endpoints.PublicIpAddress = &publicIpAddress
	}

	// No error
	return nil
}

// AssignProperties_From_ComputeInstanceConnectivityEndpoints_STATUS populates our ComputeInstanceConnectivityEndpoints_STATUS from the provided source ComputeInstanceConnectivityEndpoints_STATUS
func (endpoints *ComputeInstanceConnectivityEndpoints_STATUS) AssignProperties_From_ComputeInstanceConnectivityEndpoints_STATUS(source *storage.ComputeInstanceConnectivityEndpoints_STATUS) error {

	// PrivateIpAddress
	endpoints.PrivateIpAddress = genruntime.ClonePointerToString(source.PrivateIpAddress)

	// PublicIpAddress
	endpoints.PublicIpAddress = genruntime.ClonePointerToString(source.PublicIpAddress)

	// No error
	return nil
}

// AssignProperties_To_ComputeInstanceConnectivityEndpoints_STATUS populates the provided destination ComputeInstanceConnectivityEndpoints_STATUS from our ComputeInstanceConnectivityEndpoints_STATUS
func (endpoints *ComputeInstanceConnectivityEndpoints_STATUS) AssignProperties_To_ComputeInstanceConnectivityEndpoints_STATUS(destination *storage.ComputeInstanceConnectivityEndpoints_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrivateIpAddress
	destination.PrivateIpAddress = genruntime.ClonePointerToString(endpoints.PrivateIpAddress)

	// PublicIpAddress
	destination.PublicIpAddress = genruntime.ClonePointerToString(endpoints.PublicIpAddress)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes information on user who created this ComputeInstance.
type ComputeInstanceCreatedBy_STATUS struct {
	// UserId: Uniquely identifies the user within his/her organization.
	UserId *string `json:"userId,omitempty"`

	// UserName: Name of the user.
	UserName *string `json:"userName,omitempty"`

	// UserOrgId: Uniquely identifies user' Azure Active Directory organization.
	UserOrgId *string `json:"userOrgId,omitempty"`
}

var _ genruntime.FromARMConverter = &ComputeInstanceCreatedBy_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (createdBy *ComputeInstanceCreatedBy_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComputeInstanceCreatedBy_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (createdBy *ComputeInstanceCreatedBy_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComputeInstanceCreatedBy_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComputeInstanceCreatedBy_STATUS, got %T", armInput)
	}

	// Set property "UserId":
	if typedInput.UserId != nil {
		userId := *typedInput.UserId
		createdBy.UserId = &userId
	}

	// Set property "UserName":
	if typedInput.UserName != nil {
		userName := *typedInput.UserName
		createdBy.UserName = &userName
	}

	// Set property "UserOrgId":
	if typedInput.UserOrgId != nil {
		userOrgId := *typedInput.UserOrgId
		createdBy.UserOrgId = &userOrgId
	}

	// No error
	return nil
}

// AssignProperties_From_ComputeInstanceCreatedBy_STATUS populates our ComputeInstanceCreatedBy_STATUS from the provided source ComputeInstanceCreatedBy_STATUS
func (createdBy *ComputeInstanceCreatedBy_STATUS) AssignProperties_From_ComputeInstanceCreatedBy_STATUS(source *storage.ComputeInstanceCreatedBy_STATUS) error {

	// UserId
	createdBy.UserId = genruntime.ClonePointerToString(source.UserId)

	// UserName
	createdBy.UserName = genruntime.ClonePointerToString(source.UserName)

	// UserOrgId
	createdBy.UserOrgId = genruntime.ClonePointerToString(source.UserOrgId)

	// No error
	return nil
}

// AssignProperties_To_ComputeInstanceCreatedBy_STATUS populates the provided destination ComputeInstanceCreatedBy_STATUS from our ComputeInstanceCreatedBy_STATUS
func (createdBy *ComputeInstanceCreatedBy_STATUS) AssignProperties_To_ComputeInstanceCreatedBy_STATUS(destination *storage.ComputeInstanceCreatedBy_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// UserId
	destination.UserId = genruntime.ClonePointerToString(createdBy.UserId)

	// UserName
	destination.UserName = genruntime.ClonePointerToString(createdBy.UserName)

	// UserOrgId
	destination.UserOrgId = genruntime.ClonePointerToString(createdBy.UserOrgId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The last operation on ComputeInstance.
type ComputeInstanceLastOperation_STATUS struct {
	// OperationName: Name of the last operation.
	OperationName *ComputeInstanceLastOperation_OperationName_STATUS `json:"operationName,omitempty"`

	// OperationStatus: Operation status.
	OperationStatus *ComputeInstanceLastOperation_OperationStatus_STATUS `json:"operationStatus,omitempty"`

	// OperationTime: Time of the last operation.
	OperationTime *string `json:"operationTime,omitempty"`
}

var _ genruntime.FromARMConverter = &ComputeInstanceLastOperation_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (operation *ComputeInstanceLastOperation_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComputeInstanceLastOperation_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (operation *ComputeInstanceLastOperation_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComputeInstanceLastOperation_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComputeInstanceLastOperation_STATUS, got %T", armInput)
	}

	// Set property "OperationName":
	if typedInput.OperationName != nil {
		var temp string
		temp = string(*typedInput.OperationName)
		operationName := ComputeInstanceLastOperation_OperationName_STATUS(temp)
		operation.OperationName = &operationName
	}

	// Set property "OperationStatus":
	if typedInput.OperationStatus != nil {
		var temp string
		temp = string(*typedInput.OperationStatus)
		operationStatus := ComputeInstanceLastOperation_OperationStatus_STATUS(temp)
		operation.OperationStatus = &operationStatus
	}

	// Set property "OperationTime":
	if typedInput.OperationTime != nil {
		operationTime := *typedInput.OperationTime
		operation.OperationTime = &operationTime
	}

	// No error
	return nil
}

// AssignProperties_From_ComputeInstanceLastOperation_STATUS populates our ComputeInstanceLastOperation_STATUS from the provided source ComputeInstanceLastOperation_STATUS
func (operation *ComputeInstanceLastOperation_STATUS) AssignProperties_From_ComputeInstanceLastOperation_STATUS(source *storage.ComputeInstanceLastOperation_STATUS) error {

	// OperationName
	if source.OperationName != nil {
		operationName := *source.OperationName
		operationNameTemp := genruntime.ToEnum(operationName, computeInstanceLastOperation_OperationName_STATUS_Values)
		operation.OperationName = &operationNameTemp
	} else {
		operation.OperationName = nil
	}

	// OperationStatus
	if source.OperationStatus != nil {
		operationStatus := *source.OperationStatus
		operationStatusTemp := genruntime.ToEnum(operationStatus, computeInstanceLastOperation_OperationStatus_STATUS_Values)
		operation.OperationStatus = &operationStatusTemp
	} else {
		operation.OperationStatus = nil
	}

	// OperationTime
	operation.OperationTime = genruntime.ClonePointerToString(source.OperationTime)

	// No error
	return nil
}

// AssignProperties_To_ComputeInstanceLastOperation_STATUS populates the provided destination ComputeInstanceLastOperation_STATUS from our ComputeInstanceLastOperation_STATUS
func (operation *ComputeInstanceLastOperation_STATUS) AssignProperties_To_ComputeInstanceLastOperation_STATUS(destination *storage.ComputeInstanceLastOperation_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// OperationName
	if operation.OperationName != nil {
		operationName := string(*operation.OperationName)
		destination.OperationName = &operationName
	} else {
		destination.OperationName = nil
	}

	// OperationStatus
	if operation.OperationStatus != nil {
		operationStatus := string(*operation.OperationStatus)
		destination.OperationStatus = &operationStatus
	} else {
		destination.OperationStatus = nil
	}

	// OperationTime
	destination.OperationTime = genruntime.ClonePointerToString(operation.OperationTime)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Personal","Shared"}
type ComputeInstanceProperties_ApplicationSharingPolicy string

const (
	ComputeInstanceProperties_ApplicationSharingPolicy_Personal = ComputeInstanceProperties_ApplicationSharingPolicy("Personal")
	ComputeInstanceProperties_ApplicationSharingPolicy_Shared   = ComputeInstanceProperties_ApplicationSharingPolicy("Shared")
)

// Mapping from string to ComputeInstanceProperties_ApplicationSharingPolicy
var computeInstanceProperties_ApplicationSharingPolicy_Values = map[string]ComputeInstanceProperties_ApplicationSharingPolicy{
	"personal": ComputeInstanceProperties_ApplicationSharingPolicy_Personal,
	"shared":   ComputeInstanceProperties_ApplicationSharingPolicy_Shared,
}

type ComputeInstanceProperties_ApplicationSharingPolicy_STATUS string

const (
	ComputeInstanceProperties_ApplicationSharingPolicy_STATUS_Personal = ComputeInstanceProperties_ApplicationSharingPolicy_STATUS("Personal")
	ComputeInstanceProperties_ApplicationSharingPolicy_STATUS_Shared   = ComputeInstanceProperties_ApplicationSharingPolicy_STATUS("Shared")
)

// Mapping from string to ComputeInstanceProperties_ApplicationSharingPolicy_STATUS
var computeInstanceProperties_ApplicationSharingPolicy_STATUS_Values = map[string]ComputeInstanceProperties_ApplicationSharingPolicy_STATUS{
	"personal": ComputeInstanceProperties_ApplicationSharingPolicy_STATUS_Personal,
	"shared":   ComputeInstanceProperties_ApplicationSharingPolicy_STATUS_Shared,
}

// +kubebuilder:validation:Enum={"personal"}
type ComputeInstanceProperties_ComputeInstanceAuthorizationType string

const ComputeInstanceProperties_ComputeInstanceAuthorizationType_Personal = ComputeInstanceProperties_ComputeInstanceAuthorizationType("personal")

// Mapping from string to ComputeInstanceProperties_ComputeInstanceAuthorizationType
var computeInstanceProperties_ComputeInstanceAuthorizationType_Values = map[string]ComputeInstanceProperties_ComputeInstanceAuthorizationType{
	"personal": ComputeInstanceProperties_ComputeInstanceAuthorizationType_Personal,
}

type ComputeInstanceProperties_ComputeInstanceAuthorizationType_STATUS string

const ComputeInstanceProperties_ComputeInstanceAuthorizationType_STATUS_Personal = ComputeInstanceProperties_ComputeInstanceAuthorizationType_STATUS("personal")

// Mapping from string to ComputeInstanceProperties_ComputeInstanceAuthorizationType_STATUS
var computeInstanceProperties_ComputeInstanceAuthorizationType_STATUS_Values = map[string]ComputeInstanceProperties_ComputeInstanceAuthorizationType_STATUS{
	"personal": ComputeInstanceProperties_ComputeInstanceAuthorizationType_STATUS_Personal,
}

// Specifies policy and settings for SSH access.
type ComputeInstanceSshSettings struct {
	// AdminPublicKey: Specifies the SSH rsa public key file as a string. Use "ssh-keygen -t rsa -b 2048" to generate your SSH
	// key pairs.
	AdminPublicKey *string `json:"adminPublicKey,omitempty"`

	// SshPublicAccess: State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is
	// closed on this instance. Enabled - Indicates that the public ssh port is open and accessible according to the
	// VNet/subnet policy if applicable.
	SshPublicAccess *ComputeInstanceSshSettings_SshPublicAccess `json:"sshPublicAccess,omitempty"`
}

var _ genruntime.ARMTransformer = &ComputeInstanceSshSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *ComputeInstanceSshSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.ComputeInstanceSshSettings{}

	// Set property "AdminPublicKey":
	if settings.AdminPublicKey != nil {
		adminPublicKey := *settings.AdminPublicKey
		result.AdminPublicKey = &adminPublicKey
	}

	// Set property "SshPublicAccess":
	if settings.SshPublicAccess != nil {
		var temp string
		temp = string(*settings.SshPublicAccess)
		sshPublicAccess := arm.ComputeInstanceSshSettings_SshPublicAccess(temp)
		result.SshPublicAccess = &sshPublicAccess
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *ComputeInstanceSshSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComputeInstanceSshSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *ComputeInstanceSshSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComputeInstanceSshSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComputeInstanceSshSettings, got %T", armInput)
	}

	// Set property "AdminPublicKey":
	if typedInput.AdminPublicKey != nil {
		adminPublicKey := *typedInput.AdminPublicKey
		settings.AdminPublicKey = &adminPublicKey
	}

	// Set property "SshPublicAccess":
	if typedInput.SshPublicAccess != nil {
		var temp string
		temp = string(*typedInput.SshPublicAccess)
		sshPublicAccess := ComputeInstanceSshSettings_SshPublicAccess(temp)
		settings.SshPublicAccess = &sshPublicAccess
	}

	// No error
	return nil
}

// AssignProperties_From_ComputeInstanceSshSettings populates our ComputeInstanceSshSettings from the provided source ComputeInstanceSshSettings
func (settings *ComputeInstanceSshSettings) AssignProperties_From_ComputeInstanceSshSettings(source *storage.ComputeInstanceSshSettings) error {

	// AdminPublicKey
	settings.AdminPublicKey = genruntime.ClonePointerToString(source.AdminPublicKey)

	// SshPublicAccess
	if source.SshPublicAccess != nil {
		sshPublicAccess := *source.SshPublicAccess
		sshPublicAccessTemp := genruntime.ToEnum(sshPublicAccess, computeInstanceSshSettings_SshPublicAccess_Values)
		settings.SshPublicAccess = &sshPublicAccessTemp
	} else {
		settings.SshPublicAccess = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ComputeInstanceSshSettings populates the provided destination ComputeInstanceSshSettings from our ComputeInstanceSshSettings
func (settings *ComputeInstanceSshSettings) AssignProperties_To_ComputeInstanceSshSettings(destination *storage.ComputeInstanceSshSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminPublicKey
	destination.AdminPublicKey = genruntime.ClonePointerToString(settings.AdminPublicKey)

	// SshPublicAccess
	if settings.SshPublicAccess != nil {
		sshPublicAccess := string(*settings.SshPublicAccess)
		destination.SshPublicAccess = &sshPublicAccess
	} else {
		destination.SshPublicAccess = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Specifies policy and settings for SSH access.
type ComputeInstanceSshSettings_STATUS struct {
	// AdminPublicKey: Specifies the SSH rsa public key file as a string. Use "ssh-keygen -t rsa -b 2048" to generate your SSH
	// key pairs.
	AdminPublicKey *string `json:"adminPublicKey,omitempty"`

	// AdminUserName: Describes the admin user name.
	AdminUserName *string `json:"adminUserName,omitempty"`

	// SshPort: Describes the port for connecting through SSH.
	SshPort *int `json:"sshPort,omitempty"`

	// SshPublicAccess: State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is
	// closed on this instance. Enabled - Indicates that the public ssh port is open and accessible according to the
	// VNet/subnet policy if applicable.
	SshPublicAccess *ComputeInstanceSshSettings_SshPublicAccess_STATUS `json:"sshPublicAccess,omitempty"`
}

var _ genruntime.FromARMConverter = &ComputeInstanceSshSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *ComputeInstanceSshSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComputeInstanceSshSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *ComputeInstanceSshSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComputeInstanceSshSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComputeInstanceSshSettings_STATUS, got %T", armInput)
	}

	// Set property "AdminPublicKey":
	if typedInput.AdminPublicKey != nil {
		adminPublicKey := *typedInput.AdminPublicKey
		settings.AdminPublicKey = &adminPublicKey
	}

	// Set property "AdminUserName":
	if typedInput.AdminUserName != nil {
		adminUserName := *typedInput.AdminUserName
		settings.AdminUserName = &adminUserName
	}

	// Set property "SshPort":
	if typedInput.SshPort != nil {
		sshPort := *typedInput.SshPort
		settings.SshPort = &sshPort
	}

	// Set property "SshPublicAccess":
	if typedInput.SshPublicAccess != nil {
		var temp string
		temp = string(*typedInput.SshPublicAccess)
		sshPublicAccess := ComputeInstanceSshSettings_SshPublicAccess_STATUS(temp)
		settings.SshPublicAccess = &sshPublicAccess
	}

	// No error
	return nil
}

// AssignProperties_From_ComputeInstanceSshSettings_STATUS populates our ComputeInstanceSshSettings_STATUS from the provided source ComputeInstanceSshSettings_STATUS
func (settings *ComputeInstanceSshSettings_STATUS) AssignProperties_From_ComputeInstanceSshSettings_STATUS(source *storage.ComputeInstanceSshSettings_STATUS) error {

	// AdminPublicKey
	settings.AdminPublicKey = genruntime.ClonePointerToString(source.AdminPublicKey)

	// AdminUserName
	settings.AdminUserName = genruntime.ClonePointerToString(source.AdminUserName)

	// SshPort
	settings.SshPort = genruntime.ClonePointerToInt(source.SshPort)

	// SshPublicAccess
	if source.SshPublicAccess != nil {
		sshPublicAccess := *source.SshPublicAccess
		sshPublicAccessTemp := genruntime.ToEnum(sshPublicAccess, computeInstanceSshSettings_SshPublicAccess_STATUS_Values)
		settings.SshPublicAccess = &sshPublicAccessTemp
	} else {
		settings.SshPublicAccess = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ComputeInstanceSshSettings_STATUS populates the provided destination ComputeInstanceSshSettings_STATUS from our ComputeInstanceSshSettings_STATUS
func (settings *ComputeInstanceSshSettings_STATUS) AssignProperties_To_ComputeInstanceSshSettings_STATUS(destination *storage.ComputeInstanceSshSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminPublicKey
	destination.AdminPublicKey = genruntime.ClonePointerToString(settings.AdminPublicKey)

	// AdminUserName
	destination.AdminUserName = genruntime.ClonePointerToString(settings.AdminUserName)

	// SshPort
	destination.SshPort = genruntime.ClonePointerToInt(settings.SshPort)

	// SshPublicAccess
	if settings.SshPublicAccess != nil {
		sshPublicAccess := string(*settings.SshPublicAccess)
		destination.SshPublicAccess = &sshPublicAccess
	} else {
		destination.SshPublicAccess = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Current state of an ComputeInstance.
type ComputeInstanceState_STATUS string

const (
	ComputeInstanceState_STATUS_CreateFailed    = ComputeInstanceState_STATUS("CreateFailed")
	ComputeInstanceState_STATUS_Creating        = ComputeInstanceState_STATUS("Creating")
	ComputeInstanceState_STATUS_Deleting        = ComputeInstanceState_STATUS("Deleting")
	ComputeInstanceState_STATUS_JobRunning      = ComputeInstanceState_STATUS("JobRunning")
	ComputeInstanceState_STATUS_Restarting      = ComputeInstanceState_STATUS("Restarting")
	ComputeInstanceState_STATUS_Running         = ComputeInstanceState_STATUS("Running")
	ComputeInstanceState_STATUS_SettingUp       = ComputeInstanceState_STATUS("SettingUp")
	ComputeInstanceState_STATUS_SetupFailed     = ComputeInstanceState_STATUS("SetupFailed")
	ComputeInstanceState_STATUS_Starting        = ComputeInstanceState_STATUS("Starting")
	ComputeInstanceState_STATUS_Stopped         = ComputeInstanceState_STATUS("Stopped")
	ComputeInstanceState_STATUS_Stopping        = ComputeInstanceState_STATUS("Stopping")
	ComputeInstanceState_STATUS_Unknown         = ComputeInstanceState_STATUS("Unknown")
	ComputeInstanceState_STATUS_Unusable        = ComputeInstanceState_STATUS("Unusable")
	ComputeInstanceState_STATUS_UserSettingUp   = ComputeInstanceState_STATUS("UserSettingUp")
	ComputeInstanceState_STATUS_UserSetupFailed = ComputeInstanceState_STATUS("UserSetupFailed")
)

// Mapping from string to ComputeInstanceState_STATUS
var computeInstanceState_STATUS_Values = map[string]ComputeInstanceState_STATUS{
	"createfailed":    ComputeInstanceState_STATUS_CreateFailed,
	"creating":        ComputeInstanceState_STATUS_Creating,
	"deleting":        ComputeInstanceState_STATUS_Deleting,
	"jobrunning":      ComputeInstanceState_STATUS_JobRunning,
	"restarting":      ComputeInstanceState_STATUS_Restarting,
	"running":         ComputeInstanceState_STATUS_Running,
	"settingup":       ComputeInstanceState_STATUS_SettingUp,
	"setupfailed":     ComputeInstanceState_STATUS_SetupFailed,
	"starting":        ComputeInstanceState_STATUS_Starting,
	"stopped":         ComputeInstanceState_STATUS_Stopped,
	"stopping":        ComputeInstanceState_STATUS_Stopping,
	"unknown":         ComputeInstanceState_STATUS_Unknown,
	"unusable":        ComputeInstanceState_STATUS_Unusable,
	"usersettingup":   ComputeInstanceState_STATUS_UserSettingUp,
	"usersetupfailed": ComputeInstanceState_STATUS_UserSetupFailed,
}

// The error detail.
type ErrorDetail_STATUS struct {
	// AdditionalInfo: The error additional info.
	AdditionalInfo []ErrorAdditionalInfo_STATUS `json:"additionalInfo,omitempty"`

	// Code: The error code.
	Code *string `json:"code,omitempty"`

	// Details: The error details.
	Details []ErrorDetail_STATUS_Unrolled `json:"details,omitempty"`

	// Message: The error message.
	Message *string `json:"message,omitempty"`

	// Target: The error target.
	Target *string `json:"target,omitempty"`
}

var _ genruntime.FromARMConverter = &ErrorDetail_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (detail *ErrorDetail_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ErrorDetail_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (detail *ErrorDetail_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ErrorDetail_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ErrorDetail_STATUS, got %T", armInput)
	}

	// Set property "AdditionalInfo":
	for _, item := range typedInput.AdditionalInfo {
		var item1 ErrorAdditionalInfo_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		detail.AdditionalInfo = append(detail.AdditionalInfo, item1)
	}

	// Set property "Code":
	if typedInput.Code != nil {
		code := *typedInput.Code
		detail.Code = &code
	}

	// Set property "Details":
	for _, item := range typedInput.Details {
		var item1 ErrorDetail_STATUS_Unrolled
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		detail.Details = append(detail.Details, item1)
	}

	// Set property "Message":
	if typedInput.Message != nil {
		message := *typedInput.Message
		detail.Message = &message
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		detail.Target = &target
	}

	// No error
	return nil
}

// AssignProperties_From_ErrorDetail_STATUS populates our ErrorDetail_STATUS from the provided source ErrorDetail_STATUS
func (detail *ErrorDetail_STATUS) AssignProperties_From_ErrorDetail_STATUS(source *storage.ErrorDetail_STATUS) error {

	// AdditionalInfo
	if source.AdditionalInfo != nil {
		additionalInfoList := make([]ErrorAdditionalInfo_STATUS, len(source.AdditionalInfo))
		for additionalInfoIndex, additionalInfoItem := range source.AdditionalInfo {
			// Shadow the loop variable to avoid aliasing
			additionalInfoItem := additionalInfoItem
			var additionalInfo ErrorAdditionalInfo_STATUS
			err := additionalInfo.AssignProperties_From_ErrorAdditionalInfo_STATUS(&additionalInfoItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ErrorAdditionalInfo_STATUS() to populate field AdditionalInfo")
			}
			additionalInfoList[additionalInfoIndex] = additionalInfo
		}
		detail.AdditionalInfo = additionalInfoList
	} else {
		detail.AdditionalInfo = nil
	}

	// Code
	detail.Code = genruntime.ClonePointerToString(source.Code)

	// Details
	if source.Details != nil {
		detailList := make([]ErrorDetail_STATUS_Unrolled, len(source.Details))
		for detailIndex, detailItem := range source.Details {
			// Shadow the loop variable to avoid aliasing
			detailItem := detailItem
			var detailLocal ErrorDetail_STATUS_Unrolled
			err := detailLocal.AssignProperties_From_ErrorDetail_STATUS_Unrolled(&detailItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ErrorDetail_STATUS_Unrolled() to populate field Details")
			}
			detailList[detailIndex] = detailLocal
		}
		detail.Details = detailList
	} else {
		detail.Details = nil
	}

	// Message
	detail.Message = genruntime.ClonePointerToString(source.Message)

	// Target
	detail.Target = genruntime.ClonePointerToString(source.Target)

	// No error
	return nil
}

// AssignProperties_To_ErrorDetail_STATUS populates the provided destination ErrorDetail_STATUS from our ErrorDetail_STATUS
func (detail *ErrorDetail_STATUS) AssignProperties_To_ErrorDetail_STATUS(destination *storage.ErrorDetail_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalInfo
	if detail.AdditionalInfo != nil {
		additionalInfoList := make([]storage.ErrorAdditionalInfo_STATUS, len(detail.AdditionalInfo))
		for additionalInfoIndex, additionalInfoItem := range detail.AdditionalInfo {
			// Shadow the loop variable to avoid aliasing
			additionalInfoItem := additionalInfoItem
			var additionalInfo storage.ErrorAdditionalInfo_STATUS
			err := additionalInfoItem.AssignProperties_To_ErrorAdditionalInfo_STATUS(&additionalInfo)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ErrorAdditionalInfo_STATUS() to populate field AdditionalInfo")
			}
			additionalInfoList[additionalInfoIndex] = additionalInfo
		}
		destination.AdditionalInfo = additionalInfoList
	} else {
		destination.AdditionalInfo = nil
	}

	// Code
	destination.Code = genruntime.ClonePointerToString(detail.Code)

	// Details
	if detail.Details != nil {
		detailList := make([]storage.ErrorDetail_STATUS_Unrolled, len(detail.Details))
		for detailIndex, detailItem := range detail.Details {
			// Shadow the loop variable to avoid aliasing
			detailItem := detailItem
			var detailLocal storage.ErrorDetail_STATUS_Unrolled
			err := detailItem.AssignProperties_To_ErrorDetail_STATUS_Unrolled(&detailLocal)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ErrorDetail_STATUS_Unrolled() to populate field Details")
			}
			detailList[detailIndex] = detailLocal
		}
		destination.Details = detailList
	} else {
		destination.Details = nil
	}

	// Message
	destination.Message = genruntime.ClonePointerToString(detail.Message)

	// Target
	destination.Target = genruntime.ClonePointerToString(detail.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Instance type schema.
type InstanceTypeSchema struct {
	// NodeSelector: Node Selector
	NodeSelector map[string]string `json:"nodeSelector,omitempty"`

	// Resources: Resource requests/limits for this instance type
	Resources *InstanceTypeSchema_Resources `json:"resources,omitempty"`
}

var _ genruntime.ARMTransformer = &InstanceTypeSchema{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (schema *InstanceTypeSchema) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if schema == nil {
		return nil, nil
	}
	result := &arm.InstanceTypeSchema{}

	// Set property "NodeSelector":
	if schema.NodeSelector != nil {
		result.NodeSelector = make(map[string]string, len(schema.NodeSelector))
		for key, value := range schema.NodeSelector {
			result.NodeSelector[key] = value
		}
	}

	// Set property "Resources":
	if schema.Resources != nil {
		resources_ARM, err := (*schema.Resources).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		resources := *resources_ARM.(*arm.InstanceTypeSchema_Resources)
		result.Resources = &resources
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (schema *InstanceTypeSchema) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.InstanceTypeSchema{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (schema *InstanceTypeSchema) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.InstanceTypeSchema)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.InstanceTypeSchema, got %T", armInput)
	}

	// Set property "NodeSelector":
	if typedInput.NodeSelector != nil {
		schema.NodeSelector = make(map[string]string, len(typedInput.NodeSelector))
		for key, value := range typedInput.NodeSelector {
			schema.NodeSelector[key] = value
		}
	}

	// Set property "Resources":
	if typedInput.Resources != nil {
		var resources1 InstanceTypeSchema_Resources
		err := resources1.PopulateFromARM(owner, *typedInput.Resources)
		if err != nil {
			return err
		}
		resources := resources1
		schema.Resources = &resources
	}

	// No error
	return nil
}

// AssignProperties_From_InstanceTypeSchema populates our InstanceTypeSchema from the provided source InstanceTypeSchema
func (schema *InstanceTypeSchema) AssignProperties_From_InstanceTypeSchema(source *storage.InstanceTypeSchema) error {

	// NodeSelector
	schema.NodeSelector = genruntime.CloneMapOfStringToString(source.NodeSelector)

	// Resources
	if source.Resources != nil {
		var resource InstanceTypeSchema_Resources
		err := resource.AssignProperties_From_InstanceTypeSchema_Resources(source.Resources)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_InstanceTypeSchema_Resources() to populate field Resources")
		}
		schema.Resources = &resource
	} else {
		schema.Resources = nil
	}

	// No error
	return nil
}

// AssignProperties_To_InstanceTypeSchema populates the provided destination InstanceTypeSchema from our InstanceTypeSchema
func (schema *InstanceTypeSchema) AssignProperties_To_InstanceTypeSchema(destination *storage.InstanceTypeSchema) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// NodeSelector
	destination.NodeSelector = genruntime.CloneMapOfStringToString(schema.NodeSelector)

	// Resources
	if schema.Resources != nil {
		var resource storage.InstanceTypeSchema_Resources
		err := schema.Resources.AssignProperties_To_InstanceTypeSchema_Resources(&resource)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_InstanceTypeSchema_Resources() to populate field Resources")
		}
		destination.Resources = &resource
	} else {
		destination.Resources = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Instance type schema.
type InstanceTypeSchema_STATUS struct {
	// NodeSelector: Node Selector
	NodeSelector map[string]string `json:"nodeSelector,omitempty"`

	// Resources: Resource requests/limits for this instance type
	Resources *InstanceTypeSchema_Resources_STATUS `json:"resources,omitempty"`
}

var _ genruntime.FromARMConverter = &InstanceTypeSchema_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (schema *InstanceTypeSchema_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.InstanceTypeSchema_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (schema *InstanceTypeSchema_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.InstanceTypeSchema_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.InstanceTypeSchema_STATUS, got %T", armInput)
	}

	// Set property "NodeSelector":
	if typedInput.NodeSelector != nil {
		schema.NodeSelector = make(map[string]string, len(typedInput.NodeSelector))
		for key, value := range typedInput.NodeSelector {
			schema.NodeSelector[key] = value
		}
	}

	// Set property "Resources":
	if typedInput.Resources != nil {
		var resources1 InstanceTypeSchema_Resources_STATUS
		err := resources1.PopulateFromARM(owner, *typedInput.Resources)
		if err != nil {
			return err
		}
		resources := resources1
		schema.Resources = &resources
	}

	// No error
	return nil
}

// AssignProperties_From_InstanceTypeSchema_STATUS populates our InstanceTypeSchema_STATUS from the provided source InstanceTypeSchema_STATUS
func (schema *InstanceTypeSchema_STATUS) AssignProperties_From_InstanceTypeSchema_STATUS(source *storage.InstanceTypeSchema_STATUS) error {

	// NodeSelector
	schema.NodeSelector = genruntime.CloneMapOfStringToString(source.NodeSelector)

	// Resources
	if source.Resources != nil {
		var resource InstanceTypeSchema_Resources_STATUS
		err := resource.AssignProperties_From_InstanceTypeSchema_Resources_STATUS(source.Resources)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_InstanceTypeSchema_Resources_STATUS() to populate field Resources")
		}
		schema.Resources = &resource
	} else {
		schema.Resources = nil
	}

	// No error
	return nil
}

// AssignProperties_To_InstanceTypeSchema_STATUS populates the provided destination InstanceTypeSchema_STATUS from our InstanceTypeSchema_STATUS
func (schema *InstanceTypeSchema_STATUS) AssignProperties_To_InstanceTypeSchema_STATUS(destination *storage.InstanceTypeSchema_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// NodeSelector
	destination.NodeSelector = genruntime.CloneMapOfStringToString(schema.NodeSelector)

	// Resources
	if schema.Resources != nil {
		var resource storage.InstanceTypeSchema_Resources_STATUS
		err := schema.Resources.AssignProperties_To_InstanceTypeSchema_Resources_STATUS(&resource)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_InstanceTypeSchema_Resources_STATUS() to populate field Resources")
		}
		destination.Resources = &resource
	} else {
		destination.Resources = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Counts of various compute node states on the amlCompute.
type NodeStateCounts_STATUS struct {
	// IdleNodeCount: Number of compute nodes in idle state.
	IdleNodeCount *int `json:"idleNodeCount,omitempty"`

	// LeavingNodeCount: Number of compute nodes which are leaving the amlCompute.
	LeavingNodeCount *int `json:"leavingNodeCount,omitempty"`

	// PreemptedNodeCount: Number of compute nodes which are in preempted state.
	PreemptedNodeCount *int `json:"preemptedNodeCount,omitempty"`

	// PreparingNodeCount: Number of compute nodes which are being prepared.
	PreparingNodeCount *int `json:"preparingNodeCount,omitempty"`

	// RunningNodeCount: Number of compute nodes which are running jobs.
	RunningNodeCount *int `json:"runningNodeCount,omitempty"`

	// UnusableNodeCount: Number of compute nodes which are in unusable state.
	UnusableNodeCount *int `json:"unusableNodeCount,omitempty"`
}

var _ genruntime.FromARMConverter = &NodeStateCounts_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (counts *NodeStateCounts_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NodeStateCounts_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (counts *NodeStateCounts_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NodeStateCounts_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NodeStateCounts_STATUS, got %T", armInput)
	}

	// Set property "IdleNodeCount":
	if typedInput.IdleNodeCount != nil {
		idleNodeCount := *typedInput.IdleNodeCount
		counts.IdleNodeCount = &idleNodeCount
	}

	// Set property "LeavingNodeCount":
	if typedInput.LeavingNodeCount != nil {
		leavingNodeCount := *typedInput.LeavingNodeCount
		counts.LeavingNodeCount = &leavingNodeCount
	}

	// Set property "PreemptedNodeCount":
	if typedInput.PreemptedNodeCount != nil {
		preemptedNodeCount := *typedInput.PreemptedNodeCount
		counts.PreemptedNodeCount = &preemptedNodeCount
	}

	// Set property "PreparingNodeCount":
	if typedInput.PreparingNodeCount != nil {
		preparingNodeCount := *typedInput.PreparingNodeCount
		counts.PreparingNodeCount = &preparingNodeCount
	}

	// Set property "RunningNodeCount":
	if typedInput.RunningNodeCount != nil {
		runningNodeCount := *typedInput.RunningNodeCount
		counts.RunningNodeCount = &runningNodeCount
	}

	// Set property "UnusableNodeCount":
	if typedInput.UnusableNodeCount != nil {
		unusableNodeCount := *typedInput.UnusableNodeCount
		counts.UnusableNodeCount = &unusableNodeCount
	}

	// No error
	return nil
}

// AssignProperties_From_NodeStateCounts_STATUS populates our NodeStateCounts_STATUS from the provided source NodeStateCounts_STATUS
func (counts *NodeStateCounts_STATUS) AssignProperties_From_NodeStateCounts_STATUS(source *storage.NodeStateCounts_STATUS) error {

	// IdleNodeCount
	counts.IdleNodeCount = genruntime.ClonePointerToInt(source.IdleNodeCount)

	// LeavingNodeCount
	counts.LeavingNodeCount = genruntime.ClonePointerToInt(source.LeavingNodeCount)

	// PreemptedNodeCount
	counts.PreemptedNodeCount = genruntime.ClonePointerToInt(source.PreemptedNodeCount)

	// PreparingNodeCount
	counts.PreparingNodeCount = genruntime.ClonePointerToInt(source.PreparingNodeCount)

	// RunningNodeCount
	counts.RunningNodeCount = genruntime.ClonePointerToInt(source.RunningNodeCount)

	// UnusableNodeCount
	counts.UnusableNodeCount = genruntime.ClonePointerToInt(source.UnusableNodeCount)

	// No error
	return nil
}

// AssignProperties_To_NodeStateCounts_STATUS populates the provided destination NodeStateCounts_STATUS from our NodeStateCounts_STATUS
func (counts *NodeStateCounts_STATUS) AssignProperties_To_NodeStateCounts_STATUS(destination *storage.NodeStateCounts_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IdleNodeCount
	destination.IdleNodeCount = genruntime.ClonePointerToInt(counts.IdleNodeCount)

	// LeavingNodeCount
	destination.LeavingNodeCount = genruntime.ClonePointerToInt(counts.LeavingNodeCount)

	// PreemptedNodeCount
	destination.PreemptedNodeCount = genruntime.ClonePointerToInt(counts.PreemptedNodeCount)

	// PreparingNodeCount
	destination.PreparingNodeCount = genruntime.ClonePointerToInt(counts.PreparingNodeCount)

	// RunningNodeCount
	destination.RunningNodeCount = genruntime.ClonePointerToInt(counts.RunningNodeCount)

	// UnusableNodeCount
	destination.UnusableNodeCount = genruntime.ClonePointerToInt(counts.UnusableNodeCount)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Settings for a personal compute instance.
type PersonalComputeInstanceSettings struct {
	// AssignedUser: A user explicitly assigned to a personal compute instance.
	AssignedUser *AssignedUser `json:"assignedUser,omitempty"`
}

var _ genruntime.ARMTransformer = &PersonalComputeInstanceSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *PersonalComputeInstanceSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.PersonalComputeInstanceSettings{}

	// Set property "AssignedUser":
	if settings.AssignedUser != nil {
		assignedUser_ARM, err := (*settings.AssignedUser).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		assignedUser := *assignedUser_ARM.(*arm.AssignedUser)
		result.AssignedUser = &assignedUser
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *PersonalComputeInstanceSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PersonalComputeInstanceSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *PersonalComputeInstanceSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PersonalComputeInstanceSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PersonalComputeInstanceSettings, got %T", armInput)
	}

	// Set property "AssignedUser":
	if typedInput.AssignedUser != nil {
		var assignedUser1 AssignedUser
		err := assignedUser1.PopulateFromARM(owner, *typedInput.AssignedUser)
		if err != nil {
			return err
		}
		assignedUser := assignedUser1
		settings.AssignedUser = &assignedUser
	}

	// No error
	return nil
}

// AssignProperties_From_PersonalComputeInstanceSettings populates our PersonalComputeInstanceSettings from the provided source PersonalComputeInstanceSettings
func (settings *PersonalComputeInstanceSettings) AssignProperties_From_PersonalComputeInstanceSettings(source *storage.PersonalComputeInstanceSettings) error {

	// AssignedUser
	if source.AssignedUser != nil {
		var assignedUser AssignedUser
		err := assignedUser.AssignProperties_From_AssignedUser(source.AssignedUser)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AssignedUser() to populate field AssignedUser")
		}
		settings.AssignedUser = &assignedUser
	} else {
		settings.AssignedUser = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PersonalComputeInstanceSettings populates the provided destination PersonalComputeInstanceSettings from our PersonalComputeInstanceSettings
func (settings *PersonalComputeInstanceSettings) AssignProperties_To_PersonalComputeInstanceSettings(destination *storage.PersonalComputeInstanceSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AssignedUser
	if settings.AssignedUser != nil {
		var assignedUser storage.AssignedUser
		err := settings.AssignedUser.AssignProperties_To_AssignedUser(&assignedUser)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AssignedUser() to populate field AssignedUser")
		}
		destination.AssignedUser = &assignedUser
	} else {
		destination.AssignedUser = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Settings for a personal compute instance.
type PersonalComputeInstanceSettings_STATUS struct {
	// AssignedUser: A user explicitly assigned to a personal compute instance.
	AssignedUser *AssignedUser_STATUS `json:"assignedUser,omitempty"`
}

var _ genruntime.FromARMConverter = &PersonalComputeInstanceSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *PersonalComputeInstanceSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PersonalComputeInstanceSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *PersonalComputeInstanceSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PersonalComputeInstanceSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PersonalComputeInstanceSettings_STATUS, got %T", armInput)
	}

	// Set property "AssignedUser":
	if typedInput.AssignedUser != nil {
		var assignedUser1 AssignedUser_STATUS
		err := assignedUser1.PopulateFromARM(owner, *typedInput.AssignedUser)
		if err != nil {
			return err
		}
		assignedUser := assignedUser1
		settings.AssignedUser = &assignedUser
	}

	// No error
	return nil
}

// AssignProperties_From_PersonalComputeInstanceSettings_STATUS populates our PersonalComputeInstanceSettings_STATUS from the provided source PersonalComputeInstanceSettings_STATUS
func (settings *PersonalComputeInstanceSettings_STATUS) AssignProperties_From_PersonalComputeInstanceSettings_STATUS(source *storage.PersonalComputeInstanceSettings_STATUS) error {

	// AssignedUser
	if source.AssignedUser != nil {
		var assignedUser AssignedUser_STATUS
		err := assignedUser.AssignProperties_From_AssignedUser_STATUS(source.AssignedUser)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AssignedUser_STATUS() to populate field AssignedUser")
		}
		settings.AssignedUser = &assignedUser
	} else {
		settings.AssignedUser = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PersonalComputeInstanceSettings_STATUS populates the provided destination PersonalComputeInstanceSettings_STATUS from our PersonalComputeInstanceSettings_STATUS
func (settings *PersonalComputeInstanceSettings_STATUS) AssignProperties_To_PersonalComputeInstanceSettings_STATUS(destination *storage.PersonalComputeInstanceSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AssignedUser
	if settings.AssignedUser != nil {
		var assignedUser storage.AssignedUser_STATUS
		err := settings.AssignedUser.AssignProperties_To_AssignedUser_STATUS(&assignedUser)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AssignedUser_STATUS() to populate field AssignedUser")
		}
		destination.AssignedUser = &assignedUser
	} else {
		destination.AssignedUser = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Represents a resource ID. For example, for a subnet, it is the resource URL for the subnet.
type ResourceId struct {
	// +kubebuilder:validation:Required
	// Reference: The ID of the resource
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &ResourceId{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (resourceId *ResourceId) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if resourceId == nil {
		return nil, nil
	}
	result := &arm.ResourceId{}

	// Set property "Id":
	if resourceId.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*resourceId.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resourceId *ResourceId) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ResourceId{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resourceId *ResourceId) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(arm.ResourceId)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ResourceId, got %T", armInput)
	}

	// no assignment for property "Reference"

	// No error
	return nil
}

// AssignProperties_From_ResourceId populates our ResourceId from the provided source ResourceId
func (resourceId *ResourceId) AssignProperties_From_ResourceId(source *storage.ResourceId) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		resourceId.Reference = &reference
	} else {
		resourceId.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ResourceId populates the provided destination ResourceId from our ResourceId
func (resourceId *ResourceId) AssignProperties_To_ResourceId(destination *storage.ResourceId) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if resourceId.Reference != nil {
		reference := resourceId.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Represents a resource ID. For example, for a subnet, it is the resource URL for the subnet.
type ResourceId_STATUS struct {
	// Id: The ID of the resource
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ResourceId_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resourceId *ResourceId_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ResourceId_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resourceId *ResourceId_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ResourceId_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ResourceId_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		resourceId.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_ResourceId_STATUS populates our ResourceId_STATUS from the provided source ResourceId_STATUS
func (resourceId *ResourceId_STATUS) AssignProperties_From_ResourceId_STATUS(source *storage.ResourceId_STATUS) error {

	// Id
	resourceId.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_ResourceId_STATUS populates the provided destination ResourceId_STATUS from our ResourceId_STATUS
func (resourceId *ResourceId_STATUS) AssignProperties_To_ResourceId_STATUS(destination *storage.ResourceId_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(resourceId.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// scale settings for AML Compute
type ScaleSettings struct {
	// +kubebuilder:validation:Required
	// MaxNodeCount: Max number of nodes to use
	MaxNodeCount *int `json:"maxNodeCount,omitempty"`

	// MinNodeCount: Min number of nodes to use
	MinNodeCount *int `json:"minNodeCount,omitempty"`

	// NodeIdleTimeBeforeScaleDown: Node Idle Time before scaling down amlCompute. This string needs to be in the RFC Format.
	NodeIdleTimeBeforeScaleDown *string `json:"nodeIdleTimeBeforeScaleDown,omitempty"`
}

var _ genruntime.ARMTransformer = &ScaleSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *ScaleSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.ScaleSettings{}

	// Set property "MaxNodeCount":
	if settings.MaxNodeCount != nil {
		maxNodeCount := *settings.MaxNodeCount
		result.MaxNodeCount = &maxNodeCount
	}

	// Set property "MinNodeCount":
	if settings.MinNodeCount != nil {
		minNodeCount := *settings.MinNodeCount
		result.MinNodeCount = &minNodeCount
	}

	// Set property "NodeIdleTimeBeforeScaleDown":
	if settings.NodeIdleTimeBeforeScaleDown != nil {
		nodeIdleTimeBeforeScaleDown := *settings.NodeIdleTimeBeforeScaleDown
		result.NodeIdleTimeBeforeScaleDown = &nodeIdleTimeBeforeScaleDown
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *ScaleSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ScaleSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *ScaleSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ScaleSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ScaleSettings, got %T", armInput)
	}

	// Set property "MaxNodeCount":
	if typedInput.MaxNodeCount != nil {
		maxNodeCount := *typedInput.MaxNodeCount
		settings.MaxNodeCount = &maxNodeCount
	}

	// Set property "MinNodeCount":
	if typedInput.MinNodeCount != nil {
		minNodeCount := *typedInput.MinNodeCount
		settings.MinNodeCount = &minNodeCount
	}

	// Set property "NodeIdleTimeBeforeScaleDown":
	if typedInput.NodeIdleTimeBeforeScaleDown != nil {
		nodeIdleTimeBeforeScaleDown := *typedInput.NodeIdleTimeBeforeScaleDown
		settings.NodeIdleTimeBeforeScaleDown = &nodeIdleTimeBeforeScaleDown
	}

	// No error
	return nil
}

// AssignProperties_From_ScaleSettings populates our ScaleSettings from the provided source ScaleSettings
func (settings *ScaleSettings) AssignProperties_From_ScaleSettings(source *storage.ScaleSettings) error {

	// MaxNodeCount
	settings.MaxNodeCount = genruntime.ClonePointerToInt(source.MaxNodeCount)

	// MinNodeCount
	settings.MinNodeCount = genruntime.ClonePointerToInt(source.MinNodeCount)

	// NodeIdleTimeBeforeScaleDown
	settings.NodeIdleTimeBeforeScaleDown = genruntime.ClonePointerToString(source.NodeIdleTimeBeforeScaleDown)

	// No error
	return nil
}

// AssignProperties_To_ScaleSettings populates the provided destination ScaleSettings from our ScaleSettings
func (settings *ScaleSettings) AssignProperties_To_ScaleSettings(destination *storage.ScaleSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MaxNodeCount
	destination.MaxNodeCount = genruntime.ClonePointerToInt(settings.MaxNodeCount)

	// MinNodeCount
	destination.MinNodeCount = genruntime.ClonePointerToInt(settings.MinNodeCount)

	// NodeIdleTimeBeforeScaleDown
	destination.NodeIdleTimeBeforeScaleDown = genruntime.ClonePointerToString(settings.NodeIdleTimeBeforeScaleDown)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// scale settings for AML Compute
type ScaleSettings_STATUS struct {
	// MaxNodeCount: Max number of nodes to use
	MaxNodeCount *int `json:"maxNodeCount,omitempty"`

	// MinNodeCount: Min number of nodes to use
	MinNodeCount *int `json:"minNodeCount,omitempty"`

	// NodeIdleTimeBeforeScaleDown: Node Idle Time before scaling down amlCompute. This string needs to be in the RFC Format.
	NodeIdleTimeBeforeScaleDown *string `json:"nodeIdleTimeBeforeScaleDown,omitempty"`
}

var _ genruntime.FromARMConverter = &ScaleSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *ScaleSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ScaleSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *ScaleSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ScaleSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ScaleSettings_STATUS, got %T", armInput)
	}

	// Set property "MaxNodeCount":
	if typedInput.MaxNodeCount != nil {
		maxNodeCount := *typedInput.MaxNodeCount
		settings.MaxNodeCount = &maxNodeCount
	}

	// Set property "MinNodeCount":
	if typedInput.MinNodeCount != nil {
		minNodeCount := *typedInput.MinNodeCount
		settings.MinNodeCount = &minNodeCount
	}

	// Set property "NodeIdleTimeBeforeScaleDown":
	if typedInput.NodeIdleTimeBeforeScaleDown != nil {
		nodeIdleTimeBeforeScaleDown := *typedInput.NodeIdleTimeBeforeScaleDown
		settings.NodeIdleTimeBeforeScaleDown = &nodeIdleTimeBeforeScaleDown
	}

	// No error
	return nil
}

// AssignProperties_From_ScaleSettings_STATUS populates our ScaleSettings_STATUS from the provided source ScaleSettings_STATUS
func (settings *ScaleSettings_STATUS) AssignProperties_From_ScaleSettings_STATUS(source *storage.ScaleSettings_STATUS) error {

	// MaxNodeCount
	settings.MaxNodeCount = genruntime.ClonePointerToInt(source.MaxNodeCount)

	// MinNodeCount
	settings.MinNodeCount = genruntime.ClonePointerToInt(source.MinNodeCount)

	// NodeIdleTimeBeforeScaleDown
	settings.NodeIdleTimeBeforeScaleDown = genruntime.ClonePointerToString(source.NodeIdleTimeBeforeScaleDown)

	// No error
	return nil
}

// AssignProperties_To_ScaleSettings_STATUS populates the provided destination ScaleSettings_STATUS from our ScaleSettings_STATUS
func (settings *ScaleSettings_STATUS) AssignProperties_To_ScaleSettings_STATUS(destination *storage.ScaleSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MaxNodeCount
	destination.MaxNodeCount = genruntime.ClonePointerToInt(settings.MaxNodeCount)

	// MinNodeCount
	destination.MinNodeCount = genruntime.ClonePointerToInt(settings.MinNodeCount)

	// NodeIdleTimeBeforeScaleDown
	destination.NodeIdleTimeBeforeScaleDown = genruntime.ClonePointerToString(settings.NodeIdleTimeBeforeScaleDown)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details of customized scripts to execute for setting up the cluster.
type SetupScripts struct {
	// Scripts: Customized setup scripts
	Scripts *ScriptsToExecute `json:"scripts,omitempty"`
}

var _ genruntime.ARMTransformer = &SetupScripts{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (scripts *SetupScripts) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if scripts == nil {
		return nil, nil
	}
	result := &arm.SetupScripts{}

	// Set property "Scripts":
	if scripts.Scripts != nil {
		scripts_ARM, err := (*scripts.Scripts).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		scripts1 := *scripts_ARM.(*arm.ScriptsToExecute)
		result.Scripts = &scripts1
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (scripts *SetupScripts) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SetupScripts{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (scripts *SetupScripts) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SetupScripts)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SetupScripts, got %T", armInput)
	}

	// Set property "Scripts":
	if typedInput.Scripts != nil {
		var scripts2 ScriptsToExecute
		err := scripts2.PopulateFromARM(owner, *typedInput.Scripts)
		if err != nil {
			return err
		}
		scripts1 := scripts2
		scripts.Scripts = &scripts1
	}

	// No error
	return nil
}

// AssignProperties_From_SetupScripts populates our SetupScripts from the provided source SetupScripts
func (scripts *SetupScripts) AssignProperties_From_SetupScripts(source *storage.SetupScripts) error {

	// Scripts
	if source.Scripts != nil {
		var script ScriptsToExecute
		err := script.AssignProperties_From_ScriptsToExecute(source.Scripts)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ScriptsToExecute() to populate field Scripts")
		}
		scripts.Scripts = &script
	} else {
		scripts.Scripts = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SetupScripts populates the provided destination SetupScripts from our SetupScripts
func (scripts *SetupScripts) AssignProperties_To_SetupScripts(destination *storage.SetupScripts) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Scripts
	if scripts.Scripts != nil {
		var script storage.ScriptsToExecute
		err := scripts.Scripts.AssignProperties_To_ScriptsToExecute(&script)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ScriptsToExecute() to populate field Scripts")
		}
		destination.Scripts = &script
	} else {
		destination.Scripts = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details of customized scripts to execute for setting up the cluster.
type SetupScripts_STATUS struct {
	// Scripts: Customized setup scripts
	Scripts *ScriptsToExecute_STATUS `json:"scripts,omitempty"`
}

var _ genruntime.FromARMConverter = &SetupScripts_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (scripts *SetupScripts_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SetupScripts_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (scripts *SetupScripts_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SetupScripts_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SetupScripts_STATUS, got %T", armInput)
	}

	// Set property "Scripts":
	if typedInput.Scripts != nil {
		var scripts2 ScriptsToExecute_STATUS
		err := scripts2.PopulateFromARM(owner, *typedInput.Scripts)
		if err != nil {
			return err
		}
		scripts1 := scripts2
		scripts.Scripts = &scripts1
	}

	// No error
	return nil
}

// AssignProperties_From_SetupScripts_STATUS populates our SetupScripts_STATUS from the provided source SetupScripts_STATUS
func (scripts *SetupScripts_STATUS) AssignProperties_From_SetupScripts_STATUS(source *storage.SetupScripts_STATUS) error {

	// Scripts
	if source.Scripts != nil {
		var script ScriptsToExecute_STATUS
		err := script.AssignProperties_From_ScriptsToExecute_STATUS(source.Scripts)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ScriptsToExecute_STATUS() to populate field Scripts")
		}
		scripts.Scripts = &script
	} else {
		scripts.Scripts = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SetupScripts_STATUS populates the provided destination SetupScripts_STATUS from our SetupScripts_STATUS
func (scripts *SetupScripts_STATUS) AssignProperties_To_SetupScripts_STATUS(destination *storage.SetupScripts_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Scripts
	if scripts.Scripts != nil {
		var script storage.ScriptsToExecute_STATUS
		err := scripts.Scripts.AssignProperties_To_ScriptsToExecute_STATUS(&script)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ScriptsToExecute_STATUS() to populate field Scripts")
		}
		destination.Scripts = &script
	} else {
		destination.Scripts = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The ssl configuration for scoring
type SslConfiguration struct {
	// Cert: Cert data
	Cert *genruntime.SecretReference `json:"cert,omitempty"`

	// Cname: CNAME of the cert
	Cname *string `json:"cname,omitempty"`

	// Key: Key data
	Key *genruntime.SecretReference `json:"key,omitempty"`

	// LeafDomainLabel: Leaf domain label of public endpoint
	LeafDomainLabel *string `json:"leafDomainLabel,omitempty"`

	// OverwriteExistingDomain: Indicates whether to overwrite existing domain label.
	OverwriteExistingDomain *bool `json:"overwriteExistingDomain,omitempty"`

	// Status: Enable or disable ssl for scoring
	Status *SslConfiguration_Status `json:"status,omitempty"`
}

var _ genruntime.ARMTransformer = &SslConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *SslConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.SslConfiguration{}

	// Set property "Cert":
	if configuration.Cert != nil {
		certSecret, err := resolved.ResolvedSecrets.Lookup(*configuration.Cert)
		if err != nil {
			return nil, eris.Wrap(err, "looking up secret for property Cert")
		}
		cert := certSecret
		result.Cert = &cert
	}

	// Set property "Cname":
	if configuration.Cname != nil {
		cname := *configuration.Cname
		result.Cname = &cname
	}

	// Set property "Key":
	if configuration.Key != nil {
		keySecret, err := resolved.ResolvedSecrets.Lookup(*configuration.Key)
		if err != nil {
			return nil, eris.Wrap(err, "looking up secret for property Key")
		}
		key := keySecret
		result.Key = &key
	}

	// Set property "LeafDomainLabel":
	if configuration.LeafDomainLabel != nil {
		leafDomainLabel := *configuration.LeafDomainLabel
		result.LeafDomainLabel = &leafDomainLabel
	}

	// Set property "OverwriteExistingDomain":
	if configuration.OverwriteExistingDomain != nil {
		overwriteExistingDomain := *configuration.OverwriteExistingDomain
		result.OverwriteExistingDomain = &overwriteExistingDomain
	}

	// Set property "Status":
	if configuration.Status != nil {
		var temp string
		temp = string(*configuration.Status)
		status := arm.SslConfiguration_Status(temp)
		result.Status = &status
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *SslConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SslConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *SslConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SslConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SslConfiguration, got %T", armInput)
	}

	// no assignment for property "Cert"

	// Set property "Cname":
	if typedInput.Cname != nil {
		cname := *typedInput.Cname
		configuration.Cname = &cname
	}

	// no assignment for property "Key"

	// Set property "LeafDomainLabel":
	if typedInput.LeafDomainLabel != nil {
		leafDomainLabel := *typedInput.LeafDomainLabel
		configuration.LeafDomainLabel = &leafDomainLabel
	}

	// Set property "OverwriteExistingDomain":
	if typedInput.OverwriteExistingDomain != nil {
		overwriteExistingDomain := *typedInput.OverwriteExistingDomain
		configuration.OverwriteExistingDomain = &overwriteExistingDomain
	}

	// Set property "Status":
	if typedInput.Status != nil {
		var temp string
		temp = string(*typedInput.Status)
		status := SslConfiguration_Status(temp)
		configuration.Status = &status
	}

	// No error
	return nil
}

// AssignProperties_From_SslConfiguration populates our SslConfiguration from the provided source SslConfiguration
func (configuration *SslConfiguration) AssignProperties_From_SslConfiguration(source *storage.SslConfiguration) error {

	// Cert
	if source.Cert != nil {
		cert := source.Cert.Copy()
		configuration.Cert = &cert
	} else {
		configuration.Cert = nil
	}

	// Cname
	configuration.Cname = genruntime.ClonePointerToString(source.Cname)

	// Key
	if source.Key != nil {
		key := source.Key.Copy()
		configuration.Key = &key
	} else {
		configuration.Key = nil
	}

	// LeafDomainLabel
	configuration.LeafDomainLabel = genruntime.ClonePointerToString(source.LeafDomainLabel)

	// OverwriteExistingDomain
	if source.OverwriteExistingDomain != nil {
		overwriteExistingDomain := *source.OverwriteExistingDomain
		configuration.OverwriteExistingDomain = &overwriteExistingDomain
	} else {
		configuration.OverwriteExistingDomain = nil
	}

	// Status
	if source.Status != nil {
		status := *source.Status
		statusTemp := genruntime.ToEnum(status, sslConfiguration_Status_Values)
		configuration.Status = &statusTemp
	} else {
		configuration.Status = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SslConfiguration populates the provided destination SslConfiguration from our SslConfiguration
func (configuration *SslConfiguration) AssignProperties_To_SslConfiguration(destination *storage.SslConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Cert
	if configuration.Cert != nil {
		cert := configuration.Cert.Copy()
		destination.Cert = &cert
	} else {
		destination.Cert = nil
	}

	// Cname
	destination.Cname = genruntime.ClonePointerToString(configuration.Cname)

	// Key
	if configuration.Key != nil {
		key := configuration.Key.Copy()
		destination.Key = &key
	} else {
		destination.Key = nil
	}

	// LeafDomainLabel
	destination.LeafDomainLabel = genruntime.ClonePointerToString(configuration.LeafDomainLabel)

	// OverwriteExistingDomain
	if configuration.OverwriteExistingDomain != nil {
		overwriteExistingDomain := *configuration.OverwriteExistingDomain
		destination.OverwriteExistingDomain = &overwriteExistingDomain
	} else {
		destination.OverwriteExistingDomain = nil
	}

	// Status
	if configuration.Status != nil {
		status := string(*configuration.Status)
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The ssl configuration for scoring
type SslConfiguration_STATUS struct {
	// Cname: CNAME of the cert
	Cname *string `json:"cname,omitempty"`

	// LeafDomainLabel: Leaf domain label of public endpoint
	LeafDomainLabel *string `json:"leafDomainLabel,omitempty"`

	// OverwriteExistingDomain: Indicates whether to overwrite existing domain label.
	OverwriteExistingDomain *bool `json:"overwriteExistingDomain,omitempty"`

	// Status: Enable or disable ssl for scoring
	Status *SslConfiguration_Status_STATUS `json:"status,omitempty"`
}

var _ genruntime.FromARMConverter = &SslConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *SslConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SslConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *SslConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SslConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SslConfiguration_STATUS, got %T", armInput)
	}

	// Set property "Cname":
	if typedInput.Cname != nil {
		cname := *typedInput.Cname
		configuration.Cname = &cname
	}

	// Set property "LeafDomainLabel":
	if typedInput.LeafDomainLabel != nil {
		leafDomainLabel := *typedInput.LeafDomainLabel
		configuration.LeafDomainLabel = &leafDomainLabel
	}

	// Set property "OverwriteExistingDomain":
	if typedInput.OverwriteExistingDomain != nil {
		overwriteExistingDomain := *typedInput.OverwriteExistingDomain
		configuration.OverwriteExistingDomain = &overwriteExistingDomain
	}

	// Set property "Status":
	if typedInput.Status != nil {
		var temp string
		temp = string(*typedInput.Status)
		status := SslConfiguration_Status_STATUS(temp)
		configuration.Status = &status
	}

	// No error
	return nil
}

// AssignProperties_From_SslConfiguration_STATUS populates our SslConfiguration_STATUS from the provided source SslConfiguration_STATUS
func (configuration *SslConfiguration_STATUS) AssignProperties_From_SslConfiguration_STATUS(source *storage.SslConfiguration_STATUS) error {

	// Cname
	configuration.Cname = genruntime.ClonePointerToString(source.Cname)

	// LeafDomainLabel
	configuration.LeafDomainLabel = genruntime.ClonePointerToString(source.LeafDomainLabel)

	// OverwriteExistingDomain
	if source.OverwriteExistingDomain != nil {
		overwriteExistingDomain := *source.OverwriteExistingDomain
		configuration.OverwriteExistingDomain = &overwriteExistingDomain
	} else {
		configuration.OverwriteExistingDomain = nil
	}

	// Status
	if source.Status != nil {
		status := *source.Status
		statusTemp := genruntime.ToEnum(status, sslConfiguration_Status_STATUS_Values)
		configuration.Status = &statusTemp
	} else {
		configuration.Status = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SslConfiguration_STATUS populates the provided destination SslConfiguration_STATUS from our SslConfiguration_STATUS
func (configuration *SslConfiguration_STATUS) AssignProperties_To_SslConfiguration_STATUS(destination *storage.SslConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Cname
	destination.Cname = genruntime.ClonePointerToString(configuration.Cname)

	// LeafDomainLabel
	destination.LeafDomainLabel = genruntime.ClonePointerToString(configuration.LeafDomainLabel)

	// OverwriteExistingDomain
	if configuration.OverwriteExistingDomain != nil {
		overwriteExistingDomain := *configuration.OverwriteExistingDomain
		destination.OverwriteExistingDomain = &overwriteExistingDomain
	} else {
		destination.OverwriteExistingDomain = nil
	}

	// Status
	if configuration.Status != nil {
		status := string(*configuration.Status)
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// A system service running on a compute.
type SystemService_STATUS struct {
	// PublicIpAddress: Public IP address
	PublicIpAddress *string `json:"publicIpAddress,omitempty"`

	// SystemServiceType: The type of this system service.
	SystemServiceType *string `json:"systemServiceType,omitempty"`

	// Version: The version for this type.
	Version *string `json:"version,omitempty"`
}

var _ genruntime.FromARMConverter = &SystemService_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (service *SystemService_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SystemService_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (service *SystemService_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SystemService_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SystemService_STATUS, got %T", armInput)
	}

	// Set property "PublicIpAddress":
	if typedInput.PublicIpAddress != nil {
		publicIpAddress := *typedInput.PublicIpAddress
		service.PublicIpAddress = &publicIpAddress
	}

	// Set property "SystemServiceType":
	if typedInput.SystemServiceType != nil {
		systemServiceType := *typedInput.SystemServiceType
		service.SystemServiceType = &systemServiceType
	}

	// Set property "Version":
	if typedInput.Version != nil {
		version := *typedInput.Version
		service.Version = &version
	}

	// No error
	return nil
}

// AssignProperties_From_SystemService_STATUS populates our SystemService_STATUS from the provided source SystemService_STATUS
func (service *SystemService_STATUS) AssignProperties_From_SystemService_STATUS(source *storage.SystemService_STATUS) error {

	// PublicIpAddress
	service.PublicIpAddress = genruntime.ClonePointerToString(source.PublicIpAddress)

	// SystemServiceType
	service.SystemServiceType = genruntime.ClonePointerToString(source.SystemServiceType)

	// Version
	service.Version = genruntime.ClonePointerToString(source.Version)

	// No error
	return nil
}

// AssignProperties_To_SystemService_STATUS populates the provided destination SystemService_STATUS from our SystemService_STATUS
func (service *SystemService_STATUS) AssignProperties_To_SystemService_STATUS(destination *storage.SystemService_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PublicIpAddress
	destination.PublicIpAddress = genruntime.ClonePointerToString(service.PublicIpAddress)

	// SystemServiceType
	destination.SystemServiceType = genruntime.ClonePointerToString(service.SystemServiceType)

	// Version
	destination.Version = genruntime.ClonePointerToString(service.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Settings for user account that gets created on each on the nodes of a compute.
type UserAccountCredentials struct {
	// +kubebuilder:validation:Required
	// AdminUserName: Name of the administrator user account which can be used to SSH to nodes.
	AdminUserName *string `json:"adminUserName,omitempty"`

	// AdminUserPassword: Password of the administrator user account.
	AdminUserPassword *genruntime.SecretReference `json:"adminUserPassword,omitempty"`

	// AdminUserSshPublicKey: SSH public key of the administrator user account.
	AdminUserSshPublicKey *genruntime.SecretReference `json:"adminUserSshPublicKey,omitempty"`
}

var _ genruntime.ARMTransformer = &UserAccountCredentials{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (credentials *UserAccountCredentials) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if credentials == nil {
		return nil, nil
	}
	result := &arm.UserAccountCredentials{}

	// Set property "AdminUserName":
	if credentials.AdminUserName != nil {
		adminUserName := *credentials.AdminUserName
		result.AdminUserName = &adminUserName
	}

	// Set property "AdminUserPassword":
	if credentials.AdminUserPassword != nil {
		adminUserPasswordSecret, err := resolved.ResolvedSecrets.Lookup(*credentials.AdminUserPassword)
		if err != nil {
			return nil, eris.Wrap(err, "looking up secret for property AdminUserPassword")
		}
		adminUserPassword := adminUserPasswordSecret
		result.AdminUserPassword = &adminUserPassword
	}

	// Set property "AdminUserSshPublicKey":
	if credentials.AdminUserSshPublicKey != nil {
		adminUserSshPublicKeySecret, err := resolved.ResolvedSecrets.Lookup(*credentials.AdminUserSshPublicKey)
		if err != nil {
			return nil, eris.Wrap(err, "looking up secret for property AdminUserSshPublicKey")
		}
		adminUserSshPublicKey := adminUserSshPublicKeySecret
		result.AdminUserSshPublicKey = &adminUserSshPublicKey
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (credentials *UserAccountCredentials) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UserAccountCredentials{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (credentials *UserAccountCredentials) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UserAccountCredentials)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UserAccountCredentials, got %T", armInput)
	}

	// Set property "AdminUserName":
	if typedInput.AdminUserName != nil {
		adminUserName := *typedInput.AdminUserName
		credentials.AdminUserName = &adminUserName
	}

	// no assignment for property "AdminUserPassword"

	// no assignment for property "AdminUserSshPublicKey"

	// No error
	return nil
}

// AssignProperties_From_UserAccountCredentials populates our UserAccountCredentials from the provided source UserAccountCredentials
func (credentials *UserAccountCredentials) AssignProperties_From_UserAccountCredentials(source *storage.UserAccountCredentials) error {

	// AdminUserName
	credentials.AdminUserName = genruntime.ClonePointerToString(source.AdminUserName)

	// AdminUserPassword
	if source.AdminUserPassword != nil {
		adminUserPassword := source.AdminUserPassword.Copy()
		credentials.AdminUserPassword = &adminUserPassword
	} else {
		credentials.AdminUserPassword = nil
	}

	// AdminUserSshPublicKey
	if source.AdminUserSshPublicKey != nil {
		adminUserSshPublicKey := source.AdminUserSshPublicKey.Copy()
		credentials.AdminUserSshPublicKey = &adminUserSshPublicKey
	} else {
		credentials.AdminUserSshPublicKey = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UserAccountCredentials populates the provided destination UserAccountCredentials from our UserAccountCredentials
func (credentials *UserAccountCredentials) AssignProperties_To_UserAccountCredentials(destination *storage.UserAccountCredentials) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminUserName
	destination.AdminUserName = genruntime.ClonePointerToString(credentials.AdminUserName)

	// AdminUserPassword
	if credentials.AdminUserPassword != nil {
		adminUserPassword := credentials.AdminUserPassword.Copy()
		destination.AdminUserPassword = &adminUserPassword
	} else {
		destination.AdminUserPassword = nil
	}

	// AdminUserSshPublicKey
	if credentials.AdminUserSshPublicKey != nil {
		adminUserSshPublicKey := credentials.AdminUserSshPublicKey.Copy()
		destination.AdminUserSshPublicKey = &adminUserSshPublicKey
	} else {
		destination.AdminUserSshPublicKey = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Settings for user account that gets created on each on the nodes of a compute.
type UserAccountCredentials_STATUS struct {
	// AdminUserName: Name of the administrator user account which can be used to SSH to nodes.
	AdminUserName *string `json:"adminUserName,omitempty"`
}

var _ genruntime.FromARMConverter = &UserAccountCredentials_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (credentials *UserAccountCredentials_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UserAccountCredentials_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (credentials *UserAccountCredentials_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UserAccountCredentials_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UserAccountCredentials_STATUS, got %T", armInput)
	}

	// Set property "AdminUserName":
	if typedInput.AdminUserName != nil {
		adminUserName := *typedInput.AdminUserName
		credentials.AdminUserName = &adminUserName
	}

	// No error
	return nil
}

// AssignProperties_From_UserAccountCredentials_STATUS populates our UserAccountCredentials_STATUS from the provided source UserAccountCredentials_STATUS
func (credentials *UserAccountCredentials_STATUS) AssignProperties_From_UserAccountCredentials_STATUS(source *storage.UserAccountCredentials_STATUS) error {

	// AdminUserName
	credentials.AdminUserName = genruntime.ClonePointerToString(source.AdminUserName)

	// No error
	return nil
}

// AssignProperties_To_UserAccountCredentials_STATUS populates the provided destination UserAccountCredentials_STATUS from our UserAccountCredentials_STATUS
func (credentials *UserAccountCredentials_STATUS) AssignProperties_To_UserAccountCredentials_STATUS(destination *storage.UserAccountCredentials_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminUserName
	destination.AdminUserName = genruntime.ClonePointerToString(credentials.AdminUserName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Virtual Machine image for Windows AML Compute
type VirtualMachineImage struct {
	// +kubebuilder:validation:Required
	// Reference: Virtual Machine image path
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineImage{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (image *VirtualMachineImage) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if image == nil {
		return nil, nil
	}
	result := &arm.VirtualMachineImage{}

	// Set property "Id":
	if image.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*image.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (image *VirtualMachineImage) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineImage{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (image *VirtualMachineImage) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(arm.VirtualMachineImage)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineImage, got %T", armInput)
	}

	// no assignment for property "Reference"

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineImage populates our VirtualMachineImage from the provided source VirtualMachineImage
func (image *VirtualMachineImage) AssignProperties_From_VirtualMachineImage(source *storage.VirtualMachineImage) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		image.Reference = &reference
	} else {
		image.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineImage populates the provided destination VirtualMachineImage from our VirtualMachineImage
func (image *VirtualMachineImage) AssignProperties_To_VirtualMachineImage(destination *storage.VirtualMachineImage) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if image.Reference != nil {
		reference := image.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Virtual Machine image for Windows AML Compute
type VirtualMachineImage_STATUS struct {
	// Id: Virtual Machine image path
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineImage_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (image *VirtualMachineImage_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineImage_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (image *VirtualMachineImage_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineImage_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineImage_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		image.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineImage_STATUS populates our VirtualMachineImage_STATUS from the provided source VirtualMachineImage_STATUS
func (image *VirtualMachineImage_STATUS) AssignProperties_From_VirtualMachineImage_STATUS(source *storage.VirtualMachineImage_STATUS) error {

	// Id
	image.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineImage_STATUS populates the provided destination VirtualMachineImage_STATUS from our VirtualMachineImage_STATUS
func (image *VirtualMachineImage_STATUS) AssignProperties_To_VirtualMachineImage_STATUS(destination *storage.VirtualMachineImage_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(image.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Admin credentials for virtual machine
type VirtualMachineSshCredentials struct {
	// Password: Password of admin account
	Password *genruntime.SecretReference `json:"password,omitempty"`

	// PrivateKeyData: Private key data
	PrivateKeyData *genruntime.SecretReference `json:"privateKeyData,omitempty"`

	// PublicKeyData: Public key data
	PublicKeyData *genruntime.SecretReference `json:"publicKeyData,omitempty"`

	// Username: Username of admin account
	Username *string `json:"username,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineSshCredentials{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (credentials *VirtualMachineSshCredentials) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if credentials == nil {
		return nil, nil
	}
	result := &arm.VirtualMachineSshCredentials{}

	// Set property "Password":
	if credentials.Password != nil {
		passwordSecret, err := resolved.ResolvedSecrets.Lookup(*credentials.Password)
		if err != nil {
			return nil, eris.Wrap(err, "looking up secret for property Password")
		}
		password := passwordSecret
		result.Password = &password
	}

	// Set property "PrivateKeyData":
	if credentials.PrivateKeyData != nil {
		privateKeyDataSecret, err := resolved.ResolvedSecrets.Lookup(*credentials.PrivateKeyData)
		if err != nil {
			return nil, eris.Wrap(err, "looking up secret for property PrivateKeyData")
		}
		privateKeyData := privateKeyDataSecret
		result.PrivateKeyData = &privateKeyData
	}

	// Set property "PublicKeyData":
	if credentials.PublicKeyData != nil {
		publicKeyDataSecret, err := resolved.ResolvedSecrets.Lookup(*credentials.PublicKeyData)
		if err != nil {
			return nil, eris.Wrap(err, "looking up secret for property PublicKeyData")
		}
		publicKeyData := publicKeyDataSecret
		result.PublicKeyData = &publicKeyData
	}

	// Set property "Username":
	if credentials.Username != nil {
		username := *credentials.Username
		result.Username = &username
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (credentials *VirtualMachineSshCredentials) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineSshCredentials{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (credentials *VirtualMachineSshCredentials) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineSshCredentials)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineSshCredentials, got %T", armInput)
	}

	// no assignment for property "Password"

	// no assignment for property "PrivateKeyData"

	// no assignment for property "PublicKeyData"

	// Set property "Username":
	if typedInput.Username != nil {
		username := *typedInput.Username
		credentials.Username = &username
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineSshCredentials populates our VirtualMachineSshCredentials from the provided source VirtualMachineSshCredentials
func (credentials *VirtualMachineSshCredentials) AssignProperties_From_VirtualMachineSshCredentials(source *storage.VirtualMachineSshCredentials) error {

	// Password
	if source.Password != nil {
		password := source.Password.Copy()
		credentials.Password = &password
	} else {
		credentials.Password = nil
	}

	// PrivateKeyData
	if source.PrivateKeyData != nil {
		privateKeyDatum := source.PrivateKeyData.Copy()
		credentials.PrivateKeyData = &privateKeyDatum
	} else {
		credentials.PrivateKeyData = nil
	}

	// PublicKeyData
	if source.PublicKeyData != nil {
		publicKeyDatum := source.PublicKeyData.Copy()
		credentials.PublicKeyData = &publicKeyDatum
	} else {
		credentials.PublicKeyData = nil
	}

	// Username
	credentials.Username = genruntime.ClonePointerToString(source.Username)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineSshCredentials populates the provided destination VirtualMachineSshCredentials from our VirtualMachineSshCredentials
func (credentials *VirtualMachineSshCredentials) AssignProperties_To_VirtualMachineSshCredentials(destination *storage.VirtualMachineSshCredentials) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Password
	if credentials.Password != nil {
		password := credentials.Password.Copy()
		destination.Password = &password
	} else {
		destination.Password = nil
	}

	// PrivateKeyData
	if credentials.PrivateKeyData != nil {
		privateKeyDatum := credentials.PrivateKeyData.Copy()
		destination.PrivateKeyData = &privateKeyDatum
	} else {
		destination.PrivateKeyData = nil
	}

	// PublicKeyData
	if credentials.PublicKeyData != nil {
		publicKeyDatum := credentials.PublicKeyData.Copy()
		destination.PublicKeyData = &publicKeyDatum
	} else {
		destination.PublicKeyData = nil
	}

	// Username
	destination.Username = genruntime.ClonePointerToString(credentials.Username)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Admin credentials for virtual machine
type VirtualMachineSshCredentials_STATUS struct {
	// Username: Username of admin account
	Username *string `json:"username,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineSshCredentials_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (credentials *VirtualMachineSshCredentials_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineSshCredentials_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (credentials *VirtualMachineSshCredentials_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineSshCredentials_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineSshCredentials_STATUS, got %T", armInput)
	}

	// Set property "Username":
	if typedInput.Username != nil {
		username := *typedInput.Username
		credentials.Username = &username
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineSshCredentials_STATUS populates our VirtualMachineSshCredentials_STATUS from the provided source VirtualMachineSshCredentials_STATUS
func (credentials *VirtualMachineSshCredentials_STATUS) AssignProperties_From_VirtualMachineSshCredentials_STATUS(source *storage.VirtualMachineSshCredentials_STATUS) error {

	// Username
	credentials.Username = genruntime.ClonePointerToString(source.Username)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineSshCredentials_STATUS populates the provided destination VirtualMachineSshCredentials_STATUS from our VirtualMachineSshCredentials_STATUS
func (credentials *VirtualMachineSshCredentials_STATUS) AssignProperties_To_VirtualMachineSshCredentials_STATUS(destination *storage.VirtualMachineSshCredentials_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Username
	destination.Username = genruntime.ClonePointerToString(credentials.Username)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// A user that can be assigned to a compute instance.
type AssignedUser struct {
	// +kubebuilder:validation:Required
	// ObjectId: Users AAD Object Id.
	ObjectId *string `json:"objectId,omitempty"`

	// +kubebuilder:validation:Required
	// TenantId: Users AAD Tenant Id.
	TenantId *string `json:"tenantId,omitempty"`
}

var _ genruntime.ARMTransformer = &AssignedUser{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (user *AssignedUser) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if user == nil {
		return nil, nil
	}
	result := &arm.AssignedUser{}

	// Set property "ObjectId":
	if user.ObjectId != nil {
		objectId := *user.ObjectId
		result.ObjectId = &objectId
	}

	// Set property "TenantId":
	if user.TenantId != nil {
		tenantId := *user.TenantId
		result.TenantId = &tenantId
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (user *AssignedUser) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AssignedUser{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (user *AssignedUser) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AssignedUser)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AssignedUser, got %T", armInput)
	}

	// Set property "ObjectId":
	if typedInput.ObjectId != nil {
		objectId := *typedInput.ObjectId
		user.ObjectId = &objectId
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		user.TenantId = &tenantId
	}

	// No error
	return nil
}

// AssignProperties_From_AssignedUser populates our AssignedUser from the provided source AssignedUser
func (user *AssignedUser) AssignProperties_From_AssignedUser(source *storage.AssignedUser) error {

	// ObjectId
	user.ObjectId = genruntime.ClonePointerToString(source.ObjectId)

	// TenantId
	user.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// No error
	return nil
}

// AssignProperties_To_AssignedUser populates the provided destination AssignedUser from our AssignedUser
func (user *AssignedUser) AssignProperties_To_AssignedUser(destination *storage.AssignedUser) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ObjectId
	destination.ObjectId = genruntime.ClonePointerToString(user.ObjectId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(user.TenantId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// A user that can be assigned to a compute instance.
type AssignedUser_STATUS struct {
	// ObjectId: Users AAD Object Id.
	ObjectId *string `json:"objectId,omitempty"`

	// TenantId: Users AAD Tenant Id.
	TenantId *string `json:"tenantId,omitempty"`
}

var _ genruntime.FromARMConverter = &AssignedUser_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (user *AssignedUser_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AssignedUser_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (user *AssignedUser_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AssignedUser_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AssignedUser_STATUS, got %T", armInput)
	}

	// Set property "ObjectId":
	if typedInput.ObjectId != nil {
		objectId := *typedInput.ObjectId
		user.ObjectId = &objectId
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		user.TenantId = &tenantId
	}

	// No error
	return nil
}

// AssignProperties_From_AssignedUser_STATUS populates our AssignedUser_STATUS from the provided source AssignedUser_STATUS
func (user *AssignedUser_STATUS) AssignProperties_From_AssignedUser_STATUS(source *storage.AssignedUser_STATUS) error {

	// ObjectId
	user.ObjectId = genruntime.ClonePointerToString(source.ObjectId)

	// TenantId
	user.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// No error
	return nil
}

// AssignProperties_To_AssignedUser_STATUS populates the provided destination AssignedUser_STATUS from our AssignedUser_STATUS
func (user *AssignedUser_STATUS) AssignProperties_To_AssignedUser_STATUS(destination *storage.AssignedUser_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ObjectId
	destination.ObjectId = genruntime.ClonePointerToString(user.ObjectId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(user.TenantId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ComputeInstanceLastOperation_OperationName_STATUS string

const (
	ComputeInstanceLastOperation_OperationName_STATUS_Create  = ComputeInstanceLastOperation_OperationName_STATUS("Create")
	ComputeInstanceLastOperation_OperationName_STATUS_Delete  = ComputeInstanceLastOperation_OperationName_STATUS("Delete")
	ComputeInstanceLastOperation_OperationName_STATUS_Reimage = ComputeInstanceLastOperation_OperationName_STATUS("Reimage")
	ComputeInstanceLastOperation_OperationName_STATUS_Restart = ComputeInstanceLastOperation_OperationName_STATUS("Restart")
	ComputeInstanceLastOperation_OperationName_STATUS_Start   = ComputeInstanceLastOperation_OperationName_STATUS("Start")
	ComputeInstanceLastOperation_OperationName_STATUS_Stop    = ComputeInstanceLastOperation_OperationName_STATUS("Stop")
)

// Mapping from string to ComputeInstanceLastOperation_OperationName_STATUS
var computeInstanceLastOperation_OperationName_STATUS_Values = map[string]ComputeInstanceLastOperation_OperationName_STATUS{
	"create":  ComputeInstanceLastOperation_OperationName_STATUS_Create,
	"delete":  ComputeInstanceLastOperation_OperationName_STATUS_Delete,
	"reimage": ComputeInstanceLastOperation_OperationName_STATUS_Reimage,
	"restart": ComputeInstanceLastOperation_OperationName_STATUS_Restart,
	"start":   ComputeInstanceLastOperation_OperationName_STATUS_Start,
	"stop":    ComputeInstanceLastOperation_OperationName_STATUS_Stop,
}

type ComputeInstanceLastOperation_OperationStatus_STATUS string

const (
	ComputeInstanceLastOperation_OperationStatus_STATUS_CreateFailed  = ComputeInstanceLastOperation_OperationStatus_STATUS("CreateFailed")
	ComputeInstanceLastOperation_OperationStatus_STATUS_DeleteFailed  = ComputeInstanceLastOperation_OperationStatus_STATUS("DeleteFailed")
	ComputeInstanceLastOperation_OperationStatus_STATUS_InProgress    = ComputeInstanceLastOperation_OperationStatus_STATUS("InProgress")
	ComputeInstanceLastOperation_OperationStatus_STATUS_ReimageFailed = ComputeInstanceLastOperation_OperationStatus_STATUS("ReimageFailed")
	ComputeInstanceLastOperation_OperationStatus_STATUS_RestartFailed = ComputeInstanceLastOperation_OperationStatus_STATUS("RestartFailed")
	ComputeInstanceLastOperation_OperationStatus_STATUS_StartFailed   = ComputeInstanceLastOperation_OperationStatus_STATUS("StartFailed")
	ComputeInstanceLastOperation_OperationStatus_STATUS_StopFailed    = ComputeInstanceLastOperation_OperationStatus_STATUS("StopFailed")
	ComputeInstanceLastOperation_OperationStatus_STATUS_Succeeded     = ComputeInstanceLastOperation_OperationStatus_STATUS("Succeeded")
)

// Mapping from string to ComputeInstanceLastOperation_OperationStatus_STATUS
var computeInstanceLastOperation_OperationStatus_STATUS_Values = map[string]ComputeInstanceLastOperation_OperationStatus_STATUS{
	"createfailed":  ComputeInstanceLastOperation_OperationStatus_STATUS_CreateFailed,
	"deletefailed":  ComputeInstanceLastOperation_OperationStatus_STATUS_DeleteFailed,
	"inprogress":    ComputeInstanceLastOperation_OperationStatus_STATUS_InProgress,
	"reimagefailed": ComputeInstanceLastOperation_OperationStatus_STATUS_ReimageFailed,
	"restartfailed": ComputeInstanceLastOperation_OperationStatus_STATUS_RestartFailed,
	"startfailed":   ComputeInstanceLastOperation_OperationStatus_STATUS_StartFailed,
	"stopfailed":    ComputeInstanceLastOperation_OperationStatus_STATUS_StopFailed,
	"succeeded":     ComputeInstanceLastOperation_OperationStatus_STATUS_Succeeded,
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type ComputeInstanceSshSettings_SshPublicAccess string

const (
	ComputeInstanceSshSettings_SshPublicAccess_Disabled = ComputeInstanceSshSettings_SshPublicAccess("Disabled")
	ComputeInstanceSshSettings_SshPublicAccess_Enabled  = ComputeInstanceSshSettings_SshPublicAccess("Enabled")
)

// Mapping from string to ComputeInstanceSshSettings_SshPublicAccess
var computeInstanceSshSettings_SshPublicAccess_Values = map[string]ComputeInstanceSshSettings_SshPublicAccess{
	"disabled": ComputeInstanceSshSettings_SshPublicAccess_Disabled,
	"enabled":  ComputeInstanceSshSettings_SshPublicAccess_Enabled,
}

type ComputeInstanceSshSettings_SshPublicAccess_STATUS string

const (
	ComputeInstanceSshSettings_SshPublicAccess_STATUS_Disabled = ComputeInstanceSshSettings_SshPublicAccess_STATUS("Disabled")
	ComputeInstanceSshSettings_SshPublicAccess_STATUS_Enabled  = ComputeInstanceSshSettings_SshPublicAccess_STATUS("Enabled")
)

// Mapping from string to ComputeInstanceSshSettings_SshPublicAccess_STATUS
var computeInstanceSshSettings_SshPublicAccess_STATUS_Values = map[string]ComputeInstanceSshSettings_SshPublicAccess_STATUS{
	"disabled": ComputeInstanceSshSettings_SshPublicAccess_STATUS_Disabled,
	"enabled":  ComputeInstanceSshSettings_SshPublicAccess_STATUS_Enabled,
}

// The resource management error additional info.
type ErrorAdditionalInfo_STATUS struct {
	// Info: The additional info.
	Info map[string]v1.JSON `json:"info,omitempty"`

	// Type: The additional info type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &ErrorAdditionalInfo_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (info *ErrorAdditionalInfo_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ErrorAdditionalInfo_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (info *ErrorAdditionalInfo_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ErrorAdditionalInfo_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ErrorAdditionalInfo_STATUS, got %T", armInput)
	}

	// Set property "Info":
	if typedInput.Info != nil {
		info.Info = make(map[string]v1.JSON, len(typedInput.Info))
		for key, value := range typedInput.Info {
			info.Info[key] = *value.DeepCopy()
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		info.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_ErrorAdditionalInfo_STATUS populates our ErrorAdditionalInfo_STATUS from the provided source ErrorAdditionalInfo_STATUS
func (info *ErrorAdditionalInfo_STATUS) AssignProperties_From_ErrorAdditionalInfo_STATUS(source *storage.ErrorAdditionalInfo_STATUS) error {

	// Info
	if source.Info != nil {
		infoMap := make(map[string]v1.JSON, len(source.Info))
		for infoKey, infoValue := range source.Info {
			// Shadow the loop variable to avoid aliasing
			infoValue := infoValue
			infoMap[infoKey] = *infoValue.DeepCopy()
		}
		info.Info = infoMap
	} else {
		info.Info = nil
	}

	// Type
	info.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_ErrorAdditionalInfo_STATUS populates the provided destination ErrorAdditionalInfo_STATUS from our ErrorAdditionalInfo_STATUS
func (info *ErrorAdditionalInfo_STATUS) AssignProperties_To_ErrorAdditionalInfo_STATUS(destination *storage.ErrorAdditionalInfo_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Info
	if info.Info != nil {
		infoMap := make(map[string]v1.JSON, len(info.Info))
		for infoKey, infoValue := range info.Info {
			// Shadow the loop variable to avoid aliasing
			infoValue := infoValue
			infoMap[infoKey] = *infoValue.DeepCopy()
		}
		destination.Info = infoMap
	} else {
		destination.Info = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(info.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ErrorDetail_STATUS_Unrolled struct {
	// AdditionalInfo: The error additional info.
	AdditionalInfo []ErrorAdditionalInfo_STATUS `json:"additionalInfo,omitempty"`

	// Code: The error code.
	Code *string `json:"code,omitempty"`

	// Message: The error message.
	Message *string `json:"message,omitempty"`

	// Target: The error target.
	Target *string `json:"target,omitempty"`
}

var _ genruntime.FromARMConverter = &ErrorDetail_STATUS_Unrolled{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (unrolled *ErrorDetail_STATUS_Unrolled) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ErrorDetail_STATUS_Unrolled{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (unrolled *ErrorDetail_STATUS_Unrolled) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ErrorDetail_STATUS_Unrolled)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ErrorDetail_STATUS_Unrolled, got %T", armInput)
	}

	// Set property "AdditionalInfo":
	for _, item := range typedInput.AdditionalInfo {
		var item1 ErrorAdditionalInfo_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		unrolled.AdditionalInfo = append(unrolled.AdditionalInfo, item1)
	}

	// Set property "Code":
	if typedInput.Code != nil {
		code := *typedInput.Code
		unrolled.Code = &code
	}

	// Set property "Message":
	if typedInput.Message != nil {
		message := *typedInput.Message
		unrolled.Message = &message
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		unrolled.Target = &target
	}

	// No error
	return nil
}

// AssignProperties_From_ErrorDetail_STATUS_Unrolled populates our ErrorDetail_STATUS_Unrolled from the provided source ErrorDetail_STATUS_Unrolled
func (unrolled *ErrorDetail_STATUS_Unrolled) AssignProperties_From_ErrorDetail_STATUS_Unrolled(source *storage.ErrorDetail_STATUS_Unrolled) error {

	// AdditionalInfo
	if source.AdditionalInfo != nil {
		additionalInfoList := make([]ErrorAdditionalInfo_STATUS, len(source.AdditionalInfo))
		for additionalInfoIndex, additionalInfoItem := range source.AdditionalInfo {
			// Shadow the loop variable to avoid aliasing
			additionalInfoItem := additionalInfoItem
			var additionalInfo ErrorAdditionalInfo_STATUS
			err := additionalInfo.AssignProperties_From_ErrorAdditionalInfo_STATUS(&additionalInfoItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ErrorAdditionalInfo_STATUS() to populate field AdditionalInfo")
			}
			additionalInfoList[additionalInfoIndex] = additionalInfo
		}
		unrolled.AdditionalInfo = additionalInfoList
	} else {
		unrolled.AdditionalInfo = nil
	}

	// Code
	unrolled.Code = genruntime.ClonePointerToString(source.Code)

	// Message
	unrolled.Message = genruntime.ClonePointerToString(source.Message)

	// Target
	unrolled.Target = genruntime.ClonePointerToString(source.Target)

	// No error
	return nil
}

// AssignProperties_To_ErrorDetail_STATUS_Unrolled populates the provided destination ErrorDetail_STATUS_Unrolled from our ErrorDetail_STATUS_Unrolled
func (unrolled *ErrorDetail_STATUS_Unrolled) AssignProperties_To_ErrorDetail_STATUS_Unrolled(destination *storage.ErrorDetail_STATUS_Unrolled) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalInfo
	if unrolled.AdditionalInfo != nil {
		additionalInfoList := make([]storage.ErrorAdditionalInfo_STATUS, len(unrolled.AdditionalInfo))
		for additionalInfoIndex, additionalInfoItem := range unrolled.AdditionalInfo {
			// Shadow the loop variable to avoid aliasing
			additionalInfoItem := additionalInfoItem
			var additionalInfo storage.ErrorAdditionalInfo_STATUS
			err := additionalInfoItem.AssignProperties_To_ErrorAdditionalInfo_STATUS(&additionalInfo)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ErrorAdditionalInfo_STATUS() to populate field AdditionalInfo")
			}
			additionalInfoList[additionalInfoIndex] = additionalInfo
		}
		destination.AdditionalInfo = additionalInfoList
	} else {
		destination.AdditionalInfo = nil
	}

	// Code
	destination.Code = genruntime.ClonePointerToString(unrolled.Code)

	// Message
	destination.Message = genruntime.ClonePointerToString(unrolled.Message)

	// Target
	destination.Target = genruntime.ClonePointerToString(unrolled.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type InstanceTypeSchema_Resources struct {
	// Limits: Resource limits for this instance type
	Limits map[string]string `json:"limits,omitempty"`

	// Requests: Resource requests for this instance type
	Requests map[string]string `json:"requests,omitempty"`
}

var _ genruntime.ARMTransformer = &InstanceTypeSchema_Resources{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (resources *InstanceTypeSchema_Resources) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if resources == nil {
		return nil, nil
	}
	result := &arm.InstanceTypeSchema_Resources{}

	// Set property "Limits":
	if resources.Limits != nil {
		result.Limits = make(map[string]string, len(resources.Limits))
		for key, value := range resources.Limits {
			result.Limits[key] = value
		}
	}

	// Set property "Requests":
	if resources.Requests != nil {
		result.Requests = make(map[string]string, len(resources.Requests))
		for key, value := range resources.Requests {
			result.Requests[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resources *InstanceTypeSchema_Resources) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.InstanceTypeSchema_Resources{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resources *InstanceTypeSchema_Resources) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.InstanceTypeSchema_Resources)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.InstanceTypeSchema_Resources, got %T", armInput)
	}

	// Set property "Limits":
	if typedInput.Limits != nil {
		resources.Limits = make(map[string]string, len(typedInput.Limits))
		for key, value := range typedInput.Limits {
			resources.Limits[key] = value
		}
	}

	// Set property "Requests":
	if typedInput.Requests != nil {
		resources.Requests = make(map[string]string, len(typedInput.Requests))
		for key, value := range typedInput.Requests {
			resources.Requests[key] = value
		}
	}

	// No error
	return nil
}

// AssignProperties_From_InstanceTypeSchema_Resources populates our InstanceTypeSchema_Resources from the provided source InstanceTypeSchema_Resources
func (resources *InstanceTypeSchema_Resources) AssignProperties_From_InstanceTypeSchema_Resources(source *storage.InstanceTypeSchema_Resources) error {

	// Limits
	resources.Limits = genruntime.CloneMapOfStringToString(source.Limits)

	// Requests
	resources.Requests = genruntime.CloneMapOfStringToString(source.Requests)

	// No error
	return nil
}

// AssignProperties_To_InstanceTypeSchema_Resources populates the provided destination InstanceTypeSchema_Resources from our InstanceTypeSchema_Resources
func (resources *InstanceTypeSchema_Resources) AssignProperties_To_InstanceTypeSchema_Resources(destination *storage.InstanceTypeSchema_Resources) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Limits
	destination.Limits = genruntime.CloneMapOfStringToString(resources.Limits)

	// Requests
	destination.Requests = genruntime.CloneMapOfStringToString(resources.Requests)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type InstanceTypeSchema_Resources_STATUS struct {
	// Limits: Resource limits for this instance type
	Limits map[string]string `json:"limits,omitempty"`

	// Requests: Resource requests for this instance type
	Requests map[string]string `json:"requests,omitempty"`
}

var _ genruntime.FromARMConverter = &InstanceTypeSchema_Resources_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resources *InstanceTypeSchema_Resources_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.InstanceTypeSchema_Resources_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resources *InstanceTypeSchema_Resources_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.InstanceTypeSchema_Resources_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.InstanceTypeSchema_Resources_STATUS, got %T", armInput)
	}

	// Set property "Limits":
	if typedInput.Limits != nil {
		resources.Limits = make(map[string]string, len(typedInput.Limits))
		for key, value := range typedInput.Limits {
			resources.Limits[key] = value
		}
	}

	// Set property "Requests":
	if typedInput.Requests != nil {
		resources.Requests = make(map[string]string, len(typedInput.Requests))
		for key, value := range typedInput.Requests {
			resources.Requests[key] = value
		}
	}

	// No error
	return nil
}

// AssignProperties_From_InstanceTypeSchema_Resources_STATUS populates our InstanceTypeSchema_Resources_STATUS from the provided source InstanceTypeSchema_Resources_STATUS
func (resources *InstanceTypeSchema_Resources_STATUS) AssignProperties_From_InstanceTypeSchema_Resources_STATUS(source *storage.InstanceTypeSchema_Resources_STATUS) error {

	// Limits
	resources.Limits = genruntime.CloneMapOfStringToString(source.Limits)

	// Requests
	resources.Requests = genruntime.CloneMapOfStringToString(source.Requests)

	// No error
	return nil
}

// AssignProperties_To_InstanceTypeSchema_Resources_STATUS populates the provided destination InstanceTypeSchema_Resources_STATUS from our InstanceTypeSchema_Resources_STATUS
func (resources *InstanceTypeSchema_Resources_STATUS) AssignProperties_To_InstanceTypeSchema_Resources_STATUS(destination *storage.InstanceTypeSchema_Resources_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Limits
	destination.Limits = genruntime.CloneMapOfStringToString(resources.Limits)

	// Requests
	destination.Requests = genruntime.CloneMapOfStringToString(resources.Requests)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Customized setup scripts
type ScriptsToExecute struct {
	// CreationScript: Script that's run only once during provision of the compute.
	CreationScript *ScriptReference `json:"creationScript,omitempty"`

	// StartupScript: Script that's run every time the machine starts.
	StartupScript *ScriptReference `json:"startupScript,omitempty"`
}

var _ genruntime.ARMTransformer = &ScriptsToExecute{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (execute *ScriptsToExecute) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if execute == nil {
		return nil, nil
	}
	result := &arm.ScriptsToExecute{}

	// Set property "CreationScript":
	if execute.CreationScript != nil {
		creationScript_ARM, err := (*execute.CreationScript).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		creationScript := *creationScript_ARM.(*arm.ScriptReference)
		result.CreationScript = &creationScript
	}

	// Set property "StartupScript":
	if execute.StartupScript != nil {
		startupScript_ARM, err := (*execute.StartupScript).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		startupScript := *startupScript_ARM.(*arm.ScriptReference)
		result.StartupScript = &startupScript
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (execute *ScriptsToExecute) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ScriptsToExecute{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (execute *ScriptsToExecute) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ScriptsToExecute)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ScriptsToExecute, got %T", armInput)
	}

	// Set property "CreationScript":
	if typedInput.CreationScript != nil {
		var creationScript1 ScriptReference
		err := creationScript1.PopulateFromARM(owner, *typedInput.CreationScript)
		if err != nil {
			return err
		}
		creationScript := creationScript1
		execute.CreationScript = &creationScript
	}

	// Set property "StartupScript":
	if typedInput.StartupScript != nil {
		var startupScript1 ScriptReference
		err := startupScript1.PopulateFromARM(owner, *typedInput.StartupScript)
		if err != nil {
			return err
		}
		startupScript := startupScript1
		execute.StartupScript = &startupScript
	}

	// No error
	return nil
}

// AssignProperties_From_ScriptsToExecute populates our ScriptsToExecute from the provided source ScriptsToExecute
func (execute *ScriptsToExecute) AssignProperties_From_ScriptsToExecute(source *storage.ScriptsToExecute) error {

	// CreationScript
	if source.CreationScript != nil {
		var creationScript ScriptReference
		err := creationScript.AssignProperties_From_ScriptReference(source.CreationScript)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ScriptReference() to populate field CreationScript")
		}
		execute.CreationScript = &creationScript
	} else {
		execute.CreationScript = nil
	}

	// StartupScript
	if source.StartupScript != nil {
		var startupScript ScriptReference
		err := startupScript.AssignProperties_From_ScriptReference(source.StartupScript)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ScriptReference() to populate field StartupScript")
		}
		execute.StartupScript = &startupScript
	} else {
		execute.StartupScript = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ScriptsToExecute populates the provided destination ScriptsToExecute from our ScriptsToExecute
func (execute *ScriptsToExecute) AssignProperties_To_ScriptsToExecute(destination *storage.ScriptsToExecute) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CreationScript
	if execute.CreationScript != nil {
		var creationScript storage.ScriptReference
		err := execute.CreationScript.AssignProperties_To_ScriptReference(&creationScript)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ScriptReference() to populate field CreationScript")
		}
		destination.CreationScript = &creationScript
	} else {
		destination.CreationScript = nil
	}

	// StartupScript
	if execute.StartupScript != nil {
		var startupScript storage.ScriptReference
		err := execute.StartupScript.AssignProperties_To_ScriptReference(&startupScript)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ScriptReference() to populate field StartupScript")
		}
		destination.StartupScript = &startupScript
	} else {
		destination.StartupScript = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Customized setup scripts
type ScriptsToExecute_STATUS struct {
	// CreationScript: Script that's run only once during provision of the compute.
	CreationScript *ScriptReference_STATUS `json:"creationScript,omitempty"`

	// StartupScript: Script that's run every time the machine starts.
	StartupScript *ScriptReference_STATUS `json:"startupScript,omitempty"`
}

var _ genruntime.FromARMConverter = &ScriptsToExecute_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (execute *ScriptsToExecute_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ScriptsToExecute_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (execute *ScriptsToExecute_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ScriptsToExecute_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ScriptsToExecute_STATUS, got %T", armInput)
	}

	// Set property "CreationScript":
	if typedInput.CreationScript != nil {
		var creationScript1 ScriptReference_STATUS
		err := creationScript1.PopulateFromARM(owner, *typedInput.CreationScript)
		if err != nil {
			return err
		}
		creationScript := creationScript1
		execute.CreationScript = &creationScript
	}

	// Set property "StartupScript":
	if typedInput.StartupScript != nil {
		var startupScript1 ScriptReference_STATUS
		err := startupScript1.PopulateFromARM(owner, *typedInput.StartupScript)
		if err != nil {
			return err
		}
		startupScript := startupScript1
		execute.StartupScript = &startupScript
	}

	// No error
	return nil
}

// AssignProperties_From_ScriptsToExecute_STATUS populates our ScriptsToExecute_STATUS from the provided source ScriptsToExecute_STATUS
func (execute *ScriptsToExecute_STATUS) AssignProperties_From_ScriptsToExecute_STATUS(source *storage.ScriptsToExecute_STATUS) error {

	// CreationScript
	if source.CreationScript != nil {
		var creationScript ScriptReference_STATUS
		err := creationScript.AssignProperties_From_ScriptReference_STATUS(source.CreationScript)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ScriptReference_STATUS() to populate field CreationScript")
		}
		execute.CreationScript = &creationScript
	} else {
		execute.CreationScript = nil
	}

	// StartupScript
	if source.StartupScript != nil {
		var startupScript ScriptReference_STATUS
		err := startupScript.AssignProperties_From_ScriptReference_STATUS(source.StartupScript)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ScriptReference_STATUS() to populate field StartupScript")
		}
		execute.StartupScript = &startupScript
	} else {
		execute.StartupScript = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ScriptsToExecute_STATUS populates the provided destination ScriptsToExecute_STATUS from our ScriptsToExecute_STATUS
func (execute *ScriptsToExecute_STATUS) AssignProperties_To_ScriptsToExecute_STATUS(destination *storage.ScriptsToExecute_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CreationScript
	if execute.CreationScript != nil {
		var creationScript storage.ScriptReference_STATUS
		err := execute.CreationScript.AssignProperties_To_ScriptReference_STATUS(&creationScript)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ScriptReference_STATUS() to populate field CreationScript")
		}
		destination.CreationScript = &creationScript
	} else {
		destination.CreationScript = nil
	}

	// StartupScript
	if execute.StartupScript != nil {
		var startupScript storage.ScriptReference_STATUS
		err := execute.StartupScript.AssignProperties_To_ScriptReference_STATUS(&startupScript)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ScriptReference_STATUS() to populate field StartupScript")
		}
		destination.StartupScript = &startupScript
	} else {
		destination.StartupScript = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Auto","Disabled","Enabled"}
type SslConfiguration_Status string

const (
	SslConfiguration_Status_Auto     = SslConfiguration_Status("Auto")
	SslConfiguration_Status_Disabled = SslConfiguration_Status("Disabled")
	SslConfiguration_Status_Enabled  = SslConfiguration_Status("Enabled")
)

// Mapping from string to SslConfiguration_Status
var sslConfiguration_Status_Values = map[string]SslConfiguration_Status{
	"auto":     SslConfiguration_Status_Auto,
	"disabled": SslConfiguration_Status_Disabled,
	"enabled":  SslConfiguration_Status_Enabled,
}

type SslConfiguration_Status_STATUS string

const (
	SslConfiguration_Status_STATUS_Auto     = SslConfiguration_Status_STATUS("Auto")
	SslConfiguration_Status_STATUS_Disabled = SslConfiguration_Status_STATUS("Disabled")
	SslConfiguration_Status_STATUS_Enabled  = SslConfiguration_Status_STATUS("Enabled")
)

// Mapping from string to SslConfiguration_Status_STATUS
var sslConfiguration_Status_STATUS_Values = map[string]SslConfiguration_Status_STATUS{
	"auto":     SslConfiguration_Status_STATUS_Auto,
	"disabled": SslConfiguration_Status_STATUS_Disabled,
	"enabled":  SslConfiguration_Status_STATUS_Enabled,
}

// Script reference
type ScriptReference struct {
	// ScriptArguments: Optional command line arguments passed to the script to run.
	ScriptArguments *string `json:"scriptArguments,omitempty"`

	// ScriptData: The location of scripts in the mounted volume.
	ScriptData *string `json:"scriptData,omitempty"`

	// ScriptSource: The storage source of the script: inline, workspace.
	ScriptSource *string `json:"scriptSource,omitempty"`

	// Timeout: Optional time period passed to timeout command.
	Timeout *string `json:"timeout,omitempty"`
}

var _ genruntime.ARMTransformer = &ScriptReference{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (reference *ScriptReference) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if reference == nil {
		return nil, nil
	}
	result := &arm.ScriptReference{}

	// Set property "ScriptArguments":
	if reference.ScriptArguments != nil {
		scriptArguments := *reference.ScriptArguments
		result.ScriptArguments = &scriptArguments
	}

	// Set property "ScriptData":
	if reference.ScriptData != nil {
		scriptData := *reference.ScriptData
		result.ScriptData = &scriptData
	}

	// Set property "ScriptSource":
	if reference.ScriptSource != nil {
		scriptSource := *reference.ScriptSource
		result.ScriptSource = &scriptSource
	}

	// Set property "Timeout":
	if reference.Timeout != nil {
		timeout := *reference.Timeout
		result.Timeout = &timeout
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *ScriptReference) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ScriptReference{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *ScriptReference) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ScriptReference)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ScriptReference, got %T", armInput)
	}

	// Set property "ScriptArguments":
	if typedInput.ScriptArguments != nil {
		scriptArguments := *typedInput.ScriptArguments
		reference.ScriptArguments = &scriptArguments
	}

	// Set property "ScriptData":
	if typedInput.ScriptData != nil {
		scriptData := *typedInput.ScriptData
		reference.ScriptData = &scriptData
	}

	// Set property "ScriptSource":
	if typedInput.ScriptSource != nil {
		scriptSource := *typedInput.ScriptSource
		reference.ScriptSource = &scriptSource
	}

	// Set property "Timeout":
	if typedInput.Timeout != nil {
		timeout := *typedInput.Timeout
		reference.Timeout = &timeout
	}

	// No error
	return nil
}

// AssignProperties_From_ScriptReference populates our ScriptReference from the provided source ScriptReference
func (reference *ScriptReference) AssignProperties_From_ScriptReference(source *storage.ScriptReference) error {

	// ScriptArguments
	reference.ScriptArguments = genruntime.ClonePointerToString(source.ScriptArguments)

	// ScriptData
	reference.ScriptData = genruntime.ClonePointerToString(source.ScriptData)

	// ScriptSource
	reference.ScriptSource = genruntime.ClonePointerToString(source.ScriptSource)

	// Timeout
	reference.Timeout = genruntime.ClonePointerToString(source.Timeout)

	// No error
	return nil
}

// AssignProperties_To_ScriptReference populates the provided destination ScriptReference from our ScriptReference
func (reference *ScriptReference) AssignProperties_To_ScriptReference(destination *storage.ScriptReference) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ScriptArguments
	destination.ScriptArguments = genruntime.ClonePointerToString(reference.ScriptArguments)

	// ScriptData
	destination.ScriptData = genruntime.ClonePointerToString(reference.ScriptData)

	// ScriptSource
	destination.ScriptSource = genruntime.ClonePointerToString(reference.ScriptSource)

	// Timeout
	destination.Timeout = genruntime.ClonePointerToString(reference.Timeout)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Script reference
type ScriptReference_STATUS struct {
	// ScriptArguments: Optional command line arguments passed to the script to run.
	ScriptArguments *string `json:"scriptArguments,omitempty"`

	// ScriptData: The location of scripts in the mounted volume.
	ScriptData *string `json:"scriptData,omitempty"`

	// ScriptSource: The storage source of the script: inline, workspace.
	ScriptSource *string `json:"scriptSource,omitempty"`

	// Timeout: Optional time period passed to timeout command.
	Timeout *string `json:"timeout,omitempty"`
}

var _ genruntime.FromARMConverter = &ScriptReference_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *ScriptReference_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ScriptReference_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *ScriptReference_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ScriptReference_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ScriptReference_STATUS, got %T", armInput)
	}

	// Set property "ScriptArguments":
	if typedInput.ScriptArguments != nil {
		scriptArguments := *typedInput.ScriptArguments
		reference.ScriptArguments = &scriptArguments
	}

	// Set property "ScriptData":
	if typedInput.ScriptData != nil {
		scriptData := *typedInput.ScriptData
		reference.ScriptData = &scriptData
	}

	// Set property "ScriptSource":
	if typedInput.ScriptSource != nil {
		scriptSource := *typedInput.ScriptSource
		reference.ScriptSource = &scriptSource
	}

	// Set property "Timeout":
	if typedInput.Timeout != nil {
		timeout := *typedInput.Timeout
		reference.Timeout = &timeout
	}

	// No error
	return nil
}

// AssignProperties_From_ScriptReference_STATUS populates our ScriptReference_STATUS from the provided source ScriptReference_STATUS
func (reference *ScriptReference_STATUS) AssignProperties_From_ScriptReference_STATUS(source *storage.ScriptReference_STATUS) error {

	// ScriptArguments
	reference.ScriptArguments = genruntime.ClonePointerToString(source.ScriptArguments)

	// ScriptData
	reference.ScriptData = genruntime.ClonePointerToString(source.ScriptData)

	// ScriptSource
	reference.ScriptSource = genruntime.ClonePointerToString(source.ScriptSource)

	// Timeout
	reference.Timeout = genruntime.ClonePointerToString(source.Timeout)

	// No error
	return nil
}

// AssignProperties_To_ScriptReference_STATUS populates the provided destination ScriptReference_STATUS from our ScriptReference_STATUS
func (reference *ScriptReference_STATUS) AssignProperties_To_ScriptReference_STATUS(destination *storage.ScriptReference_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ScriptArguments
	destination.ScriptArguments = genruntime.ClonePointerToString(reference.ScriptArguments)

	// ScriptData
	destination.ScriptData = genruntime.ClonePointerToString(reference.ScriptData)

	// ScriptSource
	destination.ScriptSource = genruntime.ClonePointerToString(reference.ScriptSource)

	// Timeout
	destination.Timeout = genruntime.ClonePointerToString(reference.Timeout)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&WorkspacesCompute{}, &WorkspacesComputeList{})
}
