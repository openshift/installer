// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20240101

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/network/v1api20240101/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/network/v1api20240101/storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /network/resource-manager/Microsoft.Network/stable/2024-01-01/webapplicationfirewall.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ApplicationGatewayWebApplicationFirewallPolicies/{policyName}
type WebApplicationFirewallPolicy struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              WebApplicationFirewallPolicy_Spec   `json:"spec,omitempty"`
	Status            WebApplicationFirewallPolicy_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &WebApplicationFirewallPolicy{}

// GetConditions returns the conditions of the resource
func (policy *WebApplicationFirewallPolicy) GetConditions() conditions.Conditions {
	return policy.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (policy *WebApplicationFirewallPolicy) SetConditions(conditions conditions.Conditions) {
	policy.Status.Conditions = conditions
}

var _ conversion.Convertible = &WebApplicationFirewallPolicy{}

// ConvertFrom populates our WebApplicationFirewallPolicy from the provided hub WebApplicationFirewallPolicy
func (policy *WebApplicationFirewallPolicy) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.WebApplicationFirewallPolicy)
	if !ok {
		return fmt.Errorf("expected network/v1api20240101/storage/WebApplicationFirewallPolicy but received %T instead", hub)
	}

	return policy.AssignProperties_From_WebApplicationFirewallPolicy(source)
}

// ConvertTo populates the provided hub WebApplicationFirewallPolicy from our WebApplicationFirewallPolicy
func (policy *WebApplicationFirewallPolicy) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.WebApplicationFirewallPolicy)
	if !ok {
		return fmt.Errorf("expected network/v1api20240101/storage/WebApplicationFirewallPolicy but received %T instead", hub)
	}

	return policy.AssignProperties_To_WebApplicationFirewallPolicy(destination)
}

// +kubebuilder:webhook:path=/mutate-network-azure-com-v1api20240101-webapplicationfirewallpolicy,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=network.azure.com,resources=webapplicationfirewallpolicies,verbs=create;update,versions=v1api20240101,name=default.v1api20240101.webapplicationfirewallpolicies.network.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &WebApplicationFirewallPolicy{}

// Default applies defaults to the WebApplicationFirewallPolicy resource
func (policy *WebApplicationFirewallPolicy) Default() {
	policy.defaultImpl()
	var temp any = policy
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (policy *WebApplicationFirewallPolicy) defaultAzureName() {
	if policy.Spec.AzureName == "" {
		policy.Spec.AzureName = policy.Name
	}
}

// defaultImpl applies the code generated defaults to the WebApplicationFirewallPolicy resource
func (policy *WebApplicationFirewallPolicy) defaultImpl() { policy.defaultAzureName() }

var _ configmaps.Exporter = &WebApplicationFirewallPolicy{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (policy *WebApplicationFirewallPolicy) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if policy.Spec.OperatorSpec == nil {
		return nil
	}
	return policy.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &WebApplicationFirewallPolicy{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (policy *WebApplicationFirewallPolicy) SecretDestinationExpressions() []*core.DestinationExpression {
	if policy.Spec.OperatorSpec == nil {
		return nil
	}
	return policy.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &WebApplicationFirewallPolicy{}

// InitializeSpec initializes the spec for this resource from the given status
func (policy *WebApplicationFirewallPolicy) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*WebApplicationFirewallPolicy_STATUS); ok {
		return policy.Spec.Initialize_From_WebApplicationFirewallPolicy_STATUS(s)
	}

	return fmt.Errorf("expected Status of type WebApplicationFirewallPolicy_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &WebApplicationFirewallPolicy{}

// AzureName returns the Azure name of the resource
func (policy *WebApplicationFirewallPolicy) AzureName() string {
	return policy.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2024-01-01"
func (policy WebApplicationFirewallPolicy) GetAPIVersion() string {
	return "2024-01-01"
}

// GetResourceScope returns the scope of the resource
func (policy *WebApplicationFirewallPolicy) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (policy *WebApplicationFirewallPolicy) GetSpec() genruntime.ConvertibleSpec {
	return &policy.Spec
}

// GetStatus returns the status of this resource
func (policy *WebApplicationFirewallPolicy) GetStatus() genruntime.ConvertibleStatus {
	return &policy.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (policy *WebApplicationFirewallPolicy) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Network/ApplicationGatewayWebApplicationFirewallPolicies"
func (policy *WebApplicationFirewallPolicy) GetType() string {
	return "Microsoft.Network/ApplicationGatewayWebApplicationFirewallPolicies"
}

// NewEmptyStatus returns a new empty (blank) status
func (policy *WebApplicationFirewallPolicy) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &WebApplicationFirewallPolicy_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (policy *WebApplicationFirewallPolicy) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(policy.Spec)
	return policy.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (policy *WebApplicationFirewallPolicy) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*WebApplicationFirewallPolicy_STATUS); ok {
		policy.Status = *st
		return nil
	}

	// Convert status to required version
	var st WebApplicationFirewallPolicy_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	policy.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-network-azure-com-v1api20240101-webapplicationfirewallpolicy,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=network.azure.com,resources=webapplicationfirewallpolicies,verbs=create;update,versions=v1api20240101,name=validate.v1api20240101.webapplicationfirewallpolicies.network.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &WebApplicationFirewallPolicy{}

// ValidateCreate validates the creation of the resource
func (policy *WebApplicationFirewallPolicy) ValidateCreate() (admission.Warnings, error) {
	validations := policy.createValidations()
	var temp any = policy
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	return genruntime.ValidateCreate(validations)
}

// ValidateDelete validates the deletion of the resource
func (policy *WebApplicationFirewallPolicy) ValidateDelete() (admission.Warnings, error) {
	validations := policy.deleteValidations()
	var temp any = policy
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	return genruntime.ValidateDelete(validations)
}

// ValidateUpdate validates an update of the resource
func (policy *WebApplicationFirewallPolicy) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	validations := policy.updateValidations()
	var temp any = policy
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	return genruntime.ValidateUpdate(old, validations)
}

// createValidations validates the creation of the resource
func (policy *WebApplicationFirewallPolicy) createValidations() []func() (admission.Warnings, error) {
	return []func() (admission.Warnings, error){policy.validateResourceReferences, policy.validateOwnerReference, policy.validateSecretDestinations, policy.validateConfigMapDestinations}
}

// deleteValidations validates the deletion of the resource
func (policy *WebApplicationFirewallPolicy) deleteValidations() []func() (admission.Warnings, error) {
	return nil
}

// updateValidations validates the update of the resource
func (policy *WebApplicationFirewallPolicy) updateValidations() []func(old runtime.Object) (admission.Warnings, error) {
	return []func(old runtime.Object) (admission.Warnings, error){
		func(old runtime.Object) (admission.Warnings, error) {
			return policy.validateResourceReferences()
		},
		policy.validateWriteOnceProperties,
		func(old runtime.Object) (admission.Warnings, error) {
			return policy.validateOwnerReference()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return policy.validateSecretDestinations()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return policy.validateConfigMapDestinations()
		},
	}
}

// validateConfigMapDestinations validates there are no colliding genruntime.ConfigMapDestinations
func (policy *WebApplicationFirewallPolicy) validateConfigMapDestinations() (admission.Warnings, error) {
	if policy.Spec.OperatorSpec == nil {
		return nil, nil
	}
	return configmaps.ValidateDestinations(policy, nil, policy.Spec.OperatorSpec.ConfigMapExpressions)
}

// validateOwnerReference validates the owner field
func (policy *WebApplicationFirewallPolicy) validateOwnerReference() (admission.Warnings, error) {
	return genruntime.ValidateOwner(policy)
}

// validateResourceReferences validates all resource references
func (policy *WebApplicationFirewallPolicy) validateResourceReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindResourceReferences(&policy.Spec)
	if err != nil {
		return nil, err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateSecretDestinations validates there are no colliding genruntime.SecretDestination's
func (policy *WebApplicationFirewallPolicy) validateSecretDestinations() (admission.Warnings, error) {
	if policy.Spec.OperatorSpec == nil {
		return nil, nil
	}
	return secrets.ValidateDestinations(policy, nil, policy.Spec.OperatorSpec.SecretExpressions)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (policy *WebApplicationFirewallPolicy) validateWriteOnceProperties(old runtime.Object) (admission.Warnings, error) {
	oldObj, ok := old.(*WebApplicationFirewallPolicy)
	if !ok {
		return nil, nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, policy)
}

// AssignProperties_From_WebApplicationFirewallPolicy populates our WebApplicationFirewallPolicy from the provided source WebApplicationFirewallPolicy
func (policy *WebApplicationFirewallPolicy) AssignProperties_From_WebApplicationFirewallPolicy(source *storage.WebApplicationFirewallPolicy) error {

	// ObjectMeta
	policy.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec WebApplicationFirewallPolicy_Spec
	err := spec.AssignProperties_From_WebApplicationFirewallPolicy_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_WebApplicationFirewallPolicy_Spec() to populate field Spec")
	}
	policy.Spec = spec

	// Status
	var status WebApplicationFirewallPolicy_STATUS
	err = status.AssignProperties_From_WebApplicationFirewallPolicy_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_WebApplicationFirewallPolicy_STATUS() to populate field Status")
	}
	policy.Status = status

	// No error
	return nil
}

// AssignProperties_To_WebApplicationFirewallPolicy populates the provided destination WebApplicationFirewallPolicy from our WebApplicationFirewallPolicy
func (policy *WebApplicationFirewallPolicy) AssignProperties_To_WebApplicationFirewallPolicy(destination *storage.WebApplicationFirewallPolicy) error {

	// ObjectMeta
	destination.ObjectMeta = *policy.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.WebApplicationFirewallPolicy_Spec
	err := policy.Spec.AssignProperties_To_WebApplicationFirewallPolicy_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_WebApplicationFirewallPolicy_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.WebApplicationFirewallPolicy_STATUS
	err = policy.Status.AssignProperties_To_WebApplicationFirewallPolicy_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_WebApplicationFirewallPolicy_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (policy *WebApplicationFirewallPolicy) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: policy.Spec.OriginalVersion(),
		Kind:    "WebApplicationFirewallPolicy",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /network/resource-manager/Microsoft.Network/stable/2024-01-01/webapplicationfirewall.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ApplicationGatewayWebApplicationFirewallPolicies/{policyName}
type WebApplicationFirewallPolicyList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []WebApplicationFirewallPolicy `json:"items"`
}

type WebApplicationFirewallPolicy_Spec struct {
	// +kubebuilder:validation:MaxLength=128
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// CustomRules: The custom rules inside the policy.
	CustomRules []WebApplicationFirewallCustomRule `json:"customRules,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// +kubebuilder:validation:Required
	// ManagedRules: Describes the managedRules structure.
	ManagedRules *ManagedRulesDefinition `json:"managedRules,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *WebApplicationFirewallPolicyOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// PolicySettings: The PolicySettings for policy.
	PolicySettings *PolicySettings `json:"policySettings,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &WebApplicationFirewallPolicy_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *WebApplicationFirewallPolicy_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	result := &arm.WebApplicationFirewallPolicy_Spec{}

	// Set property "Location":
	if policy.Location != nil {
		location := *policy.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if policy.CustomRules != nil ||
		policy.ManagedRules != nil ||
		policy.PolicySettings != nil {
		result.Properties = &arm.WebApplicationFirewallPolicyPropertiesFormat{}
	}
	for _, item := range policy.CustomRules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.CustomRules = append(result.Properties.CustomRules, *item_ARM.(*arm.WebApplicationFirewallCustomRule))
	}
	if policy.ManagedRules != nil {
		managedRules_ARM, err := (*policy.ManagedRules).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		managedRules := *managedRules_ARM.(*arm.ManagedRulesDefinition)
		result.Properties.ManagedRules = &managedRules
	}
	if policy.PolicySettings != nil {
		policySettings_ARM, err := (*policy.PolicySettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		policySettings := *policySettings_ARM.(*arm.PolicySettings)
		result.Properties.PolicySettings = &policySettings
	}

	// Set property "Tags":
	if policy.Tags != nil {
		result.Tags = make(map[string]string, len(policy.Tags))
		for key, value := range policy.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *WebApplicationFirewallPolicy_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WebApplicationFirewallPolicy_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *WebApplicationFirewallPolicy_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WebApplicationFirewallPolicy_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WebApplicationFirewallPolicy_Spec, got %T", armInput)
	}

	// Set property "AzureName":
	policy.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "CustomRules":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.CustomRules {
			var item1 WebApplicationFirewallCustomRule
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			policy.CustomRules = append(policy.CustomRules, item1)
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		policy.Location = &location
	}

	// Set property "ManagedRules":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ManagedRules != nil {
			var managedRules1 ManagedRulesDefinition
			err := managedRules1.PopulateFromARM(owner, *typedInput.Properties.ManagedRules)
			if err != nil {
				return err
			}
			managedRules := managedRules1
			policy.ManagedRules = &managedRules
		}
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	policy.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "PolicySettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PolicySettings != nil {
			var policySettings1 PolicySettings
			err := policySettings1.PopulateFromARM(owner, *typedInput.Properties.PolicySettings)
			if err != nil {
				return err
			}
			policySettings := policySettings1
			policy.PolicySettings = &policySettings
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		policy.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			policy.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &WebApplicationFirewallPolicy_Spec{}

// ConvertSpecFrom populates our WebApplicationFirewallPolicy_Spec from the provided source
func (policy *WebApplicationFirewallPolicy_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.WebApplicationFirewallPolicy_Spec)
	if ok {
		// Populate our instance from source
		return policy.AssignProperties_From_WebApplicationFirewallPolicy_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.WebApplicationFirewallPolicy_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = policy.AssignProperties_From_WebApplicationFirewallPolicy_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our WebApplicationFirewallPolicy_Spec
func (policy *WebApplicationFirewallPolicy_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.WebApplicationFirewallPolicy_Spec)
	if ok {
		// Populate destination from our instance
		return policy.AssignProperties_To_WebApplicationFirewallPolicy_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.WebApplicationFirewallPolicy_Spec{}
	err := policy.AssignProperties_To_WebApplicationFirewallPolicy_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_WebApplicationFirewallPolicy_Spec populates our WebApplicationFirewallPolicy_Spec from the provided source WebApplicationFirewallPolicy_Spec
func (policy *WebApplicationFirewallPolicy_Spec) AssignProperties_From_WebApplicationFirewallPolicy_Spec(source *storage.WebApplicationFirewallPolicy_Spec) error {

	// AzureName
	policy.AzureName = source.AzureName

	// CustomRules
	if source.CustomRules != nil {
		customRuleList := make([]WebApplicationFirewallCustomRule, len(source.CustomRules))
		for customRuleIndex, customRuleItem := range source.CustomRules {
			// Shadow the loop variable to avoid aliasing
			customRuleItem := customRuleItem
			var customRule WebApplicationFirewallCustomRule
			err := customRule.AssignProperties_From_WebApplicationFirewallCustomRule(&customRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_WebApplicationFirewallCustomRule() to populate field CustomRules")
			}
			customRuleList[customRuleIndex] = customRule
		}
		policy.CustomRules = customRuleList
	} else {
		policy.CustomRules = nil
	}

	// Location
	policy.Location = genruntime.ClonePointerToString(source.Location)

	// ManagedRules
	if source.ManagedRules != nil {
		var managedRule ManagedRulesDefinition
		err := managedRule.AssignProperties_From_ManagedRulesDefinition(source.ManagedRules)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedRulesDefinition() to populate field ManagedRules")
		}
		policy.ManagedRules = &managedRule
	} else {
		policy.ManagedRules = nil
	}

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec WebApplicationFirewallPolicyOperatorSpec
		err := operatorSpec.AssignProperties_From_WebApplicationFirewallPolicyOperatorSpec(source.OperatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WebApplicationFirewallPolicyOperatorSpec() to populate field OperatorSpec")
		}
		policy.OperatorSpec = &operatorSpec
	} else {
		policy.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		policy.Owner = &owner
	} else {
		policy.Owner = nil
	}

	// PolicySettings
	if source.PolicySettings != nil {
		var policySetting PolicySettings
		err := policySetting.AssignProperties_From_PolicySettings(source.PolicySettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PolicySettings() to populate field PolicySettings")
		}
		policy.PolicySettings = &policySetting
	} else {
		policy.PolicySettings = nil
	}

	// Tags
	policy.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// AssignProperties_To_WebApplicationFirewallPolicy_Spec populates the provided destination WebApplicationFirewallPolicy_Spec from our WebApplicationFirewallPolicy_Spec
func (policy *WebApplicationFirewallPolicy_Spec) AssignProperties_To_WebApplicationFirewallPolicy_Spec(destination *storage.WebApplicationFirewallPolicy_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = policy.AzureName

	// CustomRules
	if policy.CustomRules != nil {
		customRuleList := make([]storage.WebApplicationFirewallCustomRule, len(policy.CustomRules))
		for customRuleIndex, customRuleItem := range policy.CustomRules {
			// Shadow the loop variable to avoid aliasing
			customRuleItem := customRuleItem
			var customRule storage.WebApplicationFirewallCustomRule
			err := customRuleItem.AssignProperties_To_WebApplicationFirewallCustomRule(&customRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_WebApplicationFirewallCustomRule() to populate field CustomRules")
			}
			customRuleList[customRuleIndex] = customRule
		}
		destination.CustomRules = customRuleList
	} else {
		destination.CustomRules = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(policy.Location)

	// ManagedRules
	if policy.ManagedRules != nil {
		var managedRule storage.ManagedRulesDefinition
		err := policy.ManagedRules.AssignProperties_To_ManagedRulesDefinition(&managedRule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedRulesDefinition() to populate field ManagedRules")
		}
		destination.ManagedRules = &managedRule
	} else {
		destination.ManagedRules = nil
	}

	// OperatorSpec
	if policy.OperatorSpec != nil {
		var operatorSpec storage.WebApplicationFirewallPolicyOperatorSpec
		err := policy.OperatorSpec.AssignProperties_To_WebApplicationFirewallPolicyOperatorSpec(&operatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WebApplicationFirewallPolicyOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = policy.OriginalVersion()

	// Owner
	if policy.Owner != nil {
		owner := policy.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// PolicySettings
	if policy.PolicySettings != nil {
		var policySetting storage.PolicySettings
		err := policy.PolicySettings.AssignProperties_To_PolicySettings(&policySetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PolicySettings() to populate field PolicySettings")
		}
		destination.PolicySettings = &policySetting
	} else {
		destination.PolicySettings = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(policy.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_WebApplicationFirewallPolicy_STATUS populates our WebApplicationFirewallPolicy_Spec from the provided source WebApplicationFirewallPolicy_STATUS
func (policy *WebApplicationFirewallPolicy_Spec) Initialize_From_WebApplicationFirewallPolicy_STATUS(source *WebApplicationFirewallPolicy_STATUS) error {

	// CustomRules
	if source.CustomRules != nil {
		customRuleList := make([]WebApplicationFirewallCustomRule, len(source.CustomRules))
		for customRuleIndex, customRuleItem := range source.CustomRules {
			// Shadow the loop variable to avoid aliasing
			customRuleItem := customRuleItem
			var customRule WebApplicationFirewallCustomRule
			err := customRule.Initialize_From_WebApplicationFirewallCustomRule_STATUS(&customRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_WebApplicationFirewallCustomRule_STATUS() to populate field CustomRules")
			}
			customRuleList[customRuleIndex] = customRule
		}
		policy.CustomRules = customRuleList
	} else {
		policy.CustomRules = nil
	}

	// Location
	policy.Location = genruntime.ClonePointerToString(source.Location)

	// ManagedRules
	if source.ManagedRules != nil {
		var managedRule ManagedRulesDefinition
		err := managedRule.Initialize_From_ManagedRulesDefinition_STATUS(source.ManagedRules)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ManagedRulesDefinition_STATUS() to populate field ManagedRules")
		}
		policy.ManagedRules = &managedRule
	} else {
		policy.ManagedRules = nil
	}

	// PolicySettings
	if source.PolicySettings != nil {
		var policySetting PolicySettings
		err := policySetting.Initialize_From_PolicySettings_STATUS(source.PolicySettings)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_PolicySettings_STATUS() to populate field PolicySettings")
		}
		policy.PolicySettings = &policySetting
	} else {
		policy.PolicySettings = nil
	}

	// Tags
	policy.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (policy *WebApplicationFirewallPolicy_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (policy *WebApplicationFirewallPolicy_Spec) SetAzureName(azureName string) {
	policy.AzureName = azureName
}

type WebApplicationFirewallPolicy_STATUS struct {
	// ApplicationGateways: A collection of references to application gateways.
	ApplicationGateways []ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded `json:"applicationGateways,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// CustomRules: The custom rules inside the policy.
	CustomRules []WebApplicationFirewallCustomRule_STATUS `json:"customRules,omitempty"`

	// Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	// HttpListeners: A collection of references to application gateway http listeners.
	HttpListeners []SubResource_STATUS `json:"httpListeners,omitempty"`

	// Id: Resource ID.
	Id *string `json:"id,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// ManagedRules: Describes the managedRules structure.
	ManagedRules *ManagedRulesDefinition_STATUS `json:"managedRules,omitempty"`

	// Name: Resource name.
	Name *string `json:"name,omitempty"`

	// PathBasedRules: A collection of references to application gateway path rules.
	PathBasedRules []SubResource_STATUS `json:"pathBasedRules,omitempty"`

	// PolicySettings: The PolicySettings for policy.
	PolicySettings *PolicySettings_STATUS `json:"policySettings,omitempty"`

	// ProvisioningState: The provisioning state of the web application firewall policy resource.
	ProvisioningState *ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// ResourceState: Resource status of the policy.
	ResourceState *WebApplicationFirewallPolicyPropertiesFormat_ResourceState_STATUS `json:"resourceState,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: Resource type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &WebApplicationFirewallPolicy_STATUS{}

// ConvertStatusFrom populates our WebApplicationFirewallPolicy_STATUS from the provided source
func (policy *WebApplicationFirewallPolicy_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.WebApplicationFirewallPolicy_STATUS)
	if ok {
		// Populate our instance from source
		return policy.AssignProperties_From_WebApplicationFirewallPolicy_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.WebApplicationFirewallPolicy_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = policy.AssignProperties_From_WebApplicationFirewallPolicy_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our WebApplicationFirewallPolicy_STATUS
func (policy *WebApplicationFirewallPolicy_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.WebApplicationFirewallPolicy_STATUS)
	if ok {
		// Populate destination from our instance
		return policy.AssignProperties_To_WebApplicationFirewallPolicy_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.WebApplicationFirewallPolicy_STATUS{}
	err := policy.AssignProperties_To_WebApplicationFirewallPolicy_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &WebApplicationFirewallPolicy_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *WebApplicationFirewallPolicy_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WebApplicationFirewallPolicy_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *WebApplicationFirewallPolicy_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WebApplicationFirewallPolicy_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WebApplicationFirewallPolicy_STATUS, got %T", armInput)
	}

	// Set property "ApplicationGateways":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationGateways {
			var item1 ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			policy.ApplicationGateways = append(policy.ApplicationGateways, item1)
		}
	}

	// no assignment for property "Conditions"

	// Set property "CustomRules":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.CustomRules {
			var item1 WebApplicationFirewallCustomRule_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			policy.CustomRules = append(policy.CustomRules, item1)
		}
	}

	// Set property "Etag":
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		policy.Etag = &etag
	}

	// Set property "HttpListeners":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.HttpListeners {
			var item1 SubResource_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			policy.HttpListeners = append(policy.HttpListeners, item1)
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		policy.Id = &id
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		policy.Location = &location
	}

	// Set property "ManagedRules":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ManagedRules != nil {
			var managedRules1 ManagedRulesDefinition_STATUS
			err := managedRules1.PopulateFromARM(owner, *typedInput.Properties.ManagedRules)
			if err != nil {
				return err
			}
			managedRules := managedRules1
			policy.ManagedRules = &managedRules
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		policy.Name = &name
	}

	// Set property "PathBasedRules":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.PathBasedRules {
			var item1 SubResource_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			policy.PathBasedRules = append(policy.PathBasedRules, item1)
		}
	}

	// Set property "PolicySettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PolicySettings != nil {
			var policySettings1 PolicySettings_STATUS
			err := policySettings1.PopulateFromARM(owner, *typedInput.Properties.PolicySettings)
			if err != nil {
				return err
			}
			policySettings := policySettings1
			policy.PolicySettings = &policySettings
		}
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			var temp string
			temp = string(*typedInput.Properties.ProvisioningState)
			provisioningState := ProvisioningState_STATUS(temp)
			policy.ProvisioningState = &provisioningState
		}
	}

	// Set property "ResourceState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ResourceState != nil {
			var temp string
			temp = string(*typedInput.Properties.ResourceState)
			resourceState := WebApplicationFirewallPolicyPropertiesFormat_ResourceState_STATUS(temp)
			policy.ResourceState = &resourceState
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		policy.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			policy.Tags[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		policy.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_WebApplicationFirewallPolicy_STATUS populates our WebApplicationFirewallPolicy_STATUS from the provided source WebApplicationFirewallPolicy_STATUS
func (policy *WebApplicationFirewallPolicy_STATUS) AssignProperties_From_WebApplicationFirewallPolicy_STATUS(source *storage.WebApplicationFirewallPolicy_STATUS) error {

	// ApplicationGateways
	if source.ApplicationGateways != nil {
		applicationGatewayList := make([]ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded, len(source.ApplicationGateways))
		for applicationGatewayIndex, applicationGatewayItem := range source.ApplicationGateways {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayItem := applicationGatewayItem
			var applicationGateway ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded
			err := applicationGateway.AssignProperties_From_ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded(&applicationGatewayItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded() to populate field ApplicationGateways")
			}
			applicationGatewayList[applicationGatewayIndex] = applicationGateway
		}
		policy.ApplicationGateways = applicationGatewayList
	} else {
		policy.ApplicationGateways = nil
	}

	// Conditions
	policy.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// CustomRules
	if source.CustomRules != nil {
		customRuleList := make([]WebApplicationFirewallCustomRule_STATUS, len(source.CustomRules))
		for customRuleIndex, customRuleItem := range source.CustomRules {
			// Shadow the loop variable to avoid aliasing
			customRuleItem := customRuleItem
			var customRule WebApplicationFirewallCustomRule_STATUS
			err := customRule.AssignProperties_From_WebApplicationFirewallCustomRule_STATUS(&customRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_WebApplicationFirewallCustomRule_STATUS() to populate field CustomRules")
			}
			customRuleList[customRuleIndex] = customRule
		}
		policy.CustomRules = customRuleList
	} else {
		policy.CustomRules = nil
	}

	// Etag
	policy.Etag = genruntime.ClonePointerToString(source.Etag)

	// HttpListeners
	if source.HttpListeners != nil {
		httpListenerList := make([]SubResource_STATUS, len(source.HttpListeners))
		for httpListenerIndex, httpListenerItem := range source.HttpListeners {
			// Shadow the loop variable to avoid aliasing
			httpListenerItem := httpListenerItem
			var httpListener SubResource_STATUS
			err := httpListener.AssignProperties_From_SubResource_STATUS(&httpListenerItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field HttpListeners")
			}
			httpListenerList[httpListenerIndex] = httpListener
		}
		policy.HttpListeners = httpListenerList
	} else {
		policy.HttpListeners = nil
	}

	// Id
	policy.Id = genruntime.ClonePointerToString(source.Id)

	// Location
	policy.Location = genruntime.ClonePointerToString(source.Location)

	// ManagedRules
	if source.ManagedRules != nil {
		var managedRule ManagedRulesDefinition_STATUS
		err := managedRule.AssignProperties_From_ManagedRulesDefinition_STATUS(source.ManagedRules)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedRulesDefinition_STATUS() to populate field ManagedRules")
		}
		policy.ManagedRules = &managedRule
	} else {
		policy.ManagedRules = nil
	}

	// Name
	policy.Name = genruntime.ClonePointerToString(source.Name)

	// PathBasedRules
	if source.PathBasedRules != nil {
		pathBasedRuleList := make([]SubResource_STATUS, len(source.PathBasedRules))
		for pathBasedRuleIndex, pathBasedRuleItem := range source.PathBasedRules {
			// Shadow the loop variable to avoid aliasing
			pathBasedRuleItem := pathBasedRuleItem
			var pathBasedRule SubResource_STATUS
			err := pathBasedRule.AssignProperties_From_SubResource_STATUS(&pathBasedRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field PathBasedRules")
			}
			pathBasedRuleList[pathBasedRuleIndex] = pathBasedRule
		}
		policy.PathBasedRules = pathBasedRuleList
	} else {
		policy.PathBasedRules = nil
	}

	// PolicySettings
	if source.PolicySettings != nil {
		var policySetting PolicySettings_STATUS
		err := policySetting.AssignProperties_From_PolicySettings_STATUS(source.PolicySettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PolicySettings_STATUS() to populate field PolicySettings")
		}
		policy.PolicySettings = &policySetting
	} else {
		policy.PolicySettings = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, provisioningState_STATUS_Values)
		policy.ProvisioningState = &provisioningStateTemp
	} else {
		policy.ProvisioningState = nil
	}

	// ResourceState
	if source.ResourceState != nil {
		resourceState := *source.ResourceState
		resourceStateTemp := genruntime.ToEnum(resourceState, webApplicationFirewallPolicyPropertiesFormat_ResourceState_STATUS_Values)
		policy.ResourceState = &resourceStateTemp
	} else {
		policy.ResourceState = nil
	}

	// Tags
	policy.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	policy.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_WebApplicationFirewallPolicy_STATUS populates the provided destination WebApplicationFirewallPolicy_STATUS from our WebApplicationFirewallPolicy_STATUS
func (policy *WebApplicationFirewallPolicy_STATUS) AssignProperties_To_WebApplicationFirewallPolicy_STATUS(destination *storage.WebApplicationFirewallPolicy_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ApplicationGateways
	if policy.ApplicationGateways != nil {
		applicationGatewayList := make([]storage.ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded, len(policy.ApplicationGateways))
		for applicationGatewayIndex, applicationGatewayItem := range policy.ApplicationGateways {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayItem := applicationGatewayItem
			var applicationGateway storage.ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded
			err := applicationGatewayItem.AssignProperties_To_ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded(&applicationGateway)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded() to populate field ApplicationGateways")
			}
			applicationGatewayList[applicationGatewayIndex] = applicationGateway
		}
		destination.ApplicationGateways = applicationGatewayList
	} else {
		destination.ApplicationGateways = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(policy.Conditions)

	// CustomRules
	if policy.CustomRules != nil {
		customRuleList := make([]storage.WebApplicationFirewallCustomRule_STATUS, len(policy.CustomRules))
		for customRuleIndex, customRuleItem := range policy.CustomRules {
			// Shadow the loop variable to avoid aliasing
			customRuleItem := customRuleItem
			var customRule storage.WebApplicationFirewallCustomRule_STATUS
			err := customRuleItem.AssignProperties_To_WebApplicationFirewallCustomRule_STATUS(&customRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_WebApplicationFirewallCustomRule_STATUS() to populate field CustomRules")
			}
			customRuleList[customRuleIndex] = customRule
		}
		destination.CustomRules = customRuleList
	} else {
		destination.CustomRules = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(policy.Etag)

	// HttpListeners
	if policy.HttpListeners != nil {
		httpListenerList := make([]storage.SubResource_STATUS, len(policy.HttpListeners))
		for httpListenerIndex, httpListenerItem := range policy.HttpListeners {
			// Shadow the loop variable to avoid aliasing
			httpListenerItem := httpListenerItem
			var httpListener storage.SubResource_STATUS
			err := httpListenerItem.AssignProperties_To_SubResource_STATUS(&httpListener)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field HttpListeners")
			}
			httpListenerList[httpListenerIndex] = httpListener
		}
		destination.HttpListeners = httpListenerList
	} else {
		destination.HttpListeners = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(policy.Id)

	// Location
	destination.Location = genruntime.ClonePointerToString(policy.Location)

	// ManagedRules
	if policy.ManagedRules != nil {
		var managedRule storage.ManagedRulesDefinition_STATUS
		err := policy.ManagedRules.AssignProperties_To_ManagedRulesDefinition_STATUS(&managedRule)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedRulesDefinition_STATUS() to populate field ManagedRules")
		}
		destination.ManagedRules = &managedRule
	} else {
		destination.ManagedRules = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(policy.Name)

	// PathBasedRules
	if policy.PathBasedRules != nil {
		pathBasedRuleList := make([]storage.SubResource_STATUS, len(policy.PathBasedRules))
		for pathBasedRuleIndex, pathBasedRuleItem := range policy.PathBasedRules {
			// Shadow the loop variable to avoid aliasing
			pathBasedRuleItem := pathBasedRuleItem
			var pathBasedRule storage.SubResource_STATUS
			err := pathBasedRuleItem.AssignProperties_To_SubResource_STATUS(&pathBasedRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field PathBasedRules")
			}
			pathBasedRuleList[pathBasedRuleIndex] = pathBasedRule
		}
		destination.PathBasedRules = pathBasedRuleList
	} else {
		destination.PathBasedRules = nil
	}

	// PolicySettings
	if policy.PolicySettings != nil {
		var policySetting storage.PolicySettings_STATUS
		err := policy.PolicySettings.AssignProperties_To_PolicySettings_STATUS(&policySetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PolicySettings_STATUS() to populate field PolicySettings")
		}
		destination.PolicySettings = &policySetting
	} else {
		destination.PolicySettings = nil
	}

	// ProvisioningState
	if policy.ProvisioningState != nil {
		provisioningState := string(*policy.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ResourceState
	if policy.ResourceState != nil {
		resourceState := string(*policy.ResourceState)
		destination.ResourceState = &resourceState
	} else {
		destination.ResourceState = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(policy.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(policy.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Application gateway resource.
type ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (embedded *ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (embedded *ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		embedded.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded populates our ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded from the provided source ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded
func (embedded *ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded) AssignProperties_From_ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded(source *storage.ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded) error {

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded populates the provided destination ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded from our ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded
func (embedded *ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded) AssignProperties_To_ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded(destination *storage.ApplicationGateway_STATUS_ApplicationGatewayWebApplicationFirewallPolicy_SubResourceEmbedded) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Allow to exclude some variable satisfy the condition for the WAF check.
type ManagedRulesDefinition struct {
	// Exclusions: The Exclusions that are applied on the policy.
	Exclusions []OwaspCrsExclusionEntry `json:"exclusions,omitempty"`

	// +kubebuilder:validation:Required
	// ManagedRuleSets: The managed rule sets that are associated with the policy.
	ManagedRuleSets []ManagedRuleSet `json:"managedRuleSets,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedRulesDefinition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (definition *ManagedRulesDefinition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if definition == nil {
		return nil, nil
	}
	result := &arm.ManagedRulesDefinition{}

	// Set property "Exclusions":
	for _, item := range definition.Exclusions {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Exclusions = append(result.Exclusions, *item_ARM.(*arm.OwaspCrsExclusionEntry))
	}

	// Set property "ManagedRuleSets":
	for _, item := range definition.ManagedRuleSets {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.ManagedRuleSets = append(result.ManagedRuleSets, *item_ARM.(*arm.ManagedRuleSet))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *ManagedRulesDefinition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedRulesDefinition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *ManagedRulesDefinition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedRulesDefinition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedRulesDefinition, got %T", armInput)
	}

	// Set property "Exclusions":
	for _, item := range typedInput.Exclusions {
		var item1 OwaspCrsExclusionEntry
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		definition.Exclusions = append(definition.Exclusions, item1)
	}

	// Set property "ManagedRuleSets":
	for _, item := range typedInput.ManagedRuleSets {
		var item1 ManagedRuleSet
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		definition.ManagedRuleSets = append(definition.ManagedRuleSets, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedRulesDefinition populates our ManagedRulesDefinition from the provided source ManagedRulesDefinition
func (definition *ManagedRulesDefinition) AssignProperties_From_ManagedRulesDefinition(source *storage.ManagedRulesDefinition) error {

	// Exclusions
	if source.Exclusions != nil {
		exclusionList := make([]OwaspCrsExclusionEntry, len(source.Exclusions))
		for exclusionIndex, exclusionItem := range source.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion OwaspCrsExclusionEntry
			err := exclusion.AssignProperties_From_OwaspCrsExclusionEntry(&exclusionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_OwaspCrsExclusionEntry() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		definition.Exclusions = exclusionList
	} else {
		definition.Exclusions = nil
	}

	// ManagedRuleSets
	if source.ManagedRuleSets != nil {
		managedRuleSetList := make([]ManagedRuleSet, len(source.ManagedRuleSets))
		for managedRuleSetIndex, managedRuleSetItem := range source.ManagedRuleSets {
			// Shadow the loop variable to avoid aliasing
			managedRuleSetItem := managedRuleSetItem
			var managedRuleSet ManagedRuleSet
			err := managedRuleSet.AssignProperties_From_ManagedRuleSet(&managedRuleSetItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedRuleSet() to populate field ManagedRuleSets")
			}
			managedRuleSetList[managedRuleSetIndex] = managedRuleSet
		}
		definition.ManagedRuleSets = managedRuleSetList
	} else {
		definition.ManagedRuleSets = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedRulesDefinition populates the provided destination ManagedRulesDefinition from our ManagedRulesDefinition
func (definition *ManagedRulesDefinition) AssignProperties_To_ManagedRulesDefinition(destination *storage.ManagedRulesDefinition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Exclusions
	if definition.Exclusions != nil {
		exclusionList := make([]storage.OwaspCrsExclusionEntry, len(definition.Exclusions))
		for exclusionIndex, exclusionItem := range definition.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion storage.OwaspCrsExclusionEntry
			err := exclusionItem.AssignProperties_To_OwaspCrsExclusionEntry(&exclusion)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_OwaspCrsExclusionEntry() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		destination.Exclusions = exclusionList
	} else {
		destination.Exclusions = nil
	}

	// ManagedRuleSets
	if definition.ManagedRuleSets != nil {
		managedRuleSetList := make([]storage.ManagedRuleSet, len(definition.ManagedRuleSets))
		for managedRuleSetIndex, managedRuleSetItem := range definition.ManagedRuleSets {
			// Shadow the loop variable to avoid aliasing
			managedRuleSetItem := managedRuleSetItem
			var managedRuleSet storage.ManagedRuleSet
			err := managedRuleSetItem.AssignProperties_To_ManagedRuleSet(&managedRuleSet)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedRuleSet() to populate field ManagedRuleSets")
			}
			managedRuleSetList[managedRuleSetIndex] = managedRuleSet
		}
		destination.ManagedRuleSets = managedRuleSetList
	} else {
		destination.ManagedRuleSets = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ManagedRulesDefinition_STATUS populates our ManagedRulesDefinition from the provided source ManagedRulesDefinition_STATUS
func (definition *ManagedRulesDefinition) Initialize_From_ManagedRulesDefinition_STATUS(source *ManagedRulesDefinition_STATUS) error {

	// Exclusions
	if source.Exclusions != nil {
		exclusionList := make([]OwaspCrsExclusionEntry, len(source.Exclusions))
		for exclusionIndex, exclusionItem := range source.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion OwaspCrsExclusionEntry
			err := exclusion.Initialize_From_OwaspCrsExclusionEntry_STATUS(&exclusionItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_OwaspCrsExclusionEntry_STATUS() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		definition.Exclusions = exclusionList
	} else {
		definition.Exclusions = nil
	}

	// ManagedRuleSets
	if source.ManagedRuleSets != nil {
		managedRuleSetList := make([]ManagedRuleSet, len(source.ManagedRuleSets))
		for managedRuleSetIndex, managedRuleSetItem := range source.ManagedRuleSets {
			// Shadow the loop variable to avoid aliasing
			managedRuleSetItem := managedRuleSetItem
			var managedRuleSet ManagedRuleSet
			err := managedRuleSet.Initialize_From_ManagedRuleSet_STATUS(&managedRuleSetItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ManagedRuleSet_STATUS() to populate field ManagedRuleSets")
			}
			managedRuleSetList[managedRuleSetIndex] = managedRuleSet
		}
		definition.ManagedRuleSets = managedRuleSetList
	} else {
		definition.ManagedRuleSets = nil
	}

	// No error
	return nil
}

// Allow to exclude some variable satisfy the condition for the WAF check.
type ManagedRulesDefinition_STATUS struct {
	// Exclusions: The Exclusions that are applied on the policy.
	Exclusions []OwaspCrsExclusionEntry_STATUS `json:"exclusions,omitempty"`

	// ManagedRuleSets: The managed rule sets that are associated with the policy.
	ManagedRuleSets []ManagedRuleSet_STATUS `json:"managedRuleSets,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedRulesDefinition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *ManagedRulesDefinition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedRulesDefinition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *ManagedRulesDefinition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedRulesDefinition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedRulesDefinition_STATUS, got %T", armInput)
	}

	// Set property "Exclusions":
	for _, item := range typedInput.Exclusions {
		var item1 OwaspCrsExclusionEntry_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		definition.Exclusions = append(definition.Exclusions, item1)
	}

	// Set property "ManagedRuleSets":
	for _, item := range typedInput.ManagedRuleSets {
		var item1 ManagedRuleSet_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		definition.ManagedRuleSets = append(definition.ManagedRuleSets, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedRulesDefinition_STATUS populates our ManagedRulesDefinition_STATUS from the provided source ManagedRulesDefinition_STATUS
func (definition *ManagedRulesDefinition_STATUS) AssignProperties_From_ManagedRulesDefinition_STATUS(source *storage.ManagedRulesDefinition_STATUS) error {

	// Exclusions
	if source.Exclusions != nil {
		exclusionList := make([]OwaspCrsExclusionEntry_STATUS, len(source.Exclusions))
		for exclusionIndex, exclusionItem := range source.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion OwaspCrsExclusionEntry_STATUS
			err := exclusion.AssignProperties_From_OwaspCrsExclusionEntry_STATUS(&exclusionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_OwaspCrsExclusionEntry_STATUS() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		definition.Exclusions = exclusionList
	} else {
		definition.Exclusions = nil
	}

	// ManagedRuleSets
	if source.ManagedRuleSets != nil {
		managedRuleSetList := make([]ManagedRuleSet_STATUS, len(source.ManagedRuleSets))
		for managedRuleSetIndex, managedRuleSetItem := range source.ManagedRuleSets {
			// Shadow the loop variable to avoid aliasing
			managedRuleSetItem := managedRuleSetItem
			var managedRuleSet ManagedRuleSet_STATUS
			err := managedRuleSet.AssignProperties_From_ManagedRuleSet_STATUS(&managedRuleSetItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedRuleSet_STATUS() to populate field ManagedRuleSets")
			}
			managedRuleSetList[managedRuleSetIndex] = managedRuleSet
		}
		definition.ManagedRuleSets = managedRuleSetList
	} else {
		definition.ManagedRuleSets = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedRulesDefinition_STATUS populates the provided destination ManagedRulesDefinition_STATUS from our ManagedRulesDefinition_STATUS
func (definition *ManagedRulesDefinition_STATUS) AssignProperties_To_ManagedRulesDefinition_STATUS(destination *storage.ManagedRulesDefinition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Exclusions
	if definition.Exclusions != nil {
		exclusionList := make([]storage.OwaspCrsExclusionEntry_STATUS, len(definition.Exclusions))
		for exclusionIndex, exclusionItem := range definition.Exclusions {
			// Shadow the loop variable to avoid aliasing
			exclusionItem := exclusionItem
			var exclusion storage.OwaspCrsExclusionEntry_STATUS
			err := exclusionItem.AssignProperties_To_OwaspCrsExclusionEntry_STATUS(&exclusion)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_OwaspCrsExclusionEntry_STATUS() to populate field Exclusions")
			}
			exclusionList[exclusionIndex] = exclusion
		}
		destination.Exclusions = exclusionList
	} else {
		destination.Exclusions = nil
	}

	// ManagedRuleSets
	if definition.ManagedRuleSets != nil {
		managedRuleSetList := make([]storage.ManagedRuleSet_STATUS, len(definition.ManagedRuleSets))
		for managedRuleSetIndex, managedRuleSetItem := range definition.ManagedRuleSets {
			// Shadow the loop variable to avoid aliasing
			managedRuleSetItem := managedRuleSetItem
			var managedRuleSet storage.ManagedRuleSet_STATUS
			err := managedRuleSetItem.AssignProperties_To_ManagedRuleSet_STATUS(&managedRuleSet)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedRuleSet_STATUS() to populate field ManagedRuleSets")
			}
			managedRuleSetList[managedRuleSetIndex] = managedRuleSet
		}
		destination.ManagedRuleSets = managedRuleSetList
	} else {
		destination.ManagedRuleSets = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines contents of a web application firewall global configuration.
type PolicySettings struct {
	// +kubebuilder:validation:MaxLength=32768
	// +kubebuilder:validation:Pattern="^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$"
	// CustomBlockResponseBody: If the action type is block, customer can override the response body. The body must be
	// specified in base64 encoding.
	CustomBlockResponseBody *string `json:"customBlockResponseBody,omitempty"`

	// +kubebuilder:validation:Minimum=0
	// CustomBlockResponseStatusCode: If the action type is block, customer can override the response status code.
	CustomBlockResponseStatusCode *int `json:"customBlockResponseStatusCode,omitempty"`

	// FileUploadEnforcement: Whether allow WAF to enforce file upload limits.
	FileUploadEnforcement *bool `json:"fileUploadEnforcement,omitempty"`

	// +kubebuilder:validation:Minimum=0
	// FileUploadLimitInMb: Maximum file upload size in Mb for WAF.
	FileUploadLimitInMb *int `json:"fileUploadLimitInMb,omitempty"`

	// +kubebuilder:validation:Maximum=1440
	// +kubebuilder:validation:Minimum=5
	// JsChallengeCookieExpirationInMins: Web Application Firewall JavaScript Challenge Cookie Expiration time in minutes.
	JsChallengeCookieExpirationInMins *int `json:"jsChallengeCookieExpirationInMins,omitempty"`

	// LogScrubbing: To scrub sensitive log fields
	LogScrubbing *PolicySettings_LogScrubbing `json:"logScrubbing,omitempty"`

	// +kubebuilder:validation:Minimum=8
	// MaxRequestBodySizeInKb: Maximum request body size in Kb for WAF.
	MaxRequestBodySizeInKb *int `json:"maxRequestBodySizeInKb,omitempty"`

	// Mode: The mode of the policy.
	Mode *PolicySettings_Mode `json:"mode,omitempty"`

	// RequestBodyCheck: Whether to allow WAF to check request Body.
	RequestBodyCheck *bool `json:"requestBodyCheck,omitempty"`

	// RequestBodyEnforcement: Whether allow WAF to enforce request body limits.
	RequestBodyEnforcement *bool `json:"requestBodyEnforcement,omitempty"`

	// RequestBodyInspectLimitInKB: Max inspection limit in KB for request body inspection for WAF.
	RequestBodyInspectLimitInKB *int `json:"requestBodyInspectLimitInKB,omitempty"`

	// State: The state of the policy.
	State *PolicySettings_State `json:"state,omitempty"`
}

var _ genruntime.ARMTransformer = &PolicySettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *PolicySettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.PolicySettings{}

	// Set property "CustomBlockResponseBody":
	if settings.CustomBlockResponseBody != nil {
		customBlockResponseBody := *settings.CustomBlockResponseBody
		result.CustomBlockResponseBody = &customBlockResponseBody
	}

	// Set property "CustomBlockResponseStatusCode":
	if settings.CustomBlockResponseStatusCode != nil {
		customBlockResponseStatusCode := *settings.CustomBlockResponseStatusCode
		result.CustomBlockResponseStatusCode = &customBlockResponseStatusCode
	}

	// Set property "FileUploadEnforcement":
	if settings.FileUploadEnforcement != nil {
		fileUploadEnforcement := *settings.FileUploadEnforcement
		result.FileUploadEnforcement = &fileUploadEnforcement
	}

	// Set property "FileUploadLimitInMb":
	if settings.FileUploadLimitInMb != nil {
		fileUploadLimitInMb := *settings.FileUploadLimitInMb
		result.FileUploadLimitInMb = &fileUploadLimitInMb
	}

	// Set property "JsChallengeCookieExpirationInMins":
	if settings.JsChallengeCookieExpirationInMins != nil {
		jsChallengeCookieExpirationInMins := *settings.JsChallengeCookieExpirationInMins
		result.JsChallengeCookieExpirationInMins = &jsChallengeCookieExpirationInMins
	}

	// Set property "LogScrubbing":
	if settings.LogScrubbing != nil {
		logScrubbing_ARM, err := (*settings.LogScrubbing).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		logScrubbing := *logScrubbing_ARM.(*arm.PolicySettings_LogScrubbing)
		result.LogScrubbing = &logScrubbing
	}

	// Set property "MaxRequestBodySizeInKb":
	if settings.MaxRequestBodySizeInKb != nil {
		maxRequestBodySizeInKb := *settings.MaxRequestBodySizeInKb
		result.MaxRequestBodySizeInKb = &maxRequestBodySizeInKb
	}

	// Set property "Mode":
	if settings.Mode != nil {
		var temp string
		temp = string(*settings.Mode)
		mode := arm.PolicySettings_Mode(temp)
		result.Mode = &mode
	}

	// Set property "RequestBodyCheck":
	if settings.RequestBodyCheck != nil {
		requestBodyCheck := *settings.RequestBodyCheck
		result.RequestBodyCheck = &requestBodyCheck
	}

	// Set property "RequestBodyEnforcement":
	if settings.RequestBodyEnforcement != nil {
		requestBodyEnforcement := *settings.RequestBodyEnforcement
		result.RequestBodyEnforcement = &requestBodyEnforcement
	}

	// Set property "RequestBodyInspectLimitInKB":
	if settings.RequestBodyInspectLimitInKB != nil {
		requestBodyInspectLimitInKB := *settings.RequestBodyInspectLimitInKB
		result.RequestBodyInspectLimitInKB = &requestBodyInspectLimitInKB
	}

	// Set property "State":
	if settings.State != nil {
		var temp string
		temp = string(*settings.State)
		state := arm.PolicySettings_State(temp)
		result.State = &state
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *PolicySettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PolicySettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *PolicySettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PolicySettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PolicySettings, got %T", armInput)
	}

	// Set property "CustomBlockResponseBody":
	if typedInput.CustomBlockResponseBody != nil {
		customBlockResponseBody := *typedInput.CustomBlockResponseBody
		settings.CustomBlockResponseBody = &customBlockResponseBody
	}

	// Set property "CustomBlockResponseStatusCode":
	if typedInput.CustomBlockResponseStatusCode != nil {
		customBlockResponseStatusCode := *typedInput.CustomBlockResponseStatusCode
		settings.CustomBlockResponseStatusCode = &customBlockResponseStatusCode
	}

	// Set property "FileUploadEnforcement":
	if typedInput.FileUploadEnforcement != nil {
		fileUploadEnforcement := *typedInput.FileUploadEnforcement
		settings.FileUploadEnforcement = &fileUploadEnforcement
	}

	// Set property "FileUploadLimitInMb":
	if typedInput.FileUploadLimitInMb != nil {
		fileUploadLimitInMb := *typedInput.FileUploadLimitInMb
		settings.FileUploadLimitInMb = &fileUploadLimitInMb
	}

	// Set property "JsChallengeCookieExpirationInMins":
	if typedInput.JsChallengeCookieExpirationInMins != nil {
		jsChallengeCookieExpirationInMins := *typedInput.JsChallengeCookieExpirationInMins
		settings.JsChallengeCookieExpirationInMins = &jsChallengeCookieExpirationInMins
	}

	// Set property "LogScrubbing":
	if typedInput.LogScrubbing != nil {
		var logScrubbing1 PolicySettings_LogScrubbing
		err := logScrubbing1.PopulateFromARM(owner, *typedInput.LogScrubbing)
		if err != nil {
			return err
		}
		logScrubbing := logScrubbing1
		settings.LogScrubbing = &logScrubbing
	}

	// Set property "MaxRequestBodySizeInKb":
	if typedInput.MaxRequestBodySizeInKb != nil {
		maxRequestBodySizeInKb := *typedInput.MaxRequestBodySizeInKb
		settings.MaxRequestBodySizeInKb = &maxRequestBodySizeInKb
	}

	// Set property "Mode":
	if typedInput.Mode != nil {
		var temp string
		temp = string(*typedInput.Mode)
		mode := PolicySettings_Mode(temp)
		settings.Mode = &mode
	}

	// Set property "RequestBodyCheck":
	if typedInput.RequestBodyCheck != nil {
		requestBodyCheck := *typedInput.RequestBodyCheck
		settings.RequestBodyCheck = &requestBodyCheck
	}

	// Set property "RequestBodyEnforcement":
	if typedInput.RequestBodyEnforcement != nil {
		requestBodyEnforcement := *typedInput.RequestBodyEnforcement
		settings.RequestBodyEnforcement = &requestBodyEnforcement
	}

	// Set property "RequestBodyInspectLimitInKB":
	if typedInput.RequestBodyInspectLimitInKB != nil {
		requestBodyInspectLimitInKB := *typedInput.RequestBodyInspectLimitInKB
		settings.RequestBodyInspectLimitInKB = &requestBodyInspectLimitInKB
	}

	// Set property "State":
	if typedInput.State != nil {
		var temp string
		temp = string(*typedInput.State)
		state := PolicySettings_State(temp)
		settings.State = &state
	}

	// No error
	return nil
}

// AssignProperties_From_PolicySettings populates our PolicySettings from the provided source PolicySettings
func (settings *PolicySettings) AssignProperties_From_PolicySettings(source *storage.PolicySettings) error {

	// CustomBlockResponseBody
	if source.CustomBlockResponseBody != nil {
		customBlockResponseBody := *source.CustomBlockResponseBody
		settings.CustomBlockResponseBody = &customBlockResponseBody
	} else {
		settings.CustomBlockResponseBody = nil
	}

	// CustomBlockResponseStatusCode
	if source.CustomBlockResponseStatusCode != nil {
		customBlockResponseStatusCode := *source.CustomBlockResponseStatusCode
		settings.CustomBlockResponseStatusCode = &customBlockResponseStatusCode
	} else {
		settings.CustomBlockResponseStatusCode = nil
	}

	// FileUploadEnforcement
	if source.FileUploadEnforcement != nil {
		fileUploadEnforcement := *source.FileUploadEnforcement
		settings.FileUploadEnforcement = &fileUploadEnforcement
	} else {
		settings.FileUploadEnforcement = nil
	}

	// FileUploadLimitInMb
	if source.FileUploadLimitInMb != nil {
		fileUploadLimitInMb := *source.FileUploadLimitInMb
		settings.FileUploadLimitInMb = &fileUploadLimitInMb
	} else {
		settings.FileUploadLimitInMb = nil
	}

	// JsChallengeCookieExpirationInMins
	if source.JsChallengeCookieExpirationInMins != nil {
		jsChallengeCookieExpirationInMin := *source.JsChallengeCookieExpirationInMins
		settings.JsChallengeCookieExpirationInMins = &jsChallengeCookieExpirationInMin
	} else {
		settings.JsChallengeCookieExpirationInMins = nil
	}

	// LogScrubbing
	if source.LogScrubbing != nil {
		var logScrubbing PolicySettings_LogScrubbing
		err := logScrubbing.AssignProperties_From_PolicySettings_LogScrubbing(source.LogScrubbing)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PolicySettings_LogScrubbing() to populate field LogScrubbing")
		}
		settings.LogScrubbing = &logScrubbing
	} else {
		settings.LogScrubbing = nil
	}

	// MaxRequestBodySizeInKb
	if source.MaxRequestBodySizeInKb != nil {
		maxRequestBodySizeInKb := *source.MaxRequestBodySizeInKb
		settings.MaxRequestBodySizeInKb = &maxRequestBodySizeInKb
	} else {
		settings.MaxRequestBodySizeInKb = nil
	}

	// Mode
	if source.Mode != nil {
		mode := *source.Mode
		modeTemp := genruntime.ToEnum(mode, policySettings_Mode_Values)
		settings.Mode = &modeTemp
	} else {
		settings.Mode = nil
	}

	// RequestBodyCheck
	if source.RequestBodyCheck != nil {
		requestBodyCheck := *source.RequestBodyCheck
		settings.RequestBodyCheck = &requestBodyCheck
	} else {
		settings.RequestBodyCheck = nil
	}

	// RequestBodyEnforcement
	if source.RequestBodyEnforcement != nil {
		requestBodyEnforcement := *source.RequestBodyEnforcement
		settings.RequestBodyEnforcement = &requestBodyEnforcement
	} else {
		settings.RequestBodyEnforcement = nil
	}

	// RequestBodyInspectLimitInKB
	settings.RequestBodyInspectLimitInKB = genruntime.ClonePointerToInt(source.RequestBodyInspectLimitInKB)

	// State
	if source.State != nil {
		state := *source.State
		stateTemp := genruntime.ToEnum(state, policySettings_State_Values)
		settings.State = &stateTemp
	} else {
		settings.State = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PolicySettings populates the provided destination PolicySettings from our PolicySettings
func (settings *PolicySettings) AssignProperties_To_PolicySettings(destination *storage.PolicySettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CustomBlockResponseBody
	if settings.CustomBlockResponseBody != nil {
		customBlockResponseBody := *settings.CustomBlockResponseBody
		destination.CustomBlockResponseBody = &customBlockResponseBody
	} else {
		destination.CustomBlockResponseBody = nil
	}

	// CustomBlockResponseStatusCode
	if settings.CustomBlockResponseStatusCode != nil {
		customBlockResponseStatusCode := *settings.CustomBlockResponseStatusCode
		destination.CustomBlockResponseStatusCode = &customBlockResponseStatusCode
	} else {
		destination.CustomBlockResponseStatusCode = nil
	}

	// FileUploadEnforcement
	if settings.FileUploadEnforcement != nil {
		fileUploadEnforcement := *settings.FileUploadEnforcement
		destination.FileUploadEnforcement = &fileUploadEnforcement
	} else {
		destination.FileUploadEnforcement = nil
	}

	// FileUploadLimitInMb
	if settings.FileUploadLimitInMb != nil {
		fileUploadLimitInMb := *settings.FileUploadLimitInMb
		destination.FileUploadLimitInMb = &fileUploadLimitInMb
	} else {
		destination.FileUploadLimitInMb = nil
	}

	// JsChallengeCookieExpirationInMins
	if settings.JsChallengeCookieExpirationInMins != nil {
		jsChallengeCookieExpirationInMin := *settings.JsChallengeCookieExpirationInMins
		destination.JsChallengeCookieExpirationInMins = &jsChallengeCookieExpirationInMin
	} else {
		destination.JsChallengeCookieExpirationInMins = nil
	}

	// LogScrubbing
	if settings.LogScrubbing != nil {
		var logScrubbing storage.PolicySettings_LogScrubbing
		err := settings.LogScrubbing.AssignProperties_To_PolicySettings_LogScrubbing(&logScrubbing)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PolicySettings_LogScrubbing() to populate field LogScrubbing")
		}
		destination.LogScrubbing = &logScrubbing
	} else {
		destination.LogScrubbing = nil
	}

	// MaxRequestBodySizeInKb
	if settings.MaxRequestBodySizeInKb != nil {
		maxRequestBodySizeInKb := *settings.MaxRequestBodySizeInKb
		destination.MaxRequestBodySizeInKb = &maxRequestBodySizeInKb
	} else {
		destination.MaxRequestBodySizeInKb = nil
	}

	// Mode
	if settings.Mode != nil {
		mode := string(*settings.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// RequestBodyCheck
	if settings.RequestBodyCheck != nil {
		requestBodyCheck := *settings.RequestBodyCheck
		destination.RequestBodyCheck = &requestBodyCheck
	} else {
		destination.RequestBodyCheck = nil
	}

	// RequestBodyEnforcement
	if settings.RequestBodyEnforcement != nil {
		requestBodyEnforcement := *settings.RequestBodyEnforcement
		destination.RequestBodyEnforcement = &requestBodyEnforcement
	} else {
		destination.RequestBodyEnforcement = nil
	}

	// RequestBodyInspectLimitInKB
	destination.RequestBodyInspectLimitInKB = genruntime.ClonePointerToInt(settings.RequestBodyInspectLimitInKB)

	// State
	if settings.State != nil {
		state := string(*settings.State)
		destination.State = &state
	} else {
		destination.State = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_PolicySettings_STATUS populates our PolicySettings from the provided source PolicySettings_STATUS
func (settings *PolicySettings) Initialize_From_PolicySettings_STATUS(source *PolicySettings_STATUS) error {

	// CustomBlockResponseBody
	if source.CustomBlockResponseBody != nil {
		customBlockResponseBody := *source.CustomBlockResponseBody
		settings.CustomBlockResponseBody = &customBlockResponseBody
	} else {
		settings.CustomBlockResponseBody = nil
	}

	// CustomBlockResponseStatusCode
	if source.CustomBlockResponseStatusCode != nil {
		customBlockResponseStatusCode := *source.CustomBlockResponseStatusCode
		settings.CustomBlockResponseStatusCode = &customBlockResponseStatusCode
	} else {
		settings.CustomBlockResponseStatusCode = nil
	}

	// FileUploadEnforcement
	if source.FileUploadEnforcement != nil {
		fileUploadEnforcement := *source.FileUploadEnforcement
		settings.FileUploadEnforcement = &fileUploadEnforcement
	} else {
		settings.FileUploadEnforcement = nil
	}

	// FileUploadLimitInMb
	if source.FileUploadLimitInMb != nil {
		fileUploadLimitInMb := *source.FileUploadLimitInMb
		settings.FileUploadLimitInMb = &fileUploadLimitInMb
	} else {
		settings.FileUploadLimitInMb = nil
	}

	// JsChallengeCookieExpirationInMins
	if source.JsChallengeCookieExpirationInMins != nil {
		jsChallengeCookieExpirationInMin := *source.JsChallengeCookieExpirationInMins
		settings.JsChallengeCookieExpirationInMins = &jsChallengeCookieExpirationInMin
	} else {
		settings.JsChallengeCookieExpirationInMins = nil
	}

	// LogScrubbing
	if source.LogScrubbing != nil {
		var logScrubbing PolicySettings_LogScrubbing
		err := logScrubbing.Initialize_From_PolicySettings_LogScrubbing_STATUS(source.LogScrubbing)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_PolicySettings_LogScrubbing_STATUS() to populate field LogScrubbing")
		}
		settings.LogScrubbing = &logScrubbing
	} else {
		settings.LogScrubbing = nil
	}

	// MaxRequestBodySizeInKb
	if source.MaxRequestBodySizeInKb != nil {
		maxRequestBodySizeInKb := *source.MaxRequestBodySizeInKb
		settings.MaxRequestBodySizeInKb = &maxRequestBodySizeInKb
	} else {
		settings.MaxRequestBodySizeInKb = nil
	}

	// Mode
	if source.Mode != nil {
		mode := genruntime.ToEnum(string(*source.Mode), policySettings_Mode_Values)
		settings.Mode = &mode
	} else {
		settings.Mode = nil
	}

	// RequestBodyCheck
	if source.RequestBodyCheck != nil {
		requestBodyCheck := *source.RequestBodyCheck
		settings.RequestBodyCheck = &requestBodyCheck
	} else {
		settings.RequestBodyCheck = nil
	}

	// RequestBodyEnforcement
	if source.RequestBodyEnforcement != nil {
		requestBodyEnforcement := *source.RequestBodyEnforcement
		settings.RequestBodyEnforcement = &requestBodyEnforcement
	} else {
		settings.RequestBodyEnforcement = nil
	}

	// RequestBodyInspectLimitInKB
	settings.RequestBodyInspectLimitInKB = genruntime.ClonePointerToInt(source.RequestBodyInspectLimitInKB)

	// State
	if source.State != nil {
		state := genruntime.ToEnum(string(*source.State), policySettings_State_Values)
		settings.State = &state
	} else {
		settings.State = nil
	}

	// No error
	return nil
}

// Defines contents of a web application firewall global configuration.
type PolicySettings_STATUS struct {
	// CustomBlockResponseBody: If the action type is block, customer can override the response body. The body must be
	// specified in base64 encoding.
	CustomBlockResponseBody *string `json:"customBlockResponseBody,omitempty"`

	// CustomBlockResponseStatusCode: If the action type is block, customer can override the response status code.
	CustomBlockResponseStatusCode *int `json:"customBlockResponseStatusCode,omitempty"`

	// FileUploadEnforcement: Whether allow WAF to enforce file upload limits.
	FileUploadEnforcement *bool `json:"fileUploadEnforcement,omitempty"`

	// FileUploadLimitInMb: Maximum file upload size in Mb for WAF.
	FileUploadLimitInMb *int `json:"fileUploadLimitInMb,omitempty"`

	// JsChallengeCookieExpirationInMins: Web Application Firewall JavaScript Challenge Cookie Expiration time in minutes.
	JsChallengeCookieExpirationInMins *int `json:"jsChallengeCookieExpirationInMins,omitempty"`

	// LogScrubbing: To scrub sensitive log fields
	LogScrubbing *PolicySettings_LogScrubbing_STATUS `json:"logScrubbing,omitempty"`

	// MaxRequestBodySizeInKb: Maximum request body size in Kb for WAF.
	MaxRequestBodySizeInKb *int `json:"maxRequestBodySizeInKb,omitempty"`

	// Mode: The mode of the policy.
	Mode *PolicySettings_Mode_STATUS `json:"mode,omitempty"`

	// RequestBodyCheck: Whether to allow WAF to check request Body.
	RequestBodyCheck *bool `json:"requestBodyCheck,omitempty"`

	// RequestBodyEnforcement: Whether allow WAF to enforce request body limits.
	RequestBodyEnforcement *bool `json:"requestBodyEnforcement,omitempty"`

	// RequestBodyInspectLimitInKB: Max inspection limit in KB for request body inspection for WAF.
	RequestBodyInspectLimitInKB *int `json:"requestBodyInspectLimitInKB,omitempty"`

	// State: The state of the policy.
	State *PolicySettings_State_STATUS `json:"state,omitempty"`
}

var _ genruntime.FromARMConverter = &PolicySettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *PolicySettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PolicySettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *PolicySettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PolicySettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PolicySettings_STATUS, got %T", armInput)
	}

	// Set property "CustomBlockResponseBody":
	if typedInput.CustomBlockResponseBody != nil {
		customBlockResponseBody := *typedInput.CustomBlockResponseBody
		settings.CustomBlockResponseBody = &customBlockResponseBody
	}

	// Set property "CustomBlockResponseStatusCode":
	if typedInput.CustomBlockResponseStatusCode != nil {
		customBlockResponseStatusCode := *typedInput.CustomBlockResponseStatusCode
		settings.CustomBlockResponseStatusCode = &customBlockResponseStatusCode
	}

	// Set property "FileUploadEnforcement":
	if typedInput.FileUploadEnforcement != nil {
		fileUploadEnforcement := *typedInput.FileUploadEnforcement
		settings.FileUploadEnforcement = &fileUploadEnforcement
	}

	// Set property "FileUploadLimitInMb":
	if typedInput.FileUploadLimitInMb != nil {
		fileUploadLimitInMb := *typedInput.FileUploadLimitInMb
		settings.FileUploadLimitInMb = &fileUploadLimitInMb
	}

	// Set property "JsChallengeCookieExpirationInMins":
	if typedInput.JsChallengeCookieExpirationInMins != nil {
		jsChallengeCookieExpirationInMins := *typedInput.JsChallengeCookieExpirationInMins
		settings.JsChallengeCookieExpirationInMins = &jsChallengeCookieExpirationInMins
	}

	// Set property "LogScrubbing":
	if typedInput.LogScrubbing != nil {
		var logScrubbing1 PolicySettings_LogScrubbing_STATUS
		err := logScrubbing1.PopulateFromARM(owner, *typedInput.LogScrubbing)
		if err != nil {
			return err
		}
		logScrubbing := logScrubbing1
		settings.LogScrubbing = &logScrubbing
	}

	// Set property "MaxRequestBodySizeInKb":
	if typedInput.MaxRequestBodySizeInKb != nil {
		maxRequestBodySizeInKb := *typedInput.MaxRequestBodySizeInKb
		settings.MaxRequestBodySizeInKb = &maxRequestBodySizeInKb
	}

	// Set property "Mode":
	if typedInput.Mode != nil {
		var temp string
		temp = string(*typedInput.Mode)
		mode := PolicySettings_Mode_STATUS(temp)
		settings.Mode = &mode
	}

	// Set property "RequestBodyCheck":
	if typedInput.RequestBodyCheck != nil {
		requestBodyCheck := *typedInput.RequestBodyCheck
		settings.RequestBodyCheck = &requestBodyCheck
	}

	// Set property "RequestBodyEnforcement":
	if typedInput.RequestBodyEnforcement != nil {
		requestBodyEnforcement := *typedInput.RequestBodyEnforcement
		settings.RequestBodyEnforcement = &requestBodyEnforcement
	}

	// Set property "RequestBodyInspectLimitInKB":
	if typedInput.RequestBodyInspectLimitInKB != nil {
		requestBodyInspectLimitInKB := *typedInput.RequestBodyInspectLimitInKB
		settings.RequestBodyInspectLimitInKB = &requestBodyInspectLimitInKB
	}

	// Set property "State":
	if typedInput.State != nil {
		var temp string
		temp = string(*typedInput.State)
		state := PolicySettings_State_STATUS(temp)
		settings.State = &state
	}

	// No error
	return nil
}

// AssignProperties_From_PolicySettings_STATUS populates our PolicySettings_STATUS from the provided source PolicySettings_STATUS
func (settings *PolicySettings_STATUS) AssignProperties_From_PolicySettings_STATUS(source *storage.PolicySettings_STATUS) error {

	// CustomBlockResponseBody
	settings.CustomBlockResponseBody = genruntime.ClonePointerToString(source.CustomBlockResponseBody)

	// CustomBlockResponseStatusCode
	settings.CustomBlockResponseStatusCode = genruntime.ClonePointerToInt(source.CustomBlockResponseStatusCode)

	// FileUploadEnforcement
	if source.FileUploadEnforcement != nil {
		fileUploadEnforcement := *source.FileUploadEnforcement
		settings.FileUploadEnforcement = &fileUploadEnforcement
	} else {
		settings.FileUploadEnforcement = nil
	}

	// FileUploadLimitInMb
	settings.FileUploadLimitInMb = genruntime.ClonePointerToInt(source.FileUploadLimitInMb)

	// JsChallengeCookieExpirationInMins
	settings.JsChallengeCookieExpirationInMins = genruntime.ClonePointerToInt(source.JsChallengeCookieExpirationInMins)

	// LogScrubbing
	if source.LogScrubbing != nil {
		var logScrubbing PolicySettings_LogScrubbing_STATUS
		err := logScrubbing.AssignProperties_From_PolicySettings_LogScrubbing_STATUS(source.LogScrubbing)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PolicySettings_LogScrubbing_STATUS() to populate field LogScrubbing")
		}
		settings.LogScrubbing = &logScrubbing
	} else {
		settings.LogScrubbing = nil
	}

	// MaxRequestBodySizeInKb
	settings.MaxRequestBodySizeInKb = genruntime.ClonePointerToInt(source.MaxRequestBodySizeInKb)

	// Mode
	if source.Mode != nil {
		mode := *source.Mode
		modeTemp := genruntime.ToEnum(mode, policySettings_Mode_STATUS_Values)
		settings.Mode = &modeTemp
	} else {
		settings.Mode = nil
	}

	// RequestBodyCheck
	if source.RequestBodyCheck != nil {
		requestBodyCheck := *source.RequestBodyCheck
		settings.RequestBodyCheck = &requestBodyCheck
	} else {
		settings.RequestBodyCheck = nil
	}

	// RequestBodyEnforcement
	if source.RequestBodyEnforcement != nil {
		requestBodyEnforcement := *source.RequestBodyEnforcement
		settings.RequestBodyEnforcement = &requestBodyEnforcement
	} else {
		settings.RequestBodyEnforcement = nil
	}

	// RequestBodyInspectLimitInKB
	settings.RequestBodyInspectLimitInKB = genruntime.ClonePointerToInt(source.RequestBodyInspectLimitInKB)

	// State
	if source.State != nil {
		state := *source.State
		stateTemp := genruntime.ToEnum(state, policySettings_State_STATUS_Values)
		settings.State = &stateTemp
	} else {
		settings.State = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PolicySettings_STATUS populates the provided destination PolicySettings_STATUS from our PolicySettings_STATUS
func (settings *PolicySettings_STATUS) AssignProperties_To_PolicySettings_STATUS(destination *storage.PolicySettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CustomBlockResponseBody
	destination.CustomBlockResponseBody = genruntime.ClonePointerToString(settings.CustomBlockResponseBody)

	// CustomBlockResponseStatusCode
	destination.CustomBlockResponseStatusCode = genruntime.ClonePointerToInt(settings.CustomBlockResponseStatusCode)

	// FileUploadEnforcement
	if settings.FileUploadEnforcement != nil {
		fileUploadEnforcement := *settings.FileUploadEnforcement
		destination.FileUploadEnforcement = &fileUploadEnforcement
	} else {
		destination.FileUploadEnforcement = nil
	}

	// FileUploadLimitInMb
	destination.FileUploadLimitInMb = genruntime.ClonePointerToInt(settings.FileUploadLimitInMb)

	// JsChallengeCookieExpirationInMins
	destination.JsChallengeCookieExpirationInMins = genruntime.ClonePointerToInt(settings.JsChallengeCookieExpirationInMins)

	// LogScrubbing
	if settings.LogScrubbing != nil {
		var logScrubbing storage.PolicySettings_LogScrubbing_STATUS
		err := settings.LogScrubbing.AssignProperties_To_PolicySettings_LogScrubbing_STATUS(&logScrubbing)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PolicySettings_LogScrubbing_STATUS() to populate field LogScrubbing")
		}
		destination.LogScrubbing = &logScrubbing
	} else {
		destination.LogScrubbing = nil
	}

	// MaxRequestBodySizeInKb
	destination.MaxRequestBodySizeInKb = genruntime.ClonePointerToInt(settings.MaxRequestBodySizeInKb)

	// Mode
	if settings.Mode != nil {
		mode := string(*settings.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// RequestBodyCheck
	if settings.RequestBodyCheck != nil {
		requestBodyCheck := *settings.RequestBodyCheck
		destination.RequestBodyCheck = &requestBodyCheck
	} else {
		destination.RequestBodyCheck = nil
	}

	// RequestBodyEnforcement
	if settings.RequestBodyEnforcement != nil {
		requestBodyEnforcement := *settings.RequestBodyEnforcement
		destination.RequestBodyEnforcement = &requestBodyEnforcement
	} else {
		destination.RequestBodyEnforcement = nil
	}

	// RequestBodyInspectLimitInKB
	destination.RequestBodyInspectLimitInKB = genruntime.ClonePointerToInt(settings.RequestBodyInspectLimitInKB)

	// State
	if settings.State != nil {
		state := string(*settings.State)
		destination.State = &state
	} else {
		destination.State = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Reference to another subresource.
type SubResource_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &SubResource_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *SubResource_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SubResource_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *SubResource_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SubResource_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SubResource_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		resource.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_SubResource_STATUS populates our SubResource_STATUS from the provided source SubResource_STATUS
func (resource *SubResource_STATUS) AssignProperties_From_SubResource_STATUS(source *storage.SubResource_STATUS) error {

	// Id
	resource.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_SubResource_STATUS populates the provided destination SubResource_STATUS from our SubResource_STATUS
func (resource *SubResource_STATUS) AssignProperties_To_SubResource_STATUS(destination *storage.SubResource_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(resource.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines contents of a web application rule.
type WebApplicationFirewallCustomRule struct {
	// +kubebuilder:validation:Required
	// Action: Type of Actions.
	Action *WebApplicationFirewallCustomRule_Action `json:"action,omitempty"`

	// GroupByUserSession: List of user session identifier group by clauses.
	GroupByUserSession []GroupByUserSession `json:"groupByUserSession,omitempty"`

	// +kubebuilder:validation:Required
	// MatchConditions: List of match conditions.
	MatchConditions []MatchCondition `json:"matchConditions,omitempty"`

	// +kubebuilder:validation:MaxLength=128
	// Name: The name of the resource that is unique within a policy. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Priority: Priority of the rule. Rules with a lower value will be evaluated before rules with a higher value.
	Priority *int `json:"priority,omitempty"`

	// RateLimitDuration: Duration over which Rate Limit policy will be applied. Applies only when ruleType is RateLimitRule.
	RateLimitDuration *WebApplicationFirewallCustomRule_RateLimitDuration `json:"rateLimitDuration,omitempty"`

	// RateLimitThreshold: Rate Limit threshold to apply in case ruleType is RateLimitRule. Must be greater than or equal to 1
	RateLimitThreshold *int `json:"rateLimitThreshold,omitempty"`

	// +kubebuilder:validation:Required
	// RuleType: The rule type.
	RuleType *WebApplicationFirewallCustomRule_RuleType `json:"ruleType,omitempty"`

	// State: Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not specified.
	State *WebApplicationFirewallCustomRule_State `json:"state,omitempty"`
}

var _ genruntime.ARMTransformer = &WebApplicationFirewallCustomRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *WebApplicationFirewallCustomRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.WebApplicationFirewallCustomRule{}

	// Set property "Action":
	if rule.Action != nil {
		var temp string
		temp = string(*rule.Action)
		action := arm.WebApplicationFirewallCustomRule_Action(temp)
		result.Action = &action
	}

	// Set property "GroupByUserSession":
	for _, item := range rule.GroupByUserSession {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.GroupByUserSession = append(result.GroupByUserSession, *item_ARM.(*arm.GroupByUserSession))
	}

	// Set property "MatchConditions":
	for _, item := range rule.MatchConditions {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.MatchConditions = append(result.MatchConditions, *item_ARM.(*arm.MatchCondition))
	}

	// Set property "Name":
	if rule.Name != nil {
		name := *rule.Name
		result.Name = &name
	}

	// Set property "Priority":
	if rule.Priority != nil {
		priority := *rule.Priority
		result.Priority = &priority
	}

	// Set property "RateLimitDuration":
	if rule.RateLimitDuration != nil {
		var temp string
		temp = string(*rule.RateLimitDuration)
		rateLimitDuration := arm.WebApplicationFirewallCustomRule_RateLimitDuration(temp)
		result.RateLimitDuration = &rateLimitDuration
	}

	// Set property "RateLimitThreshold":
	if rule.RateLimitThreshold != nil {
		rateLimitThreshold := *rule.RateLimitThreshold
		result.RateLimitThreshold = &rateLimitThreshold
	}

	// Set property "RuleType":
	if rule.RuleType != nil {
		var temp string
		temp = string(*rule.RuleType)
		ruleType := arm.WebApplicationFirewallCustomRule_RuleType(temp)
		result.RuleType = &ruleType
	}

	// Set property "State":
	if rule.State != nil {
		var temp string
		temp = string(*rule.State)
		state := arm.WebApplicationFirewallCustomRule_State(temp)
		result.State = &state
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *WebApplicationFirewallCustomRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WebApplicationFirewallCustomRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *WebApplicationFirewallCustomRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WebApplicationFirewallCustomRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WebApplicationFirewallCustomRule, got %T", armInput)
	}

	// Set property "Action":
	if typedInput.Action != nil {
		var temp string
		temp = string(*typedInput.Action)
		action := WebApplicationFirewallCustomRule_Action(temp)
		rule.Action = &action
	}

	// Set property "GroupByUserSession":
	for _, item := range typedInput.GroupByUserSession {
		var item1 GroupByUserSession
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		rule.GroupByUserSession = append(rule.GroupByUserSession, item1)
	}

	// Set property "MatchConditions":
	for _, item := range typedInput.MatchConditions {
		var item1 MatchCondition
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		rule.MatchConditions = append(rule.MatchConditions, item1)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property "Priority":
	if typedInput.Priority != nil {
		priority := *typedInput.Priority
		rule.Priority = &priority
	}

	// Set property "RateLimitDuration":
	if typedInput.RateLimitDuration != nil {
		var temp string
		temp = string(*typedInput.RateLimitDuration)
		rateLimitDuration := WebApplicationFirewallCustomRule_RateLimitDuration(temp)
		rule.RateLimitDuration = &rateLimitDuration
	}

	// Set property "RateLimitThreshold":
	if typedInput.RateLimitThreshold != nil {
		rateLimitThreshold := *typedInput.RateLimitThreshold
		rule.RateLimitThreshold = &rateLimitThreshold
	}

	// Set property "RuleType":
	if typedInput.RuleType != nil {
		var temp string
		temp = string(*typedInput.RuleType)
		ruleType := WebApplicationFirewallCustomRule_RuleType(temp)
		rule.RuleType = &ruleType
	}

	// Set property "State":
	if typedInput.State != nil {
		var temp string
		temp = string(*typedInput.State)
		state := WebApplicationFirewallCustomRule_State(temp)
		rule.State = &state
	}

	// No error
	return nil
}

// AssignProperties_From_WebApplicationFirewallCustomRule populates our WebApplicationFirewallCustomRule from the provided source WebApplicationFirewallCustomRule
func (rule *WebApplicationFirewallCustomRule) AssignProperties_From_WebApplicationFirewallCustomRule(source *storage.WebApplicationFirewallCustomRule) error {

	// Action
	if source.Action != nil {
		action := *source.Action
		actionTemp := genruntime.ToEnum(action, webApplicationFirewallCustomRule_Action_Values)
		rule.Action = &actionTemp
	} else {
		rule.Action = nil
	}

	// GroupByUserSession
	if source.GroupByUserSession != nil {
		groupByUserSessionList := make([]GroupByUserSession, len(source.GroupByUserSession))
		for groupByUserSessionIndex, groupByUserSessionItem := range source.GroupByUserSession {
			// Shadow the loop variable to avoid aliasing
			groupByUserSessionItem := groupByUserSessionItem
			var groupByUserSession GroupByUserSession
			err := groupByUserSession.AssignProperties_From_GroupByUserSession(&groupByUserSessionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_GroupByUserSession() to populate field GroupByUserSession")
			}
			groupByUserSessionList[groupByUserSessionIndex] = groupByUserSession
		}
		rule.GroupByUserSession = groupByUserSessionList
	} else {
		rule.GroupByUserSession = nil
	}

	// MatchConditions
	if source.MatchConditions != nil {
		matchConditionList := make([]MatchCondition, len(source.MatchConditions))
		for matchConditionIndex, matchConditionItem := range source.MatchConditions {
			// Shadow the loop variable to avoid aliasing
			matchConditionItem := matchConditionItem
			var matchCondition MatchCondition
			err := matchCondition.AssignProperties_From_MatchCondition(&matchConditionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_MatchCondition() to populate field MatchConditions")
			}
			matchConditionList[matchConditionIndex] = matchCondition
		}
		rule.MatchConditions = matchConditionList
	} else {
		rule.MatchConditions = nil
	}

	// Name
	if source.Name != nil {
		name := *source.Name
		rule.Name = &name
	} else {
		rule.Name = nil
	}

	// Priority
	rule.Priority = genruntime.ClonePointerToInt(source.Priority)

	// RateLimitDuration
	if source.RateLimitDuration != nil {
		rateLimitDuration := *source.RateLimitDuration
		rateLimitDurationTemp := genruntime.ToEnum(rateLimitDuration, webApplicationFirewallCustomRule_RateLimitDuration_Values)
		rule.RateLimitDuration = &rateLimitDurationTemp
	} else {
		rule.RateLimitDuration = nil
	}

	// RateLimitThreshold
	rule.RateLimitThreshold = genruntime.ClonePointerToInt(source.RateLimitThreshold)

	// RuleType
	if source.RuleType != nil {
		ruleType := *source.RuleType
		ruleTypeTemp := genruntime.ToEnum(ruleType, webApplicationFirewallCustomRule_RuleType_Values)
		rule.RuleType = &ruleTypeTemp
	} else {
		rule.RuleType = nil
	}

	// State
	if source.State != nil {
		state := *source.State
		stateTemp := genruntime.ToEnum(state, webApplicationFirewallCustomRule_State_Values)
		rule.State = &stateTemp
	} else {
		rule.State = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WebApplicationFirewallCustomRule populates the provided destination WebApplicationFirewallCustomRule from our WebApplicationFirewallCustomRule
func (rule *WebApplicationFirewallCustomRule) AssignProperties_To_WebApplicationFirewallCustomRule(destination *storage.WebApplicationFirewallCustomRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	if rule.Action != nil {
		action := string(*rule.Action)
		destination.Action = &action
	} else {
		destination.Action = nil
	}

	// GroupByUserSession
	if rule.GroupByUserSession != nil {
		groupByUserSessionList := make([]storage.GroupByUserSession, len(rule.GroupByUserSession))
		for groupByUserSessionIndex, groupByUserSessionItem := range rule.GroupByUserSession {
			// Shadow the loop variable to avoid aliasing
			groupByUserSessionItem := groupByUserSessionItem
			var groupByUserSession storage.GroupByUserSession
			err := groupByUserSessionItem.AssignProperties_To_GroupByUserSession(&groupByUserSession)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_GroupByUserSession() to populate field GroupByUserSession")
			}
			groupByUserSessionList[groupByUserSessionIndex] = groupByUserSession
		}
		destination.GroupByUserSession = groupByUserSessionList
	} else {
		destination.GroupByUserSession = nil
	}

	// MatchConditions
	if rule.MatchConditions != nil {
		matchConditionList := make([]storage.MatchCondition, len(rule.MatchConditions))
		for matchConditionIndex, matchConditionItem := range rule.MatchConditions {
			// Shadow the loop variable to avoid aliasing
			matchConditionItem := matchConditionItem
			var matchCondition storage.MatchCondition
			err := matchConditionItem.AssignProperties_To_MatchCondition(&matchCondition)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_MatchCondition() to populate field MatchConditions")
			}
			matchConditionList[matchConditionIndex] = matchCondition
		}
		destination.MatchConditions = matchConditionList
	} else {
		destination.MatchConditions = nil
	}

	// Name
	if rule.Name != nil {
		name := *rule.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Priority
	destination.Priority = genruntime.ClonePointerToInt(rule.Priority)

	// RateLimitDuration
	if rule.RateLimitDuration != nil {
		rateLimitDuration := string(*rule.RateLimitDuration)
		destination.RateLimitDuration = &rateLimitDuration
	} else {
		destination.RateLimitDuration = nil
	}

	// RateLimitThreshold
	destination.RateLimitThreshold = genruntime.ClonePointerToInt(rule.RateLimitThreshold)

	// RuleType
	if rule.RuleType != nil {
		ruleType := string(*rule.RuleType)
		destination.RuleType = &ruleType
	} else {
		destination.RuleType = nil
	}

	// State
	if rule.State != nil {
		state := string(*rule.State)
		destination.State = &state
	} else {
		destination.State = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_WebApplicationFirewallCustomRule_STATUS populates our WebApplicationFirewallCustomRule from the provided source WebApplicationFirewallCustomRule_STATUS
func (rule *WebApplicationFirewallCustomRule) Initialize_From_WebApplicationFirewallCustomRule_STATUS(source *WebApplicationFirewallCustomRule_STATUS) error {

	// Action
	if source.Action != nil {
		action := genruntime.ToEnum(string(*source.Action), webApplicationFirewallCustomRule_Action_Values)
		rule.Action = &action
	} else {
		rule.Action = nil
	}

	// GroupByUserSession
	if source.GroupByUserSession != nil {
		groupByUserSessionList := make([]GroupByUserSession, len(source.GroupByUserSession))
		for groupByUserSessionIndex, groupByUserSessionItem := range source.GroupByUserSession {
			// Shadow the loop variable to avoid aliasing
			groupByUserSessionItem := groupByUserSessionItem
			var groupByUserSession GroupByUserSession
			err := groupByUserSession.Initialize_From_GroupByUserSession_STATUS(&groupByUserSessionItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_GroupByUserSession_STATUS() to populate field GroupByUserSession")
			}
			groupByUserSessionList[groupByUserSessionIndex] = groupByUserSession
		}
		rule.GroupByUserSession = groupByUserSessionList
	} else {
		rule.GroupByUserSession = nil
	}

	// MatchConditions
	if source.MatchConditions != nil {
		matchConditionList := make([]MatchCondition, len(source.MatchConditions))
		for matchConditionIndex, matchConditionItem := range source.MatchConditions {
			// Shadow the loop variable to avoid aliasing
			matchConditionItem := matchConditionItem
			var matchCondition MatchCondition
			err := matchCondition.Initialize_From_MatchCondition_STATUS(&matchConditionItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_MatchCondition_STATUS() to populate field MatchConditions")
			}
			matchConditionList[matchConditionIndex] = matchCondition
		}
		rule.MatchConditions = matchConditionList
	} else {
		rule.MatchConditions = nil
	}

	// Name
	if source.Name != nil {
		name := *source.Name
		rule.Name = &name
	} else {
		rule.Name = nil
	}

	// Priority
	rule.Priority = genruntime.ClonePointerToInt(source.Priority)

	// RateLimitDuration
	if source.RateLimitDuration != nil {
		rateLimitDuration := genruntime.ToEnum(string(*source.RateLimitDuration), webApplicationFirewallCustomRule_RateLimitDuration_Values)
		rule.RateLimitDuration = &rateLimitDuration
	} else {
		rule.RateLimitDuration = nil
	}

	// RateLimitThreshold
	rule.RateLimitThreshold = genruntime.ClonePointerToInt(source.RateLimitThreshold)

	// RuleType
	if source.RuleType != nil {
		ruleType := genruntime.ToEnum(string(*source.RuleType), webApplicationFirewallCustomRule_RuleType_Values)
		rule.RuleType = &ruleType
	} else {
		rule.RuleType = nil
	}

	// State
	if source.State != nil {
		state := genruntime.ToEnum(string(*source.State), webApplicationFirewallCustomRule_State_Values)
		rule.State = &state
	} else {
		rule.State = nil
	}

	// No error
	return nil
}

// Defines contents of a web application rule.
type WebApplicationFirewallCustomRule_STATUS struct {
	// Action: Type of Actions.
	Action *WebApplicationFirewallCustomRule_Action_STATUS `json:"action,omitempty"`

	// Etag: A unique read-only string that changes whenever the resource is updated.
	Etag *string `json:"etag,omitempty"`

	// GroupByUserSession: List of user session identifier group by clauses.
	GroupByUserSession []GroupByUserSession_STATUS `json:"groupByUserSession,omitempty"`

	// MatchConditions: List of match conditions.
	MatchConditions []MatchCondition_STATUS `json:"matchConditions,omitempty"`

	// Name: The name of the resource that is unique within a policy. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`

	// Priority: Priority of the rule. Rules with a lower value will be evaluated before rules with a higher value.
	Priority *int `json:"priority,omitempty"`

	// RateLimitDuration: Duration over which Rate Limit policy will be applied. Applies only when ruleType is RateLimitRule.
	RateLimitDuration *WebApplicationFirewallCustomRule_RateLimitDuration_STATUS `json:"rateLimitDuration,omitempty"`

	// RateLimitThreshold: Rate Limit threshold to apply in case ruleType is RateLimitRule. Must be greater than or equal to 1
	RateLimitThreshold *int `json:"rateLimitThreshold,omitempty"`

	// RuleType: The rule type.
	RuleType *WebApplicationFirewallCustomRule_RuleType_STATUS `json:"ruleType,omitempty"`

	// State: Describes if the custom rule is in enabled or disabled state. Defaults to Enabled if not specified.
	State *WebApplicationFirewallCustomRule_State_STATUS `json:"state,omitempty"`
}

var _ genruntime.FromARMConverter = &WebApplicationFirewallCustomRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *WebApplicationFirewallCustomRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WebApplicationFirewallCustomRule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *WebApplicationFirewallCustomRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WebApplicationFirewallCustomRule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WebApplicationFirewallCustomRule_STATUS, got %T", armInput)
	}

	// Set property "Action":
	if typedInput.Action != nil {
		var temp string
		temp = string(*typedInput.Action)
		action := WebApplicationFirewallCustomRule_Action_STATUS(temp)
		rule.Action = &action
	}

	// Set property "Etag":
	if typedInput.Etag != nil {
		etag := *typedInput.Etag
		rule.Etag = &etag
	}

	// Set property "GroupByUserSession":
	for _, item := range typedInput.GroupByUserSession {
		var item1 GroupByUserSession_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		rule.GroupByUserSession = append(rule.GroupByUserSession, item1)
	}

	// Set property "MatchConditions":
	for _, item := range typedInput.MatchConditions {
		var item1 MatchCondition_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		rule.MatchConditions = append(rule.MatchConditions, item1)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property "Priority":
	if typedInput.Priority != nil {
		priority := *typedInput.Priority
		rule.Priority = &priority
	}

	// Set property "RateLimitDuration":
	if typedInput.RateLimitDuration != nil {
		var temp string
		temp = string(*typedInput.RateLimitDuration)
		rateLimitDuration := WebApplicationFirewallCustomRule_RateLimitDuration_STATUS(temp)
		rule.RateLimitDuration = &rateLimitDuration
	}

	// Set property "RateLimitThreshold":
	if typedInput.RateLimitThreshold != nil {
		rateLimitThreshold := *typedInput.RateLimitThreshold
		rule.RateLimitThreshold = &rateLimitThreshold
	}

	// Set property "RuleType":
	if typedInput.RuleType != nil {
		var temp string
		temp = string(*typedInput.RuleType)
		ruleType := WebApplicationFirewallCustomRule_RuleType_STATUS(temp)
		rule.RuleType = &ruleType
	}

	// Set property "State":
	if typedInput.State != nil {
		var temp string
		temp = string(*typedInput.State)
		state := WebApplicationFirewallCustomRule_State_STATUS(temp)
		rule.State = &state
	}

	// No error
	return nil
}

// AssignProperties_From_WebApplicationFirewallCustomRule_STATUS populates our WebApplicationFirewallCustomRule_STATUS from the provided source WebApplicationFirewallCustomRule_STATUS
func (rule *WebApplicationFirewallCustomRule_STATUS) AssignProperties_From_WebApplicationFirewallCustomRule_STATUS(source *storage.WebApplicationFirewallCustomRule_STATUS) error {

	// Action
	if source.Action != nil {
		action := *source.Action
		actionTemp := genruntime.ToEnum(action, webApplicationFirewallCustomRule_Action_STATUS_Values)
		rule.Action = &actionTemp
	} else {
		rule.Action = nil
	}

	// Etag
	rule.Etag = genruntime.ClonePointerToString(source.Etag)

	// GroupByUserSession
	if source.GroupByUserSession != nil {
		groupByUserSessionList := make([]GroupByUserSession_STATUS, len(source.GroupByUserSession))
		for groupByUserSessionIndex, groupByUserSessionItem := range source.GroupByUserSession {
			// Shadow the loop variable to avoid aliasing
			groupByUserSessionItem := groupByUserSessionItem
			var groupByUserSession GroupByUserSession_STATUS
			err := groupByUserSession.AssignProperties_From_GroupByUserSession_STATUS(&groupByUserSessionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_GroupByUserSession_STATUS() to populate field GroupByUserSession")
			}
			groupByUserSessionList[groupByUserSessionIndex] = groupByUserSession
		}
		rule.GroupByUserSession = groupByUserSessionList
	} else {
		rule.GroupByUserSession = nil
	}

	// MatchConditions
	if source.MatchConditions != nil {
		matchConditionList := make([]MatchCondition_STATUS, len(source.MatchConditions))
		for matchConditionIndex, matchConditionItem := range source.MatchConditions {
			// Shadow the loop variable to avoid aliasing
			matchConditionItem := matchConditionItem
			var matchCondition MatchCondition_STATUS
			err := matchCondition.AssignProperties_From_MatchCondition_STATUS(&matchConditionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_MatchCondition_STATUS() to populate field MatchConditions")
			}
			matchConditionList[matchConditionIndex] = matchCondition
		}
		rule.MatchConditions = matchConditionList
	} else {
		rule.MatchConditions = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Priority
	rule.Priority = genruntime.ClonePointerToInt(source.Priority)

	// RateLimitDuration
	if source.RateLimitDuration != nil {
		rateLimitDuration := *source.RateLimitDuration
		rateLimitDurationTemp := genruntime.ToEnum(rateLimitDuration, webApplicationFirewallCustomRule_RateLimitDuration_STATUS_Values)
		rule.RateLimitDuration = &rateLimitDurationTemp
	} else {
		rule.RateLimitDuration = nil
	}

	// RateLimitThreshold
	rule.RateLimitThreshold = genruntime.ClonePointerToInt(source.RateLimitThreshold)

	// RuleType
	if source.RuleType != nil {
		ruleType := *source.RuleType
		ruleTypeTemp := genruntime.ToEnum(ruleType, webApplicationFirewallCustomRule_RuleType_STATUS_Values)
		rule.RuleType = &ruleTypeTemp
	} else {
		rule.RuleType = nil
	}

	// State
	if source.State != nil {
		state := *source.State
		stateTemp := genruntime.ToEnum(state, webApplicationFirewallCustomRule_State_STATUS_Values)
		rule.State = &stateTemp
	} else {
		rule.State = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WebApplicationFirewallCustomRule_STATUS populates the provided destination WebApplicationFirewallCustomRule_STATUS from our WebApplicationFirewallCustomRule_STATUS
func (rule *WebApplicationFirewallCustomRule_STATUS) AssignProperties_To_WebApplicationFirewallCustomRule_STATUS(destination *storage.WebApplicationFirewallCustomRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	if rule.Action != nil {
		action := string(*rule.Action)
		destination.Action = &action
	} else {
		destination.Action = nil
	}

	// Etag
	destination.Etag = genruntime.ClonePointerToString(rule.Etag)

	// GroupByUserSession
	if rule.GroupByUserSession != nil {
		groupByUserSessionList := make([]storage.GroupByUserSession_STATUS, len(rule.GroupByUserSession))
		for groupByUserSessionIndex, groupByUserSessionItem := range rule.GroupByUserSession {
			// Shadow the loop variable to avoid aliasing
			groupByUserSessionItem := groupByUserSessionItem
			var groupByUserSession storage.GroupByUserSession_STATUS
			err := groupByUserSessionItem.AssignProperties_To_GroupByUserSession_STATUS(&groupByUserSession)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_GroupByUserSession_STATUS() to populate field GroupByUserSession")
			}
			groupByUserSessionList[groupByUserSessionIndex] = groupByUserSession
		}
		destination.GroupByUserSession = groupByUserSessionList
	} else {
		destination.GroupByUserSession = nil
	}

	// MatchConditions
	if rule.MatchConditions != nil {
		matchConditionList := make([]storage.MatchCondition_STATUS, len(rule.MatchConditions))
		for matchConditionIndex, matchConditionItem := range rule.MatchConditions {
			// Shadow the loop variable to avoid aliasing
			matchConditionItem := matchConditionItem
			var matchCondition storage.MatchCondition_STATUS
			err := matchConditionItem.AssignProperties_To_MatchCondition_STATUS(&matchCondition)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_MatchCondition_STATUS() to populate field MatchConditions")
			}
			matchConditionList[matchConditionIndex] = matchCondition
		}
		destination.MatchConditions = matchConditionList
	} else {
		destination.MatchConditions = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Priority
	destination.Priority = genruntime.ClonePointerToInt(rule.Priority)

	// RateLimitDuration
	if rule.RateLimitDuration != nil {
		rateLimitDuration := string(*rule.RateLimitDuration)
		destination.RateLimitDuration = &rateLimitDuration
	} else {
		destination.RateLimitDuration = nil
	}

	// RateLimitThreshold
	destination.RateLimitThreshold = genruntime.ClonePointerToInt(rule.RateLimitThreshold)

	// RuleType
	if rule.RuleType != nil {
		ruleType := string(*rule.RuleType)
		destination.RuleType = &ruleType
	} else {
		destination.RuleType = nil
	}

	// State
	if rule.State != nil {
		state := string(*rule.State)
		destination.State = &state
	} else {
		destination.State = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type WebApplicationFirewallPolicyOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_WebApplicationFirewallPolicyOperatorSpec populates our WebApplicationFirewallPolicyOperatorSpec from the provided source WebApplicationFirewallPolicyOperatorSpec
func (operator *WebApplicationFirewallPolicyOperatorSpec) AssignProperties_From_WebApplicationFirewallPolicyOperatorSpec(source *storage.WebApplicationFirewallPolicyOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WebApplicationFirewallPolicyOperatorSpec populates the provided destination WebApplicationFirewallPolicyOperatorSpec from our WebApplicationFirewallPolicyOperatorSpec
func (operator *WebApplicationFirewallPolicyOperatorSpec) AssignProperties_To_WebApplicationFirewallPolicyOperatorSpec(destination *storage.WebApplicationFirewallPolicyOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type WebApplicationFirewallPolicyPropertiesFormat_ResourceState_STATUS string

const (
	WebApplicationFirewallPolicyPropertiesFormat_ResourceState_STATUS_Creating  = WebApplicationFirewallPolicyPropertiesFormat_ResourceState_STATUS("Creating")
	WebApplicationFirewallPolicyPropertiesFormat_ResourceState_STATUS_Deleting  = WebApplicationFirewallPolicyPropertiesFormat_ResourceState_STATUS("Deleting")
	WebApplicationFirewallPolicyPropertiesFormat_ResourceState_STATUS_Disabled  = WebApplicationFirewallPolicyPropertiesFormat_ResourceState_STATUS("Disabled")
	WebApplicationFirewallPolicyPropertiesFormat_ResourceState_STATUS_Disabling = WebApplicationFirewallPolicyPropertiesFormat_ResourceState_STATUS("Disabling")
	WebApplicationFirewallPolicyPropertiesFormat_ResourceState_STATUS_Enabled   = WebApplicationFirewallPolicyPropertiesFormat_ResourceState_STATUS("Enabled")
	WebApplicationFirewallPolicyPropertiesFormat_ResourceState_STATUS_Enabling  = WebApplicationFirewallPolicyPropertiesFormat_ResourceState_STATUS("Enabling")
)

// Mapping from string to WebApplicationFirewallPolicyPropertiesFormat_ResourceState_STATUS
var webApplicationFirewallPolicyPropertiesFormat_ResourceState_STATUS_Values = map[string]WebApplicationFirewallPolicyPropertiesFormat_ResourceState_STATUS{
	"creating":  WebApplicationFirewallPolicyPropertiesFormat_ResourceState_STATUS_Creating,
	"deleting":  WebApplicationFirewallPolicyPropertiesFormat_ResourceState_STATUS_Deleting,
	"disabled":  WebApplicationFirewallPolicyPropertiesFormat_ResourceState_STATUS_Disabled,
	"disabling": WebApplicationFirewallPolicyPropertiesFormat_ResourceState_STATUS_Disabling,
	"enabled":   WebApplicationFirewallPolicyPropertiesFormat_ResourceState_STATUS_Enabled,
	"enabling":  WebApplicationFirewallPolicyPropertiesFormat_ResourceState_STATUS_Enabling,
}

// Define user session identifier group by clauses.
type GroupByUserSession struct {
	// +kubebuilder:validation:Required
	// GroupByVariables: List of group by clause variables.
	GroupByVariables []GroupByVariable `json:"groupByVariables,omitempty"`
}

var _ genruntime.ARMTransformer = &GroupByUserSession{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (session *GroupByUserSession) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if session == nil {
		return nil, nil
	}
	result := &arm.GroupByUserSession{}

	// Set property "GroupByVariables":
	for _, item := range session.GroupByVariables {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.GroupByVariables = append(result.GroupByVariables, *item_ARM.(*arm.GroupByVariable))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (session *GroupByUserSession) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.GroupByUserSession{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (session *GroupByUserSession) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.GroupByUserSession)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.GroupByUserSession, got %T", armInput)
	}

	// Set property "GroupByVariables":
	for _, item := range typedInput.GroupByVariables {
		var item1 GroupByVariable
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		session.GroupByVariables = append(session.GroupByVariables, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_GroupByUserSession populates our GroupByUserSession from the provided source GroupByUserSession
func (session *GroupByUserSession) AssignProperties_From_GroupByUserSession(source *storage.GroupByUserSession) error {

	// GroupByVariables
	if source.GroupByVariables != nil {
		groupByVariableList := make([]GroupByVariable, len(source.GroupByVariables))
		for groupByVariableIndex, groupByVariableItem := range source.GroupByVariables {
			// Shadow the loop variable to avoid aliasing
			groupByVariableItem := groupByVariableItem
			var groupByVariable GroupByVariable
			err := groupByVariable.AssignProperties_From_GroupByVariable(&groupByVariableItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_GroupByVariable() to populate field GroupByVariables")
			}
			groupByVariableList[groupByVariableIndex] = groupByVariable
		}
		session.GroupByVariables = groupByVariableList
	} else {
		session.GroupByVariables = nil
	}

	// No error
	return nil
}

// AssignProperties_To_GroupByUserSession populates the provided destination GroupByUserSession from our GroupByUserSession
func (session *GroupByUserSession) AssignProperties_To_GroupByUserSession(destination *storage.GroupByUserSession) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// GroupByVariables
	if session.GroupByVariables != nil {
		groupByVariableList := make([]storage.GroupByVariable, len(session.GroupByVariables))
		for groupByVariableIndex, groupByVariableItem := range session.GroupByVariables {
			// Shadow the loop variable to avoid aliasing
			groupByVariableItem := groupByVariableItem
			var groupByVariable storage.GroupByVariable
			err := groupByVariableItem.AssignProperties_To_GroupByVariable(&groupByVariable)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_GroupByVariable() to populate field GroupByVariables")
			}
			groupByVariableList[groupByVariableIndex] = groupByVariable
		}
		destination.GroupByVariables = groupByVariableList
	} else {
		destination.GroupByVariables = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_GroupByUserSession_STATUS populates our GroupByUserSession from the provided source GroupByUserSession_STATUS
func (session *GroupByUserSession) Initialize_From_GroupByUserSession_STATUS(source *GroupByUserSession_STATUS) error {

	// GroupByVariables
	if source.GroupByVariables != nil {
		groupByVariableList := make([]GroupByVariable, len(source.GroupByVariables))
		for groupByVariableIndex, groupByVariableItem := range source.GroupByVariables {
			// Shadow the loop variable to avoid aliasing
			groupByVariableItem := groupByVariableItem
			var groupByVariable GroupByVariable
			err := groupByVariable.Initialize_From_GroupByVariable_STATUS(&groupByVariableItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_GroupByVariable_STATUS() to populate field GroupByVariables")
			}
			groupByVariableList[groupByVariableIndex] = groupByVariable
		}
		session.GroupByVariables = groupByVariableList
	} else {
		session.GroupByVariables = nil
	}

	// No error
	return nil
}

// Define user session identifier group by clauses.
type GroupByUserSession_STATUS struct {
	// GroupByVariables: List of group by clause variables.
	GroupByVariables []GroupByVariable_STATUS `json:"groupByVariables,omitempty"`
}

var _ genruntime.FromARMConverter = &GroupByUserSession_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (session *GroupByUserSession_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.GroupByUserSession_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (session *GroupByUserSession_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.GroupByUserSession_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.GroupByUserSession_STATUS, got %T", armInput)
	}

	// Set property "GroupByVariables":
	for _, item := range typedInput.GroupByVariables {
		var item1 GroupByVariable_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		session.GroupByVariables = append(session.GroupByVariables, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_GroupByUserSession_STATUS populates our GroupByUserSession_STATUS from the provided source GroupByUserSession_STATUS
func (session *GroupByUserSession_STATUS) AssignProperties_From_GroupByUserSession_STATUS(source *storage.GroupByUserSession_STATUS) error {

	// GroupByVariables
	if source.GroupByVariables != nil {
		groupByVariableList := make([]GroupByVariable_STATUS, len(source.GroupByVariables))
		for groupByVariableIndex, groupByVariableItem := range source.GroupByVariables {
			// Shadow the loop variable to avoid aliasing
			groupByVariableItem := groupByVariableItem
			var groupByVariable GroupByVariable_STATUS
			err := groupByVariable.AssignProperties_From_GroupByVariable_STATUS(&groupByVariableItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_GroupByVariable_STATUS() to populate field GroupByVariables")
			}
			groupByVariableList[groupByVariableIndex] = groupByVariable
		}
		session.GroupByVariables = groupByVariableList
	} else {
		session.GroupByVariables = nil
	}

	// No error
	return nil
}

// AssignProperties_To_GroupByUserSession_STATUS populates the provided destination GroupByUserSession_STATUS from our GroupByUserSession_STATUS
func (session *GroupByUserSession_STATUS) AssignProperties_To_GroupByUserSession_STATUS(destination *storage.GroupByUserSession_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// GroupByVariables
	if session.GroupByVariables != nil {
		groupByVariableList := make([]storage.GroupByVariable_STATUS, len(session.GroupByVariables))
		for groupByVariableIndex, groupByVariableItem := range session.GroupByVariables {
			// Shadow the loop variable to avoid aliasing
			groupByVariableItem := groupByVariableItem
			var groupByVariable storage.GroupByVariable_STATUS
			err := groupByVariableItem.AssignProperties_To_GroupByVariable_STATUS(&groupByVariable)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_GroupByVariable_STATUS() to populate field GroupByVariables")
			}
			groupByVariableList[groupByVariableIndex] = groupByVariable
		}
		destination.GroupByVariables = groupByVariableList
	} else {
		destination.GroupByVariables = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines a managed rule set.
type ManagedRuleSet struct {
	// RuleGroupOverrides: Defines the rule group overrides to apply to the rule set.
	RuleGroupOverrides []ManagedRuleGroupOverride `json:"ruleGroupOverrides,omitempty"`

	// +kubebuilder:validation:Required
	// RuleSetType: Defines the rule set type to use.
	RuleSetType *string `json:"ruleSetType,omitempty"`

	// +kubebuilder:validation:Required
	// RuleSetVersion: Defines the version of the rule set to use.
	RuleSetVersion *string `json:"ruleSetVersion,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedRuleSet{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (ruleSet *ManagedRuleSet) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if ruleSet == nil {
		return nil, nil
	}
	result := &arm.ManagedRuleSet{}

	// Set property "RuleGroupOverrides":
	for _, item := range ruleSet.RuleGroupOverrides {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.RuleGroupOverrides = append(result.RuleGroupOverrides, *item_ARM.(*arm.ManagedRuleGroupOverride))
	}

	// Set property "RuleSetType":
	if ruleSet.RuleSetType != nil {
		ruleSetType := *ruleSet.RuleSetType
		result.RuleSetType = &ruleSetType
	}

	// Set property "RuleSetVersion":
	if ruleSet.RuleSetVersion != nil {
		ruleSetVersion := *ruleSet.RuleSetVersion
		result.RuleSetVersion = &ruleSetVersion
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (ruleSet *ManagedRuleSet) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedRuleSet{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (ruleSet *ManagedRuleSet) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedRuleSet)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedRuleSet, got %T", armInput)
	}

	// Set property "RuleGroupOverrides":
	for _, item := range typedInput.RuleGroupOverrides {
		var item1 ManagedRuleGroupOverride
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		ruleSet.RuleGroupOverrides = append(ruleSet.RuleGroupOverrides, item1)
	}

	// Set property "RuleSetType":
	if typedInput.RuleSetType != nil {
		ruleSetType := *typedInput.RuleSetType
		ruleSet.RuleSetType = &ruleSetType
	}

	// Set property "RuleSetVersion":
	if typedInput.RuleSetVersion != nil {
		ruleSetVersion := *typedInput.RuleSetVersion
		ruleSet.RuleSetVersion = &ruleSetVersion
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedRuleSet populates our ManagedRuleSet from the provided source ManagedRuleSet
func (ruleSet *ManagedRuleSet) AssignProperties_From_ManagedRuleSet(source *storage.ManagedRuleSet) error {

	// RuleGroupOverrides
	if source.RuleGroupOverrides != nil {
		ruleGroupOverrideList := make([]ManagedRuleGroupOverride, len(source.RuleGroupOverrides))
		for ruleGroupOverrideIndex, ruleGroupOverrideItem := range source.RuleGroupOverrides {
			// Shadow the loop variable to avoid aliasing
			ruleGroupOverrideItem := ruleGroupOverrideItem
			var ruleGroupOverride ManagedRuleGroupOverride
			err := ruleGroupOverride.AssignProperties_From_ManagedRuleGroupOverride(&ruleGroupOverrideItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedRuleGroupOverride() to populate field RuleGroupOverrides")
			}
			ruleGroupOverrideList[ruleGroupOverrideIndex] = ruleGroupOverride
		}
		ruleSet.RuleGroupOverrides = ruleGroupOverrideList
	} else {
		ruleSet.RuleGroupOverrides = nil
	}

	// RuleSetType
	ruleSet.RuleSetType = genruntime.ClonePointerToString(source.RuleSetType)

	// RuleSetVersion
	ruleSet.RuleSetVersion = genruntime.ClonePointerToString(source.RuleSetVersion)

	// No error
	return nil
}

// AssignProperties_To_ManagedRuleSet populates the provided destination ManagedRuleSet from our ManagedRuleSet
func (ruleSet *ManagedRuleSet) AssignProperties_To_ManagedRuleSet(destination *storage.ManagedRuleSet) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RuleGroupOverrides
	if ruleSet.RuleGroupOverrides != nil {
		ruleGroupOverrideList := make([]storage.ManagedRuleGroupOverride, len(ruleSet.RuleGroupOverrides))
		for ruleGroupOverrideIndex, ruleGroupOverrideItem := range ruleSet.RuleGroupOverrides {
			// Shadow the loop variable to avoid aliasing
			ruleGroupOverrideItem := ruleGroupOverrideItem
			var ruleGroupOverride storage.ManagedRuleGroupOverride
			err := ruleGroupOverrideItem.AssignProperties_To_ManagedRuleGroupOverride(&ruleGroupOverride)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedRuleGroupOverride() to populate field RuleGroupOverrides")
			}
			ruleGroupOverrideList[ruleGroupOverrideIndex] = ruleGroupOverride
		}
		destination.RuleGroupOverrides = ruleGroupOverrideList
	} else {
		destination.RuleGroupOverrides = nil
	}

	// RuleSetType
	destination.RuleSetType = genruntime.ClonePointerToString(ruleSet.RuleSetType)

	// RuleSetVersion
	destination.RuleSetVersion = genruntime.ClonePointerToString(ruleSet.RuleSetVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ManagedRuleSet_STATUS populates our ManagedRuleSet from the provided source ManagedRuleSet_STATUS
func (ruleSet *ManagedRuleSet) Initialize_From_ManagedRuleSet_STATUS(source *ManagedRuleSet_STATUS) error {

	// RuleGroupOverrides
	if source.RuleGroupOverrides != nil {
		ruleGroupOverrideList := make([]ManagedRuleGroupOverride, len(source.RuleGroupOverrides))
		for ruleGroupOverrideIndex, ruleGroupOverrideItem := range source.RuleGroupOverrides {
			// Shadow the loop variable to avoid aliasing
			ruleGroupOverrideItem := ruleGroupOverrideItem
			var ruleGroupOverride ManagedRuleGroupOverride
			err := ruleGroupOverride.Initialize_From_ManagedRuleGroupOverride_STATUS(&ruleGroupOverrideItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ManagedRuleGroupOverride_STATUS() to populate field RuleGroupOverrides")
			}
			ruleGroupOverrideList[ruleGroupOverrideIndex] = ruleGroupOverride
		}
		ruleSet.RuleGroupOverrides = ruleGroupOverrideList
	} else {
		ruleSet.RuleGroupOverrides = nil
	}

	// RuleSetType
	ruleSet.RuleSetType = genruntime.ClonePointerToString(source.RuleSetType)

	// RuleSetVersion
	ruleSet.RuleSetVersion = genruntime.ClonePointerToString(source.RuleSetVersion)

	// No error
	return nil
}

// Defines a managed rule set.
type ManagedRuleSet_STATUS struct {
	// RuleGroupOverrides: Defines the rule group overrides to apply to the rule set.
	RuleGroupOverrides []ManagedRuleGroupOverride_STATUS `json:"ruleGroupOverrides,omitempty"`

	// RuleSetType: Defines the rule set type to use.
	RuleSetType *string `json:"ruleSetType,omitempty"`

	// RuleSetVersion: Defines the version of the rule set to use.
	RuleSetVersion *string `json:"ruleSetVersion,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedRuleSet_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (ruleSet *ManagedRuleSet_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedRuleSet_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (ruleSet *ManagedRuleSet_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedRuleSet_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedRuleSet_STATUS, got %T", armInput)
	}

	// Set property "RuleGroupOverrides":
	for _, item := range typedInput.RuleGroupOverrides {
		var item1 ManagedRuleGroupOverride_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		ruleSet.RuleGroupOverrides = append(ruleSet.RuleGroupOverrides, item1)
	}

	// Set property "RuleSetType":
	if typedInput.RuleSetType != nil {
		ruleSetType := *typedInput.RuleSetType
		ruleSet.RuleSetType = &ruleSetType
	}

	// Set property "RuleSetVersion":
	if typedInput.RuleSetVersion != nil {
		ruleSetVersion := *typedInput.RuleSetVersion
		ruleSet.RuleSetVersion = &ruleSetVersion
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedRuleSet_STATUS populates our ManagedRuleSet_STATUS from the provided source ManagedRuleSet_STATUS
func (ruleSet *ManagedRuleSet_STATUS) AssignProperties_From_ManagedRuleSet_STATUS(source *storage.ManagedRuleSet_STATUS) error {

	// RuleGroupOverrides
	if source.RuleGroupOverrides != nil {
		ruleGroupOverrideList := make([]ManagedRuleGroupOverride_STATUS, len(source.RuleGroupOverrides))
		for ruleGroupOverrideIndex, ruleGroupOverrideItem := range source.RuleGroupOverrides {
			// Shadow the loop variable to avoid aliasing
			ruleGroupOverrideItem := ruleGroupOverrideItem
			var ruleGroupOverride ManagedRuleGroupOverride_STATUS
			err := ruleGroupOverride.AssignProperties_From_ManagedRuleGroupOverride_STATUS(&ruleGroupOverrideItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedRuleGroupOverride_STATUS() to populate field RuleGroupOverrides")
			}
			ruleGroupOverrideList[ruleGroupOverrideIndex] = ruleGroupOverride
		}
		ruleSet.RuleGroupOverrides = ruleGroupOverrideList
	} else {
		ruleSet.RuleGroupOverrides = nil
	}

	// RuleSetType
	ruleSet.RuleSetType = genruntime.ClonePointerToString(source.RuleSetType)

	// RuleSetVersion
	ruleSet.RuleSetVersion = genruntime.ClonePointerToString(source.RuleSetVersion)

	// No error
	return nil
}

// AssignProperties_To_ManagedRuleSet_STATUS populates the provided destination ManagedRuleSet_STATUS from our ManagedRuleSet_STATUS
func (ruleSet *ManagedRuleSet_STATUS) AssignProperties_To_ManagedRuleSet_STATUS(destination *storage.ManagedRuleSet_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RuleGroupOverrides
	if ruleSet.RuleGroupOverrides != nil {
		ruleGroupOverrideList := make([]storage.ManagedRuleGroupOverride_STATUS, len(ruleSet.RuleGroupOverrides))
		for ruleGroupOverrideIndex, ruleGroupOverrideItem := range ruleSet.RuleGroupOverrides {
			// Shadow the loop variable to avoid aliasing
			ruleGroupOverrideItem := ruleGroupOverrideItem
			var ruleGroupOverride storage.ManagedRuleGroupOverride_STATUS
			err := ruleGroupOverrideItem.AssignProperties_To_ManagedRuleGroupOverride_STATUS(&ruleGroupOverride)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedRuleGroupOverride_STATUS() to populate field RuleGroupOverrides")
			}
			ruleGroupOverrideList[ruleGroupOverrideIndex] = ruleGroupOverride
		}
		destination.RuleGroupOverrides = ruleGroupOverrideList
	} else {
		destination.RuleGroupOverrides = nil
	}

	// RuleSetType
	destination.RuleSetType = genruntime.ClonePointerToString(ruleSet.RuleSetType)

	// RuleSetVersion
	destination.RuleSetVersion = genruntime.ClonePointerToString(ruleSet.RuleSetVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Define match conditions.
type MatchCondition struct {
	// +kubebuilder:validation:Required
	// MatchValues: Match value.
	MatchValues []string `json:"matchValues,omitempty"`

	// +kubebuilder:validation:Required
	// MatchVariables: List of match variables.
	MatchVariables []MatchVariable `json:"matchVariables,omitempty"`

	// NegationConditon: Whether this is negate condition or not.
	NegationConditon *bool `json:"negationConditon,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: The operator to be matched.
	Operator *MatchCondition_Operator `json:"operator,omitempty"`

	// Transforms: List of transforms.
	Transforms []Transform `json:"transforms,omitempty"`
}

var _ genruntime.ARMTransformer = &MatchCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *MatchCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &arm.MatchCondition{}

	// Set property "MatchValues":
	for _, item := range condition.MatchValues {
		result.MatchValues = append(result.MatchValues, item)
	}

	// Set property "MatchVariables":
	for _, item := range condition.MatchVariables {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.MatchVariables = append(result.MatchVariables, *item_ARM.(*arm.MatchVariable))
	}

	// Set property "NegationConditon":
	if condition.NegationConditon != nil {
		negationConditon := *condition.NegationConditon
		result.NegationConditon = &negationConditon
	}

	// Set property "Operator":
	if condition.Operator != nil {
		var temp string
		temp = string(*condition.Operator)
		operator := arm.MatchCondition_Operator(temp)
		result.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range condition.Transforms {
		var temp string
		temp = string(item)
		result.Transforms = append(result.Transforms, arm.Transform(temp))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *MatchCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.MatchCondition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *MatchCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.MatchCondition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.MatchCondition, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		condition.MatchValues = append(condition.MatchValues, item)
	}

	// Set property "MatchVariables":
	for _, item := range typedInput.MatchVariables {
		var item1 MatchVariable
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		condition.MatchVariables = append(condition.MatchVariables, item1)
	}

	// Set property "NegationConditon":
	if typedInput.NegationConditon != nil {
		negationConditon := *typedInput.NegationConditon
		condition.NegationConditon = &negationConditon
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := MatchCondition_Operator(temp)
		condition.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		condition.Transforms = append(condition.Transforms, Transform(temp))
	}

	// No error
	return nil
}

// AssignProperties_From_MatchCondition populates our MatchCondition from the provided source MatchCondition
func (condition *MatchCondition) AssignProperties_From_MatchCondition(source *storage.MatchCondition) error {

	// MatchValues
	condition.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// MatchVariables
	if source.MatchVariables != nil {
		matchVariableList := make([]MatchVariable, len(source.MatchVariables))
		for matchVariableIndex, matchVariableItem := range source.MatchVariables {
			// Shadow the loop variable to avoid aliasing
			matchVariableItem := matchVariableItem
			var matchVariable MatchVariable
			err := matchVariable.AssignProperties_From_MatchVariable(&matchVariableItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_MatchVariable() to populate field MatchVariables")
			}
			matchVariableList[matchVariableIndex] = matchVariable
		}
		condition.MatchVariables = matchVariableList
	} else {
		condition.MatchVariables = nil
	}

	// NegationConditon
	if source.NegationConditon != nil {
		negationConditon := *source.NegationConditon
		condition.NegationConditon = &negationConditon
	} else {
		condition.NegationConditon = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, matchCondition_Operator_Values)
		condition.Operator = &operatorTemp
	} else {
		condition.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_Values)
		}
		condition.Transforms = transformList
	} else {
		condition.Transforms = nil
	}

	// No error
	return nil
}

// AssignProperties_To_MatchCondition populates the provided destination MatchCondition from our MatchCondition
func (condition *MatchCondition) AssignProperties_To_MatchCondition(destination *storage.MatchCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(condition.MatchValues)

	// MatchVariables
	if condition.MatchVariables != nil {
		matchVariableList := make([]storage.MatchVariable, len(condition.MatchVariables))
		for matchVariableIndex, matchVariableItem := range condition.MatchVariables {
			// Shadow the loop variable to avoid aliasing
			matchVariableItem := matchVariableItem
			var matchVariable storage.MatchVariable
			err := matchVariableItem.AssignProperties_To_MatchVariable(&matchVariable)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_MatchVariable() to populate field MatchVariables")
			}
			matchVariableList[matchVariableIndex] = matchVariable
		}
		destination.MatchVariables = matchVariableList
	} else {
		destination.MatchVariables = nil
	}

	// NegationConditon
	if condition.NegationConditon != nil {
		negationConditon := *condition.NegationConditon
		destination.NegationConditon = &negationConditon
	} else {
		destination.NegationConditon = nil
	}

	// Operator
	if condition.Operator != nil {
		operator := string(*condition.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if condition.Transforms != nil {
		transformList := make([]string, len(condition.Transforms))
		for transformIndex, transformItem := range condition.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_MatchCondition_STATUS populates our MatchCondition from the provided source MatchCondition_STATUS
func (condition *MatchCondition) Initialize_From_MatchCondition_STATUS(source *MatchCondition_STATUS) error {

	// MatchValues
	condition.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// MatchVariables
	if source.MatchVariables != nil {
		matchVariableList := make([]MatchVariable, len(source.MatchVariables))
		for matchVariableIndex, matchVariableItem := range source.MatchVariables {
			// Shadow the loop variable to avoid aliasing
			matchVariableItem := matchVariableItem
			var matchVariable MatchVariable
			err := matchVariable.Initialize_From_MatchVariable_STATUS(&matchVariableItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_MatchVariable_STATUS() to populate field MatchVariables")
			}
			matchVariableList[matchVariableIndex] = matchVariable
		}
		condition.MatchVariables = matchVariableList
	} else {
		condition.MatchVariables = nil
	}

	// NegationConditon
	if source.NegationConditon != nil {
		negationConditon := *source.NegationConditon
		condition.NegationConditon = &negationConditon
	} else {
		condition.NegationConditon = nil
	}

	// Operator
	if source.Operator != nil {
		operator := genruntime.ToEnum(string(*source.Operator), matchCondition_Operator_Values)
		condition.Operator = &operator
	} else {
		condition.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := genruntime.ToEnum(string(transformItem), transform_Values)
			transformList[transformIndex] = transform
		}
		condition.Transforms = transformList
	} else {
		condition.Transforms = nil
	}

	// No error
	return nil
}

// Define match conditions.
type MatchCondition_STATUS struct {
	// MatchValues: Match value.
	MatchValues []string `json:"matchValues,omitempty"`

	// MatchVariables: List of match variables.
	MatchVariables []MatchVariable_STATUS `json:"matchVariables,omitempty"`

	// NegationConditon: Whether this is negate condition or not.
	NegationConditon *bool `json:"negationConditon,omitempty"`

	// Operator: The operator to be matched.
	Operator *MatchCondition_Operator_STATUS `json:"operator,omitempty"`

	// Transforms: List of transforms.
	Transforms []Transform_STATUS `json:"transforms,omitempty"`
}

var _ genruntime.FromARMConverter = &MatchCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *MatchCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.MatchCondition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *MatchCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.MatchCondition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.MatchCondition_STATUS, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		condition.MatchValues = append(condition.MatchValues, item)
	}

	// Set property "MatchVariables":
	for _, item := range typedInput.MatchVariables {
		var item1 MatchVariable_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		condition.MatchVariables = append(condition.MatchVariables, item1)
	}

	// Set property "NegationConditon":
	if typedInput.NegationConditon != nil {
		negationConditon := *typedInput.NegationConditon
		condition.NegationConditon = &negationConditon
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		var temp string
		temp = string(*typedInput.Operator)
		operator := MatchCondition_Operator_STATUS(temp)
		condition.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		var temp string
		temp = string(item)
		condition.Transforms = append(condition.Transforms, Transform_STATUS(temp))
	}

	// No error
	return nil
}

// AssignProperties_From_MatchCondition_STATUS populates our MatchCondition_STATUS from the provided source MatchCondition_STATUS
func (condition *MatchCondition_STATUS) AssignProperties_From_MatchCondition_STATUS(source *storage.MatchCondition_STATUS) error {

	// MatchValues
	condition.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// MatchVariables
	if source.MatchVariables != nil {
		matchVariableList := make([]MatchVariable_STATUS, len(source.MatchVariables))
		for matchVariableIndex, matchVariableItem := range source.MatchVariables {
			// Shadow the loop variable to avoid aliasing
			matchVariableItem := matchVariableItem
			var matchVariable MatchVariable_STATUS
			err := matchVariable.AssignProperties_From_MatchVariable_STATUS(&matchVariableItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_MatchVariable_STATUS() to populate field MatchVariables")
			}
			matchVariableList[matchVariableIndex] = matchVariable
		}
		condition.MatchVariables = matchVariableList
	} else {
		condition.MatchVariables = nil
	}

	// NegationConditon
	if source.NegationConditon != nil {
		negationConditon := *source.NegationConditon
		condition.NegationConditon = &negationConditon
	} else {
		condition.NegationConditon = nil
	}

	// Operator
	if source.Operator != nil {
		operator := *source.Operator
		operatorTemp := genruntime.ToEnum(operator, matchCondition_Operator_STATUS_Values)
		condition.Operator = &operatorTemp
	} else {
		condition.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = genruntime.ToEnum(transformItem, transform_STATUS_Values)
		}
		condition.Transforms = transformList
	} else {
		condition.Transforms = nil
	}

	// No error
	return nil
}

// AssignProperties_To_MatchCondition_STATUS populates the provided destination MatchCondition_STATUS from our MatchCondition_STATUS
func (condition *MatchCondition_STATUS) AssignProperties_To_MatchCondition_STATUS(destination *storage.MatchCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(condition.MatchValues)

	// MatchVariables
	if condition.MatchVariables != nil {
		matchVariableList := make([]storage.MatchVariable_STATUS, len(condition.MatchVariables))
		for matchVariableIndex, matchVariableItem := range condition.MatchVariables {
			// Shadow the loop variable to avoid aliasing
			matchVariableItem := matchVariableItem
			var matchVariable storage.MatchVariable_STATUS
			err := matchVariableItem.AssignProperties_To_MatchVariable_STATUS(&matchVariable)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_MatchVariable_STATUS() to populate field MatchVariables")
			}
			matchVariableList[matchVariableIndex] = matchVariable
		}
		destination.MatchVariables = matchVariableList
	} else {
		destination.MatchVariables = nil
	}

	// NegationConditon
	if condition.NegationConditon != nil {
		negationConditon := *condition.NegationConditon
		destination.NegationConditon = &negationConditon
	} else {
		destination.NegationConditon = nil
	}

	// Operator
	if condition.Operator != nil {
		operator := string(*condition.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if condition.Transforms != nil {
		transformList := make([]string, len(condition.Transforms))
		for transformIndex, transformItem := range condition.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Allow to exclude some variable satisfy the condition for the WAF check.
type OwaspCrsExclusionEntry struct {
	// ExclusionManagedRuleSets: The managed rule sets that are associated with the exclusion.
	ExclusionManagedRuleSets []ExclusionManagedRuleSet `json:"exclusionManagedRuleSets,omitempty"`

	// +kubebuilder:validation:Required
	// MatchVariable: The variable to be excluded.
	MatchVariable *OwaspCrsExclusionEntry_MatchVariable `json:"matchVariable,omitempty"`

	// +kubebuilder:validation:Required
	// Selector: When matchVariable is a collection, operator used to specify which elements in the collection this exclusion
	// applies to.
	Selector *string `json:"selector,omitempty"`

	// +kubebuilder:validation:Required
	// SelectorMatchOperator: When matchVariable is a collection, operate on the selector to specify which elements in the
	// collection this exclusion applies to.
	SelectorMatchOperator *OwaspCrsExclusionEntry_SelectorMatchOperator `json:"selectorMatchOperator,omitempty"`
}

var _ genruntime.ARMTransformer = &OwaspCrsExclusionEntry{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (entry *OwaspCrsExclusionEntry) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if entry == nil {
		return nil, nil
	}
	result := &arm.OwaspCrsExclusionEntry{}

	// Set property "ExclusionManagedRuleSets":
	for _, item := range entry.ExclusionManagedRuleSets {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.ExclusionManagedRuleSets = append(result.ExclusionManagedRuleSets, *item_ARM.(*arm.ExclusionManagedRuleSet))
	}

	// Set property "MatchVariable":
	if entry.MatchVariable != nil {
		var temp string
		temp = string(*entry.MatchVariable)
		matchVariable := arm.OwaspCrsExclusionEntry_MatchVariable(temp)
		result.MatchVariable = &matchVariable
	}

	// Set property "Selector":
	if entry.Selector != nil {
		selector := *entry.Selector
		result.Selector = &selector
	}

	// Set property "SelectorMatchOperator":
	if entry.SelectorMatchOperator != nil {
		var temp string
		temp = string(*entry.SelectorMatchOperator)
		selectorMatchOperator := arm.OwaspCrsExclusionEntry_SelectorMatchOperator(temp)
		result.SelectorMatchOperator = &selectorMatchOperator
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (entry *OwaspCrsExclusionEntry) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.OwaspCrsExclusionEntry{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (entry *OwaspCrsExclusionEntry) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.OwaspCrsExclusionEntry)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.OwaspCrsExclusionEntry, got %T", armInput)
	}

	// Set property "ExclusionManagedRuleSets":
	for _, item := range typedInput.ExclusionManagedRuleSets {
		var item1 ExclusionManagedRuleSet
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		entry.ExclusionManagedRuleSets = append(entry.ExclusionManagedRuleSets, item1)
	}

	// Set property "MatchVariable":
	if typedInput.MatchVariable != nil {
		var temp string
		temp = string(*typedInput.MatchVariable)
		matchVariable := OwaspCrsExclusionEntry_MatchVariable(temp)
		entry.MatchVariable = &matchVariable
	}

	// Set property "Selector":
	if typedInput.Selector != nil {
		selector := *typedInput.Selector
		entry.Selector = &selector
	}

	// Set property "SelectorMatchOperator":
	if typedInput.SelectorMatchOperator != nil {
		var temp string
		temp = string(*typedInput.SelectorMatchOperator)
		selectorMatchOperator := OwaspCrsExclusionEntry_SelectorMatchOperator(temp)
		entry.SelectorMatchOperator = &selectorMatchOperator
	}

	// No error
	return nil
}

// AssignProperties_From_OwaspCrsExclusionEntry populates our OwaspCrsExclusionEntry from the provided source OwaspCrsExclusionEntry
func (entry *OwaspCrsExclusionEntry) AssignProperties_From_OwaspCrsExclusionEntry(source *storage.OwaspCrsExclusionEntry) error {

	// ExclusionManagedRuleSets
	if source.ExclusionManagedRuleSets != nil {
		exclusionManagedRuleSetList := make([]ExclusionManagedRuleSet, len(source.ExclusionManagedRuleSets))
		for exclusionManagedRuleSetIndex, exclusionManagedRuleSetItem := range source.ExclusionManagedRuleSets {
			// Shadow the loop variable to avoid aliasing
			exclusionManagedRuleSetItem := exclusionManagedRuleSetItem
			var exclusionManagedRuleSet ExclusionManagedRuleSet
			err := exclusionManagedRuleSet.AssignProperties_From_ExclusionManagedRuleSet(&exclusionManagedRuleSetItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ExclusionManagedRuleSet() to populate field ExclusionManagedRuleSets")
			}
			exclusionManagedRuleSetList[exclusionManagedRuleSetIndex] = exclusionManagedRuleSet
		}
		entry.ExclusionManagedRuleSets = exclusionManagedRuleSetList
	} else {
		entry.ExclusionManagedRuleSets = nil
	}

	// MatchVariable
	if source.MatchVariable != nil {
		matchVariable := *source.MatchVariable
		matchVariableTemp := genruntime.ToEnum(matchVariable, owaspCrsExclusionEntry_MatchVariable_Values)
		entry.MatchVariable = &matchVariableTemp
	} else {
		entry.MatchVariable = nil
	}

	// Selector
	entry.Selector = genruntime.ClonePointerToString(source.Selector)

	// SelectorMatchOperator
	if source.SelectorMatchOperator != nil {
		selectorMatchOperator := *source.SelectorMatchOperator
		selectorMatchOperatorTemp := genruntime.ToEnum(selectorMatchOperator, owaspCrsExclusionEntry_SelectorMatchOperator_Values)
		entry.SelectorMatchOperator = &selectorMatchOperatorTemp
	} else {
		entry.SelectorMatchOperator = nil
	}

	// No error
	return nil
}

// AssignProperties_To_OwaspCrsExclusionEntry populates the provided destination OwaspCrsExclusionEntry from our OwaspCrsExclusionEntry
func (entry *OwaspCrsExclusionEntry) AssignProperties_To_OwaspCrsExclusionEntry(destination *storage.OwaspCrsExclusionEntry) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ExclusionManagedRuleSets
	if entry.ExclusionManagedRuleSets != nil {
		exclusionManagedRuleSetList := make([]storage.ExclusionManagedRuleSet, len(entry.ExclusionManagedRuleSets))
		for exclusionManagedRuleSetIndex, exclusionManagedRuleSetItem := range entry.ExclusionManagedRuleSets {
			// Shadow the loop variable to avoid aliasing
			exclusionManagedRuleSetItem := exclusionManagedRuleSetItem
			var exclusionManagedRuleSet storage.ExclusionManagedRuleSet
			err := exclusionManagedRuleSetItem.AssignProperties_To_ExclusionManagedRuleSet(&exclusionManagedRuleSet)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ExclusionManagedRuleSet() to populate field ExclusionManagedRuleSets")
			}
			exclusionManagedRuleSetList[exclusionManagedRuleSetIndex] = exclusionManagedRuleSet
		}
		destination.ExclusionManagedRuleSets = exclusionManagedRuleSetList
	} else {
		destination.ExclusionManagedRuleSets = nil
	}

	// MatchVariable
	if entry.MatchVariable != nil {
		matchVariable := string(*entry.MatchVariable)
		destination.MatchVariable = &matchVariable
	} else {
		destination.MatchVariable = nil
	}

	// Selector
	destination.Selector = genruntime.ClonePointerToString(entry.Selector)

	// SelectorMatchOperator
	if entry.SelectorMatchOperator != nil {
		selectorMatchOperator := string(*entry.SelectorMatchOperator)
		destination.SelectorMatchOperator = &selectorMatchOperator
	} else {
		destination.SelectorMatchOperator = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_OwaspCrsExclusionEntry_STATUS populates our OwaspCrsExclusionEntry from the provided source OwaspCrsExclusionEntry_STATUS
func (entry *OwaspCrsExclusionEntry) Initialize_From_OwaspCrsExclusionEntry_STATUS(source *OwaspCrsExclusionEntry_STATUS) error {

	// ExclusionManagedRuleSets
	if source.ExclusionManagedRuleSets != nil {
		exclusionManagedRuleSetList := make([]ExclusionManagedRuleSet, len(source.ExclusionManagedRuleSets))
		for exclusionManagedRuleSetIndex, exclusionManagedRuleSetItem := range source.ExclusionManagedRuleSets {
			// Shadow the loop variable to avoid aliasing
			exclusionManagedRuleSetItem := exclusionManagedRuleSetItem
			var exclusionManagedRuleSet ExclusionManagedRuleSet
			err := exclusionManagedRuleSet.Initialize_From_ExclusionManagedRuleSet_STATUS(&exclusionManagedRuleSetItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ExclusionManagedRuleSet_STATUS() to populate field ExclusionManagedRuleSets")
			}
			exclusionManagedRuleSetList[exclusionManagedRuleSetIndex] = exclusionManagedRuleSet
		}
		entry.ExclusionManagedRuleSets = exclusionManagedRuleSetList
	} else {
		entry.ExclusionManagedRuleSets = nil
	}

	// MatchVariable
	if source.MatchVariable != nil {
		matchVariable := genruntime.ToEnum(string(*source.MatchVariable), owaspCrsExclusionEntry_MatchVariable_Values)
		entry.MatchVariable = &matchVariable
	} else {
		entry.MatchVariable = nil
	}

	// Selector
	entry.Selector = genruntime.ClonePointerToString(source.Selector)

	// SelectorMatchOperator
	if source.SelectorMatchOperator != nil {
		selectorMatchOperator := genruntime.ToEnum(string(*source.SelectorMatchOperator), owaspCrsExclusionEntry_SelectorMatchOperator_Values)
		entry.SelectorMatchOperator = &selectorMatchOperator
	} else {
		entry.SelectorMatchOperator = nil
	}

	// No error
	return nil
}

// Allow to exclude some variable satisfy the condition for the WAF check.
type OwaspCrsExclusionEntry_STATUS struct {
	// ExclusionManagedRuleSets: The managed rule sets that are associated with the exclusion.
	ExclusionManagedRuleSets []ExclusionManagedRuleSet_STATUS `json:"exclusionManagedRuleSets,omitempty"`

	// MatchVariable: The variable to be excluded.
	MatchVariable *OwaspCrsExclusionEntry_MatchVariable_STATUS `json:"matchVariable,omitempty"`

	// Selector: When matchVariable is a collection, operator used to specify which elements in the collection this exclusion
	// applies to.
	Selector *string `json:"selector,omitempty"`

	// SelectorMatchOperator: When matchVariable is a collection, operate on the selector to specify which elements in the
	// collection this exclusion applies to.
	SelectorMatchOperator *OwaspCrsExclusionEntry_SelectorMatchOperator_STATUS `json:"selectorMatchOperator,omitempty"`
}

var _ genruntime.FromARMConverter = &OwaspCrsExclusionEntry_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (entry *OwaspCrsExclusionEntry_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.OwaspCrsExclusionEntry_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (entry *OwaspCrsExclusionEntry_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.OwaspCrsExclusionEntry_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.OwaspCrsExclusionEntry_STATUS, got %T", armInput)
	}

	// Set property "ExclusionManagedRuleSets":
	for _, item := range typedInput.ExclusionManagedRuleSets {
		var item1 ExclusionManagedRuleSet_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		entry.ExclusionManagedRuleSets = append(entry.ExclusionManagedRuleSets, item1)
	}

	// Set property "MatchVariable":
	if typedInput.MatchVariable != nil {
		var temp string
		temp = string(*typedInput.MatchVariable)
		matchVariable := OwaspCrsExclusionEntry_MatchVariable_STATUS(temp)
		entry.MatchVariable = &matchVariable
	}

	// Set property "Selector":
	if typedInput.Selector != nil {
		selector := *typedInput.Selector
		entry.Selector = &selector
	}

	// Set property "SelectorMatchOperator":
	if typedInput.SelectorMatchOperator != nil {
		var temp string
		temp = string(*typedInput.SelectorMatchOperator)
		selectorMatchOperator := OwaspCrsExclusionEntry_SelectorMatchOperator_STATUS(temp)
		entry.SelectorMatchOperator = &selectorMatchOperator
	}

	// No error
	return nil
}

// AssignProperties_From_OwaspCrsExclusionEntry_STATUS populates our OwaspCrsExclusionEntry_STATUS from the provided source OwaspCrsExclusionEntry_STATUS
func (entry *OwaspCrsExclusionEntry_STATUS) AssignProperties_From_OwaspCrsExclusionEntry_STATUS(source *storage.OwaspCrsExclusionEntry_STATUS) error {

	// ExclusionManagedRuleSets
	if source.ExclusionManagedRuleSets != nil {
		exclusionManagedRuleSetList := make([]ExclusionManagedRuleSet_STATUS, len(source.ExclusionManagedRuleSets))
		for exclusionManagedRuleSetIndex, exclusionManagedRuleSetItem := range source.ExclusionManagedRuleSets {
			// Shadow the loop variable to avoid aliasing
			exclusionManagedRuleSetItem := exclusionManagedRuleSetItem
			var exclusionManagedRuleSet ExclusionManagedRuleSet_STATUS
			err := exclusionManagedRuleSet.AssignProperties_From_ExclusionManagedRuleSet_STATUS(&exclusionManagedRuleSetItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ExclusionManagedRuleSet_STATUS() to populate field ExclusionManagedRuleSets")
			}
			exclusionManagedRuleSetList[exclusionManagedRuleSetIndex] = exclusionManagedRuleSet
		}
		entry.ExclusionManagedRuleSets = exclusionManagedRuleSetList
	} else {
		entry.ExclusionManagedRuleSets = nil
	}

	// MatchVariable
	if source.MatchVariable != nil {
		matchVariable := *source.MatchVariable
		matchVariableTemp := genruntime.ToEnum(matchVariable, owaspCrsExclusionEntry_MatchVariable_STATUS_Values)
		entry.MatchVariable = &matchVariableTemp
	} else {
		entry.MatchVariable = nil
	}

	// Selector
	entry.Selector = genruntime.ClonePointerToString(source.Selector)

	// SelectorMatchOperator
	if source.SelectorMatchOperator != nil {
		selectorMatchOperator := *source.SelectorMatchOperator
		selectorMatchOperatorTemp := genruntime.ToEnum(selectorMatchOperator, owaspCrsExclusionEntry_SelectorMatchOperator_STATUS_Values)
		entry.SelectorMatchOperator = &selectorMatchOperatorTemp
	} else {
		entry.SelectorMatchOperator = nil
	}

	// No error
	return nil
}

// AssignProperties_To_OwaspCrsExclusionEntry_STATUS populates the provided destination OwaspCrsExclusionEntry_STATUS from our OwaspCrsExclusionEntry_STATUS
func (entry *OwaspCrsExclusionEntry_STATUS) AssignProperties_To_OwaspCrsExclusionEntry_STATUS(destination *storage.OwaspCrsExclusionEntry_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ExclusionManagedRuleSets
	if entry.ExclusionManagedRuleSets != nil {
		exclusionManagedRuleSetList := make([]storage.ExclusionManagedRuleSet_STATUS, len(entry.ExclusionManagedRuleSets))
		for exclusionManagedRuleSetIndex, exclusionManagedRuleSetItem := range entry.ExclusionManagedRuleSets {
			// Shadow the loop variable to avoid aliasing
			exclusionManagedRuleSetItem := exclusionManagedRuleSetItem
			var exclusionManagedRuleSet storage.ExclusionManagedRuleSet_STATUS
			err := exclusionManagedRuleSetItem.AssignProperties_To_ExclusionManagedRuleSet_STATUS(&exclusionManagedRuleSet)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ExclusionManagedRuleSet_STATUS() to populate field ExclusionManagedRuleSets")
			}
			exclusionManagedRuleSetList[exclusionManagedRuleSetIndex] = exclusionManagedRuleSet
		}
		destination.ExclusionManagedRuleSets = exclusionManagedRuleSetList
	} else {
		destination.ExclusionManagedRuleSets = nil
	}

	// MatchVariable
	if entry.MatchVariable != nil {
		matchVariable := string(*entry.MatchVariable)
		destination.MatchVariable = &matchVariable
	} else {
		destination.MatchVariable = nil
	}

	// Selector
	destination.Selector = genruntime.ClonePointerToString(entry.Selector)

	// SelectorMatchOperator
	if entry.SelectorMatchOperator != nil {
		selectorMatchOperator := string(*entry.SelectorMatchOperator)
		destination.SelectorMatchOperator = &selectorMatchOperator
	} else {
		destination.SelectorMatchOperator = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type PolicySettings_LogScrubbing struct {
	// ScrubbingRules: The rules that are applied to the logs for scrubbing.
	ScrubbingRules []WebApplicationFirewallScrubbingRules `json:"scrubbingRules,omitempty"`

	// State: State of the log scrubbing config. Default value is Enabled.
	State *PolicySettings_LogScrubbing_State `json:"state,omitempty"`
}

var _ genruntime.ARMTransformer = &PolicySettings_LogScrubbing{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (scrubbing *PolicySettings_LogScrubbing) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if scrubbing == nil {
		return nil, nil
	}
	result := &arm.PolicySettings_LogScrubbing{}

	// Set property "ScrubbingRules":
	for _, item := range scrubbing.ScrubbingRules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.ScrubbingRules = append(result.ScrubbingRules, *item_ARM.(*arm.WebApplicationFirewallScrubbingRules))
	}

	// Set property "State":
	if scrubbing.State != nil {
		var temp string
		temp = string(*scrubbing.State)
		state := arm.PolicySettings_LogScrubbing_State(temp)
		result.State = &state
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (scrubbing *PolicySettings_LogScrubbing) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PolicySettings_LogScrubbing{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (scrubbing *PolicySettings_LogScrubbing) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PolicySettings_LogScrubbing)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PolicySettings_LogScrubbing, got %T", armInput)
	}

	// Set property "ScrubbingRules":
	for _, item := range typedInput.ScrubbingRules {
		var item1 WebApplicationFirewallScrubbingRules
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		scrubbing.ScrubbingRules = append(scrubbing.ScrubbingRules, item1)
	}

	// Set property "State":
	if typedInput.State != nil {
		var temp string
		temp = string(*typedInput.State)
		state := PolicySettings_LogScrubbing_State(temp)
		scrubbing.State = &state
	}

	// No error
	return nil
}

// AssignProperties_From_PolicySettings_LogScrubbing populates our PolicySettings_LogScrubbing from the provided source PolicySettings_LogScrubbing
func (scrubbing *PolicySettings_LogScrubbing) AssignProperties_From_PolicySettings_LogScrubbing(source *storage.PolicySettings_LogScrubbing) error {

	// ScrubbingRules
	if source.ScrubbingRules != nil {
		scrubbingRuleList := make([]WebApplicationFirewallScrubbingRules, len(source.ScrubbingRules))
		for scrubbingRuleIndex, scrubbingRuleItem := range source.ScrubbingRules {
			// Shadow the loop variable to avoid aliasing
			scrubbingRuleItem := scrubbingRuleItem
			var scrubbingRule WebApplicationFirewallScrubbingRules
			err := scrubbingRule.AssignProperties_From_WebApplicationFirewallScrubbingRules(&scrubbingRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_WebApplicationFirewallScrubbingRules() to populate field ScrubbingRules")
			}
			scrubbingRuleList[scrubbingRuleIndex] = scrubbingRule
		}
		scrubbing.ScrubbingRules = scrubbingRuleList
	} else {
		scrubbing.ScrubbingRules = nil
	}

	// State
	if source.State != nil {
		state := *source.State
		stateTemp := genruntime.ToEnum(state, policySettings_LogScrubbing_State_Values)
		scrubbing.State = &stateTemp
	} else {
		scrubbing.State = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PolicySettings_LogScrubbing populates the provided destination PolicySettings_LogScrubbing from our PolicySettings_LogScrubbing
func (scrubbing *PolicySettings_LogScrubbing) AssignProperties_To_PolicySettings_LogScrubbing(destination *storage.PolicySettings_LogScrubbing) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ScrubbingRules
	if scrubbing.ScrubbingRules != nil {
		scrubbingRuleList := make([]storage.WebApplicationFirewallScrubbingRules, len(scrubbing.ScrubbingRules))
		for scrubbingRuleIndex, scrubbingRuleItem := range scrubbing.ScrubbingRules {
			// Shadow the loop variable to avoid aliasing
			scrubbingRuleItem := scrubbingRuleItem
			var scrubbingRule storage.WebApplicationFirewallScrubbingRules
			err := scrubbingRuleItem.AssignProperties_To_WebApplicationFirewallScrubbingRules(&scrubbingRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_WebApplicationFirewallScrubbingRules() to populate field ScrubbingRules")
			}
			scrubbingRuleList[scrubbingRuleIndex] = scrubbingRule
		}
		destination.ScrubbingRules = scrubbingRuleList
	} else {
		destination.ScrubbingRules = nil
	}

	// State
	if scrubbing.State != nil {
		state := string(*scrubbing.State)
		destination.State = &state
	} else {
		destination.State = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_PolicySettings_LogScrubbing_STATUS populates our PolicySettings_LogScrubbing from the provided source PolicySettings_LogScrubbing_STATUS
func (scrubbing *PolicySettings_LogScrubbing) Initialize_From_PolicySettings_LogScrubbing_STATUS(source *PolicySettings_LogScrubbing_STATUS) error {

	// ScrubbingRules
	if source.ScrubbingRules != nil {
		scrubbingRuleList := make([]WebApplicationFirewallScrubbingRules, len(source.ScrubbingRules))
		for scrubbingRuleIndex, scrubbingRuleItem := range source.ScrubbingRules {
			// Shadow the loop variable to avoid aliasing
			scrubbingRuleItem := scrubbingRuleItem
			var scrubbingRule WebApplicationFirewallScrubbingRules
			err := scrubbingRule.Initialize_From_WebApplicationFirewallScrubbingRules_STATUS(&scrubbingRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_WebApplicationFirewallScrubbingRules_STATUS() to populate field ScrubbingRules")
			}
			scrubbingRuleList[scrubbingRuleIndex] = scrubbingRule
		}
		scrubbing.ScrubbingRules = scrubbingRuleList
	} else {
		scrubbing.ScrubbingRules = nil
	}

	// State
	if source.State != nil {
		state := genruntime.ToEnum(string(*source.State), policySettings_LogScrubbing_State_Values)
		scrubbing.State = &state
	} else {
		scrubbing.State = nil
	}

	// No error
	return nil
}

type PolicySettings_LogScrubbing_STATUS struct {
	// ScrubbingRules: The rules that are applied to the logs for scrubbing.
	ScrubbingRules []WebApplicationFirewallScrubbingRules_STATUS `json:"scrubbingRules,omitempty"`

	// State: State of the log scrubbing config. Default value is Enabled.
	State *PolicySettings_LogScrubbing_State_STATUS `json:"state,omitempty"`
}

var _ genruntime.FromARMConverter = &PolicySettings_LogScrubbing_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (scrubbing *PolicySettings_LogScrubbing_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PolicySettings_LogScrubbing_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (scrubbing *PolicySettings_LogScrubbing_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PolicySettings_LogScrubbing_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PolicySettings_LogScrubbing_STATUS, got %T", armInput)
	}

	// Set property "ScrubbingRules":
	for _, item := range typedInput.ScrubbingRules {
		var item1 WebApplicationFirewallScrubbingRules_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		scrubbing.ScrubbingRules = append(scrubbing.ScrubbingRules, item1)
	}

	// Set property "State":
	if typedInput.State != nil {
		var temp string
		temp = string(*typedInput.State)
		state := PolicySettings_LogScrubbing_State_STATUS(temp)
		scrubbing.State = &state
	}

	// No error
	return nil
}

// AssignProperties_From_PolicySettings_LogScrubbing_STATUS populates our PolicySettings_LogScrubbing_STATUS from the provided source PolicySettings_LogScrubbing_STATUS
func (scrubbing *PolicySettings_LogScrubbing_STATUS) AssignProperties_From_PolicySettings_LogScrubbing_STATUS(source *storage.PolicySettings_LogScrubbing_STATUS) error {

	// ScrubbingRules
	if source.ScrubbingRules != nil {
		scrubbingRuleList := make([]WebApplicationFirewallScrubbingRules_STATUS, len(source.ScrubbingRules))
		for scrubbingRuleIndex, scrubbingRuleItem := range source.ScrubbingRules {
			// Shadow the loop variable to avoid aliasing
			scrubbingRuleItem := scrubbingRuleItem
			var scrubbingRule WebApplicationFirewallScrubbingRules_STATUS
			err := scrubbingRule.AssignProperties_From_WebApplicationFirewallScrubbingRules_STATUS(&scrubbingRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_WebApplicationFirewallScrubbingRules_STATUS() to populate field ScrubbingRules")
			}
			scrubbingRuleList[scrubbingRuleIndex] = scrubbingRule
		}
		scrubbing.ScrubbingRules = scrubbingRuleList
	} else {
		scrubbing.ScrubbingRules = nil
	}

	// State
	if source.State != nil {
		state := *source.State
		stateTemp := genruntime.ToEnum(state, policySettings_LogScrubbing_State_STATUS_Values)
		scrubbing.State = &stateTemp
	} else {
		scrubbing.State = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PolicySettings_LogScrubbing_STATUS populates the provided destination PolicySettings_LogScrubbing_STATUS from our PolicySettings_LogScrubbing_STATUS
func (scrubbing *PolicySettings_LogScrubbing_STATUS) AssignProperties_To_PolicySettings_LogScrubbing_STATUS(destination *storage.PolicySettings_LogScrubbing_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ScrubbingRules
	if scrubbing.ScrubbingRules != nil {
		scrubbingRuleList := make([]storage.WebApplicationFirewallScrubbingRules_STATUS, len(scrubbing.ScrubbingRules))
		for scrubbingRuleIndex, scrubbingRuleItem := range scrubbing.ScrubbingRules {
			// Shadow the loop variable to avoid aliasing
			scrubbingRuleItem := scrubbingRuleItem
			var scrubbingRule storage.WebApplicationFirewallScrubbingRules_STATUS
			err := scrubbingRuleItem.AssignProperties_To_WebApplicationFirewallScrubbingRules_STATUS(&scrubbingRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_WebApplicationFirewallScrubbingRules_STATUS() to populate field ScrubbingRules")
			}
			scrubbingRuleList[scrubbingRuleIndex] = scrubbingRule
		}
		destination.ScrubbingRules = scrubbingRuleList
	} else {
		destination.ScrubbingRules = nil
	}

	// State
	if scrubbing.State != nil {
		state := string(*scrubbing.State)
		destination.State = &state
	} else {
		destination.State = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Detection","Prevention"}
type PolicySettings_Mode string

const (
	PolicySettings_Mode_Detection  = PolicySettings_Mode("Detection")
	PolicySettings_Mode_Prevention = PolicySettings_Mode("Prevention")
)

// Mapping from string to PolicySettings_Mode
var policySettings_Mode_Values = map[string]PolicySettings_Mode{
	"detection":  PolicySettings_Mode_Detection,
	"prevention": PolicySettings_Mode_Prevention,
}

type PolicySettings_Mode_STATUS string

const (
	PolicySettings_Mode_STATUS_Detection  = PolicySettings_Mode_STATUS("Detection")
	PolicySettings_Mode_STATUS_Prevention = PolicySettings_Mode_STATUS("Prevention")
)

// Mapping from string to PolicySettings_Mode_STATUS
var policySettings_Mode_STATUS_Values = map[string]PolicySettings_Mode_STATUS{
	"detection":  PolicySettings_Mode_STATUS_Detection,
	"prevention": PolicySettings_Mode_STATUS_Prevention,
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type PolicySettings_State string

const (
	PolicySettings_State_Disabled = PolicySettings_State("Disabled")
	PolicySettings_State_Enabled  = PolicySettings_State("Enabled")
)

// Mapping from string to PolicySettings_State
var policySettings_State_Values = map[string]PolicySettings_State{
	"disabled": PolicySettings_State_Disabled,
	"enabled":  PolicySettings_State_Enabled,
}

type PolicySettings_State_STATUS string

const (
	PolicySettings_State_STATUS_Disabled = PolicySettings_State_STATUS("Disabled")
	PolicySettings_State_STATUS_Enabled  = PolicySettings_State_STATUS("Enabled")
)

// Mapping from string to PolicySettings_State_STATUS
var policySettings_State_STATUS_Values = map[string]PolicySettings_State_STATUS{
	"disabled": PolicySettings_State_STATUS_Disabled,
	"enabled":  PolicySettings_State_STATUS_Enabled,
}

// +kubebuilder:validation:Enum={"Allow","Block","JSChallenge","Log"}
type WebApplicationFirewallCustomRule_Action string

const (
	WebApplicationFirewallCustomRule_Action_Allow       = WebApplicationFirewallCustomRule_Action("Allow")
	WebApplicationFirewallCustomRule_Action_Block       = WebApplicationFirewallCustomRule_Action("Block")
	WebApplicationFirewallCustomRule_Action_JSChallenge = WebApplicationFirewallCustomRule_Action("JSChallenge")
	WebApplicationFirewallCustomRule_Action_Log         = WebApplicationFirewallCustomRule_Action("Log")
)

// Mapping from string to WebApplicationFirewallCustomRule_Action
var webApplicationFirewallCustomRule_Action_Values = map[string]WebApplicationFirewallCustomRule_Action{
	"allow":       WebApplicationFirewallCustomRule_Action_Allow,
	"block":       WebApplicationFirewallCustomRule_Action_Block,
	"jschallenge": WebApplicationFirewallCustomRule_Action_JSChallenge,
	"log":         WebApplicationFirewallCustomRule_Action_Log,
}

type WebApplicationFirewallCustomRule_Action_STATUS string

const (
	WebApplicationFirewallCustomRule_Action_STATUS_Allow       = WebApplicationFirewallCustomRule_Action_STATUS("Allow")
	WebApplicationFirewallCustomRule_Action_STATUS_Block       = WebApplicationFirewallCustomRule_Action_STATUS("Block")
	WebApplicationFirewallCustomRule_Action_STATUS_JSChallenge = WebApplicationFirewallCustomRule_Action_STATUS("JSChallenge")
	WebApplicationFirewallCustomRule_Action_STATUS_Log         = WebApplicationFirewallCustomRule_Action_STATUS("Log")
)

// Mapping from string to WebApplicationFirewallCustomRule_Action_STATUS
var webApplicationFirewallCustomRule_Action_STATUS_Values = map[string]WebApplicationFirewallCustomRule_Action_STATUS{
	"allow":       WebApplicationFirewallCustomRule_Action_STATUS_Allow,
	"block":       WebApplicationFirewallCustomRule_Action_STATUS_Block,
	"jschallenge": WebApplicationFirewallCustomRule_Action_STATUS_JSChallenge,
	"log":         WebApplicationFirewallCustomRule_Action_STATUS_Log,
}

// +kubebuilder:validation:Enum={"FiveMins","OneMin"}
type WebApplicationFirewallCustomRule_RateLimitDuration string

const (
	WebApplicationFirewallCustomRule_RateLimitDuration_FiveMins = WebApplicationFirewallCustomRule_RateLimitDuration("FiveMins")
	WebApplicationFirewallCustomRule_RateLimitDuration_OneMin   = WebApplicationFirewallCustomRule_RateLimitDuration("OneMin")
)

// Mapping from string to WebApplicationFirewallCustomRule_RateLimitDuration
var webApplicationFirewallCustomRule_RateLimitDuration_Values = map[string]WebApplicationFirewallCustomRule_RateLimitDuration{
	"fivemins": WebApplicationFirewallCustomRule_RateLimitDuration_FiveMins,
	"onemin":   WebApplicationFirewallCustomRule_RateLimitDuration_OneMin,
}

type WebApplicationFirewallCustomRule_RateLimitDuration_STATUS string

const (
	WebApplicationFirewallCustomRule_RateLimitDuration_STATUS_FiveMins = WebApplicationFirewallCustomRule_RateLimitDuration_STATUS("FiveMins")
	WebApplicationFirewallCustomRule_RateLimitDuration_STATUS_OneMin   = WebApplicationFirewallCustomRule_RateLimitDuration_STATUS("OneMin")
)

// Mapping from string to WebApplicationFirewallCustomRule_RateLimitDuration_STATUS
var webApplicationFirewallCustomRule_RateLimitDuration_STATUS_Values = map[string]WebApplicationFirewallCustomRule_RateLimitDuration_STATUS{
	"fivemins": WebApplicationFirewallCustomRule_RateLimitDuration_STATUS_FiveMins,
	"onemin":   WebApplicationFirewallCustomRule_RateLimitDuration_STATUS_OneMin,
}

// +kubebuilder:validation:Enum={"Invalid","MatchRule","RateLimitRule"}
type WebApplicationFirewallCustomRule_RuleType string

const (
	WebApplicationFirewallCustomRule_RuleType_Invalid       = WebApplicationFirewallCustomRule_RuleType("Invalid")
	WebApplicationFirewallCustomRule_RuleType_MatchRule     = WebApplicationFirewallCustomRule_RuleType("MatchRule")
	WebApplicationFirewallCustomRule_RuleType_RateLimitRule = WebApplicationFirewallCustomRule_RuleType("RateLimitRule")
)

// Mapping from string to WebApplicationFirewallCustomRule_RuleType
var webApplicationFirewallCustomRule_RuleType_Values = map[string]WebApplicationFirewallCustomRule_RuleType{
	"invalid":       WebApplicationFirewallCustomRule_RuleType_Invalid,
	"matchrule":     WebApplicationFirewallCustomRule_RuleType_MatchRule,
	"ratelimitrule": WebApplicationFirewallCustomRule_RuleType_RateLimitRule,
}

type WebApplicationFirewallCustomRule_RuleType_STATUS string

const (
	WebApplicationFirewallCustomRule_RuleType_STATUS_Invalid       = WebApplicationFirewallCustomRule_RuleType_STATUS("Invalid")
	WebApplicationFirewallCustomRule_RuleType_STATUS_MatchRule     = WebApplicationFirewallCustomRule_RuleType_STATUS("MatchRule")
	WebApplicationFirewallCustomRule_RuleType_STATUS_RateLimitRule = WebApplicationFirewallCustomRule_RuleType_STATUS("RateLimitRule")
)

// Mapping from string to WebApplicationFirewallCustomRule_RuleType_STATUS
var webApplicationFirewallCustomRule_RuleType_STATUS_Values = map[string]WebApplicationFirewallCustomRule_RuleType_STATUS{
	"invalid":       WebApplicationFirewallCustomRule_RuleType_STATUS_Invalid,
	"matchrule":     WebApplicationFirewallCustomRule_RuleType_STATUS_MatchRule,
	"ratelimitrule": WebApplicationFirewallCustomRule_RuleType_STATUS_RateLimitRule,
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type WebApplicationFirewallCustomRule_State string

const (
	WebApplicationFirewallCustomRule_State_Disabled = WebApplicationFirewallCustomRule_State("Disabled")
	WebApplicationFirewallCustomRule_State_Enabled  = WebApplicationFirewallCustomRule_State("Enabled")
)

// Mapping from string to WebApplicationFirewallCustomRule_State
var webApplicationFirewallCustomRule_State_Values = map[string]WebApplicationFirewallCustomRule_State{
	"disabled": WebApplicationFirewallCustomRule_State_Disabled,
	"enabled":  WebApplicationFirewallCustomRule_State_Enabled,
}

type WebApplicationFirewallCustomRule_State_STATUS string

const (
	WebApplicationFirewallCustomRule_State_STATUS_Disabled = WebApplicationFirewallCustomRule_State_STATUS("Disabled")
	WebApplicationFirewallCustomRule_State_STATUS_Enabled  = WebApplicationFirewallCustomRule_State_STATUS("Enabled")
)

// Mapping from string to WebApplicationFirewallCustomRule_State_STATUS
var webApplicationFirewallCustomRule_State_STATUS_Values = map[string]WebApplicationFirewallCustomRule_State_STATUS{
	"disabled": WebApplicationFirewallCustomRule_State_STATUS_Disabled,
	"enabled":  WebApplicationFirewallCustomRule_State_STATUS_Enabled,
}

// Defines a managed rule set for Exclusions.
type ExclusionManagedRuleSet struct {
	// RuleGroups: Defines the rule groups to apply to the rule set.
	RuleGroups []ExclusionManagedRuleGroup `json:"ruleGroups,omitempty"`

	// +kubebuilder:validation:Required
	// RuleSetType: Defines the rule set type to use.
	RuleSetType *string `json:"ruleSetType,omitempty"`

	// +kubebuilder:validation:Required
	// RuleSetVersion: Defines the version of the rule set to use.
	RuleSetVersion *string `json:"ruleSetVersion,omitempty"`
}

var _ genruntime.ARMTransformer = &ExclusionManagedRuleSet{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (ruleSet *ExclusionManagedRuleSet) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if ruleSet == nil {
		return nil, nil
	}
	result := &arm.ExclusionManagedRuleSet{}

	// Set property "RuleGroups":
	for _, item := range ruleSet.RuleGroups {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.RuleGroups = append(result.RuleGroups, *item_ARM.(*arm.ExclusionManagedRuleGroup))
	}

	// Set property "RuleSetType":
	if ruleSet.RuleSetType != nil {
		ruleSetType := *ruleSet.RuleSetType
		result.RuleSetType = &ruleSetType
	}

	// Set property "RuleSetVersion":
	if ruleSet.RuleSetVersion != nil {
		ruleSetVersion := *ruleSet.RuleSetVersion
		result.RuleSetVersion = &ruleSetVersion
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (ruleSet *ExclusionManagedRuleSet) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ExclusionManagedRuleSet{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (ruleSet *ExclusionManagedRuleSet) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ExclusionManagedRuleSet)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ExclusionManagedRuleSet, got %T", armInput)
	}

	// Set property "RuleGroups":
	for _, item := range typedInput.RuleGroups {
		var item1 ExclusionManagedRuleGroup
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		ruleSet.RuleGroups = append(ruleSet.RuleGroups, item1)
	}

	// Set property "RuleSetType":
	if typedInput.RuleSetType != nil {
		ruleSetType := *typedInput.RuleSetType
		ruleSet.RuleSetType = &ruleSetType
	}

	// Set property "RuleSetVersion":
	if typedInput.RuleSetVersion != nil {
		ruleSetVersion := *typedInput.RuleSetVersion
		ruleSet.RuleSetVersion = &ruleSetVersion
	}

	// No error
	return nil
}

// AssignProperties_From_ExclusionManagedRuleSet populates our ExclusionManagedRuleSet from the provided source ExclusionManagedRuleSet
func (ruleSet *ExclusionManagedRuleSet) AssignProperties_From_ExclusionManagedRuleSet(source *storage.ExclusionManagedRuleSet) error {

	// RuleGroups
	if source.RuleGroups != nil {
		ruleGroupList := make([]ExclusionManagedRuleGroup, len(source.RuleGroups))
		for ruleGroupIndex, ruleGroupItem := range source.RuleGroups {
			// Shadow the loop variable to avoid aliasing
			ruleGroupItem := ruleGroupItem
			var ruleGroup ExclusionManagedRuleGroup
			err := ruleGroup.AssignProperties_From_ExclusionManagedRuleGroup(&ruleGroupItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ExclusionManagedRuleGroup() to populate field RuleGroups")
			}
			ruleGroupList[ruleGroupIndex] = ruleGroup
		}
		ruleSet.RuleGroups = ruleGroupList
	} else {
		ruleSet.RuleGroups = nil
	}

	// RuleSetType
	ruleSet.RuleSetType = genruntime.ClonePointerToString(source.RuleSetType)

	// RuleSetVersion
	ruleSet.RuleSetVersion = genruntime.ClonePointerToString(source.RuleSetVersion)

	// No error
	return nil
}

// AssignProperties_To_ExclusionManagedRuleSet populates the provided destination ExclusionManagedRuleSet from our ExclusionManagedRuleSet
func (ruleSet *ExclusionManagedRuleSet) AssignProperties_To_ExclusionManagedRuleSet(destination *storage.ExclusionManagedRuleSet) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RuleGroups
	if ruleSet.RuleGroups != nil {
		ruleGroupList := make([]storage.ExclusionManagedRuleGroup, len(ruleSet.RuleGroups))
		for ruleGroupIndex, ruleGroupItem := range ruleSet.RuleGroups {
			// Shadow the loop variable to avoid aliasing
			ruleGroupItem := ruleGroupItem
			var ruleGroup storage.ExclusionManagedRuleGroup
			err := ruleGroupItem.AssignProperties_To_ExclusionManagedRuleGroup(&ruleGroup)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ExclusionManagedRuleGroup() to populate field RuleGroups")
			}
			ruleGroupList[ruleGroupIndex] = ruleGroup
		}
		destination.RuleGroups = ruleGroupList
	} else {
		destination.RuleGroups = nil
	}

	// RuleSetType
	destination.RuleSetType = genruntime.ClonePointerToString(ruleSet.RuleSetType)

	// RuleSetVersion
	destination.RuleSetVersion = genruntime.ClonePointerToString(ruleSet.RuleSetVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ExclusionManagedRuleSet_STATUS populates our ExclusionManagedRuleSet from the provided source ExclusionManagedRuleSet_STATUS
func (ruleSet *ExclusionManagedRuleSet) Initialize_From_ExclusionManagedRuleSet_STATUS(source *ExclusionManagedRuleSet_STATUS) error {

	// RuleGroups
	if source.RuleGroups != nil {
		ruleGroupList := make([]ExclusionManagedRuleGroup, len(source.RuleGroups))
		for ruleGroupIndex, ruleGroupItem := range source.RuleGroups {
			// Shadow the loop variable to avoid aliasing
			ruleGroupItem := ruleGroupItem
			var ruleGroup ExclusionManagedRuleGroup
			err := ruleGroup.Initialize_From_ExclusionManagedRuleGroup_STATUS(&ruleGroupItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ExclusionManagedRuleGroup_STATUS() to populate field RuleGroups")
			}
			ruleGroupList[ruleGroupIndex] = ruleGroup
		}
		ruleSet.RuleGroups = ruleGroupList
	} else {
		ruleSet.RuleGroups = nil
	}

	// RuleSetType
	ruleSet.RuleSetType = genruntime.ClonePointerToString(source.RuleSetType)

	// RuleSetVersion
	ruleSet.RuleSetVersion = genruntime.ClonePointerToString(source.RuleSetVersion)

	// No error
	return nil
}

// Defines a managed rule set for Exclusions.
type ExclusionManagedRuleSet_STATUS struct {
	// RuleGroups: Defines the rule groups to apply to the rule set.
	RuleGroups []ExclusionManagedRuleGroup_STATUS `json:"ruleGroups,omitempty"`

	// RuleSetType: Defines the rule set type to use.
	RuleSetType *string `json:"ruleSetType,omitempty"`

	// RuleSetVersion: Defines the version of the rule set to use.
	RuleSetVersion *string `json:"ruleSetVersion,omitempty"`
}

var _ genruntime.FromARMConverter = &ExclusionManagedRuleSet_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (ruleSet *ExclusionManagedRuleSet_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ExclusionManagedRuleSet_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (ruleSet *ExclusionManagedRuleSet_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ExclusionManagedRuleSet_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ExclusionManagedRuleSet_STATUS, got %T", armInput)
	}

	// Set property "RuleGroups":
	for _, item := range typedInput.RuleGroups {
		var item1 ExclusionManagedRuleGroup_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		ruleSet.RuleGroups = append(ruleSet.RuleGroups, item1)
	}

	// Set property "RuleSetType":
	if typedInput.RuleSetType != nil {
		ruleSetType := *typedInput.RuleSetType
		ruleSet.RuleSetType = &ruleSetType
	}

	// Set property "RuleSetVersion":
	if typedInput.RuleSetVersion != nil {
		ruleSetVersion := *typedInput.RuleSetVersion
		ruleSet.RuleSetVersion = &ruleSetVersion
	}

	// No error
	return nil
}

// AssignProperties_From_ExclusionManagedRuleSet_STATUS populates our ExclusionManagedRuleSet_STATUS from the provided source ExclusionManagedRuleSet_STATUS
func (ruleSet *ExclusionManagedRuleSet_STATUS) AssignProperties_From_ExclusionManagedRuleSet_STATUS(source *storage.ExclusionManagedRuleSet_STATUS) error {

	// RuleGroups
	if source.RuleGroups != nil {
		ruleGroupList := make([]ExclusionManagedRuleGroup_STATUS, len(source.RuleGroups))
		for ruleGroupIndex, ruleGroupItem := range source.RuleGroups {
			// Shadow the loop variable to avoid aliasing
			ruleGroupItem := ruleGroupItem
			var ruleGroup ExclusionManagedRuleGroup_STATUS
			err := ruleGroup.AssignProperties_From_ExclusionManagedRuleGroup_STATUS(&ruleGroupItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ExclusionManagedRuleGroup_STATUS() to populate field RuleGroups")
			}
			ruleGroupList[ruleGroupIndex] = ruleGroup
		}
		ruleSet.RuleGroups = ruleGroupList
	} else {
		ruleSet.RuleGroups = nil
	}

	// RuleSetType
	ruleSet.RuleSetType = genruntime.ClonePointerToString(source.RuleSetType)

	// RuleSetVersion
	ruleSet.RuleSetVersion = genruntime.ClonePointerToString(source.RuleSetVersion)

	// No error
	return nil
}

// AssignProperties_To_ExclusionManagedRuleSet_STATUS populates the provided destination ExclusionManagedRuleSet_STATUS from our ExclusionManagedRuleSet_STATUS
func (ruleSet *ExclusionManagedRuleSet_STATUS) AssignProperties_To_ExclusionManagedRuleSet_STATUS(destination *storage.ExclusionManagedRuleSet_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RuleGroups
	if ruleSet.RuleGroups != nil {
		ruleGroupList := make([]storage.ExclusionManagedRuleGroup_STATUS, len(ruleSet.RuleGroups))
		for ruleGroupIndex, ruleGroupItem := range ruleSet.RuleGroups {
			// Shadow the loop variable to avoid aliasing
			ruleGroupItem := ruleGroupItem
			var ruleGroup storage.ExclusionManagedRuleGroup_STATUS
			err := ruleGroupItem.AssignProperties_To_ExclusionManagedRuleGroup_STATUS(&ruleGroup)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ExclusionManagedRuleGroup_STATUS() to populate field RuleGroups")
			}
			ruleGroupList[ruleGroupIndex] = ruleGroup
		}
		destination.RuleGroups = ruleGroupList
	} else {
		destination.RuleGroups = nil
	}

	// RuleSetType
	destination.RuleSetType = genruntime.ClonePointerToString(ruleSet.RuleSetType)

	// RuleSetVersion
	destination.RuleSetVersion = genruntime.ClonePointerToString(ruleSet.RuleSetVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Define user session group by clause variables.
type GroupByVariable struct {
	// +kubebuilder:validation:Required
	// VariableName: User Session clause variable.
	VariableName *GroupByVariable_VariableName `json:"variableName,omitempty"`
}

var _ genruntime.ARMTransformer = &GroupByVariable{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (variable *GroupByVariable) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if variable == nil {
		return nil, nil
	}
	result := &arm.GroupByVariable{}

	// Set property "VariableName":
	if variable.VariableName != nil {
		var temp string
		temp = string(*variable.VariableName)
		variableName := arm.GroupByVariable_VariableName(temp)
		result.VariableName = &variableName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (variable *GroupByVariable) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.GroupByVariable{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (variable *GroupByVariable) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.GroupByVariable)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.GroupByVariable, got %T", armInput)
	}

	// Set property "VariableName":
	if typedInput.VariableName != nil {
		var temp string
		temp = string(*typedInput.VariableName)
		variableName := GroupByVariable_VariableName(temp)
		variable.VariableName = &variableName
	}

	// No error
	return nil
}

// AssignProperties_From_GroupByVariable populates our GroupByVariable from the provided source GroupByVariable
func (variable *GroupByVariable) AssignProperties_From_GroupByVariable(source *storage.GroupByVariable) error {

	// VariableName
	if source.VariableName != nil {
		variableName := *source.VariableName
		variableNameTemp := genruntime.ToEnum(variableName, groupByVariable_VariableName_Values)
		variable.VariableName = &variableNameTemp
	} else {
		variable.VariableName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_GroupByVariable populates the provided destination GroupByVariable from our GroupByVariable
func (variable *GroupByVariable) AssignProperties_To_GroupByVariable(destination *storage.GroupByVariable) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// VariableName
	if variable.VariableName != nil {
		variableName := string(*variable.VariableName)
		destination.VariableName = &variableName
	} else {
		destination.VariableName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_GroupByVariable_STATUS populates our GroupByVariable from the provided source GroupByVariable_STATUS
func (variable *GroupByVariable) Initialize_From_GroupByVariable_STATUS(source *GroupByVariable_STATUS) error {

	// VariableName
	if source.VariableName != nil {
		variableName := genruntime.ToEnum(string(*source.VariableName), groupByVariable_VariableName_Values)
		variable.VariableName = &variableName
	} else {
		variable.VariableName = nil
	}

	// No error
	return nil
}

// Define user session group by clause variables.
type GroupByVariable_STATUS struct {
	// VariableName: User Session clause variable.
	VariableName *GroupByVariable_VariableName_STATUS `json:"variableName,omitempty"`
}

var _ genruntime.FromARMConverter = &GroupByVariable_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (variable *GroupByVariable_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.GroupByVariable_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (variable *GroupByVariable_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.GroupByVariable_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.GroupByVariable_STATUS, got %T", armInput)
	}

	// Set property "VariableName":
	if typedInput.VariableName != nil {
		var temp string
		temp = string(*typedInput.VariableName)
		variableName := GroupByVariable_VariableName_STATUS(temp)
		variable.VariableName = &variableName
	}

	// No error
	return nil
}

// AssignProperties_From_GroupByVariable_STATUS populates our GroupByVariable_STATUS from the provided source GroupByVariable_STATUS
func (variable *GroupByVariable_STATUS) AssignProperties_From_GroupByVariable_STATUS(source *storage.GroupByVariable_STATUS) error {

	// VariableName
	if source.VariableName != nil {
		variableName := *source.VariableName
		variableNameTemp := genruntime.ToEnum(variableName, groupByVariable_VariableName_STATUS_Values)
		variable.VariableName = &variableNameTemp
	} else {
		variable.VariableName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_GroupByVariable_STATUS populates the provided destination GroupByVariable_STATUS from our GroupByVariable_STATUS
func (variable *GroupByVariable_STATUS) AssignProperties_To_GroupByVariable_STATUS(destination *storage.GroupByVariable_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// VariableName
	if variable.VariableName != nil {
		variableName := string(*variable.VariableName)
		destination.VariableName = &variableName
	} else {
		destination.VariableName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines a managed rule group override setting.
type ManagedRuleGroupOverride struct {
	// +kubebuilder:validation:Required
	// RuleGroupName: The managed rule group to override.
	RuleGroupName *string `json:"ruleGroupName,omitempty"`

	// Rules: List of rules that will be disabled. If none specified, all rules in the group will be disabled.
	Rules []ManagedRuleOverride `json:"rules,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedRuleGroupOverride{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (override *ManagedRuleGroupOverride) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if override == nil {
		return nil, nil
	}
	result := &arm.ManagedRuleGroupOverride{}

	// Set property "RuleGroupName":
	if override.RuleGroupName != nil {
		ruleGroupName := *override.RuleGroupName
		result.RuleGroupName = &ruleGroupName
	}

	// Set property "Rules":
	for _, item := range override.Rules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Rules = append(result.Rules, *item_ARM.(*arm.ManagedRuleOverride))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (override *ManagedRuleGroupOverride) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedRuleGroupOverride{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (override *ManagedRuleGroupOverride) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedRuleGroupOverride)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedRuleGroupOverride, got %T", armInput)
	}

	// Set property "RuleGroupName":
	if typedInput.RuleGroupName != nil {
		ruleGroupName := *typedInput.RuleGroupName
		override.RuleGroupName = &ruleGroupName
	}

	// Set property "Rules":
	for _, item := range typedInput.Rules {
		var item1 ManagedRuleOverride
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		override.Rules = append(override.Rules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedRuleGroupOverride populates our ManagedRuleGroupOverride from the provided source ManagedRuleGroupOverride
func (override *ManagedRuleGroupOverride) AssignProperties_From_ManagedRuleGroupOverride(source *storage.ManagedRuleGroupOverride) error {

	// RuleGroupName
	override.RuleGroupName = genruntime.ClonePointerToString(source.RuleGroupName)

	// Rules
	if source.Rules != nil {
		ruleList := make([]ManagedRuleOverride, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule ManagedRuleOverride
			err := rule.AssignProperties_From_ManagedRuleOverride(&ruleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedRuleOverride() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		override.Rules = ruleList
	} else {
		override.Rules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedRuleGroupOverride populates the provided destination ManagedRuleGroupOverride from our ManagedRuleGroupOverride
func (override *ManagedRuleGroupOverride) AssignProperties_To_ManagedRuleGroupOverride(destination *storage.ManagedRuleGroupOverride) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RuleGroupName
	destination.RuleGroupName = genruntime.ClonePointerToString(override.RuleGroupName)

	// Rules
	if override.Rules != nil {
		ruleList := make([]storage.ManagedRuleOverride, len(override.Rules))
		for ruleIndex, ruleItem := range override.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule storage.ManagedRuleOverride
			err := ruleItem.AssignProperties_To_ManagedRuleOverride(&rule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedRuleOverride() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ManagedRuleGroupOverride_STATUS populates our ManagedRuleGroupOverride from the provided source ManagedRuleGroupOverride_STATUS
func (override *ManagedRuleGroupOverride) Initialize_From_ManagedRuleGroupOverride_STATUS(source *ManagedRuleGroupOverride_STATUS) error {

	// RuleGroupName
	override.RuleGroupName = genruntime.ClonePointerToString(source.RuleGroupName)

	// Rules
	if source.Rules != nil {
		ruleList := make([]ManagedRuleOverride, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule ManagedRuleOverride
			err := rule.Initialize_From_ManagedRuleOverride_STATUS(&ruleItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ManagedRuleOverride_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		override.Rules = ruleList
	} else {
		override.Rules = nil
	}

	// No error
	return nil
}

// Defines a managed rule group override setting.
type ManagedRuleGroupOverride_STATUS struct {
	// RuleGroupName: The managed rule group to override.
	RuleGroupName *string `json:"ruleGroupName,omitempty"`

	// Rules: List of rules that will be disabled. If none specified, all rules in the group will be disabled.
	Rules []ManagedRuleOverride_STATUS `json:"rules,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedRuleGroupOverride_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (override *ManagedRuleGroupOverride_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedRuleGroupOverride_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (override *ManagedRuleGroupOverride_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedRuleGroupOverride_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedRuleGroupOverride_STATUS, got %T", armInput)
	}

	// Set property "RuleGroupName":
	if typedInput.RuleGroupName != nil {
		ruleGroupName := *typedInput.RuleGroupName
		override.RuleGroupName = &ruleGroupName
	}

	// Set property "Rules":
	for _, item := range typedInput.Rules {
		var item1 ManagedRuleOverride_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		override.Rules = append(override.Rules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedRuleGroupOverride_STATUS populates our ManagedRuleGroupOverride_STATUS from the provided source ManagedRuleGroupOverride_STATUS
func (override *ManagedRuleGroupOverride_STATUS) AssignProperties_From_ManagedRuleGroupOverride_STATUS(source *storage.ManagedRuleGroupOverride_STATUS) error {

	// RuleGroupName
	override.RuleGroupName = genruntime.ClonePointerToString(source.RuleGroupName)

	// Rules
	if source.Rules != nil {
		ruleList := make([]ManagedRuleOverride_STATUS, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule ManagedRuleOverride_STATUS
			err := rule.AssignProperties_From_ManagedRuleOverride_STATUS(&ruleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedRuleOverride_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		override.Rules = ruleList
	} else {
		override.Rules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedRuleGroupOverride_STATUS populates the provided destination ManagedRuleGroupOverride_STATUS from our ManagedRuleGroupOverride_STATUS
func (override *ManagedRuleGroupOverride_STATUS) AssignProperties_To_ManagedRuleGroupOverride_STATUS(destination *storage.ManagedRuleGroupOverride_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RuleGroupName
	destination.RuleGroupName = genruntime.ClonePointerToString(override.RuleGroupName)

	// Rules
	if override.Rules != nil {
		ruleList := make([]storage.ManagedRuleOverride_STATUS, len(override.Rules))
		for ruleIndex, ruleItem := range override.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule storage.ManagedRuleOverride_STATUS
			err := ruleItem.AssignProperties_To_ManagedRuleOverride_STATUS(&rule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedRuleOverride_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Any","BeginsWith","Contains","EndsWith","Equal","GeoMatch","GreaterThan","GreaterThanOrEqual","IPMatch","LessThan","LessThanOrEqual","Regex"}
type MatchCondition_Operator string

const (
	MatchCondition_Operator_Any                = MatchCondition_Operator("Any")
	MatchCondition_Operator_BeginsWith         = MatchCondition_Operator("BeginsWith")
	MatchCondition_Operator_Contains           = MatchCondition_Operator("Contains")
	MatchCondition_Operator_EndsWith           = MatchCondition_Operator("EndsWith")
	MatchCondition_Operator_Equal              = MatchCondition_Operator("Equal")
	MatchCondition_Operator_GeoMatch           = MatchCondition_Operator("GeoMatch")
	MatchCondition_Operator_GreaterThan        = MatchCondition_Operator("GreaterThan")
	MatchCondition_Operator_GreaterThanOrEqual = MatchCondition_Operator("GreaterThanOrEqual")
	MatchCondition_Operator_IPMatch            = MatchCondition_Operator("IPMatch")
	MatchCondition_Operator_LessThan           = MatchCondition_Operator("LessThan")
	MatchCondition_Operator_LessThanOrEqual    = MatchCondition_Operator("LessThanOrEqual")
	MatchCondition_Operator_Regex              = MatchCondition_Operator("Regex")
)

// Mapping from string to MatchCondition_Operator
var matchCondition_Operator_Values = map[string]MatchCondition_Operator{
	"any":                MatchCondition_Operator_Any,
	"beginswith":         MatchCondition_Operator_BeginsWith,
	"contains":           MatchCondition_Operator_Contains,
	"endswith":           MatchCondition_Operator_EndsWith,
	"equal":              MatchCondition_Operator_Equal,
	"geomatch":           MatchCondition_Operator_GeoMatch,
	"greaterthan":        MatchCondition_Operator_GreaterThan,
	"greaterthanorequal": MatchCondition_Operator_GreaterThanOrEqual,
	"ipmatch":            MatchCondition_Operator_IPMatch,
	"lessthan":           MatchCondition_Operator_LessThan,
	"lessthanorequal":    MatchCondition_Operator_LessThanOrEqual,
	"regex":              MatchCondition_Operator_Regex,
}

type MatchCondition_Operator_STATUS string

const (
	MatchCondition_Operator_STATUS_Any                = MatchCondition_Operator_STATUS("Any")
	MatchCondition_Operator_STATUS_BeginsWith         = MatchCondition_Operator_STATUS("BeginsWith")
	MatchCondition_Operator_STATUS_Contains           = MatchCondition_Operator_STATUS("Contains")
	MatchCondition_Operator_STATUS_EndsWith           = MatchCondition_Operator_STATUS("EndsWith")
	MatchCondition_Operator_STATUS_Equal              = MatchCondition_Operator_STATUS("Equal")
	MatchCondition_Operator_STATUS_GeoMatch           = MatchCondition_Operator_STATUS("GeoMatch")
	MatchCondition_Operator_STATUS_GreaterThan        = MatchCondition_Operator_STATUS("GreaterThan")
	MatchCondition_Operator_STATUS_GreaterThanOrEqual = MatchCondition_Operator_STATUS("GreaterThanOrEqual")
	MatchCondition_Operator_STATUS_IPMatch            = MatchCondition_Operator_STATUS("IPMatch")
	MatchCondition_Operator_STATUS_LessThan           = MatchCondition_Operator_STATUS("LessThan")
	MatchCondition_Operator_STATUS_LessThanOrEqual    = MatchCondition_Operator_STATUS("LessThanOrEqual")
	MatchCondition_Operator_STATUS_Regex              = MatchCondition_Operator_STATUS("Regex")
)

// Mapping from string to MatchCondition_Operator_STATUS
var matchCondition_Operator_STATUS_Values = map[string]MatchCondition_Operator_STATUS{
	"any":                MatchCondition_Operator_STATUS_Any,
	"beginswith":         MatchCondition_Operator_STATUS_BeginsWith,
	"contains":           MatchCondition_Operator_STATUS_Contains,
	"endswith":           MatchCondition_Operator_STATUS_EndsWith,
	"equal":              MatchCondition_Operator_STATUS_Equal,
	"geomatch":           MatchCondition_Operator_STATUS_GeoMatch,
	"greaterthan":        MatchCondition_Operator_STATUS_GreaterThan,
	"greaterthanorequal": MatchCondition_Operator_STATUS_GreaterThanOrEqual,
	"ipmatch":            MatchCondition_Operator_STATUS_IPMatch,
	"lessthan":           MatchCondition_Operator_STATUS_LessThan,
	"lessthanorequal":    MatchCondition_Operator_STATUS_LessThanOrEqual,
	"regex":              MatchCondition_Operator_STATUS_Regex,
}

// Define match variables.
type MatchVariable struct {
	// Selector: The selector of match variable.
	Selector *string `json:"selector,omitempty"`

	// +kubebuilder:validation:Required
	// VariableName: Match Variable.
	VariableName *MatchVariable_VariableName `json:"variableName,omitempty"`
}

var _ genruntime.ARMTransformer = &MatchVariable{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (variable *MatchVariable) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if variable == nil {
		return nil, nil
	}
	result := &arm.MatchVariable{}

	// Set property "Selector":
	if variable.Selector != nil {
		selector := *variable.Selector
		result.Selector = &selector
	}

	// Set property "VariableName":
	if variable.VariableName != nil {
		var temp string
		temp = string(*variable.VariableName)
		variableName := arm.MatchVariable_VariableName(temp)
		result.VariableName = &variableName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (variable *MatchVariable) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.MatchVariable{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (variable *MatchVariable) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.MatchVariable)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.MatchVariable, got %T", armInput)
	}

	// Set property "Selector":
	if typedInput.Selector != nil {
		selector := *typedInput.Selector
		variable.Selector = &selector
	}

	// Set property "VariableName":
	if typedInput.VariableName != nil {
		var temp string
		temp = string(*typedInput.VariableName)
		variableName := MatchVariable_VariableName(temp)
		variable.VariableName = &variableName
	}

	// No error
	return nil
}

// AssignProperties_From_MatchVariable populates our MatchVariable from the provided source MatchVariable
func (variable *MatchVariable) AssignProperties_From_MatchVariable(source *storage.MatchVariable) error {

	// Selector
	variable.Selector = genruntime.ClonePointerToString(source.Selector)

	// VariableName
	if source.VariableName != nil {
		variableName := *source.VariableName
		variableNameTemp := genruntime.ToEnum(variableName, matchVariable_VariableName_Values)
		variable.VariableName = &variableNameTemp
	} else {
		variable.VariableName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_MatchVariable populates the provided destination MatchVariable from our MatchVariable
func (variable *MatchVariable) AssignProperties_To_MatchVariable(destination *storage.MatchVariable) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Selector
	destination.Selector = genruntime.ClonePointerToString(variable.Selector)

	// VariableName
	if variable.VariableName != nil {
		variableName := string(*variable.VariableName)
		destination.VariableName = &variableName
	} else {
		destination.VariableName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_MatchVariable_STATUS populates our MatchVariable from the provided source MatchVariable_STATUS
func (variable *MatchVariable) Initialize_From_MatchVariable_STATUS(source *MatchVariable_STATUS) error {

	// Selector
	variable.Selector = genruntime.ClonePointerToString(source.Selector)

	// VariableName
	if source.VariableName != nil {
		variableName := genruntime.ToEnum(string(*source.VariableName), matchVariable_VariableName_Values)
		variable.VariableName = &variableName
	} else {
		variable.VariableName = nil
	}

	// No error
	return nil
}

// Define match variables.
type MatchVariable_STATUS struct {
	// Selector: The selector of match variable.
	Selector *string `json:"selector,omitempty"`

	// VariableName: Match Variable.
	VariableName *MatchVariable_VariableName_STATUS `json:"variableName,omitempty"`
}

var _ genruntime.FromARMConverter = &MatchVariable_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (variable *MatchVariable_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.MatchVariable_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (variable *MatchVariable_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.MatchVariable_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.MatchVariable_STATUS, got %T", armInput)
	}

	// Set property "Selector":
	if typedInput.Selector != nil {
		selector := *typedInput.Selector
		variable.Selector = &selector
	}

	// Set property "VariableName":
	if typedInput.VariableName != nil {
		var temp string
		temp = string(*typedInput.VariableName)
		variableName := MatchVariable_VariableName_STATUS(temp)
		variable.VariableName = &variableName
	}

	// No error
	return nil
}

// AssignProperties_From_MatchVariable_STATUS populates our MatchVariable_STATUS from the provided source MatchVariable_STATUS
func (variable *MatchVariable_STATUS) AssignProperties_From_MatchVariable_STATUS(source *storage.MatchVariable_STATUS) error {

	// Selector
	variable.Selector = genruntime.ClonePointerToString(source.Selector)

	// VariableName
	if source.VariableName != nil {
		variableName := *source.VariableName
		variableNameTemp := genruntime.ToEnum(variableName, matchVariable_VariableName_STATUS_Values)
		variable.VariableName = &variableNameTemp
	} else {
		variable.VariableName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_MatchVariable_STATUS populates the provided destination MatchVariable_STATUS from our MatchVariable_STATUS
func (variable *MatchVariable_STATUS) AssignProperties_To_MatchVariable_STATUS(destination *storage.MatchVariable_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Selector
	destination.Selector = genruntime.ClonePointerToString(variable.Selector)

	// VariableName
	if variable.VariableName != nil {
		variableName := string(*variable.VariableName)
		destination.VariableName = &variableName
	} else {
		destination.VariableName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"RequestArgKeys","RequestArgNames","RequestArgValues","RequestCookieKeys","RequestCookieNames","RequestCookieValues","RequestHeaderKeys","RequestHeaderNames","RequestHeaderValues"}
type OwaspCrsExclusionEntry_MatchVariable string

const (
	OwaspCrsExclusionEntry_MatchVariable_RequestArgKeys      = OwaspCrsExclusionEntry_MatchVariable("RequestArgKeys")
	OwaspCrsExclusionEntry_MatchVariable_RequestArgNames     = OwaspCrsExclusionEntry_MatchVariable("RequestArgNames")
	OwaspCrsExclusionEntry_MatchVariable_RequestArgValues    = OwaspCrsExclusionEntry_MatchVariable("RequestArgValues")
	OwaspCrsExclusionEntry_MatchVariable_RequestCookieKeys   = OwaspCrsExclusionEntry_MatchVariable("RequestCookieKeys")
	OwaspCrsExclusionEntry_MatchVariable_RequestCookieNames  = OwaspCrsExclusionEntry_MatchVariable("RequestCookieNames")
	OwaspCrsExclusionEntry_MatchVariable_RequestCookieValues = OwaspCrsExclusionEntry_MatchVariable("RequestCookieValues")
	OwaspCrsExclusionEntry_MatchVariable_RequestHeaderKeys   = OwaspCrsExclusionEntry_MatchVariable("RequestHeaderKeys")
	OwaspCrsExclusionEntry_MatchVariable_RequestHeaderNames  = OwaspCrsExclusionEntry_MatchVariable("RequestHeaderNames")
	OwaspCrsExclusionEntry_MatchVariable_RequestHeaderValues = OwaspCrsExclusionEntry_MatchVariable("RequestHeaderValues")
)

// Mapping from string to OwaspCrsExclusionEntry_MatchVariable
var owaspCrsExclusionEntry_MatchVariable_Values = map[string]OwaspCrsExclusionEntry_MatchVariable{
	"requestargkeys":      OwaspCrsExclusionEntry_MatchVariable_RequestArgKeys,
	"requestargnames":     OwaspCrsExclusionEntry_MatchVariable_RequestArgNames,
	"requestargvalues":    OwaspCrsExclusionEntry_MatchVariable_RequestArgValues,
	"requestcookiekeys":   OwaspCrsExclusionEntry_MatchVariable_RequestCookieKeys,
	"requestcookienames":  OwaspCrsExclusionEntry_MatchVariable_RequestCookieNames,
	"requestcookievalues": OwaspCrsExclusionEntry_MatchVariable_RequestCookieValues,
	"requestheaderkeys":   OwaspCrsExclusionEntry_MatchVariable_RequestHeaderKeys,
	"requestheadernames":  OwaspCrsExclusionEntry_MatchVariable_RequestHeaderNames,
	"requestheadervalues": OwaspCrsExclusionEntry_MatchVariable_RequestHeaderValues,
}

type OwaspCrsExclusionEntry_MatchVariable_STATUS string

const (
	OwaspCrsExclusionEntry_MatchVariable_STATUS_RequestArgKeys      = OwaspCrsExclusionEntry_MatchVariable_STATUS("RequestArgKeys")
	OwaspCrsExclusionEntry_MatchVariable_STATUS_RequestArgNames     = OwaspCrsExclusionEntry_MatchVariable_STATUS("RequestArgNames")
	OwaspCrsExclusionEntry_MatchVariable_STATUS_RequestArgValues    = OwaspCrsExclusionEntry_MatchVariable_STATUS("RequestArgValues")
	OwaspCrsExclusionEntry_MatchVariable_STATUS_RequestCookieKeys   = OwaspCrsExclusionEntry_MatchVariable_STATUS("RequestCookieKeys")
	OwaspCrsExclusionEntry_MatchVariable_STATUS_RequestCookieNames  = OwaspCrsExclusionEntry_MatchVariable_STATUS("RequestCookieNames")
	OwaspCrsExclusionEntry_MatchVariable_STATUS_RequestCookieValues = OwaspCrsExclusionEntry_MatchVariable_STATUS("RequestCookieValues")
	OwaspCrsExclusionEntry_MatchVariable_STATUS_RequestHeaderKeys   = OwaspCrsExclusionEntry_MatchVariable_STATUS("RequestHeaderKeys")
	OwaspCrsExclusionEntry_MatchVariable_STATUS_RequestHeaderNames  = OwaspCrsExclusionEntry_MatchVariable_STATUS("RequestHeaderNames")
	OwaspCrsExclusionEntry_MatchVariable_STATUS_RequestHeaderValues = OwaspCrsExclusionEntry_MatchVariable_STATUS("RequestHeaderValues")
)

// Mapping from string to OwaspCrsExclusionEntry_MatchVariable_STATUS
var owaspCrsExclusionEntry_MatchVariable_STATUS_Values = map[string]OwaspCrsExclusionEntry_MatchVariable_STATUS{
	"requestargkeys":      OwaspCrsExclusionEntry_MatchVariable_STATUS_RequestArgKeys,
	"requestargnames":     OwaspCrsExclusionEntry_MatchVariable_STATUS_RequestArgNames,
	"requestargvalues":    OwaspCrsExclusionEntry_MatchVariable_STATUS_RequestArgValues,
	"requestcookiekeys":   OwaspCrsExclusionEntry_MatchVariable_STATUS_RequestCookieKeys,
	"requestcookienames":  OwaspCrsExclusionEntry_MatchVariable_STATUS_RequestCookieNames,
	"requestcookievalues": OwaspCrsExclusionEntry_MatchVariable_STATUS_RequestCookieValues,
	"requestheaderkeys":   OwaspCrsExclusionEntry_MatchVariable_STATUS_RequestHeaderKeys,
	"requestheadernames":  OwaspCrsExclusionEntry_MatchVariable_STATUS_RequestHeaderNames,
	"requestheadervalues": OwaspCrsExclusionEntry_MatchVariable_STATUS_RequestHeaderValues,
}

// +kubebuilder:validation:Enum={"Contains","EndsWith","Equals","EqualsAny","StartsWith"}
type OwaspCrsExclusionEntry_SelectorMatchOperator string

const (
	OwaspCrsExclusionEntry_SelectorMatchOperator_Contains   = OwaspCrsExclusionEntry_SelectorMatchOperator("Contains")
	OwaspCrsExclusionEntry_SelectorMatchOperator_EndsWith   = OwaspCrsExclusionEntry_SelectorMatchOperator("EndsWith")
	OwaspCrsExclusionEntry_SelectorMatchOperator_Equals     = OwaspCrsExclusionEntry_SelectorMatchOperator("Equals")
	OwaspCrsExclusionEntry_SelectorMatchOperator_EqualsAny  = OwaspCrsExclusionEntry_SelectorMatchOperator("EqualsAny")
	OwaspCrsExclusionEntry_SelectorMatchOperator_StartsWith = OwaspCrsExclusionEntry_SelectorMatchOperator("StartsWith")
)

// Mapping from string to OwaspCrsExclusionEntry_SelectorMatchOperator
var owaspCrsExclusionEntry_SelectorMatchOperator_Values = map[string]OwaspCrsExclusionEntry_SelectorMatchOperator{
	"contains":   OwaspCrsExclusionEntry_SelectorMatchOperator_Contains,
	"endswith":   OwaspCrsExclusionEntry_SelectorMatchOperator_EndsWith,
	"equals":     OwaspCrsExclusionEntry_SelectorMatchOperator_Equals,
	"equalsany":  OwaspCrsExclusionEntry_SelectorMatchOperator_EqualsAny,
	"startswith": OwaspCrsExclusionEntry_SelectorMatchOperator_StartsWith,
}

type OwaspCrsExclusionEntry_SelectorMatchOperator_STATUS string

const (
	OwaspCrsExclusionEntry_SelectorMatchOperator_STATUS_Contains   = OwaspCrsExclusionEntry_SelectorMatchOperator_STATUS("Contains")
	OwaspCrsExclusionEntry_SelectorMatchOperator_STATUS_EndsWith   = OwaspCrsExclusionEntry_SelectorMatchOperator_STATUS("EndsWith")
	OwaspCrsExclusionEntry_SelectorMatchOperator_STATUS_Equals     = OwaspCrsExclusionEntry_SelectorMatchOperator_STATUS("Equals")
	OwaspCrsExclusionEntry_SelectorMatchOperator_STATUS_EqualsAny  = OwaspCrsExclusionEntry_SelectorMatchOperator_STATUS("EqualsAny")
	OwaspCrsExclusionEntry_SelectorMatchOperator_STATUS_StartsWith = OwaspCrsExclusionEntry_SelectorMatchOperator_STATUS("StartsWith")
)

// Mapping from string to OwaspCrsExclusionEntry_SelectorMatchOperator_STATUS
var owaspCrsExclusionEntry_SelectorMatchOperator_STATUS_Values = map[string]OwaspCrsExclusionEntry_SelectorMatchOperator_STATUS{
	"contains":   OwaspCrsExclusionEntry_SelectorMatchOperator_STATUS_Contains,
	"endswith":   OwaspCrsExclusionEntry_SelectorMatchOperator_STATUS_EndsWith,
	"equals":     OwaspCrsExclusionEntry_SelectorMatchOperator_STATUS_Equals,
	"equalsany":  OwaspCrsExclusionEntry_SelectorMatchOperator_STATUS_EqualsAny,
	"startswith": OwaspCrsExclusionEntry_SelectorMatchOperator_STATUS_StartsWith,
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type PolicySettings_LogScrubbing_State string

const (
	PolicySettings_LogScrubbing_State_Disabled = PolicySettings_LogScrubbing_State("Disabled")
	PolicySettings_LogScrubbing_State_Enabled  = PolicySettings_LogScrubbing_State("Enabled")
)

// Mapping from string to PolicySettings_LogScrubbing_State
var policySettings_LogScrubbing_State_Values = map[string]PolicySettings_LogScrubbing_State{
	"disabled": PolicySettings_LogScrubbing_State_Disabled,
	"enabled":  PolicySettings_LogScrubbing_State_Enabled,
}

type PolicySettings_LogScrubbing_State_STATUS string

const (
	PolicySettings_LogScrubbing_State_STATUS_Disabled = PolicySettings_LogScrubbing_State_STATUS("Disabled")
	PolicySettings_LogScrubbing_State_STATUS_Enabled  = PolicySettings_LogScrubbing_State_STATUS("Enabled")
)

// Mapping from string to PolicySettings_LogScrubbing_State_STATUS
var policySettings_LogScrubbing_State_STATUS_Values = map[string]PolicySettings_LogScrubbing_State_STATUS{
	"disabled": PolicySettings_LogScrubbing_State_STATUS_Disabled,
	"enabled":  PolicySettings_LogScrubbing_State_STATUS_Enabled,
}

// Transforms applied before matching.
// +kubebuilder:validation:Enum={"HtmlEntityDecode","Lowercase","RemoveNulls","Trim","Uppercase","UrlDecode","UrlEncode"}
type Transform string

const (
	Transform_HtmlEntityDecode = Transform("HtmlEntityDecode")
	Transform_Lowercase        = Transform("Lowercase")
	Transform_RemoveNulls      = Transform("RemoveNulls")
	Transform_Trim             = Transform("Trim")
	Transform_Uppercase        = Transform("Uppercase")
	Transform_UrlDecode        = Transform("UrlDecode")
	Transform_UrlEncode        = Transform("UrlEncode")
)

// Mapping from string to Transform
var transform_Values = map[string]Transform{
	"htmlentitydecode": Transform_HtmlEntityDecode,
	"lowercase":        Transform_Lowercase,
	"removenulls":      Transform_RemoveNulls,
	"trim":             Transform_Trim,
	"uppercase":        Transform_Uppercase,
	"urldecode":        Transform_UrlDecode,
	"urlencode":        Transform_UrlEncode,
}

// Transforms applied before matching.
type Transform_STATUS string

const (
	Transform_STATUS_HtmlEntityDecode = Transform_STATUS("HtmlEntityDecode")
	Transform_STATUS_Lowercase        = Transform_STATUS("Lowercase")
	Transform_STATUS_RemoveNulls      = Transform_STATUS("RemoveNulls")
	Transform_STATUS_Trim             = Transform_STATUS("Trim")
	Transform_STATUS_Uppercase        = Transform_STATUS("Uppercase")
	Transform_STATUS_UrlDecode        = Transform_STATUS("UrlDecode")
	Transform_STATUS_UrlEncode        = Transform_STATUS("UrlEncode")
)

// Mapping from string to Transform_STATUS
var transform_STATUS_Values = map[string]Transform_STATUS{
	"htmlentitydecode": Transform_STATUS_HtmlEntityDecode,
	"lowercase":        Transform_STATUS_Lowercase,
	"removenulls":      Transform_STATUS_RemoveNulls,
	"trim":             Transform_STATUS_Trim,
	"uppercase":        Transform_STATUS_Uppercase,
	"urldecode":        Transform_STATUS_UrlDecode,
	"urlencode":        Transform_STATUS_UrlEncode,
}

// Allow certain variables to be scrubbed on WAF logs
type WebApplicationFirewallScrubbingRules struct {
	// +kubebuilder:validation:Required
	// MatchVariable: The variable to be scrubbed from the logs.
	MatchVariable *WebApplicationFirewallScrubbingRules_MatchVariable `json:"matchVariable,omitempty"`

	// Selector: When matchVariable is a collection, operator used to specify which elements in the collection this rule
	// applies to.
	Selector *string `json:"selector,omitempty"`

	// +kubebuilder:validation:Required
	// SelectorMatchOperator: When matchVariable is a collection, operate on the selector to specify which elements in the
	// collection this rule applies to.
	SelectorMatchOperator *WebApplicationFirewallScrubbingRules_SelectorMatchOperator `json:"selectorMatchOperator,omitempty"`

	// State: Defines the state of log scrubbing rule. Default value is Enabled.
	State *WebApplicationFirewallScrubbingRules_State `json:"state,omitempty"`
}

var _ genruntime.ARMTransformer = &WebApplicationFirewallScrubbingRules{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rules *WebApplicationFirewallScrubbingRules) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rules == nil {
		return nil, nil
	}
	result := &arm.WebApplicationFirewallScrubbingRules{}

	// Set property "MatchVariable":
	if rules.MatchVariable != nil {
		var temp string
		temp = string(*rules.MatchVariable)
		matchVariable := arm.WebApplicationFirewallScrubbingRules_MatchVariable(temp)
		result.MatchVariable = &matchVariable
	}

	// Set property "Selector":
	if rules.Selector != nil {
		selector := *rules.Selector
		result.Selector = &selector
	}

	// Set property "SelectorMatchOperator":
	if rules.SelectorMatchOperator != nil {
		var temp string
		temp = string(*rules.SelectorMatchOperator)
		selectorMatchOperator := arm.WebApplicationFirewallScrubbingRules_SelectorMatchOperator(temp)
		result.SelectorMatchOperator = &selectorMatchOperator
	}

	// Set property "State":
	if rules.State != nil {
		var temp string
		temp = string(*rules.State)
		state := arm.WebApplicationFirewallScrubbingRules_State(temp)
		result.State = &state
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rules *WebApplicationFirewallScrubbingRules) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WebApplicationFirewallScrubbingRules{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rules *WebApplicationFirewallScrubbingRules) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WebApplicationFirewallScrubbingRules)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WebApplicationFirewallScrubbingRules, got %T", armInput)
	}

	// Set property "MatchVariable":
	if typedInput.MatchVariable != nil {
		var temp string
		temp = string(*typedInput.MatchVariable)
		matchVariable := WebApplicationFirewallScrubbingRules_MatchVariable(temp)
		rules.MatchVariable = &matchVariable
	}

	// Set property "Selector":
	if typedInput.Selector != nil {
		selector := *typedInput.Selector
		rules.Selector = &selector
	}

	// Set property "SelectorMatchOperator":
	if typedInput.SelectorMatchOperator != nil {
		var temp string
		temp = string(*typedInput.SelectorMatchOperator)
		selectorMatchOperator := WebApplicationFirewallScrubbingRules_SelectorMatchOperator(temp)
		rules.SelectorMatchOperator = &selectorMatchOperator
	}

	// Set property "State":
	if typedInput.State != nil {
		var temp string
		temp = string(*typedInput.State)
		state := WebApplicationFirewallScrubbingRules_State(temp)
		rules.State = &state
	}

	// No error
	return nil
}

// AssignProperties_From_WebApplicationFirewallScrubbingRules populates our WebApplicationFirewallScrubbingRules from the provided source WebApplicationFirewallScrubbingRules
func (rules *WebApplicationFirewallScrubbingRules) AssignProperties_From_WebApplicationFirewallScrubbingRules(source *storage.WebApplicationFirewallScrubbingRules) error {

	// MatchVariable
	if source.MatchVariable != nil {
		matchVariable := *source.MatchVariable
		matchVariableTemp := genruntime.ToEnum(matchVariable, webApplicationFirewallScrubbingRules_MatchVariable_Values)
		rules.MatchVariable = &matchVariableTemp
	} else {
		rules.MatchVariable = nil
	}

	// Selector
	rules.Selector = genruntime.ClonePointerToString(source.Selector)

	// SelectorMatchOperator
	if source.SelectorMatchOperator != nil {
		selectorMatchOperator := *source.SelectorMatchOperator
		selectorMatchOperatorTemp := genruntime.ToEnum(selectorMatchOperator, webApplicationFirewallScrubbingRules_SelectorMatchOperator_Values)
		rules.SelectorMatchOperator = &selectorMatchOperatorTemp
	} else {
		rules.SelectorMatchOperator = nil
	}

	// State
	if source.State != nil {
		state := *source.State
		stateTemp := genruntime.ToEnum(state, webApplicationFirewallScrubbingRules_State_Values)
		rules.State = &stateTemp
	} else {
		rules.State = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WebApplicationFirewallScrubbingRules populates the provided destination WebApplicationFirewallScrubbingRules from our WebApplicationFirewallScrubbingRules
func (rules *WebApplicationFirewallScrubbingRules) AssignProperties_To_WebApplicationFirewallScrubbingRules(destination *storage.WebApplicationFirewallScrubbingRules) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchVariable
	if rules.MatchVariable != nil {
		matchVariable := string(*rules.MatchVariable)
		destination.MatchVariable = &matchVariable
	} else {
		destination.MatchVariable = nil
	}

	// Selector
	destination.Selector = genruntime.ClonePointerToString(rules.Selector)

	// SelectorMatchOperator
	if rules.SelectorMatchOperator != nil {
		selectorMatchOperator := string(*rules.SelectorMatchOperator)
		destination.SelectorMatchOperator = &selectorMatchOperator
	} else {
		destination.SelectorMatchOperator = nil
	}

	// State
	if rules.State != nil {
		state := string(*rules.State)
		destination.State = &state
	} else {
		destination.State = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_WebApplicationFirewallScrubbingRules_STATUS populates our WebApplicationFirewallScrubbingRules from the provided source WebApplicationFirewallScrubbingRules_STATUS
func (rules *WebApplicationFirewallScrubbingRules) Initialize_From_WebApplicationFirewallScrubbingRules_STATUS(source *WebApplicationFirewallScrubbingRules_STATUS) error {

	// MatchVariable
	if source.MatchVariable != nil {
		matchVariable := genruntime.ToEnum(string(*source.MatchVariable), webApplicationFirewallScrubbingRules_MatchVariable_Values)
		rules.MatchVariable = &matchVariable
	} else {
		rules.MatchVariable = nil
	}

	// Selector
	rules.Selector = genruntime.ClonePointerToString(source.Selector)

	// SelectorMatchOperator
	if source.SelectorMatchOperator != nil {
		selectorMatchOperator := genruntime.ToEnum(string(*source.SelectorMatchOperator), webApplicationFirewallScrubbingRules_SelectorMatchOperator_Values)
		rules.SelectorMatchOperator = &selectorMatchOperator
	} else {
		rules.SelectorMatchOperator = nil
	}

	// State
	if source.State != nil {
		state := genruntime.ToEnum(string(*source.State), webApplicationFirewallScrubbingRules_State_Values)
		rules.State = &state
	} else {
		rules.State = nil
	}

	// No error
	return nil
}

// Allow certain variables to be scrubbed on WAF logs
type WebApplicationFirewallScrubbingRules_STATUS struct {
	// MatchVariable: The variable to be scrubbed from the logs.
	MatchVariable *WebApplicationFirewallScrubbingRules_MatchVariable_STATUS `json:"matchVariable,omitempty"`

	// Selector: When matchVariable is a collection, operator used to specify which elements in the collection this rule
	// applies to.
	Selector *string `json:"selector,omitempty"`

	// SelectorMatchOperator: When matchVariable is a collection, operate on the selector to specify which elements in the
	// collection this rule applies to.
	SelectorMatchOperator *WebApplicationFirewallScrubbingRules_SelectorMatchOperator_STATUS `json:"selectorMatchOperator,omitempty"`

	// State: Defines the state of log scrubbing rule. Default value is Enabled.
	State *WebApplicationFirewallScrubbingRules_State_STATUS `json:"state,omitempty"`
}

var _ genruntime.FromARMConverter = &WebApplicationFirewallScrubbingRules_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rules *WebApplicationFirewallScrubbingRules_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WebApplicationFirewallScrubbingRules_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rules *WebApplicationFirewallScrubbingRules_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WebApplicationFirewallScrubbingRules_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WebApplicationFirewallScrubbingRules_STATUS, got %T", armInput)
	}

	// Set property "MatchVariable":
	if typedInput.MatchVariable != nil {
		var temp string
		temp = string(*typedInput.MatchVariable)
		matchVariable := WebApplicationFirewallScrubbingRules_MatchVariable_STATUS(temp)
		rules.MatchVariable = &matchVariable
	}

	// Set property "Selector":
	if typedInput.Selector != nil {
		selector := *typedInput.Selector
		rules.Selector = &selector
	}

	// Set property "SelectorMatchOperator":
	if typedInput.SelectorMatchOperator != nil {
		var temp string
		temp = string(*typedInput.SelectorMatchOperator)
		selectorMatchOperator := WebApplicationFirewallScrubbingRules_SelectorMatchOperator_STATUS(temp)
		rules.SelectorMatchOperator = &selectorMatchOperator
	}

	// Set property "State":
	if typedInput.State != nil {
		var temp string
		temp = string(*typedInput.State)
		state := WebApplicationFirewallScrubbingRules_State_STATUS(temp)
		rules.State = &state
	}

	// No error
	return nil
}

// AssignProperties_From_WebApplicationFirewallScrubbingRules_STATUS populates our WebApplicationFirewallScrubbingRules_STATUS from the provided source WebApplicationFirewallScrubbingRules_STATUS
func (rules *WebApplicationFirewallScrubbingRules_STATUS) AssignProperties_From_WebApplicationFirewallScrubbingRules_STATUS(source *storage.WebApplicationFirewallScrubbingRules_STATUS) error {

	// MatchVariable
	if source.MatchVariable != nil {
		matchVariable := *source.MatchVariable
		matchVariableTemp := genruntime.ToEnum(matchVariable, webApplicationFirewallScrubbingRules_MatchVariable_STATUS_Values)
		rules.MatchVariable = &matchVariableTemp
	} else {
		rules.MatchVariable = nil
	}

	// Selector
	rules.Selector = genruntime.ClonePointerToString(source.Selector)

	// SelectorMatchOperator
	if source.SelectorMatchOperator != nil {
		selectorMatchOperator := *source.SelectorMatchOperator
		selectorMatchOperatorTemp := genruntime.ToEnum(selectorMatchOperator, webApplicationFirewallScrubbingRules_SelectorMatchOperator_STATUS_Values)
		rules.SelectorMatchOperator = &selectorMatchOperatorTemp
	} else {
		rules.SelectorMatchOperator = nil
	}

	// State
	if source.State != nil {
		state := *source.State
		stateTemp := genruntime.ToEnum(state, webApplicationFirewallScrubbingRules_State_STATUS_Values)
		rules.State = &stateTemp
	} else {
		rules.State = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WebApplicationFirewallScrubbingRules_STATUS populates the provided destination WebApplicationFirewallScrubbingRules_STATUS from our WebApplicationFirewallScrubbingRules_STATUS
func (rules *WebApplicationFirewallScrubbingRules_STATUS) AssignProperties_To_WebApplicationFirewallScrubbingRules_STATUS(destination *storage.WebApplicationFirewallScrubbingRules_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchVariable
	if rules.MatchVariable != nil {
		matchVariable := string(*rules.MatchVariable)
		destination.MatchVariable = &matchVariable
	} else {
		destination.MatchVariable = nil
	}

	// Selector
	destination.Selector = genruntime.ClonePointerToString(rules.Selector)

	// SelectorMatchOperator
	if rules.SelectorMatchOperator != nil {
		selectorMatchOperator := string(*rules.SelectorMatchOperator)
		destination.SelectorMatchOperator = &selectorMatchOperator
	} else {
		destination.SelectorMatchOperator = nil
	}

	// State
	if rules.State != nil {
		state := string(*rules.State)
		destination.State = &state
	} else {
		destination.State = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines a managed rule group to use for exclusion.
type ExclusionManagedRuleGroup struct {
	// +kubebuilder:validation:Required
	// RuleGroupName: The managed rule group for exclusion.
	RuleGroupName *string `json:"ruleGroupName,omitempty"`

	// Rules: List of rules that will be excluded. If none specified, all rules in the group will be excluded.
	Rules []ExclusionManagedRule `json:"rules,omitempty"`
}

var _ genruntime.ARMTransformer = &ExclusionManagedRuleGroup{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (group *ExclusionManagedRuleGroup) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if group == nil {
		return nil, nil
	}
	result := &arm.ExclusionManagedRuleGroup{}

	// Set property "RuleGroupName":
	if group.RuleGroupName != nil {
		ruleGroupName := *group.RuleGroupName
		result.RuleGroupName = &ruleGroupName
	}

	// Set property "Rules":
	for _, item := range group.Rules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Rules = append(result.Rules, *item_ARM.(*arm.ExclusionManagedRule))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (group *ExclusionManagedRuleGroup) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ExclusionManagedRuleGroup{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (group *ExclusionManagedRuleGroup) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ExclusionManagedRuleGroup)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ExclusionManagedRuleGroup, got %T", armInput)
	}

	// Set property "RuleGroupName":
	if typedInput.RuleGroupName != nil {
		ruleGroupName := *typedInput.RuleGroupName
		group.RuleGroupName = &ruleGroupName
	}

	// Set property "Rules":
	for _, item := range typedInput.Rules {
		var item1 ExclusionManagedRule
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		group.Rules = append(group.Rules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ExclusionManagedRuleGroup populates our ExclusionManagedRuleGroup from the provided source ExclusionManagedRuleGroup
func (group *ExclusionManagedRuleGroup) AssignProperties_From_ExclusionManagedRuleGroup(source *storage.ExclusionManagedRuleGroup) error {

	// RuleGroupName
	group.RuleGroupName = genruntime.ClonePointerToString(source.RuleGroupName)

	// Rules
	if source.Rules != nil {
		ruleList := make([]ExclusionManagedRule, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule ExclusionManagedRule
			err := rule.AssignProperties_From_ExclusionManagedRule(&ruleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ExclusionManagedRule() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		group.Rules = ruleList
	} else {
		group.Rules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ExclusionManagedRuleGroup populates the provided destination ExclusionManagedRuleGroup from our ExclusionManagedRuleGroup
func (group *ExclusionManagedRuleGroup) AssignProperties_To_ExclusionManagedRuleGroup(destination *storage.ExclusionManagedRuleGroup) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RuleGroupName
	destination.RuleGroupName = genruntime.ClonePointerToString(group.RuleGroupName)

	// Rules
	if group.Rules != nil {
		ruleList := make([]storage.ExclusionManagedRule, len(group.Rules))
		for ruleIndex, ruleItem := range group.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule storage.ExclusionManagedRule
			err := ruleItem.AssignProperties_To_ExclusionManagedRule(&rule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ExclusionManagedRule() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ExclusionManagedRuleGroup_STATUS populates our ExclusionManagedRuleGroup from the provided source ExclusionManagedRuleGroup_STATUS
func (group *ExclusionManagedRuleGroup) Initialize_From_ExclusionManagedRuleGroup_STATUS(source *ExclusionManagedRuleGroup_STATUS) error {

	// RuleGroupName
	group.RuleGroupName = genruntime.ClonePointerToString(source.RuleGroupName)

	// Rules
	if source.Rules != nil {
		ruleList := make([]ExclusionManagedRule, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule ExclusionManagedRule
			err := rule.Initialize_From_ExclusionManagedRule_STATUS(&ruleItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_ExclusionManagedRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		group.Rules = ruleList
	} else {
		group.Rules = nil
	}

	// No error
	return nil
}

// Defines a managed rule group to use for exclusion.
type ExclusionManagedRuleGroup_STATUS struct {
	// RuleGroupName: The managed rule group for exclusion.
	RuleGroupName *string `json:"ruleGroupName,omitempty"`

	// Rules: List of rules that will be excluded. If none specified, all rules in the group will be excluded.
	Rules []ExclusionManagedRule_STATUS `json:"rules,omitempty"`
}

var _ genruntime.FromARMConverter = &ExclusionManagedRuleGroup_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (group *ExclusionManagedRuleGroup_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ExclusionManagedRuleGroup_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (group *ExclusionManagedRuleGroup_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ExclusionManagedRuleGroup_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ExclusionManagedRuleGroup_STATUS, got %T", armInput)
	}

	// Set property "RuleGroupName":
	if typedInput.RuleGroupName != nil {
		ruleGroupName := *typedInput.RuleGroupName
		group.RuleGroupName = &ruleGroupName
	}

	// Set property "Rules":
	for _, item := range typedInput.Rules {
		var item1 ExclusionManagedRule_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		group.Rules = append(group.Rules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ExclusionManagedRuleGroup_STATUS populates our ExclusionManagedRuleGroup_STATUS from the provided source ExclusionManagedRuleGroup_STATUS
func (group *ExclusionManagedRuleGroup_STATUS) AssignProperties_From_ExclusionManagedRuleGroup_STATUS(source *storage.ExclusionManagedRuleGroup_STATUS) error {

	// RuleGroupName
	group.RuleGroupName = genruntime.ClonePointerToString(source.RuleGroupName)

	// Rules
	if source.Rules != nil {
		ruleList := make([]ExclusionManagedRule_STATUS, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule ExclusionManagedRule_STATUS
			err := rule.AssignProperties_From_ExclusionManagedRule_STATUS(&ruleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ExclusionManagedRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		group.Rules = ruleList
	} else {
		group.Rules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ExclusionManagedRuleGroup_STATUS populates the provided destination ExclusionManagedRuleGroup_STATUS from our ExclusionManagedRuleGroup_STATUS
func (group *ExclusionManagedRuleGroup_STATUS) AssignProperties_To_ExclusionManagedRuleGroup_STATUS(destination *storage.ExclusionManagedRuleGroup_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RuleGroupName
	destination.RuleGroupName = genruntime.ClonePointerToString(group.RuleGroupName)

	// Rules
	if group.Rules != nil {
		ruleList := make([]storage.ExclusionManagedRule_STATUS, len(group.Rules))
		for ruleIndex, ruleItem := range group.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule storage.ExclusionManagedRule_STATUS
			err := ruleItem.AssignProperties_To_ExclusionManagedRule_STATUS(&rule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ExclusionManagedRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"ClientAddr","GeoLocation","None"}
type GroupByVariable_VariableName string

const (
	GroupByVariable_VariableName_ClientAddr  = GroupByVariable_VariableName("ClientAddr")
	GroupByVariable_VariableName_GeoLocation = GroupByVariable_VariableName("GeoLocation")
	GroupByVariable_VariableName_None        = GroupByVariable_VariableName("None")
)

// Mapping from string to GroupByVariable_VariableName
var groupByVariable_VariableName_Values = map[string]GroupByVariable_VariableName{
	"clientaddr":  GroupByVariable_VariableName_ClientAddr,
	"geolocation": GroupByVariable_VariableName_GeoLocation,
	"none":        GroupByVariable_VariableName_None,
}

type GroupByVariable_VariableName_STATUS string

const (
	GroupByVariable_VariableName_STATUS_ClientAddr  = GroupByVariable_VariableName_STATUS("ClientAddr")
	GroupByVariable_VariableName_STATUS_GeoLocation = GroupByVariable_VariableName_STATUS("GeoLocation")
	GroupByVariable_VariableName_STATUS_None        = GroupByVariable_VariableName_STATUS("None")
)

// Mapping from string to GroupByVariable_VariableName_STATUS
var groupByVariable_VariableName_STATUS_Values = map[string]GroupByVariable_VariableName_STATUS{
	"clientaddr":  GroupByVariable_VariableName_STATUS_ClientAddr,
	"geolocation": GroupByVariable_VariableName_STATUS_GeoLocation,
	"none":        GroupByVariable_VariableName_STATUS_None,
}

// Defines a managed rule group override setting.
type ManagedRuleOverride struct {
	// Action: Describes the override action to be applied when rule matches.
	Action *ActionType `json:"action,omitempty"`

	// +kubebuilder:validation:Required
	// RuleId: Identifier for the managed rule.
	RuleId *string `json:"ruleId,omitempty"`

	// State: The state of the managed rule. Defaults to Disabled if not specified.
	State *ManagedRuleOverride_State `json:"state,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedRuleOverride{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (override *ManagedRuleOverride) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if override == nil {
		return nil, nil
	}
	result := &arm.ManagedRuleOverride{}

	// Set property "Action":
	if override.Action != nil {
		var temp string
		temp = string(*override.Action)
		action := arm.ActionType(temp)
		result.Action = &action
	}

	// Set property "RuleId":
	if override.RuleId != nil {
		ruleId := *override.RuleId
		result.RuleId = &ruleId
	}

	// Set property "State":
	if override.State != nil {
		var temp string
		temp = string(*override.State)
		state := arm.ManagedRuleOverride_State(temp)
		result.State = &state
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (override *ManagedRuleOverride) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedRuleOverride{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (override *ManagedRuleOverride) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedRuleOverride)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedRuleOverride, got %T", armInput)
	}

	// Set property "Action":
	if typedInput.Action != nil {
		var temp string
		temp = string(*typedInput.Action)
		action := ActionType(temp)
		override.Action = &action
	}

	// Set property "RuleId":
	if typedInput.RuleId != nil {
		ruleId := *typedInput.RuleId
		override.RuleId = &ruleId
	}

	// Set property "State":
	if typedInput.State != nil {
		var temp string
		temp = string(*typedInput.State)
		state := ManagedRuleOverride_State(temp)
		override.State = &state
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedRuleOverride populates our ManagedRuleOverride from the provided source ManagedRuleOverride
func (override *ManagedRuleOverride) AssignProperties_From_ManagedRuleOverride(source *storage.ManagedRuleOverride) error {

	// Action
	if source.Action != nil {
		action := *source.Action
		actionTemp := genruntime.ToEnum(action, actionType_Values)
		override.Action = &actionTemp
	} else {
		override.Action = nil
	}

	// RuleId
	override.RuleId = genruntime.ClonePointerToString(source.RuleId)

	// State
	if source.State != nil {
		state := *source.State
		stateTemp := genruntime.ToEnum(state, managedRuleOverride_State_Values)
		override.State = &stateTemp
	} else {
		override.State = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedRuleOverride populates the provided destination ManagedRuleOverride from our ManagedRuleOverride
func (override *ManagedRuleOverride) AssignProperties_To_ManagedRuleOverride(destination *storage.ManagedRuleOverride) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	if override.Action != nil {
		action := string(*override.Action)
		destination.Action = &action
	} else {
		destination.Action = nil
	}

	// RuleId
	destination.RuleId = genruntime.ClonePointerToString(override.RuleId)

	// State
	if override.State != nil {
		state := string(*override.State)
		destination.State = &state
	} else {
		destination.State = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ManagedRuleOverride_STATUS populates our ManagedRuleOverride from the provided source ManagedRuleOverride_STATUS
func (override *ManagedRuleOverride) Initialize_From_ManagedRuleOverride_STATUS(source *ManagedRuleOverride_STATUS) error {

	// Action
	if source.Action != nil {
		action := genruntime.ToEnum(string(*source.Action), actionType_Values)
		override.Action = &action
	} else {
		override.Action = nil
	}

	// RuleId
	override.RuleId = genruntime.ClonePointerToString(source.RuleId)

	// State
	if source.State != nil {
		state := genruntime.ToEnum(string(*source.State), managedRuleOverride_State_Values)
		override.State = &state
	} else {
		override.State = nil
	}

	// No error
	return nil
}

// Defines a managed rule group override setting.
type ManagedRuleOverride_STATUS struct {
	// Action: Describes the override action to be applied when rule matches.
	Action *ActionType_STATUS `json:"action,omitempty"`

	// RuleId: Identifier for the managed rule.
	RuleId *string `json:"ruleId,omitempty"`

	// State: The state of the managed rule. Defaults to Disabled if not specified.
	State *ManagedRuleOverride_State_STATUS `json:"state,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedRuleOverride_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (override *ManagedRuleOverride_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedRuleOverride_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (override *ManagedRuleOverride_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedRuleOverride_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedRuleOverride_STATUS, got %T", armInput)
	}

	// Set property "Action":
	if typedInput.Action != nil {
		var temp string
		temp = string(*typedInput.Action)
		action := ActionType_STATUS(temp)
		override.Action = &action
	}

	// Set property "RuleId":
	if typedInput.RuleId != nil {
		ruleId := *typedInput.RuleId
		override.RuleId = &ruleId
	}

	// Set property "State":
	if typedInput.State != nil {
		var temp string
		temp = string(*typedInput.State)
		state := ManagedRuleOverride_State_STATUS(temp)
		override.State = &state
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedRuleOverride_STATUS populates our ManagedRuleOverride_STATUS from the provided source ManagedRuleOverride_STATUS
func (override *ManagedRuleOverride_STATUS) AssignProperties_From_ManagedRuleOverride_STATUS(source *storage.ManagedRuleOverride_STATUS) error {

	// Action
	if source.Action != nil {
		action := *source.Action
		actionTemp := genruntime.ToEnum(action, actionType_STATUS_Values)
		override.Action = &actionTemp
	} else {
		override.Action = nil
	}

	// RuleId
	override.RuleId = genruntime.ClonePointerToString(source.RuleId)

	// State
	if source.State != nil {
		state := *source.State
		stateTemp := genruntime.ToEnum(state, managedRuleOverride_State_STATUS_Values)
		override.State = &stateTemp
	} else {
		override.State = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedRuleOverride_STATUS populates the provided destination ManagedRuleOverride_STATUS from our ManagedRuleOverride_STATUS
func (override *ManagedRuleOverride_STATUS) AssignProperties_To_ManagedRuleOverride_STATUS(destination *storage.ManagedRuleOverride_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	if override.Action != nil {
		action := string(*override.Action)
		destination.Action = &action
	} else {
		destination.Action = nil
	}

	// RuleId
	destination.RuleId = genruntime.ClonePointerToString(override.RuleId)

	// State
	if override.State != nil {
		state := string(*override.State)
		destination.State = &state
	} else {
		destination.State = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"PostArgs","QueryString","RemoteAddr","RequestBody","RequestCookies","RequestHeaders","RequestMethod","RequestUri"}
type MatchVariable_VariableName string

const (
	MatchVariable_VariableName_PostArgs       = MatchVariable_VariableName("PostArgs")
	MatchVariable_VariableName_QueryString    = MatchVariable_VariableName("QueryString")
	MatchVariable_VariableName_RemoteAddr     = MatchVariable_VariableName("RemoteAddr")
	MatchVariable_VariableName_RequestBody    = MatchVariable_VariableName("RequestBody")
	MatchVariable_VariableName_RequestCookies = MatchVariable_VariableName("RequestCookies")
	MatchVariable_VariableName_RequestHeaders = MatchVariable_VariableName("RequestHeaders")
	MatchVariable_VariableName_RequestMethod  = MatchVariable_VariableName("RequestMethod")
	MatchVariable_VariableName_RequestUri     = MatchVariable_VariableName("RequestUri")
)

// Mapping from string to MatchVariable_VariableName
var matchVariable_VariableName_Values = map[string]MatchVariable_VariableName{
	"postargs":       MatchVariable_VariableName_PostArgs,
	"querystring":    MatchVariable_VariableName_QueryString,
	"remoteaddr":     MatchVariable_VariableName_RemoteAddr,
	"requestbody":    MatchVariable_VariableName_RequestBody,
	"requestcookies": MatchVariable_VariableName_RequestCookies,
	"requestheaders": MatchVariable_VariableName_RequestHeaders,
	"requestmethod":  MatchVariable_VariableName_RequestMethod,
	"requesturi":     MatchVariable_VariableName_RequestUri,
}

type MatchVariable_VariableName_STATUS string

const (
	MatchVariable_VariableName_STATUS_PostArgs       = MatchVariable_VariableName_STATUS("PostArgs")
	MatchVariable_VariableName_STATUS_QueryString    = MatchVariable_VariableName_STATUS("QueryString")
	MatchVariable_VariableName_STATUS_RemoteAddr     = MatchVariable_VariableName_STATUS("RemoteAddr")
	MatchVariable_VariableName_STATUS_RequestBody    = MatchVariable_VariableName_STATUS("RequestBody")
	MatchVariable_VariableName_STATUS_RequestCookies = MatchVariable_VariableName_STATUS("RequestCookies")
	MatchVariable_VariableName_STATUS_RequestHeaders = MatchVariable_VariableName_STATUS("RequestHeaders")
	MatchVariable_VariableName_STATUS_RequestMethod  = MatchVariable_VariableName_STATUS("RequestMethod")
	MatchVariable_VariableName_STATUS_RequestUri     = MatchVariable_VariableName_STATUS("RequestUri")
)

// Mapping from string to MatchVariable_VariableName_STATUS
var matchVariable_VariableName_STATUS_Values = map[string]MatchVariable_VariableName_STATUS{
	"postargs":       MatchVariable_VariableName_STATUS_PostArgs,
	"querystring":    MatchVariable_VariableName_STATUS_QueryString,
	"remoteaddr":     MatchVariable_VariableName_STATUS_RemoteAddr,
	"requestbody":    MatchVariable_VariableName_STATUS_RequestBody,
	"requestcookies": MatchVariable_VariableName_STATUS_RequestCookies,
	"requestheaders": MatchVariable_VariableName_STATUS_RequestHeaders,
	"requestmethod":  MatchVariable_VariableName_STATUS_RequestMethod,
	"requesturi":     MatchVariable_VariableName_STATUS_RequestUri,
}

// +kubebuilder:validation:Enum={"RequestArgNames","RequestCookieNames","RequestHeaderNames","RequestIPAddress","RequestJSONArgNames","RequestPostArgNames"}
type WebApplicationFirewallScrubbingRules_MatchVariable string

const (
	WebApplicationFirewallScrubbingRules_MatchVariable_RequestArgNames     = WebApplicationFirewallScrubbingRules_MatchVariable("RequestArgNames")
	WebApplicationFirewallScrubbingRules_MatchVariable_RequestCookieNames  = WebApplicationFirewallScrubbingRules_MatchVariable("RequestCookieNames")
	WebApplicationFirewallScrubbingRules_MatchVariable_RequestHeaderNames  = WebApplicationFirewallScrubbingRules_MatchVariable("RequestHeaderNames")
	WebApplicationFirewallScrubbingRules_MatchVariable_RequestIPAddress    = WebApplicationFirewallScrubbingRules_MatchVariable("RequestIPAddress")
	WebApplicationFirewallScrubbingRules_MatchVariable_RequestJSONArgNames = WebApplicationFirewallScrubbingRules_MatchVariable("RequestJSONArgNames")
	WebApplicationFirewallScrubbingRules_MatchVariable_RequestPostArgNames = WebApplicationFirewallScrubbingRules_MatchVariable("RequestPostArgNames")
)

// Mapping from string to WebApplicationFirewallScrubbingRules_MatchVariable
var webApplicationFirewallScrubbingRules_MatchVariable_Values = map[string]WebApplicationFirewallScrubbingRules_MatchVariable{
	"requestargnames":     WebApplicationFirewallScrubbingRules_MatchVariable_RequestArgNames,
	"requestcookienames":  WebApplicationFirewallScrubbingRules_MatchVariable_RequestCookieNames,
	"requestheadernames":  WebApplicationFirewallScrubbingRules_MatchVariable_RequestHeaderNames,
	"requestipaddress":    WebApplicationFirewallScrubbingRules_MatchVariable_RequestIPAddress,
	"requestjsonargnames": WebApplicationFirewallScrubbingRules_MatchVariable_RequestJSONArgNames,
	"requestpostargnames": WebApplicationFirewallScrubbingRules_MatchVariable_RequestPostArgNames,
}

type WebApplicationFirewallScrubbingRules_MatchVariable_STATUS string

const (
	WebApplicationFirewallScrubbingRules_MatchVariable_STATUS_RequestArgNames     = WebApplicationFirewallScrubbingRules_MatchVariable_STATUS("RequestArgNames")
	WebApplicationFirewallScrubbingRules_MatchVariable_STATUS_RequestCookieNames  = WebApplicationFirewallScrubbingRules_MatchVariable_STATUS("RequestCookieNames")
	WebApplicationFirewallScrubbingRules_MatchVariable_STATUS_RequestHeaderNames  = WebApplicationFirewallScrubbingRules_MatchVariable_STATUS("RequestHeaderNames")
	WebApplicationFirewallScrubbingRules_MatchVariable_STATUS_RequestIPAddress    = WebApplicationFirewallScrubbingRules_MatchVariable_STATUS("RequestIPAddress")
	WebApplicationFirewallScrubbingRules_MatchVariable_STATUS_RequestJSONArgNames = WebApplicationFirewallScrubbingRules_MatchVariable_STATUS("RequestJSONArgNames")
	WebApplicationFirewallScrubbingRules_MatchVariable_STATUS_RequestPostArgNames = WebApplicationFirewallScrubbingRules_MatchVariable_STATUS("RequestPostArgNames")
)

// Mapping from string to WebApplicationFirewallScrubbingRules_MatchVariable_STATUS
var webApplicationFirewallScrubbingRules_MatchVariable_STATUS_Values = map[string]WebApplicationFirewallScrubbingRules_MatchVariable_STATUS{
	"requestargnames":     WebApplicationFirewallScrubbingRules_MatchVariable_STATUS_RequestArgNames,
	"requestcookienames":  WebApplicationFirewallScrubbingRules_MatchVariable_STATUS_RequestCookieNames,
	"requestheadernames":  WebApplicationFirewallScrubbingRules_MatchVariable_STATUS_RequestHeaderNames,
	"requestipaddress":    WebApplicationFirewallScrubbingRules_MatchVariable_STATUS_RequestIPAddress,
	"requestjsonargnames": WebApplicationFirewallScrubbingRules_MatchVariable_STATUS_RequestJSONArgNames,
	"requestpostargnames": WebApplicationFirewallScrubbingRules_MatchVariable_STATUS_RequestPostArgNames,
}

// +kubebuilder:validation:Enum={"Equals","EqualsAny"}
type WebApplicationFirewallScrubbingRules_SelectorMatchOperator string

const (
	WebApplicationFirewallScrubbingRules_SelectorMatchOperator_Equals    = WebApplicationFirewallScrubbingRules_SelectorMatchOperator("Equals")
	WebApplicationFirewallScrubbingRules_SelectorMatchOperator_EqualsAny = WebApplicationFirewallScrubbingRules_SelectorMatchOperator("EqualsAny")
)

// Mapping from string to WebApplicationFirewallScrubbingRules_SelectorMatchOperator
var webApplicationFirewallScrubbingRules_SelectorMatchOperator_Values = map[string]WebApplicationFirewallScrubbingRules_SelectorMatchOperator{
	"equals":    WebApplicationFirewallScrubbingRules_SelectorMatchOperator_Equals,
	"equalsany": WebApplicationFirewallScrubbingRules_SelectorMatchOperator_EqualsAny,
}

type WebApplicationFirewallScrubbingRules_SelectorMatchOperator_STATUS string

const (
	WebApplicationFirewallScrubbingRules_SelectorMatchOperator_STATUS_Equals    = WebApplicationFirewallScrubbingRules_SelectorMatchOperator_STATUS("Equals")
	WebApplicationFirewallScrubbingRules_SelectorMatchOperator_STATUS_EqualsAny = WebApplicationFirewallScrubbingRules_SelectorMatchOperator_STATUS("EqualsAny")
)

// Mapping from string to WebApplicationFirewallScrubbingRules_SelectorMatchOperator_STATUS
var webApplicationFirewallScrubbingRules_SelectorMatchOperator_STATUS_Values = map[string]WebApplicationFirewallScrubbingRules_SelectorMatchOperator_STATUS{
	"equals":    WebApplicationFirewallScrubbingRules_SelectorMatchOperator_STATUS_Equals,
	"equalsany": WebApplicationFirewallScrubbingRules_SelectorMatchOperator_STATUS_EqualsAny,
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type WebApplicationFirewallScrubbingRules_State string

const (
	WebApplicationFirewallScrubbingRules_State_Disabled = WebApplicationFirewallScrubbingRules_State("Disabled")
	WebApplicationFirewallScrubbingRules_State_Enabled  = WebApplicationFirewallScrubbingRules_State("Enabled")
)

// Mapping from string to WebApplicationFirewallScrubbingRules_State
var webApplicationFirewallScrubbingRules_State_Values = map[string]WebApplicationFirewallScrubbingRules_State{
	"disabled": WebApplicationFirewallScrubbingRules_State_Disabled,
	"enabled":  WebApplicationFirewallScrubbingRules_State_Enabled,
}

type WebApplicationFirewallScrubbingRules_State_STATUS string

const (
	WebApplicationFirewallScrubbingRules_State_STATUS_Disabled = WebApplicationFirewallScrubbingRules_State_STATUS("Disabled")
	WebApplicationFirewallScrubbingRules_State_STATUS_Enabled  = WebApplicationFirewallScrubbingRules_State_STATUS("Enabled")
)

// Mapping from string to WebApplicationFirewallScrubbingRules_State_STATUS
var webApplicationFirewallScrubbingRules_State_STATUS_Values = map[string]WebApplicationFirewallScrubbingRules_State_STATUS{
	"disabled": WebApplicationFirewallScrubbingRules_State_STATUS_Disabled,
	"enabled":  WebApplicationFirewallScrubbingRules_State_STATUS_Enabled,
}

// Defines the action to take on rule match.
// +kubebuilder:validation:Enum={"Allow","AnomalyScoring","Block","JSChallenge","Log"}
type ActionType string

const (
	ActionType_Allow          = ActionType("Allow")
	ActionType_AnomalyScoring = ActionType("AnomalyScoring")
	ActionType_Block          = ActionType("Block")
	ActionType_JSChallenge    = ActionType("JSChallenge")
	ActionType_Log            = ActionType("Log")
)

// Mapping from string to ActionType
var actionType_Values = map[string]ActionType{
	"allow":          ActionType_Allow,
	"anomalyscoring": ActionType_AnomalyScoring,
	"block":          ActionType_Block,
	"jschallenge":    ActionType_JSChallenge,
	"log":            ActionType_Log,
}

// Defines the action to take on rule match.
type ActionType_STATUS string

const (
	ActionType_STATUS_Allow          = ActionType_STATUS("Allow")
	ActionType_STATUS_AnomalyScoring = ActionType_STATUS("AnomalyScoring")
	ActionType_STATUS_Block          = ActionType_STATUS("Block")
	ActionType_STATUS_JSChallenge    = ActionType_STATUS("JSChallenge")
	ActionType_STATUS_Log            = ActionType_STATUS("Log")
)

// Mapping from string to ActionType_STATUS
var actionType_STATUS_Values = map[string]ActionType_STATUS{
	"allow":          ActionType_STATUS_Allow,
	"anomalyscoring": ActionType_STATUS_AnomalyScoring,
	"block":          ActionType_STATUS_Block,
	"jschallenge":    ActionType_STATUS_JSChallenge,
	"log":            ActionType_STATUS_Log,
}

// Defines a managed rule to use for exclusion.
type ExclusionManagedRule struct {
	// +kubebuilder:validation:Required
	// RuleId: Identifier for the managed rule.
	RuleId *string `json:"ruleId,omitempty"`
}

var _ genruntime.ARMTransformer = &ExclusionManagedRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *ExclusionManagedRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.ExclusionManagedRule{}

	// Set property "RuleId":
	if rule.RuleId != nil {
		ruleId := *rule.RuleId
		result.RuleId = &ruleId
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *ExclusionManagedRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ExclusionManagedRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *ExclusionManagedRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ExclusionManagedRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ExclusionManagedRule, got %T", armInput)
	}

	// Set property "RuleId":
	if typedInput.RuleId != nil {
		ruleId := *typedInput.RuleId
		rule.RuleId = &ruleId
	}

	// No error
	return nil
}

// AssignProperties_From_ExclusionManagedRule populates our ExclusionManagedRule from the provided source ExclusionManagedRule
func (rule *ExclusionManagedRule) AssignProperties_From_ExclusionManagedRule(source *storage.ExclusionManagedRule) error {

	// RuleId
	rule.RuleId = genruntime.ClonePointerToString(source.RuleId)

	// No error
	return nil
}

// AssignProperties_To_ExclusionManagedRule populates the provided destination ExclusionManagedRule from our ExclusionManagedRule
func (rule *ExclusionManagedRule) AssignProperties_To_ExclusionManagedRule(destination *storage.ExclusionManagedRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RuleId
	destination.RuleId = genruntime.ClonePointerToString(rule.RuleId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ExclusionManagedRule_STATUS populates our ExclusionManagedRule from the provided source ExclusionManagedRule_STATUS
func (rule *ExclusionManagedRule) Initialize_From_ExclusionManagedRule_STATUS(source *ExclusionManagedRule_STATUS) error {

	// RuleId
	rule.RuleId = genruntime.ClonePointerToString(source.RuleId)

	// No error
	return nil
}

// Defines a managed rule to use for exclusion.
type ExclusionManagedRule_STATUS struct {
	// RuleId: Identifier for the managed rule.
	RuleId *string `json:"ruleId,omitempty"`
}

var _ genruntime.FromARMConverter = &ExclusionManagedRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *ExclusionManagedRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ExclusionManagedRule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *ExclusionManagedRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ExclusionManagedRule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ExclusionManagedRule_STATUS, got %T", armInput)
	}

	// Set property "RuleId":
	if typedInput.RuleId != nil {
		ruleId := *typedInput.RuleId
		rule.RuleId = &ruleId
	}

	// No error
	return nil
}

// AssignProperties_From_ExclusionManagedRule_STATUS populates our ExclusionManagedRule_STATUS from the provided source ExclusionManagedRule_STATUS
func (rule *ExclusionManagedRule_STATUS) AssignProperties_From_ExclusionManagedRule_STATUS(source *storage.ExclusionManagedRule_STATUS) error {

	// RuleId
	rule.RuleId = genruntime.ClonePointerToString(source.RuleId)

	// No error
	return nil
}

// AssignProperties_To_ExclusionManagedRule_STATUS populates the provided destination ExclusionManagedRule_STATUS from our ExclusionManagedRule_STATUS
func (rule *ExclusionManagedRule_STATUS) AssignProperties_To_ExclusionManagedRule_STATUS(destination *storage.ExclusionManagedRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RuleId
	destination.RuleId = genruntime.ClonePointerToString(rule.RuleId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type ManagedRuleOverride_State string

const (
	ManagedRuleOverride_State_Disabled = ManagedRuleOverride_State("Disabled")
	ManagedRuleOverride_State_Enabled  = ManagedRuleOverride_State("Enabled")
)

// Mapping from string to ManagedRuleOverride_State
var managedRuleOverride_State_Values = map[string]ManagedRuleOverride_State{
	"disabled": ManagedRuleOverride_State_Disabled,
	"enabled":  ManagedRuleOverride_State_Enabled,
}

type ManagedRuleOverride_State_STATUS string

const (
	ManagedRuleOverride_State_STATUS_Disabled = ManagedRuleOverride_State_STATUS("Disabled")
	ManagedRuleOverride_State_STATUS_Enabled  = ManagedRuleOverride_State_STATUS("Enabled")
)

// Mapping from string to ManagedRuleOverride_State_STATUS
var managedRuleOverride_State_STATUS_Values = map[string]ManagedRuleOverride_State_STATUS{
	"disabled": ManagedRuleOverride_State_STATUS_Disabled,
	"enabled":  ManagedRuleOverride_State_STATUS_Enabled,
}

func init() {
	SchemeBuilder.Register(&WebApplicationFirewallPolicy{}, &WebApplicationFirewallPolicyList{})
}
