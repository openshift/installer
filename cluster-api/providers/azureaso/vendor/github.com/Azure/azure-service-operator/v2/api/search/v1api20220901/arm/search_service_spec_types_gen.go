// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import "github.com/Azure/azure-service-operator/v2/pkg/genruntime"

type SearchService_Spec struct {
	// Identity: The identity of the resource.
	Identity *Identity `json:"identity,omitempty"`

	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	Name     string  `json:"name,omitempty"`

	// Properties: Properties of the search service.
	Properties *SearchServiceProperties `json:"properties,omitempty"`

	// Sku: The SKU of the Search Service, which determines price tier and capacity limits. This property is required when
	// creating a new Search Service.
	Sku *Sku `json:"sku,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMResourceSpec = &SearchService_Spec{}

// GetAPIVersion returns the ARM API version of the resource. This is always "2022-09-01"
func (service SearchService_Spec) GetAPIVersion() string {
	return "2022-09-01"
}

// GetName returns the Name of the resource
func (service *SearchService_Spec) GetName() string {
	return service.Name
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Search/searchServices"
func (service *SearchService_Spec) GetType() string {
	return "Microsoft.Search/searchServices"
}

// Identity for the resource.
type Identity struct {
	// Type: The identity type.
	Type *Identity_Type `json:"type,omitempty"`
}

// Properties of the search service.
type SearchServiceProperties struct {
	// AuthOptions: Defines the options for how the data plane API of a search service authenticates requests. This cannot be
	// set if 'disableLocalAuth' is set to true.
	AuthOptions *DataPlaneAuthOptions `json:"authOptions,omitempty"`

	// DisableLocalAuth: When set to true, calls to the search service will not be permitted to utilize API keys for
	// authentication. This cannot be set to true if 'dataPlaneAuthOptions' are defined.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// EncryptionWithCmk: Specifies any policy regarding encryption of resources (such as indexes) using customer manager keys
	// within a search service.
	EncryptionWithCmk *EncryptionWithCmk `json:"encryptionWithCmk,omitempty"`

	// HostingMode: Applicable only for the standard3 SKU. You can set this property to enable up to 3 high density partitions
	// that allow up to 1000 indexes, which is much higher than the maximum indexes allowed for any other SKU. For the
	// standard3 SKU, the value is either 'default' or 'highDensity'. For all other SKUs, this value must be 'default'.
	HostingMode *SearchServiceProperties_HostingMode `json:"hostingMode,omitempty"`

	// NetworkRuleSet: Network specific rules that determine how the Azure Cognitive Search service may be reached.
	NetworkRuleSet *NetworkRuleSet `json:"networkRuleSet,omitempty"`

	// PartitionCount: The number of partitions in the search service; if specified, it can be 1, 2, 3, 4, 6, or 12. Values
	// greater than 1 are only valid for standard SKUs. For 'standard3' services with hostingMode set to 'highDensity', the
	// allowed values are between 1 and 3.
	PartitionCount *int `json:"partitionCount,omitempty"`

	// PublicNetworkAccess: This value can be set to 'enabled' to avoid breaking changes on existing customer resources and
	// templates. If set to 'disabled', traffic over public interface is not allowed, and private endpoint connections would be
	// the exclusive access method.
	PublicNetworkAccess *SearchServiceProperties_PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// ReplicaCount: The number of replicas in the search service. If specified, it must be a value between 1 and 12 inclusive
	// for standard SKUs or between 1 and 3 inclusive for basic SKU.
	ReplicaCount *int `json:"replicaCount,omitempty"`
}

// Defines the SKU of an Azure Cognitive Search Service, which determines price tier and capacity limits.
type Sku struct {
	// Name: The SKU of the search service. Valid values include: 'free': Shared service. 'basic': Dedicated service with up to
	// 3 replicas. 'standard': Dedicated service with up to 12 partitions and 12 replicas. 'standard2': Similar to standard,
	// but with more capacity per search unit. 'standard3': The largest Standard offering with up to 12 partitions and 12
	// replicas (or up to 3 partitions with more indexes if you also set the hostingMode property to 'highDensity').
	// 'storage_optimized_l1': Supports 1TB per partition, up to 12 partitions. 'storage_optimized_l2': Supports 2TB per
	// partition, up to 12 partitions.'
	Name *Sku_Name `json:"name,omitempty"`
}

// Defines the options for how the data plane API of a Search service authenticates requests. This cannot be set if
// 'disableLocalAuth' is set to true.
type DataPlaneAuthOptions struct {
	// AadOrApiKey: Indicates that either the API key or an access token from Azure Active Directory can be used for
	// authentication.
	AadOrApiKey *DataPlaneAadOrApiKeyAuthOption `json:"aadOrApiKey,omitempty"`
}

// Describes a policy that determines how resources within the search service are to be encrypted with Customer Managed
// Keys.
type EncryptionWithCmk struct {
	// Enforcement: Describes how a search service should enforce having one or more non customer encrypted resources.
	Enforcement *EncryptionWithCmk_Enforcement `json:"enforcement,omitempty"`
}

// +kubebuilder:validation:Enum={"None","SystemAssigned"}
type Identity_Type string

const (
	Identity_Type_None           = Identity_Type("None")
	Identity_Type_SystemAssigned = Identity_Type("SystemAssigned")
)

// Mapping from string to Identity_Type
var identity_Type_Values = map[string]Identity_Type{
	"none":           Identity_Type_None,
	"systemassigned": Identity_Type_SystemAssigned,
}

// Network specific rules that determine how the Azure Cognitive Search service may be reached.
type NetworkRuleSet struct {
	// IpRules: A list of IP restriction rules that defines the inbound network(s) with allowing access to the search service
	// endpoint. At the meantime, all other public IP networks are blocked by the firewall. These restriction rules are applied
	// only when the 'publicNetworkAccess' of the search service is 'enabled'; otherwise, traffic over public interface is not
	// allowed even with any public IP rules, and private endpoint connections would be the exclusive access method.
	IpRules []IpRule `json:"ipRules,omitempty"`
}

// +kubebuilder:validation:Enum={"default","highDensity"}
type SearchServiceProperties_HostingMode string

const (
	SearchServiceProperties_HostingMode_Default     = SearchServiceProperties_HostingMode("default")
	SearchServiceProperties_HostingMode_HighDensity = SearchServiceProperties_HostingMode("highDensity")
)

// Mapping from string to SearchServiceProperties_HostingMode
var searchServiceProperties_HostingMode_Values = map[string]SearchServiceProperties_HostingMode{
	"default":     SearchServiceProperties_HostingMode_Default,
	"highdensity": SearchServiceProperties_HostingMode_HighDensity,
}

// +kubebuilder:validation:Enum={"disabled","enabled"}
type SearchServiceProperties_PublicNetworkAccess string

const (
	SearchServiceProperties_PublicNetworkAccess_Disabled = SearchServiceProperties_PublicNetworkAccess("disabled")
	SearchServiceProperties_PublicNetworkAccess_Enabled  = SearchServiceProperties_PublicNetworkAccess("enabled")
)

// Mapping from string to SearchServiceProperties_PublicNetworkAccess
var searchServiceProperties_PublicNetworkAccess_Values = map[string]SearchServiceProperties_PublicNetworkAccess{
	"disabled": SearchServiceProperties_PublicNetworkAccess_Disabled,
	"enabled":  SearchServiceProperties_PublicNetworkAccess_Enabled,
}

// +kubebuilder:validation:Enum={"basic","free","standard","standard2","standard3","storage_optimized_l1","storage_optimized_l2"}
type Sku_Name string

const (
	Sku_Name_Basic                = Sku_Name("basic")
	Sku_Name_Free                 = Sku_Name("free")
	Sku_Name_Standard             = Sku_Name("standard")
	Sku_Name_Standard2            = Sku_Name("standard2")
	Sku_Name_Standard3            = Sku_Name("standard3")
	Sku_Name_Storage_Optimized_L1 = Sku_Name("storage_optimized_l1")
	Sku_Name_Storage_Optimized_L2 = Sku_Name("storage_optimized_l2")
)

// Mapping from string to Sku_Name
var sku_Name_Values = map[string]Sku_Name{
	"basic":                Sku_Name_Basic,
	"free":                 Sku_Name_Free,
	"standard":             Sku_Name_Standard,
	"standard2":            Sku_Name_Standard2,
	"standard3":            Sku_Name_Standard3,
	"storage_optimized_l1": Sku_Name_Storage_Optimized_L1,
	"storage_optimized_l2": Sku_Name_Storage_Optimized_L2,
}

// Indicates that either the API key or an access token from Azure Active Directory can be used for authentication.
type DataPlaneAadOrApiKeyAuthOption struct {
	// AadAuthFailureMode: Describes what response the data plane API of a Search service would send for requests that failed
	// authentication.
	AadAuthFailureMode *DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode `json:"aadAuthFailureMode,omitempty"`
}

// +kubebuilder:validation:Enum={"Disabled","Enabled","Unspecified"}
type EncryptionWithCmk_Enforcement string

const (
	EncryptionWithCmk_Enforcement_Disabled    = EncryptionWithCmk_Enforcement("Disabled")
	EncryptionWithCmk_Enforcement_Enabled     = EncryptionWithCmk_Enforcement("Enabled")
	EncryptionWithCmk_Enforcement_Unspecified = EncryptionWithCmk_Enforcement("Unspecified")
)

// Mapping from string to EncryptionWithCmk_Enforcement
var encryptionWithCmk_Enforcement_Values = map[string]EncryptionWithCmk_Enforcement{
	"disabled":    EncryptionWithCmk_Enforcement_Disabled,
	"enabled":     EncryptionWithCmk_Enforcement_Enabled,
	"unspecified": EncryptionWithCmk_Enforcement_Unspecified,
}

// The IP restriction rule of the Azure Cognitive Search service.
type IpRule struct {
	// Value: Value corresponding to a single IPv4 address (eg., 123.1.2.3) or an IP range in CIDR format (eg., 123.1.2.3/24)
	// to be allowed.
	Value *string `json:"value,omitempty"`
}

// +kubebuilder:validation:Enum={"http401WithBearerChallenge","http403"}
type DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode string

const (
	DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode_Http401WithBearerChallenge = DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode("http401WithBearerChallenge")
	DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode_Http403                    = DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode("http403")
)

// Mapping from string to DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode
var dataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode_Values = map[string]DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode{
	"http401withbearerchallenge": DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode_Http401WithBearerChallenge,
	"http403":                    DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode_Http403,
}
