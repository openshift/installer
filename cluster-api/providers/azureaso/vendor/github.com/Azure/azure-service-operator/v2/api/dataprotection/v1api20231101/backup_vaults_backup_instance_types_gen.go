// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20231101

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/dataprotection/v1api20231101/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/dataprotection/v1api20231101/storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /dataprotection/resource-manager/Microsoft.DataProtection/stable/2023-11-01/dataprotection.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupInstances/{backupInstanceName}
type BackupVaultsBackupInstance struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              BackupVaultsBackupInstance_Spec   `json:"spec,omitempty"`
	Status            BackupVaultsBackupInstance_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &BackupVaultsBackupInstance{}

// GetConditions returns the conditions of the resource
func (instance *BackupVaultsBackupInstance) GetConditions() conditions.Conditions {
	return instance.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (instance *BackupVaultsBackupInstance) SetConditions(conditions conditions.Conditions) {
	instance.Status.Conditions = conditions
}

var _ conversion.Convertible = &BackupVaultsBackupInstance{}

// ConvertFrom populates our BackupVaultsBackupInstance from the provided hub BackupVaultsBackupInstance
func (instance *BackupVaultsBackupInstance) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.BackupVaultsBackupInstance)
	if !ok {
		return fmt.Errorf("expected dataprotection/v1api20231101/storage/BackupVaultsBackupInstance but received %T instead", hub)
	}

	return instance.AssignProperties_From_BackupVaultsBackupInstance(source)
}

// ConvertTo populates the provided hub BackupVaultsBackupInstance from our BackupVaultsBackupInstance
func (instance *BackupVaultsBackupInstance) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.BackupVaultsBackupInstance)
	if !ok {
		return fmt.Errorf("expected dataprotection/v1api20231101/storage/BackupVaultsBackupInstance but received %T instead", hub)
	}

	return instance.AssignProperties_To_BackupVaultsBackupInstance(destination)
}

// +kubebuilder:webhook:path=/mutate-dataprotection-azure-com-v1api20231101-backupvaultsbackupinstance,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=dataprotection.azure.com,resources=backupvaultsbackupinstances,verbs=create;update,versions=v1api20231101,name=default.v1api20231101.backupvaultsbackupinstances.dataprotection.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &BackupVaultsBackupInstance{}

// Default applies defaults to the BackupVaultsBackupInstance resource
func (instance *BackupVaultsBackupInstance) Default() {
	instance.defaultImpl()
	var temp any = instance
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (instance *BackupVaultsBackupInstance) defaultAzureName() {
	if instance.Spec.AzureName == "" {
		instance.Spec.AzureName = instance.Name
	}
}

// defaultImpl applies the code generated defaults to the BackupVaultsBackupInstance resource
func (instance *BackupVaultsBackupInstance) defaultImpl() { instance.defaultAzureName() }

var _ configmaps.Exporter = &BackupVaultsBackupInstance{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (instance *BackupVaultsBackupInstance) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if instance.Spec.OperatorSpec == nil {
		return nil
	}
	return instance.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &BackupVaultsBackupInstance{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (instance *BackupVaultsBackupInstance) SecretDestinationExpressions() []*core.DestinationExpression {
	if instance.Spec.OperatorSpec == nil {
		return nil
	}
	return instance.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &BackupVaultsBackupInstance{}

// InitializeSpec initializes the spec for this resource from the given status
func (instance *BackupVaultsBackupInstance) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*BackupVaultsBackupInstance_STATUS); ok {
		return instance.Spec.Initialize_From_BackupVaultsBackupInstance_STATUS(s)
	}

	return fmt.Errorf("expected Status of type BackupVaultsBackupInstance_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &BackupVaultsBackupInstance{}

// AzureName returns the Azure name of the resource
func (instance *BackupVaultsBackupInstance) AzureName() string {
	return instance.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2023-11-01"
func (instance BackupVaultsBackupInstance) GetAPIVersion() string {
	return "2023-11-01"
}

// GetResourceScope returns the scope of the resource
func (instance *BackupVaultsBackupInstance) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (instance *BackupVaultsBackupInstance) GetSpec() genruntime.ConvertibleSpec {
	return &instance.Spec
}

// GetStatus returns the status of this resource
func (instance *BackupVaultsBackupInstance) GetStatus() genruntime.ConvertibleStatus {
	return &instance.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (instance *BackupVaultsBackupInstance) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.DataProtection/backupVaults/backupInstances"
func (instance *BackupVaultsBackupInstance) GetType() string {
	return "Microsoft.DataProtection/backupVaults/backupInstances"
}

// NewEmptyStatus returns a new empty (blank) status
func (instance *BackupVaultsBackupInstance) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &BackupVaultsBackupInstance_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (instance *BackupVaultsBackupInstance) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(instance.Spec)
	return instance.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (instance *BackupVaultsBackupInstance) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*BackupVaultsBackupInstance_STATUS); ok {
		instance.Status = *st
		return nil
	}

	// Convert status to required version
	var st BackupVaultsBackupInstance_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	instance.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-dataprotection-azure-com-v1api20231101-backupvaultsbackupinstance,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=dataprotection.azure.com,resources=backupvaultsbackupinstances,verbs=create;update,versions=v1api20231101,name=validate.v1api20231101.backupvaultsbackupinstances.dataprotection.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &BackupVaultsBackupInstance{}

// ValidateCreate validates the creation of the resource
func (instance *BackupVaultsBackupInstance) ValidateCreate() (admission.Warnings, error) {
	validations := instance.createValidations()
	var temp any = instance
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	return genruntime.ValidateCreate(validations)
}

// ValidateDelete validates the deletion of the resource
func (instance *BackupVaultsBackupInstance) ValidateDelete() (admission.Warnings, error) {
	validations := instance.deleteValidations()
	var temp any = instance
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	return genruntime.ValidateDelete(validations)
}

// ValidateUpdate validates an update of the resource
func (instance *BackupVaultsBackupInstance) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	validations := instance.updateValidations()
	var temp any = instance
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	return genruntime.ValidateUpdate(old, validations)
}

// createValidations validates the creation of the resource
func (instance *BackupVaultsBackupInstance) createValidations() []func() (admission.Warnings, error) {
	return []func() (admission.Warnings, error){instance.validateResourceReferences, instance.validateOwnerReference, instance.validateSecretDestinations, instance.validateConfigMapDestinations}
}

// deleteValidations validates the deletion of the resource
func (instance *BackupVaultsBackupInstance) deleteValidations() []func() (admission.Warnings, error) {
	return nil
}

// updateValidations validates the update of the resource
func (instance *BackupVaultsBackupInstance) updateValidations() []func(old runtime.Object) (admission.Warnings, error) {
	return []func(old runtime.Object) (admission.Warnings, error){
		func(old runtime.Object) (admission.Warnings, error) {
			return instance.validateResourceReferences()
		},
		instance.validateWriteOnceProperties,
		func(old runtime.Object) (admission.Warnings, error) {
			return instance.validateOwnerReference()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return instance.validateSecretDestinations()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return instance.validateConfigMapDestinations()
		},
	}
}

// validateConfigMapDestinations validates there are no colliding genruntime.ConfigMapDestinations
func (instance *BackupVaultsBackupInstance) validateConfigMapDestinations() (admission.Warnings, error) {
	if instance.Spec.OperatorSpec == nil {
		return nil, nil
	}
	return configmaps.ValidateDestinations(instance, nil, instance.Spec.OperatorSpec.ConfigMapExpressions)
}

// validateOwnerReference validates the owner field
func (instance *BackupVaultsBackupInstance) validateOwnerReference() (admission.Warnings, error) {
	return genruntime.ValidateOwner(instance)
}

// validateResourceReferences validates all resource references
func (instance *BackupVaultsBackupInstance) validateResourceReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindResourceReferences(&instance.Spec)
	if err != nil {
		return nil, err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateSecretDestinations validates there are no colliding genruntime.SecretDestination's
func (instance *BackupVaultsBackupInstance) validateSecretDestinations() (admission.Warnings, error) {
	if instance.Spec.OperatorSpec == nil {
		return nil, nil
	}
	return secrets.ValidateDestinations(instance, nil, instance.Spec.OperatorSpec.SecretExpressions)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (instance *BackupVaultsBackupInstance) validateWriteOnceProperties(old runtime.Object) (admission.Warnings, error) {
	oldObj, ok := old.(*BackupVaultsBackupInstance)
	if !ok {
		return nil, nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, instance)
}

// AssignProperties_From_BackupVaultsBackupInstance populates our BackupVaultsBackupInstance from the provided source BackupVaultsBackupInstance
func (instance *BackupVaultsBackupInstance) AssignProperties_From_BackupVaultsBackupInstance(source *storage.BackupVaultsBackupInstance) error {

	// ObjectMeta
	instance.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec BackupVaultsBackupInstance_Spec
	err := spec.AssignProperties_From_BackupVaultsBackupInstance_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_BackupVaultsBackupInstance_Spec() to populate field Spec")
	}
	instance.Spec = spec

	// Status
	var status BackupVaultsBackupInstance_STATUS
	err = status.AssignProperties_From_BackupVaultsBackupInstance_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_BackupVaultsBackupInstance_STATUS() to populate field Status")
	}
	instance.Status = status

	// No error
	return nil
}

// AssignProperties_To_BackupVaultsBackupInstance populates the provided destination BackupVaultsBackupInstance from our BackupVaultsBackupInstance
func (instance *BackupVaultsBackupInstance) AssignProperties_To_BackupVaultsBackupInstance(destination *storage.BackupVaultsBackupInstance) error {

	// ObjectMeta
	destination.ObjectMeta = *instance.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.BackupVaultsBackupInstance_Spec
	err := instance.Spec.AssignProperties_To_BackupVaultsBackupInstance_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_BackupVaultsBackupInstance_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.BackupVaultsBackupInstance_STATUS
	err = instance.Status.AssignProperties_To_BackupVaultsBackupInstance_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_BackupVaultsBackupInstance_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (instance *BackupVaultsBackupInstance) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: instance.Spec.OriginalVersion(),
		Kind:    "BackupVaultsBackupInstance",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /dataprotection/resource-manager/Microsoft.DataProtection/stable/2023-11-01/dataprotection.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataProtection/backupVaults/{vaultName}/backupInstances/{backupInstanceName}
type BackupVaultsBackupInstanceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []BackupVaultsBackupInstance `json:"items"`
}

type BackupVaultsBackupInstance_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *BackupVaultsBackupInstanceOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a dataprotection.azure.com/BackupVault resource
	Owner *genruntime.KnownResourceReference `group:"dataprotection.azure.com" json:"owner,omitempty" kind:"BackupVault"`

	// Properties: BackupInstanceResource properties
	Properties *BackupInstance `json:"properties,omitempty"`

	// Tags: Proxy Resource tags.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &BackupVaultsBackupInstance_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (instance *BackupVaultsBackupInstance_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if instance == nil {
		return nil, nil
	}
	result := &arm.BackupVaultsBackupInstance_Spec{}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if instance.Properties != nil {
		properties_ARM, err := (*instance.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*arm.BackupInstance)
		result.Properties = &properties
	}

	// Set property "Tags":
	if instance.Tags != nil {
		result.Tags = make(map[string]string, len(instance.Tags))
		for key, value := range instance.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (instance *BackupVaultsBackupInstance_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackupVaultsBackupInstance_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (instance *BackupVaultsBackupInstance_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackupVaultsBackupInstance_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackupVaultsBackupInstance_Spec, got %T", armInput)
	}

	// Set property "AzureName":
	instance.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	instance.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 BackupInstance
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		instance.Properties = &properties
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		instance.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			instance.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &BackupVaultsBackupInstance_Spec{}

// ConvertSpecFrom populates our BackupVaultsBackupInstance_Spec from the provided source
func (instance *BackupVaultsBackupInstance_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.BackupVaultsBackupInstance_Spec)
	if ok {
		// Populate our instance from source
		return instance.AssignProperties_From_BackupVaultsBackupInstance_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.BackupVaultsBackupInstance_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = instance.AssignProperties_From_BackupVaultsBackupInstance_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our BackupVaultsBackupInstance_Spec
func (instance *BackupVaultsBackupInstance_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.BackupVaultsBackupInstance_Spec)
	if ok {
		// Populate destination from our instance
		return instance.AssignProperties_To_BackupVaultsBackupInstance_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.BackupVaultsBackupInstance_Spec{}
	err := instance.AssignProperties_To_BackupVaultsBackupInstance_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_BackupVaultsBackupInstance_Spec populates our BackupVaultsBackupInstance_Spec from the provided source BackupVaultsBackupInstance_Spec
func (instance *BackupVaultsBackupInstance_Spec) AssignProperties_From_BackupVaultsBackupInstance_Spec(source *storage.BackupVaultsBackupInstance_Spec) error {

	// AzureName
	instance.AzureName = source.AzureName

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec BackupVaultsBackupInstanceOperatorSpec
		err := operatorSpec.AssignProperties_From_BackupVaultsBackupInstanceOperatorSpec(source.OperatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BackupVaultsBackupInstanceOperatorSpec() to populate field OperatorSpec")
		}
		instance.OperatorSpec = &operatorSpec
	} else {
		instance.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		instance.Owner = &owner
	} else {
		instance.Owner = nil
	}

	// Properties
	if source.Properties != nil {
		var property BackupInstance
		err := property.AssignProperties_From_BackupInstance(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BackupInstance() to populate field Properties")
		}
		instance.Properties = &property
	} else {
		instance.Properties = nil
	}

	// Tags
	instance.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// AssignProperties_To_BackupVaultsBackupInstance_Spec populates the provided destination BackupVaultsBackupInstance_Spec from our BackupVaultsBackupInstance_Spec
func (instance *BackupVaultsBackupInstance_Spec) AssignProperties_To_BackupVaultsBackupInstance_Spec(destination *storage.BackupVaultsBackupInstance_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = instance.AzureName

	// OperatorSpec
	if instance.OperatorSpec != nil {
		var operatorSpec storage.BackupVaultsBackupInstanceOperatorSpec
		err := instance.OperatorSpec.AssignProperties_To_BackupVaultsBackupInstanceOperatorSpec(&operatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BackupVaultsBackupInstanceOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = instance.OriginalVersion()

	// Owner
	if instance.Owner != nil {
		owner := instance.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Properties
	if instance.Properties != nil {
		var property storage.BackupInstance
		err := instance.Properties.AssignProperties_To_BackupInstance(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BackupInstance() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(instance.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_BackupVaultsBackupInstance_STATUS populates our BackupVaultsBackupInstance_Spec from the provided source BackupVaultsBackupInstance_STATUS
func (instance *BackupVaultsBackupInstance_Spec) Initialize_From_BackupVaultsBackupInstance_STATUS(source *BackupVaultsBackupInstance_STATUS) error {

	// Properties
	if source.Properties != nil {
		var property BackupInstance
		err := property.Initialize_From_BackupInstance_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_BackupInstance_STATUS() to populate field Properties")
		}
		instance.Properties = &property
	} else {
		instance.Properties = nil
	}

	// Tags
	instance.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (instance *BackupVaultsBackupInstance_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (instance *BackupVaultsBackupInstance_Spec) SetAzureName(azureName string) {
	instance.AzureName = azureName
}

type BackupVaultsBackupInstance_STATUS struct {
	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// Id: Proxy Resource Id represents the complete path to the resource.
	Id *string `json:"id,omitempty"`

	// Name: Proxy Resource name associated with the resource.
	Name *string `json:"name,omitempty"`

	// Properties: BackupInstanceResource properties
	Properties *BackupInstance_STATUS `json:"properties,omitempty"`

	// SystemData: Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData_STATUS `json:"systemData,omitempty"`

	// Tags: Proxy Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: Proxy Resource type represents the complete path of the form Namespace/ResourceType/ResourceType/...
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &BackupVaultsBackupInstance_STATUS{}

// ConvertStatusFrom populates our BackupVaultsBackupInstance_STATUS from the provided source
func (instance *BackupVaultsBackupInstance_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.BackupVaultsBackupInstance_STATUS)
	if ok {
		// Populate our instance from source
		return instance.AssignProperties_From_BackupVaultsBackupInstance_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.BackupVaultsBackupInstance_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = instance.AssignProperties_From_BackupVaultsBackupInstance_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our BackupVaultsBackupInstance_STATUS
func (instance *BackupVaultsBackupInstance_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.BackupVaultsBackupInstance_STATUS)
	if ok {
		// Populate destination from our instance
		return instance.AssignProperties_To_BackupVaultsBackupInstance_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.BackupVaultsBackupInstance_STATUS{}
	err := instance.AssignProperties_To_BackupVaultsBackupInstance_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &BackupVaultsBackupInstance_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (instance *BackupVaultsBackupInstance_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackupVaultsBackupInstance_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (instance *BackupVaultsBackupInstance_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackupVaultsBackupInstance_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackupVaultsBackupInstance_STATUS, got %T", armInput)
	}

	// no assignment for property "Conditions"

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		instance.Id = &id
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		instance.Name = &name
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 BackupInstance_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		instance.Properties = &properties
	}

	// Set property "SystemData":
	if typedInput.SystemData != nil {
		var systemData1 SystemData_STATUS
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		instance.SystemData = &systemData
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		instance.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			instance.Tags[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		instance.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_BackupVaultsBackupInstance_STATUS populates our BackupVaultsBackupInstance_STATUS from the provided source BackupVaultsBackupInstance_STATUS
func (instance *BackupVaultsBackupInstance_STATUS) AssignProperties_From_BackupVaultsBackupInstance_STATUS(source *storage.BackupVaultsBackupInstance_STATUS) error {

	// Conditions
	instance.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// Id
	instance.Id = genruntime.ClonePointerToString(source.Id)

	// Name
	instance.Name = genruntime.ClonePointerToString(source.Name)

	// Properties
	if source.Properties != nil {
		var property BackupInstance_STATUS
		err := property.AssignProperties_From_BackupInstance_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BackupInstance_STATUS() to populate field Properties")
		}
		instance.Properties = &property
	} else {
		instance.Properties = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		instance.SystemData = &systemDatum
	} else {
		instance.SystemData = nil
	}

	// Tags
	instance.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	instance.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_BackupVaultsBackupInstance_STATUS populates the provided destination BackupVaultsBackupInstance_STATUS from our BackupVaultsBackupInstance_STATUS
func (instance *BackupVaultsBackupInstance_STATUS) AssignProperties_To_BackupVaultsBackupInstance_STATUS(destination *storage.BackupVaultsBackupInstance_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(instance.Conditions)

	// Id
	destination.Id = genruntime.ClonePointerToString(instance.Id)

	// Name
	destination.Name = genruntime.ClonePointerToString(instance.Name)

	// Properties
	if instance.Properties != nil {
		var property storage.BackupInstance_STATUS
		err := instance.Properties.AssignProperties_To_BackupInstance_STATUS(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BackupInstance_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// SystemData
	if instance.SystemData != nil {
		var systemDatum storage.SystemData_STATUS
		err := instance.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(instance.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(instance.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Backup Instance
type BackupInstance struct {
	// +kubebuilder:validation:Required
	// DataSourceInfo: Gets or sets the data source information.
	DataSourceInfo *Datasource `json:"dataSourceInfo,omitempty"`

	// DataSourceSetInfo: Gets or sets the data source set information.
	DataSourceSetInfo *DatasourceSet `json:"dataSourceSetInfo,omitempty"`

	// DatasourceAuthCredentials: Credentials to use to authenticate with data source provider.
	DatasourceAuthCredentials *AuthCredentials `json:"datasourceAuthCredentials,omitempty"`

	// FriendlyName: Gets or sets the Backup Instance friendly name.
	FriendlyName *string `json:"friendlyName,omitempty"`

	// IdentityDetails: Contains information of the Identity Details for the BI.
	// If it is null, default will be considered as System Assigned.
	IdentityDetails *IdentityDetails `json:"identityDetails,omitempty"`

	// +kubebuilder:validation:Required
	ObjectType *string `json:"objectType,omitempty"`

	// +kubebuilder:validation:Required
	// PolicyInfo: Gets or sets the policy information.
	PolicyInfo *PolicyInfo `json:"policyInfo,omitempty"`

	// ValidationType: Specifies the type of validation. In case of DeepValidation, all validations from /validateForBackup API
	// will run again.
	ValidationType *BackupInstance_ValidationType `json:"validationType,omitempty"`
}

var _ genruntime.ARMTransformer = &BackupInstance{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (instance *BackupInstance) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if instance == nil {
		return nil, nil
	}
	result := &arm.BackupInstance{}

	// Set property "DataSourceInfo":
	if instance.DataSourceInfo != nil {
		dataSourceInfo_ARM, err := (*instance.DataSourceInfo).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dataSourceInfo := *dataSourceInfo_ARM.(*arm.Datasource)
		result.DataSourceInfo = &dataSourceInfo
	}

	// Set property "DataSourceSetInfo":
	if instance.DataSourceSetInfo != nil {
		dataSourceSetInfo_ARM, err := (*instance.DataSourceSetInfo).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dataSourceSetInfo := *dataSourceSetInfo_ARM.(*arm.DatasourceSet)
		result.DataSourceSetInfo = &dataSourceSetInfo
	}

	// Set property "DatasourceAuthCredentials":
	if instance.DatasourceAuthCredentials != nil {
		datasourceAuthCredentials_ARM, err := (*instance.DatasourceAuthCredentials).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		datasourceAuthCredentials := *datasourceAuthCredentials_ARM.(*arm.AuthCredentials)
		result.DatasourceAuthCredentials = &datasourceAuthCredentials
	}

	// Set property "FriendlyName":
	if instance.FriendlyName != nil {
		friendlyName := *instance.FriendlyName
		result.FriendlyName = &friendlyName
	}

	// Set property "IdentityDetails":
	if instance.IdentityDetails != nil {
		identityDetails_ARM, err := (*instance.IdentityDetails).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identityDetails := *identityDetails_ARM.(*arm.IdentityDetails)
		result.IdentityDetails = &identityDetails
	}

	// Set property "ObjectType":
	if instance.ObjectType != nil {
		objectType := *instance.ObjectType
		result.ObjectType = &objectType
	}

	// Set property "PolicyInfo":
	if instance.PolicyInfo != nil {
		policyInfo_ARM, err := (*instance.PolicyInfo).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		policyInfo := *policyInfo_ARM.(*arm.PolicyInfo)
		result.PolicyInfo = &policyInfo
	}

	// Set property "ValidationType":
	if instance.ValidationType != nil {
		var temp string
		temp = string(*instance.ValidationType)
		validationType := arm.BackupInstance_ValidationType(temp)
		result.ValidationType = &validationType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (instance *BackupInstance) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackupInstance{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (instance *BackupInstance) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackupInstance)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackupInstance, got %T", armInput)
	}

	// Set property "DataSourceInfo":
	if typedInput.DataSourceInfo != nil {
		var dataSourceInfo1 Datasource
		err := dataSourceInfo1.PopulateFromARM(owner, *typedInput.DataSourceInfo)
		if err != nil {
			return err
		}
		dataSourceInfo := dataSourceInfo1
		instance.DataSourceInfo = &dataSourceInfo
	}

	// Set property "DataSourceSetInfo":
	if typedInput.DataSourceSetInfo != nil {
		var dataSourceSetInfo1 DatasourceSet
		err := dataSourceSetInfo1.PopulateFromARM(owner, *typedInput.DataSourceSetInfo)
		if err != nil {
			return err
		}
		dataSourceSetInfo := dataSourceSetInfo1
		instance.DataSourceSetInfo = &dataSourceSetInfo
	}

	// Set property "DatasourceAuthCredentials":
	if typedInput.DatasourceAuthCredentials != nil {
		var datasourceAuthCredentials1 AuthCredentials
		err := datasourceAuthCredentials1.PopulateFromARM(owner, *typedInput.DatasourceAuthCredentials)
		if err != nil {
			return err
		}
		datasourceAuthCredentials := datasourceAuthCredentials1
		instance.DatasourceAuthCredentials = &datasourceAuthCredentials
	}

	// Set property "FriendlyName":
	if typedInput.FriendlyName != nil {
		friendlyName := *typedInput.FriendlyName
		instance.FriendlyName = &friendlyName
	}

	// Set property "IdentityDetails":
	if typedInput.IdentityDetails != nil {
		var identityDetails1 IdentityDetails
		err := identityDetails1.PopulateFromARM(owner, *typedInput.IdentityDetails)
		if err != nil {
			return err
		}
		identityDetails := identityDetails1
		instance.IdentityDetails = &identityDetails
	}

	// Set property "ObjectType":
	if typedInput.ObjectType != nil {
		objectType := *typedInput.ObjectType
		instance.ObjectType = &objectType
	}

	// Set property "PolicyInfo":
	if typedInput.PolicyInfo != nil {
		var policyInfo1 PolicyInfo
		err := policyInfo1.PopulateFromARM(owner, *typedInput.PolicyInfo)
		if err != nil {
			return err
		}
		policyInfo := policyInfo1
		instance.PolicyInfo = &policyInfo
	}

	// Set property "ValidationType":
	if typedInput.ValidationType != nil {
		var temp string
		temp = string(*typedInput.ValidationType)
		validationType := BackupInstance_ValidationType(temp)
		instance.ValidationType = &validationType
	}

	// No error
	return nil
}

// AssignProperties_From_BackupInstance populates our BackupInstance from the provided source BackupInstance
func (instance *BackupInstance) AssignProperties_From_BackupInstance(source *storage.BackupInstance) error {

	// DataSourceInfo
	if source.DataSourceInfo != nil {
		var dataSourceInfo Datasource
		err := dataSourceInfo.AssignProperties_From_Datasource(source.DataSourceInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Datasource() to populate field DataSourceInfo")
		}
		instance.DataSourceInfo = &dataSourceInfo
	} else {
		instance.DataSourceInfo = nil
	}

	// DataSourceSetInfo
	if source.DataSourceSetInfo != nil {
		var dataSourceSetInfo DatasourceSet
		err := dataSourceSetInfo.AssignProperties_From_DatasourceSet(source.DataSourceSetInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DatasourceSet() to populate field DataSourceSetInfo")
		}
		instance.DataSourceSetInfo = &dataSourceSetInfo
	} else {
		instance.DataSourceSetInfo = nil
	}

	// DatasourceAuthCredentials
	if source.DatasourceAuthCredentials != nil {
		var datasourceAuthCredential AuthCredentials
		err := datasourceAuthCredential.AssignProperties_From_AuthCredentials(source.DatasourceAuthCredentials)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AuthCredentials() to populate field DatasourceAuthCredentials")
		}
		instance.DatasourceAuthCredentials = &datasourceAuthCredential
	} else {
		instance.DatasourceAuthCredentials = nil
	}

	// FriendlyName
	instance.FriendlyName = genruntime.ClonePointerToString(source.FriendlyName)

	// IdentityDetails
	if source.IdentityDetails != nil {
		var identityDetail IdentityDetails
		err := identityDetail.AssignProperties_From_IdentityDetails(source.IdentityDetails)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_IdentityDetails() to populate field IdentityDetails")
		}
		instance.IdentityDetails = &identityDetail
	} else {
		instance.IdentityDetails = nil
	}

	// ObjectType
	instance.ObjectType = genruntime.ClonePointerToString(source.ObjectType)

	// PolicyInfo
	if source.PolicyInfo != nil {
		var policyInfo PolicyInfo
		err := policyInfo.AssignProperties_From_PolicyInfo(source.PolicyInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PolicyInfo() to populate field PolicyInfo")
		}
		instance.PolicyInfo = &policyInfo
	} else {
		instance.PolicyInfo = nil
	}

	// ValidationType
	if source.ValidationType != nil {
		validationType := *source.ValidationType
		validationTypeTemp := genruntime.ToEnum(validationType, backupInstance_ValidationType_Values)
		instance.ValidationType = &validationTypeTemp
	} else {
		instance.ValidationType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackupInstance populates the provided destination BackupInstance from our BackupInstance
func (instance *BackupInstance) AssignProperties_To_BackupInstance(destination *storage.BackupInstance) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataSourceInfo
	if instance.DataSourceInfo != nil {
		var dataSourceInfo storage.Datasource
		err := instance.DataSourceInfo.AssignProperties_To_Datasource(&dataSourceInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Datasource() to populate field DataSourceInfo")
		}
		destination.DataSourceInfo = &dataSourceInfo
	} else {
		destination.DataSourceInfo = nil
	}

	// DataSourceSetInfo
	if instance.DataSourceSetInfo != nil {
		var dataSourceSetInfo storage.DatasourceSet
		err := instance.DataSourceSetInfo.AssignProperties_To_DatasourceSet(&dataSourceSetInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DatasourceSet() to populate field DataSourceSetInfo")
		}
		destination.DataSourceSetInfo = &dataSourceSetInfo
	} else {
		destination.DataSourceSetInfo = nil
	}

	// DatasourceAuthCredentials
	if instance.DatasourceAuthCredentials != nil {
		var datasourceAuthCredential storage.AuthCredentials
		err := instance.DatasourceAuthCredentials.AssignProperties_To_AuthCredentials(&datasourceAuthCredential)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AuthCredentials() to populate field DatasourceAuthCredentials")
		}
		destination.DatasourceAuthCredentials = &datasourceAuthCredential
	} else {
		destination.DatasourceAuthCredentials = nil
	}

	// FriendlyName
	destination.FriendlyName = genruntime.ClonePointerToString(instance.FriendlyName)

	// IdentityDetails
	if instance.IdentityDetails != nil {
		var identityDetail storage.IdentityDetails
		err := instance.IdentityDetails.AssignProperties_To_IdentityDetails(&identityDetail)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_IdentityDetails() to populate field IdentityDetails")
		}
		destination.IdentityDetails = &identityDetail
	} else {
		destination.IdentityDetails = nil
	}

	// ObjectType
	destination.ObjectType = genruntime.ClonePointerToString(instance.ObjectType)

	// PolicyInfo
	if instance.PolicyInfo != nil {
		var policyInfo storage.PolicyInfo
		err := instance.PolicyInfo.AssignProperties_To_PolicyInfo(&policyInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PolicyInfo() to populate field PolicyInfo")
		}
		destination.PolicyInfo = &policyInfo
	} else {
		destination.PolicyInfo = nil
	}

	// ValidationType
	if instance.ValidationType != nil {
		validationType := string(*instance.ValidationType)
		destination.ValidationType = &validationType
	} else {
		destination.ValidationType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_BackupInstance_STATUS populates our BackupInstance from the provided source BackupInstance_STATUS
func (instance *BackupInstance) Initialize_From_BackupInstance_STATUS(source *BackupInstance_STATUS) error {

	// DataSourceInfo
	if source.DataSourceInfo != nil {
		var dataSourceInfo Datasource
		err := dataSourceInfo.Initialize_From_Datasource_STATUS(source.DataSourceInfo)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_Datasource_STATUS() to populate field DataSourceInfo")
		}
		instance.DataSourceInfo = &dataSourceInfo
	} else {
		instance.DataSourceInfo = nil
	}

	// DataSourceSetInfo
	if source.DataSourceSetInfo != nil {
		var dataSourceSetInfo DatasourceSet
		err := dataSourceSetInfo.Initialize_From_DatasourceSet_STATUS(source.DataSourceSetInfo)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DatasourceSet_STATUS() to populate field DataSourceSetInfo")
		}
		instance.DataSourceSetInfo = &dataSourceSetInfo
	} else {
		instance.DataSourceSetInfo = nil
	}

	// DatasourceAuthCredentials
	if source.DatasourceAuthCredentials != nil {
		var datasourceAuthCredential AuthCredentials
		err := datasourceAuthCredential.Initialize_From_AuthCredentials_STATUS(source.DatasourceAuthCredentials)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_AuthCredentials_STATUS() to populate field DatasourceAuthCredentials")
		}
		instance.DatasourceAuthCredentials = &datasourceAuthCredential
	} else {
		instance.DatasourceAuthCredentials = nil
	}

	// FriendlyName
	instance.FriendlyName = genruntime.ClonePointerToString(source.FriendlyName)

	// IdentityDetails
	if source.IdentityDetails != nil {
		var identityDetail IdentityDetails
		err := identityDetail.Initialize_From_IdentityDetails_STATUS(source.IdentityDetails)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_IdentityDetails_STATUS() to populate field IdentityDetails")
		}
		instance.IdentityDetails = &identityDetail
	} else {
		instance.IdentityDetails = nil
	}

	// ObjectType
	instance.ObjectType = genruntime.ClonePointerToString(source.ObjectType)

	// PolicyInfo
	if source.PolicyInfo != nil {
		var policyInfo PolicyInfo
		err := policyInfo.Initialize_From_PolicyInfo_STATUS(source.PolicyInfo)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_PolicyInfo_STATUS() to populate field PolicyInfo")
		}
		instance.PolicyInfo = &policyInfo
	} else {
		instance.PolicyInfo = nil
	}

	// ValidationType
	if source.ValidationType != nil {
		validationType := genruntime.ToEnum(string(*source.ValidationType), backupInstance_ValidationType_Values)
		instance.ValidationType = &validationType
	} else {
		instance.ValidationType = nil
	}

	// No error
	return nil
}

// Backup Instance
type BackupInstance_STATUS struct {
	// CurrentProtectionState: Specifies the current protection state of the resource
	CurrentProtectionState *BackupInstance_CurrentProtectionState_STATUS `json:"currentProtectionState,omitempty"`

	// DataSourceInfo: Gets or sets the data source information.
	DataSourceInfo *Datasource_STATUS `json:"dataSourceInfo,omitempty"`

	// DataSourceSetInfo: Gets or sets the data source set information.
	DataSourceSetInfo *DatasourceSet_STATUS `json:"dataSourceSetInfo,omitempty"`

	// DatasourceAuthCredentials: Credentials to use to authenticate with data source provider.
	DatasourceAuthCredentials *AuthCredentials_STATUS `json:"datasourceAuthCredentials,omitempty"`

	// FriendlyName: Gets or sets the Backup Instance friendly name.
	FriendlyName *string `json:"friendlyName,omitempty"`

	// IdentityDetails: Contains information of the Identity Details for the BI.
	// If it is null, default will be considered as System Assigned.
	IdentityDetails *IdentityDetails_STATUS `json:"identityDetails,omitempty"`
	ObjectType      *string                 `json:"objectType,omitempty"`

	// PolicyInfo: Gets or sets the policy information.
	PolicyInfo *PolicyInfo_STATUS `json:"policyInfo,omitempty"`

	// ProtectionErrorDetails: Specifies the protection error of the resource
	ProtectionErrorDetails *UserFacingError_STATUS `json:"protectionErrorDetails,omitempty"`

	// ProtectionStatus: Specifies the protection status of the resource
	ProtectionStatus *ProtectionStatusDetails_STATUS `json:"protectionStatus,omitempty"`

	// ProvisioningState: Specifies the provisioning state of the resource i.e. provisioning/updating/Succeeded/Failed
	ProvisioningState *string `json:"provisioningState,omitempty"`

	// ValidationType: Specifies the type of validation. In case of DeepValidation, all validations from /validateForBackup API
	// will run again.
	ValidationType *BackupInstance_ValidationType_STATUS `json:"validationType,omitempty"`
}

var _ genruntime.FromARMConverter = &BackupInstance_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (instance *BackupInstance_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackupInstance_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (instance *BackupInstance_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackupInstance_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackupInstance_STATUS, got %T", armInput)
	}

	// Set property "CurrentProtectionState":
	if typedInput.CurrentProtectionState != nil {
		var temp string
		temp = string(*typedInput.CurrentProtectionState)
		currentProtectionState := BackupInstance_CurrentProtectionState_STATUS(temp)
		instance.CurrentProtectionState = &currentProtectionState
	}

	// Set property "DataSourceInfo":
	if typedInput.DataSourceInfo != nil {
		var dataSourceInfo1 Datasource_STATUS
		err := dataSourceInfo1.PopulateFromARM(owner, *typedInput.DataSourceInfo)
		if err != nil {
			return err
		}
		dataSourceInfo := dataSourceInfo1
		instance.DataSourceInfo = &dataSourceInfo
	}

	// Set property "DataSourceSetInfo":
	if typedInput.DataSourceSetInfo != nil {
		var dataSourceSetInfo1 DatasourceSet_STATUS
		err := dataSourceSetInfo1.PopulateFromARM(owner, *typedInput.DataSourceSetInfo)
		if err != nil {
			return err
		}
		dataSourceSetInfo := dataSourceSetInfo1
		instance.DataSourceSetInfo = &dataSourceSetInfo
	}

	// Set property "DatasourceAuthCredentials":
	if typedInput.DatasourceAuthCredentials != nil {
		var datasourceAuthCredentials1 AuthCredentials_STATUS
		err := datasourceAuthCredentials1.PopulateFromARM(owner, *typedInput.DatasourceAuthCredentials)
		if err != nil {
			return err
		}
		datasourceAuthCredentials := datasourceAuthCredentials1
		instance.DatasourceAuthCredentials = &datasourceAuthCredentials
	}

	// Set property "FriendlyName":
	if typedInput.FriendlyName != nil {
		friendlyName := *typedInput.FriendlyName
		instance.FriendlyName = &friendlyName
	}

	// Set property "IdentityDetails":
	if typedInput.IdentityDetails != nil {
		var identityDetails1 IdentityDetails_STATUS
		err := identityDetails1.PopulateFromARM(owner, *typedInput.IdentityDetails)
		if err != nil {
			return err
		}
		identityDetails := identityDetails1
		instance.IdentityDetails = &identityDetails
	}

	// Set property "ObjectType":
	if typedInput.ObjectType != nil {
		objectType := *typedInput.ObjectType
		instance.ObjectType = &objectType
	}

	// Set property "PolicyInfo":
	if typedInput.PolicyInfo != nil {
		var policyInfo1 PolicyInfo_STATUS
		err := policyInfo1.PopulateFromARM(owner, *typedInput.PolicyInfo)
		if err != nil {
			return err
		}
		policyInfo := policyInfo1
		instance.PolicyInfo = &policyInfo
	}

	// Set property "ProtectionErrorDetails":
	if typedInput.ProtectionErrorDetails != nil {
		var protectionErrorDetails1 UserFacingError_STATUS
		err := protectionErrorDetails1.PopulateFromARM(owner, *typedInput.ProtectionErrorDetails)
		if err != nil {
			return err
		}
		protectionErrorDetails := protectionErrorDetails1
		instance.ProtectionErrorDetails = &protectionErrorDetails
	}

	// Set property "ProtectionStatus":
	if typedInput.ProtectionStatus != nil {
		var protectionStatus1 ProtectionStatusDetails_STATUS
		err := protectionStatus1.PopulateFromARM(owner, *typedInput.ProtectionStatus)
		if err != nil {
			return err
		}
		protectionStatus := protectionStatus1
		instance.ProtectionStatus = &protectionStatus
	}

	// Set property "ProvisioningState":
	if typedInput.ProvisioningState != nil {
		provisioningState := *typedInput.ProvisioningState
		instance.ProvisioningState = &provisioningState
	}

	// Set property "ValidationType":
	if typedInput.ValidationType != nil {
		var temp string
		temp = string(*typedInput.ValidationType)
		validationType := BackupInstance_ValidationType_STATUS(temp)
		instance.ValidationType = &validationType
	}

	// No error
	return nil
}

// AssignProperties_From_BackupInstance_STATUS populates our BackupInstance_STATUS from the provided source BackupInstance_STATUS
func (instance *BackupInstance_STATUS) AssignProperties_From_BackupInstance_STATUS(source *storage.BackupInstance_STATUS) error {

	// CurrentProtectionState
	if source.CurrentProtectionState != nil {
		currentProtectionState := *source.CurrentProtectionState
		currentProtectionStateTemp := genruntime.ToEnum(currentProtectionState, backupInstance_CurrentProtectionState_STATUS_Values)
		instance.CurrentProtectionState = &currentProtectionStateTemp
	} else {
		instance.CurrentProtectionState = nil
	}

	// DataSourceInfo
	if source.DataSourceInfo != nil {
		var dataSourceInfo Datasource_STATUS
		err := dataSourceInfo.AssignProperties_From_Datasource_STATUS(source.DataSourceInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Datasource_STATUS() to populate field DataSourceInfo")
		}
		instance.DataSourceInfo = &dataSourceInfo
	} else {
		instance.DataSourceInfo = nil
	}

	// DataSourceSetInfo
	if source.DataSourceSetInfo != nil {
		var dataSourceSetInfo DatasourceSet_STATUS
		err := dataSourceSetInfo.AssignProperties_From_DatasourceSet_STATUS(source.DataSourceSetInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DatasourceSet_STATUS() to populate field DataSourceSetInfo")
		}
		instance.DataSourceSetInfo = &dataSourceSetInfo
	} else {
		instance.DataSourceSetInfo = nil
	}

	// DatasourceAuthCredentials
	if source.DatasourceAuthCredentials != nil {
		var datasourceAuthCredential AuthCredentials_STATUS
		err := datasourceAuthCredential.AssignProperties_From_AuthCredentials_STATUS(source.DatasourceAuthCredentials)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AuthCredentials_STATUS() to populate field DatasourceAuthCredentials")
		}
		instance.DatasourceAuthCredentials = &datasourceAuthCredential
	} else {
		instance.DatasourceAuthCredentials = nil
	}

	// FriendlyName
	instance.FriendlyName = genruntime.ClonePointerToString(source.FriendlyName)

	// IdentityDetails
	if source.IdentityDetails != nil {
		var identityDetail IdentityDetails_STATUS
		err := identityDetail.AssignProperties_From_IdentityDetails_STATUS(source.IdentityDetails)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_IdentityDetails_STATUS() to populate field IdentityDetails")
		}
		instance.IdentityDetails = &identityDetail
	} else {
		instance.IdentityDetails = nil
	}

	// ObjectType
	instance.ObjectType = genruntime.ClonePointerToString(source.ObjectType)

	// PolicyInfo
	if source.PolicyInfo != nil {
		var policyInfo PolicyInfo_STATUS
		err := policyInfo.AssignProperties_From_PolicyInfo_STATUS(source.PolicyInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PolicyInfo_STATUS() to populate field PolicyInfo")
		}
		instance.PolicyInfo = &policyInfo
	} else {
		instance.PolicyInfo = nil
	}

	// ProtectionErrorDetails
	if source.ProtectionErrorDetails != nil {
		var protectionErrorDetail UserFacingError_STATUS
		err := protectionErrorDetail.AssignProperties_From_UserFacingError_STATUS(source.ProtectionErrorDetails)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UserFacingError_STATUS() to populate field ProtectionErrorDetails")
		}
		instance.ProtectionErrorDetails = &protectionErrorDetail
	} else {
		instance.ProtectionErrorDetails = nil
	}

	// ProtectionStatus
	if source.ProtectionStatus != nil {
		var protectionStatus ProtectionStatusDetails_STATUS
		err := protectionStatus.AssignProperties_From_ProtectionStatusDetails_STATUS(source.ProtectionStatus)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ProtectionStatusDetails_STATUS() to populate field ProtectionStatus")
		}
		instance.ProtectionStatus = &protectionStatus
	} else {
		instance.ProtectionStatus = nil
	}

	// ProvisioningState
	instance.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// ValidationType
	if source.ValidationType != nil {
		validationType := *source.ValidationType
		validationTypeTemp := genruntime.ToEnum(validationType, backupInstance_ValidationType_STATUS_Values)
		instance.ValidationType = &validationTypeTemp
	} else {
		instance.ValidationType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackupInstance_STATUS populates the provided destination BackupInstance_STATUS from our BackupInstance_STATUS
func (instance *BackupInstance_STATUS) AssignProperties_To_BackupInstance_STATUS(destination *storage.BackupInstance_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CurrentProtectionState
	if instance.CurrentProtectionState != nil {
		currentProtectionState := string(*instance.CurrentProtectionState)
		destination.CurrentProtectionState = &currentProtectionState
	} else {
		destination.CurrentProtectionState = nil
	}

	// DataSourceInfo
	if instance.DataSourceInfo != nil {
		var dataSourceInfo storage.Datasource_STATUS
		err := instance.DataSourceInfo.AssignProperties_To_Datasource_STATUS(&dataSourceInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Datasource_STATUS() to populate field DataSourceInfo")
		}
		destination.DataSourceInfo = &dataSourceInfo
	} else {
		destination.DataSourceInfo = nil
	}

	// DataSourceSetInfo
	if instance.DataSourceSetInfo != nil {
		var dataSourceSetInfo storage.DatasourceSet_STATUS
		err := instance.DataSourceSetInfo.AssignProperties_To_DatasourceSet_STATUS(&dataSourceSetInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DatasourceSet_STATUS() to populate field DataSourceSetInfo")
		}
		destination.DataSourceSetInfo = &dataSourceSetInfo
	} else {
		destination.DataSourceSetInfo = nil
	}

	// DatasourceAuthCredentials
	if instance.DatasourceAuthCredentials != nil {
		var datasourceAuthCredential storage.AuthCredentials_STATUS
		err := instance.DatasourceAuthCredentials.AssignProperties_To_AuthCredentials_STATUS(&datasourceAuthCredential)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AuthCredentials_STATUS() to populate field DatasourceAuthCredentials")
		}
		destination.DatasourceAuthCredentials = &datasourceAuthCredential
	} else {
		destination.DatasourceAuthCredentials = nil
	}

	// FriendlyName
	destination.FriendlyName = genruntime.ClonePointerToString(instance.FriendlyName)

	// IdentityDetails
	if instance.IdentityDetails != nil {
		var identityDetail storage.IdentityDetails_STATUS
		err := instance.IdentityDetails.AssignProperties_To_IdentityDetails_STATUS(&identityDetail)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_IdentityDetails_STATUS() to populate field IdentityDetails")
		}
		destination.IdentityDetails = &identityDetail
	} else {
		destination.IdentityDetails = nil
	}

	// ObjectType
	destination.ObjectType = genruntime.ClonePointerToString(instance.ObjectType)

	// PolicyInfo
	if instance.PolicyInfo != nil {
		var policyInfo storage.PolicyInfo_STATUS
		err := instance.PolicyInfo.AssignProperties_To_PolicyInfo_STATUS(&policyInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PolicyInfo_STATUS() to populate field PolicyInfo")
		}
		destination.PolicyInfo = &policyInfo
	} else {
		destination.PolicyInfo = nil
	}

	// ProtectionErrorDetails
	if instance.ProtectionErrorDetails != nil {
		var protectionErrorDetail storage.UserFacingError_STATUS
		err := instance.ProtectionErrorDetails.AssignProperties_To_UserFacingError_STATUS(&protectionErrorDetail)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UserFacingError_STATUS() to populate field ProtectionErrorDetails")
		}
		destination.ProtectionErrorDetails = &protectionErrorDetail
	} else {
		destination.ProtectionErrorDetails = nil
	}

	// ProtectionStatus
	if instance.ProtectionStatus != nil {
		var protectionStatus storage.ProtectionStatusDetails_STATUS
		err := instance.ProtectionStatus.AssignProperties_To_ProtectionStatusDetails_STATUS(&protectionStatus)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ProtectionStatusDetails_STATUS() to populate field ProtectionStatus")
		}
		destination.ProtectionStatus = &protectionStatus
	} else {
		destination.ProtectionStatus = nil
	}

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(instance.ProvisioningState)

	// ValidationType
	if instance.ValidationType != nil {
		validationType := string(*instance.ValidationType)
		destination.ValidationType = &validationType
	} else {
		destination.ValidationType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type BackupVaultsBackupInstanceOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_BackupVaultsBackupInstanceOperatorSpec populates our BackupVaultsBackupInstanceOperatorSpec from the provided source BackupVaultsBackupInstanceOperatorSpec
func (operator *BackupVaultsBackupInstanceOperatorSpec) AssignProperties_From_BackupVaultsBackupInstanceOperatorSpec(source *storage.BackupVaultsBackupInstanceOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackupVaultsBackupInstanceOperatorSpec populates the provided destination BackupVaultsBackupInstanceOperatorSpec from our BackupVaultsBackupInstanceOperatorSpec
func (operator *BackupVaultsBackupInstanceOperatorSpec) AssignProperties_To_BackupVaultsBackupInstanceOperatorSpec(destination *storage.BackupVaultsBackupInstanceOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AuthCredentials struct {
	// SecretStoreBasedAuthCredentials: Mutually exclusive with all other properties
	SecretStoreBasedAuthCredentials *SecretStoreBasedAuthCredentials `json:"secretStoreBasedAuthCredentials,omitempty"`
}

var _ genruntime.ARMTransformer = &AuthCredentials{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (credentials *AuthCredentials) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if credentials == nil {
		return nil, nil
	}
	result := &arm.AuthCredentials{}

	// Set property "SecretStoreBasedAuthCredentials":
	if credentials.SecretStoreBasedAuthCredentials != nil {
		secretStoreBasedAuthCredentials_ARM, err := (*credentials.SecretStoreBasedAuthCredentials).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		secretStoreBasedAuthCredentials := *secretStoreBasedAuthCredentials_ARM.(*arm.SecretStoreBasedAuthCredentials)
		result.SecretStoreBasedAuthCredentials = &secretStoreBasedAuthCredentials
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (credentials *AuthCredentials) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AuthCredentials{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (credentials *AuthCredentials) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AuthCredentials)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AuthCredentials, got %T", armInput)
	}

	// Set property "SecretStoreBasedAuthCredentials":
	if typedInput.SecretStoreBasedAuthCredentials != nil {
		var secretStoreBasedAuthCredentials1 SecretStoreBasedAuthCredentials
		err := secretStoreBasedAuthCredentials1.PopulateFromARM(owner, *typedInput.SecretStoreBasedAuthCredentials)
		if err != nil {
			return err
		}
		secretStoreBasedAuthCredentials := secretStoreBasedAuthCredentials1
		credentials.SecretStoreBasedAuthCredentials = &secretStoreBasedAuthCredentials
	}

	// No error
	return nil
}

// AssignProperties_From_AuthCredentials populates our AuthCredentials from the provided source AuthCredentials
func (credentials *AuthCredentials) AssignProperties_From_AuthCredentials(source *storage.AuthCredentials) error {

	// SecretStoreBasedAuthCredentials
	if source.SecretStoreBasedAuthCredentials != nil {
		var secretStoreBasedAuthCredential SecretStoreBasedAuthCredentials
		err := secretStoreBasedAuthCredential.AssignProperties_From_SecretStoreBasedAuthCredentials(source.SecretStoreBasedAuthCredentials)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SecretStoreBasedAuthCredentials() to populate field SecretStoreBasedAuthCredentials")
		}
		credentials.SecretStoreBasedAuthCredentials = &secretStoreBasedAuthCredential
	} else {
		credentials.SecretStoreBasedAuthCredentials = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AuthCredentials populates the provided destination AuthCredentials from our AuthCredentials
func (credentials *AuthCredentials) AssignProperties_To_AuthCredentials(destination *storage.AuthCredentials) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SecretStoreBasedAuthCredentials
	if credentials.SecretStoreBasedAuthCredentials != nil {
		var secretStoreBasedAuthCredential storage.SecretStoreBasedAuthCredentials
		err := credentials.SecretStoreBasedAuthCredentials.AssignProperties_To_SecretStoreBasedAuthCredentials(&secretStoreBasedAuthCredential)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SecretStoreBasedAuthCredentials() to populate field SecretStoreBasedAuthCredentials")
		}
		destination.SecretStoreBasedAuthCredentials = &secretStoreBasedAuthCredential
	} else {
		destination.SecretStoreBasedAuthCredentials = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AuthCredentials_STATUS populates our AuthCredentials from the provided source AuthCredentials_STATUS
func (credentials *AuthCredentials) Initialize_From_AuthCredentials_STATUS(source *AuthCredentials_STATUS) error {

	// SecretStoreBasedAuthCredentials
	if source.SecretStoreBasedAuthCredentials != nil {
		var secretStoreBasedAuthCredential SecretStoreBasedAuthCredentials
		err := secretStoreBasedAuthCredential.Initialize_From_SecretStoreBasedAuthCredentials_STATUS(source.SecretStoreBasedAuthCredentials)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SecretStoreBasedAuthCredentials_STATUS() to populate field SecretStoreBasedAuthCredentials")
		}
		credentials.SecretStoreBasedAuthCredentials = &secretStoreBasedAuthCredential
	} else {
		credentials.SecretStoreBasedAuthCredentials = nil
	}

	// No error
	return nil
}

type AuthCredentials_STATUS struct {
	// SecretStoreBasedAuthCredentials: Mutually exclusive with all other properties
	SecretStoreBasedAuthCredentials *SecretStoreBasedAuthCredentials_STATUS `json:"secretStoreBasedAuthCredentials,omitempty"`
}

var _ genruntime.FromARMConverter = &AuthCredentials_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (credentials *AuthCredentials_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AuthCredentials_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (credentials *AuthCredentials_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AuthCredentials_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AuthCredentials_STATUS, got %T", armInput)
	}

	// Set property "SecretStoreBasedAuthCredentials":
	if typedInput.SecretStoreBasedAuthCredentials != nil {
		var secretStoreBasedAuthCredentials1 SecretStoreBasedAuthCredentials_STATUS
		err := secretStoreBasedAuthCredentials1.PopulateFromARM(owner, *typedInput.SecretStoreBasedAuthCredentials)
		if err != nil {
			return err
		}
		secretStoreBasedAuthCredentials := secretStoreBasedAuthCredentials1
		credentials.SecretStoreBasedAuthCredentials = &secretStoreBasedAuthCredentials
	}

	// No error
	return nil
}

// AssignProperties_From_AuthCredentials_STATUS populates our AuthCredentials_STATUS from the provided source AuthCredentials_STATUS
func (credentials *AuthCredentials_STATUS) AssignProperties_From_AuthCredentials_STATUS(source *storage.AuthCredentials_STATUS) error {

	// SecretStoreBasedAuthCredentials
	if source.SecretStoreBasedAuthCredentials != nil {
		var secretStoreBasedAuthCredential SecretStoreBasedAuthCredentials_STATUS
		err := secretStoreBasedAuthCredential.AssignProperties_From_SecretStoreBasedAuthCredentials_STATUS(source.SecretStoreBasedAuthCredentials)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SecretStoreBasedAuthCredentials_STATUS() to populate field SecretStoreBasedAuthCredentials")
		}
		credentials.SecretStoreBasedAuthCredentials = &secretStoreBasedAuthCredential
	} else {
		credentials.SecretStoreBasedAuthCredentials = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AuthCredentials_STATUS populates the provided destination AuthCredentials_STATUS from our AuthCredentials_STATUS
func (credentials *AuthCredentials_STATUS) AssignProperties_To_AuthCredentials_STATUS(destination *storage.AuthCredentials_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SecretStoreBasedAuthCredentials
	if credentials.SecretStoreBasedAuthCredentials != nil {
		var secretStoreBasedAuthCredential storage.SecretStoreBasedAuthCredentials_STATUS
		err := credentials.SecretStoreBasedAuthCredentials.AssignProperties_To_SecretStoreBasedAuthCredentials_STATUS(&secretStoreBasedAuthCredential)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SecretStoreBasedAuthCredentials_STATUS() to populate field SecretStoreBasedAuthCredentials")
		}
		destination.SecretStoreBasedAuthCredentials = &secretStoreBasedAuthCredential
	} else {
		destination.SecretStoreBasedAuthCredentials = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type BackupInstance_CurrentProtectionState_STATUS string

const (
	BackupInstance_CurrentProtectionState_STATUS_BackupSchedulesSuspended    = BackupInstance_CurrentProtectionState_STATUS("BackupSchedulesSuspended")
	BackupInstance_CurrentProtectionState_STATUS_ConfiguringProtection       = BackupInstance_CurrentProtectionState_STATUS("ConfiguringProtection")
	BackupInstance_CurrentProtectionState_STATUS_ConfiguringProtectionFailed = BackupInstance_CurrentProtectionState_STATUS("ConfiguringProtectionFailed")
	BackupInstance_CurrentProtectionState_STATUS_Invalid                     = BackupInstance_CurrentProtectionState_STATUS("Invalid")
	BackupInstance_CurrentProtectionState_STATUS_NotProtected                = BackupInstance_CurrentProtectionState_STATUS("NotProtected")
	BackupInstance_CurrentProtectionState_STATUS_ProtectionConfigured        = BackupInstance_CurrentProtectionState_STATUS("ProtectionConfigured")
	BackupInstance_CurrentProtectionState_STATUS_ProtectionError             = BackupInstance_CurrentProtectionState_STATUS("ProtectionError")
	BackupInstance_CurrentProtectionState_STATUS_ProtectionStopped           = BackupInstance_CurrentProtectionState_STATUS("ProtectionStopped")
	BackupInstance_CurrentProtectionState_STATUS_RetentionSchedulesSuspended = BackupInstance_CurrentProtectionState_STATUS("RetentionSchedulesSuspended")
	BackupInstance_CurrentProtectionState_STATUS_SoftDeleted                 = BackupInstance_CurrentProtectionState_STATUS("SoftDeleted")
	BackupInstance_CurrentProtectionState_STATUS_SoftDeleting                = BackupInstance_CurrentProtectionState_STATUS("SoftDeleting")
	BackupInstance_CurrentProtectionState_STATUS_UpdatingProtection          = BackupInstance_CurrentProtectionState_STATUS("UpdatingProtection")
)

// Mapping from string to BackupInstance_CurrentProtectionState_STATUS
var backupInstance_CurrentProtectionState_STATUS_Values = map[string]BackupInstance_CurrentProtectionState_STATUS{
	"backupschedulessuspended":    BackupInstance_CurrentProtectionState_STATUS_BackupSchedulesSuspended,
	"configuringprotection":       BackupInstance_CurrentProtectionState_STATUS_ConfiguringProtection,
	"configuringprotectionfailed": BackupInstance_CurrentProtectionState_STATUS_ConfiguringProtectionFailed,
	"invalid":                     BackupInstance_CurrentProtectionState_STATUS_Invalid,
	"notprotected":                BackupInstance_CurrentProtectionState_STATUS_NotProtected,
	"protectionconfigured":        BackupInstance_CurrentProtectionState_STATUS_ProtectionConfigured,
	"protectionerror":             BackupInstance_CurrentProtectionState_STATUS_ProtectionError,
	"protectionstopped":           BackupInstance_CurrentProtectionState_STATUS_ProtectionStopped,
	"retentionschedulessuspended": BackupInstance_CurrentProtectionState_STATUS_RetentionSchedulesSuspended,
	"softdeleted":                 BackupInstance_CurrentProtectionState_STATUS_SoftDeleted,
	"softdeleting":                BackupInstance_CurrentProtectionState_STATUS_SoftDeleting,
	"updatingprotection":          BackupInstance_CurrentProtectionState_STATUS_UpdatingProtection,
}

// +kubebuilder:validation:Enum={"DeepValidation","ShallowValidation"}
type BackupInstance_ValidationType string

const (
	BackupInstance_ValidationType_DeepValidation    = BackupInstance_ValidationType("DeepValidation")
	BackupInstance_ValidationType_ShallowValidation = BackupInstance_ValidationType("ShallowValidation")
)

// Mapping from string to BackupInstance_ValidationType
var backupInstance_ValidationType_Values = map[string]BackupInstance_ValidationType{
	"deepvalidation":    BackupInstance_ValidationType_DeepValidation,
	"shallowvalidation": BackupInstance_ValidationType_ShallowValidation,
}

type BackupInstance_ValidationType_STATUS string

const (
	BackupInstance_ValidationType_STATUS_DeepValidation    = BackupInstance_ValidationType_STATUS("DeepValidation")
	BackupInstance_ValidationType_STATUS_ShallowValidation = BackupInstance_ValidationType_STATUS("ShallowValidation")
)

// Mapping from string to BackupInstance_ValidationType_STATUS
var backupInstance_ValidationType_STATUS_Values = map[string]BackupInstance_ValidationType_STATUS{
	"deepvalidation":    BackupInstance_ValidationType_STATUS_DeepValidation,
	"shallowvalidation": BackupInstance_ValidationType_STATUS_ShallowValidation,
}

// Datasource to be backed up
type Datasource struct {
	// DatasourceType: DatasourceType of the resource.
	DatasourceType *string `json:"datasourceType,omitempty"`

	// ObjectType: Type of Datasource object, used to initialize the right inherited type
	ObjectType *string `json:"objectType,omitempty"`

	// ResourceLocation: Location of datasource.
	ResourceLocation *string `json:"resourceLocation,omitempty"`

	// ResourceName: Unique identifier of the resource in the context of parent.
	ResourceName *string `json:"resourceName,omitempty"`

	// ResourceProperties: Properties specific to data source
	ResourceProperties *BaseResourceProperties `json:"resourceProperties,omitempty"`

	// +kubebuilder:validation:Required
	// ResourceReference: Full ARM ID of the resource. For azure resources, this is ARM ID. For non azure resources, this will
	// be the ID created by backup service via Fabric/Vault.
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceID" json:"resourceReference,omitempty"`

	// ResourceType: Resource Type of Datasource.
	ResourceType *string `json:"resourceType,omitempty"`

	// ResourceUri: Uri of the resource.
	ResourceUri *string `json:"resourceUri,omitempty"`
}

var _ genruntime.ARMTransformer = &Datasource{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (datasource *Datasource) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if datasource == nil {
		return nil, nil
	}
	result := &arm.Datasource{}

	// Set property "DatasourceType":
	if datasource.DatasourceType != nil {
		datasourceType := *datasource.DatasourceType
		result.DatasourceType = &datasourceType
	}

	// Set property "ObjectType":
	if datasource.ObjectType != nil {
		objectType := *datasource.ObjectType
		result.ObjectType = &objectType
	}

	// Set property "ResourceID":
	if datasource.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*datasource.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceID = &resourceReference
	}

	// Set property "ResourceLocation":
	if datasource.ResourceLocation != nil {
		resourceLocation := *datasource.ResourceLocation
		result.ResourceLocation = &resourceLocation
	}

	// Set property "ResourceName":
	if datasource.ResourceName != nil {
		resourceName := *datasource.ResourceName
		result.ResourceName = &resourceName
	}

	// Set property "ResourceProperties":
	if datasource.ResourceProperties != nil {
		resourceProperties_ARM, err := (*datasource.ResourceProperties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		resourceProperties := *resourceProperties_ARM.(*arm.BaseResourceProperties)
		result.ResourceProperties = &resourceProperties
	}

	// Set property "ResourceType":
	if datasource.ResourceType != nil {
		resourceType := *datasource.ResourceType
		result.ResourceType = &resourceType
	}

	// Set property "ResourceUri":
	if datasource.ResourceUri != nil {
		resourceUri := *datasource.ResourceUri
		result.ResourceUri = &resourceUri
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (datasource *Datasource) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Datasource{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (datasource *Datasource) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Datasource)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Datasource, got %T", armInput)
	}

	// Set property "DatasourceType":
	if typedInput.DatasourceType != nil {
		datasourceType := *typedInput.DatasourceType
		datasource.DatasourceType = &datasourceType
	}

	// Set property "ObjectType":
	if typedInput.ObjectType != nil {
		objectType := *typedInput.ObjectType
		datasource.ObjectType = &objectType
	}

	// Set property "ResourceLocation":
	if typedInput.ResourceLocation != nil {
		resourceLocation := *typedInput.ResourceLocation
		datasource.ResourceLocation = &resourceLocation
	}

	// Set property "ResourceName":
	if typedInput.ResourceName != nil {
		resourceName := *typedInput.ResourceName
		datasource.ResourceName = &resourceName
	}

	// Set property "ResourceProperties":
	if typedInput.ResourceProperties != nil {
		var resourceProperties1 BaseResourceProperties
		err := resourceProperties1.PopulateFromARM(owner, *typedInput.ResourceProperties)
		if err != nil {
			return err
		}
		resourceProperties := resourceProperties1
		datasource.ResourceProperties = &resourceProperties
	}

	// no assignment for property "ResourceReference"

	// Set property "ResourceType":
	if typedInput.ResourceType != nil {
		resourceType := *typedInput.ResourceType
		datasource.ResourceType = &resourceType
	}

	// Set property "ResourceUri":
	if typedInput.ResourceUri != nil {
		resourceUri := *typedInput.ResourceUri
		datasource.ResourceUri = &resourceUri
	}

	// No error
	return nil
}

// AssignProperties_From_Datasource populates our Datasource from the provided source Datasource
func (datasource *Datasource) AssignProperties_From_Datasource(source *storage.Datasource) error {

	// DatasourceType
	datasource.DatasourceType = genruntime.ClonePointerToString(source.DatasourceType)

	// ObjectType
	datasource.ObjectType = genruntime.ClonePointerToString(source.ObjectType)

	// ResourceLocation
	datasource.ResourceLocation = genruntime.ClonePointerToString(source.ResourceLocation)

	// ResourceName
	datasource.ResourceName = genruntime.ClonePointerToString(source.ResourceName)

	// ResourceProperties
	if source.ResourceProperties != nil {
		var resourceProperty BaseResourceProperties
		err := resourceProperty.AssignProperties_From_BaseResourceProperties(source.ResourceProperties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BaseResourceProperties() to populate field ResourceProperties")
		}
		datasource.ResourceProperties = &resourceProperty
	} else {
		datasource.ResourceProperties = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		datasource.ResourceReference = &resourceReference
	} else {
		datasource.ResourceReference = nil
	}

	// ResourceType
	datasource.ResourceType = genruntime.ClonePointerToString(source.ResourceType)

	// ResourceUri
	datasource.ResourceUri = genruntime.ClonePointerToString(source.ResourceUri)

	// No error
	return nil
}

// AssignProperties_To_Datasource populates the provided destination Datasource from our Datasource
func (datasource *Datasource) AssignProperties_To_Datasource(destination *storage.Datasource) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DatasourceType
	destination.DatasourceType = genruntime.ClonePointerToString(datasource.DatasourceType)

	// ObjectType
	destination.ObjectType = genruntime.ClonePointerToString(datasource.ObjectType)

	// ResourceLocation
	destination.ResourceLocation = genruntime.ClonePointerToString(datasource.ResourceLocation)

	// ResourceName
	destination.ResourceName = genruntime.ClonePointerToString(datasource.ResourceName)

	// ResourceProperties
	if datasource.ResourceProperties != nil {
		var resourceProperty storage.BaseResourceProperties
		err := datasource.ResourceProperties.AssignProperties_To_BaseResourceProperties(&resourceProperty)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BaseResourceProperties() to populate field ResourceProperties")
		}
		destination.ResourceProperties = &resourceProperty
	} else {
		destination.ResourceProperties = nil
	}

	// ResourceReference
	if datasource.ResourceReference != nil {
		resourceReference := datasource.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// ResourceType
	destination.ResourceType = genruntime.ClonePointerToString(datasource.ResourceType)

	// ResourceUri
	destination.ResourceUri = genruntime.ClonePointerToString(datasource.ResourceUri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Datasource_STATUS populates our Datasource from the provided source Datasource_STATUS
func (datasource *Datasource) Initialize_From_Datasource_STATUS(source *Datasource_STATUS) error {

	// DatasourceType
	datasource.DatasourceType = genruntime.ClonePointerToString(source.DatasourceType)

	// ObjectType
	datasource.ObjectType = genruntime.ClonePointerToString(source.ObjectType)

	// ResourceLocation
	datasource.ResourceLocation = genruntime.ClonePointerToString(source.ResourceLocation)

	// ResourceName
	datasource.ResourceName = genruntime.ClonePointerToString(source.ResourceName)

	// ResourceProperties
	if source.ResourceProperties != nil {
		var resourceProperty BaseResourceProperties
		err := resourceProperty.Initialize_From_BaseResourceProperties_STATUS(source.ResourceProperties)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_BaseResourceProperties_STATUS() to populate field ResourceProperties")
		}
		datasource.ResourceProperties = &resourceProperty
	} else {
		datasource.ResourceProperties = nil
	}

	// ResourceType
	datasource.ResourceType = genruntime.ClonePointerToString(source.ResourceType)

	// ResourceUri
	datasource.ResourceUri = genruntime.ClonePointerToString(source.ResourceUri)

	// No error
	return nil
}

// Datasource to be backed up
type Datasource_STATUS struct {
	// DatasourceType: DatasourceType of the resource.
	DatasourceType *string `json:"datasourceType,omitempty"`

	// ObjectType: Type of Datasource object, used to initialize the right inherited type
	ObjectType *string `json:"objectType,omitempty"`

	// ResourceID: Full ARM ID of the resource. For azure resources, this is ARM ID. For non azure resources, this will be the
	// ID created by backup service via Fabric/Vault.
	ResourceID *string `json:"resourceID,omitempty"`

	// ResourceLocation: Location of datasource.
	ResourceLocation *string `json:"resourceLocation,omitempty"`

	// ResourceName: Unique identifier of the resource in the context of parent.
	ResourceName *string `json:"resourceName,omitempty"`

	// ResourceProperties: Properties specific to data source
	ResourceProperties *BaseResourceProperties_STATUS `json:"resourceProperties,omitempty"`

	// ResourceType: Resource Type of Datasource.
	ResourceType *string `json:"resourceType,omitempty"`

	// ResourceUri: Uri of the resource.
	ResourceUri *string `json:"resourceUri,omitempty"`
}

var _ genruntime.FromARMConverter = &Datasource_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (datasource *Datasource_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Datasource_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (datasource *Datasource_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Datasource_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Datasource_STATUS, got %T", armInput)
	}

	// Set property "DatasourceType":
	if typedInput.DatasourceType != nil {
		datasourceType := *typedInput.DatasourceType
		datasource.DatasourceType = &datasourceType
	}

	// Set property "ObjectType":
	if typedInput.ObjectType != nil {
		objectType := *typedInput.ObjectType
		datasource.ObjectType = &objectType
	}

	// Set property "ResourceID":
	if typedInput.ResourceID != nil {
		resourceID := *typedInput.ResourceID
		datasource.ResourceID = &resourceID
	}

	// Set property "ResourceLocation":
	if typedInput.ResourceLocation != nil {
		resourceLocation := *typedInput.ResourceLocation
		datasource.ResourceLocation = &resourceLocation
	}

	// Set property "ResourceName":
	if typedInput.ResourceName != nil {
		resourceName := *typedInput.ResourceName
		datasource.ResourceName = &resourceName
	}

	// Set property "ResourceProperties":
	if typedInput.ResourceProperties != nil {
		var resourceProperties1 BaseResourceProperties_STATUS
		err := resourceProperties1.PopulateFromARM(owner, *typedInput.ResourceProperties)
		if err != nil {
			return err
		}
		resourceProperties := resourceProperties1
		datasource.ResourceProperties = &resourceProperties
	}

	// Set property "ResourceType":
	if typedInput.ResourceType != nil {
		resourceType := *typedInput.ResourceType
		datasource.ResourceType = &resourceType
	}

	// Set property "ResourceUri":
	if typedInput.ResourceUri != nil {
		resourceUri := *typedInput.ResourceUri
		datasource.ResourceUri = &resourceUri
	}

	// No error
	return nil
}

// AssignProperties_From_Datasource_STATUS populates our Datasource_STATUS from the provided source Datasource_STATUS
func (datasource *Datasource_STATUS) AssignProperties_From_Datasource_STATUS(source *storage.Datasource_STATUS) error {

	// DatasourceType
	datasource.DatasourceType = genruntime.ClonePointerToString(source.DatasourceType)

	// ObjectType
	datasource.ObjectType = genruntime.ClonePointerToString(source.ObjectType)

	// ResourceID
	datasource.ResourceID = genruntime.ClonePointerToString(source.ResourceID)

	// ResourceLocation
	datasource.ResourceLocation = genruntime.ClonePointerToString(source.ResourceLocation)

	// ResourceName
	datasource.ResourceName = genruntime.ClonePointerToString(source.ResourceName)

	// ResourceProperties
	if source.ResourceProperties != nil {
		var resourceProperty BaseResourceProperties_STATUS
		err := resourceProperty.AssignProperties_From_BaseResourceProperties_STATUS(source.ResourceProperties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BaseResourceProperties_STATUS() to populate field ResourceProperties")
		}
		datasource.ResourceProperties = &resourceProperty
	} else {
		datasource.ResourceProperties = nil
	}

	// ResourceType
	datasource.ResourceType = genruntime.ClonePointerToString(source.ResourceType)

	// ResourceUri
	datasource.ResourceUri = genruntime.ClonePointerToString(source.ResourceUri)

	// No error
	return nil
}

// AssignProperties_To_Datasource_STATUS populates the provided destination Datasource_STATUS from our Datasource_STATUS
func (datasource *Datasource_STATUS) AssignProperties_To_Datasource_STATUS(destination *storage.Datasource_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DatasourceType
	destination.DatasourceType = genruntime.ClonePointerToString(datasource.DatasourceType)

	// ObjectType
	destination.ObjectType = genruntime.ClonePointerToString(datasource.ObjectType)

	// ResourceID
	destination.ResourceID = genruntime.ClonePointerToString(datasource.ResourceID)

	// ResourceLocation
	destination.ResourceLocation = genruntime.ClonePointerToString(datasource.ResourceLocation)

	// ResourceName
	destination.ResourceName = genruntime.ClonePointerToString(datasource.ResourceName)

	// ResourceProperties
	if datasource.ResourceProperties != nil {
		var resourceProperty storage.BaseResourceProperties_STATUS
		err := datasource.ResourceProperties.AssignProperties_To_BaseResourceProperties_STATUS(&resourceProperty)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BaseResourceProperties_STATUS() to populate field ResourceProperties")
		}
		destination.ResourceProperties = &resourceProperty
	} else {
		destination.ResourceProperties = nil
	}

	// ResourceType
	destination.ResourceType = genruntime.ClonePointerToString(datasource.ResourceType)

	// ResourceUri
	destination.ResourceUri = genruntime.ClonePointerToString(datasource.ResourceUri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// DatasourceSet details of datasource to be backed up
type DatasourceSet struct {
	// DatasourceType: DatasourceType of the resource.
	DatasourceType *string `json:"datasourceType,omitempty"`

	// ObjectType: Type of Datasource object, used to initialize the right inherited type
	ObjectType *string `json:"objectType,omitempty"`

	// ResourceLocation: Location of datasource.
	ResourceLocation *string `json:"resourceLocation,omitempty"`

	// ResourceName: Unique identifier of the resource in the context of parent.
	ResourceName *string `json:"resourceName,omitempty"`

	// ResourceProperties: Properties specific to data source set
	ResourceProperties *BaseResourceProperties `json:"resourceProperties,omitempty"`

	// +kubebuilder:validation:Required
	// ResourceReference: Full ARM ID of the resource. For azure resources, this is ARM ID. For non azure resources, this will
	// be the ID created by backup service via Fabric/Vault.
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceID" json:"resourceReference,omitempty"`

	// ResourceType: Resource Type of Datasource.
	ResourceType *string `json:"resourceType,omitempty"`

	// ResourceUri: Uri of the resource.
	ResourceUri *string `json:"resourceUri,omitempty"`
}

var _ genruntime.ARMTransformer = &DatasourceSet{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (datasourceSet *DatasourceSet) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if datasourceSet == nil {
		return nil, nil
	}
	result := &arm.DatasourceSet{}

	// Set property "DatasourceType":
	if datasourceSet.DatasourceType != nil {
		datasourceType := *datasourceSet.DatasourceType
		result.DatasourceType = &datasourceType
	}

	// Set property "ObjectType":
	if datasourceSet.ObjectType != nil {
		objectType := *datasourceSet.ObjectType
		result.ObjectType = &objectType
	}

	// Set property "ResourceID":
	if datasourceSet.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*datasourceSet.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceID = &resourceReference
	}

	// Set property "ResourceLocation":
	if datasourceSet.ResourceLocation != nil {
		resourceLocation := *datasourceSet.ResourceLocation
		result.ResourceLocation = &resourceLocation
	}

	// Set property "ResourceName":
	if datasourceSet.ResourceName != nil {
		resourceName := *datasourceSet.ResourceName
		result.ResourceName = &resourceName
	}

	// Set property "ResourceProperties":
	if datasourceSet.ResourceProperties != nil {
		resourceProperties_ARM, err := (*datasourceSet.ResourceProperties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		resourceProperties := *resourceProperties_ARM.(*arm.BaseResourceProperties)
		result.ResourceProperties = &resourceProperties
	}

	// Set property "ResourceType":
	if datasourceSet.ResourceType != nil {
		resourceType := *datasourceSet.ResourceType
		result.ResourceType = &resourceType
	}

	// Set property "ResourceUri":
	if datasourceSet.ResourceUri != nil {
		resourceUri := *datasourceSet.ResourceUri
		result.ResourceUri = &resourceUri
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (datasourceSet *DatasourceSet) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DatasourceSet{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (datasourceSet *DatasourceSet) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DatasourceSet)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DatasourceSet, got %T", armInput)
	}

	// Set property "DatasourceType":
	if typedInput.DatasourceType != nil {
		datasourceType := *typedInput.DatasourceType
		datasourceSet.DatasourceType = &datasourceType
	}

	// Set property "ObjectType":
	if typedInput.ObjectType != nil {
		objectType := *typedInput.ObjectType
		datasourceSet.ObjectType = &objectType
	}

	// Set property "ResourceLocation":
	if typedInput.ResourceLocation != nil {
		resourceLocation := *typedInput.ResourceLocation
		datasourceSet.ResourceLocation = &resourceLocation
	}

	// Set property "ResourceName":
	if typedInput.ResourceName != nil {
		resourceName := *typedInput.ResourceName
		datasourceSet.ResourceName = &resourceName
	}

	// Set property "ResourceProperties":
	if typedInput.ResourceProperties != nil {
		var resourceProperties1 BaseResourceProperties
		err := resourceProperties1.PopulateFromARM(owner, *typedInput.ResourceProperties)
		if err != nil {
			return err
		}
		resourceProperties := resourceProperties1
		datasourceSet.ResourceProperties = &resourceProperties
	}

	// no assignment for property "ResourceReference"

	// Set property "ResourceType":
	if typedInput.ResourceType != nil {
		resourceType := *typedInput.ResourceType
		datasourceSet.ResourceType = &resourceType
	}

	// Set property "ResourceUri":
	if typedInput.ResourceUri != nil {
		resourceUri := *typedInput.ResourceUri
		datasourceSet.ResourceUri = &resourceUri
	}

	// No error
	return nil
}

// AssignProperties_From_DatasourceSet populates our DatasourceSet from the provided source DatasourceSet
func (datasourceSet *DatasourceSet) AssignProperties_From_DatasourceSet(source *storage.DatasourceSet) error {

	// DatasourceType
	datasourceSet.DatasourceType = genruntime.ClonePointerToString(source.DatasourceType)

	// ObjectType
	datasourceSet.ObjectType = genruntime.ClonePointerToString(source.ObjectType)

	// ResourceLocation
	datasourceSet.ResourceLocation = genruntime.ClonePointerToString(source.ResourceLocation)

	// ResourceName
	datasourceSet.ResourceName = genruntime.ClonePointerToString(source.ResourceName)

	// ResourceProperties
	if source.ResourceProperties != nil {
		var resourceProperty BaseResourceProperties
		err := resourceProperty.AssignProperties_From_BaseResourceProperties(source.ResourceProperties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BaseResourceProperties() to populate field ResourceProperties")
		}
		datasourceSet.ResourceProperties = &resourceProperty
	} else {
		datasourceSet.ResourceProperties = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		datasourceSet.ResourceReference = &resourceReference
	} else {
		datasourceSet.ResourceReference = nil
	}

	// ResourceType
	datasourceSet.ResourceType = genruntime.ClonePointerToString(source.ResourceType)

	// ResourceUri
	datasourceSet.ResourceUri = genruntime.ClonePointerToString(source.ResourceUri)

	// No error
	return nil
}

// AssignProperties_To_DatasourceSet populates the provided destination DatasourceSet from our DatasourceSet
func (datasourceSet *DatasourceSet) AssignProperties_To_DatasourceSet(destination *storage.DatasourceSet) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DatasourceType
	destination.DatasourceType = genruntime.ClonePointerToString(datasourceSet.DatasourceType)

	// ObjectType
	destination.ObjectType = genruntime.ClonePointerToString(datasourceSet.ObjectType)

	// ResourceLocation
	destination.ResourceLocation = genruntime.ClonePointerToString(datasourceSet.ResourceLocation)

	// ResourceName
	destination.ResourceName = genruntime.ClonePointerToString(datasourceSet.ResourceName)

	// ResourceProperties
	if datasourceSet.ResourceProperties != nil {
		var resourceProperty storage.BaseResourceProperties
		err := datasourceSet.ResourceProperties.AssignProperties_To_BaseResourceProperties(&resourceProperty)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BaseResourceProperties() to populate field ResourceProperties")
		}
		destination.ResourceProperties = &resourceProperty
	} else {
		destination.ResourceProperties = nil
	}

	// ResourceReference
	if datasourceSet.ResourceReference != nil {
		resourceReference := datasourceSet.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// ResourceType
	destination.ResourceType = genruntime.ClonePointerToString(datasourceSet.ResourceType)

	// ResourceUri
	destination.ResourceUri = genruntime.ClonePointerToString(datasourceSet.ResourceUri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DatasourceSet_STATUS populates our DatasourceSet from the provided source DatasourceSet_STATUS
func (datasourceSet *DatasourceSet) Initialize_From_DatasourceSet_STATUS(source *DatasourceSet_STATUS) error {

	// DatasourceType
	datasourceSet.DatasourceType = genruntime.ClonePointerToString(source.DatasourceType)

	// ObjectType
	datasourceSet.ObjectType = genruntime.ClonePointerToString(source.ObjectType)

	// ResourceLocation
	datasourceSet.ResourceLocation = genruntime.ClonePointerToString(source.ResourceLocation)

	// ResourceName
	datasourceSet.ResourceName = genruntime.ClonePointerToString(source.ResourceName)

	// ResourceProperties
	if source.ResourceProperties != nil {
		var resourceProperty BaseResourceProperties
		err := resourceProperty.Initialize_From_BaseResourceProperties_STATUS(source.ResourceProperties)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_BaseResourceProperties_STATUS() to populate field ResourceProperties")
		}
		datasourceSet.ResourceProperties = &resourceProperty
	} else {
		datasourceSet.ResourceProperties = nil
	}

	// ResourceType
	datasourceSet.ResourceType = genruntime.ClonePointerToString(source.ResourceType)

	// ResourceUri
	datasourceSet.ResourceUri = genruntime.ClonePointerToString(source.ResourceUri)

	// No error
	return nil
}

// DatasourceSet details of datasource to be backed up
type DatasourceSet_STATUS struct {
	// DatasourceType: DatasourceType of the resource.
	DatasourceType *string `json:"datasourceType,omitempty"`

	// ObjectType: Type of Datasource object, used to initialize the right inherited type
	ObjectType *string `json:"objectType,omitempty"`

	// ResourceID: Full ARM ID of the resource. For azure resources, this is ARM ID. For non azure resources, this will be the
	// ID created by backup service via Fabric/Vault.
	ResourceID *string `json:"resourceID,omitempty"`

	// ResourceLocation: Location of datasource.
	ResourceLocation *string `json:"resourceLocation,omitempty"`

	// ResourceName: Unique identifier of the resource in the context of parent.
	ResourceName *string `json:"resourceName,omitempty"`

	// ResourceProperties: Properties specific to data source set
	ResourceProperties *BaseResourceProperties_STATUS `json:"resourceProperties,omitempty"`

	// ResourceType: Resource Type of Datasource.
	ResourceType *string `json:"resourceType,omitempty"`

	// ResourceUri: Uri of the resource.
	ResourceUri *string `json:"resourceUri,omitempty"`
}

var _ genruntime.FromARMConverter = &DatasourceSet_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (datasourceSet *DatasourceSet_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DatasourceSet_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (datasourceSet *DatasourceSet_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DatasourceSet_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DatasourceSet_STATUS, got %T", armInput)
	}

	// Set property "DatasourceType":
	if typedInput.DatasourceType != nil {
		datasourceType := *typedInput.DatasourceType
		datasourceSet.DatasourceType = &datasourceType
	}

	// Set property "ObjectType":
	if typedInput.ObjectType != nil {
		objectType := *typedInput.ObjectType
		datasourceSet.ObjectType = &objectType
	}

	// Set property "ResourceID":
	if typedInput.ResourceID != nil {
		resourceID := *typedInput.ResourceID
		datasourceSet.ResourceID = &resourceID
	}

	// Set property "ResourceLocation":
	if typedInput.ResourceLocation != nil {
		resourceLocation := *typedInput.ResourceLocation
		datasourceSet.ResourceLocation = &resourceLocation
	}

	// Set property "ResourceName":
	if typedInput.ResourceName != nil {
		resourceName := *typedInput.ResourceName
		datasourceSet.ResourceName = &resourceName
	}

	// Set property "ResourceProperties":
	if typedInput.ResourceProperties != nil {
		var resourceProperties1 BaseResourceProperties_STATUS
		err := resourceProperties1.PopulateFromARM(owner, *typedInput.ResourceProperties)
		if err != nil {
			return err
		}
		resourceProperties := resourceProperties1
		datasourceSet.ResourceProperties = &resourceProperties
	}

	// Set property "ResourceType":
	if typedInput.ResourceType != nil {
		resourceType := *typedInput.ResourceType
		datasourceSet.ResourceType = &resourceType
	}

	// Set property "ResourceUri":
	if typedInput.ResourceUri != nil {
		resourceUri := *typedInput.ResourceUri
		datasourceSet.ResourceUri = &resourceUri
	}

	// No error
	return nil
}

// AssignProperties_From_DatasourceSet_STATUS populates our DatasourceSet_STATUS from the provided source DatasourceSet_STATUS
func (datasourceSet *DatasourceSet_STATUS) AssignProperties_From_DatasourceSet_STATUS(source *storage.DatasourceSet_STATUS) error {

	// DatasourceType
	datasourceSet.DatasourceType = genruntime.ClonePointerToString(source.DatasourceType)

	// ObjectType
	datasourceSet.ObjectType = genruntime.ClonePointerToString(source.ObjectType)

	// ResourceID
	datasourceSet.ResourceID = genruntime.ClonePointerToString(source.ResourceID)

	// ResourceLocation
	datasourceSet.ResourceLocation = genruntime.ClonePointerToString(source.ResourceLocation)

	// ResourceName
	datasourceSet.ResourceName = genruntime.ClonePointerToString(source.ResourceName)

	// ResourceProperties
	if source.ResourceProperties != nil {
		var resourceProperty BaseResourceProperties_STATUS
		err := resourceProperty.AssignProperties_From_BaseResourceProperties_STATUS(source.ResourceProperties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BaseResourceProperties_STATUS() to populate field ResourceProperties")
		}
		datasourceSet.ResourceProperties = &resourceProperty
	} else {
		datasourceSet.ResourceProperties = nil
	}

	// ResourceType
	datasourceSet.ResourceType = genruntime.ClonePointerToString(source.ResourceType)

	// ResourceUri
	datasourceSet.ResourceUri = genruntime.ClonePointerToString(source.ResourceUri)

	// No error
	return nil
}

// AssignProperties_To_DatasourceSet_STATUS populates the provided destination DatasourceSet_STATUS from our DatasourceSet_STATUS
func (datasourceSet *DatasourceSet_STATUS) AssignProperties_To_DatasourceSet_STATUS(destination *storage.DatasourceSet_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DatasourceType
	destination.DatasourceType = genruntime.ClonePointerToString(datasourceSet.DatasourceType)

	// ObjectType
	destination.ObjectType = genruntime.ClonePointerToString(datasourceSet.ObjectType)

	// ResourceID
	destination.ResourceID = genruntime.ClonePointerToString(datasourceSet.ResourceID)

	// ResourceLocation
	destination.ResourceLocation = genruntime.ClonePointerToString(datasourceSet.ResourceLocation)

	// ResourceName
	destination.ResourceName = genruntime.ClonePointerToString(datasourceSet.ResourceName)

	// ResourceProperties
	if datasourceSet.ResourceProperties != nil {
		var resourceProperty storage.BaseResourceProperties_STATUS
		err := datasourceSet.ResourceProperties.AssignProperties_To_BaseResourceProperties_STATUS(&resourceProperty)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BaseResourceProperties_STATUS() to populate field ResourceProperties")
		}
		destination.ResourceProperties = &resourceProperty
	} else {
		destination.ResourceProperties = nil
	}

	// ResourceType
	destination.ResourceType = genruntime.ClonePointerToString(datasourceSet.ResourceType)

	// ResourceUri
	destination.ResourceUri = genruntime.ClonePointerToString(datasourceSet.ResourceUri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type IdentityDetails struct {
	// UseSystemAssignedIdentity: Specifies if the BI is protected by System Identity.
	UseSystemAssignedIdentity *bool `json:"useSystemAssignedIdentity,omitempty"`

	// UserAssignedIdentityArmUrl: ARM URL for User Assigned Identity.
	UserAssignedIdentityArmUrl *string `json:"userAssignedIdentityArmUrl,omitempty"`
}

var _ genruntime.ARMTransformer = &IdentityDetails{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (details *IdentityDetails) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if details == nil {
		return nil, nil
	}
	result := &arm.IdentityDetails{}

	// Set property "UseSystemAssignedIdentity":
	if details.UseSystemAssignedIdentity != nil {
		useSystemAssignedIdentity := *details.UseSystemAssignedIdentity
		result.UseSystemAssignedIdentity = &useSystemAssignedIdentity
	}

	// Set property "UserAssignedIdentityArmUrl":
	if details.UserAssignedIdentityArmUrl != nil {
		userAssignedIdentityArmUrl := *details.UserAssignedIdentityArmUrl
		result.UserAssignedIdentityArmUrl = &userAssignedIdentityArmUrl
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (details *IdentityDetails) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IdentityDetails{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (details *IdentityDetails) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IdentityDetails)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IdentityDetails, got %T", armInput)
	}

	// Set property "UseSystemAssignedIdentity":
	if typedInput.UseSystemAssignedIdentity != nil {
		useSystemAssignedIdentity := *typedInput.UseSystemAssignedIdentity
		details.UseSystemAssignedIdentity = &useSystemAssignedIdentity
	}

	// Set property "UserAssignedIdentityArmUrl":
	if typedInput.UserAssignedIdentityArmUrl != nil {
		userAssignedIdentityArmUrl := *typedInput.UserAssignedIdentityArmUrl
		details.UserAssignedIdentityArmUrl = &userAssignedIdentityArmUrl
	}

	// No error
	return nil
}

// AssignProperties_From_IdentityDetails populates our IdentityDetails from the provided source IdentityDetails
func (details *IdentityDetails) AssignProperties_From_IdentityDetails(source *storage.IdentityDetails) error {

	// UseSystemAssignedIdentity
	if source.UseSystemAssignedIdentity != nil {
		useSystemAssignedIdentity := *source.UseSystemAssignedIdentity
		details.UseSystemAssignedIdentity = &useSystemAssignedIdentity
	} else {
		details.UseSystemAssignedIdentity = nil
	}

	// UserAssignedIdentityArmUrl
	details.UserAssignedIdentityArmUrl = genruntime.ClonePointerToString(source.UserAssignedIdentityArmUrl)

	// No error
	return nil
}

// AssignProperties_To_IdentityDetails populates the provided destination IdentityDetails from our IdentityDetails
func (details *IdentityDetails) AssignProperties_To_IdentityDetails(destination *storage.IdentityDetails) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// UseSystemAssignedIdentity
	if details.UseSystemAssignedIdentity != nil {
		useSystemAssignedIdentity := *details.UseSystemAssignedIdentity
		destination.UseSystemAssignedIdentity = &useSystemAssignedIdentity
	} else {
		destination.UseSystemAssignedIdentity = nil
	}

	// UserAssignedIdentityArmUrl
	destination.UserAssignedIdentityArmUrl = genruntime.ClonePointerToString(details.UserAssignedIdentityArmUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_IdentityDetails_STATUS populates our IdentityDetails from the provided source IdentityDetails_STATUS
func (details *IdentityDetails) Initialize_From_IdentityDetails_STATUS(source *IdentityDetails_STATUS) error {

	// UseSystemAssignedIdentity
	if source.UseSystemAssignedIdentity != nil {
		useSystemAssignedIdentity := *source.UseSystemAssignedIdentity
		details.UseSystemAssignedIdentity = &useSystemAssignedIdentity
	} else {
		details.UseSystemAssignedIdentity = nil
	}

	// UserAssignedIdentityArmUrl
	details.UserAssignedIdentityArmUrl = genruntime.ClonePointerToString(source.UserAssignedIdentityArmUrl)

	// No error
	return nil
}

type IdentityDetails_STATUS struct {
	// UseSystemAssignedIdentity: Specifies if the BI is protected by System Identity.
	UseSystemAssignedIdentity *bool `json:"useSystemAssignedIdentity,omitempty"`

	// UserAssignedIdentityArmUrl: ARM URL for User Assigned Identity.
	UserAssignedIdentityArmUrl *string `json:"userAssignedIdentityArmUrl,omitempty"`
}

var _ genruntime.FromARMConverter = &IdentityDetails_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (details *IdentityDetails_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IdentityDetails_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (details *IdentityDetails_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IdentityDetails_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IdentityDetails_STATUS, got %T", armInput)
	}

	// Set property "UseSystemAssignedIdentity":
	if typedInput.UseSystemAssignedIdentity != nil {
		useSystemAssignedIdentity := *typedInput.UseSystemAssignedIdentity
		details.UseSystemAssignedIdentity = &useSystemAssignedIdentity
	}

	// Set property "UserAssignedIdentityArmUrl":
	if typedInput.UserAssignedIdentityArmUrl != nil {
		userAssignedIdentityArmUrl := *typedInput.UserAssignedIdentityArmUrl
		details.UserAssignedIdentityArmUrl = &userAssignedIdentityArmUrl
	}

	// No error
	return nil
}

// AssignProperties_From_IdentityDetails_STATUS populates our IdentityDetails_STATUS from the provided source IdentityDetails_STATUS
func (details *IdentityDetails_STATUS) AssignProperties_From_IdentityDetails_STATUS(source *storage.IdentityDetails_STATUS) error {

	// UseSystemAssignedIdentity
	if source.UseSystemAssignedIdentity != nil {
		useSystemAssignedIdentity := *source.UseSystemAssignedIdentity
		details.UseSystemAssignedIdentity = &useSystemAssignedIdentity
	} else {
		details.UseSystemAssignedIdentity = nil
	}

	// UserAssignedIdentityArmUrl
	details.UserAssignedIdentityArmUrl = genruntime.ClonePointerToString(source.UserAssignedIdentityArmUrl)

	// No error
	return nil
}

// AssignProperties_To_IdentityDetails_STATUS populates the provided destination IdentityDetails_STATUS from our IdentityDetails_STATUS
func (details *IdentityDetails_STATUS) AssignProperties_To_IdentityDetails_STATUS(destination *storage.IdentityDetails_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// UseSystemAssignedIdentity
	if details.UseSystemAssignedIdentity != nil {
		useSystemAssignedIdentity := *details.UseSystemAssignedIdentity
		destination.UseSystemAssignedIdentity = &useSystemAssignedIdentity
	} else {
		destination.UseSystemAssignedIdentity = nil
	}

	// UserAssignedIdentityArmUrl
	destination.UserAssignedIdentityArmUrl = genruntime.ClonePointerToString(details.UserAssignedIdentityArmUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Policy Info in backupInstance
type PolicyInfo struct {
	// PolicyParameters: Policy parameters for the backup instance
	PolicyParameters *PolicyParameters `json:"policyParameters,omitempty"`

	// +kubebuilder:validation:Required
	PolicyReference *genruntime.ResourceReference `armReference:"PolicyId" json:"policyReference,omitempty"`
}

var _ genruntime.ARMTransformer = &PolicyInfo{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (info *PolicyInfo) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if info == nil {
		return nil, nil
	}
	result := &arm.PolicyInfo{}

	// Set property "PolicyId":
	if info.PolicyReference != nil {
		policyReferenceARMID, err := resolved.ResolvedReferences.Lookup(*info.PolicyReference)
		if err != nil {
			return nil, err
		}
		policyReference := policyReferenceARMID
		result.PolicyId = &policyReference
	}

	// Set property "PolicyParameters":
	if info.PolicyParameters != nil {
		policyParameters_ARM, err := (*info.PolicyParameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		policyParameters := *policyParameters_ARM.(*arm.PolicyParameters)
		result.PolicyParameters = &policyParameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (info *PolicyInfo) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PolicyInfo{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (info *PolicyInfo) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PolicyInfo)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PolicyInfo, got %T", armInput)
	}

	// Set property "PolicyParameters":
	if typedInput.PolicyParameters != nil {
		var policyParameters1 PolicyParameters
		err := policyParameters1.PopulateFromARM(owner, *typedInput.PolicyParameters)
		if err != nil {
			return err
		}
		policyParameters := policyParameters1
		info.PolicyParameters = &policyParameters
	}

	// no assignment for property "PolicyReference"

	// No error
	return nil
}

// AssignProperties_From_PolicyInfo populates our PolicyInfo from the provided source PolicyInfo
func (info *PolicyInfo) AssignProperties_From_PolicyInfo(source *storage.PolicyInfo) error {

	// PolicyParameters
	if source.PolicyParameters != nil {
		var policyParameter PolicyParameters
		err := policyParameter.AssignProperties_From_PolicyParameters(source.PolicyParameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PolicyParameters() to populate field PolicyParameters")
		}
		info.PolicyParameters = &policyParameter
	} else {
		info.PolicyParameters = nil
	}

	// PolicyReference
	if source.PolicyReference != nil {
		policyReference := source.PolicyReference.Copy()
		info.PolicyReference = &policyReference
	} else {
		info.PolicyReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PolicyInfo populates the provided destination PolicyInfo from our PolicyInfo
func (info *PolicyInfo) AssignProperties_To_PolicyInfo(destination *storage.PolicyInfo) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PolicyParameters
	if info.PolicyParameters != nil {
		var policyParameter storage.PolicyParameters
		err := info.PolicyParameters.AssignProperties_To_PolicyParameters(&policyParameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PolicyParameters() to populate field PolicyParameters")
		}
		destination.PolicyParameters = &policyParameter
	} else {
		destination.PolicyParameters = nil
	}

	// PolicyReference
	if info.PolicyReference != nil {
		policyReference := info.PolicyReference.Copy()
		destination.PolicyReference = &policyReference
	} else {
		destination.PolicyReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_PolicyInfo_STATUS populates our PolicyInfo from the provided source PolicyInfo_STATUS
func (info *PolicyInfo) Initialize_From_PolicyInfo_STATUS(source *PolicyInfo_STATUS) error {

	// PolicyParameters
	if source.PolicyParameters != nil {
		var policyParameter PolicyParameters
		err := policyParameter.Initialize_From_PolicyParameters_STATUS(source.PolicyParameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_PolicyParameters_STATUS() to populate field PolicyParameters")
		}
		info.PolicyParameters = &policyParameter
	} else {
		info.PolicyParameters = nil
	}

	// PolicyReference
	if source.PolicyId != nil {
		policyReference := genruntime.CreateResourceReferenceFromARMID(*source.PolicyId)
		info.PolicyReference = &policyReference
	} else {
		info.PolicyReference = nil
	}

	// No error
	return nil
}

// Policy Info in backupInstance
type PolicyInfo_STATUS struct {
	PolicyId *string `json:"policyId,omitempty"`

	// PolicyParameters: Policy parameters for the backup instance
	PolicyParameters *PolicyParameters_STATUS `json:"policyParameters,omitempty"`
	PolicyVersion    *string                  `json:"policyVersion,omitempty"`
}

var _ genruntime.FromARMConverter = &PolicyInfo_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (info *PolicyInfo_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PolicyInfo_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (info *PolicyInfo_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PolicyInfo_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PolicyInfo_STATUS, got %T", armInput)
	}

	// Set property "PolicyId":
	if typedInput.PolicyId != nil {
		policyId := *typedInput.PolicyId
		info.PolicyId = &policyId
	}

	// Set property "PolicyParameters":
	if typedInput.PolicyParameters != nil {
		var policyParameters1 PolicyParameters_STATUS
		err := policyParameters1.PopulateFromARM(owner, *typedInput.PolicyParameters)
		if err != nil {
			return err
		}
		policyParameters := policyParameters1
		info.PolicyParameters = &policyParameters
	}

	// Set property "PolicyVersion":
	if typedInput.PolicyVersion != nil {
		policyVersion := *typedInput.PolicyVersion
		info.PolicyVersion = &policyVersion
	}

	// No error
	return nil
}

// AssignProperties_From_PolicyInfo_STATUS populates our PolicyInfo_STATUS from the provided source PolicyInfo_STATUS
func (info *PolicyInfo_STATUS) AssignProperties_From_PolicyInfo_STATUS(source *storage.PolicyInfo_STATUS) error {

	// PolicyId
	info.PolicyId = genruntime.ClonePointerToString(source.PolicyId)

	// PolicyParameters
	if source.PolicyParameters != nil {
		var policyParameter PolicyParameters_STATUS
		err := policyParameter.AssignProperties_From_PolicyParameters_STATUS(source.PolicyParameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PolicyParameters_STATUS() to populate field PolicyParameters")
		}
		info.PolicyParameters = &policyParameter
	} else {
		info.PolicyParameters = nil
	}

	// PolicyVersion
	info.PolicyVersion = genruntime.ClonePointerToString(source.PolicyVersion)

	// No error
	return nil
}

// AssignProperties_To_PolicyInfo_STATUS populates the provided destination PolicyInfo_STATUS from our PolicyInfo_STATUS
func (info *PolicyInfo_STATUS) AssignProperties_To_PolicyInfo_STATUS(destination *storage.PolicyInfo_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PolicyId
	destination.PolicyId = genruntime.ClonePointerToString(info.PolicyId)

	// PolicyParameters
	if info.PolicyParameters != nil {
		var policyParameter storage.PolicyParameters_STATUS
		err := info.PolicyParameters.AssignProperties_To_PolicyParameters_STATUS(&policyParameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PolicyParameters_STATUS() to populate field PolicyParameters")
		}
		destination.PolicyParameters = &policyParameter
	} else {
		destination.PolicyParameters = nil
	}

	// PolicyVersion
	destination.PolicyVersion = genruntime.ClonePointerToString(info.PolicyVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Protection status details
type ProtectionStatusDetails_STATUS struct {
	// ErrorDetails: Specifies the protection status error of the resource
	ErrorDetails *UserFacingError_STATUS `json:"errorDetails,omitempty"`

	// Status: Specifies the protection status of the resource
	Status *ProtectionStatusDetails_Status_STATUS `json:"status,omitempty"`
}

var _ genruntime.FromARMConverter = &ProtectionStatusDetails_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (details *ProtectionStatusDetails_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ProtectionStatusDetails_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (details *ProtectionStatusDetails_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ProtectionStatusDetails_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ProtectionStatusDetails_STATUS, got %T", armInput)
	}

	// Set property "ErrorDetails":
	if typedInput.ErrorDetails != nil {
		var errorDetails1 UserFacingError_STATUS
		err := errorDetails1.PopulateFromARM(owner, *typedInput.ErrorDetails)
		if err != nil {
			return err
		}
		errorDetails := errorDetails1
		details.ErrorDetails = &errorDetails
	}

	// Set property "Status":
	if typedInput.Status != nil {
		var temp string
		temp = string(*typedInput.Status)
		status := ProtectionStatusDetails_Status_STATUS(temp)
		details.Status = &status
	}

	// No error
	return nil
}

// AssignProperties_From_ProtectionStatusDetails_STATUS populates our ProtectionStatusDetails_STATUS from the provided source ProtectionStatusDetails_STATUS
func (details *ProtectionStatusDetails_STATUS) AssignProperties_From_ProtectionStatusDetails_STATUS(source *storage.ProtectionStatusDetails_STATUS) error {

	// ErrorDetails
	if source.ErrorDetails != nil {
		var errorDetail UserFacingError_STATUS
		err := errorDetail.AssignProperties_From_UserFacingError_STATUS(source.ErrorDetails)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UserFacingError_STATUS() to populate field ErrorDetails")
		}
		details.ErrorDetails = &errorDetail
	} else {
		details.ErrorDetails = nil
	}

	// Status
	if source.Status != nil {
		status := *source.Status
		statusTemp := genruntime.ToEnum(status, protectionStatusDetails_Status_STATUS_Values)
		details.Status = &statusTemp
	} else {
		details.Status = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ProtectionStatusDetails_STATUS populates the provided destination ProtectionStatusDetails_STATUS from our ProtectionStatusDetails_STATUS
func (details *ProtectionStatusDetails_STATUS) AssignProperties_To_ProtectionStatusDetails_STATUS(destination *storage.ProtectionStatusDetails_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ErrorDetails
	if details.ErrorDetails != nil {
		var errorDetail storage.UserFacingError_STATUS
		err := details.ErrorDetails.AssignProperties_To_UserFacingError_STATUS(&errorDetail)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UserFacingError_STATUS() to populate field ErrorDetails")
		}
		destination.ErrorDetails = &errorDetail
	} else {
		destination.ErrorDetails = nil
	}

	// Status
	if details.Status != nil {
		status := string(*details.Status)
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Error object used by layers that have access to localized content, and propagate that to user
type UserFacingError_STATUS struct {
	// Code: Unique code for this error
	Code *string `json:"code,omitempty"`

	// Details: Additional related Errors
	Details []UserFacingError_STATUS_Unrolled `json:"details,omitempty"`

	// InnerError: Inner Error
	InnerError *InnerError_STATUS `json:"innerError,omitempty"`

	// IsRetryable: Whether the operation will be retryable or not
	IsRetryable *bool `json:"isRetryable,omitempty"`

	// IsUserError: Whether the operation is due to a user error or service error
	IsUserError *bool   `json:"isUserError,omitempty"`
	Message     *string `json:"message,omitempty"`

	// Properties: Any key value pairs that can be injected inside error object
	Properties map[string]string `json:"properties,omitempty"`

	// RecommendedAction: RecommendedAction  localized.
	RecommendedAction []string `json:"recommendedAction,omitempty"`

	// Target: Target of the error.
	Target *string `json:"target,omitempty"`
}

var _ genruntime.FromARMConverter = &UserFacingError_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (error *UserFacingError_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UserFacingError_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (error *UserFacingError_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UserFacingError_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UserFacingError_STATUS, got %T", armInput)
	}

	// Set property "Code":
	if typedInput.Code != nil {
		code := *typedInput.Code
		error.Code = &code
	}

	// Set property "Details":
	for _, item := range typedInput.Details {
		var item1 UserFacingError_STATUS_Unrolled
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		error.Details = append(error.Details, item1)
	}

	// Set property "InnerError":
	if typedInput.InnerError != nil {
		var innerError1 InnerError_STATUS
		err := innerError1.PopulateFromARM(owner, *typedInput.InnerError)
		if err != nil {
			return err
		}
		innerError := innerError1
		error.InnerError = &innerError
	}

	// Set property "IsRetryable":
	if typedInput.IsRetryable != nil {
		isRetryable := *typedInput.IsRetryable
		error.IsRetryable = &isRetryable
	}

	// Set property "IsUserError":
	if typedInput.IsUserError != nil {
		isUserError := *typedInput.IsUserError
		error.IsUserError = &isUserError
	}

	// Set property "Message":
	if typedInput.Message != nil {
		message := *typedInput.Message
		error.Message = &message
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		error.Properties = make(map[string]string, len(typedInput.Properties))
		for key, value := range typedInput.Properties {
			error.Properties[key] = value
		}
	}

	// Set property "RecommendedAction":
	for _, item := range typedInput.RecommendedAction {
		error.RecommendedAction = append(error.RecommendedAction, item)
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		error.Target = &target
	}

	// No error
	return nil
}

// AssignProperties_From_UserFacingError_STATUS populates our UserFacingError_STATUS from the provided source UserFacingError_STATUS
func (error *UserFacingError_STATUS) AssignProperties_From_UserFacingError_STATUS(source *storage.UserFacingError_STATUS) error {

	// Code
	error.Code = genruntime.ClonePointerToString(source.Code)

	// Details
	if source.Details != nil {
		detailList := make([]UserFacingError_STATUS_Unrolled, len(source.Details))
		for detailIndex, detailItem := range source.Details {
			// Shadow the loop variable to avoid aliasing
			detailItem := detailItem
			var detail UserFacingError_STATUS_Unrolled
			err := detail.AssignProperties_From_UserFacingError_STATUS_Unrolled(&detailItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_UserFacingError_STATUS_Unrolled() to populate field Details")
			}
			detailList[detailIndex] = detail
		}
		error.Details = detailList
	} else {
		error.Details = nil
	}

	// InnerError
	if source.InnerError != nil {
		var innerError InnerError_STATUS
		err := innerError.AssignProperties_From_InnerError_STATUS(source.InnerError)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_InnerError_STATUS() to populate field InnerError")
		}
		error.InnerError = &innerError
	} else {
		error.InnerError = nil
	}

	// IsRetryable
	if source.IsRetryable != nil {
		isRetryable := *source.IsRetryable
		error.IsRetryable = &isRetryable
	} else {
		error.IsRetryable = nil
	}

	// IsUserError
	if source.IsUserError != nil {
		isUserError := *source.IsUserError
		error.IsUserError = &isUserError
	} else {
		error.IsUserError = nil
	}

	// Message
	error.Message = genruntime.ClonePointerToString(source.Message)

	// Properties
	error.Properties = genruntime.CloneMapOfStringToString(source.Properties)

	// RecommendedAction
	error.RecommendedAction = genruntime.CloneSliceOfString(source.RecommendedAction)

	// Target
	error.Target = genruntime.ClonePointerToString(source.Target)

	// No error
	return nil
}

// AssignProperties_To_UserFacingError_STATUS populates the provided destination UserFacingError_STATUS from our UserFacingError_STATUS
func (error *UserFacingError_STATUS) AssignProperties_To_UserFacingError_STATUS(destination *storage.UserFacingError_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Code
	destination.Code = genruntime.ClonePointerToString(error.Code)

	// Details
	if error.Details != nil {
		detailList := make([]storage.UserFacingError_STATUS_Unrolled, len(error.Details))
		for detailIndex, detailItem := range error.Details {
			// Shadow the loop variable to avoid aliasing
			detailItem := detailItem
			var detail storage.UserFacingError_STATUS_Unrolled
			err := detailItem.AssignProperties_To_UserFacingError_STATUS_Unrolled(&detail)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_UserFacingError_STATUS_Unrolled() to populate field Details")
			}
			detailList[detailIndex] = detail
		}
		destination.Details = detailList
	} else {
		destination.Details = nil
	}

	// InnerError
	if error.InnerError != nil {
		var innerError storage.InnerError_STATUS
		err := error.InnerError.AssignProperties_To_InnerError_STATUS(&innerError)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_InnerError_STATUS() to populate field InnerError")
		}
		destination.InnerError = &innerError
	} else {
		destination.InnerError = nil
	}

	// IsRetryable
	if error.IsRetryable != nil {
		isRetryable := *error.IsRetryable
		destination.IsRetryable = &isRetryable
	} else {
		destination.IsRetryable = nil
	}

	// IsUserError
	if error.IsUserError != nil {
		isUserError := *error.IsUserError
		destination.IsUserError = &isUserError
	} else {
		destination.IsUserError = nil
	}

	// Message
	destination.Message = genruntime.ClonePointerToString(error.Message)

	// Properties
	destination.Properties = genruntime.CloneMapOfStringToString(error.Properties)

	// RecommendedAction
	destination.RecommendedAction = genruntime.CloneSliceOfString(error.RecommendedAction)

	// Target
	destination.Target = genruntime.ClonePointerToString(error.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type BaseResourceProperties struct {
	// DefaultResourceProperties: Mutually exclusive with all other properties
	DefaultResourceProperties *DefaultResourceProperties `json:"defaultResourceProperties,omitempty"`
}

var _ genruntime.ARMTransformer = &BaseResourceProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *BaseResourceProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.BaseResourceProperties{}

	// Set property "DefaultResourceProperties":
	if properties.DefaultResourceProperties != nil {
		defaultResourceProperties_ARM, err := (*properties.DefaultResourceProperties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		defaultResourceProperties := *defaultResourceProperties_ARM.(*arm.DefaultResourceProperties)
		result.DefaultResourceProperties = &defaultResourceProperties
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *BaseResourceProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BaseResourceProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *BaseResourceProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BaseResourceProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BaseResourceProperties, got %T", armInput)
	}

	// Set property "DefaultResourceProperties":
	if typedInput.DefaultResourceProperties != nil {
		var defaultResourceProperties1 DefaultResourceProperties
		err := defaultResourceProperties1.PopulateFromARM(owner, *typedInput.DefaultResourceProperties)
		if err != nil {
			return err
		}
		defaultResourceProperties := defaultResourceProperties1
		properties.DefaultResourceProperties = &defaultResourceProperties
	}

	// No error
	return nil
}

// AssignProperties_From_BaseResourceProperties populates our BaseResourceProperties from the provided source BaseResourceProperties
func (properties *BaseResourceProperties) AssignProperties_From_BaseResourceProperties(source *storage.BaseResourceProperties) error {

	// DefaultResourceProperties
	if source.DefaultResourceProperties != nil {
		var defaultResourceProperty DefaultResourceProperties
		err := defaultResourceProperty.AssignProperties_From_DefaultResourceProperties(source.DefaultResourceProperties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DefaultResourceProperties() to populate field DefaultResourceProperties")
		}
		properties.DefaultResourceProperties = &defaultResourceProperty
	} else {
		properties.DefaultResourceProperties = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BaseResourceProperties populates the provided destination BaseResourceProperties from our BaseResourceProperties
func (properties *BaseResourceProperties) AssignProperties_To_BaseResourceProperties(destination *storage.BaseResourceProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DefaultResourceProperties
	if properties.DefaultResourceProperties != nil {
		var defaultResourceProperty storage.DefaultResourceProperties
		err := properties.DefaultResourceProperties.AssignProperties_To_DefaultResourceProperties(&defaultResourceProperty)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DefaultResourceProperties() to populate field DefaultResourceProperties")
		}
		destination.DefaultResourceProperties = &defaultResourceProperty
	} else {
		destination.DefaultResourceProperties = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_BaseResourceProperties_STATUS populates our BaseResourceProperties from the provided source BaseResourceProperties_STATUS
func (properties *BaseResourceProperties) Initialize_From_BaseResourceProperties_STATUS(source *BaseResourceProperties_STATUS) error {

	// DefaultResourceProperties
	if source.DefaultResourceProperties != nil {
		var defaultResourceProperty DefaultResourceProperties
		err := defaultResourceProperty.Initialize_From_DefaultResourceProperties_STATUS(source.DefaultResourceProperties)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DefaultResourceProperties_STATUS() to populate field DefaultResourceProperties")
		}
		properties.DefaultResourceProperties = &defaultResourceProperty
	} else {
		properties.DefaultResourceProperties = nil
	}

	// No error
	return nil
}

type BaseResourceProperties_STATUS struct {
	// DefaultResourceProperties: Mutually exclusive with all other properties
	DefaultResourceProperties *DefaultResourceProperties_STATUS `json:"defaultResourceProperties,omitempty"`
}

var _ genruntime.FromARMConverter = &BaseResourceProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *BaseResourceProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BaseResourceProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *BaseResourceProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BaseResourceProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BaseResourceProperties_STATUS, got %T", armInput)
	}

	// Set property "DefaultResourceProperties":
	if typedInput.DefaultResourceProperties != nil {
		var defaultResourceProperties1 DefaultResourceProperties_STATUS
		err := defaultResourceProperties1.PopulateFromARM(owner, *typedInput.DefaultResourceProperties)
		if err != nil {
			return err
		}
		defaultResourceProperties := defaultResourceProperties1
		properties.DefaultResourceProperties = &defaultResourceProperties
	}

	// No error
	return nil
}

// AssignProperties_From_BaseResourceProperties_STATUS populates our BaseResourceProperties_STATUS from the provided source BaseResourceProperties_STATUS
func (properties *BaseResourceProperties_STATUS) AssignProperties_From_BaseResourceProperties_STATUS(source *storage.BaseResourceProperties_STATUS) error {

	// DefaultResourceProperties
	if source.DefaultResourceProperties != nil {
		var defaultResourceProperty DefaultResourceProperties_STATUS
		err := defaultResourceProperty.AssignProperties_From_DefaultResourceProperties_STATUS(source.DefaultResourceProperties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DefaultResourceProperties_STATUS() to populate field DefaultResourceProperties")
		}
		properties.DefaultResourceProperties = &defaultResourceProperty
	} else {
		properties.DefaultResourceProperties = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BaseResourceProperties_STATUS populates the provided destination BaseResourceProperties_STATUS from our BaseResourceProperties_STATUS
func (properties *BaseResourceProperties_STATUS) AssignProperties_To_BaseResourceProperties_STATUS(destination *storage.BaseResourceProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DefaultResourceProperties
	if properties.DefaultResourceProperties != nil {
		var defaultResourceProperty storage.DefaultResourceProperties_STATUS
		err := properties.DefaultResourceProperties.AssignProperties_To_DefaultResourceProperties_STATUS(&defaultResourceProperty)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DefaultResourceProperties_STATUS() to populate field DefaultResourceProperties")
		}
		destination.DefaultResourceProperties = &defaultResourceProperty
	} else {
		destination.DefaultResourceProperties = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Inner Error
type InnerError_STATUS struct {
	// AdditionalInfo: Any Key value pairs that can be provided to the client for additional  verbose information.
	AdditionalInfo map[string]string `json:"additionalInfo,omitempty"`

	// Code: Unique code for this error
	Code *string `json:"code,omitempty"`

	// EmbeddedInnerError: Child Inner Error, to allow Nesting.
	EmbeddedInnerError *InnerError_STATUS_Unrolled `json:"embeddedInnerError,omitempty"`
}

var _ genruntime.FromARMConverter = &InnerError_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (error *InnerError_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.InnerError_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (error *InnerError_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.InnerError_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.InnerError_STATUS, got %T", armInput)
	}

	// Set property "AdditionalInfo":
	if typedInput.AdditionalInfo != nil {
		error.AdditionalInfo = make(map[string]string, len(typedInput.AdditionalInfo))
		for key, value := range typedInput.AdditionalInfo {
			error.AdditionalInfo[key] = value
		}
	}

	// Set property "Code":
	if typedInput.Code != nil {
		code := *typedInput.Code
		error.Code = &code
	}

	// Set property "EmbeddedInnerError":
	if typedInput.EmbeddedInnerError != nil {
		var embeddedInnerError1 InnerError_STATUS_Unrolled
		err := embeddedInnerError1.PopulateFromARM(owner, *typedInput.EmbeddedInnerError)
		if err != nil {
			return err
		}
		embeddedInnerError := embeddedInnerError1
		error.EmbeddedInnerError = &embeddedInnerError
	}

	// No error
	return nil
}

// AssignProperties_From_InnerError_STATUS populates our InnerError_STATUS from the provided source InnerError_STATUS
func (error *InnerError_STATUS) AssignProperties_From_InnerError_STATUS(source *storage.InnerError_STATUS) error {

	// AdditionalInfo
	error.AdditionalInfo = genruntime.CloneMapOfStringToString(source.AdditionalInfo)

	// Code
	error.Code = genruntime.ClonePointerToString(source.Code)

	// EmbeddedInnerError
	if source.EmbeddedInnerError != nil {
		var embeddedInnerError InnerError_STATUS_Unrolled
		err := embeddedInnerError.AssignProperties_From_InnerError_STATUS_Unrolled(source.EmbeddedInnerError)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_InnerError_STATUS_Unrolled() to populate field EmbeddedInnerError")
		}
		error.EmbeddedInnerError = &embeddedInnerError
	} else {
		error.EmbeddedInnerError = nil
	}

	// No error
	return nil
}

// AssignProperties_To_InnerError_STATUS populates the provided destination InnerError_STATUS from our InnerError_STATUS
func (error *InnerError_STATUS) AssignProperties_To_InnerError_STATUS(destination *storage.InnerError_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalInfo
	destination.AdditionalInfo = genruntime.CloneMapOfStringToString(error.AdditionalInfo)

	// Code
	destination.Code = genruntime.ClonePointerToString(error.Code)

	// EmbeddedInnerError
	if error.EmbeddedInnerError != nil {
		var embeddedInnerError storage.InnerError_STATUS_Unrolled
		err := error.EmbeddedInnerError.AssignProperties_To_InnerError_STATUS_Unrolled(&embeddedInnerError)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_InnerError_STATUS_Unrolled() to populate field EmbeddedInnerError")
		}
		destination.EmbeddedInnerError = &embeddedInnerError
	} else {
		destination.EmbeddedInnerError = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Parameters in Policy
type PolicyParameters struct {
	// BackupDatasourceParametersList: Gets or sets the Backup Data Source Parameters
	BackupDatasourceParametersList []BackupDatasourceParameters `json:"backupDatasourceParametersList,omitempty"`

	// DataStoreParametersList: Gets or sets the DataStore Parameters
	DataStoreParametersList []DataStoreParameters `json:"dataStoreParametersList,omitempty"`
}

var _ genruntime.ARMTransformer = &PolicyParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *PolicyParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.PolicyParameters{}

	// Set property "BackupDatasourceParametersList":
	for _, item := range parameters.BackupDatasourceParametersList {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.BackupDatasourceParametersList = append(result.BackupDatasourceParametersList, *item_ARM.(*arm.BackupDatasourceParameters))
	}

	// Set property "DataStoreParametersList":
	for _, item := range parameters.DataStoreParametersList {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.DataStoreParametersList = append(result.DataStoreParametersList, *item_ARM.(*arm.DataStoreParameters))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *PolicyParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PolicyParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *PolicyParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PolicyParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PolicyParameters, got %T", armInput)
	}

	// Set property "BackupDatasourceParametersList":
	for _, item := range typedInput.BackupDatasourceParametersList {
		var item1 BackupDatasourceParameters
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		parameters.BackupDatasourceParametersList = append(parameters.BackupDatasourceParametersList, item1)
	}

	// Set property "DataStoreParametersList":
	for _, item := range typedInput.DataStoreParametersList {
		var item1 DataStoreParameters
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		parameters.DataStoreParametersList = append(parameters.DataStoreParametersList, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_PolicyParameters populates our PolicyParameters from the provided source PolicyParameters
func (parameters *PolicyParameters) AssignProperties_From_PolicyParameters(source *storage.PolicyParameters) error {

	// BackupDatasourceParametersList
	if source.BackupDatasourceParametersList != nil {
		backupDatasourceParametersList := make([]BackupDatasourceParameters, len(source.BackupDatasourceParametersList))
		for backupDatasourceParametersListIndex, backupDatasourceParametersListItem := range source.BackupDatasourceParametersList {
			// Shadow the loop variable to avoid aliasing
			backupDatasourceParametersListItem := backupDatasourceParametersListItem
			var backupDatasourceParametersListLocal BackupDatasourceParameters
			err := backupDatasourceParametersListLocal.AssignProperties_From_BackupDatasourceParameters(&backupDatasourceParametersListItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_BackupDatasourceParameters() to populate field BackupDatasourceParametersList")
			}
			backupDatasourceParametersList[backupDatasourceParametersListIndex] = backupDatasourceParametersListLocal
		}
		parameters.BackupDatasourceParametersList = backupDatasourceParametersList
	} else {
		parameters.BackupDatasourceParametersList = nil
	}

	// DataStoreParametersList
	if source.DataStoreParametersList != nil {
		dataStoreParametersList := make([]DataStoreParameters, len(source.DataStoreParametersList))
		for dataStoreParametersListIndex, dataStoreParametersListItem := range source.DataStoreParametersList {
			// Shadow the loop variable to avoid aliasing
			dataStoreParametersListItem := dataStoreParametersListItem
			var dataStoreParametersListLocal DataStoreParameters
			err := dataStoreParametersListLocal.AssignProperties_From_DataStoreParameters(&dataStoreParametersListItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DataStoreParameters() to populate field DataStoreParametersList")
			}
			dataStoreParametersList[dataStoreParametersListIndex] = dataStoreParametersListLocal
		}
		parameters.DataStoreParametersList = dataStoreParametersList
	} else {
		parameters.DataStoreParametersList = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PolicyParameters populates the provided destination PolicyParameters from our PolicyParameters
func (parameters *PolicyParameters) AssignProperties_To_PolicyParameters(destination *storage.PolicyParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackupDatasourceParametersList
	if parameters.BackupDatasourceParametersList != nil {
		backupDatasourceParametersList := make([]storage.BackupDatasourceParameters, len(parameters.BackupDatasourceParametersList))
		for backupDatasourceParametersListIndex, backupDatasourceParametersListItem := range parameters.BackupDatasourceParametersList {
			// Shadow the loop variable to avoid aliasing
			backupDatasourceParametersListItem := backupDatasourceParametersListItem
			var backupDatasourceParametersListLocal storage.BackupDatasourceParameters
			err := backupDatasourceParametersListItem.AssignProperties_To_BackupDatasourceParameters(&backupDatasourceParametersListLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_BackupDatasourceParameters() to populate field BackupDatasourceParametersList")
			}
			backupDatasourceParametersList[backupDatasourceParametersListIndex] = backupDatasourceParametersListLocal
		}
		destination.BackupDatasourceParametersList = backupDatasourceParametersList
	} else {
		destination.BackupDatasourceParametersList = nil
	}

	// DataStoreParametersList
	if parameters.DataStoreParametersList != nil {
		dataStoreParametersList := make([]storage.DataStoreParameters, len(parameters.DataStoreParametersList))
		for dataStoreParametersListIndex, dataStoreParametersListItem := range parameters.DataStoreParametersList {
			// Shadow the loop variable to avoid aliasing
			dataStoreParametersListItem := dataStoreParametersListItem
			var dataStoreParametersListLocal storage.DataStoreParameters
			err := dataStoreParametersListItem.AssignProperties_To_DataStoreParameters(&dataStoreParametersListLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DataStoreParameters() to populate field DataStoreParametersList")
			}
			dataStoreParametersList[dataStoreParametersListIndex] = dataStoreParametersListLocal
		}
		destination.DataStoreParametersList = dataStoreParametersList
	} else {
		destination.DataStoreParametersList = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_PolicyParameters_STATUS populates our PolicyParameters from the provided source PolicyParameters_STATUS
func (parameters *PolicyParameters) Initialize_From_PolicyParameters_STATUS(source *PolicyParameters_STATUS) error {

	// BackupDatasourceParametersList
	if source.BackupDatasourceParametersList != nil {
		backupDatasourceParametersList := make([]BackupDatasourceParameters, len(source.BackupDatasourceParametersList))
		for backupDatasourceParametersListIndex, backupDatasourceParametersListItem := range source.BackupDatasourceParametersList {
			// Shadow the loop variable to avoid aliasing
			backupDatasourceParametersListItem := backupDatasourceParametersListItem
			var backupDatasourceParametersListLocal BackupDatasourceParameters
			err := backupDatasourceParametersListLocal.Initialize_From_BackupDatasourceParameters_STATUS(&backupDatasourceParametersListItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_BackupDatasourceParameters_STATUS() to populate field BackupDatasourceParametersList")
			}
			backupDatasourceParametersList[backupDatasourceParametersListIndex] = backupDatasourceParametersListLocal
		}
		parameters.BackupDatasourceParametersList = backupDatasourceParametersList
	} else {
		parameters.BackupDatasourceParametersList = nil
	}

	// DataStoreParametersList
	if source.DataStoreParametersList != nil {
		dataStoreParametersList := make([]DataStoreParameters, len(source.DataStoreParametersList))
		for dataStoreParametersListIndex, dataStoreParametersListItem := range source.DataStoreParametersList {
			// Shadow the loop variable to avoid aliasing
			dataStoreParametersListItem := dataStoreParametersListItem
			var dataStoreParametersListLocal DataStoreParameters
			err := dataStoreParametersListLocal.Initialize_From_DataStoreParameters_STATUS(&dataStoreParametersListItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_DataStoreParameters_STATUS() to populate field DataStoreParametersList")
			}
			dataStoreParametersList[dataStoreParametersListIndex] = dataStoreParametersListLocal
		}
		parameters.DataStoreParametersList = dataStoreParametersList
	} else {
		parameters.DataStoreParametersList = nil
	}

	// No error
	return nil
}

// Parameters in Policy
type PolicyParameters_STATUS struct {
	// BackupDatasourceParametersList: Gets or sets the Backup Data Source Parameters
	BackupDatasourceParametersList []BackupDatasourceParameters_STATUS `json:"backupDatasourceParametersList,omitempty"`

	// DataStoreParametersList: Gets or sets the DataStore Parameters
	DataStoreParametersList []DataStoreParameters_STATUS `json:"dataStoreParametersList,omitempty"`
}

var _ genruntime.FromARMConverter = &PolicyParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *PolicyParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PolicyParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *PolicyParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PolicyParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PolicyParameters_STATUS, got %T", armInput)
	}

	// Set property "BackupDatasourceParametersList":
	for _, item := range typedInput.BackupDatasourceParametersList {
		var item1 BackupDatasourceParameters_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		parameters.BackupDatasourceParametersList = append(parameters.BackupDatasourceParametersList, item1)
	}

	// Set property "DataStoreParametersList":
	for _, item := range typedInput.DataStoreParametersList {
		var item1 DataStoreParameters_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		parameters.DataStoreParametersList = append(parameters.DataStoreParametersList, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_PolicyParameters_STATUS populates our PolicyParameters_STATUS from the provided source PolicyParameters_STATUS
func (parameters *PolicyParameters_STATUS) AssignProperties_From_PolicyParameters_STATUS(source *storage.PolicyParameters_STATUS) error {

	// BackupDatasourceParametersList
	if source.BackupDatasourceParametersList != nil {
		backupDatasourceParametersList := make([]BackupDatasourceParameters_STATUS, len(source.BackupDatasourceParametersList))
		for backupDatasourceParametersListIndex, backupDatasourceParametersListItem := range source.BackupDatasourceParametersList {
			// Shadow the loop variable to avoid aliasing
			backupDatasourceParametersListItem := backupDatasourceParametersListItem
			var backupDatasourceParametersListLocal BackupDatasourceParameters_STATUS
			err := backupDatasourceParametersListLocal.AssignProperties_From_BackupDatasourceParameters_STATUS(&backupDatasourceParametersListItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_BackupDatasourceParameters_STATUS() to populate field BackupDatasourceParametersList")
			}
			backupDatasourceParametersList[backupDatasourceParametersListIndex] = backupDatasourceParametersListLocal
		}
		parameters.BackupDatasourceParametersList = backupDatasourceParametersList
	} else {
		parameters.BackupDatasourceParametersList = nil
	}

	// DataStoreParametersList
	if source.DataStoreParametersList != nil {
		dataStoreParametersList := make([]DataStoreParameters_STATUS, len(source.DataStoreParametersList))
		for dataStoreParametersListIndex, dataStoreParametersListItem := range source.DataStoreParametersList {
			// Shadow the loop variable to avoid aliasing
			dataStoreParametersListItem := dataStoreParametersListItem
			var dataStoreParametersListLocal DataStoreParameters_STATUS
			err := dataStoreParametersListLocal.AssignProperties_From_DataStoreParameters_STATUS(&dataStoreParametersListItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DataStoreParameters_STATUS() to populate field DataStoreParametersList")
			}
			dataStoreParametersList[dataStoreParametersListIndex] = dataStoreParametersListLocal
		}
		parameters.DataStoreParametersList = dataStoreParametersList
	} else {
		parameters.DataStoreParametersList = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PolicyParameters_STATUS populates the provided destination PolicyParameters_STATUS from our PolicyParameters_STATUS
func (parameters *PolicyParameters_STATUS) AssignProperties_To_PolicyParameters_STATUS(destination *storage.PolicyParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackupDatasourceParametersList
	if parameters.BackupDatasourceParametersList != nil {
		backupDatasourceParametersList := make([]storage.BackupDatasourceParameters_STATUS, len(parameters.BackupDatasourceParametersList))
		for backupDatasourceParametersListIndex, backupDatasourceParametersListItem := range parameters.BackupDatasourceParametersList {
			// Shadow the loop variable to avoid aliasing
			backupDatasourceParametersListItem := backupDatasourceParametersListItem
			var backupDatasourceParametersListLocal storage.BackupDatasourceParameters_STATUS
			err := backupDatasourceParametersListItem.AssignProperties_To_BackupDatasourceParameters_STATUS(&backupDatasourceParametersListLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_BackupDatasourceParameters_STATUS() to populate field BackupDatasourceParametersList")
			}
			backupDatasourceParametersList[backupDatasourceParametersListIndex] = backupDatasourceParametersListLocal
		}
		destination.BackupDatasourceParametersList = backupDatasourceParametersList
	} else {
		destination.BackupDatasourceParametersList = nil
	}

	// DataStoreParametersList
	if parameters.DataStoreParametersList != nil {
		dataStoreParametersList := make([]storage.DataStoreParameters_STATUS, len(parameters.DataStoreParametersList))
		for dataStoreParametersListIndex, dataStoreParametersListItem := range parameters.DataStoreParametersList {
			// Shadow the loop variable to avoid aliasing
			dataStoreParametersListItem := dataStoreParametersListItem
			var dataStoreParametersListLocal storage.DataStoreParameters_STATUS
			err := dataStoreParametersListItem.AssignProperties_To_DataStoreParameters_STATUS(&dataStoreParametersListLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DataStoreParameters_STATUS() to populate field DataStoreParametersList")
			}
			dataStoreParametersList[dataStoreParametersListIndex] = dataStoreParametersListLocal
		}
		destination.DataStoreParametersList = dataStoreParametersList
	} else {
		destination.DataStoreParametersList = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ProtectionStatusDetails_Status_STATUS string

const (
	ProtectionStatusDetails_Status_STATUS_ConfiguringProtection       = ProtectionStatusDetails_Status_STATUS("ConfiguringProtection")
	ProtectionStatusDetails_Status_STATUS_ConfiguringProtectionFailed = ProtectionStatusDetails_Status_STATUS("ConfiguringProtectionFailed")
	ProtectionStatusDetails_Status_STATUS_ProtectionConfigured        = ProtectionStatusDetails_Status_STATUS("ProtectionConfigured")
	ProtectionStatusDetails_Status_STATUS_ProtectionStopped           = ProtectionStatusDetails_Status_STATUS("ProtectionStopped")
	ProtectionStatusDetails_Status_STATUS_SoftDeleted                 = ProtectionStatusDetails_Status_STATUS("SoftDeleted")
	ProtectionStatusDetails_Status_STATUS_SoftDeleting                = ProtectionStatusDetails_Status_STATUS("SoftDeleting")
)

// Mapping from string to ProtectionStatusDetails_Status_STATUS
var protectionStatusDetails_Status_STATUS_Values = map[string]ProtectionStatusDetails_Status_STATUS{
	"configuringprotection":       ProtectionStatusDetails_Status_STATUS_ConfiguringProtection,
	"configuringprotectionfailed": ProtectionStatusDetails_Status_STATUS_ConfiguringProtectionFailed,
	"protectionconfigured":        ProtectionStatusDetails_Status_STATUS_ProtectionConfigured,
	"protectionstopped":           ProtectionStatusDetails_Status_STATUS_ProtectionStopped,
	"softdeleted":                 ProtectionStatusDetails_Status_STATUS_SoftDeleted,
	"softdeleting":                ProtectionStatusDetails_Status_STATUS_SoftDeleting,
}

type SecretStoreBasedAuthCredentials struct {
	// +kubebuilder:validation:Required
	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *SecretStoreBasedAuthCredentials_ObjectType `json:"objectType,omitempty"`

	// SecretStoreResource: Secret store resource
	SecretStoreResource *SecretStoreResource `json:"secretStoreResource,omitempty"`
}

var _ genruntime.ARMTransformer = &SecretStoreBasedAuthCredentials{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (credentials *SecretStoreBasedAuthCredentials) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if credentials == nil {
		return nil, nil
	}
	result := &arm.SecretStoreBasedAuthCredentials{}

	// Set property "ObjectType":
	if credentials.ObjectType != nil {
		var temp arm.SecretStoreBasedAuthCredentials_ObjectType
		var temp1 string
		temp1 = string(*credentials.ObjectType)
		temp = arm.SecretStoreBasedAuthCredentials_ObjectType(temp1)
		result.ObjectType = temp
	}

	// Set property "SecretStoreResource":
	if credentials.SecretStoreResource != nil {
		secretStoreResource_ARM, err := (*credentials.SecretStoreResource).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		secretStoreResource := *secretStoreResource_ARM.(*arm.SecretStoreResource)
		result.SecretStoreResource = &secretStoreResource
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (credentials *SecretStoreBasedAuthCredentials) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SecretStoreBasedAuthCredentials{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (credentials *SecretStoreBasedAuthCredentials) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SecretStoreBasedAuthCredentials)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SecretStoreBasedAuthCredentials, got %T", armInput)
	}

	// Set property "ObjectType":
	var temp SecretStoreBasedAuthCredentials_ObjectType
	var temp1 string
	temp1 = string(typedInput.ObjectType)
	temp = SecretStoreBasedAuthCredentials_ObjectType(temp1)
	credentials.ObjectType = &temp

	// Set property "SecretStoreResource":
	if typedInput.SecretStoreResource != nil {
		var secretStoreResource1 SecretStoreResource
		err := secretStoreResource1.PopulateFromARM(owner, *typedInput.SecretStoreResource)
		if err != nil {
			return err
		}
		secretStoreResource := secretStoreResource1
		credentials.SecretStoreResource = &secretStoreResource
	}

	// No error
	return nil
}

// AssignProperties_From_SecretStoreBasedAuthCredentials populates our SecretStoreBasedAuthCredentials from the provided source SecretStoreBasedAuthCredentials
func (credentials *SecretStoreBasedAuthCredentials) AssignProperties_From_SecretStoreBasedAuthCredentials(source *storage.SecretStoreBasedAuthCredentials) error {

	// ObjectType
	if source.ObjectType != nil {
		objectType := *source.ObjectType
		objectTypeTemp := genruntime.ToEnum(objectType, secretStoreBasedAuthCredentials_ObjectType_Values)
		credentials.ObjectType = &objectTypeTemp
	} else {
		credentials.ObjectType = nil
	}

	// SecretStoreResource
	if source.SecretStoreResource != nil {
		var secretStoreResource SecretStoreResource
		err := secretStoreResource.AssignProperties_From_SecretStoreResource(source.SecretStoreResource)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SecretStoreResource() to populate field SecretStoreResource")
		}
		credentials.SecretStoreResource = &secretStoreResource
	} else {
		credentials.SecretStoreResource = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SecretStoreBasedAuthCredentials populates the provided destination SecretStoreBasedAuthCredentials from our SecretStoreBasedAuthCredentials
func (credentials *SecretStoreBasedAuthCredentials) AssignProperties_To_SecretStoreBasedAuthCredentials(destination *storage.SecretStoreBasedAuthCredentials) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ObjectType
	if credentials.ObjectType != nil {
		objectType := string(*credentials.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// SecretStoreResource
	if credentials.SecretStoreResource != nil {
		var secretStoreResource storage.SecretStoreResource
		err := credentials.SecretStoreResource.AssignProperties_To_SecretStoreResource(&secretStoreResource)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SecretStoreResource() to populate field SecretStoreResource")
		}
		destination.SecretStoreResource = &secretStoreResource
	} else {
		destination.SecretStoreResource = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_SecretStoreBasedAuthCredentials_STATUS populates our SecretStoreBasedAuthCredentials from the provided source SecretStoreBasedAuthCredentials_STATUS
func (credentials *SecretStoreBasedAuthCredentials) Initialize_From_SecretStoreBasedAuthCredentials_STATUS(source *SecretStoreBasedAuthCredentials_STATUS) error {

	// ObjectType
	if source.ObjectType != nil {
		objectType := genruntime.ToEnum(string(*source.ObjectType), secretStoreBasedAuthCredentials_ObjectType_Values)
		credentials.ObjectType = &objectType
	} else {
		credentials.ObjectType = nil
	}

	// SecretStoreResource
	if source.SecretStoreResource != nil {
		var secretStoreResource SecretStoreResource
		err := secretStoreResource.Initialize_From_SecretStoreResource_STATUS(source.SecretStoreResource)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SecretStoreResource_STATUS() to populate field SecretStoreResource")
		}
		credentials.SecretStoreResource = &secretStoreResource
	} else {
		credentials.SecretStoreResource = nil
	}

	// No error
	return nil
}

type SecretStoreBasedAuthCredentials_STATUS struct {
	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *SecretStoreBasedAuthCredentials_ObjectType_STATUS `json:"objectType,omitempty"`

	// SecretStoreResource: Secret store resource
	SecretStoreResource *SecretStoreResource_STATUS `json:"secretStoreResource,omitempty"`
}

var _ genruntime.FromARMConverter = &SecretStoreBasedAuthCredentials_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (credentials *SecretStoreBasedAuthCredentials_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SecretStoreBasedAuthCredentials_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (credentials *SecretStoreBasedAuthCredentials_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SecretStoreBasedAuthCredentials_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SecretStoreBasedAuthCredentials_STATUS, got %T", armInput)
	}

	// Set property "ObjectType":
	var temp SecretStoreBasedAuthCredentials_ObjectType_STATUS
	var temp1 string
	temp1 = string(typedInput.ObjectType)
	temp = SecretStoreBasedAuthCredentials_ObjectType_STATUS(temp1)
	credentials.ObjectType = &temp

	// Set property "SecretStoreResource":
	if typedInput.SecretStoreResource != nil {
		var secretStoreResource1 SecretStoreResource_STATUS
		err := secretStoreResource1.PopulateFromARM(owner, *typedInput.SecretStoreResource)
		if err != nil {
			return err
		}
		secretStoreResource := secretStoreResource1
		credentials.SecretStoreResource = &secretStoreResource
	}

	// No error
	return nil
}

// AssignProperties_From_SecretStoreBasedAuthCredentials_STATUS populates our SecretStoreBasedAuthCredentials_STATUS from the provided source SecretStoreBasedAuthCredentials_STATUS
func (credentials *SecretStoreBasedAuthCredentials_STATUS) AssignProperties_From_SecretStoreBasedAuthCredentials_STATUS(source *storage.SecretStoreBasedAuthCredentials_STATUS) error {

	// ObjectType
	if source.ObjectType != nil {
		objectType := *source.ObjectType
		objectTypeTemp := genruntime.ToEnum(objectType, secretStoreBasedAuthCredentials_ObjectType_STATUS_Values)
		credentials.ObjectType = &objectTypeTemp
	} else {
		credentials.ObjectType = nil
	}

	// SecretStoreResource
	if source.SecretStoreResource != nil {
		var secretStoreResource SecretStoreResource_STATUS
		err := secretStoreResource.AssignProperties_From_SecretStoreResource_STATUS(source.SecretStoreResource)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SecretStoreResource_STATUS() to populate field SecretStoreResource")
		}
		credentials.SecretStoreResource = &secretStoreResource
	} else {
		credentials.SecretStoreResource = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SecretStoreBasedAuthCredentials_STATUS populates the provided destination SecretStoreBasedAuthCredentials_STATUS from our SecretStoreBasedAuthCredentials_STATUS
func (credentials *SecretStoreBasedAuthCredentials_STATUS) AssignProperties_To_SecretStoreBasedAuthCredentials_STATUS(destination *storage.SecretStoreBasedAuthCredentials_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ObjectType
	if credentials.ObjectType != nil {
		objectType := string(*credentials.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// SecretStoreResource
	if credentials.SecretStoreResource != nil {
		var secretStoreResource storage.SecretStoreResource_STATUS
		err := credentials.SecretStoreResource.AssignProperties_To_SecretStoreResource_STATUS(&secretStoreResource)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SecretStoreResource_STATUS() to populate field SecretStoreResource")
		}
		destination.SecretStoreResource = &secretStoreResource
	} else {
		destination.SecretStoreResource = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type UserFacingError_STATUS_Unrolled struct {
	// Code: Unique code for this error
	Code *string `json:"code,omitempty"`

	// InnerError: Inner Error
	InnerError *InnerError_STATUS `json:"innerError,omitempty"`

	// IsRetryable: Whether the operation will be retryable or not
	IsRetryable *bool `json:"isRetryable,omitempty"`

	// IsUserError: Whether the operation is due to a user error or service error
	IsUserError *bool   `json:"isUserError,omitempty"`
	Message     *string `json:"message,omitempty"`

	// Properties: Any key value pairs that can be injected inside error object
	Properties map[string]string `json:"properties,omitempty"`

	// RecommendedAction: RecommendedAction  localized.
	RecommendedAction []string `json:"recommendedAction,omitempty"`

	// Target: Target of the error.
	Target *string `json:"target,omitempty"`
}

var _ genruntime.FromARMConverter = &UserFacingError_STATUS_Unrolled{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (unrolled *UserFacingError_STATUS_Unrolled) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UserFacingError_STATUS_Unrolled{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (unrolled *UserFacingError_STATUS_Unrolled) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UserFacingError_STATUS_Unrolled)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UserFacingError_STATUS_Unrolled, got %T", armInput)
	}

	// Set property "Code":
	if typedInput.Code != nil {
		code := *typedInput.Code
		unrolled.Code = &code
	}

	// Set property "InnerError":
	if typedInput.InnerError != nil {
		var innerError1 InnerError_STATUS
		err := innerError1.PopulateFromARM(owner, *typedInput.InnerError)
		if err != nil {
			return err
		}
		innerError := innerError1
		unrolled.InnerError = &innerError
	}

	// Set property "IsRetryable":
	if typedInput.IsRetryable != nil {
		isRetryable := *typedInput.IsRetryable
		unrolled.IsRetryable = &isRetryable
	}

	// Set property "IsUserError":
	if typedInput.IsUserError != nil {
		isUserError := *typedInput.IsUserError
		unrolled.IsUserError = &isUserError
	}

	// Set property "Message":
	if typedInput.Message != nil {
		message := *typedInput.Message
		unrolled.Message = &message
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		unrolled.Properties = make(map[string]string, len(typedInput.Properties))
		for key, value := range typedInput.Properties {
			unrolled.Properties[key] = value
		}
	}

	// Set property "RecommendedAction":
	for _, item := range typedInput.RecommendedAction {
		unrolled.RecommendedAction = append(unrolled.RecommendedAction, item)
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		unrolled.Target = &target
	}

	// No error
	return nil
}

// AssignProperties_From_UserFacingError_STATUS_Unrolled populates our UserFacingError_STATUS_Unrolled from the provided source UserFacingError_STATUS_Unrolled
func (unrolled *UserFacingError_STATUS_Unrolled) AssignProperties_From_UserFacingError_STATUS_Unrolled(source *storage.UserFacingError_STATUS_Unrolled) error {

	// Code
	unrolled.Code = genruntime.ClonePointerToString(source.Code)

	// InnerError
	if source.InnerError != nil {
		var innerError InnerError_STATUS
		err := innerError.AssignProperties_From_InnerError_STATUS(source.InnerError)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_InnerError_STATUS() to populate field InnerError")
		}
		unrolled.InnerError = &innerError
	} else {
		unrolled.InnerError = nil
	}

	// IsRetryable
	if source.IsRetryable != nil {
		isRetryable := *source.IsRetryable
		unrolled.IsRetryable = &isRetryable
	} else {
		unrolled.IsRetryable = nil
	}

	// IsUserError
	if source.IsUserError != nil {
		isUserError := *source.IsUserError
		unrolled.IsUserError = &isUserError
	} else {
		unrolled.IsUserError = nil
	}

	// Message
	unrolled.Message = genruntime.ClonePointerToString(source.Message)

	// Properties
	unrolled.Properties = genruntime.CloneMapOfStringToString(source.Properties)

	// RecommendedAction
	unrolled.RecommendedAction = genruntime.CloneSliceOfString(source.RecommendedAction)

	// Target
	unrolled.Target = genruntime.ClonePointerToString(source.Target)

	// No error
	return nil
}

// AssignProperties_To_UserFacingError_STATUS_Unrolled populates the provided destination UserFacingError_STATUS_Unrolled from our UserFacingError_STATUS_Unrolled
func (unrolled *UserFacingError_STATUS_Unrolled) AssignProperties_To_UserFacingError_STATUS_Unrolled(destination *storage.UserFacingError_STATUS_Unrolled) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Code
	destination.Code = genruntime.ClonePointerToString(unrolled.Code)

	// InnerError
	if unrolled.InnerError != nil {
		var innerError storage.InnerError_STATUS
		err := unrolled.InnerError.AssignProperties_To_InnerError_STATUS(&innerError)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_InnerError_STATUS() to populate field InnerError")
		}
		destination.InnerError = &innerError
	} else {
		destination.InnerError = nil
	}

	// IsRetryable
	if unrolled.IsRetryable != nil {
		isRetryable := *unrolled.IsRetryable
		destination.IsRetryable = &isRetryable
	} else {
		destination.IsRetryable = nil
	}

	// IsUserError
	if unrolled.IsUserError != nil {
		isUserError := *unrolled.IsUserError
		destination.IsUserError = &isUserError
	} else {
		destination.IsUserError = nil
	}

	// Message
	destination.Message = genruntime.ClonePointerToString(unrolled.Message)

	// Properties
	destination.Properties = genruntime.CloneMapOfStringToString(unrolled.Properties)

	// RecommendedAction
	destination.RecommendedAction = genruntime.CloneSliceOfString(unrolled.RecommendedAction)

	// Target
	destination.Target = genruntime.ClonePointerToString(unrolled.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type BackupDatasourceParameters struct {
	// Blob: Mutually exclusive with all other properties
	Blob *BlobBackupDatasourceParameters `json:"blobBackupDatasourceParameters,omitempty"`

	// KubernetesCluster: Mutually exclusive with all other properties
	KubernetesCluster *KubernetesClusterBackupDatasourceParameters `json:"kubernetesClusterBackupDatasourceParameters,omitempty"`
}

var _ genruntime.ARMTransformer = &BackupDatasourceParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *BackupDatasourceParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.BackupDatasourceParameters{}

	// Set property "Blob":
	if parameters.Blob != nil {
		blob_ARM, err := (*parameters.Blob).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		blob := *blob_ARM.(*arm.BlobBackupDatasourceParameters)
		result.Blob = &blob
	}

	// Set property "KubernetesCluster":
	if parameters.KubernetesCluster != nil {
		kubernetesCluster_ARM, err := (*parameters.KubernetesCluster).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		kubernetesCluster := *kubernetesCluster_ARM.(*arm.KubernetesClusterBackupDatasourceParameters)
		result.KubernetesCluster = &kubernetesCluster
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *BackupDatasourceParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackupDatasourceParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *BackupDatasourceParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackupDatasourceParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackupDatasourceParameters, got %T", armInput)
	}

	// Set property "Blob":
	if typedInput.Blob != nil {
		var blob1 BlobBackupDatasourceParameters
		err := blob1.PopulateFromARM(owner, *typedInput.Blob)
		if err != nil {
			return err
		}
		blob := blob1
		parameters.Blob = &blob
	}

	// Set property "KubernetesCluster":
	if typedInput.KubernetesCluster != nil {
		var kubernetesCluster1 KubernetesClusterBackupDatasourceParameters
		err := kubernetesCluster1.PopulateFromARM(owner, *typedInput.KubernetesCluster)
		if err != nil {
			return err
		}
		kubernetesCluster := kubernetesCluster1
		parameters.KubernetesCluster = &kubernetesCluster
	}

	// No error
	return nil
}

// AssignProperties_From_BackupDatasourceParameters populates our BackupDatasourceParameters from the provided source BackupDatasourceParameters
func (parameters *BackupDatasourceParameters) AssignProperties_From_BackupDatasourceParameters(source *storage.BackupDatasourceParameters) error {

	// Blob
	if source.Blob != nil {
		var blob BlobBackupDatasourceParameters
		err := blob.AssignProperties_From_BlobBackupDatasourceParameters(source.Blob)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BlobBackupDatasourceParameters() to populate field Blob")
		}
		parameters.Blob = &blob
	} else {
		parameters.Blob = nil
	}

	// KubernetesCluster
	if source.KubernetesCluster != nil {
		var kubernetesCluster KubernetesClusterBackupDatasourceParameters
		err := kubernetesCluster.AssignProperties_From_KubernetesClusterBackupDatasourceParameters(source.KubernetesCluster)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_KubernetesClusterBackupDatasourceParameters() to populate field KubernetesCluster")
		}
		parameters.KubernetesCluster = &kubernetesCluster
	} else {
		parameters.KubernetesCluster = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackupDatasourceParameters populates the provided destination BackupDatasourceParameters from our BackupDatasourceParameters
func (parameters *BackupDatasourceParameters) AssignProperties_To_BackupDatasourceParameters(destination *storage.BackupDatasourceParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Blob
	if parameters.Blob != nil {
		var blob storage.BlobBackupDatasourceParameters
		err := parameters.Blob.AssignProperties_To_BlobBackupDatasourceParameters(&blob)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BlobBackupDatasourceParameters() to populate field Blob")
		}
		destination.Blob = &blob
	} else {
		destination.Blob = nil
	}

	// KubernetesCluster
	if parameters.KubernetesCluster != nil {
		var kubernetesCluster storage.KubernetesClusterBackupDatasourceParameters
		err := parameters.KubernetesCluster.AssignProperties_To_KubernetesClusterBackupDatasourceParameters(&kubernetesCluster)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_KubernetesClusterBackupDatasourceParameters() to populate field KubernetesCluster")
		}
		destination.KubernetesCluster = &kubernetesCluster
	} else {
		destination.KubernetesCluster = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_BackupDatasourceParameters_STATUS populates our BackupDatasourceParameters from the provided source BackupDatasourceParameters_STATUS
func (parameters *BackupDatasourceParameters) Initialize_From_BackupDatasourceParameters_STATUS(source *BackupDatasourceParameters_STATUS) error {

	// Blob
	if source.Blob != nil {
		var blob BlobBackupDatasourceParameters
		err := blob.Initialize_From_BlobBackupDatasourceParameters_STATUS(source.Blob)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_BlobBackupDatasourceParameters_STATUS() to populate field Blob")
		}
		parameters.Blob = &blob
	} else {
		parameters.Blob = nil
	}

	// KubernetesCluster
	if source.KubernetesCluster != nil {
		var kubernetesCluster KubernetesClusterBackupDatasourceParameters
		err := kubernetesCluster.Initialize_From_KubernetesClusterBackupDatasourceParameters_STATUS(source.KubernetesCluster)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_KubernetesClusterBackupDatasourceParameters_STATUS() to populate field KubernetesCluster")
		}
		parameters.KubernetesCluster = &kubernetesCluster
	} else {
		parameters.KubernetesCluster = nil
	}

	// No error
	return nil
}

type BackupDatasourceParameters_STATUS struct {
	// Blob: Mutually exclusive with all other properties
	Blob *BlobBackupDatasourceParameters_STATUS `json:"blobBackupDatasourceParameters,omitempty"`

	// KubernetesCluster: Mutually exclusive with all other properties
	KubernetesCluster *KubernetesClusterBackupDatasourceParameters_STATUS `json:"kubernetesClusterBackupDatasourceParameters,omitempty"`
}

var _ genruntime.FromARMConverter = &BackupDatasourceParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *BackupDatasourceParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackupDatasourceParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *BackupDatasourceParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackupDatasourceParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackupDatasourceParameters_STATUS, got %T", armInput)
	}

	// Set property "Blob":
	if typedInput.Blob != nil {
		var blob1 BlobBackupDatasourceParameters_STATUS
		err := blob1.PopulateFromARM(owner, *typedInput.Blob)
		if err != nil {
			return err
		}
		blob := blob1
		parameters.Blob = &blob
	}

	// Set property "KubernetesCluster":
	if typedInput.KubernetesCluster != nil {
		var kubernetesCluster1 KubernetesClusterBackupDatasourceParameters_STATUS
		err := kubernetesCluster1.PopulateFromARM(owner, *typedInput.KubernetesCluster)
		if err != nil {
			return err
		}
		kubernetesCluster := kubernetesCluster1
		parameters.KubernetesCluster = &kubernetesCluster
	}

	// No error
	return nil
}

// AssignProperties_From_BackupDatasourceParameters_STATUS populates our BackupDatasourceParameters_STATUS from the provided source BackupDatasourceParameters_STATUS
func (parameters *BackupDatasourceParameters_STATUS) AssignProperties_From_BackupDatasourceParameters_STATUS(source *storage.BackupDatasourceParameters_STATUS) error {

	// Blob
	if source.Blob != nil {
		var blob BlobBackupDatasourceParameters_STATUS
		err := blob.AssignProperties_From_BlobBackupDatasourceParameters_STATUS(source.Blob)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BlobBackupDatasourceParameters_STATUS() to populate field Blob")
		}
		parameters.Blob = &blob
	} else {
		parameters.Blob = nil
	}

	// KubernetesCluster
	if source.KubernetesCluster != nil {
		var kubernetesCluster KubernetesClusterBackupDatasourceParameters_STATUS
		err := kubernetesCluster.AssignProperties_From_KubernetesClusterBackupDatasourceParameters_STATUS(source.KubernetesCluster)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_KubernetesClusterBackupDatasourceParameters_STATUS() to populate field KubernetesCluster")
		}
		parameters.KubernetesCluster = &kubernetesCluster
	} else {
		parameters.KubernetesCluster = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackupDatasourceParameters_STATUS populates the provided destination BackupDatasourceParameters_STATUS from our BackupDatasourceParameters_STATUS
func (parameters *BackupDatasourceParameters_STATUS) AssignProperties_To_BackupDatasourceParameters_STATUS(destination *storage.BackupDatasourceParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Blob
	if parameters.Blob != nil {
		var blob storage.BlobBackupDatasourceParameters_STATUS
		err := parameters.Blob.AssignProperties_To_BlobBackupDatasourceParameters_STATUS(&blob)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BlobBackupDatasourceParameters_STATUS() to populate field Blob")
		}
		destination.Blob = &blob
	} else {
		destination.Blob = nil
	}

	// KubernetesCluster
	if parameters.KubernetesCluster != nil {
		var kubernetesCluster storage.KubernetesClusterBackupDatasourceParameters_STATUS
		err := parameters.KubernetesCluster.AssignProperties_To_KubernetesClusterBackupDatasourceParameters_STATUS(&kubernetesCluster)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_KubernetesClusterBackupDatasourceParameters_STATUS() to populate field KubernetesCluster")
		}
		destination.KubernetesCluster = &kubernetesCluster
	} else {
		destination.KubernetesCluster = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DataStoreParameters struct {
	// AzureOperationalStoreParameters: Mutually exclusive with all other properties
	AzureOperationalStoreParameters *AzureOperationalStoreParameters `json:"azureOperationalStoreParameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DataStoreParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *DataStoreParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.DataStoreParameters{}

	// Set property "AzureOperationalStoreParameters":
	if parameters.AzureOperationalStoreParameters != nil {
		azureOperationalStoreParameters_ARM, err := (*parameters.AzureOperationalStoreParameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		azureOperationalStoreParameters := *azureOperationalStoreParameters_ARM.(*arm.AzureOperationalStoreParameters)
		result.AzureOperationalStoreParameters = &azureOperationalStoreParameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *DataStoreParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DataStoreParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *DataStoreParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DataStoreParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DataStoreParameters, got %T", armInput)
	}

	// Set property "AzureOperationalStoreParameters":
	if typedInput.AzureOperationalStoreParameters != nil {
		var azureOperationalStoreParameters1 AzureOperationalStoreParameters
		err := azureOperationalStoreParameters1.PopulateFromARM(owner, *typedInput.AzureOperationalStoreParameters)
		if err != nil {
			return err
		}
		azureOperationalStoreParameters := azureOperationalStoreParameters1
		parameters.AzureOperationalStoreParameters = &azureOperationalStoreParameters
	}

	// No error
	return nil
}

// AssignProperties_From_DataStoreParameters populates our DataStoreParameters from the provided source DataStoreParameters
func (parameters *DataStoreParameters) AssignProperties_From_DataStoreParameters(source *storage.DataStoreParameters) error {

	// AzureOperationalStoreParameters
	if source.AzureOperationalStoreParameters != nil {
		var azureOperationalStoreParameter AzureOperationalStoreParameters
		err := azureOperationalStoreParameter.AssignProperties_From_AzureOperationalStoreParameters(source.AzureOperationalStoreParameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AzureOperationalStoreParameters() to populate field AzureOperationalStoreParameters")
		}
		parameters.AzureOperationalStoreParameters = &azureOperationalStoreParameter
	} else {
		parameters.AzureOperationalStoreParameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DataStoreParameters populates the provided destination DataStoreParameters from our DataStoreParameters
func (parameters *DataStoreParameters) AssignProperties_To_DataStoreParameters(destination *storage.DataStoreParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureOperationalStoreParameters
	if parameters.AzureOperationalStoreParameters != nil {
		var azureOperationalStoreParameter storage.AzureOperationalStoreParameters
		err := parameters.AzureOperationalStoreParameters.AssignProperties_To_AzureOperationalStoreParameters(&azureOperationalStoreParameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AzureOperationalStoreParameters() to populate field AzureOperationalStoreParameters")
		}
		destination.AzureOperationalStoreParameters = &azureOperationalStoreParameter
	} else {
		destination.AzureOperationalStoreParameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DataStoreParameters_STATUS populates our DataStoreParameters from the provided source DataStoreParameters_STATUS
func (parameters *DataStoreParameters) Initialize_From_DataStoreParameters_STATUS(source *DataStoreParameters_STATUS) error {

	// AzureOperationalStoreParameters
	if source.AzureOperationalStoreParameters != nil {
		var azureOperationalStoreParameter AzureOperationalStoreParameters
		err := azureOperationalStoreParameter.Initialize_From_AzureOperationalStoreParameters_STATUS(source.AzureOperationalStoreParameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_AzureOperationalStoreParameters_STATUS() to populate field AzureOperationalStoreParameters")
		}
		parameters.AzureOperationalStoreParameters = &azureOperationalStoreParameter
	} else {
		parameters.AzureOperationalStoreParameters = nil
	}

	// No error
	return nil
}

type DataStoreParameters_STATUS struct {
	// AzureOperationalStoreParameters: Mutually exclusive with all other properties
	AzureOperationalStoreParameters *AzureOperationalStoreParameters_STATUS `json:"azureOperationalStoreParameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DataStoreParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *DataStoreParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DataStoreParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *DataStoreParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DataStoreParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DataStoreParameters_STATUS, got %T", armInput)
	}

	// Set property "AzureOperationalStoreParameters":
	if typedInput.AzureOperationalStoreParameters != nil {
		var azureOperationalStoreParameters1 AzureOperationalStoreParameters_STATUS
		err := azureOperationalStoreParameters1.PopulateFromARM(owner, *typedInput.AzureOperationalStoreParameters)
		if err != nil {
			return err
		}
		azureOperationalStoreParameters := azureOperationalStoreParameters1
		parameters.AzureOperationalStoreParameters = &azureOperationalStoreParameters
	}

	// No error
	return nil
}

// AssignProperties_From_DataStoreParameters_STATUS populates our DataStoreParameters_STATUS from the provided source DataStoreParameters_STATUS
func (parameters *DataStoreParameters_STATUS) AssignProperties_From_DataStoreParameters_STATUS(source *storage.DataStoreParameters_STATUS) error {

	// AzureOperationalStoreParameters
	if source.AzureOperationalStoreParameters != nil {
		var azureOperationalStoreParameter AzureOperationalStoreParameters_STATUS
		err := azureOperationalStoreParameter.AssignProperties_From_AzureOperationalStoreParameters_STATUS(source.AzureOperationalStoreParameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AzureOperationalStoreParameters_STATUS() to populate field AzureOperationalStoreParameters")
		}
		parameters.AzureOperationalStoreParameters = &azureOperationalStoreParameter
	} else {
		parameters.AzureOperationalStoreParameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DataStoreParameters_STATUS populates the provided destination DataStoreParameters_STATUS from our DataStoreParameters_STATUS
func (parameters *DataStoreParameters_STATUS) AssignProperties_To_DataStoreParameters_STATUS(destination *storage.DataStoreParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureOperationalStoreParameters
	if parameters.AzureOperationalStoreParameters != nil {
		var azureOperationalStoreParameter storage.AzureOperationalStoreParameters_STATUS
		err := parameters.AzureOperationalStoreParameters.AssignProperties_To_AzureOperationalStoreParameters_STATUS(&azureOperationalStoreParameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AzureOperationalStoreParameters_STATUS() to populate field AzureOperationalStoreParameters")
		}
		destination.AzureOperationalStoreParameters = &azureOperationalStoreParameter
	} else {
		destination.AzureOperationalStoreParameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DefaultResourceProperties struct {
	// +kubebuilder:validation:Required
	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *DefaultResourceProperties_ObjectType `json:"objectType,omitempty"`
}

var _ genruntime.ARMTransformer = &DefaultResourceProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *DefaultResourceProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.DefaultResourceProperties{}

	// Set property "ObjectType":
	if properties.ObjectType != nil {
		var temp arm.DefaultResourceProperties_ObjectType
		var temp1 string
		temp1 = string(*properties.ObjectType)
		temp = arm.DefaultResourceProperties_ObjectType(temp1)
		result.ObjectType = temp
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *DefaultResourceProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DefaultResourceProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *DefaultResourceProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DefaultResourceProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DefaultResourceProperties, got %T", armInput)
	}

	// Set property "ObjectType":
	var temp DefaultResourceProperties_ObjectType
	var temp1 string
	temp1 = string(typedInput.ObjectType)
	temp = DefaultResourceProperties_ObjectType(temp1)
	properties.ObjectType = &temp

	// No error
	return nil
}

// AssignProperties_From_DefaultResourceProperties populates our DefaultResourceProperties from the provided source DefaultResourceProperties
func (properties *DefaultResourceProperties) AssignProperties_From_DefaultResourceProperties(source *storage.DefaultResourceProperties) error {

	// ObjectType
	if source.ObjectType != nil {
		objectType := *source.ObjectType
		objectTypeTemp := genruntime.ToEnum(objectType, defaultResourceProperties_ObjectType_Values)
		properties.ObjectType = &objectTypeTemp
	} else {
		properties.ObjectType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DefaultResourceProperties populates the provided destination DefaultResourceProperties from our DefaultResourceProperties
func (properties *DefaultResourceProperties) AssignProperties_To_DefaultResourceProperties(destination *storage.DefaultResourceProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ObjectType
	if properties.ObjectType != nil {
		objectType := string(*properties.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DefaultResourceProperties_STATUS populates our DefaultResourceProperties from the provided source DefaultResourceProperties_STATUS
func (properties *DefaultResourceProperties) Initialize_From_DefaultResourceProperties_STATUS(source *DefaultResourceProperties_STATUS) error {

	// ObjectType
	if source.ObjectType != nil {
		objectType := genruntime.ToEnum(string(*source.ObjectType), defaultResourceProperties_ObjectType_Values)
		properties.ObjectType = &objectType
	} else {
		properties.ObjectType = nil
	}

	// No error
	return nil
}

type DefaultResourceProperties_STATUS struct {
	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *DefaultResourceProperties_ObjectType_STATUS `json:"objectType,omitempty"`
}

var _ genruntime.FromARMConverter = &DefaultResourceProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *DefaultResourceProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DefaultResourceProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *DefaultResourceProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DefaultResourceProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DefaultResourceProperties_STATUS, got %T", armInput)
	}

	// Set property "ObjectType":
	var temp DefaultResourceProperties_ObjectType_STATUS
	var temp1 string
	temp1 = string(typedInput.ObjectType)
	temp = DefaultResourceProperties_ObjectType_STATUS(temp1)
	properties.ObjectType = &temp

	// No error
	return nil
}

// AssignProperties_From_DefaultResourceProperties_STATUS populates our DefaultResourceProperties_STATUS from the provided source DefaultResourceProperties_STATUS
func (properties *DefaultResourceProperties_STATUS) AssignProperties_From_DefaultResourceProperties_STATUS(source *storage.DefaultResourceProperties_STATUS) error {

	// ObjectType
	if source.ObjectType != nil {
		objectType := *source.ObjectType
		objectTypeTemp := genruntime.ToEnum(objectType, defaultResourceProperties_ObjectType_STATUS_Values)
		properties.ObjectType = &objectTypeTemp
	} else {
		properties.ObjectType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DefaultResourceProperties_STATUS populates the provided destination DefaultResourceProperties_STATUS from our DefaultResourceProperties_STATUS
func (properties *DefaultResourceProperties_STATUS) AssignProperties_To_DefaultResourceProperties_STATUS(destination *storage.DefaultResourceProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ObjectType
	if properties.ObjectType != nil {
		objectType := string(*properties.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type InnerError_STATUS_Unrolled struct {
	// AdditionalInfo: Any Key value pairs that can be provided to the client for additional  verbose information.
	AdditionalInfo map[string]string `json:"additionalInfo,omitempty"`

	// Code: Unique code for this error
	Code *string `json:"code,omitempty"`
}

var _ genruntime.FromARMConverter = &InnerError_STATUS_Unrolled{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (unrolled *InnerError_STATUS_Unrolled) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.InnerError_STATUS_Unrolled{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (unrolled *InnerError_STATUS_Unrolled) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.InnerError_STATUS_Unrolled)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.InnerError_STATUS_Unrolled, got %T", armInput)
	}

	// Set property "AdditionalInfo":
	if typedInput.AdditionalInfo != nil {
		unrolled.AdditionalInfo = make(map[string]string, len(typedInput.AdditionalInfo))
		for key, value := range typedInput.AdditionalInfo {
			unrolled.AdditionalInfo[key] = value
		}
	}

	// Set property "Code":
	if typedInput.Code != nil {
		code := *typedInput.Code
		unrolled.Code = &code
	}

	// No error
	return nil
}

// AssignProperties_From_InnerError_STATUS_Unrolled populates our InnerError_STATUS_Unrolled from the provided source InnerError_STATUS_Unrolled
func (unrolled *InnerError_STATUS_Unrolled) AssignProperties_From_InnerError_STATUS_Unrolled(source *storage.InnerError_STATUS_Unrolled) error {

	// AdditionalInfo
	unrolled.AdditionalInfo = genruntime.CloneMapOfStringToString(source.AdditionalInfo)

	// Code
	unrolled.Code = genruntime.ClonePointerToString(source.Code)

	// No error
	return nil
}

// AssignProperties_To_InnerError_STATUS_Unrolled populates the provided destination InnerError_STATUS_Unrolled from our InnerError_STATUS_Unrolled
func (unrolled *InnerError_STATUS_Unrolled) AssignProperties_To_InnerError_STATUS_Unrolled(destination *storage.InnerError_STATUS_Unrolled) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalInfo
	destination.AdditionalInfo = genruntime.CloneMapOfStringToString(unrolled.AdditionalInfo)

	// Code
	destination.Code = genruntime.ClonePointerToString(unrolled.Code)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"SecretStoreBasedAuthCredentials"}
type SecretStoreBasedAuthCredentials_ObjectType string

const SecretStoreBasedAuthCredentials_ObjectType_SecretStoreBasedAuthCredentials = SecretStoreBasedAuthCredentials_ObjectType("SecretStoreBasedAuthCredentials")

// Mapping from string to SecretStoreBasedAuthCredentials_ObjectType
var secretStoreBasedAuthCredentials_ObjectType_Values = map[string]SecretStoreBasedAuthCredentials_ObjectType{
	"secretstorebasedauthcredentials": SecretStoreBasedAuthCredentials_ObjectType_SecretStoreBasedAuthCredentials,
}

type SecretStoreBasedAuthCredentials_ObjectType_STATUS string

const SecretStoreBasedAuthCredentials_ObjectType_STATUS_SecretStoreBasedAuthCredentials = SecretStoreBasedAuthCredentials_ObjectType_STATUS("SecretStoreBasedAuthCredentials")

// Mapping from string to SecretStoreBasedAuthCredentials_ObjectType_STATUS
var secretStoreBasedAuthCredentials_ObjectType_STATUS_Values = map[string]SecretStoreBasedAuthCredentials_ObjectType_STATUS{
	"secretstorebasedauthcredentials": SecretStoreBasedAuthCredentials_ObjectType_STATUS_SecretStoreBasedAuthCredentials,
}

// Class representing a secret store resource.
type SecretStoreResource struct {
	// +kubebuilder:validation:Required
	// SecretStoreType: Gets or sets the type of secret store
	SecretStoreType *SecretStoreResource_SecretStoreType `json:"secretStoreType,omitempty"`

	// Uri: Uri to get to the resource
	Uri *string `json:"uri,omitempty"`

	// Value: Gets or sets value stored in secret store resource
	Value *string `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &SecretStoreResource{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (resource *SecretStoreResource) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if resource == nil {
		return nil, nil
	}
	result := &arm.SecretStoreResource{}

	// Set property "SecretStoreType":
	if resource.SecretStoreType != nil {
		var temp string
		temp = string(*resource.SecretStoreType)
		secretStoreType := arm.SecretStoreResource_SecretStoreType(temp)
		result.SecretStoreType = &secretStoreType
	}

	// Set property "Uri":
	if resource.Uri != nil {
		uri := *resource.Uri
		result.Uri = &uri
	}

	// Set property "Value":
	if resource.Value != nil {
		value := *resource.Value
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *SecretStoreResource) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SecretStoreResource{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *SecretStoreResource) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SecretStoreResource)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SecretStoreResource, got %T", armInput)
	}

	// Set property "SecretStoreType":
	if typedInput.SecretStoreType != nil {
		var temp string
		temp = string(*typedInput.SecretStoreType)
		secretStoreType := SecretStoreResource_SecretStoreType(temp)
		resource.SecretStoreType = &secretStoreType
	}

	// Set property "Uri":
	if typedInput.Uri != nil {
		uri := *typedInput.Uri
		resource.Uri = &uri
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		resource.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_SecretStoreResource populates our SecretStoreResource from the provided source SecretStoreResource
func (resource *SecretStoreResource) AssignProperties_From_SecretStoreResource(source *storage.SecretStoreResource) error {

	// SecretStoreType
	if source.SecretStoreType != nil {
		secretStoreType := *source.SecretStoreType
		secretStoreTypeTemp := genruntime.ToEnum(secretStoreType, secretStoreResource_SecretStoreType_Values)
		resource.SecretStoreType = &secretStoreTypeTemp
	} else {
		resource.SecretStoreType = nil
	}

	// Uri
	resource.Uri = genruntime.ClonePointerToString(source.Uri)

	// Value
	resource.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_SecretStoreResource populates the provided destination SecretStoreResource from our SecretStoreResource
func (resource *SecretStoreResource) AssignProperties_To_SecretStoreResource(destination *storage.SecretStoreResource) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SecretStoreType
	if resource.SecretStoreType != nil {
		secretStoreType := string(*resource.SecretStoreType)
		destination.SecretStoreType = &secretStoreType
	} else {
		destination.SecretStoreType = nil
	}

	// Uri
	destination.Uri = genruntime.ClonePointerToString(resource.Uri)

	// Value
	destination.Value = genruntime.ClonePointerToString(resource.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_SecretStoreResource_STATUS populates our SecretStoreResource from the provided source SecretStoreResource_STATUS
func (resource *SecretStoreResource) Initialize_From_SecretStoreResource_STATUS(source *SecretStoreResource_STATUS) error {

	// SecretStoreType
	if source.SecretStoreType != nil {
		secretStoreType := genruntime.ToEnum(string(*source.SecretStoreType), secretStoreResource_SecretStoreType_Values)
		resource.SecretStoreType = &secretStoreType
	} else {
		resource.SecretStoreType = nil
	}

	// Uri
	resource.Uri = genruntime.ClonePointerToString(source.Uri)

	// Value
	resource.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// Class representing a secret store resource.
type SecretStoreResource_STATUS struct {
	// SecretStoreType: Gets or sets the type of secret store
	SecretStoreType *SecretStoreResource_SecretStoreType_STATUS `json:"secretStoreType,omitempty"`

	// Uri: Uri to get to the resource
	Uri *string `json:"uri,omitempty"`

	// Value: Gets or sets value stored in secret store resource
	Value *string `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &SecretStoreResource_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *SecretStoreResource_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SecretStoreResource_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *SecretStoreResource_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SecretStoreResource_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SecretStoreResource_STATUS, got %T", armInput)
	}

	// Set property "SecretStoreType":
	if typedInput.SecretStoreType != nil {
		var temp string
		temp = string(*typedInput.SecretStoreType)
		secretStoreType := SecretStoreResource_SecretStoreType_STATUS(temp)
		resource.SecretStoreType = &secretStoreType
	}

	// Set property "Uri":
	if typedInput.Uri != nil {
		uri := *typedInput.Uri
		resource.Uri = &uri
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		resource.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_SecretStoreResource_STATUS populates our SecretStoreResource_STATUS from the provided source SecretStoreResource_STATUS
func (resource *SecretStoreResource_STATUS) AssignProperties_From_SecretStoreResource_STATUS(source *storage.SecretStoreResource_STATUS) error {

	// SecretStoreType
	if source.SecretStoreType != nil {
		secretStoreType := *source.SecretStoreType
		secretStoreTypeTemp := genruntime.ToEnum(secretStoreType, secretStoreResource_SecretStoreType_STATUS_Values)
		resource.SecretStoreType = &secretStoreTypeTemp
	} else {
		resource.SecretStoreType = nil
	}

	// Uri
	resource.Uri = genruntime.ClonePointerToString(source.Uri)

	// Value
	resource.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_SecretStoreResource_STATUS populates the provided destination SecretStoreResource_STATUS from our SecretStoreResource_STATUS
func (resource *SecretStoreResource_STATUS) AssignProperties_To_SecretStoreResource_STATUS(destination *storage.SecretStoreResource_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SecretStoreType
	if resource.SecretStoreType != nil {
		secretStoreType := string(*resource.SecretStoreType)
		destination.SecretStoreType = &secretStoreType
	} else {
		destination.SecretStoreType = nil
	}

	// Uri
	destination.Uri = genruntime.ClonePointerToString(resource.Uri)

	// Value
	destination.Value = genruntime.ClonePointerToString(resource.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AzureOperationalStoreParameters struct {
	// +kubebuilder:validation:Required
	// DataStoreType: type of datastore; Operational/Vault/Archive
	DataStoreType *AzureOperationalStoreParameters_DataStoreType `json:"dataStoreType,omitempty"`

	// +kubebuilder:validation:Required
	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *AzureOperationalStoreParameters_ObjectType `json:"objectType,omitempty"`

	// ResourceGroupReference: Gets or sets the Snapshot Resource Group Uri.
	ResourceGroupReference *genruntime.ResourceReference `armReference:"ResourceGroupId" json:"resourceGroupReference,omitempty"`
}

var _ genruntime.ARMTransformer = &AzureOperationalStoreParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *AzureOperationalStoreParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.AzureOperationalStoreParameters{}

	// Set property "DataStoreType":
	if parameters.DataStoreType != nil {
		var temp string
		temp = string(*parameters.DataStoreType)
		dataStoreType := arm.AzureOperationalStoreParameters_DataStoreType(temp)
		result.DataStoreType = &dataStoreType
	}

	// Set property "ObjectType":
	if parameters.ObjectType != nil {
		var temp arm.AzureOperationalStoreParameters_ObjectType
		var temp1 string
		temp1 = string(*parameters.ObjectType)
		temp = arm.AzureOperationalStoreParameters_ObjectType(temp1)
		result.ObjectType = temp
	}

	// Set property "ResourceGroupId":
	if parameters.ResourceGroupReference != nil {
		resourceGroupReferenceARMID, err := resolved.ResolvedReferences.Lookup(*parameters.ResourceGroupReference)
		if err != nil {
			return nil, err
		}
		resourceGroupReference := resourceGroupReferenceARMID
		result.ResourceGroupId = &resourceGroupReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *AzureOperationalStoreParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureOperationalStoreParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *AzureOperationalStoreParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureOperationalStoreParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureOperationalStoreParameters, got %T", armInput)
	}

	// Set property "DataStoreType":
	if typedInput.DataStoreType != nil {
		var temp string
		temp = string(*typedInput.DataStoreType)
		dataStoreType := AzureOperationalStoreParameters_DataStoreType(temp)
		parameters.DataStoreType = &dataStoreType
	}

	// Set property "ObjectType":
	var temp AzureOperationalStoreParameters_ObjectType
	var temp1 string
	temp1 = string(typedInput.ObjectType)
	temp = AzureOperationalStoreParameters_ObjectType(temp1)
	parameters.ObjectType = &temp

	// no assignment for property "ResourceGroupReference"

	// No error
	return nil
}

// AssignProperties_From_AzureOperationalStoreParameters populates our AzureOperationalStoreParameters from the provided source AzureOperationalStoreParameters
func (parameters *AzureOperationalStoreParameters) AssignProperties_From_AzureOperationalStoreParameters(source *storage.AzureOperationalStoreParameters) error {

	// DataStoreType
	if source.DataStoreType != nil {
		dataStoreType := *source.DataStoreType
		dataStoreTypeTemp := genruntime.ToEnum(dataStoreType, azureOperationalStoreParameters_DataStoreType_Values)
		parameters.DataStoreType = &dataStoreTypeTemp
	} else {
		parameters.DataStoreType = nil
	}

	// ObjectType
	if source.ObjectType != nil {
		objectType := *source.ObjectType
		objectTypeTemp := genruntime.ToEnum(objectType, azureOperationalStoreParameters_ObjectType_Values)
		parameters.ObjectType = &objectTypeTemp
	} else {
		parameters.ObjectType = nil
	}

	// ResourceGroupReference
	if source.ResourceGroupReference != nil {
		resourceGroupReference := source.ResourceGroupReference.Copy()
		parameters.ResourceGroupReference = &resourceGroupReference
	} else {
		parameters.ResourceGroupReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AzureOperationalStoreParameters populates the provided destination AzureOperationalStoreParameters from our AzureOperationalStoreParameters
func (parameters *AzureOperationalStoreParameters) AssignProperties_To_AzureOperationalStoreParameters(destination *storage.AzureOperationalStoreParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataStoreType
	if parameters.DataStoreType != nil {
		dataStoreType := string(*parameters.DataStoreType)
		destination.DataStoreType = &dataStoreType
	} else {
		destination.DataStoreType = nil
	}

	// ObjectType
	if parameters.ObjectType != nil {
		objectType := string(*parameters.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// ResourceGroupReference
	if parameters.ResourceGroupReference != nil {
		resourceGroupReference := parameters.ResourceGroupReference.Copy()
		destination.ResourceGroupReference = &resourceGroupReference
	} else {
		destination.ResourceGroupReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AzureOperationalStoreParameters_STATUS populates our AzureOperationalStoreParameters from the provided source AzureOperationalStoreParameters_STATUS
func (parameters *AzureOperationalStoreParameters) Initialize_From_AzureOperationalStoreParameters_STATUS(source *AzureOperationalStoreParameters_STATUS) error {

	// DataStoreType
	if source.DataStoreType != nil {
		dataStoreType := genruntime.ToEnum(string(*source.DataStoreType), azureOperationalStoreParameters_DataStoreType_Values)
		parameters.DataStoreType = &dataStoreType
	} else {
		parameters.DataStoreType = nil
	}

	// ObjectType
	if source.ObjectType != nil {
		objectType := genruntime.ToEnum(string(*source.ObjectType), azureOperationalStoreParameters_ObjectType_Values)
		parameters.ObjectType = &objectType
	} else {
		parameters.ObjectType = nil
	}

	// ResourceGroupReference
	if source.ResourceGroupId != nil {
		resourceGroupReference := genruntime.CreateResourceReferenceFromARMID(*source.ResourceGroupId)
		parameters.ResourceGroupReference = &resourceGroupReference
	} else {
		parameters.ResourceGroupReference = nil
	}

	// No error
	return nil
}

type AzureOperationalStoreParameters_STATUS struct {
	// DataStoreType: type of datastore; Operational/Vault/Archive
	DataStoreType *AzureOperationalStoreParameters_DataStoreType_STATUS `json:"dataStoreType,omitempty"`

	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *AzureOperationalStoreParameters_ObjectType_STATUS `json:"objectType,omitempty"`

	// ResourceGroupId: Gets or sets the Snapshot Resource Group Uri.
	ResourceGroupId *string `json:"resourceGroupId,omitempty"`
}

var _ genruntime.FromARMConverter = &AzureOperationalStoreParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *AzureOperationalStoreParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AzureOperationalStoreParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *AzureOperationalStoreParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AzureOperationalStoreParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AzureOperationalStoreParameters_STATUS, got %T", armInput)
	}

	// Set property "DataStoreType":
	if typedInput.DataStoreType != nil {
		var temp string
		temp = string(*typedInput.DataStoreType)
		dataStoreType := AzureOperationalStoreParameters_DataStoreType_STATUS(temp)
		parameters.DataStoreType = &dataStoreType
	}

	// Set property "ObjectType":
	var temp AzureOperationalStoreParameters_ObjectType_STATUS
	var temp1 string
	temp1 = string(typedInput.ObjectType)
	temp = AzureOperationalStoreParameters_ObjectType_STATUS(temp1)
	parameters.ObjectType = &temp

	// Set property "ResourceGroupId":
	if typedInput.ResourceGroupId != nil {
		resourceGroupId := *typedInput.ResourceGroupId
		parameters.ResourceGroupId = &resourceGroupId
	}

	// No error
	return nil
}

// AssignProperties_From_AzureOperationalStoreParameters_STATUS populates our AzureOperationalStoreParameters_STATUS from the provided source AzureOperationalStoreParameters_STATUS
func (parameters *AzureOperationalStoreParameters_STATUS) AssignProperties_From_AzureOperationalStoreParameters_STATUS(source *storage.AzureOperationalStoreParameters_STATUS) error {

	// DataStoreType
	if source.DataStoreType != nil {
		dataStoreType := *source.DataStoreType
		dataStoreTypeTemp := genruntime.ToEnum(dataStoreType, azureOperationalStoreParameters_DataStoreType_STATUS_Values)
		parameters.DataStoreType = &dataStoreTypeTemp
	} else {
		parameters.DataStoreType = nil
	}

	// ObjectType
	if source.ObjectType != nil {
		objectType := *source.ObjectType
		objectTypeTemp := genruntime.ToEnum(objectType, azureOperationalStoreParameters_ObjectType_STATUS_Values)
		parameters.ObjectType = &objectTypeTemp
	} else {
		parameters.ObjectType = nil
	}

	// ResourceGroupId
	parameters.ResourceGroupId = genruntime.ClonePointerToString(source.ResourceGroupId)

	// No error
	return nil
}

// AssignProperties_To_AzureOperationalStoreParameters_STATUS populates the provided destination AzureOperationalStoreParameters_STATUS from our AzureOperationalStoreParameters_STATUS
func (parameters *AzureOperationalStoreParameters_STATUS) AssignProperties_To_AzureOperationalStoreParameters_STATUS(destination *storage.AzureOperationalStoreParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataStoreType
	if parameters.DataStoreType != nil {
		dataStoreType := string(*parameters.DataStoreType)
		destination.DataStoreType = &dataStoreType
	} else {
		destination.DataStoreType = nil
	}

	// ObjectType
	if parameters.ObjectType != nil {
		objectType := string(*parameters.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// ResourceGroupId
	destination.ResourceGroupId = genruntime.ClonePointerToString(parameters.ResourceGroupId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type BlobBackupDatasourceParameters struct {
	// +kubebuilder:validation:Required
	// ContainersList: List of containers to be backed up during configuration of backup of blobs
	ContainersList []string `json:"containersList,omitempty"`

	// +kubebuilder:validation:Required
	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *BlobBackupDatasourceParameters_ObjectType `json:"objectType,omitempty"`
}

var _ genruntime.ARMTransformer = &BlobBackupDatasourceParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *BlobBackupDatasourceParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.BlobBackupDatasourceParameters{}

	// Set property "ContainersList":
	for _, item := range parameters.ContainersList {
		result.ContainersList = append(result.ContainersList, item)
	}

	// Set property "ObjectType":
	if parameters.ObjectType != nil {
		var temp arm.BlobBackupDatasourceParameters_ObjectType
		var temp1 string
		temp1 = string(*parameters.ObjectType)
		temp = arm.BlobBackupDatasourceParameters_ObjectType(temp1)
		result.ObjectType = temp
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *BlobBackupDatasourceParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BlobBackupDatasourceParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *BlobBackupDatasourceParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BlobBackupDatasourceParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BlobBackupDatasourceParameters, got %T", armInput)
	}

	// Set property "ContainersList":
	for _, item := range typedInput.ContainersList {
		parameters.ContainersList = append(parameters.ContainersList, item)
	}

	// Set property "ObjectType":
	var temp BlobBackupDatasourceParameters_ObjectType
	var temp1 string
	temp1 = string(typedInput.ObjectType)
	temp = BlobBackupDatasourceParameters_ObjectType(temp1)
	parameters.ObjectType = &temp

	// No error
	return nil
}

// AssignProperties_From_BlobBackupDatasourceParameters populates our BlobBackupDatasourceParameters from the provided source BlobBackupDatasourceParameters
func (parameters *BlobBackupDatasourceParameters) AssignProperties_From_BlobBackupDatasourceParameters(source *storage.BlobBackupDatasourceParameters) error {

	// ContainersList
	parameters.ContainersList = genruntime.CloneSliceOfString(source.ContainersList)

	// ObjectType
	if source.ObjectType != nil {
		objectType := *source.ObjectType
		objectTypeTemp := genruntime.ToEnum(objectType, blobBackupDatasourceParameters_ObjectType_Values)
		parameters.ObjectType = &objectTypeTemp
	} else {
		parameters.ObjectType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BlobBackupDatasourceParameters populates the provided destination BlobBackupDatasourceParameters from our BlobBackupDatasourceParameters
func (parameters *BlobBackupDatasourceParameters) AssignProperties_To_BlobBackupDatasourceParameters(destination *storage.BlobBackupDatasourceParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ContainersList
	destination.ContainersList = genruntime.CloneSliceOfString(parameters.ContainersList)

	// ObjectType
	if parameters.ObjectType != nil {
		objectType := string(*parameters.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_BlobBackupDatasourceParameters_STATUS populates our BlobBackupDatasourceParameters from the provided source BlobBackupDatasourceParameters_STATUS
func (parameters *BlobBackupDatasourceParameters) Initialize_From_BlobBackupDatasourceParameters_STATUS(source *BlobBackupDatasourceParameters_STATUS) error {

	// ContainersList
	parameters.ContainersList = genruntime.CloneSliceOfString(source.ContainersList)

	// ObjectType
	if source.ObjectType != nil {
		objectType := genruntime.ToEnum(string(*source.ObjectType), blobBackupDatasourceParameters_ObjectType_Values)
		parameters.ObjectType = &objectType
	} else {
		parameters.ObjectType = nil
	}

	// No error
	return nil
}

type BlobBackupDatasourceParameters_STATUS struct {
	// ContainersList: List of containers to be backed up during configuration of backup of blobs
	ContainersList []string `json:"containersList,omitempty"`

	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *BlobBackupDatasourceParameters_ObjectType_STATUS `json:"objectType,omitempty"`
}

var _ genruntime.FromARMConverter = &BlobBackupDatasourceParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *BlobBackupDatasourceParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BlobBackupDatasourceParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *BlobBackupDatasourceParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BlobBackupDatasourceParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BlobBackupDatasourceParameters_STATUS, got %T", armInput)
	}

	// Set property "ContainersList":
	for _, item := range typedInput.ContainersList {
		parameters.ContainersList = append(parameters.ContainersList, item)
	}

	// Set property "ObjectType":
	var temp BlobBackupDatasourceParameters_ObjectType_STATUS
	var temp1 string
	temp1 = string(typedInput.ObjectType)
	temp = BlobBackupDatasourceParameters_ObjectType_STATUS(temp1)
	parameters.ObjectType = &temp

	// No error
	return nil
}

// AssignProperties_From_BlobBackupDatasourceParameters_STATUS populates our BlobBackupDatasourceParameters_STATUS from the provided source BlobBackupDatasourceParameters_STATUS
func (parameters *BlobBackupDatasourceParameters_STATUS) AssignProperties_From_BlobBackupDatasourceParameters_STATUS(source *storage.BlobBackupDatasourceParameters_STATUS) error {

	// ContainersList
	parameters.ContainersList = genruntime.CloneSliceOfString(source.ContainersList)

	// ObjectType
	if source.ObjectType != nil {
		objectType := *source.ObjectType
		objectTypeTemp := genruntime.ToEnum(objectType, blobBackupDatasourceParameters_ObjectType_STATUS_Values)
		parameters.ObjectType = &objectTypeTemp
	} else {
		parameters.ObjectType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BlobBackupDatasourceParameters_STATUS populates the provided destination BlobBackupDatasourceParameters_STATUS from our BlobBackupDatasourceParameters_STATUS
func (parameters *BlobBackupDatasourceParameters_STATUS) AssignProperties_To_BlobBackupDatasourceParameters_STATUS(destination *storage.BlobBackupDatasourceParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ContainersList
	destination.ContainersList = genruntime.CloneSliceOfString(parameters.ContainersList)

	// ObjectType
	if parameters.ObjectType != nil {
		objectType := string(*parameters.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"DefaultResourceProperties"}
type DefaultResourceProperties_ObjectType string

const DefaultResourceProperties_ObjectType_DefaultResourceProperties = DefaultResourceProperties_ObjectType("DefaultResourceProperties")

// Mapping from string to DefaultResourceProperties_ObjectType
var defaultResourceProperties_ObjectType_Values = map[string]DefaultResourceProperties_ObjectType{
	"defaultresourceproperties": DefaultResourceProperties_ObjectType_DefaultResourceProperties,
}

type DefaultResourceProperties_ObjectType_STATUS string

const DefaultResourceProperties_ObjectType_STATUS_DefaultResourceProperties = DefaultResourceProperties_ObjectType_STATUS("DefaultResourceProperties")

// Mapping from string to DefaultResourceProperties_ObjectType_STATUS
var defaultResourceProperties_ObjectType_STATUS_Values = map[string]DefaultResourceProperties_ObjectType_STATUS{
	"defaultresourceproperties": DefaultResourceProperties_ObjectType_STATUS_DefaultResourceProperties,
}

type KubernetesClusterBackupDatasourceParameters struct {
	// BackupHookReferences: Gets or sets the backup hook references. This property sets the hook reference to be executed
	// during backup.
	BackupHookReferences []NamespacedNameResource `json:"backupHookReferences,omitempty"`

	// ExcludedNamespaces: Gets or sets the exclude namespaces property. This property sets the namespaces to be excluded
	// during backup.
	ExcludedNamespaces []string `json:"excludedNamespaces,omitempty"`

	// ExcludedResourceTypes: Gets or sets the exclude resource types property. This property sets the resource types to be
	// excluded during backup.
	ExcludedResourceTypes []string `json:"excludedResourceTypes,omitempty"`

	// +kubebuilder:validation:Required
	// IncludeClusterScopeResources: Gets or sets the include cluster resources property. This property if enabled will include
	// cluster scope resources during backup.
	IncludeClusterScopeResources *bool `json:"includeClusterScopeResources,omitempty"`

	// IncludedNamespaces: Gets or sets the include namespaces property. This property sets the namespaces to be included
	// during backup.
	IncludedNamespaces []string `json:"includedNamespaces,omitempty"`

	// IncludedResourceTypes: Gets or sets the include resource types property. This property sets the resource types to be
	// included during backup.
	IncludedResourceTypes []string `json:"includedResourceTypes,omitempty"`

	// LabelSelectors: Gets or sets the LabelSelectors property. This property sets the resource with such label selectors to
	// be included during backup.
	LabelSelectors []string `json:"labelSelectors,omitempty"`

	// +kubebuilder:validation:Required
	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *KubernetesClusterBackupDatasourceParameters_ObjectType `json:"objectType,omitempty"`

	// +kubebuilder:validation:Required
	// SnapshotVolumes: Gets or sets the volume snapshot property. This property if enabled will take volume snapshots during
	// backup.
	SnapshotVolumes *bool `json:"snapshotVolumes,omitempty"`
}

var _ genruntime.ARMTransformer = &KubernetesClusterBackupDatasourceParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *KubernetesClusterBackupDatasourceParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.KubernetesClusterBackupDatasourceParameters{}

	// Set property "BackupHookReferences":
	for _, item := range parameters.BackupHookReferences {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.BackupHookReferences = append(result.BackupHookReferences, *item_ARM.(*arm.NamespacedNameResource))
	}

	// Set property "ExcludedNamespaces":
	for _, item := range parameters.ExcludedNamespaces {
		result.ExcludedNamespaces = append(result.ExcludedNamespaces, item)
	}

	// Set property "ExcludedResourceTypes":
	for _, item := range parameters.ExcludedResourceTypes {
		result.ExcludedResourceTypes = append(result.ExcludedResourceTypes, item)
	}

	// Set property "IncludeClusterScopeResources":
	if parameters.IncludeClusterScopeResources != nil {
		includeClusterScopeResources := *parameters.IncludeClusterScopeResources
		result.IncludeClusterScopeResources = &includeClusterScopeResources
	}

	// Set property "IncludedNamespaces":
	for _, item := range parameters.IncludedNamespaces {
		result.IncludedNamespaces = append(result.IncludedNamespaces, item)
	}

	// Set property "IncludedResourceTypes":
	for _, item := range parameters.IncludedResourceTypes {
		result.IncludedResourceTypes = append(result.IncludedResourceTypes, item)
	}

	// Set property "LabelSelectors":
	for _, item := range parameters.LabelSelectors {
		result.LabelSelectors = append(result.LabelSelectors, item)
	}

	// Set property "ObjectType":
	if parameters.ObjectType != nil {
		var temp arm.KubernetesClusterBackupDatasourceParameters_ObjectType
		var temp1 string
		temp1 = string(*parameters.ObjectType)
		temp = arm.KubernetesClusterBackupDatasourceParameters_ObjectType(temp1)
		result.ObjectType = temp
	}

	// Set property "SnapshotVolumes":
	if parameters.SnapshotVolumes != nil {
		snapshotVolumes := *parameters.SnapshotVolumes
		result.SnapshotVolumes = &snapshotVolumes
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *KubernetesClusterBackupDatasourceParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KubernetesClusterBackupDatasourceParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *KubernetesClusterBackupDatasourceParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KubernetesClusterBackupDatasourceParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KubernetesClusterBackupDatasourceParameters, got %T", armInput)
	}

	// Set property "BackupHookReferences":
	for _, item := range typedInput.BackupHookReferences {
		var item1 NamespacedNameResource
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		parameters.BackupHookReferences = append(parameters.BackupHookReferences, item1)
	}

	// Set property "ExcludedNamespaces":
	for _, item := range typedInput.ExcludedNamespaces {
		parameters.ExcludedNamespaces = append(parameters.ExcludedNamespaces, item)
	}

	// Set property "ExcludedResourceTypes":
	for _, item := range typedInput.ExcludedResourceTypes {
		parameters.ExcludedResourceTypes = append(parameters.ExcludedResourceTypes, item)
	}

	// Set property "IncludeClusterScopeResources":
	if typedInput.IncludeClusterScopeResources != nil {
		includeClusterScopeResources := *typedInput.IncludeClusterScopeResources
		parameters.IncludeClusterScopeResources = &includeClusterScopeResources
	}

	// Set property "IncludedNamespaces":
	for _, item := range typedInput.IncludedNamespaces {
		parameters.IncludedNamespaces = append(parameters.IncludedNamespaces, item)
	}

	// Set property "IncludedResourceTypes":
	for _, item := range typedInput.IncludedResourceTypes {
		parameters.IncludedResourceTypes = append(parameters.IncludedResourceTypes, item)
	}

	// Set property "LabelSelectors":
	for _, item := range typedInput.LabelSelectors {
		parameters.LabelSelectors = append(parameters.LabelSelectors, item)
	}

	// Set property "ObjectType":
	var temp KubernetesClusterBackupDatasourceParameters_ObjectType
	var temp1 string
	temp1 = string(typedInput.ObjectType)
	temp = KubernetesClusterBackupDatasourceParameters_ObjectType(temp1)
	parameters.ObjectType = &temp

	// Set property "SnapshotVolumes":
	if typedInput.SnapshotVolumes != nil {
		snapshotVolumes := *typedInput.SnapshotVolumes
		parameters.SnapshotVolumes = &snapshotVolumes
	}

	// No error
	return nil
}

// AssignProperties_From_KubernetesClusterBackupDatasourceParameters populates our KubernetesClusterBackupDatasourceParameters from the provided source KubernetesClusterBackupDatasourceParameters
func (parameters *KubernetesClusterBackupDatasourceParameters) AssignProperties_From_KubernetesClusterBackupDatasourceParameters(source *storage.KubernetesClusterBackupDatasourceParameters) error {

	// BackupHookReferences
	if source.BackupHookReferences != nil {
		backupHookReferenceList := make([]NamespacedNameResource, len(source.BackupHookReferences))
		for backupHookReferenceIndex, backupHookReferenceItem := range source.BackupHookReferences {
			// Shadow the loop variable to avoid aliasing
			backupHookReferenceItem := backupHookReferenceItem
			var backupHookReference NamespacedNameResource
			err := backupHookReference.AssignProperties_From_NamespacedNameResource(&backupHookReferenceItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_NamespacedNameResource() to populate field BackupHookReferences")
			}
			backupHookReferenceList[backupHookReferenceIndex] = backupHookReference
		}
		parameters.BackupHookReferences = backupHookReferenceList
	} else {
		parameters.BackupHookReferences = nil
	}

	// ExcludedNamespaces
	parameters.ExcludedNamespaces = genruntime.CloneSliceOfString(source.ExcludedNamespaces)

	// ExcludedResourceTypes
	parameters.ExcludedResourceTypes = genruntime.CloneSliceOfString(source.ExcludedResourceTypes)

	// IncludeClusterScopeResources
	if source.IncludeClusterScopeResources != nil {
		includeClusterScopeResource := *source.IncludeClusterScopeResources
		parameters.IncludeClusterScopeResources = &includeClusterScopeResource
	} else {
		parameters.IncludeClusterScopeResources = nil
	}

	// IncludedNamespaces
	parameters.IncludedNamespaces = genruntime.CloneSliceOfString(source.IncludedNamespaces)

	// IncludedResourceTypes
	parameters.IncludedResourceTypes = genruntime.CloneSliceOfString(source.IncludedResourceTypes)

	// LabelSelectors
	parameters.LabelSelectors = genruntime.CloneSliceOfString(source.LabelSelectors)

	// ObjectType
	if source.ObjectType != nil {
		objectType := *source.ObjectType
		objectTypeTemp := genruntime.ToEnum(objectType, kubernetesClusterBackupDatasourceParameters_ObjectType_Values)
		parameters.ObjectType = &objectTypeTemp
	} else {
		parameters.ObjectType = nil
	}

	// SnapshotVolumes
	if source.SnapshotVolumes != nil {
		snapshotVolume := *source.SnapshotVolumes
		parameters.SnapshotVolumes = &snapshotVolume
	} else {
		parameters.SnapshotVolumes = nil
	}

	// No error
	return nil
}

// AssignProperties_To_KubernetesClusterBackupDatasourceParameters populates the provided destination KubernetesClusterBackupDatasourceParameters from our KubernetesClusterBackupDatasourceParameters
func (parameters *KubernetesClusterBackupDatasourceParameters) AssignProperties_To_KubernetesClusterBackupDatasourceParameters(destination *storage.KubernetesClusterBackupDatasourceParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackupHookReferences
	if parameters.BackupHookReferences != nil {
		backupHookReferenceList := make([]storage.NamespacedNameResource, len(parameters.BackupHookReferences))
		for backupHookReferenceIndex, backupHookReferenceItem := range parameters.BackupHookReferences {
			// Shadow the loop variable to avoid aliasing
			backupHookReferenceItem := backupHookReferenceItem
			var backupHookReference storage.NamespacedNameResource
			err := backupHookReferenceItem.AssignProperties_To_NamespacedNameResource(&backupHookReference)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_NamespacedNameResource() to populate field BackupHookReferences")
			}
			backupHookReferenceList[backupHookReferenceIndex] = backupHookReference
		}
		destination.BackupHookReferences = backupHookReferenceList
	} else {
		destination.BackupHookReferences = nil
	}

	// ExcludedNamespaces
	destination.ExcludedNamespaces = genruntime.CloneSliceOfString(parameters.ExcludedNamespaces)

	// ExcludedResourceTypes
	destination.ExcludedResourceTypes = genruntime.CloneSliceOfString(parameters.ExcludedResourceTypes)

	// IncludeClusterScopeResources
	if parameters.IncludeClusterScopeResources != nil {
		includeClusterScopeResource := *parameters.IncludeClusterScopeResources
		destination.IncludeClusterScopeResources = &includeClusterScopeResource
	} else {
		destination.IncludeClusterScopeResources = nil
	}

	// IncludedNamespaces
	destination.IncludedNamespaces = genruntime.CloneSliceOfString(parameters.IncludedNamespaces)

	// IncludedResourceTypes
	destination.IncludedResourceTypes = genruntime.CloneSliceOfString(parameters.IncludedResourceTypes)

	// LabelSelectors
	destination.LabelSelectors = genruntime.CloneSliceOfString(parameters.LabelSelectors)

	// ObjectType
	if parameters.ObjectType != nil {
		objectType := string(*parameters.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// SnapshotVolumes
	if parameters.SnapshotVolumes != nil {
		snapshotVolume := *parameters.SnapshotVolumes
		destination.SnapshotVolumes = &snapshotVolume
	} else {
		destination.SnapshotVolumes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_KubernetesClusterBackupDatasourceParameters_STATUS populates our KubernetesClusterBackupDatasourceParameters from the provided source KubernetesClusterBackupDatasourceParameters_STATUS
func (parameters *KubernetesClusterBackupDatasourceParameters) Initialize_From_KubernetesClusterBackupDatasourceParameters_STATUS(source *KubernetesClusterBackupDatasourceParameters_STATUS) error {

	// BackupHookReferences
	if source.BackupHookReferences != nil {
		backupHookReferenceList := make([]NamespacedNameResource, len(source.BackupHookReferences))
		for backupHookReferenceIndex, backupHookReferenceItem := range source.BackupHookReferences {
			// Shadow the loop variable to avoid aliasing
			backupHookReferenceItem := backupHookReferenceItem
			var backupHookReference NamespacedNameResource
			err := backupHookReference.Initialize_From_NamespacedNameResource_STATUS(&backupHookReferenceItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_NamespacedNameResource_STATUS() to populate field BackupHookReferences")
			}
			backupHookReferenceList[backupHookReferenceIndex] = backupHookReference
		}
		parameters.BackupHookReferences = backupHookReferenceList
	} else {
		parameters.BackupHookReferences = nil
	}

	// ExcludedNamespaces
	parameters.ExcludedNamespaces = genruntime.CloneSliceOfString(source.ExcludedNamespaces)

	// ExcludedResourceTypes
	parameters.ExcludedResourceTypes = genruntime.CloneSliceOfString(source.ExcludedResourceTypes)

	// IncludeClusterScopeResources
	if source.IncludeClusterScopeResources != nil {
		includeClusterScopeResource := *source.IncludeClusterScopeResources
		parameters.IncludeClusterScopeResources = &includeClusterScopeResource
	} else {
		parameters.IncludeClusterScopeResources = nil
	}

	// IncludedNamespaces
	parameters.IncludedNamespaces = genruntime.CloneSliceOfString(source.IncludedNamespaces)

	// IncludedResourceTypes
	parameters.IncludedResourceTypes = genruntime.CloneSliceOfString(source.IncludedResourceTypes)

	// LabelSelectors
	parameters.LabelSelectors = genruntime.CloneSliceOfString(source.LabelSelectors)

	// ObjectType
	if source.ObjectType != nil {
		objectType := genruntime.ToEnum(string(*source.ObjectType), kubernetesClusterBackupDatasourceParameters_ObjectType_Values)
		parameters.ObjectType = &objectType
	} else {
		parameters.ObjectType = nil
	}

	// SnapshotVolumes
	if source.SnapshotVolumes != nil {
		snapshotVolume := *source.SnapshotVolumes
		parameters.SnapshotVolumes = &snapshotVolume
	} else {
		parameters.SnapshotVolumes = nil
	}

	// No error
	return nil
}

type KubernetesClusterBackupDatasourceParameters_STATUS struct {
	// BackupHookReferences: Gets or sets the backup hook references. This property sets the hook reference to be executed
	// during backup.
	BackupHookReferences []NamespacedNameResource_STATUS `json:"backupHookReferences,omitempty"`

	// ExcludedNamespaces: Gets or sets the exclude namespaces property. This property sets the namespaces to be excluded
	// during backup.
	ExcludedNamespaces []string `json:"excludedNamespaces,omitempty"`

	// ExcludedResourceTypes: Gets or sets the exclude resource types property. This property sets the resource types to be
	// excluded during backup.
	ExcludedResourceTypes []string `json:"excludedResourceTypes,omitempty"`

	// IncludeClusterScopeResources: Gets or sets the include cluster resources property. This property if enabled will include
	// cluster scope resources during backup.
	IncludeClusterScopeResources *bool `json:"includeClusterScopeResources,omitempty"`

	// IncludedNamespaces: Gets or sets the include namespaces property. This property sets the namespaces to be included
	// during backup.
	IncludedNamespaces []string `json:"includedNamespaces,omitempty"`

	// IncludedResourceTypes: Gets or sets the include resource types property. This property sets the resource types to be
	// included during backup.
	IncludedResourceTypes []string `json:"includedResourceTypes,omitempty"`

	// LabelSelectors: Gets or sets the LabelSelectors property. This property sets the resource with such label selectors to
	// be included during backup.
	LabelSelectors []string `json:"labelSelectors,omitempty"`

	// ObjectType: Type of the specific object - used for deserializing
	ObjectType *KubernetesClusterBackupDatasourceParameters_ObjectType_STATUS `json:"objectType,omitempty"`

	// SnapshotVolumes: Gets or sets the volume snapshot property. This property if enabled will take volume snapshots during
	// backup.
	SnapshotVolumes *bool `json:"snapshotVolumes,omitempty"`
}

var _ genruntime.FromARMConverter = &KubernetesClusterBackupDatasourceParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *KubernetesClusterBackupDatasourceParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KubernetesClusterBackupDatasourceParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *KubernetesClusterBackupDatasourceParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KubernetesClusterBackupDatasourceParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KubernetesClusterBackupDatasourceParameters_STATUS, got %T", armInput)
	}

	// Set property "BackupHookReferences":
	for _, item := range typedInput.BackupHookReferences {
		var item1 NamespacedNameResource_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		parameters.BackupHookReferences = append(parameters.BackupHookReferences, item1)
	}

	// Set property "ExcludedNamespaces":
	for _, item := range typedInput.ExcludedNamespaces {
		parameters.ExcludedNamespaces = append(parameters.ExcludedNamespaces, item)
	}

	// Set property "ExcludedResourceTypes":
	for _, item := range typedInput.ExcludedResourceTypes {
		parameters.ExcludedResourceTypes = append(parameters.ExcludedResourceTypes, item)
	}

	// Set property "IncludeClusterScopeResources":
	if typedInput.IncludeClusterScopeResources != nil {
		includeClusterScopeResources := *typedInput.IncludeClusterScopeResources
		parameters.IncludeClusterScopeResources = &includeClusterScopeResources
	}

	// Set property "IncludedNamespaces":
	for _, item := range typedInput.IncludedNamespaces {
		parameters.IncludedNamespaces = append(parameters.IncludedNamespaces, item)
	}

	// Set property "IncludedResourceTypes":
	for _, item := range typedInput.IncludedResourceTypes {
		parameters.IncludedResourceTypes = append(parameters.IncludedResourceTypes, item)
	}

	// Set property "LabelSelectors":
	for _, item := range typedInput.LabelSelectors {
		parameters.LabelSelectors = append(parameters.LabelSelectors, item)
	}

	// Set property "ObjectType":
	var temp KubernetesClusterBackupDatasourceParameters_ObjectType_STATUS
	var temp1 string
	temp1 = string(typedInput.ObjectType)
	temp = KubernetesClusterBackupDatasourceParameters_ObjectType_STATUS(temp1)
	parameters.ObjectType = &temp

	// Set property "SnapshotVolumes":
	if typedInput.SnapshotVolumes != nil {
		snapshotVolumes := *typedInput.SnapshotVolumes
		parameters.SnapshotVolumes = &snapshotVolumes
	}

	// No error
	return nil
}

// AssignProperties_From_KubernetesClusterBackupDatasourceParameters_STATUS populates our KubernetesClusterBackupDatasourceParameters_STATUS from the provided source KubernetesClusterBackupDatasourceParameters_STATUS
func (parameters *KubernetesClusterBackupDatasourceParameters_STATUS) AssignProperties_From_KubernetesClusterBackupDatasourceParameters_STATUS(source *storage.KubernetesClusterBackupDatasourceParameters_STATUS) error {

	// BackupHookReferences
	if source.BackupHookReferences != nil {
		backupHookReferenceList := make([]NamespacedNameResource_STATUS, len(source.BackupHookReferences))
		for backupHookReferenceIndex, backupHookReferenceItem := range source.BackupHookReferences {
			// Shadow the loop variable to avoid aliasing
			backupHookReferenceItem := backupHookReferenceItem
			var backupHookReference NamespacedNameResource_STATUS
			err := backupHookReference.AssignProperties_From_NamespacedNameResource_STATUS(&backupHookReferenceItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_NamespacedNameResource_STATUS() to populate field BackupHookReferences")
			}
			backupHookReferenceList[backupHookReferenceIndex] = backupHookReference
		}
		parameters.BackupHookReferences = backupHookReferenceList
	} else {
		parameters.BackupHookReferences = nil
	}

	// ExcludedNamespaces
	parameters.ExcludedNamespaces = genruntime.CloneSliceOfString(source.ExcludedNamespaces)

	// ExcludedResourceTypes
	parameters.ExcludedResourceTypes = genruntime.CloneSliceOfString(source.ExcludedResourceTypes)

	// IncludeClusterScopeResources
	if source.IncludeClusterScopeResources != nil {
		includeClusterScopeResource := *source.IncludeClusterScopeResources
		parameters.IncludeClusterScopeResources = &includeClusterScopeResource
	} else {
		parameters.IncludeClusterScopeResources = nil
	}

	// IncludedNamespaces
	parameters.IncludedNamespaces = genruntime.CloneSliceOfString(source.IncludedNamespaces)

	// IncludedResourceTypes
	parameters.IncludedResourceTypes = genruntime.CloneSliceOfString(source.IncludedResourceTypes)

	// LabelSelectors
	parameters.LabelSelectors = genruntime.CloneSliceOfString(source.LabelSelectors)

	// ObjectType
	if source.ObjectType != nil {
		objectType := *source.ObjectType
		objectTypeTemp := genruntime.ToEnum(objectType, kubernetesClusterBackupDatasourceParameters_ObjectType_STATUS_Values)
		parameters.ObjectType = &objectTypeTemp
	} else {
		parameters.ObjectType = nil
	}

	// SnapshotVolumes
	if source.SnapshotVolumes != nil {
		snapshotVolume := *source.SnapshotVolumes
		parameters.SnapshotVolumes = &snapshotVolume
	} else {
		parameters.SnapshotVolumes = nil
	}

	// No error
	return nil
}

// AssignProperties_To_KubernetesClusterBackupDatasourceParameters_STATUS populates the provided destination KubernetesClusterBackupDatasourceParameters_STATUS from our KubernetesClusterBackupDatasourceParameters_STATUS
func (parameters *KubernetesClusterBackupDatasourceParameters_STATUS) AssignProperties_To_KubernetesClusterBackupDatasourceParameters_STATUS(destination *storage.KubernetesClusterBackupDatasourceParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackupHookReferences
	if parameters.BackupHookReferences != nil {
		backupHookReferenceList := make([]storage.NamespacedNameResource_STATUS, len(parameters.BackupHookReferences))
		for backupHookReferenceIndex, backupHookReferenceItem := range parameters.BackupHookReferences {
			// Shadow the loop variable to avoid aliasing
			backupHookReferenceItem := backupHookReferenceItem
			var backupHookReference storage.NamespacedNameResource_STATUS
			err := backupHookReferenceItem.AssignProperties_To_NamespacedNameResource_STATUS(&backupHookReference)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_NamespacedNameResource_STATUS() to populate field BackupHookReferences")
			}
			backupHookReferenceList[backupHookReferenceIndex] = backupHookReference
		}
		destination.BackupHookReferences = backupHookReferenceList
	} else {
		destination.BackupHookReferences = nil
	}

	// ExcludedNamespaces
	destination.ExcludedNamespaces = genruntime.CloneSliceOfString(parameters.ExcludedNamespaces)

	// ExcludedResourceTypes
	destination.ExcludedResourceTypes = genruntime.CloneSliceOfString(parameters.ExcludedResourceTypes)

	// IncludeClusterScopeResources
	if parameters.IncludeClusterScopeResources != nil {
		includeClusterScopeResource := *parameters.IncludeClusterScopeResources
		destination.IncludeClusterScopeResources = &includeClusterScopeResource
	} else {
		destination.IncludeClusterScopeResources = nil
	}

	// IncludedNamespaces
	destination.IncludedNamespaces = genruntime.CloneSliceOfString(parameters.IncludedNamespaces)

	// IncludedResourceTypes
	destination.IncludedResourceTypes = genruntime.CloneSliceOfString(parameters.IncludedResourceTypes)

	// LabelSelectors
	destination.LabelSelectors = genruntime.CloneSliceOfString(parameters.LabelSelectors)

	// ObjectType
	if parameters.ObjectType != nil {
		objectType := string(*parameters.ObjectType)
		destination.ObjectType = &objectType
	} else {
		destination.ObjectType = nil
	}

	// SnapshotVolumes
	if parameters.SnapshotVolumes != nil {
		snapshotVolume := *parameters.SnapshotVolumes
		destination.SnapshotVolumes = &snapshotVolume
	} else {
		destination.SnapshotVolumes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"AzureKeyVault","Invalid"}
type SecretStoreResource_SecretStoreType string

const (
	SecretStoreResource_SecretStoreType_AzureKeyVault = SecretStoreResource_SecretStoreType("AzureKeyVault")
	SecretStoreResource_SecretStoreType_Invalid       = SecretStoreResource_SecretStoreType("Invalid")
)

// Mapping from string to SecretStoreResource_SecretStoreType
var secretStoreResource_SecretStoreType_Values = map[string]SecretStoreResource_SecretStoreType{
	"azurekeyvault": SecretStoreResource_SecretStoreType_AzureKeyVault,
	"invalid":       SecretStoreResource_SecretStoreType_Invalid,
}

type SecretStoreResource_SecretStoreType_STATUS string

const (
	SecretStoreResource_SecretStoreType_STATUS_AzureKeyVault = SecretStoreResource_SecretStoreType_STATUS("AzureKeyVault")
	SecretStoreResource_SecretStoreType_STATUS_Invalid       = SecretStoreResource_SecretStoreType_STATUS("Invalid")
)

// Mapping from string to SecretStoreResource_SecretStoreType_STATUS
var secretStoreResource_SecretStoreType_STATUS_Values = map[string]SecretStoreResource_SecretStoreType_STATUS{
	"azurekeyvault": SecretStoreResource_SecretStoreType_STATUS_AzureKeyVault,
	"invalid":       SecretStoreResource_SecretStoreType_STATUS_Invalid,
}

// +kubebuilder:validation:Enum={"ArchiveStore","OperationalStore","VaultStore"}
type AzureOperationalStoreParameters_DataStoreType string

const (
	AzureOperationalStoreParameters_DataStoreType_ArchiveStore     = AzureOperationalStoreParameters_DataStoreType("ArchiveStore")
	AzureOperationalStoreParameters_DataStoreType_OperationalStore = AzureOperationalStoreParameters_DataStoreType("OperationalStore")
	AzureOperationalStoreParameters_DataStoreType_VaultStore       = AzureOperationalStoreParameters_DataStoreType("VaultStore")
)

// Mapping from string to AzureOperationalStoreParameters_DataStoreType
var azureOperationalStoreParameters_DataStoreType_Values = map[string]AzureOperationalStoreParameters_DataStoreType{
	"archivestore":     AzureOperationalStoreParameters_DataStoreType_ArchiveStore,
	"operationalstore": AzureOperationalStoreParameters_DataStoreType_OperationalStore,
	"vaultstore":       AzureOperationalStoreParameters_DataStoreType_VaultStore,
}

type AzureOperationalStoreParameters_DataStoreType_STATUS string

const (
	AzureOperationalStoreParameters_DataStoreType_STATUS_ArchiveStore     = AzureOperationalStoreParameters_DataStoreType_STATUS("ArchiveStore")
	AzureOperationalStoreParameters_DataStoreType_STATUS_OperationalStore = AzureOperationalStoreParameters_DataStoreType_STATUS("OperationalStore")
	AzureOperationalStoreParameters_DataStoreType_STATUS_VaultStore       = AzureOperationalStoreParameters_DataStoreType_STATUS("VaultStore")
)

// Mapping from string to AzureOperationalStoreParameters_DataStoreType_STATUS
var azureOperationalStoreParameters_DataStoreType_STATUS_Values = map[string]AzureOperationalStoreParameters_DataStoreType_STATUS{
	"archivestore":     AzureOperationalStoreParameters_DataStoreType_STATUS_ArchiveStore,
	"operationalstore": AzureOperationalStoreParameters_DataStoreType_STATUS_OperationalStore,
	"vaultstore":       AzureOperationalStoreParameters_DataStoreType_STATUS_VaultStore,
}

// +kubebuilder:validation:Enum={"AzureOperationalStoreParameters"}
type AzureOperationalStoreParameters_ObjectType string

const AzureOperationalStoreParameters_ObjectType_AzureOperationalStoreParameters = AzureOperationalStoreParameters_ObjectType("AzureOperationalStoreParameters")

// Mapping from string to AzureOperationalStoreParameters_ObjectType
var azureOperationalStoreParameters_ObjectType_Values = map[string]AzureOperationalStoreParameters_ObjectType{
	"azureoperationalstoreparameters": AzureOperationalStoreParameters_ObjectType_AzureOperationalStoreParameters,
}

type AzureOperationalStoreParameters_ObjectType_STATUS string

const AzureOperationalStoreParameters_ObjectType_STATUS_AzureOperationalStoreParameters = AzureOperationalStoreParameters_ObjectType_STATUS("AzureOperationalStoreParameters")

// Mapping from string to AzureOperationalStoreParameters_ObjectType_STATUS
var azureOperationalStoreParameters_ObjectType_STATUS_Values = map[string]AzureOperationalStoreParameters_ObjectType_STATUS{
	"azureoperationalstoreparameters": AzureOperationalStoreParameters_ObjectType_STATUS_AzureOperationalStoreParameters,
}

// +kubebuilder:validation:Enum={"BlobBackupDatasourceParameters"}
type BlobBackupDatasourceParameters_ObjectType string

const BlobBackupDatasourceParameters_ObjectType_BlobBackupDatasourceParameters = BlobBackupDatasourceParameters_ObjectType("BlobBackupDatasourceParameters")

// Mapping from string to BlobBackupDatasourceParameters_ObjectType
var blobBackupDatasourceParameters_ObjectType_Values = map[string]BlobBackupDatasourceParameters_ObjectType{
	"blobbackupdatasourceparameters": BlobBackupDatasourceParameters_ObjectType_BlobBackupDatasourceParameters,
}

type BlobBackupDatasourceParameters_ObjectType_STATUS string

const BlobBackupDatasourceParameters_ObjectType_STATUS_BlobBackupDatasourceParameters = BlobBackupDatasourceParameters_ObjectType_STATUS("BlobBackupDatasourceParameters")

// Mapping from string to BlobBackupDatasourceParameters_ObjectType_STATUS
var blobBackupDatasourceParameters_ObjectType_STATUS_Values = map[string]BlobBackupDatasourceParameters_ObjectType_STATUS{
	"blobbackupdatasourceparameters": BlobBackupDatasourceParameters_ObjectType_STATUS_BlobBackupDatasourceParameters,
}

// +kubebuilder:validation:Enum={"KubernetesClusterBackupDatasourceParameters"}
type KubernetesClusterBackupDatasourceParameters_ObjectType string

const KubernetesClusterBackupDatasourceParameters_ObjectType_KubernetesClusterBackupDatasourceParameters = KubernetesClusterBackupDatasourceParameters_ObjectType("KubernetesClusterBackupDatasourceParameters")

// Mapping from string to KubernetesClusterBackupDatasourceParameters_ObjectType
var kubernetesClusterBackupDatasourceParameters_ObjectType_Values = map[string]KubernetesClusterBackupDatasourceParameters_ObjectType{
	"kubernetesclusterbackupdatasourceparameters": KubernetesClusterBackupDatasourceParameters_ObjectType_KubernetesClusterBackupDatasourceParameters,
}

type KubernetesClusterBackupDatasourceParameters_ObjectType_STATUS string

const KubernetesClusterBackupDatasourceParameters_ObjectType_STATUS_KubernetesClusterBackupDatasourceParameters = KubernetesClusterBackupDatasourceParameters_ObjectType_STATUS("KubernetesClusterBackupDatasourceParameters")

// Mapping from string to KubernetesClusterBackupDatasourceParameters_ObjectType_STATUS
var kubernetesClusterBackupDatasourceParameters_ObjectType_STATUS_Values = map[string]KubernetesClusterBackupDatasourceParameters_ObjectType_STATUS{
	"kubernetesclusterbackupdatasourceparameters": KubernetesClusterBackupDatasourceParameters_ObjectType_STATUS_KubernetesClusterBackupDatasourceParameters,
}

// Class to refer resources which contains namespace and name
type NamespacedNameResource struct {
	// Name: Name of the resource
	Name *string `json:"name,omitempty"`

	// Namespace: Namespace in which the resource exists
	Namespace *string `json:"namespace,omitempty"`
}

var _ genruntime.ARMTransformer = &NamespacedNameResource{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (resource *NamespacedNameResource) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if resource == nil {
		return nil, nil
	}
	result := &arm.NamespacedNameResource{}

	// Set property "Name":
	if resource.Name != nil {
		name := *resource.Name
		result.Name = &name
	}

	// Set property "Namespace":
	if resource.Namespace != nil {
		namespace := *resource.Namespace
		result.Namespace = &namespace
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *NamespacedNameResource) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NamespacedNameResource{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *NamespacedNameResource) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NamespacedNameResource)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NamespacedNameResource, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		resource.Name = &name
	}

	// Set property "Namespace":
	if typedInput.Namespace != nil {
		namespace := *typedInput.Namespace
		resource.Namespace = &namespace
	}

	// No error
	return nil
}

// AssignProperties_From_NamespacedNameResource populates our NamespacedNameResource from the provided source NamespacedNameResource
func (resource *NamespacedNameResource) AssignProperties_From_NamespacedNameResource(source *storage.NamespacedNameResource) error {

	// Name
	resource.Name = genruntime.ClonePointerToString(source.Name)

	// Namespace
	resource.Namespace = genruntime.ClonePointerToString(source.Namespace)

	// No error
	return nil
}

// AssignProperties_To_NamespacedNameResource populates the provided destination NamespacedNameResource from our NamespacedNameResource
func (resource *NamespacedNameResource) AssignProperties_To_NamespacedNameResource(destination *storage.NamespacedNameResource) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(resource.Name)

	// Namespace
	destination.Namespace = genruntime.ClonePointerToString(resource.Namespace)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_NamespacedNameResource_STATUS populates our NamespacedNameResource from the provided source NamespacedNameResource_STATUS
func (resource *NamespacedNameResource) Initialize_From_NamespacedNameResource_STATUS(source *NamespacedNameResource_STATUS) error {

	// Name
	resource.Name = genruntime.ClonePointerToString(source.Name)

	// Namespace
	resource.Namespace = genruntime.ClonePointerToString(source.Namespace)

	// No error
	return nil
}

// Class to refer resources which contains namespace and name
type NamespacedNameResource_STATUS struct {
	// Name: Name of the resource
	Name *string `json:"name,omitempty"`

	// Namespace: Namespace in which the resource exists
	Namespace *string `json:"namespace,omitempty"`
}

var _ genruntime.FromARMConverter = &NamespacedNameResource_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *NamespacedNameResource_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NamespacedNameResource_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *NamespacedNameResource_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NamespacedNameResource_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NamespacedNameResource_STATUS, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		resource.Name = &name
	}

	// Set property "Namespace":
	if typedInput.Namespace != nil {
		namespace := *typedInput.Namespace
		resource.Namespace = &namespace
	}

	// No error
	return nil
}

// AssignProperties_From_NamespacedNameResource_STATUS populates our NamespacedNameResource_STATUS from the provided source NamespacedNameResource_STATUS
func (resource *NamespacedNameResource_STATUS) AssignProperties_From_NamespacedNameResource_STATUS(source *storage.NamespacedNameResource_STATUS) error {

	// Name
	resource.Name = genruntime.ClonePointerToString(source.Name)

	// Namespace
	resource.Namespace = genruntime.ClonePointerToString(source.Namespace)

	// No error
	return nil
}

// AssignProperties_To_NamespacedNameResource_STATUS populates the provided destination NamespacedNameResource_STATUS from our NamespacedNameResource_STATUS
func (resource *NamespacedNameResource_STATUS) AssignProperties_To_NamespacedNameResource_STATUS(destination *storage.NamespacedNameResource_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(resource.Name)

	// Namespace
	destination.Namespace = genruntime.ClonePointerToString(resource.Namespace)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&BackupVaultsBackupInstance{}, &BackupVaultsBackupInstanceList{})
}
