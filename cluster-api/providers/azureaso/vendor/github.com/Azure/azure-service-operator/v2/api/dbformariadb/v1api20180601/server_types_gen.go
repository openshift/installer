// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20180601

import (
	"fmt"
	v20180601s "github.com/Azure/azure-service-operator/v2/api/dbformariadb/v1api20180601/storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /mariadb/resource-manager/Microsoft.DBforMariaDB/stable/2018-06-01/mariadb.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DBforMariaDB/servers/{serverName}
type Server struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              Server_Spec   `json:"spec,omitempty"`
	Status            Server_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &Server{}

// GetConditions returns the conditions of the resource
func (server *Server) GetConditions() conditions.Conditions {
	return server.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (server *Server) SetConditions(conditions conditions.Conditions) {
	server.Status.Conditions = conditions
}

var _ conversion.Convertible = &Server{}

// ConvertFrom populates our Server from the provided hub Server
func (server *Server) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v20180601s.Server)
	if !ok {
		return fmt.Errorf("expected dbformariadb/v1api20180601/storage/Server but received %T instead", hub)
	}

	return server.AssignProperties_From_Server(source)
}

// ConvertTo populates the provided hub Server from our Server
func (server *Server) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v20180601s.Server)
	if !ok {
		return fmt.Errorf("expected dbformariadb/v1api20180601/storage/Server but received %T instead", hub)
	}

	return server.AssignProperties_To_Server(destination)
}

// +kubebuilder:webhook:path=/mutate-dbformariadb-azure-com-v1api20180601-server,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=dbformariadb.azure.com,resources=servers,verbs=create;update,versions=v1api20180601,name=default.v1api20180601.servers.dbformariadb.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &Server{}

// Default applies defaults to the Server resource
func (server *Server) Default() {
	server.defaultImpl()
	var temp any = server
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (server *Server) defaultAzureName() {
	if server.Spec.AzureName == "" {
		server.Spec.AzureName = server.Name
	}
}

// defaultImpl applies the code generated defaults to the Server resource
func (server *Server) defaultImpl() { server.defaultAzureName() }

var _ genruntime.ImportableResource = &Server{}

// InitializeSpec initializes the spec for this resource from the given status
func (server *Server) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*Server_STATUS); ok {
		return server.Spec.Initialize_From_Server_STATUS(s)
	}

	return fmt.Errorf("expected Status of type Server_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &Server{}

// AzureName returns the Azure name of the resource
func (server *Server) AzureName() string {
	return server.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2018-06-01"
func (server Server) GetAPIVersion() string {
	return string(APIVersion_Value)
}

// GetResourceScope returns the scope of the resource
func (server *Server) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (server *Server) GetSpec() genruntime.ConvertibleSpec {
	return &server.Spec
}

// GetStatus returns the status of this resource
func (server *Server) GetStatus() genruntime.ConvertibleStatus {
	return &server.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (server *Server) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.DBforMariaDB/servers"
func (server *Server) GetType() string {
	return "Microsoft.DBforMariaDB/servers"
}

// NewEmptyStatus returns a new empty (blank) status
func (server *Server) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &Server_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (server *Server) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(server.Spec)
	return server.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (server *Server) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*Server_STATUS); ok {
		server.Status = *st
		return nil
	}

	// Convert status to required version
	var st Server_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	server.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-dbformariadb-azure-com-v1api20180601-server,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=dbformariadb.azure.com,resources=servers,verbs=create;update,versions=v1api20180601,name=validate.v1api20180601.servers.dbformariadb.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &Server{}

// ValidateCreate validates the creation of the resource
func (server *Server) ValidateCreate() (admission.Warnings, error) {
	validations := server.createValidations()
	var temp any = server
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	return genruntime.ValidateCreate(validations)
}

// ValidateDelete validates the deletion of the resource
func (server *Server) ValidateDelete() (admission.Warnings, error) {
	validations := server.deleteValidations()
	var temp any = server
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	return genruntime.ValidateDelete(validations)
}

// ValidateUpdate validates an update of the resource
func (server *Server) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	validations := server.updateValidations()
	var temp any = server
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	return genruntime.ValidateUpdate(old, validations)
}

// createValidations validates the creation of the resource
func (server *Server) createValidations() []func() (admission.Warnings, error) {
	return []func() (admission.Warnings, error){server.validateResourceReferences, server.validateOwnerReference, server.validateSecretDestinations}
}

// deleteValidations validates the deletion of the resource
func (server *Server) deleteValidations() []func() (admission.Warnings, error) {
	return nil
}

// updateValidations validates the update of the resource
func (server *Server) updateValidations() []func(old runtime.Object) (admission.Warnings, error) {
	return []func(old runtime.Object) (admission.Warnings, error){
		func(old runtime.Object) (admission.Warnings, error) {
			return server.validateResourceReferences()
		},
		server.validateWriteOnceProperties,
		func(old runtime.Object) (admission.Warnings, error) {
			return server.validateOwnerReference()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return server.validateSecretDestinations()
		},
	}
}

// validateOwnerReference validates the owner field
func (server *Server) validateOwnerReference() (admission.Warnings, error) {
	return genruntime.ValidateOwner(server)
}

// validateResourceReferences validates all resource references
func (server *Server) validateResourceReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindResourceReferences(&server.Spec)
	if err != nil {
		return nil, err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateSecretDestinations validates there are no colliding genruntime.SecretDestination's
func (server *Server) validateSecretDestinations() (admission.Warnings, error) {
	if server.Spec.OperatorSpec == nil {
		return nil, nil
	}
	if server.Spec.OperatorSpec.Secrets == nil {
		return nil, nil
	}
	toValidate := []*genruntime.SecretDestination{
		server.Spec.OperatorSpec.Secrets.FullyQualifiedDomainName,
	}
	return genruntime.ValidateSecretDestinations(toValidate)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (server *Server) validateWriteOnceProperties(old runtime.Object) (admission.Warnings, error) {
	oldObj, ok := old.(*Server)
	if !ok {
		return nil, nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, server)
}

// AssignProperties_From_Server populates our Server from the provided source Server
func (server *Server) AssignProperties_From_Server(source *v20180601s.Server) error {

	// ObjectMeta
	server.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec Server_Spec
	err := spec.AssignProperties_From_Server_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_Server_Spec() to populate field Spec")
	}
	server.Spec = spec

	// Status
	var status Server_STATUS
	err = status.AssignProperties_From_Server_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_Server_STATUS() to populate field Status")
	}
	server.Status = status

	// No error
	return nil
}

// AssignProperties_To_Server populates the provided destination Server from our Server
func (server *Server) AssignProperties_To_Server(destination *v20180601s.Server) error {

	// ObjectMeta
	destination.ObjectMeta = *server.ObjectMeta.DeepCopy()

	// Spec
	var spec v20180601s.Server_Spec
	err := server.Spec.AssignProperties_To_Server_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_Server_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v20180601s.Server_STATUS
	err = server.Status.AssignProperties_To_Server_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_Server_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (server *Server) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: server.Spec.OriginalVersion(),
		Kind:    "Server",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /mariadb/resource-manager/Microsoft.DBforMariaDB/stable/2018-06-01/mariadb.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DBforMariaDB/servers/{serverName}
type ServerList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Server `json:"items"`
}

type Server_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// +kubebuilder:validation:Required
	// Location: The location the resource resides in.
	Location *string `json:"location,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *ServerOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// +kubebuilder:validation:Required
	// Properties: Properties of the server.
	Properties *ServerPropertiesForCreate `json:"properties,omitempty"`

	// Sku: The SKU (pricing tier) of the server.
	Sku *Sku `json:"sku,omitempty"`

	// Tags: Application-specific metadata in the form of key-value pairs.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &Server_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (server *Server_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if server == nil {
		return nil, nil
	}
	result := &Server_Spec_ARM{}

	// Set property "Location":
	if server.Location != nil {
		location := *server.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if server.Properties != nil {
		properties_ARM, err := (*server.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*ServerPropertiesForCreate_ARM)
		result.Properties = &properties
	}

	// Set property "Sku":
	if server.Sku != nil {
		sku_ARM, err := (*server.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := *sku_ARM.(*Sku_ARM)
		result.Sku = &sku
	}

	// Set property "Tags":
	if server.Tags != nil {
		result.Tags = make(map[string]string, len(server.Tags))
		for key, value := range server.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (server *Server_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Server_Spec_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (server *Server_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Server_Spec_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Server_Spec_ARM, got %T", armInput)
	}

	// Set property "AzureName":
	server.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		server.Location = &location
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	server.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 ServerPropertiesForCreate
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		server.Properties = &properties
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 Sku
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		server.Sku = &sku
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		server.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			server.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &Server_Spec{}

// ConvertSpecFrom populates our Server_Spec from the provided source
func (server *Server_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v20180601s.Server_Spec)
	if ok {
		// Populate our instance from source
		return server.AssignProperties_From_Server_Spec(src)
	}

	// Convert to an intermediate form
	src = &v20180601s.Server_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = server.AssignProperties_From_Server_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our Server_Spec
func (server *Server_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v20180601s.Server_Spec)
	if ok {
		// Populate destination from our instance
		return server.AssignProperties_To_Server_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &v20180601s.Server_Spec{}
	err := server.AssignProperties_To_Server_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_Server_Spec populates our Server_Spec from the provided source Server_Spec
func (server *Server_Spec) AssignProperties_From_Server_Spec(source *v20180601s.Server_Spec) error {

	// AzureName
	server.AzureName = source.AzureName

	// Location
	server.Location = genruntime.ClonePointerToString(source.Location)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec ServerOperatorSpec
		err := operatorSpec.AssignProperties_From_ServerOperatorSpec(source.OperatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ServerOperatorSpec() to populate field OperatorSpec")
		}
		server.OperatorSpec = &operatorSpec
	} else {
		server.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		server.Owner = &owner
	} else {
		server.Owner = nil
	}

	// Properties
	if source.Properties != nil {
		var property ServerPropertiesForCreate
		err := property.AssignProperties_From_ServerPropertiesForCreate(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ServerPropertiesForCreate() to populate field Properties")
		}
		server.Properties = &property
	} else {
		server.Properties = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.AssignProperties_From_Sku(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Sku() to populate field Sku")
		}
		server.Sku = &sku
	} else {
		server.Sku = nil
	}

	// Tags
	server.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// AssignProperties_To_Server_Spec populates the provided destination Server_Spec from our Server_Spec
func (server *Server_Spec) AssignProperties_To_Server_Spec(destination *v20180601s.Server_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = server.AzureName

	// Location
	destination.Location = genruntime.ClonePointerToString(server.Location)

	// OperatorSpec
	if server.OperatorSpec != nil {
		var operatorSpec v20180601s.ServerOperatorSpec
		err := server.OperatorSpec.AssignProperties_To_ServerOperatorSpec(&operatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ServerOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = server.OriginalVersion()

	// Owner
	if server.Owner != nil {
		owner := server.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Properties
	if server.Properties != nil {
		var property v20180601s.ServerPropertiesForCreate
		err := server.Properties.AssignProperties_To_ServerPropertiesForCreate(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ServerPropertiesForCreate() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// Sku
	if server.Sku != nil {
		var sku v20180601s.Sku
		err := server.Sku.AssignProperties_To_Sku(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Sku() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(server.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Server_STATUS populates our Server_Spec from the provided source Server_STATUS
func (server *Server_Spec) Initialize_From_Server_STATUS(source *Server_STATUS) error {

	// Location
	server.Location = genruntime.ClonePointerToString(source.Location)

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.Initialize_From_Sku_STATUS(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_Sku_STATUS() to populate field Sku")
		}
		server.Sku = &sku
	} else {
		server.Sku = nil
	}

	// Tags
	server.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (server *Server_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (server *Server_Spec) SetAzureName(azureName string) { server.AzureName = azureName }

// Represents a server.
type Server_STATUS struct {
	// AdministratorLogin: The administrator's login name of a server. Can only be specified when the server is being created
	// (and is required for creation).
	AdministratorLogin *string `json:"administratorLogin,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// EarliestRestoreDate: Earliest restore point creation time (ISO8601 format)
	EarliestRestoreDate *string `json:"earliestRestoreDate,omitempty"`

	// FullyQualifiedDomainName: The fully qualified domain name of a server.
	FullyQualifiedDomainName *string `json:"fullyQualifiedDomainName,omitempty"`

	// Id: Fully qualified resource ID for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`

	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// MasterServerId: The master server id of a replica server.
	MasterServerId *string `json:"masterServerId,omitempty"`

	// MinimalTlsVersion: Enforce a minimal Tls version for the server.
	MinimalTlsVersion *MinimalTlsVersion_STATUS `json:"minimalTlsVersion,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// PrivateEndpointConnections: List of private endpoint connections on a server
	PrivateEndpointConnections []ServerPrivateEndpointConnection_STATUS `json:"privateEndpointConnections,omitempty"`

	// PublicNetworkAccess: Whether or not public network access is allowed for this server. Value is optional but if passed
	// in, must be 'Enabled' or 'Disabled'
	PublicNetworkAccess *PublicNetworkAccess_STATUS `json:"publicNetworkAccess,omitempty"`

	// ReplicaCapacity: The maximum number of replicas that a master server can have.
	ReplicaCapacity *int `json:"replicaCapacity,omitempty"`

	// ReplicationRole: The replication role of the server.
	ReplicationRole *string `json:"replicationRole,omitempty"`

	// Sku: The SKU (pricing tier) of the server.
	Sku *Sku_STATUS `json:"sku,omitempty"`

	// SslEnforcement: Enable ssl enforcement or not when connect to server.
	SslEnforcement *SslEnforcement_STATUS `json:"sslEnforcement,omitempty"`

	// StorageProfile: Storage profile of a server.
	StorageProfile *StorageProfile_STATUS `json:"storageProfile,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`

	// UserVisibleState: A state of a server that is visible to user.
	UserVisibleState *ServerProperties_UserVisibleState_STATUS `json:"userVisibleState,omitempty"`

	// Version: Server version.
	Version *ServerVersion_STATUS `json:"version,omitempty"`
}

var _ genruntime.ConvertibleStatus = &Server_STATUS{}

// ConvertStatusFrom populates our Server_STATUS from the provided source
func (server *Server_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v20180601s.Server_STATUS)
	if ok {
		// Populate our instance from source
		return server.AssignProperties_From_Server_STATUS(src)
	}

	// Convert to an intermediate form
	src = &v20180601s.Server_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = server.AssignProperties_From_Server_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our Server_STATUS
func (server *Server_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v20180601s.Server_STATUS)
	if ok {
		// Populate destination from our instance
		return server.AssignProperties_To_Server_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &v20180601s.Server_STATUS{}
	err := server.AssignProperties_To_Server_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &Server_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (server *Server_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Server_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (server *Server_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Server_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Server_STATUS_ARM, got %T", armInput)
	}

	// Set property "AdministratorLogin":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AdministratorLogin != nil {
			administratorLogin := *typedInput.Properties.AdministratorLogin
			server.AdministratorLogin = &administratorLogin
		}
	}

	// no assignment for property "Conditions"

	// Set property "EarliestRestoreDate":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EarliestRestoreDate != nil {
			earliestRestoreDate := *typedInput.Properties.EarliestRestoreDate
			server.EarliestRestoreDate = &earliestRestoreDate
		}
	}

	// Set property "FullyQualifiedDomainName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FullyQualifiedDomainName != nil {
			fullyQualifiedDomainName := *typedInput.Properties.FullyQualifiedDomainName
			server.FullyQualifiedDomainName = &fullyQualifiedDomainName
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		server.Id = &id
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		server.Location = &location
	}

	// Set property "MasterServerId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MasterServerId != nil {
			masterServerId := *typedInput.Properties.MasterServerId
			server.MasterServerId = &masterServerId
		}
	}

	// Set property "MinimalTlsVersion":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinimalTlsVersion != nil {
			minimalTlsVersion := *typedInput.Properties.MinimalTlsVersion
			server.MinimalTlsVersion = &minimalTlsVersion
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		server.Name = &name
	}

	// Set property "PrivateEndpointConnections":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.PrivateEndpointConnections {
			var item1 ServerPrivateEndpointConnection_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			server.PrivateEndpointConnections = append(server.PrivateEndpointConnections, item1)
		}
	}

	// Set property "PublicNetworkAccess":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicNetworkAccess != nil {
			publicNetworkAccess := *typedInput.Properties.PublicNetworkAccess
			server.PublicNetworkAccess = &publicNetworkAccess
		}
	}

	// Set property "ReplicaCapacity":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ReplicaCapacity != nil {
			replicaCapacity := *typedInput.Properties.ReplicaCapacity
			server.ReplicaCapacity = &replicaCapacity
		}
	}

	// Set property "ReplicationRole":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ReplicationRole != nil {
			replicationRole := *typedInput.Properties.ReplicationRole
			server.ReplicationRole = &replicationRole
		}
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 Sku_STATUS
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		server.Sku = &sku
	}

	// Set property "SslEnforcement":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SslEnforcement != nil {
			sslEnforcement := *typedInput.Properties.SslEnforcement
			server.SslEnforcement = &sslEnforcement
		}
	}

	// Set property "StorageProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.StorageProfile != nil {
			var storageProfile1 StorageProfile_STATUS
			err := storageProfile1.PopulateFromARM(owner, *typedInput.Properties.StorageProfile)
			if err != nil {
				return err
			}
			storageProfile := storageProfile1
			server.StorageProfile = &storageProfile
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		server.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			server.Tags[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		server.Type = &typeVar
	}

	// Set property "UserVisibleState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.UserVisibleState != nil {
			userVisibleState := *typedInput.Properties.UserVisibleState
			server.UserVisibleState = &userVisibleState
		}
	}

	// Set property "Version":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Version != nil {
			version := *typedInput.Properties.Version
			server.Version = &version
		}
	}

	// No error
	return nil
}

// AssignProperties_From_Server_STATUS populates our Server_STATUS from the provided source Server_STATUS
func (server *Server_STATUS) AssignProperties_From_Server_STATUS(source *v20180601s.Server_STATUS) error {

	// AdministratorLogin
	server.AdministratorLogin = genruntime.ClonePointerToString(source.AdministratorLogin)

	// Conditions
	server.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// EarliestRestoreDate
	server.EarliestRestoreDate = genruntime.ClonePointerToString(source.EarliestRestoreDate)

	// FullyQualifiedDomainName
	server.FullyQualifiedDomainName = genruntime.ClonePointerToString(source.FullyQualifiedDomainName)

	// Id
	server.Id = genruntime.ClonePointerToString(source.Id)

	// Location
	server.Location = genruntime.ClonePointerToString(source.Location)

	// MasterServerId
	server.MasterServerId = genruntime.ClonePointerToString(source.MasterServerId)

	// MinimalTlsVersion
	if source.MinimalTlsVersion != nil {
		minimalTlsVersion := MinimalTlsVersion_STATUS(*source.MinimalTlsVersion)
		server.MinimalTlsVersion = &minimalTlsVersion
	} else {
		server.MinimalTlsVersion = nil
	}

	// Name
	server.Name = genruntime.ClonePointerToString(source.Name)

	// PrivateEndpointConnections
	if source.PrivateEndpointConnections != nil {
		privateEndpointConnectionList := make([]ServerPrivateEndpointConnection_STATUS, len(source.PrivateEndpointConnections))
		for privateEndpointConnectionIndex, privateEndpointConnectionItem := range source.PrivateEndpointConnections {
			// Shadow the loop variable to avoid aliasing
			privateEndpointConnectionItem := privateEndpointConnectionItem
			var privateEndpointConnection ServerPrivateEndpointConnection_STATUS
			err := privateEndpointConnection.AssignProperties_From_ServerPrivateEndpointConnection_STATUS(&privateEndpointConnectionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ServerPrivateEndpointConnection_STATUS() to populate field PrivateEndpointConnections")
			}
			privateEndpointConnectionList[privateEndpointConnectionIndex] = privateEndpointConnection
		}
		server.PrivateEndpointConnections = privateEndpointConnectionList
	} else {
		server.PrivateEndpointConnections = nil
	}

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := PublicNetworkAccess_STATUS(*source.PublicNetworkAccess)
		server.PublicNetworkAccess = &publicNetworkAccess
	} else {
		server.PublicNetworkAccess = nil
	}

	// ReplicaCapacity
	server.ReplicaCapacity = genruntime.ClonePointerToInt(source.ReplicaCapacity)

	// ReplicationRole
	server.ReplicationRole = genruntime.ClonePointerToString(source.ReplicationRole)

	// Sku
	if source.Sku != nil {
		var sku Sku_STATUS
		err := sku.AssignProperties_From_Sku_STATUS(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Sku_STATUS() to populate field Sku")
		}
		server.Sku = &sku
	} else {
		server.Sku = nil
	}

	// SslEnforcement
	if source.SslEnforcement != nil {
		sslEnforcement := SslEnforcement_STATUS(*source.SslEnforcement)
		server.SslEnforcement = &sslEnforcement
	} else {
		server.SslEnforcement = nil
	}

	// StorageProfile
	if source.StorageProfile != nil {
		var storageProfile StorageProfile_STATUS
		err := storageProfile.AssignProperties_From_StorageProfile_STATUS(source.StorageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_StorageProfile_STATUS() to populate field StorageProfile")
		}
		server.StorageProfile = &storageProfile
	} else {
		server.StorageProfile = nil
	}

	// Tags
	server.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	server.Type = genruntime.ClonePointerToString(source.Type)

	// UserVisibleState
	if source.UserVisibleState != nil {
		userVisibleState := ServerProperties_UserVisibleState_STATUS(*source.UserVisibleState)
		server.UserVisibleState = &userVisibleState
	} else {
		server.UserVisibleState = nil
	}

	// Version
	if source.Version != nil {
		version := ServerVersion_STATUS(*source.Version)
		server.Version = &version
	} else {
		server.Version = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Server_STATUS populates the provided destination Server_STATUS from our Server_STATUS
func (server *Server_STATUS) AssignProperties_To_Server_STATUS(destination *v20180601s.Server_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdministratorLogin
	destination.AdministratorLogin = genruntime.ClonePointerToString(server.AdministratorLogin)

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(server.Conditions)

	// EarliestRestoreDate
	destination.EarliestRestoreDate = genruntime.ClonePointerToString(server.EarliestRestoreDate)

	// FullyQualifiedDomainName
	destination.FullyQualifiedDomainName = genruntime.ClonePointerToString(server.FullyQualifiedDomainName)

	// Id
	destination.Id = genruntime.ClonePointerToString(server.Id)

	// Location
	destination.Location = genruntime.ClonePointerToString(server.Location)

	// MasterServerId
	destination.MasterServerId = genruntime.ClonePointerToString(server.MasterServerId)

	// MinimalTlsVersion
	if server.MinimalTlsVersion != nil {
		minimalTlsVersion := string(*server.MinimalTlsVersion)
		destination.MinimalTlsVersion = &minimalTlsVersion
	} else {
		destination.MinimalTlsVersion = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(server.Name)

	// PrivateEndpointConnections
	if server.PrivateEndpointConnections != nil {
		privateEndpointConnectionList := make([]v20180601s.ServerPrivateEndpointConnection_STATUS, len(server.PrivateEndpointConnections))
		for privateEndpointConnectionIndex, privateEndpointConnectionItem := range server.PrivateEndpointConnections {
			// Shadow the loop variable to avoid aliasing
			privateEndpointConnectionItem := privateEndpointConnectionItem
			var privateEndpointConnection v20180601s.ServerPrivateEndpointConnection_STATUS
			err := privateEndpointConnectionItem.AssignProperties_To_ServerPrivateEndpointConnection_STATUS(&privateEndpointConnection)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ServerPrivateEndpointConnection_STATUS() to populate field PrivateEndpointConnections")
			}
			privateEndpointConnectionList[privateEndpointConnectionIndex] = privateEndpointConnection
		}
		destination.PrivateEndpointConnections = privateEndpointConnectionList
	} else {
		destination.PrivateEndpointConnections = nil
	}

	// PublicNetworkAccess
	if server.PublicNetworkAccess != nil {
		publicNetworkAccess := string(*server.PublicNetworkAccess)
		destination.PublicNetworkAccess = &publicNetworkAccess
	} else {
		destination.PublicNetworkAccess = nil
	}

	// ReplicaCapacity
	destination.ReplicaCapacity = genruntime.ClonePointerToInt(server.ReplicaCapacity)

	// ReplicationRole
	destination.ReplicationRole = genruntime.ClonePointerToString(server.ReplicationRole)

	// Sku
	if server.Sku != nil {
		var sku v20180601s.Sku_STATUS
		err := server.Sku.AssignProperties_To_Sku_STATUS(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Sku_STATUS() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// SslEnforcement
	if server.SslEnforcement != nil {
		sslEnforcement := string(*server.SslEnforcement)
		destination.SslEnforcement = &sslEnforcement
	} else {
		destination.SslEnforcement = nil
	}

	// StorageProfile
	if server.StorageProfile != nil {
		var storageProfile v20180601s.StorageProfile_STATUS
		err := server.StorageProfile.AssignProperties_To_StorageProfile_STATUS(&storageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_StorageProfile_STATUS() to populate field StorageProfile")
		}
		destination.StorageProfile = &storageProfile
	} else {
		destination.StorageProfile = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(server.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(server.Type)

	// UserVisibleState
	if server.UserVisibleState != nil {
		userVisibleState := string(*server.UserVisibleState)
		destination.UserVisibleState = &userVisibleState
	} else {
		destination.UserVisibleState = nil
	}

	// Version
	if server.Version != nil {
		version := string(*server.Version)
		destination.Version = &version
	} else {
		destination.Version = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Enforce a minimal Tls version for the server.
type MinimalTlsVersion_STATUS string

const (
	MinimalTlsVersion_STATUS_TLS1_0                 = MinimalTlsVersion_STATUS("TLS1_0")
	MinimalTlsVersion_STATUS_TLS1_1                 = MinimalTlsVersion_STATUS("TLS1_1")
	MinimalTlsVersion_STATUS_TLS1_2                 = MinimalTlsVersion_STATUS("TLS1_2")
	MinimalTlsVersion_STATUS_TLSEnforcementDisabled = MinimalTlsVersion_STATUS("TLSEnforcementDisabled")
)

// Whether or not public network access is allowed for this server. Value is optional but if passed in, must be 'Enabled'
// or 'Disabled'
type PublicNetworkAccess_STATUS string

const (
	PublicNetworkAccess_STATUS_Disabled = PublicNetworkAccess_STATUS("Disabled")
	PublicNetworkAccess_STATUS_Enabled  = PublicNetworkAccess_STATUS("Enabled")
)

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type ServerOperatorSpec struct {
	// Secrets: configures where to place Azure generated secrets.
	Secrets *ServerOperatorSecrets `json:"secrets,omitempty"`
}

// AssignProperties_From_ServerOperatorSpec populates our ServerOperatorSpec from the provided source ServerOperatorSpec
func (operator *ServerOperatorSpec) AssignProperties_From_ServerOperatorSpec(source *v20180601s.ServerOperatorSpec) error {

	// Secrets
	if source.Secrets != nil {
		var secret ServerOperatorSecrets
		err := secret.AssignProperties_From_ServerOperatorSecrets(source.Secrets)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ServerOperatorSecrets() to populate field Secrets")
		}
		operator.Secrets = &secret
	} else {
		operator.Secrets = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ServerOperatorSpec populates the provided destination ServerOperatorSpec from our ServerOperatorSpec
func (operator *ServerOperatorSpec) AssignProperties_To_ServerOperatorSpec(destination *v20180601s.ServerOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Secrets
	if operator.Secrets != nil {
		var secret v20180601s.ServerOperatorSecrets
		err := operator.Secrets.AssignProperties_To_ServerOperatorSecrets(&secret)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ServerOperatorSecrets() to populate field Secrets")
		}
		destination.Secrets = &secret
	} else {
		destination.Secrets = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// A private endpoint connection under a server
type ServerPrivateEndpointConnection_STATUS struct {
	// Id: Resource Id of the private endpoint connection.
	Id *string `json:"id,omitempty"`

	// Properties: Private endpoint connection properties
	Properties *ServerPrivateEndpointConnectionProperties_STATUS `json:"properties,omitempty"`
}

var _ genruntime.FromARMConverter = &ServerPrivateEndpointConnection_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (connection *ServerPrivateEndpointConnection_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ServerPrivateEndpointConnection_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (connection *ServerPrivateEndpointConnection_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ServerPrivateEndpointConnection_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ServerPrivateEndpointConnection_STATUS_ARM, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		connection.Id = &id
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 ServerPrivateEndpointConnectionProperties_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		connection.Properties = &properties
	}

	// No error
	return nil
}

// AssignProperties_From_ServerPrivateEndpointConnection_STATUS populates our ServerPrivateEndpointConnection_STATUS from the provided source ServerPrivateEndpointConnection_STATUS
func (connection *ServerPrivateEndpointConnection_STATUS) AssignProperties_From_ServerPrivateEndpointConnection_STATUS(source *v20180601s.ServerPrivateEndpointConnection_STATUS) error {

	// Id
	connection.Id = genruntime.ClonePointerToString(source.Id)

	// Properties
	if source.Properties != nil {
		var property ServerPrivateEndpointConnectionProperties_STATUS
		err := property.AssignProperties_From_ServerPrivateEndpointConnectionProperties_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ServerPrivateEndpointConnectionProperties_STATUS() to populate field Properties")
		}
		connection.Properties = &property
	} else {
		connection.Properties = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ServerPrivateEndpointConnection_STATUS populates the provided destination ServerPrivateEndpointConnection_STATUS from our ServerPrivateEndpointConnection_STATUS
func (connection *ServerPrivateEndpointConnection_STATUS) AssignProperties_To_ServerPrivateEndpointConnection_STATUS(destination *v20180601s.ServerPrivateEndpointConnection_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(connection.Id)

	// Properties
	if connection.Properties != nil {
		var property v20180601s.ServerPrivateEndpointConnectionProperties_STATUS
		err := connection.Properties.AssignProperties_To_ServerPrivateEndpointConnectionProperties_STATUS(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ServerPrivateEndpointConnectionProperties_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ServerProperties_UserVisibleState_STATUS string

const (
	ServerProperties_UserVisibleState_STATUS_Disabled = ServerProperties_UserVisibleState_STATUS("Disabled")
	ServerProperties_UserVisibleState_STATUS_Dropping = ServerProperties_UserVisibleState_STATUS("Dropping")
	ServerProperties_UserVisibleState_STATUS_Ready    = ServerProperties_UserVisibleState_STATUS("Ready")
)

type ServerPropertiesForCreate struct {
	// Default: Mutually exclusive with all other properties
	Default *ServerPropertiesForDefaultCreate `json:"default,omitempty"`

	// GeoRestore: Mutually exclusive with all other properties
	GeoRestore *ServerPropertiesForGeoRestore `json:"geoRestore,omitempty"`

	// PointInTimeRestore: Mutually exclusive with all other properties
	PointInTimeRestore *ServerPropertiesForRestore `json:"pointInTimeRestore,omitempty"`

	// Replica: Mutually exclusive with all other properties
	Replica *ServerPropertiesForReplica `json:"replica,omitempty"`
}

var _ genruntime.ARMTransformer = &ServerPropertiesForCreate{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (create *ServerPropertiesForCreate) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if create == nil {
		return nil, nil
	}
	result := &ServerPropertiesForCreate_ARM{}

	// Set property "Default":
	if create.Default != nil {
		default_ARM, err := (*create.Default).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		def := *default_ARM.(*ServerPropertiesForDefaultCreate_ARM)
		result.Default = &def
	}

	// Set property "GeoRestore":
	if create.GeoRestore != nil {
		geoRestore_ARM, err := (*create.GeoRestore).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		geoRestore := *geoRestore_ARM.(*ServerPropertiesForGeoRestore_ARM)
		result.GeoRestore = &geoRestore
	}

	// Set property "PointInTimeRestore":
	if create.PointInTimeRestore != nil {
		pointInTimeRestore_ARM, err := (*create.PointInTimeRestore).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		pointInTimeRestore := *pointInTimeRestore_ARM.(*ServerPropertiesForRestore_ARM)
		result.PointInTimeRestore = &pointInTimeRestore
	}

	// Set property "Replica":
	if create.Replica != nil {
		replica_ARM, err := (*create.Replica).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		replica := *replica_ARM.(*ServerPropertiesForReplica_ARM)
		result.Replica = &replica
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (create *ServerPropertiesForCreate) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ServerPropertiesForCreate_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (create *ServerPropertiesForCreate) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ServerPropertiesForCreate_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ServerPropertiesForCreate_ARM, got %T", armInput)
	}

	// Set property "Default":
	if typedInput.Default != nil {
		var default1 ServerPropertiesForDefaultCreate
		err := default1.PopulateFromARM(owner, *typedInput.Default)
		if err != nil {
			return err
		}
		def := default1
		create.Default = &def
	}

	// Set property "GeoRestore":
	if typedInput.GeoRestore != nil {
		var geoRestore1 ServerPropertiesForGeoRestore
		err := geoRestore1.PopulateFromARM(owner, *typedInput.GeoRestore)
		if err != nil {
			return err
		}
		geoRestore := geoRestore1
		create.GeoRestore = &geoRestore
	}

	// Set property "PointInTimeRestore":
	if typedInput.PointInTimeRestore != nil {
		var pointInTimeRestore1 ServerPropertiesForRestore
		err := pointInTimeRestore1.PopulateFromARM(owner, *typedInput.PointInTimeRestore)
		if err != nil {
			return err
		}
		pointInTimeRestore := pointInTimeRestore1
		create.PointInTimeRestore = &pointInTimeRestore
	}

	// Set property "Replica":
	if typedInput.Replica != nil {
		var replica1 ServerPropertiesForReplica
		err := replica1.PopulateFromARM(owner, *typedInput.Replica)
		if err != nil {
			return err
		}
		replica := replica1
		create.Replica = &replica
	}

	// No error
	return nil
}

// AssignProperties_From_ServerPropertiesForCreate populates our ServerPropertiesForCreate from the provided source ServerPropertiesForCreate
func (create *ServerPropertiesForCreate) AssignProperties_From_ServerPropertiesForCreate(source *v20180601s.ServerPropertiesForCreate) error {

	// Default
	if source.Default != nil {
		var def ServerPropertiesForDefaultCreate
		err := def.AssignProperties_From_ServerPropertiesForDefaultCreate(source.Default)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ServerPropertiesForDefaultCreate() to populate field Default")
		}
		create.Default = &def
	} else {
		create.Default = nil
	}

	// GeoRestore
	if source.GeoRestore != nil {
		var geoRestore ServerPropertiesForGeoRestore
		err := geoRestore.AssignProperties_From_ServerPropertiesForGeoRestore(source.GeoRestore)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ServerPropertiesForGeoRestore() to populate field GeoRestore")
		}
		create.GeoRestore = &geoRestore
	} else {
		create.GeoRestore = nil
	}

	// PointInTimeRestore
	if source.PointInTimeRestore != nil {
		var pointInTimeRestore ServerPropertiesForRestore
		err := pointInTimeRestore.AssignProperties_From_ServerPropertiesForRestore(source.PointInTimeRestore)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ServerPropertiesForRestore() to populate field PointInTimeRestore")
		}
		create.PointInTimeRestore = &pointInTimeRestore
	} else {
		create.PointInTimeRestore = nil
	}

	// Replica
	if source.Replica != nil {
		var replica ServerPropertiesForReplica
		err := replica.AssignProperties_From_ServerPropertiesForReplica(source.Replica)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ServerPropertiesForReplica() to populate field Replica")
		}
		create.Replica = &replica
	} else {
		create.Replica = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ServerPropertiesForCreate populates the provided destination ServerPropertiesForCreate from our ServerPropertiesForCreate
func (create *ServerPropertiesForCreate) AssignProperties_To_ServerPropertiesForCreate(destination *v20180601s.ServerPropertiesForCreate) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Default
	if create.Default != nil {
		var def v20180601s.ServerPropertiesForDefaultCreate
		err := create.Default.AssignProperties_To_ServerPropertiesForDefaultCreate(&def)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ServerPropertiesForDefaultCreate() to populate field Default")
		}
		destination.Default = &def
	} else {
		destination.Default = nil
	}

	// GeoRestore
	if create.GeoRestore != nil {
		var geoRestore v20180601s.ServerPropertiesForGeoRestore
		err := create.GeoRestore.AssignProperties_To_ServerPropertiesForGeoRestore(&geoRestore)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ServerPropertiesForGeoRestore() to populate field GeoRestore")
		}
		destination.GeoRestore = &geoRestore
	} else {
		destination.GeoRestore = nil
	}

	// PointInTimeRestore
	if create.PointInTimeRestore != nil {
		var pointInTimeRestore v20180601s.ServerPropertiesForRestore
		err := create.PointInTimeRestore.AssignProperties_To_ServerPropertiesForRestore(&pointInTimeRestore)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ServerPropertiesForRestore() to populate field PointInTimeRestore")
		}
		destination.PointInTimeRestore = &pointInTimeRestore
	} else {
		destination.PointInTimeRestore = nil
	}

	// Replica
	if create.Replica != nil {
		var replica v20180601s.ServerPropertiesForReplica
		err := create.Replica.AssignProperties_To_ServerPropertiesForReplica(&replica)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ServerPropertiesForReplica() to populate field Replica")
		}
		destination.Replica = &replica
	} else {
		destination.Replica = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The version of a server.
type ServerVersion_STATUS string

const (
	ServerVersion_STATUS_102 = ServerVersion_STATUS("10.2")
	ServerVersion_STATUS_103 = ServerVersion_STATUS("10.3")
)

// Billing information related properties of a server.
type Sku struct {
	// +kubebuilder:validation:Minimum=0
	// Capacity: The scale up/out capacity, representing server's compute units.
	Capacity *int `json:"capacity,omitempty"`

	// Family: The family of hardware.
	Family *string `json:"family,omitempty"`

	// +kubebuilder:validation:Required
	// Name: The name of the sku, typically, tier + family + cores, e.g. B_Gen4_1, GP_Gen5_8.
	Name *string `json:"name,omitempty"`

	// Size: The size code, to be interpreted by resource as appropriate.
	Size *string `json:"size,omitempty"`

	// Tier: The tier of the particular SKU, e.g. Basic.
	Tier *Sku_Tier `json:"tier,omitempty"`
}

var _ genruntime.ARMTransformer = &Sku{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (sku *Sku) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if sku == nil {
		return nil, nil
	}
	result := &Sku_ARM{}

	// Set property "Capacity":
	if sku.Capacity != nil {
		capacity := *sku.Capacity
		result.Capacity = &capacity
	}

	// Set property "Family":
	if sku.Family != nil {
		family := *sku.Family
		result.Family = &family
	}

	// Set property "Name":
	if sku.Name != nil {
		name := *sku.Name
		result.Name = &name
	}

	// Set property "Size":
	if sku.Size != nil {
		size := *sku.Size
		result.Size = &size
	}

	// Set property "Tier":
	if sku.Tier != nil {
		tier := *sku.Tier
		result.Tier = &tier
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sku *Sku) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Sku_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sku *Sku) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Sku_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Sku_ARM, got %T", armInput)
	}

	// Set property "Capacity":
	if typedInput.Capacity != nil {
		capacity := *typedInput.Capacity
		sku.Capacity = &capacity
	}

	// Set property "Family":
	if typedInput.Family != nil {
		family := *typedInput.Family
		sku.Family = &family
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		sku.Name = &name
	}

	// Set property "Size":
	if typedInput.Size != nil {
		size := *typedInput.Size
		sku.Size = &size
	}

	// Set property "Tier":
	if typedInput.Tier != nil {
		tier := *typedInput.Tier
		sku.Tier = &tier
	}

	// No error
	return nil
}

// AssignProperties_From_Sku populates our Sku from the provided source Sku
func (sku *Sku) AssignProperties_From_Sku(source *v20180601s.Sku) error {

	// Capacity
	if source.Capacity != nil {
		capacity := *source.Capacity
		sku.Capacity = &capacity
	} else {
		sku.Capacity = nil
	}

	// Family
	sku.Family = genruntime.ClonePointerToString(source.Family)

	// Name
	sku.Name = genruntime.ClonePointerToString(source.Name)

	// Size
	sku.Size = genruntime.ClonePointerToString(source.Size)

	// Tier
	if source.Tier != nil {
		tier := Sku_Tier(*source.Tier)
		sku.Tier = &tier
	} else {
		sku.Tier = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Sku populates the provided destination Sku from our Sku
func (sku *Sku) AssignProperties_To_Sku(destination *v20180601s.Sku) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Capacity
	if sku.Capacity != nil {
		capacity := *sku.Capacity
		destination.Capacity = &capacity
	} else {
		destination.Capacity = nil
	}

	// Family
	destination.Family = genruntime.ClonePointerToString(sku.Family)

	// Name
	destination.Name = genruntime.ClonePointerToString(sku.Name)

	// Size
	destination.Size = genruntime.ClonePointerToString(sku.Size)

	// Tier
	if sku.Tier != nil {
		tier := string(*sku.Tier)
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Sku_STATUS populates our Sku from the provided source Sku_STATUS
func (sku *Sku) Initialize_From_Sku_STATUS(source *Sku_STATUS) error {

	// Capacity
	if source.Capacity != nil {
		capacity := *source.Capacity
		sku.Capacity = &capacity
	} else {
		sku.Capacity = nil
	}

	// Family
	sku.Family = genruntime.ClonePointerToString(source.Family)

	// Name
	sku.Name = genruntime.ClonePointerToString(source.Name)

	// Size
	sku.Size = genruntime.ClonePointerToString(source.Size)

	// Tier
	if source.Tier != nil {
		tier := Sku_Tier(*source.Tier)
		sku.Tier = &tier
	} else {
		sku.Tier = nil
	}

	// No error
	return nil
}

// Billing information related properties of a server.
type Sku_STATUS struct {
	// Capacity: The scale up/out capacity, representing server's compute units.
	Capacity *int `json:"capacity,omitempty"`

	// Family: The family of hardware.
	Family *string `json:"family,omitempty"`

	// Name: The name of the sku, typically, tier + family + cores, e.g. B_Gen4_1, GP_Gen5_8.
	Name *string `json:"name,omitempty"`

	// Size: The size code, to be interpreted by resource as appropriate.
	Size *string `json:"size,omitempty"`

	// Tier: The tier of the particular SKU, e.g. Basic.
	Tier *Sku_Tier_STATUS `json:"tier,omitempty"`
}

var _ genruntime.FromARMConverter = &Sku_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sku *Sku_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Sku_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sku *Sku_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Sku_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Sku_STATUS_ARM, got %T", armInput)
	}

	// Set property "Capacity":
	if typedInput.Capacity != nil {
		capacity := *typedInput.Capacity
		sku.Capacity = &capacity
	}

	// Set property "Family":
	if typedInput.Family != nil {
		family := *typedInput.Family
		sku.Family = &family
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		sku.Name = &name
	}

	// Set property "Size":
	if typedInput.Size != nil {
		size := *typedInput.Size
		sku.Size = &size
	}

	// Set property "Tier":
	if typedInput.Tier != nil {
		tier := *typedInput.Tier
		sku.Tier = &tier
	}

	// No error
	return nil
}

// AssignProperties_From_Sku_STATUS populates our Sku_STATUS from the provided source Sku_STATUS
func (sku *Sku_STATUS) AssignProperties_From_Sku_STATUS(source *v20180601s.Sku_STATUS) error {

	// Capacity
	sku.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Family
	sku.Family = genruntime.ClonePointerToString(source.Family)

	// Name
	sku.Name = genruntime.ClonePointerToString(source.Name)

	// Size
	sku.Size = genruntime.ClonePointerToString(source.Size)

	// Tier
	if source.Tier != nil {
		tier := Sku_Tier_STATUS(*source.Tier)
		sku.Tier = &tier
	} else {
		sku.Tier = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Sku_STATUS populates the provided destination Sku_STATUS from our Sku_STATUS
func (sku *Sku_STATUS) AssignProperties_To_Sku_STATUS(destination *v20180601s.Sku_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Capacity
	destination.Capacity = genruntime.ClonePointerToInt(sku.Capacity)

	// Family
	destination.Family = genruntime.ClonePointerToString(sku.Family)

	// Name
	destination.Name = genruntime.ClonePointerToString(sku.Name)

	// Size
	destination.Size = genruntime.ClonePointerToString(sku.Size)

	// Tier
	if sku.Tier != nil {
		tier := string(*sku.Tier)
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Enable ssl enforcement or not when connect to server.
type SslEnforcement_STATUS string

const (
	SslEnforcement_STATUS_Disabled = SslEnforcement_STATUS("Disabled")
	SslEnforcement_STATUS_Enabled  = SslEnforcement_STATUS("Enabled")
)

// Storage Profile properties of a server
type StorageProfile_STATUS struct {
	// BackupRetentionDays: Backup retention days for the server.
	BackupRetentionDays *int `json:"backupRetentionDays,omitempty"`

	// GeoRedundantBackup: Enable Geo-redundant or not for server backup.
	GeoRedundantBackup *StorageProfile_GeoRedundantBackup_STATUS `json:"geoRedundantBackup,omitempty"`

	// StorageAutogrow: Enable Storage Auto Grow.
	StorageAutogrow *StorageProfile_StorageAutogrow_STATUS `json:"storageAutogrow,omitempty"`

	// StorageMB: Max storage allowed for a server.
	StorageMB *int `json:"storageMB,omitempty"`
}

var _ genruntime.FromARMConverter = &StorageProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *StorageProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &StorageProfile_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *StorageProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(StorageProfile_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected StorageProfile_STATUS_ARM, got %T", armInput)
	}

	// Set property "BackupRetentionDays":
	if typedInput.BackupRetentionDays != nil {
		backupRetentionDays := *typedInput.BackupRetentionDays
		profile.BackupRetentionDays = &backupRetentionDays
	}

	// Set property "GeoRedundantBackup":
	if typedInput.GeoRedundantBackup != nil {
		geoRedundantBackup := *typedInput.GeoRedundantBackup
		profile.GeoRedundantBackup = &geoRedundantBackup
	}

	// Set property "StorageAutogrow":
	if typedInput.StorageAutogrow != nil {
		storageAutogrow := *typedInput.StorageAutogrow
		profile.StorageAutogrow = &storageAutogrow
	}

	// Set property "StorageMB":
	if typedInput.StorageMB != nil {
		storageMB := *typedInput.StorageMB
		profile.StorageMB = &storageMB
	}

	// No error
	return nil
}

// AssignProperties_From_StorageProfile_STATUS populates our StorageProfile_STATUS from the provided source StorageProfile_STATUS
func (profile *StorageProfile_STATUS) AssignProperties_From_StorageProfile_STATUS(source *v20180601s.StorageProfile_STATUS) error {

	// BackupRetentionDays
	profile.BackupRetentionDays = genruntime.ClonePointerToInt(source.BackupRetentionDays)

	// GeoRedundantBackup
	if source.GeoRedundantBackup != nil {
		geoRedundantBackup := StorageProfile_GeoRedundantBackup_STATUS(*source.GeoRedundantBackup)
		profile.GeoRedundantBackup = &geoRedundantBackup
	} else {
		profile.GeoRedundantBackup = nil
	}

	// StorageAutogrow
	if source.StorageAutogrow != nil {
		storageAutogrow := StorageProfile_StorageAutogrow_STATUS(*source.StorageAutogrow)
		profile.StorageAutogrow = &storageAutogrow
	} else {
		profile.StorageAutogrow = nil
	}

	// StorageMB
	profile.StorageMB = genruntime.ClonePointerToInt(source.StorageMB)

	// No error
	return nil
}

// AssignProperties_To_StorageProfile_STATUS populates the provided destination StorageProfile_STATUS from our StorageProfile_STATUS
func (profile *StorageProfile_STATUS) AssignProperties_To_StorageProfile_STATUS(destination *v20180601s.StorageProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackupRetentionDays
	destination.BackupRetentionDays = genruntime.ClonePointerToInt(profile.BackupRetentionDays)

	// GeoRedundantBackup
	if profile.GeoRedundantBackup != nil {
		geoRedundantBackup := string(*profile.GeoRedundantBackup)
		destination.GeoRedundantBackup = &geoRedundantBackup
	} else {
		destination.GeoRedundantBackup = nil
	}

	// StorageAutogrow
	if profile.StorageAutogrow != nil {
		storageAutogrow := string(*profile.StorageAutogrow)
		destination.StorageAutogrow = &storageAutogrow
	} else {
		destination.StorageAutogrow = nil
	}

	// StorageMB
	destination.StorageMB = genruntime.ClonePointerToInt(profile.StorageMB)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ServerOperatorSecrets struct {
	// FullyQualifiedDomainName: indicates where the FullyQualifiedDomainName secret should be placed. If omitted, the secret
	// will not be retrieved from Azure.
	FullyQualifiedDomainName *genruntime.SecretDestination `json:"fullyQualifiedDomainName,omitempty"`
}

// AssignProperties_From_ServerOperatorSecrets populates our ServerOperatorSecrets from the provided source ServerOperatorSecrets
func (secrets *ServerOperatorSecrets) AssignProperties_From_ServerOperatorSecrets(source *v20180601s.ServerOperatorSecrets) error {

	// FullyQualifiedDomainName
	if source.FullyQualifiedDomainName != nil {
		fullyQualifiedDomainName := source.FullyQualifiedDomainName.Copy()
		secrets.FullyQualifiedDomainName = &fullyQualifiedDomainName
	} else {
		secrets.FullyQualifiedDomainName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ServerOperatorSecrets populates the provided destination ServerOperatorSecrets from our ServerOperatorSecrets
func (secrets *ServerOperatorSecrets) AssignProperties_To_ServerOperatorSecrets(destination *v20180601s.ServerOperatorSecrets) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// FullyQualifiedDomainName
	if secrets.FullyQualifiedDomainName != nil {
		fullyQualifiedDomainName := secrets.FullyQualifiedDomainName.Copy()
		destination.FullyQualifiedDomainName = &fullyQualifiedDomainName
	} else {
		destination.FullyQualifiedDomainName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Properties of a private endpoint connection.
type ServerPrivateEndpointConnectionProperties_STATUS struct {
	// PrivateEndpoint: Private endpoint which the connection belongs to.
	PrivateEndpoint *PrivateEndpointProperty_STATUS `json:"privateEndpoint,omitempty"`

	// PrivateLinkServiceConnectionState: Connection state of the private endpoint connection.
	PrivateLinkServiceConnectionState *ServerPrivateLinkServiceConnectionStateProperty_STATUS `json:"privateLinkServiceConnectionState,omitempty"`

	// ProvisioningState: State of the private endpoint connection.
	ProvisioningState *ServerPrivateEndpointConnectionProperties_ProvisioningState_STATUS `json:"provisioningState,omitempty"`
}

var _ genruntime.FromARMConverter = &ServerPrivateEndpointConnectionProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *ServerPrivateEndpointConnectionProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ServerPrivateEndpointConnectionProperties_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *ServerPrivateEndpointConnectionProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ServerPrivateEndpointConnectionProperties_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ServerPrivateEndpointConnectionProperties_STATUS_ARM, got %T", armInput)
	}

	// Set property "PrivateEndpoint":
	if typedInput.PrivateEndpoint != nil {
		var privateEndpoint1 PrivateEndpointProperty_STATUS
		err := privateEndpoint1.PopulateFromARM(owner, *typedInput.PrivateEndpoint)
		if err != nil {
			return err
		}
		privateEndpoint := privateEndpoint1
		properties.PrivateEndpoint = &privateEndpoint
	}

	// Set property "PrivateLinkServiceConnectionState":
	if typedInput.PrivateLinkServiceConnectionState != nil {
		var privateLinkServiceConnectionState1 ServerPrivateLinkServiceConnectionStateProperty_STATUS
		err := privateLinkServiceConnectionState1.PopulateFromARM(owner, *typedInput.PrivateLinkServiceConnectionState)
		if err != nil {
			return err
		}
		privateLinkServiceConnectionState := privateLinkServiceConnectionState1
		properties.PrivateLinkServiceConnectionState = &privateLinkServiceConnectionState
	}

	// Set property "ProvisioningState":
	if typedInput.ProvisioningState != nil {
		provisioningState := *typedInput.ProvisioningState
		properties.ProvisioningState = &provisioningState
	}

	// No error
	return nil
}

// AssignProperties_From_ServerPrivateEndpointConnectionProperties_STATUS populates our ServerPrivateEndpointConnectionProperties_STATUS from the provided source ServerPrivateEndpointConnectionProperties_STATUS
func (properties *ServerPrivateEndpointConnectionProperties_STATUS) AssignProperties_From_ServerPrivateEndpointConnectionProperties_STATUS(source *v20180601s.ServerPrivateEndpointConnectionProperties_STATUS) error {

	// PrivateEndpoint
	if source.PrivateEndpoint != nil {
		var privateEndpoint PrivateEndpointProperty_STATUS
		err := privateEndpoint.AssignProperties_From_PrivateEndpointProperty_STATUS(source.PrivateEndpoint)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PrivateEndpointProperty_STATUS() to populate field PrivateEndpoint")
		}
		properties.PrivateEndpoint = &privateEndpoint
	} else {
		properties.PrivateEndpoint = nil
	}

	// PrivateLinkServiceConnectionState
	if source.PrivateLinkServiceConnectionState != nil {
		var privateLinkServiceConnectionState ServerPrivateLinkServiceConnectionStateProperty_STATUS
		err := privateLinkServiceConnectionState.AssignProperties_From_ServerPrivateLinkServiceConnectionStateProperty_STATUS(source.PrivateLinkServiceConnectionState)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ServerPrivateLinkServiceConnectionStateProperty_STATUS() to populate field PrivateLinkServiceConnectionState")
		}
		properties.PrivateLinkServiceConnectionState = &privateLinkServiceConnectionState
	} else {
		properties.PrivateLinkServiceConnectionState = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ServerPrivateEndpointConnectionProperties_ProvisioningState_STATUS(*source.ProvisioningState)
		properties.ProvisioningState = &provisioningState
	} else {
		properties.ProvisioningState = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ServerPrivateEndpointConnectionProperties_STATUS populates the provided destination ServerPrivateEndpointConnectionProperties_STATUS from our ServerPrivateEndpointConnectionProperties_STATUS
func (properties *ServerPrivateEndpointConnectionProperties_STATUS) AssignProperties_To_ServerPrivateEndpointConnectionProperties_STATUS(destination *v20180601s.ServerPrivateEndpointConnectionProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrivateEndpoint
	if properties.PrivateEndpoint != nil {
		var privateEndpoint v20180601s.PrivateEndpointProperty_STATUS
		err := properties.PrivateEndpoint.AssignProperties_To_PrivateEndpointProperty_STATUS(&privateEndpoint)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PrivateEndpointProperty_STATUS() to populate field PrivateEndpoint")
		}
		destination.PrivateEndpoint = &privateEndpoint
	} else {
		destination.PrivateEndpoint = nil
	}

	// PrivateLinkServiceConnectionState
	if properties.PrivateLinkServiceConnectionState != nil {
		var privateLinkServiceConnectionState v20180601s.ServerPrivateLinkServiceConnectionStateProperty_STATUS
		err := properties.PrivateLinkServiceConnectionState.AssignProperties_To_ServerPrivateLinkServiceConnectionStateProperty_STATUS(&privateLinkServiceConnectionState)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ServerPrivateLinkServiceConnectionStateProperty_STATUS() to populate field PrivateLinkServiceConnectionState")
		}
		destination.PrivateLinkServiceConnectionState = &privateLinkServiceConnectionState
	} else {
		destination.PrivateLinkServiceConnectionState = nil
	}

	// ProvisioningState
	if properties.ProvisioningState != nil {
		provisioningState := string(*properties.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ServerPropertiesForDefaultCreate struct {
	// +kubebuilder:validation:Required
	// AdministratorLogin: The administrator's login name of a server. Can only be specified when the server is being created
	// (and is required for creation).
	AdministratorLogin *string `json:"administratorLogin,omitempty"`

	// +kubebuilder:validation:Required
	// AdministratorLoginPassword: The password of the administrator login.
	AdministratorLoginPassword *genruntime.SecretReference `json:"administratorLoginPassword,omitempty"`

	// +kubebuilder:validation:Required
	// CreateMode: The mode to create a new server.
	CreateMode *ServerPropertiesForDefaultCreate_CreateMode `json:"createMode,omitempty"`

	// MinimalTlsVersion: Enforce a minimal Tls version for the server.
	MinimalTlsVersion *MinimalTlsVersion `json:"minimalTlsVersion,omitempty"`

	// PublicNetworkAccess: Whether or not public network access is allowed for this server. Value is optional but if passed
	// in, must be 'Enabled' or 'Disabled'
	PublicNetworkAccess *PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// SslEnforcement: Enable ssl enforcement or not when connect to server.
	SslEnforcement *SslEnforcement `json:"sslEnforcement,omitempty"`

	// StorageProfile: Storage profile of a server.
	StorageProfile *StorageProfile `json:"storageProfile,omitempty"`

	// Version: Server version.
	Version *ServerVersion `json:"version,omitempty"`
}

var _ genruntime.ARMTransformer = &ServerPropertiesForDefaultCreate{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (create *ServerPropertiesForDefaultCreate) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if create == nil {
		return nil, nil
	}
	result := &ServerPropertiesForDefaultCreate_ARM{}

	// Set property "AdministratorLogin":
	if create.AdministratorLogin != nil {
		administratorLogin := *create.AdministratorLogin
		result.AdministratorLogin = &administratorLogin
	}

	// Set property "AdministratorLoginPassword":
	if create.AdministratorLoginPassword != nil {
		administratorLoginPasswordSecret, err := resolved.ResolvedSecrets.Lookup(*create.AdministratorLoginPassword)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property AdministratorLoginPassword")
		}
		administratorLoginPassword := administratorLoginPasswordSecret
		result.AdministratorLoginPassword = &administratorLoginPassword
	}

	// Set property "CreateMode":
	if create.CreateMode != nil {
		result.CreateMode = *create.CreateMode
	}

	// Set property "MinimalTlsVersion":
	if create.MinimalTlsVersion != nil {
		minimalTlsVersion := *create.MinimalTlsVersion
		result.MinimalTlsVersion = &minimalTlsVersion
	}

	// Set property "PublicNetworkAccess":
	if create.PublicNetworkAccess != nil {
		publicNetworkAccess := *create.PublicNetworkAccess
		result.PublicNetworkAccess = &publicNetworkAccess
	}

	// Set property "SslEnforcement":
	if create.SslEnforcement != nil {
		sslEnforcement := *create.SslEnforcement
		result.SslEnforcement = &sslEnforcement
	}

	// Set property "StorageProfile":
	if create.StorageProfile != nil {
		storageProfile_ARM, err := (*create.StorageProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		storageProfile := *storageProfile_ARM.(*StorageProfile_ARM)
		result.StorageProfile = &storageProfile
	}

	// Set property "Version":
	if create.Version != nil {
		version := *create.Version
		result.Version = &version
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (create *ServerPropertiesForDefaultCreate) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ServerPropertiesForDefaultCreate_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (create *ServerPropertiesForDefaultCreate) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ServerPropertiesForDefaultCreate_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ServerPropertiesForDefaultCreate_ARM, got %T", armInput)
	}

	// Set property "AdministratorLogin":
	if typedInput.AdministratorLogin != nil {
		administratorLogin := *typedInput.AdministratorLogin
		create.AdministratorLogin = &administratorLogin
	}

	// no assignment for property "AdministratorLoginPassword"

	// Set property "CreateMode":
	create.CreateMode = &typedInput.CreateMode

	// Set property "MinimalTlsVersion":
	if typedInput.MinimalTlsVersion != nil {
		minimalTlsVersion := *typedInput.MinimalTlsVersion
		create.MinimalTlsVersion = &minimalTlsVersion
	}

	// Set property "PublicNetworkAccess":
	if typedInput.PublicNetworkAccess != nil {
		publicNetworkAccess := *typedInput.PublicNetworkAccess
		create.PublicNetworkAccess = &publicNetworkAccess
	}

	// Set property "SslEnforcement":
	if typedInput.SslEnforcement != nil {
		sslEnforcement := *typedInput.SslEnforcement
		create.SslEnforcement = &sslEnforcement
	}

	// Set property "StorageProfile":
	if typedInput.StorageProfile != nil {
		var storageProfile1 StorageProfile
		err := storageProfile1.PopulateFromARM(owner, *typedInput.StorageProfile)
		if err != nil {
			return err
		}
		storageProfile := storageProfile1
		create.StorageProfile = &storageProfile
	}

	// Set property "Version":
	if typedInput.Version != nil {
		version := *typedInput.Version
		create.Version = &version
	}

	// No error
	return nil
}

// AssignProperties_From_ServerPropertiesForDefaultCreate populates our ServerPropertiesForDefaultCreate from the provided source ServerPropertiesForDefaultCreate
func (create *ServerPropertiesForDefaultCreate) AssignProperties_From_ServerPropertiesForDefaultCreate(source *v20180601s.ServerPropertiesForDefaultCreate) error {

	// AdministratorLogin
	create.AdministratorLogin = genruntime.ClonePointerToString(source.AdministratorLogin)

	// AdministratorLoginPassword
	if source.AdministratorLoginPassword != nil {
		administratorLoginPassword := source.AdministratorLoginPassword.Copy()
		create.AdministratorLoginPassword = &administratorLoginPassword
	} else {
		create.AdministratorLoginPassword = nil
	}

	// CreateMode
	if source.CreateMode != nil {
		createMode := ServerPropertiesForDefaultCreate_CreateMode(*source.CreateMode)
		create.CreateMode = &createMode
	} else {
		create.CreateMode = nil
	}

	// MinimalTlsVersion
	if source.MinimalTlsVersion != nil {
		minimalTlsVersion := MinimalTlsVersion(*source.MinimalTlsVersion)
		create.MinimalTlsVersion = &minimalTlsVersion
	} else {
		create.MinimalTlsVersion = nil
	}

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := PublicNetworkAccess(*source.PublicNetworkAccess)
		create.PublicNetworkAccess = &publicNetworkAccess
	} else {
		create.PublicNetworkAccess = nil
	}

	// SslEnforcement
	if source.SslEnforcement != nil {
		sslEnforcement := SslEnforcement(*source.SslEnforcement)
		create.SslEnforcement = &sslEnforcement
	} else {
		create.SslEnforcement = nil
	}

	// StorageProfile
	if source.StorageProfile != nil {
		var storageProfile StorageProfile
		err := storageProfile.AssignProperties_From_StorageProfile(source.StorageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_StorageProfile() to populate field StorageProfile")
		}
		create.StorageProfile = &storageProfile
	} else {
		create.StorageProfile = nil
	}

	// Version
	if source.Version != nil {
		version := ServerVersion(*source.Version)
		create.Version = &version
	} else {
		create.Version = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ServerPropertiesForDefaultCreate populates the provided destination ServerPropertiesForDefaultCreate from our ServerPropertiesForDefaultCreate
func (create *ServerPropertiesForDefaultCreate) AssignProperties_To_ServerPropertiesForDefaultCreate(destination *v20180601s.ServerPropertiesForDefaultCreate) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdministratorLogin
	destination.AdministratorLogin = genruntime.ClonePointerToString(create.AdministratorLogin)

	// AdministratorLoginPassword
	if create.AdministratorLoginPassword != nil {
		administratorLoginPassword := create.AdministratorLoginPassword.Copy()
		destination.AdministratorLoginPassword = &administratorLoginPassword
	} else {
		destination.AdministratorLoginPassword = nil
	}

	// CreateMode
	if create.CreateMode != nil {
		createMode := string(*create.CreateMode)
		destination.CreateMode = &createMode
	} else {
		destination.CreateMode = nil
	}

	// MinimalTlsVersion
	if create.MinimalTlsVersion != nil {
		minimalTlsVersion := string(*create.MinimalTlsVersion)
		destination.MinimalTlsVersion = &minimalTlsVersion
	} else {
		destination.MinimalTlsVersion = nil
	}

	// PublicNetworkAccess
	if create.PublicNetworkAccess != nil {
		publicNetworkAccess := string(*create.PublicNetworkAccess)
		destination.PublicNetworkAccess = &publicNetworkAccess
	} else {
		destination.PublicNetworkAccess = nil
	}

	// SslEnforcement
	if create.SslEnforcement != nil {
		sslEnforcement := string(*create.SslEnforcement)
		destination.SslEnforcement = &sslEnforcement
	} else {
		destination.SslEnforcement = nil
	}

	// StorageProfile
	if create.StorageProfile != nil {
		var storageProfile v20180601s.StorageProfile
		err := create.StorageProfile.AssignProperties_To_StorageProfile(&storageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_StorageProfile() to populate field StorageProfile")
		}
		destination.StorageProfile = &storageProfile
	} else {
		destination.StorageProfile = nil
	}

	// Version
	if create.Version != nil {
		version := string(*create.Version)
		destination.Version = &version
	} else {
		destination.Version = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ServerPropertiesForGeoRestore struct {
	// +kubebuilder:validation:Required
	// CreateMode: The mode to create a new server.
	CreateMode *ServerPropertiesForGeoRestore_CreateMode `json:"createMode,omitempty"`

	// MinimalTlsVersion: Enforce a minimal Tls version for the server.
	MinimalTlsVersion *MinimalTlsVersion `json:"minimalTlsVersion,omitempty"`

	// PublicNetworkAccess: Whether or not public network access is allowed for this server. Value is optional but if passed
	// in, must be 'Enabled' or 'Disabled'
	PublicNetworkAccess *PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// +kubebuilder:validation:Required
	// SourceServerId: The source server id to restore from.
	SourceServerId *string `json:"sourceServerId,omitempty"`

	// SslEnforcement: Enable ssl enforcement or not when connect to server.
	SslEnforcement *SslEnforcement `json:"sslEnforcement,omitempty"`

	// StorageProfile: Storage profile of a server.
	StorageProfile *StorageProfile `json:"storageProfile,omitempty"`

	// Version: Server version.
	Version *ServerVersion `json:"version,omitempty"`
}

var _ genruntime.ARMTransformer = &ServerPropertiesForGeoRestore{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (restore *ServerPropertiesForGeoRestore) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if restore == nil {
		return nil, nil
	}
	result := &ServerPropertiesForGeoRestore_ARM{}

	// Set property "CreateMode":
	if restore.CreateMode != nil {
		result.CreateMode = *restore.CreateMode
	}

	// Set property "MinimalTlsVersion":
	if restore.MinimalTlsVersion != nil {
		minimalTlsVersion := *restore.MinimalTlsVersion
		result.MinimalTlsVersion = &minimalTlsVersion
	}

	// Set property "PublicNetworkAccess":
	if restore.PublicNetworkAccess != nil {
		publicNetworkAccess := *restore.PublicNetworkAccess
		result.PublicNetworkAccess = &publicNetworkAccess
	}

	// Set property "SourceServerId":
	if restore.SourceServerId != nil {
		sourceServerId := *restore.SourceServerId
		result.SourceServerId = &sourceServerId
	}

	// Set property "SslEnforcement":
	if restore.SslEnforcement != nil {
		sslEnforcement := *restore.SslEnforcement
		result.SslEnforcement = &sslEnforcement
	}

	// Set property "StorageProfile":
	if restore.StorageProfile != nil {
		storageProfile_ARM, err := (*restore.StorageProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		storageProfile := *storageProfile_ARM.(*StorageProfile_ARM)
		result.StorageProfile = &storageProfile
	}

	// Set property "Version":
	if restore.Version != nil {
		version := *restore.Version
		result.Version = &version
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (restore *ServerPropertiesForGeoRestore) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ServerPropertiesForGeoRestore_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (restore *ServerPropertiesForGeoRestore) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ServerPropertiesForGeoRestore_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ServerPropertiesForGeoRestore_ARM, got %T", armInput)
	}

	// Set property "CreateMode":
	restore.CreateMode = &typedInput.CreateMode

	// Set property "MinimalTlsVersion":
	if typedInput.MinimalTlsVersion != nil {
		minimalTlsVersion := *typedInput.MinimalTlsVersion
		restore.MinimalTlsVersion = &minimalTlsVersion
	}

	// Set property "PublicNetworkAccess":
	if typedInput.PublicNetworkAccess != nil {
		publicNetworkAccess := *typedInput.PublicNetworkAccess
		restore.PublicNetworkAccess = &publicNetworkAccess
	}

	// Set property "SourceServerId":
	if typedInput.SourceServerId != nil {
		sourceServerId := *typedInput.SourceServerId
		restore.SourceServerId = &sourceServerId
	}

	// Set property "SslEnforcement":
	if typedInput.SslEnforcement != nil {
		sslEnforcement := *typedInput.SslEnforcement
		restore.SslEnforcement = &sslEnforcement
	}

	// Set property "StorageProfile":
	if typedInput.StorageProfile != nil {
		var storageProfile1 StorageProfile
		err := storageProfile1.PopulateFromARM(owner, *typedInput.StorageProfile)
		if err != nil {
			return err
		}
		storageProfile := storageProfile1
		restore.StorageProfile = &storageProfile
	}

	// Set property "Version":
	if typedInput.Version != nil {
		version := *typedInput.Version
		restore.Version = &version
	}

	// No error
	return nil
}

// AssignProperties_From_ServerPropertiesForGeoRestore populates our ServerPropertiesForGeoRestore from the provided source ServerPropertiesForGeoRestore
func (restore *ServerPropertiesForGeoRestore) AssignProperties_From_ServerPropertiesForGeoRestore(source *v20180601s.ServerPropertiesForGeoRestore) error {

	// CreateMode
	if source.CreateMode != nil {
		createMode := ServerPropertiesForGeoRestore_CreateMode(*source.CreateMode)
		restore.CreateMode = &createMode
	} else {
		restore.CreateMode = nil
	}

	// MinimalTlsVersion
	if source.MinimalTlsVersion != nil {
		minimalTlsVersion := MinimalTlsVersion(*source.MinimalTlsVersion)
		restore.MinimalTlsVersion = &minimalTlsVersion
	} else {
		restore.MinimalTlsVersion = nil
	}

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := PublicNetworkAccess(*source.PublicNetworkAccess)
		restore.PublicNetworkAccess = &publicNetworkAccess
	} else {
		restore.PublicNetworkAccess = nil
	}

	// SourceServerId
	restore.SourceServerId = genruntime.ClonePointerToString(source.SourceServerId)

	// SslEnforcement
	if source.SslEnforcement != nil {
		sslEnforcement := SslEnforcement(*source.SslEnforcement)
		restore.SslEnforcement = &sslEnforcement
	} else {
		restore.SslEnforcement = nil
	}

	// StorageProfile
	if source.StorageProfile != nil {
		var storageProfile StorageProfile
		err := storageProfile.AssignProperties_From_StorageProfile(source.StorageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_StorageProfile() to populate field StorageProfile")
		}
		restore.StorageProfile = &storageProfile
	} else {
		restore.StorageProfile = nil
	}

	// Version
	if source.Version != nil {
		version := ServerVersion(*source.Version)
		restore.Version = &version
	} else {
		restore.Version = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ServerPropertiesForGeoRestore populates the provided destination ServerPropertiesForGeoRestore from our ServerPropertiesForGeoRestore
func (restore *ServerPropertiesForGeoRestore) AssignProperties_To_ServerPropertiesForGeoRestore(destination *v20180601s.ServerPropertiesForGeoRestore) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CreateMode
	if restore.CreateMode != nil {
		createMode := string(*restore.CreateMode)
		destination.CreateMode = &createMode
	} else {
		destination.CreateMode = nil
	}

	// MinimalTlsVersion
	if restore.MinimalTlsVersion != nil {
		minimalTlsVersion := string(*restore.MinimalTlsVersion)
		destination.MinimalTlsVersion = &minimalTlsVersion
	} else {
		destination.MinimalTlsVersion = nil
	}

	// PublicNetworkAccess
	if restore.PublicNetworkAccess != nil {
		publicNetworkAccess := string(*restore.PublicNetworkAccess)
		destination.PublicNetworkAccess = &publicNetworkAccess
	} else {
		destination.PublicNetworkAccess = nil
	}

	// SourceServerId
	destination.SourceServerId = genruntime.ClonePointerToString(restore.SourceServerId)

	// SslEnforcement
	if restore.SslEnforcement != nil {
		sslEnforcement := string(*restore.SslEnforcement)
		destination.SslEnforcement = &sslEnforcement
	} else {
		destination.SslEnforcement = nil
	}

	// StorageProfile
	if restore.StorageProfile != nil {
		var storageProfile v20180601s.StorageProfile
		err := restore.StorageProfile.AssignProperties_To_StorageProfile(&storageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_StorageProfile() to populate field StorageProfile")
		}
		destination.StorageProfile = &storageProfile
	} else {
		destination.StorageProfile = nil
	}

	// Version
	if restore.Version != nil {
		version := string(*restore.Version)
		destination.Version = &version
	} else {
		destination.Version = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ServerPropertiesForReplica struct {
	// +kubebuilder:validation:Required
	// CreateMode: The mode to create a new server.
	CreateMode *ServerPropertiesForReplica_CreateMode `json:"createMode,omitempty"`

	// MinimalTlsVersion: Enforce a minimal Tls version for the server.
	MinimalTlsVersion *MinimalTlsVersion `json:"minimalTlsVersion,omitempty"`

	// PublicNetworkAccess: Whether or not public network access is allowed for this server. Value is optional but if passed
	// in, must be 'Enabled' or 'Disabled'
	PublicNetworkAccess *PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// +kubebuilder:validation:Required
	// SourceServerId: The master server id to create replica from.
	SourceServerId *string `json:"sourceServerId,omitempty"`

	// SslEnforcement: Enable ssl enforcement or not when connect to server.
	SslEnforcement *SslEnforcement `json:"sslEnforcement,omitempty"`

	// StorageProfile: Storage profile of a server.
	StorageProfile *StorageProfile `json:"storageProfile,omitempty"`

	// Version: Server version.
	Version *ServerVersion `json:"version,omitempty"`
}

var _ genruntime.ARMTransformer = &ServerPropertiesForReplica{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (replica *ServerPropertiesForReplica) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if replica == nil {
		return nil, nil
	}
	result := &ServerPropertiesForReplica_ARM{}

	// Set property "CreateMode":
	if replica.CreateMode != nil {
		result.CreateMode = *replica.CreateMode
	}

	// Set property "MinimalTlsVersion":
	if replica.MinimalTlsVersion != nil {
		minimalTlsVersion := *replica.MinimalTlsVersion
		result.MinimalTlsVersion = &minimalTlsVersion
	}

	// Set property "PublicNetworkAccess":
	if replica.PublicNetworkAccess != nil {
		publicNetworkAccess := *replica.PublicNetworkAccess
		result.PublicNetworkAccess = &publicNetworkAccess
	}

	// Set property "SourceServerId":
	if replica.SourceServerId != nil {
		sourceServerId := *replica.SourceServerId
		result.SourceServerId = &sourceServerId
	}

	// Set property "SslEnforcement":
	if replica.SslEnforcement != nil {
		sslEnforcement := *replica.SslEnforcement
		result.SslEnforcement = &sslEnforcement
	}

	// Set property "StorageProfile":
	if replica.StorageProfile != nil {
		storageProfile_ARM, err := (*replica.StorageProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		storageProfile := *storageProfile_ARM.(*StorageProfile_ARM)
		result.StorageProfile = &storageProfile
	}

	// Set property "Version":
	if replica.Version != nil {
		version := *replica.Version
		result.Version = &version
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (replica *ServerPropertiesForReplica) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ServerPropertiesForReplica_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (replica *ServerPropertiesForReplica) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ServerPropertiesForReplica_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ServerPropertiesForReplica_ARM, got %T", armInput)
	}

	// Set property "CreateMode":
	replica.CreateMode = &typedInput.CreateMode

	// Set property "MinimalTlsVersion":
	if typedInput.MinimalTlsVersion != nil {
		minimalTlsVersion := *typedInput.MinimalTlsVersion
		replica.MinimalTlsVersion = &minimalTlsVersion
	}

	// Set property "PublicNetworkAccess":
	if typedInput.PublicNetworkAccess != nil {
		publicNetworkAccess := *typedInput.PublicNetworkAccess
		replica.PublicNetworkAccess = &publicNetworkAccess
	}

	// Set property "SourceServerId":
	if typedInput.SourceServerId != nil {
		sourceServerId := *typedInput.SourceServerId
		replica.SourceServerId = &sourceServerId
	}

	// Set property "SslEnforcement":
	if typedInput.SslEnforcement != nil {
		sslEnforcement := *typedInput.SslEnforcement
		replica.SslEnforcement = &sslEnforcement
	}

	// Set property "StorageProfile":
	if typedInput.StorageProfile != nil {
		var storageProfile1 StorageProfile
		err := storageProfile1.PopulateFromARM(owner, *typedInput.StorageProfile)
		if err != nil {
			return err
		}
		storageProfile := storageProfile1
		replica.StorageProfile = &storageProfile
	}

	// Set property "Version":
	if typedInput.Version != nil {
		version := *typedInput.Version
		replica.Version = &version
	}

	// No error
	return nil
}

// AssignProperties_From_ServerPropertiesForReplica populates our ServerPropertiesForReplica from the provided source ServerPropertiesForReplica
func (replica *ServerPropertiesForReplica) AssignProperties_From_ServerPropertiesForReplica(source *v20180601s.ServerPropertiesForReplica) error {

	// CreateMode
	if source.CreateMode != nil {
		createMode := ServerPropertiesForReplica_CreateMode(*source.CreateMode)
		replica.CreateMode = &createMode
	} else {
		replica.CreateMode = nil
	}

	// MinimalTlsVersion
	if source.MinimalTlsVersion != nil {
		minimalTlsVersion := MinimalTlsVersion(*source.MinimalTlsVersion)
		replica.MinimalTlsVersion = &minimalTlsVersion
	} else {
		replica.MinimalTlsVersion = nil
	}

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := PublicNetworkAccess(*source.PublicNetworkAccess)
		replica.PublicNetworkAccess = &publicNetworkAccess
	} else {
		replica.PublicNetworkAccess = nil
	}

	// SourceServerId
	replica.SourceServerId = genruntime.ClonePointerToString(source.SourceServerId)

	// SslEnforcement
	if source.SslEnforcement != nil {
		sslEnforcement := SslEnforcement(*source.SslEnforcement)
		replica.SslEnforcement = &sslEnforcement
	} else {
		replica.SslEnforcement = nil
	}

	// StorageProfile
	if source.StorageProfile != nil {
		var storageProfile StorageProfile
		err := storageProfile.AssignProperties_From_StorageProfile(source.StorageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_StorageProfile() to populate field StorageProfile")
		}
		replica.StorageProfile = &storageProfile
	} else {
		replica.StorageProfile = nil
	}

	// Version
	if source.Version != nil {
		version := ServerVersion(*source.Version)
		replica.Version = &version
	} else {
		replica.Version = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ServerPropertiesForReplica populates the provided destination ServerPropertiesForReplica from our ServerPropertiesForReplica
func (replica *ServerPropertiesForReplica) AssignProperties_To_ServerPropertiesForReplica(destination *v20180601s.ServerPropertiesForReplica) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CreateMode
	if replica.CreateMode != nil {
		createMode := string(*replica.CreateMode)
		destination.CreateMode = &createMode
	} else {
		destination.CreateMode = nil
	}

	// MinimalTlsVersion
	if replica.MinimalTlsVersion != nil {
		minimalTlsVersion := string(*replica.MinimalTlsVersion)
		destination.MinimalTlsVersion = &minimalTlsVersion
	} else {
		destination.MinimalTlsVersion = nil
	}

	// PublicNetworkAccess
	if replica.PublicNetworkAccess != nil {
		publicNetworkAccess := string(*replica.PublicNetworkAccess)
		destination.PublicNetworkAccess = &publicNetworkAccess
	} else {
		destination.PublicNetworkAccess = nil
	}

	// SourceServerId
	destination.SourceServerId = genruntime.ClonePointerToString(replica.SourceServerId)

	// SslEnforcement
	if replica.SslEnforcement != nil {
		sslEnforcement := string(*replica.SslEnforcement)
		destination.SslEnforcement = &sslEnforcement
	} else {
		destination.SslEnforcement = nil
	}

	// StorageProfile
	if replica.StorageProfile != nil {
		var storageProfile v20180601s.StorageProfile
		err := replica.StorageProfile.AssignProperties_To_StorageProfile(&storageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_StorageProfile() to populate field StorageProfile")
		}
		destination.StorageProfile = &storageProfile
	} else {
		destination.StorageProfile = nil
	}

	// Version
	if replica.Version != nil {
		version := string(*replica.Version)
		destination.Version = &version
	} else {
		destination.Version = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ServerPropertiesForRestore struct {
	// +kubebuilder:validation:Required
	// CreateMode: The mode to create a new server.
	CreateMode *ServerPropertiesForRestore_CreateMode `json:"createMode,omitempty"`

	// MinimalTlsVersion: Enforce a minimal Tls version for the server.
	MinimalTlsVersion *MinimalTlsVersion `json:"minimalTlsVersion,omitempty"`

	// PublicNetworkAccess: Whether or not public network access is allowed for this server. Value is optional but if passed
	// in, must be 'Enabled' or 'Disabled'
	PublicNetworkAccess *PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// +kubebuilder:validation:Required
	// RestorePointInTime: Restore point creation time (ISO8601 format), specifying the time to restore from.
	RestorePointInTime *string `json:"restorePointInTime,omitempty"`

	// +kubebuilder:validation:Required
	// SourceServerId: The source server id to restore from.
	SourceServerId *string `json:"sourceServerId,omitempty"`

	// SslEnforcement: Enable ssl enforcement or not when connect to server.
	SslEnforcement *SslEnforcement `json:"sslEnforcement,omitempty"`

	// StorageProfile: Storage profile of a server.
	StorageProfile *StorageProfile `json:"storageProfile,omitempty"`

	// Version: Server version.
	Version *ServerVersion `json:"version,omitempty"`
}

var _ genruntime.ARMTransformer = &ServerPropertiesForRestore{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (restore *ServerPropertiesForRestore) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if restore == nil {
		return nil, nil
	}
	result := &ServerPropertiesForRestore_ARM{}

	// Set property "CreateMode":
	if restore.CreateMode != nil {
		result.CreateMode = *restore.CreateMode
	}

	// Set property "MinimalTlsVersion":
	if restore.MinimalTlsVersion != nil {
		minimalTlsVersion := *restore.MinimalTlsVersion
		result.MinimalTlsVersion = &minimalTlsVersion
	}

	// Set property "PublicNetworkAccess":
	if restore.PublicNetworkAccess != nil {
		publicNetworkAccess := *restore.PublicNetworkAccess
		result.PublicNetworkAccess = &publicNetworkAccess
	}

	// Set property "RestorePointInTime":
	if restore.RestorePointInTime != nil {
		restorePointInTime := *restore.RestorePointInTime
		result.RestorePointInTime = &restorePointInTime
	}

	// Set property "SourceServerId":
	if restore.SourceServerId != nil {
		sourceServerId := *restore.SourceServerId
		result.SourceServerId = &sourceServerId
	}

	// Set property "SslEnforcement":
	if restore.SslEnforcement != nil {
		sslEnforcement := *restore.SslEnforcement
		result.SslEnforcement = &sslEnforcement
	}

	// Set property "StorageProfile":
	if restore.StorageProfile != nil {
		storageProfile_ARM, err := (*restore.StorageProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		storageProfile := *storageProfile_ARM.(*StorageProfile_ARM)
		result.StorageProfile = &storageProfile
	}

	// Set property "Version":
	if restore.Version != nil {
		version := *restore.Version
		result.Version = &version
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (restore *ServerPropertiesForRestore) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ServerPropertiesForRestore_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (restore *ServerPropertiesForRestore) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ServerPropertiesForRestore_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ServerPropertiesForRestore_ARM, got %T", armInput)
	}

	// Set property "CreateMode":
	restore.CreateMode = &typedInput.CreateMode

	// Set property "MinimalTlsVersion":
	if typedInput.MinimalTlsVersion != nil {
		minimalTlsVersion := *typedInput.MinimalTlsVersion
		restore.MinimalTlsVersion = &minimalTlsVersion
	}

	// Set property "PublicNetworkAccess":
	if typedInput.PublicNetworkAccess != nil {
		publicNetworkAccess := *typedInput.PublicNetworkAccess
		restore.PublicNetworkAccess = &publicNetworkAccess
	}

	// Set property "RestorePointInTime":
	if typedInput.RestorePointInTime != nil {
		restorePointInTime := *typedInput.RestorePointInTime
		restore.RestorePointInTime = &restorePointInTime
	}

	// Set property "SourceServerId":
	if typedInput.SourceServerId != nil {
		sourceServerId := *typedInput.SourceServerId
		restore.SourceServerId = &sourceServerId
	}

	// Set property "SslEnforcement":
	if typedInput.SslEnforcement != nil {
		sslEnforcement := *typedInput.SslEnforcement
		restore.SslEnforcement = &sslEnforcement
	}

	// Set property "StorageProfile":
	if typedInput.StorageProfile != nil {
		var storageProfile1 StorageProfile
		err := storageProfile1.PopulateFromARM(owner, *typedInput.StorageProfile)
		if err != nil {
			return err
		}
		storageProfile := storageProfile1
		restore.StorageProfile = &storageProfile
	}

	// Set property "Version":
	if typedInput.Version != nil {
		version := *typedInput.Version
		restore.Version = &version
	}

	// No error
	return nil
}

// AssignProperties_From_ServerPropertiesForRestore populates our ServerPropertiesForRestore from the provided source ServerPropertiesForRestore
func (restore *ServerPropertiesForRestore) AssignProperties_From_ServerPropertiesForRestore(source *v20180601s.ServerPropertiesForRestore) error {

	// CreateMode
	if source.CreateMode != nil {
		createMode := ServerPropertiesForRestore_CreateMode(*source.CreateMode)
		restore.CreateMode = &createMode
	} else {
		restore.CreateMode = nil
	}

	// MinimalTlsVersion
	if source.MinimalTlsVersion != nil {
		minimalTlsVersion := MinimalTlsVersion(*source.MinimalTlsVersion)
		restore.MinimalTlsVersion = &minimalTlsVersion
	} else {
		restore.MinimalTlsVersion = nil
	}

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := PublicNetworkAccess(*source.PublicNetworkAccess)
		restore.PublicNetworkAccess = &publicNetworkAccess
	} else {
		restore.PublicNetworkAccess = nil
	}

	// RestorePointInTime
	restore.RestorePointInTime = genruntime.ClonePointerToString(source.RestorePointInTime)

	// SourceServerId
	restore.SourceServerId = genruntime.ClonePointerToString(source.SourceServerId)

	// SslEnforcement
	if source.SslEnforcement != nil {
		sslEnforcement := SslEnforcement(*source.SslEnforcement)
		restore.SslEnforcement = &sslEnforcement
	} else {
		restore.SslEnforcement = nil
	}

	// StorageProfile
	if source.StorageProfile != nil {
		var storageProfile StorageProfile
		err := storageProfile.AssignProperties_From_StorageProfile(source.StorageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_StorageProfile() to populate field StorageProfile")
		}
		restore.StorageProfile = &storageProfile
	} else {
		restore.StorageProfile = nil
	}

	// Version
	if source.Version != nil {
		version := ServerVersion(*source.Version)
		restore.Version = &version
	} else {
		restore.Version = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ServerPropertiesForRestore populates the provided destination ServerPropertiesForRestore from our ServerPropertiesForRestore
func (restore *ServerPropertiesForRestore) AssignProperties_To_ServerPropertiesForRestore(destination *v20180601s.ServerPropertiesForRestore) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CreateMode
	if restore.CreateMode != nil {
		createMode := string(*restore.CreateMode)
		destination.CreateMode = &createMode
	} else {
		destination.CreateMode = nil
	}

	// MinimalTlsVersion
	if restore.MinimalTlsVersion != nil {
		minimalTlsVersion := string(*restore.MinimalTlsVersion)
		destination.MinimalTlsVersion = &minimalTlsVersion
	} else {
		destination.MinimalTlsVersion = nil
	}

	// PublicNetworkAccess
	if restore.PublicNetworkAccess != nil {
		publicNetworkAccess := string(*restore.PublicNetworkAccess)
		destination.PublicNetworkAccess = &publicNetworkAccess
	} else {
		destination.PublicNetworkAccess = nil
	}

	// RestorePointInTime
	destination.RestorePointInTime = genruntime.ClonePointerToString(restore.RestorePointInTime)

	// SourceServerId
	destination.SourceServerId = genruntime.ClonePointerToString(restore.SourceServerId)

	// SslEnforcement
	if restore.SslEnforcement != nil {
		sslEnforcement := string(*restore.SslEnforcement)
		destination.SslEnforcement = &sslEnforcement
	} else {
		destination.SslEnforcement = nil
	}

	// StorageProfile
	if restore.StorageProfile != nil {
		var storageProfile v20180601s.StorageProfile
		err := restore.StorageProfile.AssignProperties_To_StorageProfile(&storageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_StorageProfile() to populate field StorageProfile")
		}
		destination.StorageProfile = &storageProfile
	} else {
		destination.StorageProfile = nil
	}

	// Version
	if restore.Version != nil {
		version := string(*restore.Version)
		destination.Version = &version
	} else {
		destination.Version = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type StorageProfile_GeoRedundantBackup_STATUS string

const (
	StorageProfile_GeoRedundantBackup_STATUS_Disabled = StorageProfile_GeoRedundantBackup_STATUS("Disabled")
	StorageProfile_GeoRedundantBackup_STATUS_Enabled  = StorageProfile_GeoRedundantBackup_STATUS("Enabled")
)

type StorageProfile_StorageAutogrow_STATUS string

const (
	StorageProfile_StorageAutogrow_STATUS_Disabled = StorageProfile_StorageAutogrow_STATUS("Disabled")
	StorageProfile_StorageAutogrow_STATUS_Enabled  = StorageProfile_StorageAutogrow_STATUS("Enabled")
)

type PrivateEndpointProperty_STATUS struct {
	// Id: Resource id of the private endpoint.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &PrivateEndpointProperty_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (property *PrivateEndpointProperty_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PrivateEndpointProperty_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (property *PrivateEndpointProperty_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PrivateEndpointProperty_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PrivateEndpointProperty_STATUS_ARM, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		property.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_PrivateEndpointProperty_STATUS populates our PrivateEndpointProperty_STATUS from the provided source PrivateEndpointProperty_STATUS
func (property *PrivateEndpointProperty_STATUS) AssignProperties_From_PrivateEndpointProperty_STATUS(source *v20180601s.PrivateEndpointProperty_STATUS) error {

	// Id
	property.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_PrivateEndpointProperty_STATUS populates the provided destination PrivateEndpointProperty_STATUS from our PrivateEndpointProperty_STATUS
func (property *PrivateEndpointProperty_STATUS) AssignProperties_To_PrivateEndpointProperty_STATUS(destination *v20180601s.PrivateEndpointProperty_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(property.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ServerPrivateEndpointConnectionProperties_ProvisioningState_STATUS string

const (
	ServerPrivateEndpointConnectionProperties_ProvisioningState_STATUS_Approving = ServerPrivateEndpointConnectionProperties_ProvisioningState_STATUS("Approving")
	ServerPrivateEndpointConnectionProperties_ProvisioningState_STATUS_Dropping  = ServerPrivateEndpointConnectionProperties_ProvisioningState_STATUS("Dropping")
	ServerPrivateEndpointConnectionProperties_ProvisioningState_STATUS_Failed    = ServerPrivateEndpointConnectionProperties_ProvisioningState_STATUS("Failed")
	ServerPrivateEndpointConnectionProperties_ProvisioningState_STATUS_Ready     = ServerPrivateEndpointConnectionProperties_ProvisioningState_STATUS("Ready")
	ServerPrivateEndpointConnectionProperties_ProvisioningState_STATUS_Rejecting = ServerPrivateEndpointConnectionProperties_ProvisioningState_STATUS("Rejecting")
)

type ServerPrivateLinkServiceConnectionStateProperty_STATUS struct {
	// ActionsRequired: The actions required for private link service connection.
	ActionsRequired *ServerPrivateLinkServiceConnectionStateProperty_ActionsRequired_STATUS `json:"actionsRequired,omitempty"`

	// Description: The private link service connection description.
	Description *string `json:"description,omitempty"`

	// Status: The private link service connection status.
	Status *ServerPrivateLinkServiceConnectionStateProperty_Status_STATUS `json:"status,omitempty"`
}

var _ genruntime.FromARMConverter = &ServerPrivateLinkServiceConnectionStateProperty_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (property *ServerPrivateLinkServiceConnectionStateProperty_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ServerPrivateLinkServiceConnectionStateProperty_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (property *ServerPrivateLinkServiceConnectionStateProperty_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ServerPrivateLinkServiceConnectionStateProperty_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ServerPrivateLinkServiceConnectionStateProperty_STATUS_ARM, got %T", armInput)
	}

	// Set property "ActionsRequired":
	if typedInput.ActionsRequired != nil {
		actionsRequired := *typedInput.ActionsRequired
		property.ActionsRequired = &actionsRequired
	}

	// Set property "Description":
	if typedInput.Description != nil {
		description := *typedInput.Description
		property.Description = &description
	}

	// Set property "Status":
	if typedInput.Status != nil {
		status := *typedInput.Status
		property.Status = &status
	}

	// No error
	return nil
}

// AssignProperties_From_ServerPrivateLinkServiceConnectionStateProperty_STATUS populates our ServerPrivateLinkServiceConnectionStateProperty_STATUS from the provided source ServerPrivateLinkServiceConnectionStateProperty_STATUS
func (property *ServerPrivateLinkServiceConnectionStateProperty_STATUS) AssignProperties_From_ServerPrivateLinkServiceConnectionStateProperty_STATUS(source *v20180601s.ServerPrivateLinkServiceConnectionStateProperty_STATUS) error {

	// ActionsRequired
	if source.ActionsRequired != nil {
		actionsRequired := ServerPrivateLinkServiceConnectionStateProperty_ActionsRequired_STATUS(*source.ActionsRequired)
		property.ActionsRequired = &actionsRequired
	} else {
		property.ActionsRequired = nil
	}

	// Description
	property.Description = genruntime.ClonePointerToString(source.Description)

	// Status
	if source.Status != nil {
		status := ServerPrivateLinkServiceConnectionStateProperty_Status_STATUS(*source.Status)
		property.Status = &status
	} else {
		property.Status = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ServerPrivateLinkServiceConnectionStateProperty_STATUS populates the provided destination ServerPrivateLinkServiceConnectionStateProperty_STATUS from our ServerPrivateLinkServiceConnectionStateProperty_STATUS
func (property *ServerPrivateLinkServiceConnectionStateProperty_STATUS) AssignProperties_To_ServerPrivateLinkServiceConnectionStateProperty_STATUS(destination *v20180601s.ServerPrivateLinkServiceConnectionStateProperty_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ActionsRequired
	if property.ActionsRequired != nil {
		actionsRequired := string(*property.ActionsRequired)
		destination.ActionsRequired = &actionsRequired
	} else {
		destination.ActionsRequired = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(property.Description)

	// Status
	if property.Status != nil {
		status := string(*property.Status)
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage Profile properties of a server
type StorageProfile struct {
	// BackupRetentionDays: Backup retention days for the server.
	BackupRetentionDays *int `json:"backupRetentionDays,omitempty"`

	// GeoRedundantBackup: Enable Geo-redundant or not for server backup.
	GeoRedundantBackup *StorageProfile_GeoRedundantBackup `json:"geoRedundantBackup,omitempty"`

	// StorageAutogrow: Enable Storage Auto Grow.
	StorageAutogrow *StorageProfile_StorageAutogrow `json:"storageAutogrow,omitempty"`

	// StorageMB: Max storage allowed for a server.
	StorageMB *int `json:"storageMB,omitempty"`
}

var _ genruntime.ARMTransformer = &StorageProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *StorageProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &StorageProfile_ARM{}

	// Set property "BackupRetentionDays":
	if profile.BackupRetentionDays != nil {
		backupRetentionDays := *profile.BackupRetentionDays
		result.BackupRetentionDays = &backupRetentionDays
	}

	// Set property "GeoRedundantBackup":
	if profile.GeoRedundantBackup != nil {
		geoRedundantBackup := *profile.GeoRedundantBackup
		result.GeoRedundantBackup = &geoRedundantBackup
	}

	// Set property "StorageAutogrow":
	if profile.StorageAutogrow != nil {
		storageAutogrow := *profile.StorageAutogrow
		result.StorageAutogrow = &storageAutogrow
	}

	// Set property "StorageMB":
	if profile.StorageMB != nil {
		storageMB := *profile.StorageMB
		result.StorageMB = &storageMB
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *StorageProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &StorageProfile_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *StorageProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(StorageProfile_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected StorageProfile_ARM, got %T", armInput)
	}

	// Set property "BackupRetentionDays":
	if typedInput.BackupRetentionDays != nil {
		backupRetentionDays := *typedInput.BackupRetentionDays
		profile.BackupRetentionDays = &backupRetentionDays
	}

	// Set property "GeoRedundantBackup":
	if typedInput.GeoRedundantBackup != nil {
		geoRedundantBackup := *typedInput.GeoRedundantBackup
		profile.GeoRedundantBackup = &geoRedundantBackup
	}

	// Set property "StorageAutogrow":
	if typedInput.StorageAutogrow != nil {
		storageAutogrow := *typedInput.StorageAutogrow
		profile.StorageAutogrow = &storageAutogrow
	}

	// Set property "StorageMB":
	if typedInput.StorageMB != nil {
		storageMB := *typedInput.StorageMB
		profile.StorageMB = &storageMB
	}

	// No error
	return nil
}

// AssignProperties_From_StorageProfile populates our StorageProfile from the provided source StorageProfile
func (profile *StorageProfile) AssignProperties_From_StorageProfile(source *v20180601s.StorageProfile) error {

	// BackupRetentionDays
	profile.BackupRetentionDays = genruntime.ClonePointerToInt(source.BackupRetentionDays)

	// GeoRedundantBackup
	if source.GeoRedundantBackup != nil {
		geoRedundantBackup := StorageProfile_GeoRedundantBackup(*source.GeoRedundantBackup)
		profile.GeoRedundantBackup = &geoRedundantBackup
	} else {
		profile.GeoRedundantBackup = nil
	}

	// StorageAutogrow
	if source.StorageAutogrow != nil {
		storageAutogrow := StorageProfile_StorageAutogrow(*source.StorageAutogrow)
		profile.StorageAutogrow = &storageAutogrow
	} else {
		profile.StorageAutogrow = nil
	}

	// StorageMB
	profile.StorageMB = genruntime.ClonePointerToInt(source.StorageMB)

	// No error
	return nil
}

// AssignProperties_To_StorageProfile populates the provided destination StorageProfile from our StorageProfile
func (profile *StorageProfile) AssignProperties_To_StorageProfile(destination *v20180601s.StorageProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackupRetentionDays
	destination.BackupRetentionDays = genruntime.ClonePointerToInt(profile.BackupRetentionDays)

	// GeoRedundantBackup
	if profile.GeoRedundantBackup != nil {
		geoRedundantBackup := string(*profile.GeoRedundantBackup)
		destination.GeoRedundantBackup = &geoRedundantBackup
	} else {
		destination.GeoRedundantBackup = nil
	}

	// StorageAutogrow
	if profile.StorageAutogrow != nil {
		storageAutogrow := string(*profile.StorageAutogrow)
		destination.StorageAutogrow = &storageAutogrow
	} else {
		destination.StorageAutogrow = nil
	}

	// StorageMB
	destination.StorageMB = genruntime.ClonePointerToInt(profile.StorageMB)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ServerPrivateLinkServiceConnectionStateProperty_ActionsRequired_STATUS string

const ServerPrivateLinkServiceConnectionStateProperty_ActionsRequired_STATUS_None = ServerPrivateLinkServiceConnectionStateProperty_ActionsRequired_STATUS("None")

type ServerPrivateLinkServiceConnectionStateProperty_Status_STATUS string

const (
	ServerPrivateLinkServiceConnectionStateProperty_Status_STATUS_Approved     = ServerPrivateLinkServiceConnectionStateProperty_Status_STATUS("Approved")
	ServerPrivateLinkServiceConnectionStateProperty_Status_STATUS_Disconnected = ServerPrivateLinkServiceConnectionStateProperty_Status_STATUS("Disconnected")
	ServerPrivateLinkServiceConnectionStateProperty_Status_STATUS_Pending      = ServerPrivateLinkServiceConnectionStateProperty_Status_STATUS("Pending")
	ServerPrivateLinkServiceConnectionStateProperty_Status_STATUS_Rejected     = ServerPrivateLinkServiceConnectionStateProperty_Status_STATUS("Rejected")
)

func init() {
	SchemeBuilder.Register(&Server{}, &ServerList{})
}
