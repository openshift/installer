// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package storage

import (
	"fmt"
	v20210701s "github.com/Azure/azure-service-operator/v2/api/compute/v1api20210701/storage"
	v20220301s "github.com/Azure/azure-service-operator/v2/api/compute/v1api20220301/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/pkg/errors"
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Storage version of v1api20201201.VirtualMachine
// Generator information:
// - Generated from: /compute/resource-manager/Microsoft.Compute/ComputeRP/stable/2020-12-01/compute.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}
type VirtualMachine struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              VirtualMachine_Spec   `json:"spec,omitempty"`
	Status            VirtualMachine_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &VirtualMachine{}

// GetConditions returns the conditions of the resource
func (machine *VirtualMachine) GetConditions() conditions.Conditions {
	return machine.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (machine *VirtualMachine) SetConditions(conditions conditions.Conditions) {
	machine.Status.Conditions = conditions
}

var _ conversion.Convertible = &VirtualMachine{}

// ConvertFrom populates our VirtualMachine from the provided hub VirtualMachine
func (machine *VirtualMachine) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v20220301s.VirtualMachine)
	if !ok {
		return fmt.Errorf("expected compute/v1api20220301/storage/VirtualMachine but received %T instead", hub)
	}

	return machine.AssignProperties_From_VirtualMachine(source)
}

// ConvertTo populates the provided hub VirtualMachine from our VirtualMachine
func (machine *VirtualMachine) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v20220301s.VirtualMachine)
	if !ok {
		return fmt.Errorf("expected compute/v1api20220301/storage/VirtualMachine but received %T instead", hub)
	}

	return machine.AssignProperties_To_VirtualMachine(destination)
}

var _ configmaps.Exporter = &VirtualMachine{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (machine *VirtualMachine) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if machine.Spec.OperatorSpec == nil {
		return nil
	}
	return machine.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &VirtualMachine{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (machine *VirtualMachine) SecretDestinationExpressions() []*core.DestinationExpression {
	if machine.Spec.OperatorSpec == nil {
		return nil
	}
	return machine.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.KubernetesResource = &VirtualMachine{}

// AzureName returns the Azure name of the resource
func (machine *VirtualMachine) AzureName() string {
	return machine.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2020-12-01"
func (machine VirtualMachine) GetAPIVersion() string {
	return "2020-12-01"
}

// GetResourceScope returns the scope of the resource
func (machine *VirtualMachine) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (machine *VirtualMachine) GetSpec() genruntime.ConvertibleSpec {
	return &machine.Spec
}

// GetStatus returns the status of this resource
func (machine *VirtualMachine) GetStatus() genruntime.ConvertibleStatus {
	return &machine.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (machine *VirtualMachine) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Compute/virtualMachines"
func (machine *VirtualMachine) GetType() string {
	return "Microsoft.Compute/virtualMachines"
}

// NewEmptyStatus returns a new empty (blank) status
func (machine *VirtualMachine) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &VirtualMachine_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (machine *VirtualMachine) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(machine.Spec)
	return machine.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (machine *VirtualMachine) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*VirtualMachine_STATUS); ok {
		machine.Status = *st
		return nil
	}

	// Convert status to required version
	var st VirtualMachine_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	machine.Status = st
	return nil
}

// AssignProperties_From_VirtualMachine populates our VirtualMachine from the provided source VirtualMachine
func (machine *VirtualMachine) AssignProperties_From_VirtualMachine(source *v20220301s.VirtualMachine) error {

	// ObjectMeta
	machine.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec VirtualMachine_Spec
	err := spec.AssignProperties_From_VirtualMachine_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_VirtualMachine_Spec() to populate field Spec")
	}
	machine.Spec = spec

	// Status
	var status VirtualMachine_STATUS
	err = status.AssignProperties_From_VirtualMachine_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_VirtualMachine_STATUS() to populate field Status")
	}
	machine.Status = status

	// Invoke the augmentConversionForVirtualMachine interface (if implemented) to customize the conversion
	var machineAsAny any = machine
	if augmentedMachine, ok := machineAsAny.(augmentConversionForVirtualMachine); ok {
		err := augmentedMachine.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachine populates the provided destination VirtualMachine from our VirtualMachine
func (machine *VirtualMachine) AssignProperties_To_VirtualMachine(destination *v20220301s.VirtualMachine) error {

	// ObjectMeta
	destination.ObjectMeta = *machine.ObjectMeta.DeepCopy()

	// Spec
	var spec v20220301s.VirtualMachine_Spec
	err := machine.Spec.AssignProperties_To_VirtualMachine_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_VirtualMachine_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v20220301s.VirtualMachine_STATUS
	err = machine.Status.AssignProperties_To_VirtualMachine_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_VirtualMachine_STATUS() to populate field Status")
	}
	destination.Status = status

	// Invoke the augmentConversionForVirtualMachine interface (if implemented) to customize the conversion
	var machineAsAny any = machine
	if augmentedMachine, ok := machineAsAny.(augmentConversionForVirtualMachine); ok {
		err := augmentedMachine.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (machine *VirtualMachine) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: machine.Spec.OriginalVersion,
		Kind:    "VirtualMachine",
	}
}

// +kubebuilder:object:root=true
// Storage version of v1api20201201.VirtualMachine
// Generator information:
// - Generated from: /compute/resource-manager/Microsoft.Compute/ComputeRP/stable/2020-12-01/compute.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}
type VirtualMachineList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []VirtualMachine `json:"items"`
}

// Storage version of v1api20201201.APIVersion
// +kubebuilder:validation:Enum={"2020-12-01"}
type APIVersion string

const APIVersion_Value = APIVersion("2020-12-01")

type augmentConversionForVirtualMachine interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachine) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachine) error
}

// Storage version of v1api20201201.VirtualMachine_Spec
type VirtualMachine_Spec struct {
	AdditionalCapabilities *AdditionalCapabilities `json:"additionalCapabilities,omitempty"`
	AvailabilitySet        *SubResource            `json:"availabilitySet,omitempty"`

	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName            string                      `json:"azureName,omitempty"`
	BillingProfile       *BillingProfile             `json:"billingProfile,omitempty"`
	DiagnosticsProfile   *DiagnosticsProfile         `json:"diagnosticsProfile,omitempty"`
	EvictionPolicy       *string                     `json:"evictionPolicy,omitempty"`
	ExtendedLocation     *ExtendedLocation           `json:"extendedLocation,omitempty"`
	ExtensionsTimeBudget *string                     `json:"extensionsTimeBudget,omitempty"`
	HardwareProfile      *HardwareProfile            `json:"hardwareProfile,omitempty"`
	Host                 *SubResource                `json:"host,omitempty"`
	HostGroup            *SubResource                `json:"hostGroup,omitempty"`
	Identity             *VirtualMachineIdentity     `json:"identity,omitempty"`
	LicenseType          *string                     `json:"licenseType,omitempty"`
	Location             *string                     `json:"location,omitempty"`
	NetworkProfile       *NetworkProfile             `json:"networkProfile,omitempty"`
	OperatorSpec         *VirtualMachineOperatorSpec `json:"operatorSpec,omitempty"`
	OriginalVersion      string                      `json:"originalVersion,omitempty"`
	OsProfile            *OSProfile                  `json:"osProfile,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner                   *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`
	Plan                    *Plan                              `json:"plan,omitempty"`
	PlatformFaultDomain     *int                               `json:"platformFaultDomain,omitempty"`
	Priority                *string                            `json:"priority,omitempty"`
	PropertyBag             genruntime.PropertyBag             `json:"$propertyBag,omitempty"`
	ProximityPlacementGroup *SubResource                       `json:"proximityPlacementGroup,omitempty"`
	SecurityProfile         *SecurityProfile                   `json:"securityProfile,omitempty"`
	StorageProfile          *StorageProfile                    `json:"storageProfile,omitempty"`
	Tags                    map[string]string                  `json:"tags,omitempty"`
	VirtualMachineScaleSet  *SubResource                       `json:"virtualMachineScaleSet,omitempty"`
	Zones                   []string                           `json:"zones,omitempty"`
}

var _ genruntime.ConvertibleSpec = &VirtualMachine_Spec{}

// ConvertSpecFrom populates our VirtualMachine_Spec from the provided source
func (machine *VirtualMachine_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v20220301s.VirtualMachine_Spec)
	if ok {
		// Populate our instance from source
		return machine.AssignProperties_From_VirtualMachine_Spec(src)
	}

	// Convert to an intermediate form
	src = &v20220301s.VirtualMachine_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = machine.AssignProperties_From_VirtualMachine_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our VirtualMachine_Spec
func (machine *VirtualMachine_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v20220301s.VirtualMachine_Spec)
	if ok {
		// Populate destination from our instance
		return machine.AssignProperties_To_VirtualMachine_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &v20220301s.VirtualMachine_Spec{}
	err := machine.AssignProperties_To_VirtualMachine_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_VirtualMachine_Spec populates our VirtualMachine_Spec from the provided source VirtualMachine_Spec
func (machine *VirtualMachine_Spec) AssignProperties_From_VirtualMachine_Spec(source *v20220301s.VirtualMachine_Spec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdditionalCapabilities
	if source.AdditionalCapabilities != nil {
		var additionalCapability AdditionalCapabilities
		err := additionalCapability.AssignProperties_From_AdditionalCapabilities(source.AdditionalCapabilities)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AdditionalCapabilities() to populate field AdditionalCapabilities")
		}
		machine.AdditionalCapabilities = &additionalCapability
	} else {
		machine.AdditionalCapabilities = nil
	}

	// ApplicationProfile
	if source.ApplicationProfile != nil {
		propertyBag.Add("ApplicationProfile", *source.ApplicationProfile)
	} else {
		propertyBag.Remove("ApplicationProfile")
	}

	// AvailabilitySet
	if source.AvailabilitySet != nil {
		var subResourceStash v20210701s.SubResource
		err := subResourceStash.AssignProperties_From_SubResource(source.AvailabilitySet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from AvailabilitySet")
		}
		var availabilitySet SubResource
		err = availabilitySet.AssignProperties_From_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field AvailabilitySet from SubResourceStash")
		}
		machine.AvailabilitySet = &availabilitySet
	} else {
		machine.AvailabilitySet = nil
	}

	// AzureName
	machine.AzureName = source.AzureName

	// BillingProfile
	if source.BillingProfile != nil {
		var billingProfile BillingProfile
		err := billingProfile.AssignProperties_From_BillingProfile(source.BillingProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BillingProfile() to populate field BillingProfile")
		}
		machine.BillingProfile = &billingProfile
	} else {
		machine.BillingProfile = nil
	}

	// CapacityReservation
	if source.CapacityReservation != nil {
		propertyBag.Add("CapacityReservation", *source.CapacityReservation)
	} else {
		propertyBag.Remove("CapacityReservation")
	}

	// DiagnosticsProfile
	if source.DiagnosticsProfile != nil {
		var diagnosticsProfile DiagnosticsProfile
		err := diagnosticsProfile.AssignProperties_From_DiagnosticsProfile(source.DiagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DiagnosticsProfile() to populate field DiagnosticsProfile")
		}
		machine.DiagnosticsProfile = &diagnosticsProfile
	} else {
		machine.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	machine.EvictionPolicy = genruntime.ClonePointerToString(source.EvictionPolicy)

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocationStash v20210701s.ExtendedLocation
		err := extendedLocationStash.AssignProperties_From_ExtendedLocation(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ExtendedLocation() to populate field ExtendedLocationStash from ExtendedLocation")
		}
		var extendedLocation ExtendedLocation
		err = extendedLocation.AssignProperties_From_ExtendedLocation(&extendedLocationStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ExtendedLocation() to populate field ExtendedLocation from ExtendedLocationStash")
		}
		machine.ExtendedLocation = &extendedLocation
	} else {
		machine.ExtendedLocation = nil
	}

	// ExtensionsTimeBudget
	machine.ExtensionsTimeBudget = genruntime.ClonePointerToString(source.ExtensionsTimeBudget)

	// HardwareProfile
	if source.HardwareProfile != nil {
		var hardwareProfile HardwareProfile
		err := hardwareProfile.AssignProperties_From_HardwareProfile(source.HardwareProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HardwareProfile() to populate field HardwareProfile")
		}
		machine.HardwareProfile = &hardwareProfile
	} else {
		machine.HardwareProfile = nil
	}

	// Host
	if source.Host != nil {
		var subResourceStash v20210701s.SubResource
		err := subResourceStash.AssignProperties_From_SubResource(source.Host)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from Host")
		}
		var host SubResource
		err = host.AssignProperties_From_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field Host from SubResourceStash")
		}
		machine.Host = &host
	} else {
		machine.Host = nil
	}

	// HostGroup
	if source.HostGroup != nil {
		var subResourceStash v20210701s.SubResource
		err := subResourceStash.AssignProperties_From_SubResource(source.HostGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from HostGroup")
		}
		var hostGroup SubResource
		err = hostGroup.AssignProperties_From_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field HostGroup from SubResourceStash")
		}
		machine.HostGroup = &hostGroup
	} else {
		machine.HostGroup = nil
	}

	// Identity
	if source.Identity != nil {
		var identity VirtualMachineIdentity
		err := identity.AssignProperties_From_VirtualMachineIdentity(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineIdentity() to populate field Identity")
		}
		machine.Identity = &identity
	} else {
		machine.Identity = nil
	}

	// LicenseType
	machine.LicenseType = genruntime.ClonePointerToString(source.LicenseType)

	// Location
	machine.Location = genruntime.ClonePointerToString(source.Location)

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile NetworkProfile
		err := networkProfile.AssignProperties_From_NetworkProfile(source.NetworkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_NetworkProfile() to populate field NetworkProfile")
		}
		machine.NetworkProfile = &networkProfile
	} else {
		machine.NetworkProfile = nil
	}

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec VirtualMachineOperatorSpec
		err := operatorSpec.AssignProperties_From_VirtualMachineOperatorSpec(source.OperatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineOperatorSpec() to populate field OperatorSpec")
		}
		machine.OperatorSpec = &operatorSpec
	} else {
		machine.OperatorSpec = nil
	}

	// OriginalVersion
	machine.OriginalVersion = source.OriginalVersion

	// OsProfile
	if source.OsProfile != nil {
		var osProfile OSProfile
		err := osProfile.AssignProperties_From_OSProfile(source.OsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OSProfile() to populate field OsProfile")
		}
		machine.OsProfile = &osProfile
	} else {
		machine.OsProfile = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		machine.Owner = &owner
	} else {
		machine.Owner = nil
	}

	// Plan
	if source.Plan != nil {
		var plan Plan
		err := plan.AssignProperties_From_Plan(source.Plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Plan() to populate field Plan")
		}
		machine.Plan = &plan
	} else {
		machine.Plan = nil
	}

	// PlatformFaultDomain
	machine.PlatformFaultDomain = genruntime.ClonePointerToInt(source.PlatformFaultDomain)

	// Priority
	machine.Priority = genruntime.ClonePointerToString(source.Priority)

	// ProximityPlacementGroup
	if source.ProximityPlacementGroup != nil {
		var subResourceStash v20210701s.SubResource
		err := subResourceStash.AssignProperties_From_SubResource(source.ProximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from ProximityPlacementGroup")
		}
		var proximityPlacementGroup SubResource
		err = proximityPlacementGroup.AssignProperties_From_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field ProximityPlacementGroup from SubResourceStash")
		}
		machine.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		machine.ProximityPlacementGroup = nil
	}

	// ScheduledEventsProfile
	if source.ScheduledEventsProfile != nil {
		propertyBag.Add("ScheduledEventsProfile", *source.ScheduledEventsProfile)
	} else {
		propertyBag.Remove("ScheduledEventsProfile")
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		var securityProfile SecurityProfile
		err := securityProfile.AssignProperties_From_SecurityProfile(source.SecurityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SecurityProfile() to populate field SecurityProfile")
		}
		machine.SecurityProfile = &securityProfile
	} else {
		machine.SecurityProfile = nil
	}

	// StorageProfile
	if source.StorageProfile != nil {
		var storageProfile StorageProfile
		err := storageProfile.AssignProperties_From_StorageProfile(source.StorageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_StorageProfile() to populate field StorageProfile")
		}
		machine.StorageProfile = &storageProfile
	} else {
		machine.StorageProfile = nil
	}

	// Tags
	machine.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// UserData
	if source.UserData != nil {
		propertyBag.Add("UserData", *source.UserData)
	} else {
		propertyBag.Remove("UserData")
	}

	// VirtualMachineScaleSet
	if source.VirtualMachineScaleSet != nil {
		var subResourceStash v20210701s.SubResource
		err := subResourceStash.AssignProperties_From_SubResource(source.VirtualMachineScaleSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from VirtualMachineScaleSet")
		}
		var virtualMachineScaleSet SubResource
		err = virtualMachineScaleSet.AssignProperties_From_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field VirtualMachineScaleSet from SubResourceStash")
		}
		machine.VirtualMachineScaleSet = &virtualMachineScaleSet
	} else {
		machine.VirtualMachineScaleSet = nil
	}

	// Zones
	machine.Zones = genruntime.CloneSliceOfString(source.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		machine.PropertyBag = propertyBag
	} else {
		machine.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachine_Spec interface (if implemented) to customize the conversion
	var machineAsAny any = machine
	if augmentedMachine, ok := machineAsAny.(augmentConversionForVirtualMachine_Spec); ok {
		err := augmentedMachine.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachine_Spec populates the provided destination VirtualMachine_Spec from our VirtualMachine_Spec
func (machine *VirtualMachine_Spec) AssignProperties_To_VirtualMachine_Spec(destination *v20220301s.VirtualMachine_Spec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(machine.PropertyBag)

	// AdditionalCapabilities
	if machine.AdditionalCapabilities != nil {
		var additionalCapability v20220301s.AdditionalCapabilities
		err := machine.AdditionalCapabilities.AssignProperties_To_AdditionalCapabilities(&additionalCapability)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AdditionalCapabilities() to populate field AdditionalCapabilities")
		}
		destination.AdditionalCapabilities = &additionalCapability
	} else {
		destination.AdditionalCapabilities = nil
	}

	// ApplicationProfile
	if propertyBag.Contains("ApplicationProfile") {
		var applicationProfile v20220301s.ApplicationProfile
		err := propertyBag.Pull("ApplicationProfile", &applicationProfile)
		if err != nil {
			return errors.Wrap(err, "pulling 'ApplicationProfile' from propertyBag")
		}

		destination.ApplicationProfile = &applicationProfile
	} else {
		destination.ApplicationProfile = nil
	}

	// AvailabilitySet
	if machine.AvailabilitySet != nil {
		var subResourceStash v20210701s.SubResource
		err := machine.AvailabilitySet.AssignProperties_To_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from AvailabilitySet")
		}
		var availabilitySet v20220301s.SubResource
		err = subResourceStash.AssignProperties_To_SubResource(&availabilitySet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field AvailabilitySet from SubResourceStash")
		}
		destination.AvailabilitySet = &availabilitySet
	} else {
		destination.AvailabilitySet = nil
	}

	// AzureName
	destination.AzureName = machine.AzureName

	// BillingProfile
	if machine.BillingProfile != nil {
		var billingProfile v20220301s.BillingProfile
		err := machine.BillingProfile.AssignProperties_To_BillingProfile(&billingProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BillingProfile() to populate field BillingProfile")
		}
		destination.BillingProfile = &billingProfile
	} else {
		destination.BillingProfile = nil
	}

	// CapacityReservation
	if propertyBag.Contains("CapacityReservation") {
		var capacityReservation v20220301s.CapacityReservationProfile
		err := propertyBag.Pull("CapacityReservation", &capacityReservation)
		if err != nil {
			return errors.Wrap(err, "pulling 'CapacityReservation' from propertyBag")
		}

		destination.CapacityReservation = &capacityReservation
	} else {
		destination.CapacityReservation = nil
	}

	// DiagnosticsProfile
	if machine.DiagnosticsProfile != nil {
		var diagnosticsProfile v20220301s.DiagnosticsProfile
		err := machine.DiagnosticsProfile.AssignProperties_To_DiagnosticsProfile(&diagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DiagnosticsProfile() to populate field DiagnosticsProfile")
		}
		destination.DiagnosticsProfile = &diagnosticsProfile
	} else {
		destination.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	destination.EvictionPolicy = genruntime.ClonePointerToString(machine.EvictionPolicy)

	// ExtendedLocation
	if machine.ExtendedLocation != nil {
		var extendedLocationStash v20210701s.ExtendedLocation
		err := machine.ExtendedLocation.AssignProperties_To_ExtendedLocation(&extendedLocationStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ExtendedLocation() to populate field ExtendedLocationStash from ExtendedLocation")
		}
		var extendedLocation v20220301s.ExtendedLocation
		err = extendedLocationStash.AssignProperties_To_ExtendedLocation(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ExtendedLocation() to populate field ExtendedLocation from ExtendedLocationStash")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// ExtensionsTimeBudget
	destination.ExtensionsTimeBudget = genruntime.ClonePointerToString(machine.ExtensionsTimeBudget)

	// HardwareProfile
	if machine.HardwareProfile != nil {
		var hardwareProfile v20220301s.HardwareProfile
		err := machine.HardwareProfile.AssignProperties_To_HardwareProfile(&hardwareProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HardwareProfile() to populate field HardwareProfile")
		}
		destination.HardwareProfile = &hardwareProfile
	} else {
		destination.HardwareProfile = nil
	}

	// Host
	if machine.Host != nil {
		var subResourceStash v20210701s.SubResource
		err := machine.Host.AssignProperties_To_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from Host")
		}
		var host v20220301s.SubResource
		err = subResourceStash.AssignProperties_To_SubResource(&host)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field Host from SubResourceStash")
		}
		destination.Host = &host
	} else {
		destination.Host = nil
	}

	// HostGroup
	if machine.HostGroup != nil {
		var subResourceStash v20210701s.SubResource
		err := machine.HostGroup.AssignProperties_To_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from HostGroup")
		}
		var hostGroup v20220301s.SubResource
		err = subResourceStash.AssignProperties_To_SubResource(&hostGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field HostGroup from SubResourceStash")
		}
		destination.HostGroup = &hostGroup
	} else {
		destination.HostGroup = nil
	}

	// Identity
	if machine.Identity != nil {
		var identity v20220301s.VirtualMachineIdentity
		err := machine.Identity.AssignProperties_To_VirtualMachineIdentity(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// LicenseType
	destination.LicenseType = genruntime.ClonePointerToString(machine.LicenseType)

	// Location
	destination.Location = genruntime.ClonePointerToString(machine.Location)

	// NetworkProfile
	if machine.NetworkProfile != nil {
		var networkProfile v20220301s.NetworkProfile
		err := machine.NetworkProfile.AssignProperties_To_NetworkProfile(&networkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_NetworkProfile() to populate field NetworkProfile")
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// OperatorSpec
	if machine.OperatorSpec != nil {
		var operatorSpec v20220301s.VirtualMachineOperatorSpec
		err := machine.OperatorSpec.AssignProperties_To_VirtualMachineOperatorSpec(&operatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = machine.OriginalVersion

	// OsProfile
	if machine.OsProfile != nil {
		var osProfile v20220301s.OSProfile
		err := machine.OsProfile.AssignProperties_To_OSProfile(&osProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OSProfile() to populate field OsProfile")
		}
		destination.OsProfile = &osProfile
	} else {
		destination.OsProfile = nil
	}

	// Owner
	if machine.Owner != nil {
		owner := machine.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Plan
	if machine.Plan != nil {
		var plan v20220301s.Plan
		err := machine.Plan.AssignProperties_To_Plan(&plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Plan() to populate field Plan")
		}
		destination.Plan = &plan
	} else {
		destination.Plan = nil
	}

	// PlatformFaultDomain
	destination.PlatformFaultDomain = genruntime.ClonePointerToInt(machine.PlatformFaultDomain)

	// Priority
	destination.Priority = genruntime.ClonePointerToString(machine.Priority)

	// ProximityPlacementGroup
	if machine.ProximityPlacementGroup != nil {
		var subResourceStash v20210701s.SubResource
		err := machine.ProximityPlacementGroup.AssignProperties_To_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from ProximityPlacementGroup")
		}
		var proximityPlacementGroup v20220301s.SubResource
		err = subResourceStash.AssignProperties_To_SubResource(&proximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field ProximityPlacementGroup from SubResourceStash")
		}
		destination.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		destination.ProximityPlacementGroup = nil
	}

	// ScheduledEventsProfile
	if propertyBag.Contains("ScheduledEventsProfile") {
		var scheduledEventsProfile v20220301s.ScheduledEventsProfile
		err := propertyBag.Pull("ScheduledEventsProfile", &scheduledEventsProfile)
		if err != nil {
			return errors.Wrap(err, "pulling 'ScheduledEventsProfile' from propertyBag")
		}

		destination.ScheduledEventsProfile = &scheduledEventsProfile
	} else {
		destination.ScheduledEventsProfile = nil
	}

	// SecurityProfile
	if machine.SecurityProfile != nil {
		var securityProfile v20220301s.SecurityProfile
		err := machine.SecurityProfile.AssignProperties_To_SecurityProfile(&securityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SecurityProfile() to populate field SecurityProfile")
		}
		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// StorageProfile
	if machine.StorageProfile != nil {
		var storageProfile v20220301s.StorageProfile
		err := machine.StorageProfile.AssignProperties_To_StorageProfile(&storageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_StorageProfile() to populate field StorageProfile")
		}
		destination.StorageProfile = &storageProfile
	} else {
		destination.StorageProfile = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(machine.Tags)

	// UserData
	if propertyBag.Contains("UserData") {
		var userDatum string
		err := propertyBag.Pull("UserData", &userDatum)
		if err != nil {
			return errors.Wrap(err, "pulling 'UserData' from propertyBag")
		}

		destination.UserData = &userDatum
	} else {
		destination.UserData = nil
	}

	// VirtualMachineScaleSet
	if machine.VirtualMachineScaleSet != nil {
		var subResourceStash v20210701s.SubResource
		err := machine.VirtualMachineScaleSet.AssignProperties_To_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from VirtualMachineScaleSet")
		}
		var virtualMachineScaleSet v20220301s.SubResource
		err = subResourceStash.AssignProperties_To_SubResource(&virtualMachineScaleSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field VirtualMachineScaleSet from SubResourceStash")
		}
		destination.VirtualMachineScaleSet = &virtualMachineScaleSet
	} else {
		destination.VirtualMachineScaleSet = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(machine.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachine_Spec interface (if implemented) to customize the conversion
	var machineAsAny any = machine
	if augmentedMachine, ok := machineAsAny.(augmentConversionForVirtualMachine_Spec); ok {
		err := augmentedMachine.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachine_STATUS
// Describes a Virtual Machine.
type VirtualMachine_STATUS struct {
	AdditionalCapabilities  *AdditionalCapabilities_STATUS     `json:"additionalCapabilities,omitempty"`
	AvailabilitySet         *SubResource_STATUS                `json:"availabilitySet,omitempty"`
	BillingProfile          *BillingProfile_STATUS             `json:"billingProfile,omitempty"`
	Conditions              []conditions.Condition             `json:"conditions,omitempty"`
	DiagnosticsProfile      *DiagnosticsProfile_STATUS         `json:"diagnosticsProfile,omitempty"`
	EvictionPolicy          *string                            `json:"evictionPolicy,omitempty"`
	ExtendedLocation        *ExtendedLocation_STATUS           `json:"extendedLocation,omitempty"`
	ExtensionsTimeBudget    *string                            `json:"extensionsTimeBudget,omitempty"`
	HardwareProfile         *HardwareProfile_STATUS            `json:"hardwareProfile,omitempty"`
	Host                    *SubResource_STATUS                `json:"host,omitempty"`
	HostGroup               *SubResource_STATUS                `json:"hostGroup,omitempty"`
	Id                      *string                            `json:"id,omitempty"`
	Identity                *VirtualMachineIdentity_STATUS     `json:"identity,omitempty"`
	InstanceView            *VirtualMachineInstanceView_STATUS `json:"instanceView,omitempty"`
	LicenseType             *string                            `json:"licenseType,omitempty"`
	Location                *string                            `json:"location,omitempty"`
	Name                    *string                            `json:"name,omitempty"`
	NetworkProfile          *NetworkProfile_STATUS             `json:"networkProfile,omitempty"`
	OsProfile               *OSProfile_STATUS                  `json:"osProfile,omitempty"`
	Plan                    *Plan_STATUS                       `json:"plan,omitempty"`
	PlatformFaultDomain     *int                               `json:"platformFaultDomain,omitempty"`
	Priority                *string                            `json:"priority,omitempty"`
	PropertyBag             genruntime.PropertyBag             `json:"$propertyBag,omitempty"`
	ProvisioningState       *string                            `json:"provisioningState,omitempty"`
	ProximityPlacementGroup *SubResource_STATUS                `json:"proximityPlacementGroup,omitempty"`
	Resources               []VirtualMachineExtension_STATUS   `json:"resources,omitempty"`
	SecurityProfile         *SecurityProfile_STATUS            `json:"securityProfile,omitempty"`
	StorageProfile          *StorageProfile_STATUS             `json:"storageProfile,omitempty"`
	Tags                    map[string]string                  `json:"tags,omitempty"`
	Type                    *string                            `json:"type,omitempty"`
	VirtualMachineScaleSet  *SubResource_STATUS                `json:"virtualMachineScaleSet,omitempty"`
	VmId                    *string                            `json:"vmId,omitempty"`
	Zones                   []string                           `json:"zones,omitempty"`
}

var _ genruntime.ConvertibleStatus = &VirtualMachine_STATUS{}

// ConvertStatusFrom populates our VirtualMachine_STATUS from the provided source
func (machine *VirtualMachine_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v20220301s.VirtualMachine_STATUS)
	if ok {
		// Populate our instance from source
		return machine.AssignProperties_From_VirtualMachine_STATUS(src)
	}

	// Convert to an intermediate form
	src = &v20220301s.VirtualMachine_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = machine.AssignProperties_From_VirtualMachine_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our VirtualMachine_STATUS
func (machine *VirtualMachine_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v20220301s.VirtualMachine_STATUS)
	if ok {
		// Populate destination from our instance
		return machine.AssignProperties_To_VirtualMachine_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &v20220301s.VirtualMachine_STATUS{}
	err := machine.AssignProperties_To_VirtualMachine_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

// AssignProperties_From_VirtualMachine_STATUS populates our VirtualMachine_STATUS from the provided source VirtualMachine_STATUS
func (machine *VirtualMachine_STATUS) AssignProperties_From_VirtualMachine_STATUS(source *v20220301s.VirtualMachine_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdditionalCapabilities
	if source.AdditionalCapabilities != nil {
		var additionalCapability AdditionalCapabilities_STATUS
		err := additionalCapability.AssignProperties_From_AdditionalCapabilities_STATUS(source.AdditionalCapabilities)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AdditionalCapabilities_STATUS() to populate field AdditionalCapabilities")
		}
		machine.AdditionalCapabilities = &additionalCapability
	} else {
		machine.AdditionalCapabilities = nil
	}

	// ApplicationProfile
	if source.ApplicationProfile != nil {
		propertyBag.Add("ApplicationProfile", *source.ApplicationProfile)
	} else {
		propertyBag.Remove("ApplicationProfile")
	}

	// AvailabilitySet
	if source.AvailabilitySet != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(source.AvailabilitySet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from AvailabilitySet")
		}
		var availabilitySet SubResource_STATUS
		err = availabilitySet.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field AvailabilitySet from SubResource_STATUSStash")
		}
		machine.AvailabilitySet = &availabilitySet
	} else {
		machine.AvailabilitySet = nil
	}

	// BillingProfile
	if source.BillingProfile != nil {
		var billingProfile BillingProfile_STATUS
		err := billingProfile.AssignProperties_From_BillingProfile_STATUS(source.BillingProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BillingProfile_STATUS() to populate field BillingProfile")
		}
		machine.BillingProfile = &billingProfile
	} else {
		machine.BillingProfile = nil
	}

	// CapacityReservation
	if source.CapacityReservation != nil {
		propertyBag.Add("CapacityReservation", *source.CapacityReservation)
	} else {
		propertyBag.Remove("CapacityReservation")
	}

	// Conditions
	machine.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// DiagnosticsProfile
	if source.DiagnosticsProfile != nil {
		var diagnosticsProfile DiagnosticsProfile_STATUS
		err := diagnosticsProfile.AssignProperties_From_DiagnosticsProfile_STATUS(source.DiagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DiagnosticsProfile_STATUS() to populate field DiagnosticsProfile")
		}
		machine.DiagnosticsProfile = &diagnosticsProfile
	} else {
		machine.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	machine.EvictionPolicy = genruntime.ClonePointerToString(source.EvictionPolicy)

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocationSTATUSStash v20210701s.ExtendedLocation_STATUS
		err := extendedLocationSTATUSStash.AssignProperties_From_ExtendedLocation_STATUS(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ExtendedLocation_STATUS() to populate field ExtendedLocation_STATUSStash from ExtendedLocation")
		}
		var extendedLocation ExtendedLocation_STATUS
		err = extendedLocation.AssignProperties_From_ExtendedLocation_STATUS(&extendedLocationSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ExtendedLocation_STATUS() to populate field ExtendedLocation from ExtendedLocation_STATUSStash")
		}
		machine.ExtendedLocation = &extendedLocation
	} else {
		machine.ExtendedLocation = nil
	}

	// ExtensionsTimeBudget
	machine.ExtensionsTimeBudget = genruntime.ClonePointerToString(source.ExtensionsTimeBudget)

	// HardwareProfile
	if source.HardwareProfile != nil {
		var hardwareProfile HardwareProfile_STATUS
		err := hardwareProfile.AssignProperties_From_HardwareProfile_STATUS(source.HardwareProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HardwareProfile_STATUS() to populate field HardwareProfile")
		}
		machine.HardwareProfile = &hardwareProfile
	} else {
		machine.HardwareProfile = nil
	}

	// Host
	if source.Host != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(source.Host)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from Host")
		}
		var host SubResource_STATUS
		err = host.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field Host from SubResource_STATUSStash")
		}
		machine.Host = &host
	} else {
		machine.Host = nil
	}

	// HostGroup
	if source.HostGroup != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(source.HostGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from HostGroup")
		}
		var hostGroup SubResource_STATUS
		err = hostGroup.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field HostGroup from SubResource_STATUSStash")
		}
		machine.HostGroup = &hostGroup
	} else {
		machine.HostGroup = nil
	}

	// Id
	machine.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity VirtualMachineIdentity_STATUS
		err := identity.AssignProperties_From_VirtualMachineIdentity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineIdentity_STATUS() to populate field Identity")
		}
		machine.Identity = &identity
	} else {
		machine.Identity = nil
	}

	// InstanceView
	if source.InstanceView != nil {
		var instanceView VirtualMachineInstanceView_STATUS
		err := instanceView.AssignProperties_From_VirtualMachineInstanceView_STATUS(source.InstanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineInstanceView_STATUS() to populate field InstanceView")
		}
		machine.InstanceView = &instanceView
	} else {
		machine.InstanceView = nil
	}

	// LicenseType
	machine.LicenseType = genruntime.ClonePointerToString(source.LicenseType)

	// Location
	machine.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	machine.Name = genruntime.ClonePointerToString(source.Name)

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile NetworkProfile_STATUS
		err := networkProfile.AssignProperties_From_NetworkProfile_STATUS(source.NetworkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_NetworkProfile_STATUS() to populate field NetworkProfile")
		}
		machine.NetworkProfile = &networkProfile
	} else {
		machine.NetworkProfile = nil
	}

	// OsProfile
	if source.OsProfile != nil {
		var osProfile OSProfile_STATUS
		err := osProfile.AssignProperties_From_OSProfile_STATUS(source.OsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OSProfile_STATUS() to populate field OsProfile")
		}
		machine.OsProfile = &osProfile
	} else {
		machine.OsProfile = nil
	}

	// Plan
	if source.Plan != nil {
		var plan Plan_STATUS
		err := plan.AssignProperties_From_Plan_STATUS(source.Plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Plan_STATUS() to populate field Plan")
		}
		machine.Plan = &plan
	} else {
		machine.Plan = nil
	}

	// PlatformFaultDomain
	machine.PlatformFaultDomain = genruntime.ClonePointerToInt(source.PlatformFaultDomain)

	// Priority
	machine.Priority = genruntime.ClonePointerToString(source.Priority)

	// ProvisioningState
	machine.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// ProximityPlacementGroup
	if source.ProximityPlacementGroup != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(source.ProximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from ProximityPlacementGroup")
		}
		var proximityPlacementGroup SubResource_STATUS
		err = proximityPlacementGroup.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field ProximityPlacementGroup from SubResource_STATUSStash")
		}
		machine.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		machine.ProximityPlacementGroup = nil
	}

	// Resources
	if source.Resources != nil {
		resourceList := make([]VirtualMachineExtension_STATUS, len(source.Resources))
		for resourceIndex, resourceItem := range source.Resources {
			// Shadow the loop variable to avoid aliasing
			resourceItem := resourceItem
			var resource VirtualMachineExtension_STATUS
			err := resource.AssignProperties_From_VirtualMachineExtension_STATUS(&resourceItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineExtension_STATUS() to populate field Resources")
			}
			resourceList[resourceIndex] = resource
		}
		machine.Resources = resourceList
	} else {
		machine.Resources = nil
	}

	// ScheduledEventsProfile
	if source.ScheduledEventsProfile != nil {
		propertyBag.Add("ScheduledEventsProfile", *source.ScheduledEventsProfile)
	} else {
		propertyBag.Remove("ScheduledEventsProfile")
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		var securityProfile SecurityProfile_STATUS
		err := securityProfile.AssignProperties_From_SecurityProfile_STATUS(source.SecurityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SecurityProfile_STATUS() to populate field SecurityProfile")
		}
		machine.SecurityProfile = &securityProfile
	} else {
		machine.SecurityProfile = nil
	}

	// StorageProfile
	if source.StorageProfile != nil {
		var storageProfile StorageProfile_STATUS
		err := storageProfile.AssignProperties_From_StorageProfile_STATUS(source.StorageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_StorageProfile_STATUS() to populate field StorageProfile")
		}
		machine.StorageProfile = &storageProfile
	} else {
		machine.StorageProfile = nil
	}

	// Tags
	machine.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TimeCreated
	if source.TimeCreated != nil {
		propertyBag.Add("TimeCreated", *source.TimeCreated)
	} else {
		propertyBag.Remove("TimeCreated")
	}

	// Type
	machine.Type = genruntime.ClonePointerToString(source.Type)

	// UserData
	if source.UserData != nil {
		propertyBag.Add("UserData", *source.UserData)
	} else {
		propertyBag.Remove("UserData")
	}

	// VirtualMachineScaleSet
	if source.VirtualMachineScaleSet != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(source.VirtualMachineScaleSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from VirtualMachineScaleSet")
		}
		var virtualMachineScaleSet SubResource_STATUS
		err = virtualMachineScaleSet.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field VirtualMachineScaleSet from SubResource_STATUSStash")
		}
		machine.VirtualMachineScaleSet = &virtualMachineScaleSet
	} else {
		machine.VirtualMachineScaleSet = nil
	}

	// VmId
	machine.VmId = genruntime.ClonePointerToString(source.VmId)

	// Zones
	machine.Zones = genruntime.CloneSliceOfString(source.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		machine.PropertyBag = propertyBag
	} else {
		machine.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachine_STATUS interface (if implemented) to customize the conversion
	var machineAsAny any = machine
	if augmentedMachine, ok := machineAsAny.(augmentConversionForVirtualMachine_STATUS); ok {
		err := augmentedMachine.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachine_STATUS populates the provided destination VirtualMachine_STATUS from our VirtualMachine_STATUS
func (machine *VirtualMachine_STATUS) AssignProperties_To_VirtualMachine_STATUS(destination *v20220301s.VirtualMachine_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(machine.PropertyBag)

	// AdditionalCapabilities
	if machine.AdditionalCapabilities != nil {
		var additionalCapability v20220301s.AdditionalCapabilities_STATUS
		err := machine.AdditionalCapabilities.AssignProperties_To_AdditionalCapabilities_STATUS(&additionalCapability)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AdditionalCapabilities_STATUS() to populate field AdditionalCapabilities")
		}
		destination.AdditionalCapabilities = &additionalCapability
	} else {
		destination.AdditionalCapabilities = nil
	}

	// ApplicationProfile
	if propertyBag.Contains("ApplicationProfile") {
		var applicationProfile v20220301s.ApplicationProfile_STATUS
		err := propertyBag.Pull("ApplicationProfile", &applicationProfile)
		if err != nil {
			return errors.Wrap(err, "pulling 'ApplicationProfile' from propertyBag")
		}

		destination.ApplicationProfile = &applicationProfile
	} else {
		destination.ApplicationProfile = nil
	}

	// AvailabilitySet
	if machine.AvailabilitySet != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := machine.AvailabilitySet.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from AvailabilitySet")
		}
		var availabilitySet v20220301s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&availabilitySet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field AvailabilitySet from SubResource_STATUSStash")
		}
		destination.AvailabilitySet = &availabilitySet
	} else {
		destination.AvailabilitySet = nil
	}

	// BillingProfile
	if machine.BillingProfile != nil {
		var billingProfile v20220301s.BillingProfile_STATUS
		err := machine.BillingProfile.AssignProperties_To_BillingProfile_STATUS(&billingProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BillingProfile_STATUS() to populate field BillingProfile")
		}
		destination.BillingProfile = &billingProfile
	} else {
		destination.BillingProfile = nil
	}

	// CapacityReservation
	if propertyBag.Contains("CapacityReservation") {
		var capacityReservation v20220301s.CapacityReservationProfile_STATUS
		err := propertyBag.Pull("CapacityReservation", &capacityReservation)
		if err != nil {
			return errors.Wrap(err, "pulling 'CapacityReservation' from propertyBag")
		}

		destination.CapacityReservation = &capacityReservation
	} else {
		destination.CapacityReservation = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(machine.Conditions)

	// DiagnosticsProfile
	if machine.DiagnosticsProfile != nil {
		var diagnosticsProfile v20220301s.DiagnosticsProfile_STATUS
		err := machine.DiagnosticsProfile.AssignProperties_To_DiagnosticsProfile_STATUS(&diagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DiagnosticsProfile_STATUS() to populate field DiagnosticsProfile")
		}
		destination.DiagnosticsProfile = &diagnosticsProfile
	} else {
		destination.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	destination.EvictionPolicy = genruntime.ClonePointerToString(machine.EvictionPolicy)

	// ExtendedLocation
	if machine.ExtendedLocation != nil {
		var extendedLocationSTATUSStash v20210701s.ExtendedLocation_STATUS
		err := machine.ExtendedLocation.AssignProperties_To_ExtendedLocation_STATUS(&extendedLocationSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ExtendedLocation_STATUS() to populate field ExtendedLocation_STATUSStash from ExtendedLocation")
		}
		var extendedLocation v20220301s.ExtendedLocation_STATUS
		err = extendedLocationSTATUSStash.AssignProperties_To_ExtendedLocation_STATUS(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ExtendedLocation_STATUS() to populate field ExtendedLocation from ExtendedLocation_STATUSStash")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// ExtensionsTimeBudget
	destination.ExtensionsTimeBudget = genruntime.ClonePointerToString(machine.ExtensionsTimeBudget)

	// HardwareProfile
	if machine.HardwareProfile != nil {
		var hardwareProfile v20220301s.HardwareProfile_STATUS
		err := machine.HardwareProfile.AssignProperties_To_HardwareProfile_STATUS(&hardwareProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HardwareProfile_STATUS() to populate field HardwareProfile")
		}
		destination.HardwareProfile = &hardwareProfile
	} else {
		destination.HardwareProfile = nil
	}

	// Host
	if machine.Host != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := machine.Host.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from Host")
		}
		var host v20220301s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&host)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field Host from SubResource_STATUSStash")
		}
		destination.Host = &host
	} else {
		destination.Host = nil
	}

	// HostGroup
	if machine.HostGroup != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := machine.HostGroup.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from HostGroup")
		}
		var hostGroup v20220301s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&hostGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field HostGroup from SubResource_STATUSStash")
		}
		destination.HostGroup = &hostGroup
	} else {
		destination.HostGroup = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(machine.Id)

	// Identity
	if machine.Identity != nil {
		var identity v20220301s.VirtualMachineIdentity_STATUS
		err := machine.Identity.AssignProperties_To_VirtualMachineIdentity_STATUS(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// InstanceView
	if machine.InstanceView != nil {
		var instanceView v20220301s.VirtualMachineInstanceView_STATUS
		err := machine.InstanceView.AssignProperties_To_VirtualMachineInstanceView_STATUS(&instanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineInstanceView_STATUS() to populate field InstanceView")
		}
		destination.InstanceView = &instanceView
	} else {
		destination.InstanceView = nil
	}

	// LicenseType
	destination.LicenseType = genruntime.ClonePointerToString(machine.LicenseType)

	// Location
	destination.Location = genruntime.ClonePointerToString(machine.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(machine.Name)

	// NetworkProfile
	if machine.NetworkProfile != nil {
		var networkProfile v20220301s.NetworkProfile_STATUS
		err := machine.NetworkProfile.AssignProperties_To_NetworkProfile_STATUS(&networkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_NetworkProfile_STATUS() to populate field NetworkProfile")
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// OsProfile
	if machine.OsProfile != nil {
		var osProfile v20220301s.OSProfile_STATUS
		err := machine.OsProfile.AssignProperties_To_OSProfile_STATUS(&osProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OSProfile_STATUS() to populate field OsProfile")
		}
		destination.OsProfile = &osProfile
	} else {
		destination.OsProfile = nil
	}

	// Plan
	if machine.Plan != nil {
		var plan v20220301s.Plan_STATUS
		err := machine.Plan.AssignProperties_To_Plan_STATUS(&plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Plan_STATUS() to populate field Plan")
		}
		destination.Plan = &plan
	} else {
		destination.Plan = nil
	}

	// PlatformFaultDomain
	destination.PlatformFaultDomain = genruntime.ClonePointerToInt(machine.PlatformFaultDomain)

	// Priority
	destination.Priority = genruntime.ClonePointerToString(machine.Priority)

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(machine.ProvisioningState)

	// ProximityPlacementGroup
	if machine.ProximityPlacementGroup != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := machine.ProximityPlacementGroup.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from ProximityPlacementGroup")
		}
		var proximityPlacementGroup v20220301s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&proximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field ProximityPlacementGroup from SubResource_STATUSStash")
		}
		destination.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		destination.ProximityPlacementGroup = nil
	}

	// Resources
	if machine.Resources != nil {
		resourceList := make([]v20220301s.VirtualMachineExtension_STATUS, len(machine.Resources))
		for resourceIndex, resourceItem := range machine.Resources {
			// Shadow the loop variable to avoid aliasing
			resourceItem := resourceItem
			var resource v20220301s.VirtualMachineExtension_STATUS
			err := resourceItem.AssignProperties_To_VirtualMachineExtension_STATUS(&resource)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineExtension_STATUS() to populate field Resources")
			}
			resourceList[resourceIndex] = resource
		}
		destination.Resources = resourceList
	} else {
		destination.Resources = nil
	}

	// ScheduledEventsProfile
	if propertyBag.Contains("ScheduledEventsProfile") {
		var scheduledEventsProfile v20220301s.ScheduledEventsProfile_STATUS
		err := propertyBag.Pull("ScheduledEventsProfile", &scheduledEventsProfile)
		if err != nil {
			return errors.Wrap(err, "pulling 'ScheduledEventsProfile' from propertyBag")
		}

		destination.ScheduledEventsProfile = &scheduledEventsProfile
	} else {
		destination.ScheduledEventsProfile = nil
	}

	// SecurityProfile
	if machine.SecurityProfile != nil {
		var securityProfile v20220301s.SecurityProfile_STATUS
		err := machine.SecurityProfile.AssignProperties_To_SecurityProfile_STATUS(&securityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SecurityProfile_STATUS() to populate field SecurityProfile")
		}
		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// StorageProfile
	if machine.StorageProfile != nil {
		var storageProfile v20220301s.StorageProfile_STATUS
		err := machine.StorageProfile.AssignProperties_To_StorageProfile_STATUS(&storageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_StorageProfile_STATUS() to populate field StorageProfile")
		}
		destination.StorageProfile = &storageProfile
	} else {
		destination.StorageProfile = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(machine.Tags)

	// TimeCreated
	if propertyBag.Contains("TimeCreated") {
		var timeCreated string
		err := propertyBag.Pull("TimeCreated", &timeCreated)
		if err != nil {
			return errors.Wrap(err, "pulling 'TimeCreated' from propertyBag")
		}

		destination.TimeCreated = &timeCreated
	} else {
		destination.TimeCreated = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(machine.Type)

	// UserData
	if propertyBag.Contains("UserData") {
		var userDatum string
		err := propertyBag.Pull("UserData", &userDatum)
		if err != nil {
			return errors.Wrap(err, "pulling 'UserData' from propertyBag")
		}

		destination.UserData = &userDatum
	} else {
		destination.UserData = nil
	}

	// VirtualMachineScaleSet
	if machine.VirtualMachineScaleSet != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := machine.VirtualMachineScaleSet.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from VirtualMachineScaleSet")
		}
		var virtualMachineScaleSet v20220301s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&virtualMachineScaleSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field VirtualMachineScaleSet from SubResource_STATUSStash")
		}
		destination.VirtualMachineScaleSet = &virtualMachineScaleSet
	} else {
		destination.VirtualMachineScaleSet = nil
	}

	// VmId
	destination.VmId = genruntime.ClonePointerToString(machine.VmId)

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(machine.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachine_STATUS interface (if implemented) to customize the conversion
	var machineAsAny any = machine
	if augmentedMachine, ok := machineAsAny.(augmentConversionForVirtualMachine_STATUS); ok {
		err := augmentedMachine.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.AdditionalCapabilities
// Enables or disables a capability on the virtual machine or virtual machine scale set.
type AdditionalCapabilities struct {
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	UltraSSDEnabled *bool                  `json:"ultraSSDEnabled,omitempty"`
}

// AssignProperties_From_AdditionalCapabilities populates our AdditionalCapabilities from the provided source AdditionalCapabilities
func (capabilities *AdditionalCapabilities) AssignProperties_From_AdditionalCapabilities(source *v20220301s.AdditionalCapabilities) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// HibernationEnabled
	if source.HibernationEnabled != nil {
		propertyBag.Add("HibernationEnabled", *source.HibernationEnabled)
	} else {
		propertyBag.Remove("HibernationEnabled")
	}

	// UltraSSDEnabled
	if source.UltraSSDEnabled != nil {
		ultraSSDEnabled := *source.UltraSSDEnabled
		capabilities.UltraSSDEnabled = &ultraSSDEnabled
	} else {
		capabilities.UltraSSDEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		capabilities.PropertyBag = propertyBag
	} else {
		capabilities.PropertyBag = nil
	}

	// Invoke the augmentConversionForAdditionalCapabilities interface (if implemented) to customize the conversion
	var capabilitiesAsAny any = capabilities
	if augmentedCapabilities, ok := capabilitiesAsAny.(augmentConversionForAdditionalCapabilities); ok {
		err := augmentedCapabilities.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AdditionalCapabilities populates the provided destination AdditionalCapabilities from our AdditionalCapabilities
func (capabilities *AdditionalCapabilities) AssignProperties_To_AdditionalCapabilities(destination *v20220301s.AdditionalCapabilities) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(capabilities.PropertyBag)

	// HibernationEnabled
	if propertyBag.Contains("HibernationEnabled") {
		var hibernationEnabled bool
		err := propertyBag.Pull("HibernationEnabled", &hibernationEnabled)
		if err != nil {
			return errors.Wrap(err, "pulling 'HibernationEnabled' from propertyBag")
		}

		destination.HibernationEnabled = &hibernationEnabled
	} else {
		destination.HibernationEnabled = nil
	}

	// UltraSSDEnabled
	if capabilities.UltraSSDEnabled != nil {
		ultraSSDEnabled := *capabilities.UltraSSDEnabled
		destination.UltraSSDEnabled = &ultraSSDEnabled
	} else {
		destination.UltraSSDEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAdditionalCapabilities interface (if implemented) to customize the conversion
	var capabilitiesAsAny any = capabilities
	if augmentedCapabilities, ok := capabilitiesAsAny.(augmentConversionForAdditionalCapabilities); ok {
		err := augmentedCapabilities.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.AdditionalCapabilities_STATUS
// Enables or disables a capability on the virtual machine or virtual machine scale set.
type AdditionalCapabilities_STATUS struct {
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	UltraSSDEnabled *bool                  `json:"ultraSSDEnabled,omitempty"`
}

// AssignProperties_From_AdditionalCapabilities_STATUS populates our AdditionalCapabilities_STATUS from the provided source AdditionalCapabilities_STATUS
func (capabilities *AdditionalCapabilities_STATUS) AssignProperties_From_AdditionalCapabilities_STATUS(source *v20220301s.AdditionalCapabilities_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// HibernationEnabled
	if source.HibernationEnabled != nil {
		propertyBag.Add("HibernationEnabled", *source.HibernationEnabled)
	} else {
		propertyBag.Remove("HibernationEnabled")
	}

	// UltraSSDEnabled
	if source.UltraSSDEnabled != nil {
		ultraSSDEnabled := *source.UltraSSDEnabled
		capabilities.UltraSSDEnabled = &ultraSSDEnabled
	} else {
		capabilities.UltraSSDEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		capabilities.PropertyBag = propertyBag
	} else {
		capabilities.PropertyBag = nil
	}

	// Invoke the augmentConversionForAdditionalCapabilities_STATUS interface (if implemented) to customize the conversion
	var capabilitiesAsAny any = capabilities
	if augmentedCapabilities, ok := capabilitiesAsAny.(augmentConversionForAdditionalCapabilities_STATUS); ok {
		err := augmentedCapabilities.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AdditionalCapabilities_STATUS populates the provided destination AdditionalCapabilities_STATUS from our AdditionalCapabilities_STATUS
func (capabilities *AdditionalCapabilities_STATUS) AssignProperties_To_AdditionalCapabilities_STATUS(destination *v20220301s.AdditionalCapabilities_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(capabilities.PropertyBag)

	// HibernationEnabled
	if propertyBag.Contains("HibernationEnabled") {
		var hibernationEnabled bool
		err := propertyBag.Pull("HibernationEnabled", &hibernationEnabled)
		if err != nil {
			return errors.Wrap(err, "pulling 'HibernationEnabled' from propertyBag")
		}

		destination.HibernationEnabled = &hibernationEnabled
	} else {
		destination.HibernationEnabled = nil
	}

	// UltraSSDEnabled
	if capabilities.UltraSSDEnabled != nil {
		ultraSSDEnabled := *capabilities.UltraSSDEnabled
		destination.UltraSSDEnabled = &ultraSSDEnabled
	} else {
		destination.UltraSSDEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAdditionalCapabilities_STATUS interface (if implemented) to customize the conversion
	var capabilitiesAsAny any = capabilities
	if augmentedCapabilities, ok := capabilitiesAsAny.(augmentConversionForAdditionalCapabilities_STATUS); ok {
		err := augmentedCapabilities.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForVirtualMachine_Spec interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachine_Spec) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachine_Spec) error
}

type augmentConversionForVirtualMachine_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachine_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachine_STATUS) error
}

// Storage version of v1api20201201.BillingProfile
// Specifies the billing related details of a Azure Spot VM or VMSS.
// Minimum api-version: 2019-03-01.
type BillingProfile struct {
	MaxPrice    *float64               `json:"maxPrice,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_BillingProfile populates our BillingProfile from the provided source BillingProfile
func (profile *BillingProfile) AssignProperties_From_BillingProfile(source *v20220301s.BillingProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MaxPrice
	if source.MaxPrice != nil {
		maxPrice := *source.MaxPrice
		profile.MaxPrice = &maxPrice
	} else {
		profile.MaxPrice = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForBillingProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForBillingProfile); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_BillingProfile populates the provided destination BillingProfile from our BillingProfile
func (profile *BillingProfile) AssignProperties_To_BillingProfile(destination *v20220301s.BillingProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// MaxPrice
	if profile.MaxPrice != nil {
		maxPrice := *profile.MaxPrice
		destination.MaxPrice = &maxPrice
	} else {
		destination.MaxPrice = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForBillingProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForBillingProfile); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.BillingProfile_STATUS
// Specifies the billing related details of a Azure Spot VM or VMSS.
// Minimum api-version: 2019-03-01.
type BillingProfile_STATUS struct {
	MaxPrice    *float64               `json:"maxPrice,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_BillingProfile_STATUS populates our BillingProfile_STATUS from the provided source BillingProfile_STATUS
func (profile *BillingProfile_STATUS) AssignProperties_From_BillingProfile_STATUS(source *v20220301s.BillingProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MaxPrice
	if source.MaxPrice != nil {
		maxPrice := *source.MaxPrice
		profile.MaxPrice = &maxPrice
	} else {
		profile.MaxPrice = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForBillingProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForBillingProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_BillingProfile_STATUS populates the provided destination BillingProfile_STATUS from our BillingProfile_STATUS
func (profile *BillingProfile_STATUS) AssignProperties_To_BillingProfile_STATUS(destination *v20220301s.BillingProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// MaxPrice
	if profile.MaxPrice != nil {
		maxPrice := *profile.MaxPrice
		destination.MaxPrice = &maxPrice
	} else {
		destination.MaxPrice = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForBillingProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForBillingProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.DiagnosticsProfile
// Specifies the boot diagnostic settings state.
// Minimum api-version: 2015-06-15.
type DiagnosticsProfile struct {
	BootDiagnostics *BootDiagnostics       `json:"bootDiagnostics,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DiagnosticsProfile populates our DiagnosticsProfile from the provided source DiagnosticsProfile
func (profile *DiagnosticsProfile) AssignProperties_From_DiagnosticsProfile(source *v20220301s.DiagnosticsProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// BootDiagnostics
	if source.BootDiagnostics != nil {
		var bootDiagnostic BootDiagnostics
		err := bootDiagnostic.AssignProperties_From_BootDiagnostics(source.BootDiagnostics)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BootDiagnostics() to populate field BootDiagnostics")
		}
		profile.BootDiagnostics = &bootDiagnostic
	} else {
		profile.BootDiagnostics = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForDiagnosticsProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForDiagnosticsProfile); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DiagnosticsProfile populates the provided destination DiagnosticsProfile from our DiagnosticsProfile
func (profile *DiagnosticsProfile) AssignProperties_To_DiagnosticsProfile(destination *v20220301s.DiagnosticsProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// BootDiagnostics
	if profile.BootDiagnostics != nil {
		var bootDiagnostic v20220301s.BootDiagnostics
		err := profile.BootDiagnostics.AssignProperties_To_BootDiagnostics(&bootDiagnostic)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BootDiagnostics() to populate field BootDiagnostics")
		}
		destination.BootDiagnostics = &bootDiagnostic
	} else {
		destination.BootDiagnostics = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDiagnosticsProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForDiagnosticsProfile); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.DiagnosticsProfile_STATUS
// Specifies the boot diagnostic settings state.
// Minimum api-version: 2015-06-15.
type DiagnosticsProfile_STATUS struct {
	BootDiagnostics *BootDiagnostics_STATUS `json:"bootDiagnostics,omitempty"`
	PropertyBag     genruntime.PropertyBag  `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DiagnosticsProfile_STATUS populates our DiagnosticsProfile_STATUS from the provided source DiagnosticsProfile_STATUS
func (profile *DiagnosticsProfile_STATUS) AssignProperties_From_DiagnosticsProfile_STATUS(source *v20220301s.DiagnosticsProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// BootDiagnostics
	if source.BootDiagnostics != nil {
		var bootDiagnostic BootDiagnostics_STATUS
		err := bootDiagnostic.AssignProperties_From_BootDiagnostics_STATUS(source.BootDiagnostics)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BootDiagnostics_STATUS() to populate field BootDiagnostics")
		}
		profile.BootDiagnostics = &bootDiagnostic
	} else {
		profile.BootDiagnostics = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForDiagnosticsProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForDiagnosticsProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DiagnosticsProfile_STATUS populates the provided destination DiagnosticsProfile_STATUS from our DiagnosticsProfile_STATUS
func (profile *DiagnosticsProfile_STATUS) AssignProperties_To_DiagnosticsProfile_STATUS(destination *v20220301s.DiagnosticsProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// BootDiagnostics
	if profile.BootDiagnostics != nil {
		var bootDiagnostic v20220301s.BootDiagnostics_STATUS
		err := profile.BootDiagnostics.AssignProperties_To_BootDiagnostics_STATUS(&bootDiagnostic)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BootDiagnostics_STATUS() to populate field BootDiagnostics")
		}
		destination.BootDiagnostics = &bootDiagnostic
	} else {
		destination.BootDiagnostics = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDiagnosticsProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForDiagnosticsProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.ExtendedLocation
// The complex type of the extended location.
type ExtendedLocation struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Type        *string                `json:"type,omitempty"`
}

// AssignProperties_From_ExtendedLocation populates our ExtendedLocation from the provided source ExtendedLocation
func (location *ExtendedLocation) AssignProperties_From_ExtendedLocation(source *v20210701s.ExtendedLocation) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	location.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	location.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		location.PropertyBag = propertyBag
	} else {
		location.PropertyBag = nil
	}

	// Invoke the augmentConversionForExtendedLocation interface (if implemented) to customize the conversion
	var locationAsAny any = location
	if augmentedLocation, ok := locationAsAny.(augmentConversionForExtendedLocation); ok {
		err := augmentedLocation.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ExtendedLocation populates the provided destination ExtendedLocation from our ExtendedLocation
func (location *ExtendedLocation) AssignProperties_To_ExtendedLocation(destination *v20210701s.ExtendedLocation) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(location.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(location.Name)

	// Type
	destination.Type = genruntime.ClonePointerToString(location.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForExtendedLocation interface (if implemented) to customize the conversion
	var locationAsAny any = location
	if augmentedLocation, ok := locationAsAny.(augmentConversionForExtendedLocation); ok {
		err := augmentedLocation.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.ExtendedLocation_STATUS
// The complex type of the extended location.
type ExtendedLocation_STATUS struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Type        *string                `json:"type,omitempty"`
}

// AssignProperties_From_ExtendedLocation_STATUS populates our ExtendedLocation_STATUS from the provided source ExtendedLocation_STATUS
func (location *ExtendedLocation_STATUS) AssignProperties_From_ExtendedLocation_STATUS(source *v20210701s.ExtendedLocation_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	location.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	location.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		location.PropertyBag = propertyBag
	} else {
		location.PropertyBag = nil
	}

	// Invoke the augmentConversionForExtendedLocation_STATUS interface (if implemented) to customize the conversion
	var locationAsAny any = location
	if augmentedLocation, ok := locationAsAny.(augmentConversionForExtendedLocation_STATUS); ok {
		err := augmentedLocation.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ExtendedLocation_STATUS populates the provided destination ExtendedLocation_STATUS from our ExtendedLocation_STATUS
func (location *ExtendedLocation_STATUS) AssignProperties_To_ExtendedLocation_STATUS(destination *v20210701s.ExtendedLocation_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(location.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(location.Name)

	// Type
	destination.Type = genruntime.ClonePointerToString(location.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForExtendedLocation_STATUS interface (if implemented) to customize the conversion
	var locationAsAny any = location
	if augmentedLocation, ok := locationAsAny.(augmentConversionForExtendedLocation_STATUS); ok {
		err := augmentedLocation.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.HardwareProfile
// Specifies the hardware settings for the virtual machine.
type HardwareProfile struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	VmSize      *string                `json:"vmSize,omitempty"`
}

// AssignProperties_From_HardwareProfile populates our HardwareProfile from the provided source HardwareProfile
func (profile *HardwareProfile) AssignProperties_From_HardwareProfile(source *v20220301s.HardwareProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// VmSize
	profile.VmSize = genruntime.ClonePointerToString(source.VmSize)

	// VmSizeProperties
	if source.VmSizeProperties != nil {
		propertyBag.Add("VmSizeProperties", *source.VmSizeProperties)
	} else {
		propertyBag.Remove("VmSizeProperties")
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForHardwareProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForHardwareProfile); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_HardwareProfile populates the provided destination HardwareProfile from our HardwareProfile
func (profile *HardwareProfile) AssignProperties_To_HardwareProfile(destination *v20220301s.HardwareProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// VmSize
	destination.VmSize = genruntime.ClonePointerToString(profile.VmSize)

	// VmSizeProperties
	if propertyBag.Contains("VmSizeProperties") {
		var vmSizeProperty v20220301s.VMSizeProperties
		err := propertyBag.Pull("VmSizeProperties", &vmSizeProperty)
		if err != nil {
			return errors.Wrap(err, "pulling 'VmSizeProperties' from propertyBag")
		}

		destination.VmSizeProperties = &vmSizeProperty
	} else {
		destination.VmSizeProperties = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForHardwareProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForHardwareProfile); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.HardwareProfile_STATUS
// Specifies the hardware settings for the virtual machine.
type HardwareProfile_STATUS struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	VmSize      *string                `json:"vmSize,omitempty"`
}

// AssignProperties_From_HardwareProfile_STATUS populates our HardwareProfile_STATUS from the provided source HardwareProfile_STATUS
func (profile *HardwareProfile_STATUS) AssignProperties_From_HardwareProfile_STATUS(source *v20220301s.HardwareProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// VmSize
	profile.VmSize = genruntime.ClonePointerToString(source.VmSize)

	// VmSizeProperties
	if source.VmSizeProperties != nil {
		propertyBag.Add("VmSizeProperties", *source.VmSizeProperties)
	} else {
		propertyBag.Remove("VmSizeProperties")
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForHardwareProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForHardwareProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_HardwareProfile_STATUS populates the provided destination HardwareProfile_STATUS from our HardwareProfile_STATUS
func (profile *HardwareProfile_STATUS) AssignProperties_To_HardwareProfile_STATUS(destination *v20220301s.HardwareProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// VmSize
	destination.VmSize = genruntime.ClonePointerToString(profile.VmSize)

	// VmSizeProperties
	if propertyBag.Contains("VmSizeProperties") {
		var vmSizeProperty v20220301s.VMSizeProperties_STATUS
		err := propertyBag.Pull("VmSizeProperties", &vmSizeProperty)
		if err != nil {
			return errors.Wrap(err, "pulling 'VmSizeProperties' from propertyBag")
		}

		destination.VmSizeProperties = &vmSizeProperty
	} else {
		destination.VmSizeProperties = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForHardwareProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForHardwareProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.NetworkProfile
// Specifies the network interfaces of the virtual machine.
type NetworkProfile struct {
	NetworkInterfaces []NetworkInterfaceReference `json:"networkInterfaces,omitempty"`
	PropertyBag       genruntime.PropertyBag      `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_NetworkProfile populates our NetworkProfile from the provided source NetworkProfile
func (profile *NetworkProfile) AssignProperties_From_NetworkProfile(source *v20220301s.NetworkProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// NetworkApiVersion
	if source.NetworkApiVersion != nil {
		propertyBag.Add("NetworkApiVersion", *source.NetworkApiVersion)
	} else {
		propertyBag.Remove("NetworkApiVersion")
	}

	// NetworkInterfaceConfigurations
	if len(source.NetworkInterfaceConfigurations) > 0 {
		propertyBag.Add("NetworkInterfaceConfigurations", source.NetworkInterfaceConfigurations)
	} else {
		propertyBag.Remove("NetworkInterfaceConfigurations")
	}

	// NetworkInterfaces
	if source.NetworkInterfaces != nil {
		networkInterfaceList := make([]NetworkInterfaceReference, len(source.NetworkInterfaces))
		for networkInterfaceIndex, networkInterfaceItem := range source.NetworkInterfaces {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceItem := networkInterfaceItem
			var networkInterface NetworkInterfaceReference
			err := networkInterface.AssignProperties_From_NetworkInterfaceReference(&networkInterfaceItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_NetworkInterfaceReference() to populate field NetworkInterfaces")
			}
			networkInterfaceList[networkInterfaceIndex] = networkInterface
		}
		profile.NetworkInterfaces = networkInterfaceList
	} else {
		profile.NetworkInterfaces = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForNetworkProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForNetworkProfile); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_NetworkProfile populates the provided destination NetworkProfile from our NetworkProfile
func (profile *NetworkProfile) AssignProperties_To_NetworkProfile(destination *v20220301s.NetworkProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// NetworkApiVersion
	if propertyBag.Contains("NetworkApiVersion") {
		var networkApiVersion string
		err := propertyBag.Pull("NetworkApiVersion", &networkApiVersion)
		if err != nil {
			return errors.Wrap(err, "pulling 'NetworkApiVersion' from propertyBag")
		}

		destination.NetworkApiVersion = &networkApiVersion
	} else {
		destination.NetworkApiVersion = nil
	}

	// NetworkInterfaceConfigurations
	if propertyBag.Contains("NetworkInterfaceConfigurations") {
		var networkInterfaceConfiguration []v20220301s.VirtualMachineNetworkInterfaceConfiguration
		err := propertyBag.Pull("NetworkInterfaceConfigurations", &networkInterfaceConfiguration)
		if err != nil {
			return errors.Wrap(err, "pulling 'NetworkInterfaceConfigurations' from propertyBag")
		}

		destination.NetworkInterfaceConfigurations = networkInterfaceConfiguration
	} else {
		destination.NetworkInterfaceConfigurations = nil
	}

	// NetworkInterfaces
	if profile.NetworkInterfaces != nil {
		networkInterfaceList := make([]v20220301s.NetworkInterfaceReference, len(profile.NetworkInterfaces))
		for networkInterfaceIndex, networkInterfaceItem := range profile.NetworkInterfaces {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceItem := networkInterfaceItem
			var networkInterface v20220301s.NetworkInterfaceReference
			err := networkInterfaceItem.AssignProperties_To_NetworkInterfaceReference(&networkInterface)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_NetworkInterfaceReference() to populate field NetworkInterfaces")
			}
			networkInterfaceList[networkInterfaceIndex] = networkInterface
		}
		destination.NetworkInterfaces = networkInterfaceList
	} else {
		destination.NetworkInterfaces = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForNetworkProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForNetworkProfile); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.NetworkProfile_STATUS
// Specifies the network interfaces of the virtual machine.
type NetworkProfile_STATUS struct {
	NetworkInterfaces []NetworkInterfaceReference_STATUS `json:"networkInterfaces,omitempty"`
	PropertyBag       genruntime.PropertyBag             `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_NetworkProfile_STATUS populates our NetworkProfile_STATUS from the provided source NetworkProfile_STATUS
func (profile *NetworkProfile_STATUS) AssignProperties_From_NetworkProfile_STATUS(source *v20220301s.NetworkProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// NetworkApiVersion
	if source.NetworkApiVersion != nil {
		propertyBag.Add("NetworkApiVersion", *source.NetworkApiVersion)
	} else {
		propertyBag.Remove("NetworkApiVersion")
	}

	// NetworkInterfaceConfigurations
	if len(source.NetworkInterfaceConfigurations) > 0 {
		propertyBag.Add("NetworkInterfaceConfigurations", source.NetworkInterfaceConfigurations)
	} else {
		propertyBag.Remove("NetworkInterfaceConfigurations")
	}

	// NetworkInterfaces
	if source.NetworkInterfaces != nil {
		networkInterfaceList := make([]NetworkInterfaceReference_STATUS, len(source.NetworkInterfaces))
		for networkInterfaceIndex, networkInterfaceItem := range source.NetworkInterfaces {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceItem := networkInterfaceItem
			var networkInterface NetworkInterfaceReference_STATUS
			err := networkInterface.AssignProperties_From_NetworkInterfaceReference_STATUS(&networkInterfaceItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_NetworkInterfaceReference_STATUS() to populate field NetworkInterfaces")
			}
			networkInterfaceList[networkInterfaceIndex] = networkInterface
		}
		profile.NetworkInterfaces = networkInterfaceList
	} else {
		profile.NetworkInterfaces = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForNetworkProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForNetworkProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_NetworkProfile_STATUS populates the provided destination NetworkProfile_STATUS from our NetworkProfile_STATUS
func (profile *NetworkProfile_STATUS) AssignProperties_To_NetworkProfile_STATUS(destination *v20220301s.NetworkProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// NetworkApiVersion
	if propertyBag.Contains("NetworkApiVersion") {
		var networkApiVersion string
		err := propertyBag.Pull("NetworkApiVersion", &networkApiVersion)
		if err != nil {
			return errors.Wrap(err, "pulling 'NetworkApiVersion' from propertyBag")
		}

		destination.NetworkApiVersion = &networkApiVersion
	} else {
		destination.NetworkApiVersion = nil
	}

	// NetworkInterfaceConfigurations
	if propertyBag.Contains("NetworkInterfaceConfigurations") {
		var networkInterfaceConfiguration []v20220301s.VirtualMachineNetworkInterfaceConfiguration_STATUS
		err := propertyBag.Pull("NetworkInterfaceConfigurations", &networkInterfaceConfiguration)
		if err != nil {
			return errors.Wrap(err, "pulling 'NetworkInterfaceConfigurations' from propertyBag")
		}

		destination.NetworkInterfaceConfigurations = networkInterfaceConfiguration
	} else {
		destination.NetworkInterfaceConfigurations = nil
	}

	// NetworkInterfaces
	if profile.NetworkInterfaces != nil {
		networkInterfaceList := make([]v20220301s.NetworkInterfaceReference_STATUS, len(profile.NetworkInterfaces))
		for networkInterfaceIndex, networkInterfaceItem := range profile.NetworkInterfaces {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceItem := networkInterfaceItem
			var networkInterface v20220301s.NetworkInterfaceReference_STATUS
			err := networkInterfaceItem.AssignProperties_To_NetworkInterfaceReference_STATUS(&networkInterface)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_NetworkInterfaceReference_STATUS() to populate field NetworkInterfaces")
			}
			networkInterfaceList[networkInterfaceIndex] = networkInterface
		}
		destination.NetworkInterfaces = networkInterfaceList
	} else {
		destination.NetworkInterfaces = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForNetworkProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForNetworkProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.OSProfile
// Specifies the operating system settings for the virtual machine. Some of the settings cannot be changed once VM is
// provisioned.
type OSProfile struct {
	AdminPassword               *genruntime.SecretReference `json:"adminPassword,omitempty"`
	AdminUsername               *string                     `json:"adminUsername,omitempty"`
	AllowExtensionOperations    *bool                       `json:"allowExtensionOperations,omitempty"`
	ComputerName                *string                     `json:"computerName,omitempty"`
	CustomData                  *string                     `json:"customData,omitempty"`
	LinuxConfiguration          *LinuxConfiguration         `json:"linuxConfiguration,omitempty"`
	PropertyBag                 genruntime.PropertyBag      `json:"$propertyBag,omitempty"`
	RequireGuestProvisionSignal *bool                       `json:"requireGuestProvisionSignal,omitempty"`
	Secrets                     []VaultSecretGroup          `json:"secrets,omitempty"`
	WindowsConfiguration        *WindowsConfiguration       `json:"windowsConfiguration,omitempty"`
}

// AssignProperties_From_OSProfile populates our OSProfile from the provided source OSProfile
func (profile *OSProfile) AssignProperties_From_OSProfile(source *v20220301s.OSProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdminPassword
	if source.AdminPassword != nil {
		adminPassword := source.AdminPassword.Copy()
		profile.AdminPassword = &adminPassword
	} else {
		profile.AdminPassword = nil
	}

	// AdminUsername
	profile.AdminUsername = genruntime.ClonePointerToString(source.AdminUsername)

	// AllowExtensionOperations
	if source.AllowExtensionOperations != nil {
		allowExtensionOperation := *source.AllowExtensionOperations
		profile.AllowExtensionOperations = &allowExtensionOperation
	} else {
		profile.AllowExtensionOperations = nil
	}

	// ComputerName
	profile.ComputerName = genruntime.ClonePointerToString(source.ComputerName)

	// CustomData
	profile.CustomData = genruntime.ClonePointerToString(source.CustomData)

	// LinuxConfiguration
	if source.LinuxConfiguration != nil {
		var linuxConfiguration LinuxConfiguration
		err := linuxConfiguration.AssignProperties_From_LinuxConfiguration(source.LinuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_LinuxConfiguration() to populate field LinuxConfiguration")
		}
		profile.LinuxConfiguration = &linuxConfiguration
	} else {
		profile.LinuxConfiguration = nil
	}

	// RequireGuestProvisionSignal
	if source.RequireGuestProvisionSignal != nil {
		requireGuestProvisionSignal := *source.RequireGuestProvisionSignal
		profile.RequireGuestProvisionSignal = &requireGuestProvisionSignal
	} else {
		profile.RequireGuestProvisionSignal = nil
	}

	// Secrets
	if source.Secrets != nil {
		secretList := make([]VaultSecretGroup, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret VaultSecretGroup
			err := secret.AssignProperties_From_VaultSecretGroup(&secretItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VaultSecretGroup() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		profile.Secrets = secretList
	} else {
		profile.Secrets = nil
	}

	// WindowsConfiguration
	if source.WindowsConfiguration != nil {
		var windowsConfiguration WindowsConfiguration
		err := windowsConfiguration.AssignProperties_From_WindowsConfiguration(source.WindowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WindowsConfiguration() to populate field WindowsConfiguration")
		}
		profile.WindowsConfiguration = &windowsConfiguration
	} else {
		profile.WindowsConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForOSProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForOSProfile); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_OSProfile populates the provided destination OSProfile from our OSProfile
func (profile *OSProfile) AssignProperties_To_OSProfile(destination *v20220301s.OSProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// AdminPassword
	if profile.AdminPassword != nil {
		adminPassword := profile.AdminPassword.Copy()
		destination.AdminPassword = &adminPassword
	} else {
		destination.AdminPassword = nil
	}

	// AdminUsername
	destination.AdminUsername = genruntime.ClonePointerToString(profile.AdminUsername)

	// AllowExtensionOperations
	if profile.AllowExtensionOperations != nil {
		allowExtensionOperation := *profile.AllowExtensionOperations
		destination.AllowExtensionOperations = &allowExtensionOperation
	} else {
		destination.AllowExtensionOperations = nil
	}

	// ComputerName
	destination.ComputerName = genruntime.ClonePointerToString(profile.ComputerName)

	// CustomData
	destination.CustomData = genruntime.ClonePointerToString(profile.CustomData)

	// LinuxConfiguration
	if profile.LinuxConfiguration != nil {
		var linuxConfiguration v20220301s.LinuxConfiguration
		err := profile.LinuxConfiguration.AssignProperties_To_LinuxConfiguration(&linuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_LinuxConfiguration() to populate field LinuxConfiguration")
		}
		destination.LinuxConfiguration = &linuxConfiguration
	} else {
		destination.LinuxConfiguration = nil
	}

	// RequireGuestProvisionSignal
	if profile.RequireGuestProvisionSignal != nil {
		requireGuestProvisionSignal := *profile.RequireGuestProvisionSignal
		destination.RequireGuestProvisionSignal = &requireGuestProvisionSignal
	} else {
		destination.RequireGuestProvisionSignal = nil
	}

	// Secrets
	if profile.Secrets != nil {
		secretList := make([]v20220301s.VaultSecretGroup, len(profile.Secrets))
		for secretIndex, secretItem := range profile.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret v20220301s.VaultSecretGroup
			err := secretItem.AssignProperties_To_VaultSecretGroup(&secret)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VaultSecretGroup() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		destination.Secrets = secretList
	} else {
		destination.Secrets = nil
	}

	// WindowsConfiguration
	if profile.WindowsConfiguration != nil {
		var windowsConfiguration v20220301s.WindowsConfiguration
		err := profile.WindowsConfiguration.AssignProperties_To_WindowsConfiguration(&windowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WindowsConfiguration() to populate field WindowsConfiguration")
		}
		destination.WindowsConfiguration = &windowsConfiguration
	} else {
		destination.WindowsConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForOSProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForOSProfile); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.OSProfile_STATUS
// Specifies the operating system settings for the virtual machine. Some of the settings cannot be changed once VM is
// provisioned.
type OSProfile_STATUS struct {
	AdminUsername               *string                      `json:"adminUsername,omitempty"`
	AllowExtensionOperations    *bool                        `json:"allowExtensionOperations,omitempty"`
	ComputerName                *string                      `json:"computerName,omitempty"`
	CustomData                  *string                      `json:"customData,omitempty"`
	LinuxConfiguration          *LinuxConfiguration_STATUS   `json:"linuxConfiguration,omitempty"`
	PropertyBag                 genruntime.PropertyBag       `json:"$propertyBag,omitempty"`
	RequireGuestProvisionSignal *bool                        `json:"requireGuestProvisionSignal,omitempty"`
	Secrets                     []VaultSecretGroup_STATUS    `json:"secrets,omitempty"`
	WindowsConfiguration        *WindowsConfiguration_STATUS `json:"windowsConfiguration,omitempty"`
}

// AssignProperties_From_OSProfile_STATUS populates our OSProfile_STATUS from the provided source OSProfile_STATUS
func (profile *OSProfile_STATUS) AssignProperties_From_OSProfile_STATUS(source *v20220301s.OSProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdminUsername
	profile.AdminUsername = genruntime.ClonePointerToString(source.AdminUsername)

	// AllowExtensionOperations
	if source.AllowExtensionOperations != nil {
		allowExtensionOperation := *source.AllowExtensionOperations
		profile.AllowExtensionOperations = &allowExtensionOperation
	} else {
		profile.AllowExtensionOperations = nil
	}

	// ComputerName
	profile.ComputerName = genruntime.ClonePointerToString(source.ComputerName)

	// CustomData
	profile.CustomData = genruntime.ClonePointerToString(source.CustomData)

	// LinuxConfiguration
	if source.LinuxConfiguration != nil {
		var linuxConfiguration LinuxConfiguration_STATUS
		err := linuxConfiguration.AssignProperties_From_LinuxConfiguration_STATUS(source.LinuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_LinuxConfiguration_STATUS() to populate field LinuxConfiguration")
		}
		profile.LinuxConfiguration = &linuxConfiguration
	} else {
		profile.LinuxConfiguration = nil
	}

	// RequireGuestProvisionSignal
	if source.RequireGuestProvisionSignal != nil {
		requireGuestProvisionSignal := *source.RequireGuestProvisionSignal
		profile.RequireGuestProvisionSignal = &requireGuestProvisionSignal
	} else {
		profile.RequireGuestProvisionSignal = nil
	}

	// Secrets
	if source.Secrets != nil {
		secretList := make([]VaultSecretGroup_STATUS, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret VaultSecretGroup_STATUS
			err := secret.AssignProperties_From_VaultSecretGroup_STATUS(&secretItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VaultSecretGroup_STATUS() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		profile.Secrets = secretList
	} else {
		profile.Secrets = nil
	}

	// WindowsConfiguration
	if source.WindowsConfiguration != nil {
		var windowsConfiguration WindowsConfiguration_STATUS
		err := windowsConfiguration.AssignProperties_From_WindowsConfiguration_STATUS(source.WindowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WindowsConfiguration_STATUS() to populate field WindowsConfiguration")
		}
		profile.WindowsConfiguration = &windowsConfiguration
	} else {
		profile.WindowsConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForOSProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForOSProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_OSProfile_STATUS populates the provided destination OSProfile_STATUS from our OSProfile_STATUS
func (profile *OSProfile_STATUS) AssignProperties_To_OSProfile_STATUS(destination *v20220301s.OSProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// AdminUsername
	destination.AdminUsername = genruntime.ClonePointerToString(profile.AdminUsername)

	// AllowExtensionOperations
	if profile.AllowExtensionOperations != nil {
		allowExtensionOperation := *profile.AllowExtensionOperations
		destination.AllowExtensionOperations = &allowExtensionOperation
	} else {
		destination.AllowExtensionOperations = nil
	}

	// ComputerName
	destination.ComputerName = genruntime.ClonePointerToString(profile.ComputerName)

	// CustomData
	destination.CustomData = genruntime.ClonePointerToString(profile.CustomData)

	// LinuxConfiguration
	if profile.LinuxConfiguration != nil {
		var linuxConfiguration v20220301s.LinuxConfiguration_STATUS
		err := profile.LinuxConfiguration.AssignProperties_To_LinuxConfiguration_STATUS(&linuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_LinuxConfiguration_STATUS() to populate field LinuxConfiguration")
		}
		destination.LinuxConfiguration = &linuxConfiguration
	} else {
		destination.LinuxConfiguration = nil
	}

	// RequireGuestProvisionSignal
	if profile.RequireGuestProvisionSignal != nil {
		requireGuestProvisionSignal := *profile.RequireGuestProvisionSignal
		destination.RequireGuestProvisionSignal = &requireGuestProvisionSignal
	} else {
		destination.RequireGuestProvisionSignal = nil
	}

	// Secrets
	if profile.Secrets != nil {
		secretList := make([]v20220301s.VaultSecretGroup_STATUS, len(profile.Secrets))
		for secretIndex, secretItem := range profile.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret v20220301s.VaultSecretGroup_STATUS
			err := secretItem.AssignProperties_To_VaultSecretGroup_STATUS(&secret)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VaultSecretGroup_STATUS() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		destination.Secrets = secretList
	} else {
		destination.Secrets = nil
	}

	// WindowsConfiguration
	if profile.WindowsConfiguration != nil {
		var windowsConfiguration v20220301s.WindowsConfiguration_STATUS
		err := profile.WindowsConfiguration.AssignProperties_To_WindowsConfiguration_STATUS(&windowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WindowsConfiguration_STATUS() to populate field WindowsConfiguration")
		}
		destination.WindowsConfiguration = &windowsConfiguration
	} else {
		destination.WindowsConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForOSProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForOSProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.Plan
// Specifies information about the marketplace image used to create the virtual machine. This element is only used for
// marketplace images. Before you can use a marketplace image from an API, you must enable the image for programmatic use.
// In the Azure portal, find the marketplace image that you want to use and then click Want to deploy programmatically,
// Get Started ->. Enter any required information and then click Save.
type Plan struct {
	Name          *string                `json:"name,omitempty"`
	Product       *string                `json:"product,omitempty"`
	PromotionCode *string                `json:"promotionCode,omitempty"`
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Publisher     *string                `json:"publisher,omitempty"`
}

// AssignProperties_From_Plan populates our Plan from the provided source Plan
func (plan *Plan) AssignProperties_From_Plan(source *v20220301s.Plan) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	plan.Name = genruntime.ClonePointerToString(source.Name)

	// Product
	plan.Product = genruntime.ClonePointerToString(source.Product)

	// PromotionCode
	plan.PromotionCode = genruntime.ClonePointerToString(source.PromotionCode)

	// Publisher
	plan.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// Update the property bag
	if len(propertyBag) > 0 {
		plan.PropertyBag = propertyBag
	} else {
		plan.PropertyBag = nil
	}

	// Invoke the augmentConversionForPlan interface (if implemented) to customize the conversion
	var planAsAny any = plan
	if augmentedPlan, ok := planAsAny.(augmentConversionForPlan); ok {
		err := augmentedPlan.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Plan populates the provided destination Plan from our Plan
func (plan *Plan) AssignProperties_To_Plan(destination *v20220301s.Plan) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(plan.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(plan.Name)

	// Product
	destination.Product = genruntime.ClonePointerToString(plan.Product)

	// PromotionCode
	destination.PromotionCode = genruntime.ClonePointerToString(plan.PromotionCode)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(plan.Publisher)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForPlan interface (if implemented) to customize the conversion
	var planAsAny any = plan
	if augmentedPlan, ok := planAsAny.(augmentConversionForPlan); ok {
		err := augmentedPlan.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.Plan_STATUS
// Specifies information about the marketplace image used to create the virtual machine. This element is only used for
// marketplace images. Before you can use a marketplace image from an API, you must enable the image for programmatic use.
// In the Azure portal, find the marketplace image that you want to use and then click Want to deploy programmatically,
// Get Started ->. Enter any required information and then click Save.
type Plan_STATUS struct {
	Name          *string                `json:"name,omitempty"`
	Product       *string                `json:"product,omitempty"`
	PromotionCode *string                `json:"promotionCode,omitempty"`
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Publisher     *string                `json:"publisher,omitempty"`
}

// AssignProperties_From_Plan_STATUS populates our Plan_STATUS from the provided source Plan_STATUS
func (plan *Plan_STATUS) AssignProperties_From_Plan_STATUS(source *v20220301s.Plan_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	plan.Name = genruntime.ClonePointerToString(source.Name)

	// Product
	plan.Product = genruntime.ClonePointerToString(source.Product)

	// PromotionCode
	plan.PromotionCode = genruntime.ClonePointerToString(source.PromotionCode)

	// Publisher
	plan.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// Update the property bag
	if len(propertyBag) > 0 {
		plan.PropertyBag = propertyBag
	} else {
		plan.PropertyBag = nil
	}

	// Invoke the augmentConversionForPlan_STATUS interface (if implemented) to customize the conversion
	var planAsAny any = plan
	if augmentedPlan, ok := planAsAny.(augmentConversionForPlan_STATUS); ok {
		err := augmentedPlan.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Plan_STATUS populates the provided destination Plan_STATUS from our Plan_STATUS
func (plan *Plan_STATUS) AssignProperties_To_Plan_STATUS(destination *v20220301s.Plan_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(plan.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(plan.Name)

	// Product
	destination.Product = genruntime.ClonePointerToString(plan.Product)

	// PromotionCode
	destination.PromotionCode = genruntime.ClonePointerToString(plan.PromotionCode)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(plan.Publisher)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForPlan_STATUS interface (if implemented) to customize the conversion
	var planAsAny any = plan
	if augmentedPlan, ok := planAsAny.(augmentConversionForPlan_STATUS); ok {
		err := augmentedPlan.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.SecurityProfile
// Specifies the Security profile settings for the virtual machine or virtual machine scale set.
type SecurityProfile struct {
	EncryptionAtHost *bool                  `json:"encryptionAtHost,omitempty"`
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SecurityType     *string                `json:"securityType,omitempty"`
	UefiSettings     *UefiSettings          `json:"uefiSettings,omitempty"`
}

// AssignProperties_From_SecurityProfile populates our SecurityProfile from the provided source SecurityProfile
func (profile *SecurityProfile) AssignProperties_From_SecurityProfile(source *v20220301s.SecurityProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// EncryptionAtHost
	if source.EncryptionAtHost != nil {
		encryptionAtHost := *source.EncryptionAtHost
		profile.EncryptionAtHost = &encryptionAtHost
	} else {
		profile.EncryptionAtHost = nil
	}

	// SecurityType
	profile.SecurityType = genruntime.ClonePointerToString(source.SecurityType)

	// UefiSettings
	if source.UefiSettings != nil {
		var uefiSetting UefiSettings
		err := uefiSetting.AssignProperties_From_UefiSettings(source.UefiSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UefiSettings() to populate field UefiSettings")
		}
		profile.UefiSettings = &uefiSetting
	} else {
		profile.UefiSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForSecurityProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForSecurityProfile); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_SecurityProfile populates the provided destination SecurityProfile from our SecurityProfile
func (profile *SecurityProfile) AssignProperties_To_SecurityProfile(destination *v20220301s.SecurityProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// EncryptionAtHost
	if profile.EncryptionAtHost != nil {
		encryptionAtHost := *profile.EncryptionAtHost
		destination.EncryptionAtHost = &encryptionAtHost
	} else {
		destination.EncryptionAtHost = nil
	}

	// SecurityType
	destination.SecurityType = genruntime.ClonePointerToString(profile.SecurityType)

	// UefiSettings
	if profile.UefiSettings != nil {
		var uefiSetting v20220301s.UefiSettings
		err := profile.UefiSettings.AssignProperties_To_UefiSettings(&uefiSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UefiSettings() to populate field UefiSettings")
		}
		destination.UefiSettings = &uefiSetting
	} else {
		destination.UefiSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSecurityProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForSecurityProfile); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.SecurityProfile_STATUS
// Specifies the Security profile settings for the virtual machine or virtual machine scale set.
type SecurityProfile_STATUS struct {
	EncryptionAtHost *bool                  `json:"encryptionAtHost,omitempty"`
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SecurityType     *string                `json:"securityType,omitempty"`
	UefiSettings     *UefiSettings_STATUS   `json:"uefiSettings,omitempty"`
}

// AssignProperties_From_SecurityProfile_STATUS populates our SecurityProfile_STATUS from the provided source SecurityProfile_STATUS
func (profile *SecurityProfile_STATUS) AssignProperties_From_SecurityProfile_STATUS(source *v20220301s.SecurityProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// EncryptionAtHost
	if source.EncryptionAtHost != nil {
		encryptionAtHost := *source.EncryptionAtHost
		profile.EncryptionAtHost = &encryptionAtHost
	} else {
		profile.EncryptionAtHost = nil
	}

	// SecurityType
	profile.SecurityType = genruntime.ClonePointerToString(source.SecurityType)

	// UefiSettings
	if source.UefiSettings != nil {
		var uefiSetting UefiSettings_STATUS
		err := uefiSetting.AssignProperties_From_UefiSettings_STATUS(source.UefiSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UefiSettings_STATUS() to populate field UefiSettings")
		}
		profile.UefiSettings = &uefiSetting
	} else {
		profile.UefiSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForSecurityProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForSecurityProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_SecurityProfile_STATUS populates the provided destination SecurityProfile_STATUS from our SecurityProfile_STATUS
func (profile *SecurityProfile_STATUS) AssignProperties_To_SecurityProfile_STATUS(destination *v20220301s.SecurityProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// EncryptionAtHost
	if profile.EncryptionAtHost != nil {
		encryptionAtHost := *profile.EncryptionAtHost
		destination.EncryptionAtHost = &encryptionAtHost
	} else {
		destination.EncryptionAtHost = nil
	}

	// SecurityType
	destination.SecurityType = genruntime.ClonePointerToString(profile.SecurityType)

	// UefiSettings
	if profile.UefiSettings != nil {
		var uefiSetting v20220301s.UefiSettings_STATUS
		err := profile.UefiSettings.AssignProperties_To_UefiSettings_STATUS(&uefiSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UefiSettings_STATUS() to populate field UefiSettings")
		}
		destination.UefiSettings = &uefiSetting
	} else {
		destination.UefiSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSecurityProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForSecurityProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.StorageProfile
// Specifies the storage settings for the virtual machine disks.
type StorageProfile struct {
	DataDisks      []DataDisk             `json:"dataDisks,omitempty"`
	ImageReference *ImageReference        `json:"imageReference,omitempty"`
	OsDisk         *OSDisk                `json:"osDisk,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_StorageProfile populates our StorageProfile from the provided source StorageProfile
func (profile *StorageProfile) AssignProperties_From_StorageProfile(source *v20220301s.StorageProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DataDisks
	if source.DataDisks != nil {
		dataDiskList := make([]DataDisk, len(source.DataDisks))
		for dataDiskIndex, dataDiskItem := range source.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk DataDisk
			err := dataDisk.AssignProperties_From_DataDisk(&dataDiskItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DataDisk() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		profile.DataDisks = dataDiskList
	} else {
		profile.DataDisks = nil
	}

	// ImageReference
	if source.ImageReference != nil {
		var imageReference ImageReference
		err := imageReference.AssignProperties_From_ImageReference(source.ImageReference)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ImageReference() to populate field ImageReference")
		}
		profile.ImageReference = &imageReference
	} else {
		profile.ImageReference = nil
	}

	// OsDisk
	if source.OsDisk != nil {
		var osDisk OSDisk
		err := osDisk.AssignProperties_From_OSDisk(source.OsDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OSDisk() to populate field OsDisk")
		}
		profile.OsDisk = &osDisk
	} else {
		profile.OsDisk = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForStorageProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForStorageProfile); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_StorageProfile populates the provided destination StorageProfile from our StorageProfile
func (profile *StorageProfile) AssignProperties_To_StorageProfile(destination *v20220301s.StorageProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// DataDisks
	if profile.DataDisks != nil {
		dataDiskList := make([]v20220301s.DataDisk, len(profile.DataDisks))
		for dataDiskIndex, dataDiskItem := range profile.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk v20220301s.DataDisk
			err := dataDiskItem.AssignProperties_To_DataDisk(&dataDisk)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DataDisk() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		destination.DataDisks = dataDiskList
	} else {
		destination.DataDisks = nil
	}

	// ImageReference
	if profile.ImageReference != nil {
		var imageReference v20220301s.ImageReference
		err := profile.ImageReference.AssignProperties_To_ImageReference(&imageReference)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ImageReference() to populate field ImageReference")
		}
		destination.ImageReference = &imageReference
	} else {
		destination.ImageReference = nil
	}

	// OsDisk
	if profile.OsDisk != nil {
		var osDisk v20220301s.OSDisk
		err := profile.OsDisk.AssignProperties_To_OSDisk(&osDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OSDisk() to populate field OsDisk")
		}
		destination.OsDisk = &osDisk
	} else {
		destination.OsDisk = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForStorageProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForStorageProfile); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.StorageProfile_STATUS
// Specifies the storage settings for the virtual machine disks.
type StorageProfile_STATUS struct {
	DataDisks      []DataDisk_STATUS      `json:"dataDisks,omitempty"`
	ImageReference *ImageReference_STATUS `json:"imageReference,omitempty"`
	OsDisk         *OSDisk_STATUS         `json:"osDisk,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_StorageProfile_STATUS populates our StorageProfile_STATUS from the provided source StorageProfile_STATUS
func (profile *StorageProfile_STATUS) AssignProperties_From_StorageProfile_STATUS(source *v20220301s.StorageProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DataDisks
	if source.DataDisks != nil {
		dataDiskList := make([]DataDisk_STATUS, len(source.DataDisks))
		for dataDiskIndex, dataDiskItem := range source.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk DataDisk_STATUS
			err := dataDisk.AssignProperties_From_DataDisk_STATUS(&dataDiskItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DataDisk_STATUS() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		profile.DataDisks = dataDiskList
	} else {
		profile.DataDisks = nil
	}

	// ImageReference
	if source.ImageReference != nil {
		var imageReference ImageReference_STATUS
		err := imageReference.AssignProperties_From_ImageReference_STATUS(source.ImageReference)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ImageReference_STATUS() to populate field ImageReference")
		}
		profile.ImageReference = &imageReference
	} else {
		profile.ImageReference = nil
	}

	// OsDisk
	if source.OsDisk != nil {
		var osDisk OSDisk_STATUS
		err := osDisk.AssignProperties_From_OSDisk_STATUS(source.OsDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OSDisk_STATUS() to populate field OsDisk")
		}
		profile.OsDisk = &osDisk
	} else {
		profile.OsDisk = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForStorageProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForStorageProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_StorageProfile_STATUS populates the provided destination StorageProfile_STATUS from our StorageProfile_STATUS
func (profile *StorageProfile_STATUS) AssignProperties_To_StorageProfile_STATUS(destination *v20220301s.StorageProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// DataDisks
	if profile.DataDisks != nil {
		dataDiskList := make([]v20220301s.DataDisk_STATUS, len(profile.DataDisks))
		for dataDiskIndex, dataDiskItem := range profile.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk v20220301s.DataDisk_STATUS
			err := dataDiskItem.AssignProperties_To_DataDisk_STATUS(&dataDisk)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DataDisk_STATUS() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		destination.DataDisks = dataDiskList
	} else {
		destination.DataDisks = nil
	}

	// ImageReference
	if profile.ImageReference != nil {
		var imageReference v20220301s.ImageReference_STATUS
		err := profile.ImageReference.AssignProperties_To_ImageReference_STATUS(&imageReference)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ImageReference_STATUS() to populate field ImageReference")
		}
		destination.ImageReference = &imageReference
	} else {
		destination.ImageReference = nil
	}

	// OsDisk
	if profile.OsDisk != nil {
		var osDisk v20220301s.OSDisk_STATUS
		err := profile.OsDisk.AssignProperties_To_OSDisk_STATUS(&osDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OSDisk_STATUS() to populate field OsDisk")
		}
		destination.OsDisk = &osDisk
	} else {
		destination.OsDisk = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForStorageProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForStorageProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.SubResource
type SubResource struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`

	// Reference: Resource Id
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

// AssignProperties_From_SubResource populates our SubResource from the provided source SubResource
func (resource *SubResource) AssignProperties_From_SubResource(source *v20210701s.SubResource) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		resource.Reference = &reference
	} else {
		resource.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		resource.PropertyBag = propertyBag
	} else {
		resource.PropertyBag = nil
	}

	// Invoke the augmentConversionForSubResource interface (if implemented) to customize the conversion
	var resourceAsAny any = resource
	if augmentedResource, ok := resourceAsAny.(augmentConversionForSubResource); ok {
		err := augmentedResource.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_SubResource populates the provided destination SubResource from our SubResource
func (resource *SubResource) AssignProperties_To_SubResource(destination *v20210701s.SubResource) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(resource.PropertyBag)

	// Reference
	if resource.Reference != nil {
		reference := resource.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSubResource interface (if implemented) to customize the conversion
	var resourceAsAny any = resource
	if augmentedResource, ok := resourceAsAny.(augmentConversionForSubResource); ok {
		err := augmentedResource.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.SubResource_STATUS
type SubResource_STATUS struct {
	Id          *string                `json:"id,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_SubResource_STATUS populates our SubResource_STATUS from the provided source SubResource_STATUS
func (resource *SubResource_STATUS) AssignProperties_From_SubResource_STATUS(source *v20210701s.SubResource_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Id
	resource.Id = genruntime.ClonePointerToString(source.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		resource.PropertyBag = propertyBag
	} else {
		resource.PropertyBag = nil
	}

	// Invoke the augmentConversionForSubResource_STATUS interface (if implemented) to customize the conversion
	var resourceAsAny any = resource
	if augmentedResource, ok := resourceAsAny.(augmentConversionForSubResource_STATUS); ok {
		err := augmentedResource.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_SubResource_STATUS populates the provided destination SubResource_STATUS from our SubResource_STATUS
func (resource *SubResource_STATUS) AssignProperties_To_SubResource_STATUS(destination *v20210701s.SubResource_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(resource.PropertyBag)

	// Id
	destination.Id = genruntime.ClonePointerToString(resource.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSubResource_STATUS interface (if implemented) to customize the conversion
	var resourceAsAny any = resource
	if augmentedResource, ok := resourceAsAny.(augmentConversionForSubResource_STATUS); ok {
		err := augmentedResource.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineExtension_STATUS
// Describes a Virtual Machine Extension.
type VirtualMachineExtension_STATUS struct {
	AutoUpgradeMinorVersion *bool                                       `json:"autoUpgradeMinorVersion,omitempty"`
	EnableAutomaticUpgrade  *bool                                       `json:"enableAutomaticUpgrade,omitempty"`
	ForceUpdateTag          *string                                     `json:"forceUpdateTag,omitempty"`
	Id                      *string                                     `json:"id,omitempty"`
	InstanceView            *VirtualMachineExtensionInstanceView_STATUS `json:"instanceView,omitempty"`
	Location                *string                                     `json:"location,omitempty"`
	Name                    *string                                     `json:"name,omitempty"`
	PropertiesType          *string                                     `json:"properties_type,omitempty"`
	PropertyBag             genruntime.PropertyBag                      `json:"$propertyBag,omitempty"`
	ProvisioningState       *string                                     `json:"provisioningState,omitempty"`
	Publisher               *string                                     `json:"publisher,omitempty"`
	Settings                map[string]v1.JSON                          `json:"settings,omitempty"`
	Tags                    map[string]string                           `json:"tags,omitempty"`
	Type                    *string                                     `json:"type,omitempty"`
	TypeHandlerVersion      *string                                     `json:"typeHandlerVersion,omitempty"`
}

// AssignProperties_From_VirtualMachineExtension_STATUS populates our VirtualMachineExtension_STATUS from the provided source VirtualMachineExtension_STATUS
func (extension *VirtualMachineExtension_STATUS) AssignProperties_From_VirtualMachineExtension_STATUS(source *v20220301s.VirtualMachineExtension_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AutoUpgradeMinorVersion
	if source.AutoUpgradeMinorVersion != nil {
		autoUpgradeMinorVersion := *source.AutoUpgradeMinorVersion
		extension.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
	} else {
		extension.AutoUpgradeMinorVersion = nil
	}

	// EnableAutomaticUpgrade
	if source.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *source.EnableAutomaticUpgrade
		extension.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	} else {
		extension.EnableAutomaticUpgrade = nil
	}

	// ForceUpdateTag
	extension.ForceUpdateTag = genruntime.ClonePointerToString(source.ForceUpdateTag)

	// Id
	extension.Id = genruntime.ClonePointerToString(source.Id)

	// InstanceView
	if source.InstanceView != nil {
		var instanceView VirtualMachineExtensionInstanceView_STATUS
		err := instanceView.AssignProperties_From_VirtualMachineExtensionInstanceView_STATUS(source.InstanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineExtensionInstanceView_STATUS() to populate field InstanceView")
		}
		extension.InstanceView = &instanceView
	} else {
		extension.InstanceView = nil
	}

	// Location
	extension.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	extension.Name = genruntime.ClonePointerToString(source.Name)

	// PropertiesType
	extension.PropertiesType = genruntime.ClonePointerToString(source.PropertiesType)

	// ProtectedSettingsFromKeyVault
	if source.ProtectedSettingsFromKeyVault != nil {
		propertyBag.Add("ProtectedSettingsFromKeyVault", *source.ProtectedSettingsFromKeyVault)
	} else {
		propertyBag.Remove("ProtectedSettingsFromKeyVault")
	}

	// ProvisioningState
	extension.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// Publisher
	extension.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// Settings
	if source.Settings != nil {
		settingMap := make(map[string]v1.JSON, len(source.Settings))
		for settingKey, settingValue := range source.Settings {
			// Shadow the loop variable to avoid aliasing
			settingValue := settingValue
			settingMap[settingKey] = *settingValue.DeepCopy()
		}
		extension.Settings = settingMap
	} else {
		extension.Settings = nil
	}

	// SuppressFailures
	if source.SuppressFailures != nil {
		propertyBag.Add("SuppressFailures", *source.SuppressFailures)
	} else {
		propertyBag.Remove("SuppressFailures")
	}

	// Tags
	extension.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	extension.Type = genruntime.ClonePointerToString(source.Type)

	// TypeHandlerVersion
	extension.TypeHandlerVersion = genruntime.ClonePointerToString(source.TypeHandlerVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		extension.PropertyBag = propertyBag
	} else {
		extension.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineExtension_STATUS interface (if implemented) to customize the conversion
	var extensionAsAny any = extension
	if augmentedExtension, ok := extensionAsAny.(augmentConversionForVirtualMachineExtension_STATUS); ok {
		err := augmentedExtension.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineExtension_STATUS populates the provided destination VirtualMachineExtension_STATUS from our VirtualMachineExtension_STATUS
func (extension *VirtualMachineExtension_STATUS) AssignProperties_To_VirtualMachineExtension_STATUS(destination *v20220301s.VirtualMachineExtension_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(extension.PropertyBag)

	// AutoUpgradeMinorVersion
	if extension.AutoUpgradeMinorVersion != nil {
		autoUpgradeMinorVersion := *extension.AutoUpgradeMinorVersion
		destination.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
	} else {
		destination.AutoUpgradeMinorVersion = nil
	}

	// EnableAutomaticUpgrade
	if extension.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *extension.EnableAutomaticUpgrade
		destination.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	} else {
		destination.EnableAutomaticUpgrade = nil
	}

	// ForceUpdateTag
	destination.ForceUpdateTag = genruntime.ClonePointerToString(extension.ForceUpdateTag)

	// Id
	destination.Id = genruntime.ClonePointerToString(extension.Id)

	// InstanceView
	if extension.InstanceView != nil {
		var instanceView v20220301s.VirtualMachineExtensionInstanceView_STATUS
		err := extension.InstanceView.AssignProperties_To_VirtualMachineExtensionInstanceView_STATUS(&instanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineExtensionInstanceView_STATUS() to populate field InstanceView")
		}
		destination.InstanceView = &instanceView
	} else {
		destination.InstanceView = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(extension.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(extension.Name)

	// PropertiesType
	destination.PropertiesType = genruntime.ClonePointerToString(extension.PropertiesType)

	// ProtectedSettingsFromKeyVault
	if propertyBag.Contains("ProtectedSettingsFromKeyVault") {
		var protectedSettingsFromKeyVault v20220301s.KeyVaultSecretReference_STATUS
		err := propertyBag.Pull("ProtectedSettingsFromKeyVault", &protectedSettingsFromKeyVault)
		if err != nil {
			return errors.Wrap(err, "pulling 'ProtectedSettingsFromKeyVault' from propertyBag")
		}

		destination.ProtectedSettingsFromKeyVault = &protectedSettingsFromKeyVault
	} else {
		destination.ProtectedSettingsFromKeyVault = nil
	}

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(extension.ProvisioningState)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(extension.Publisher)

	// Settings
	if extension.Settings != nil {
		settingMap := make(map[string]v1.JSON, len(extension.Settings))
		for settingKey, settingValue := range extension.Settings {
			// Shadow the loop variable to avoid aliasing
			settingValue := settingValue
			settingMap[settingKey] = *settingValue.DeepCopy()
		}
		destination.Settings = settingMap
	} else {
		destination.Settings = nil
	}

	// SuppressFailures
	if propertyBag.Contains("SuppressFailures") {
		var suppressFailure bool
		err := propertyBag.Pull("SuppressFailures", &suppressFailure)
		if err != nil {
			return errors.Wrap(err, "pulling 'SuppressFailures' from propertyBag")
		}

		destination.SuppressFailures = &suppressFailure
	} else {
		destination.SuppressFailures = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(extension.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(extension.Type)

	// TypeHandlerVersion
	destination.TypeHandlerVersion = genruntime.ClonePointerToString(extension.TypeHandlerVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineExtension_STATUS interface (if implemented) to customize the conversion
	var extensionAsAny any = extension
	if augmentedExtension, ok := extensionAsAny.(augmentConversionForVirtualMachineExtension_STATUS); ok {
		err := augmentedExtension.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineIdentity
// Identity for the virtual machine.
type VirtualMachineIdentity struct {
	PropertyBag            genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	Type                   *string                       `json:"type,omitempty"`
	UserAssignedIdentities []UserAssignedIdentityDetails `json:"userAssignedIdentities,omitempty"`
}

// AssignProperties_From_VirtualMachineIdentity populates our VirtualMachineIdentity from the provided source VirtualMachineIdentity
func (identity *VirtualMachineIdentity) AssignProperties_From_VirtualMachineIdentity(source *v20220301s.VirtualMachineIdentity) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Type
	identity.Type = genruntime.ClonePointerToString(source.Type)

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, len(source.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity UserAssignedIdentityDetails
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentityDetails(&userAssignedIdentityItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		identity.PropertyBag = propertyBag
	} else {
		identity.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineIdentity interface (if implemented) to customize the conversion
	var identityAsAny any = identity
	if augmentedIdentity, ok := identityAsAny.(augmentConversionForVirtualMachineIdentity); ok {
		err := augmentedIdentity.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineIdentity populates the provided destination VirtualMachineIdentity from our VirtualMachineIdentity
func (identity *VirtualMachineIdentity) AssignProperties_To_VirtualMachineIdentity(destination *v20220301s.VirtualMachineIdentity) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(identity.PropertyBag)

	// Type
	destination.Type = genruntime.ClonePointerToString(identity.Type)

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]v20220301s.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity v20220301s.UserAssignedIdentityDetails
			err := userAssignedIdentityItem.AssignProperties_To_UserAssignedIdentityDetails(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityList
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineIdentity interface (if implemented) to customize the conversion
	var identityAsAny any = identity
	if augmentedIdentity, ok := identityAsAny.(augmentConversionForVirtualMachineIdentity); ok {
		err := augmentedIdentity.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineIdentity_STATUS
// Identity for the virtual machine.
type VirtualMachineIdentity_STATUS struct {
	PrincipalId            *string                                                         `json:"principalId,omitempty"`
	PropertyBag            genruntime.PropertyBag                                          `json:"$propertyBag,omitempty"`
	TenantId               *string                                                         `json:"tenantId,omitempty"`
	Type                   *string                                                         `json:"type,omitempty"`
	UserAssignedIdentities map[string]VirtualMachineIdentity_UserAssignedIdentities_STATUS `json:"userAssignedIdentities,omitempty"`
}

// AssignProperties_From_VirtualMachineIdentity_STATUS populates our VirtualMachineIdentity_STATUS from the provided source VirtualMachineIdentity_STATUS
func (identity *VirtualMachineIdentity_STATUS) AssignProperties_From_VirtualMachineIdentity_STATUS(source *v20220301s.VirtualMachineIdentity_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	identity.Type = genruntime.ClonePointerToString(source.Type)

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]VirtualMachineIdentity_UserAssignedIdentities_STATUS, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity VirtualMachineIdentity_UserAssignedIdentities_STATUS
			err := userAssignedIdentity.AssignProperties_From_VirtualMachineIdentity_UserAssignedIdentities_STATUS(&userAssignedIdentityValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineIdentity_UserAssignedIdentities_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		identity.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		identity.PropertyBag = propertyBag
	} else {
		identity.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineIdentity_STATUS interface (if implemented) to customize the conversion
	var identityAsAny any = identity
	if augmentedIdentity, ok := identityAsAny.(augmentConversionForVirtualMachineIdentity_STATUS); ok {
		err := augmentedIdentity.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineIdentity_STATUS populates the provided destination VirtualMachineIdentity_STATUS from our VirtualMachineIdentity_STATUS
func (identity *VirtualMachineIdentity_STATUS) AssignProperties_To_VirtualMachineIdentity_STATUS(destination *v20220301s.VirtualMachineIdentity_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(identity.PropertyBag)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	destination.Type = genruntime.ClonePointerToString(identity.Type)

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]v20220301s.VirtualMachineIdentity_UserAssignedIdentities_STATUS, len(identity.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity v20220301s.VirtualMachineIdentity_UserAssignedIdentities_STATUS
			err := userAssignedIdentityValue.AssignProperties_To_VirtualMachineIdentity_UserAssignedIdentities_STATUS(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineIdentity_UserAssignedIdentities_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineIdentity_STATUS interface (if implemented) to customize the conversion
	var identityAsAny any = identity
	if augmentedIdentity, ok := identityAsAny.(augmentConversionForVirtualMachineIdentity_STATUS); ok {
		err := augmentedIdentity.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineInstanceView_STATUS
// The instance view of a virtual machine.
type VirtualMachineInstanceView_STATUS struct {
	AssignedHost              *string                                      `json:"assignedHost,omitempty"`
	BootDiagnostics           *BootDiagnosticsInstanceView_STATUS          `json:"bootDiagnostics,omitempty"`
	ComputerName              *string                                      `json:"computerName,omitempty"`
	Disks                     []DiskInstanceView_STATUS                    `json:"disks,omitempty"`
	Extensions                []VirtualMachineExtensionInstanceView_STATUS `json:"extensions,omitempty"`
	HyperVGeneration          *string                                      `json:"hyperVGeneration,omitempty"`
	MaintenanceRedeployStatus *MaintenanceRedeployStatus_STATUS            `json:"maintenanceRedeployStatus,omitempty"`
	OsName                    *string                                      `json:"osName,omitempty"`
	OsVersion                 *string                                      `json:"osVersion,omitempty"`
	PatchStatus               *VirtualMachinePatchStatus_STATUS            `json:"patchStatus,omitempty"`
	PlatformFaultDomain       *int                                         `json:"platformFaultDomain,omitempty"`
	PlatformUpdateDomain      *int                                         `json:"platformUpdateDomain,omitempty"`
	PropertyBag               genruntime.PropertyBag                       `json:"$propertyBag,omitempty"`
	RdpThumbPrint             *string                                      `json:"rdpThumbPrint,omitempty"`
	Statuses                  []InstanceViewStatus_STATUS                  `json:"statuses,omitempty"`
	VmAgent                   *VirtualMachineAgentInstanceView_STATUS      `json:"vmAgent,omitempty"`
	VmHealth                  *VirtualMachineHealthStatus_STATUS           `json:"vmHealth,omitempty"`
}

// AssignProperties_From_VirtualMachineInstanceView_STATUS populates our VirtualMachineInstanceView_STATUS from the provided source VirtualMachineInstanceView_STATUS
func (view *VirtualMachineInstanceView_STATUS) AssignProperties_From_VirtualMachineInstanceView_STATUS(source *v20220301s.VirtualMachineInstanceView_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AssignedHost
	view.AssignedHost = genruntime.ClonePointerToString(source.AssignedHost)

	// BootDiagnostics
	if source.BootDiagnostics != nil {
		var bootDiagnostic BootDiagnosticsInstanceView_STATUS
		err := bootDiagnostic.AssignProperties_From_BootDiagnosticsInstanceView_STATUS(source.BootDiagnostics)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BootDiagnosticsInstanceView_STATUS() to populate field BootDiagnostics")
		}
		view.BootDiagnostics = &bootDiagnostic
	} else {
		view.BootDiagnostics = nil
	}

	// ComputerName
	view.ComputerName = genruntime.ClonePointerToString(source.ComputerName)

	// Disks
	if source.Disks != nil {
		diskList := make([]DiskInstanceView_STATUS, len(source.Disks))
		for diskIndex, diskItem := range source.Disks {
			// Shadow the loop variable to avoid aliasing
			diskItem := diskItem
			var disk DiskInstanceView_STATUS
			err := disk.AssignProperties_From_DiskInstanceView_STATUS(&diskItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DiskInstanceView_STATUS() to populate field Disks")
			}
			diskList[diskIndex] = disk
		}
		view.Disks = diskList
	} else {
		view.Disks = nil
	}

	// Extensions
	if source.Extensions != nil {
		extensionList := make([]VirtualMachineExtensionInstanceView_STATUS, len(source.Extensions))
		for extensionIndex, extensionItem := range source.Extensions {
			// Shadow the loop variable to avoid aliasing
			extensionItem := extensionItem
			var extension VirtualMachineExtensionInstanceView_STATUS
			err := extension.AssignProperties_From_VirtualMachineExtensionInstanceView_STATUS(&extensionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineExtensionInstanceView_STATUS() to populate field Extensions")
			}
			extensionList[extensionIndex] = extension
		}
		view.Extensions = extensionList
	} else {
		view.Extensions = nil
	}

	// HyperVGeneration
	view.HyperVGeneration = genruntime.ClonePointerToString(source.HyperVGeneration)

	// MaintenanceRedeployStatus
	if source.MaintenanceRedeployStatus != nil {
		var maintenanceRedeployStatus MaintenanceRedeployStatus_STATUS
		err := maintenanceRedeployStatus.AssignProperties_From_MaintenanceRedeployStatus_STATUS(source.MaintenanceRedeployStatus)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_MaintenanceRedeployStatus_STATUS() to populate field MaintenanceRedeployStatus")
		}
		view.MaintenanceRedeployStatus = &maintenanceRedeployStatus
	} else {
		view.MaintenanceRedeployStatus = nil
	}

	// OsName
	view.OsName = genruntime.ClonePointerToString(source.OsName)

	// OsVersion
	view.OsVersion = genruntime.ClonePointerToString(source.OsVersion)

	// PatchStatus
	if source.PatchStatus != nil {
		var patchStatus VirtualMachinePatchStatus_STATUS
		err := patchStatus.AssignProperties_From_VirtualMachinePatchStatus_STATUS(source.PatchStatus)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachinePatchStatus_STATUS() to populate field PatchStatus")
		}
		view.PatchStatus = &patchStatus
	} else {
		view.PatchStatus = nil
	}

	// PlatformFaultDomain
	view.PlatformFaultDomain = genruntime.ClonePointerToInt(source.PlatformFaultDomain)

	// PlatformUpdateDomain
	view.PlatformUpdateDomain = genruntime.ClonePointerToInt(source.PlatformUpdateDomain)

	// RdpThumbPrint
	view.RdpThumbPrint = genruntime.ClonePointerToString(source.RdpThumbPrint)

	// Statuses
	if source.Statuses != nil {
		statusList := make([]InstanceViewStatus_STATUS, len(source.Statuses))
		for statusIndex, statusItem := range source.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status InstanceViewStatus_STATUS
			err := status.AssignProperties_From_InstanceViewStatus_STATUS(&statusItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_InstanceViewStatus_STATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		view.Statuses = statusList
	} else {
		view.Statuses = nil
	}

	// VmAgent
	if source.VmAgent != nil {
		var vmAgent VirtualMachineAgentInstanceView_STATUS
		err := vmAgent.AssignProperties_From_VirtualMachineAgentInstanceView_STATUS(source.VmAgent)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineAgentInstanceView_STATUS() to populate field VmAgent")
		}
		view.VmAgent = &vmAgent
	} else {
		view.VmAgent = nil
	}

	// VmHealth
	if source.VmHealth != nil {
		var vmHealth VirtualMachineHealthStatus_STATUS
		err := vmHealth.AssignProperties_From_VirtualMachineHealthStatus_STATUS(source.VmHealth)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineHealthStatus_STATUS() to populate field VmHealth")
		}
		view.VmHealth = &vmHealth
	} else {
		view.VmHealth = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		view.PropertyBag = propertyBag
	} else {
		view.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineInstanceView_STATUS interface (if implemented) to customize the conversion
	var viewAsAny any = view
	if augmentedView, ok := viewAsAny.(augmentConversionForVirtualMachineInstanceView_STATUS); ok {
		err := augmentedView.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineInstanceView_STATUS populates the provided destination VirtualMachineInstanceView_STATUS from our VirtualMachineInstanceView_STATUS
func (view *VirtualMachineInstanceView_STATUS) AssignProperties_To_VirtualMachineInstanceView_STATUS(destination *v20220301s.VirtualMachineInstanceView_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(view.PropertyBag)

	// AssignedHost
	destination.AssignedHost = genruntime.ClonePointerToString(view.AssignedHost)

	// BootDiagnostics
	if view.BootDiagnostics != nil {
		var bootDiagnostic v20220301s.BootDiagnosticsInstanceView_STATUS
		err := view.BootDiagnostics.AssignProperties_To_BootDiagnosticsInstanceView_STATUS(&bootDiagnostic)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BootDiagnosticsInstanceView_STATUS() to populate field BootDiagnostics")
		}
		destination.BootDiagnostics = &bootDiagnostic
	} else {
		destination.BootDiagnostics = nil
	}

	// ComputerName
	destination.ComputerName = genruntime.ClonePointerToString(view.ComputerName)

	// Disks
	if view.Disks != nil {
		diskList := make([]v20220301s.DiskInstanceView_STATUS, len(view.Disks))
		for diskIndex, diskItem := range view.Disks {
			// Shadow the loop variable to avoid aliasing
			diskItem := diskItem
			var disk v20220301s.DiskInstanceView_STATUS
			err := diskItem.AssignProperties_To_DiskInstanceView_STATUS(&disk)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DiskInstanceView_STATUS() to populate field Disks")
			}
			diskList[diskIndex] = disk
		}
		destination.Disks = diskList
	} else {
		destination.Disks = nil
	}

	// Extensions
	if view.Extensions != nil {
		extensionList := make([]v20220301s.VirtualMachineExtensionInstanceView_STATUS, len(view.Extensions))
		for extensionIndex, extensionItem := range view.Extensions {
			// Shadow the loop variable to avoid aliasing
			extensionItem := extensionItem
			var extension v20220301s.VirtualMachineExtensionInstanceView_STATUS
			err := extensionItem.AssignProperties_To_VirtualMachineExtensionInstanceView_STATUS(&extension)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineExtensionInstanceView_STATUS() to populate field Extensions")
			}
			extensionList[extensionIndex] = extension
		}
		destination.Extensions = extensionList
	} else {
		destination.Extensions = nil
	}

	// HyperVGeneration
	destination.HyperVGeneration = genruntime.ClonePointerToString(view.HyperVGeneration)

	// MaintenanceRedeployStatus
	if view.MaintenanceRedeployStatus != nil {
		var maintenanceRedeployStatus v20220301s.MaintenanceRedeployStatus_STATUS
		err := view.MaintenanceRedeployStatus.AssignProperties_To_MaintenanceRedeployStatus_STATUS(&maintenanceRedeployStatus)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_MaintenanceRedeployStatus_STATUS() to populate field MaintenanceRedeployStatus")
		}
		destination.MaintenanceRedeployStatus = &maintenanceRedeployStatus
	} else {
		destination.MaintenanceRedeployStatus = nil
	}

	// OsName
	destination.OsName = genruntime.ClonePointerToString(view.OsName)

	// OsVersion
	destination.OsVersion = genruntime.ClonePointerToString(view.OsVersion)

	// PatchStatus
	if view.PatchStatus != nil {
		var patchStatus v20220301s.VirtualMachinePatchStatus_STATUS
		err := view.PatchStatus.AssignProperties_To_VirtualMachinePatchStatus_STATUS(&patchStatus)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachinePatchStatus_STATUS() to populate field PatchStatus")
		}
		destination.PatchStatus = &patchStatus
	} else {
		destination.PatchStatus = nil
	}

	// PlatformFaultDomain
	destination.PlatformFaultDomain = genruntime.ClonePointerToInt(view.PlatformFaultDomain)

	// PlatformUpdateDomain
	destination.PlatformUpdateDomain = genruntime.ClonePointerToInt(view.PlatformUpdateDomain)

	// RdpThumbPrint
	destination.RdpThumbPrint = genruntime.ClonePointerToString(view.RdpThumbPrint)

	// Statuses
	if view.Statuses != nil {
		statusList := make([]v20220301s.InstanceViewStatus_STATUS, len(view.Statuses))
		for statusIndex, statusItem := range view.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status v20220301s.InstanceViewStatus_STATUS
			err := statusItem.AssignProperties_To_InstanceViewStatus_STATUS(&status)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_InstanceViewStatus_STATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		destination.Statuses = statusList
	} else {
		destination.Statuses = nil
	}

	// VmAgent
	if view.VmAgent != nil {
		var vmAgent v20220301s.VirtualMachineAgentInstanceView_STATUS
		err := view.VmAgent.AssignProperties_To_VirtualMachineAgentInstanceView_STATUS(&vmAgent)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineAgentInstanceView_STATUS() to populate field VmAgent")
		}
		destination.VmAgent = &vmAgent
	} else {
		destination.VmAgent = nil
	}

	// VmHealth
	if view.VmHealth != nil {
		var vmHealth v20220301s.VirtualMachineHealthStatus_STATUS
		err := view.VmHealth.AssignProperties_To_VirtualMachineHealthStatus_STATUS(&vmHealth)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineHealthStatus_STATUS() to populate field VmHealth")
		}
		destination.VmHealth = &vmHealth
	} else {
		destination.VmHealth = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineInstanceView_STATUS interface (if implemented) to customize the conversion
	var viewAsAny any = view
	if augmentedView, ok := viewAsAny.(augmentConversionForVirtualMachineInstanceView_STATUS); ok {
		err := augmentedView.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineOperatorSpec
// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type VirtualMachineOperatorSpec struct {
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`
	PropertyBag          genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	SecretExpressions    []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_VirtualMachineOperatorSpec populates our VirtualMachineOperatorSpec from the provided source VirtualMachineOperatorSpec
func (operator *VirtualMachineOperatorSpec) AssignProperties_From_VirtualMachineOperatorSpec(source *v20220301s.VirtualMachineOperatorSpec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		operator.PropertyBag = propertyBag
	} else {
		operator.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineOperatorSpec interface (if implemented) to customize the conversion
	var operatorAsAny any = operator
	if augmentedOperator, ok := operatorAsAny.(augmentConversionForVirtualMachineOperatorSpec); ok {
		err := augmentedOperator.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineOperatorSpec populates the provided destination VirtualMachineOperatorSpec from our VirtualMachineOperatorSpec
func (operator *VirtualMachineOperatorSpec) AssignProperties_To_VirtualMachineOperatorSpec(destination *v20220301s.VirtualMachineOperatorSpec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(operator.PropertyBag)

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineOperatorSpec interface (if implemented) to customize the conversion
	var operatorAsAny any = operator
	if augmentedOperator, ok := operatorAsAny.(augmentConversionForVirtualMachineOperatorSpec); ok {
		err := augmentedOperator.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForAdditionalCapabilities interface {
	AssignPropertiesFrom(src *v20220301s.AdditionalCapabilities) error
	AssignPropertiesTo(dst *v20220301s.AdditionalCapabilities) error
}

type augmentConversionForAdditionalCapabilities_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.AdditionalCapabilities_STATUS) error
	AssignPropertiesTo(dst *v20220301s.AdditionalCapabilities_STATUS) error
}

type augmentConversionForBillingProfile interface {
	AssignPropertiesFrom(src *v20220301s.BillingProfile) error
	AssignPropertiesTo(dst *v20220301s.BillingProfile) error
}

type augmentConversionForBillingProfile_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.BillingProfile_STATUS) error
	AssignPropertiesTo(dst *v20220301s.BillingProfile_STATUS) error
}

type augmentConversionForDiagnosticsProfile interface {
	AssignPropertiesFrom(src *v20220301s.DiagnosticsProfile) error
	AssignPropertiesTo(dst *v20220301s.DiagnosticsProfile) error
}

type augmentConversionForDiagnosticsProfile_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.DiagnosticsProfile_STATUS) error
	AssignPropertiesTo(dst *v20220301s.DiagnosticsProfile_STATUS) error
}

type augmentConversionForExtendedLocation interface {
	AssignPropertiesFrom(src *v20210701s.ExtendedLocation) error
	AssignPropertiesTo(dst *v20210701s.ExtendedLocation) error
}

type augmentConversionForExtendedLocation_STATUS interface {
	AssignPropertiesFrom(src *v20210701s.ExtendedLocation_STATUS) error
	AssignPropertiesTo(dst *v20210701s.ExtendedLocation_STATUS) error
}

type augmentConversionForHardwareProfile interface {
	AssignPropertiesFrom(src *v20220301s.HardwareProfile) error
	AssignPropertiesTo(dst *v20220301s.HardwareProfile) error
}

type augmentConversionForHardwareProfile_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.HardwareProfile_STATUS) error
	AssignPropertiesTo(dst *v20220301s.HardwareProfile_STATUS) error
}

type augmentConversionForNetworkProfile interface {
	AssignPropertiesFrom(src *v20220301s.NetworkProfile) error
	AssignPropertiesTo(dst *v20220301s.NetworkProfile) error
}

type augmentConversionForNetworkProfile_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.NetworkProfile_STATUS) error
	AssignPropertiesTo(dst *v20220301s.NetworkProfile_STATUS) error
}

type augmentConversionForOSProfile interface {
	AssignPropertiesFrom(src *v20220301s.OSProfile) error
	AssignPropertiesTo(dst *v20220301s.OSProfile) error
}

type augmentConversionForOSProfile_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.OSProfile_STATUS) error
	AssignPropertiesTo(dst *v20220301s.OSProfile_STATUS) error
}

type augmentConversionForPlan interface {
	AssignPropertiesFrom(src *v20220301s.Plan) error
	AssignPropertiesTo(dst *v20220301s.Plan) error
}

type augmentConversionForPlan_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.Plan_STATUS) error
	AssignPropertiesTo(dst *v20220301s.Plan_STATUS) error
}

type augmentConversionForSecurityProfile interface {
	AssignPropertiesFrom(src *v20220301s.SecurityProfile) error
	AssignPropertiesTo(dst *v20220301s.SecurityProfile) error
}

type augmentConversionForSecurityProfile_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.SecurityProfile_STATUS) error
	AssignPropertiesTo(dst *v20220301s.SecurityProfile_STATUS) error
}

type augmentConversionForStorageProfile interface {
	AssignPropertiesFrom(src *v20220301s.StorageProfile) error
	AssignPropertiesTo(dst *v20220301s.StorageProfile) error
}

type augmentConversionForStorageProfile_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.StorageProfile_STATUS) error
	AssignPropertiesTo(dst *v20220301s.StorageProfile_STATUS) error
}

type augmentConversionForSubResource interface {
	AssignPropertiesFrom(src *v20210701s.SubResource) error
	AssignPropertiesTo(dst *v20210701s.SubResource) error
}

type augmentConversionForSubResource_STATUS interface {
	AssignPropertiesFrom(src *v20210701s.SubResource_STATUS) error
	AssignPropertiesTo(dst *v20210701s.SubResource_STATUS) error
}

type augmentConversionForVirtualMachineExtension_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineExtension_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineExtension_STATUS) error
}

type augmentConversionForVirtualMachineIdentity interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineIdentity) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineIdentity) error
}

type augmentConversionForVirtualMachineIdentity_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineIdentity_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineIdentity_STATUS) error
}

type augmentConversionForVirtualMachineInstanceView_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineInstanceView_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineInstanceView_STATUS) error
}

type augmentConversionForVirtualMachineOperatorSpec interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineOperatorSpec) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineOperatorSpec) error
}

// Storage version of v1api20201201.BootDiagnostics
// Boot Diagnostics is a debugging feature which allows you to view Console Output and Screenshot to diagnose VM status.
// You can easily view the output of your console log.
// Azure also enables you to see a screenshot of the
// VM from the hypervisor.
type BootDiagnostics struct {
	Enabled     *bool                  `json:"enabled,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	StorageUri  *string                `json:"storageUri,omitempty"`
}

// AssignProperties_From_BootDiagnostics populates our BootDiagnostics from the provided source BootDiagnostics
func (diagnostics *BootDiagnostics) AssignProperties_From_BootDiagnostics(source *v20220301s.BootDiagnostics) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		diagnostics.Enabled = &enabled
	} else {
		diagnostics.Enabled = nil
	}

	// StorageUri
	diagnostics.StorageUri = genruntime.ClonePointerToString(source.StorageUri)

	// Update the property bag
	if len(propertyBag) > 0 {
		diagnostics.PropertyBag = propertyBag
	} else {
		diagnostics.PropertyBag = nil
	}

	// Invoke the augmentConversionForBootDiagnostics interface (if implemented) to customize the conversion
	var diagnosticsAsAny any = diagnostics
	if augmentedDiagnostics, ok := diagnosticsAsAny.(augmentConversionForBootDiagnostics); ok {
		err := augmentedDiagnostics.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_BootDiagnostics populates the provided destination BootDiagnostics from our BootDiagnostics
func (diagnostics *BootDiagnostics) AssignProperties_To_BootDiagnostics(destination *v20220301s.BootDiagnostics) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(diagnostics.PropertyBag)

	// Enabled
	if diagnostics.Enabled != nil {
		enabled := *diagnostics.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// StorageUri
	destination.StorageUri = genruntime.ClonePointerToString(diagnostics.StorageUri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForBootDiagnostics interface (if implemented) to customize the conversion
	var diagnosticsAsAny any = diagnostics
	if augmentedDiagnostics, ok := diagnosticsAsAny.(augmentConversionForBootDiagnostics); ok {
		err := augmentedDiagnostics.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.BootDiagnostics_STATUS
// Boot Diagnostics is a debugging feature which allows you to view Console Output and Screenshot to diagnose VM status.
// You can easily view the output of your console log.
// Azure also enables you to see a screenshot of the
// VM from the hypervisor.
type BootDiagnostics_STATUS struct {
	Enabled     *bool                  `json:"enabled,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	StorageUri  *string                `json:"storageUri,omitempty"`
}

// AssignProperties_From_BootDiagnostics_STATUS populates our BootDiagnostics_STATUS from the provided source BootDiagnostics_STATUS
func (diagnostics *BootDiagnostics_STATUS) AssignProperties_From_BootDiagnostics_STATUS(source *v20220301s.BootDiagnostics_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		diagnostics.Enabled = &enabled
	} else {
		diagnostics.Enabled = nil
	}

	// StorageUri
	diagnostics.StorageUri = genruntime.ClonePointerToString(source.StorageUri)

	// Update the property bag
	if len(propertyBag) > 0 {
		diagnostics.PropertyBag = propertyBag
	} else {
		diagnostics.PropertyBag = nil
	}

	// Invoke the augmentConversionForBootDiagnostics_STATUS interface (if implemented) to customize the conversion
	var diagnosticsAsAny any = diagnostics
	if augmentedDiagnostics, ok := diagnosticsAsAny.(augmentConversionForBootDiagnostics_STATUS); ok {
		err := augmentedDiagnostics.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_BootDiagnostics_STATUS populates the provided destination BootDiagnostics_STATUS from our BootDiagnostics_STATUS
func (diagnostics *BootDiagnostics_STATUS) AssignProperties_To_BootDiagnostics_STATUS(destination *v20220301s.BootDiagnostics_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(diagnostics.PropertyBag)

	// Enabled
	if diagnostics.Enabled != nil {
		enabled := *diagnostics.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// StorageUri
	destination.StorageUri = genruntime.ClonePointerToString(diagnostics.StorageUri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForBootDiagnostics_STATUS interface (if implemented) to customize the conversion
	var diagnosticsAsAny any = diagnostics
	if augmentedDiagnostics, ok := diagnosticsAsAny.(augmentConversionForBootDiagnostics_STATUS); ok {
		err := augmentedDiagnostics.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.BootDiagnosticsInstanceView_STATUS
// The instance view of a virtual machine boot diagnostics.
type BootDiagnosticsInstanceView_STATUS struct {
	ConsoleScreenshotBlobUri *string                    `json:"consoleScreenshotBlobUri,omitempty"`
	PropertyBag              genruntime.PropertyBag     `json:"$propertyBag,omitempty"`
	SerialConsoleLogBlobUri  *string                    `json:"serialConsoleLogBlobUri,omitempty"`
	Status                   *InstanceViewStatus_STATUS `json:"status,omitempty"`
}

// AssignProperties_From_BootDiagnosticsInstanceView_STATUS populates our BootDiagnosticsInstanceView_STATUS from the provided source BootDiagnosticsInstanceView_STATUS
func (view *BootDiagnosticsInstanceView_STATUS) AssignProperties_From_BootDiagnosticsInstanceView_STATUS(source *v20220301s.BootDiagnosticsInstanceView_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ConsoleScreenshotBlobUri
	view.ConsoleScreenshotBlobUri = genruntime.ClonePointerToString(source.ConsoleScreenshotBlobUri)

	// SerialConsoleLogBlobUri
	view.SerialConsoleLogBlobUri = genruntime.ClonePointerToString(source.SerialConsoleLogBlobUri)

	// Status
	if source.Status != nil {
		var status InstanceViewStatus_STATUS
		err := status.AssignProperties_From_InstanceViewStatus_STATUS(source.Status)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_InstanceViewStatus_STATUS() to populate field Status")
		}
		view.Status = &status
	} else {
		view.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		view.PropertyBag = propertyBag
	} else {
		view.PropertyBag = nil
	}

	// Invoke the augmentConversionForBootDiagnosticsInstanceView_STATUS interface (if implemented) to customize the conversion
	var viewAsAny any = view
	if augmentedView, ok := viewAsAny.(augmentConversionForBootDiagnosticsInstanceView_STATUS); ok {
		err := augmentedView.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_BootDiagnosticsInstanceView_STATUS populates the provided destination BootDiagnosticsInstanceView_STATUS from our BootDiagnosticsInstanceView_STATUS
func (view *BootDiagnosticsInstanceView_STATUS) AssignProperties_To_BootDiagnosticsInstanceView_STATUS(destination *v20220301s.BootDiagnosticsInstanceView_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(view.PropertyBag)

	// ConsoleScreenshotBlobUri
	destination.ConsoleScreenshotBlobUri = genruntime.ClonePointerToString(view.ConsoleScreenshotBlobUri)

	// SerialConsoleLogBlobUri
	destination.SerialConsoleLogBlobUri = genruntime.ClonePointerToString(view.SerialConsoleLogBlobUri)

	// Status
	if view.Status != nil {
		var status v20220301s.InstanceViewStatus_STATUS
		err := view.Status.AssignProperties_To_InstanceViewStatus_STATUS(&status)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_InstanceViewStatus_STATUS() to populate field Status")
		}
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForBootDiagnosticsInstanceView_STATUS interface (if implemented) to customize the conversion
	var viewAsAny any = view
	if augmentedView, ok := viewAsAny.(augmentConversionForBootDiagnosticsInstanceView_STATUS); ok {
		err := augmentedView.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.DataDisk
// Describes a data disk.
type DataDisk struct {
	Caching                 *string                `json:"caching,omitempty"`
	CreateOption            *string                `json:"createOption,omitempty"`
	DetachOption            *string                `json:"detachOption,omitempty"`
	DiskSizeGB              *int                   `json:"diskSizeGB,omitempty"`
	Image                   *VirtualHardDisk       `json:"image,omitempty"`
	Lun                     *int                   `json:"lun,omitempty"`
	ManagedDisk             *ManagedDiskParameters `json:"managedDisk,omitempty"`
	Name                    *string                `json:"name,omitempty"`
	PropertyBag             genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ToBeDetached            *bool                  `json:"toBeDetached,omitempty"`
	Vhd                     *VirtualHardDisk       `json:"vhd,omitempty"`
	WriteAcceleratorEnabled *bool                  `json:"writeAcceleratorEnabled,omitempty"`
}

// AssignProperties_From_DataDisk populates our DataDisk from the provided source DataDisk
func (disk *DataDisk) AssignProperties_From_DataDisk(source *v20220301s.DataDisk) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Caching
	disk.Caching = genruntime.ClonePointerToString(source.Caching)

	// CreateOption
	disk.CreateOption = genruntime.ClonePointerToString(source.CreateOption)

	// DeleteOption
	if source.DeleteOption != nil {
		propertyBag.Add("DeleteOption", *source.DeleteOption)
	} else {
		propertyBag.Remove("DeleteOption")
	}

	// DetachOption
	disk.DetachOption = genruntime.ClonePointerToString(source.DetachOption)

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// Image
	if source.Image != nil {
		var image VirtualHardDisk
		err := image.AssignProperties_From_VirtualHardDisk(source.Image)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualHardDisk() to populate field Image")
		}
		disk.Image = &image
	} else {
		disk.Image = nil
	}

	// Lun
	disk.Lun = genruntime.ClonePointerToInt(source.Lun)

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk ManagedDiskParameters
		err := managedDisk.AssignProperties_From_ManagedDiskParameters(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedDiskParameters() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// ToBeDetached
	if source.ToBeDetached != nil {
		toBeDetached := *source.ToBeDetached
		disk.ToBeDetached = &toBeDetached
	} else {
		disk.ToBeDetached = nil
	}

	// Vhd
	if source.Vhd != nil {
		var vhd VirtualHardDisk
		err := vhd.AssignProperties_From_VirtualHardDisk(source.Vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualHardDisk() to populate field Vhd")
		}
		disk.Vhd = &vhd
	} else {
		disk.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		disk.PropertyBag = propertyBag
	} else {
		disk.PropertyBag = nil
	}

	// Invoke the augmentConversionForDataDisk interface (if implemented) to customize the conversion
	var diskAsAny any = disk
	if augmentedDisk, ok := diskAsAny.(augmentConversionForDataDisk); ok {
		err := augmentedDisk.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DataDisk populates the provided destination DataDisk from our DataDisk
func (disk *DataDisk) AssignProperties_To_DataDisk(destination *v20220301s.DataDisk) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(disk.PropertyBag)

	// Caching
	destination.Caching = genruntime.ClonePointerToString(disk.Caching)

	// CreateOption
	destination.CreateOption = genruntime.ClonePointerToString(disk.CreateOption)

	// DeleteOption
	if propertyBag.Contains("DeleteOption") {
		var deleteOption string
		err := propertyBag.Pull("DeleteOption", &deleteOption)
		if err != nil {
			return errors.Wrap(err, "pulling 'DeleteOption' from propertyBag")
		}

		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// DetachOption
	destination.DetachOption = genruntime.ClonePointerToString(disk.DetachOption)

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// Image
	if disk.Image != nil {
		var image v20220301s.VirtualHardDisk
		err := disk.Image.AssignProperties_To_VirtualHardDisk(&image)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualHardDisk() to populate field Image")
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// Lun
	destination.Lun = genruntime.ClonePointerToInt(disk.Lun)

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk v20220301s.ManagedDiskParameters
		err := disk.ManagedDisk.AssignProperties_To_ManagedDiskParameters(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedDiskParameters() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// ToBeDetached
	if disk.ToBeDetached != nil {
		toBeDetached := *disk.ToBeDetached
		destination.ToBeDetached = &toBeDetached
	} else {
		destination.ToBeDetached = nil
	}

	// Vhd
	if disk.Vhd != nil {
		var vhd v20220301s.VirtualHardDisk
		err := disk.Vhd.AssignProperties_To_VirtualHardDisk(&vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualHardDisk() to populate field Vhd")
		}
		destination.Vhd = &vhd
	} else {
		destination.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDataDisk interface (if implemented) to customize the conversion
	var diskAsAny any = disk
	if augmentedDisk, ok := diskAsAny.(augmentConversionForDataDisk); ok {
		err := augmentedDisk.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.DataDisk_STATUS
// Describes a data disk.
type DataDisk_STATUS struct {
	Caching                 *string                       `json:"caching,omitempty"`
	CreateOption            *string                       `json:"createOption,omitempty"`
	DetachOption            *string                       `json:"detachOption,omitempty"`
	DiskIOPSReadWrite       *int                          `json:"diskIOPSReadWrite,omitempty"`
	DiskMBpsReadWrite       *int                          `json:"diskMBpsReadWrite,omitempty"`
	DiskSizeGB              *int                          `json:"diskSizeGB,omitempty"`
	Image                   *VirtualHardDisk_STATUS       `json:"image,omitempty"`
	Lun                     *int                          `json:"lun,omitempty"`
	ManagedDisk             *ManagedDiskParameters_STATUS `json:"managedDisk,omitempty"`
	Name                    *string                       `json:"name,omitempty"`
	PropertyBag             genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	ToBeDetached            *bool                         `json:"toBeDetached,omitempty"`
	Vhd                     *VirtualHardDisk_STATUS       `json:"vhd,omitempty"`
	WriteAcceleratorEnabled *bool                         `json:"writeAcceleratorEnabled,omitempty"`
}

// AssignProperties_From_DataDisk_STATUS populates our DataDisk_STATUS from the provided source DataDisk_STATUS
func (disk *DataDisk_STATUS) AssignProperties_From_DataDisk_STATUS(source *v20220301s.DataDisk_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Caching
	disk.Caching = genruntime.ClonePointerToString(source.Caching)

	// CreateOption
	disk.CreateOption = genruntime.ClonePointerToString(source.CreateOption)

	// DeleteOption
	if source.DeleteOption != nil {
		propertyBag.Add("DeleteOption", *source.DeleteOption)
	} else {
		propertyBag.Remove("DeleteOption")
	}

	// DetachOption
	disk.DetachOption = genruntime.ClonePointerToString(source.DetachOption)

	// DiskIOPSReadWrite
	disk.DiskIOPSReadWrite = genruntime.ClonePointerToInt(source.DiskIOPSReadWrite)

	// DiskMBpsReadWrite
	disk.DiskMBpsReadWrite = genruntime.ClonePointerToInt(source.DiskMBpsReadWrite)

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// Image
	if source.Image != nil {
		var image VirtualHardDisk_STATUS
		err := image.AssignProperties_From_VirtualHardDisk_STATUS(source.Image)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualHardDisk_STATUS() to populate field Image")
		}
		disk.Image = &image
	} else {
		disk.Image = nil
	}

	// Lun
	disk.Lun = genruntime.ClonePointerToInt(source.Lun)

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk ManagedDiskParameters_STATUS
		err := managedDisk.AssignProperties_From_ManagedDiskParameters_STATUS(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedDiskParameters_STATUS() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// ToBeDetached
	if source.ToBeDetached != nil {
		toBeDetached := *source.ToBeDetached
		disk.ToBeDetached = &toBeDetached
	} else {
		disk.ToBeDetached = nil
	}

	// Vhd
	if source.Vhd != nil {
		var vhd VirtualHardDisk_STATUS
		err := vhd.AssignProperties_From_VirtualHardDisk_STATUS(source.Vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualHardDisk_STATUS() to populate field Vhd")
		}
		disk.Vhd = &vhd
	} else {
		disk.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		disk.PropertyBag = propertyBag
	} else {
		disk.PropertyBag = nil
	}

	// Invoke the augmentConversionForDataDisk_STATUS interface (if implemented) to customize the conversion
	var diskAsAny any = disk
	if augmentedDisk, ok := diskAsAny.(augmentConversionForDataDisk_STATUS); ok {
		err := augmentedDisk.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DataDisk_STATUS populates the provided destination DataDisk_STATUS from our DataDisk_STATUS
func (disk *DataDisk_STATUS) AssignProperties_To_DataDisk_STATUS(destination *v20220301s.DataDisk_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(disk.PropertyBag)

	// Caching
	destination.Caching = genruntime.ClonePointerToString(disk.Caching)

	// CreateOption
	destination.CreateOption = genruntime.ClonePointerToString(disk.CreateOption)

	// DeleteOption
	if propertyBag.Contains("DeleteOption") {
		var deleteOption string
		err := propertyBag.Pull("DeleteOption", &deleteOption)
		if err != nil {
			return errors.Wrap(err, "pulling 'DeleteOption' from propertyBag")
		}

		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// DetachOption
	destination.DetachOption = genruntime.ClonePointerToString(disk.DetachOption)

	// DiskIOPSReadWrite
	destination.DiskIOPSReadWrite = genruntime.ClonePointerToInt(disk.DiskIOPSReadWrite)

	// DiskMBpsReadWrite
	destination.DiskMBpsReadWrite = genruntime.ClonePointerToInt(disk.DiskMBpsReadWrite)

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// Image
	if disk.Image != nil {
		var image v20220301s.VirtualHardDisk_STATUS
		err := disk.Image.AssignProperties_To_VirtualHardDisk_STATUS(&image)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualHardDisk_STATUS() to populate field Image")
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// Lun
	destination.Lun = genruntime.ClonePointerToInt(disk.Lun)

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk v20220301s.ManagedDiskParameters_STATUS
		err := disk.ManagedDisk.AssignProperties_To_ManagedDiskParameters_STATUS(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedDiskParameters_STATUS() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// ToBeDetached
	if disk.ToBeDetached != nil {
		toBeDetached := *disk.ToBeDetached
		destination.ToBeDetached = &toBeDetached
	} else {
		destination.ToBeDetached = nil
	}

	// Vhd
	if disk.Vhd != nil {
		var vhd v20220301s.VirtualHardDisk_STATUS
		err := disk.Vhd.AssignProperties_To_VirtualHardDisk_STATUS(&vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualHardDisk_STATUS() to populate field Vhd")
		}
		destination.Vhd = &vhd
	} else {
		destination.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDataDisk_STATUS interface (if implemented) to customize the conversion
	var diskAsAny any = disk
	if augmentedDisk, ok := diskAsAny.(augmentConversionForDataDisk_STATUS); ok {
		err := augmentedDisk.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.DiskInstanceView_STATUS
// The instance view of the disk.
type DiskInstanceView_STATUS struct {
	EncryptionSettings []DiskEncryptionSettings_STATUS `json:"encryptionSettings,omitempty"`
	Name               *string                         `json:"name,omitempty"`
	PropertyBag        genruntime.PropertyBag          `json:"$propertyBag,omitempty"`
	Statuses           []InstanceViewStatus_STATUS     `json:"statuses,omitempty"`
}

// AssignProperties_From_DiskInstanceView_STATUS populates our DiskInstanceView_STATUS from the provided source DiskInstanceView_STATUS
func (view *DiskInstanceView_STATUS) AssignProperties_From_DiskInstanceView_STATUS(source *v20220301s.DiskInstanceView_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// EncryptionSettings
	if source.EncryptionSettings != nil {
		encryptionSettingList := make([]DiskEncryptionSettings_STATUS, len(source.EncryptionSettings))
		for encryptionSettingIndex, encryptionSettingItem := range source.EncryptionSettings {
			// Shadow the loop variable to avoid aliasing
			encryptionSettingItem := encryptionSettingItem
			var encryptionSetting DiskEncryptionSettings_STATUS
			err := encryptionSetting.AssignProperties_From_DiskEncryptionSettings_STATUS(&encryptionSettingItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DiskEncryptionSettings_STATUS() to populate field EncryptionSettings")
			}
			encryptionSettingList[encryptionSettingIndex] = encryptionSetting
		}
		view.EncryptionSettings = encryptionSettingList
	} else {
		view.EncryptionSettings = nil
	}

	// Name
	view.Name = genruntime.ClonePointerToString(source.Name)

	// Statuses
	if source.Statuses != nil {
		statusList := make([]InstanceViewStatus_STATUS, len(source.Statuses))
		for statusIndex, statusItem := range source.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status InstanceViewStatus_STATUS
			err := status.AssignProperties_From_InstanceViewStatus_STATUS(&statusItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_InstanceViewStatus_STATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		view.Statuses = statusList
	} else {
		view.Statuses = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		view.PropertyBag = propertyBag
	} else {
		view.PropertyBag = nil
	}

	// Invoke the augmentConversionForDiskInstanceView_STATUS interface (if implemented) to customize the conversion
	var viewAsAny any = view
	if augmentedView, ok := viewAsAny.(augmentConversionForDiskInstanceView_STATUS); ok {
		err := augmentedView.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DiskInstanceView_STATUS populates the provided destination DiskInstanceView_STATUS from our DiskInstanceView_STATUS
func (view *DiskInstanceView_STATUS) AssignProperties_To_DiskInstanceView_STATUS(destination *v20220301s.DiskInstanceView_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(view.PropertyBag)

	// EncryptionSettings
	if view.EncryptionSettings != nil {
		encryptionSettingList := make([]v20220301s.DiskEncryptionSettings_STATUS, len(view.EncryptionSettings))
		for encryptionSettingIndex, encryptionSettingItem := range view.EncryptionSettings {
			// Shadow the loop variable to avoid aliasing
			encryptionSettingItem := encryptionSettingItem
			var encryptionSetting v20220301s.DiskEncryptionSettings_STATUS
			err := encryptionSettingItem.AssignProperties_To_DiskEncryptionSettings_STATUS(&encryptionSetting)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DiskEncryptionSettings_STATUS() to populate field EncryptionSettings")
			}
			encryptionSettingList[encryptionSettingIndex] = encryptionSetting
		}
		destination.EncryptionSettings = encryptionSettingList
	} else {
		destination.EncryptionSettings = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(view.Name)

	// Statuses
	if view.Statuses != nil {
		statusList := make([]v20220301s.InstanceViewStatus_STATUS, len(view.Statuses))
		for statusIndex, statusItem := range view.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status v20220301s.InstanceViewStatus_STATUS
			err := statusItem.AssignProperties_To_InstanceViewStatus_STATUS(&status)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_InstanceViewStatus_STATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		destination.Statuses = statusList
	} else {
		destination.Statuses = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDiskInstanceView_STATUS interface (if implemented) to customize the conversion
	var viewAsAny any = view
	if augmentedView, ok := viewAsAny.(augmentConversionForDiskInstanceView_STATUS); ok {
		err := augmentedView.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.ImageReference
// Specifies information about the image to use. You can specify information about platform images, marketplace images, or
// virtual machine images. This element is required when you want to use a platform image, marketplace image, or virtual
// machine image, but is not used in other creation operations. NOTE: Image reference publisher and offer can only be set
// when you create the scale set.
type ImageReference struct {
	Offer       *string                `json:"offer,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Publisher   *string                `json:"publisher,omitempty"`

	// Reference: Resource Id
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
	Sku       *string                       `json:"sku,omitempty"`
	Version   *string                       `json:"version,omitempty"`
}

// AssignProperties_From_ImageReference populates our ImageReference from the provided source ImageReference
func (reference *ImageReference) AssignProperties_From_ImageReference(source *v20220301s.ImageReference) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CommunityGalleryImageId
	if source.CommunityGalleryImageId != nil {
		propertyBag.Add("CommunityGalleryImageId", *source.CommunityGalleryImageId)
	} else {
		propertyBag.Remove("CommunityGalleryImageId")
	}

	// Offer
	reference.Offer = genruntime.ClonePointerToString(source.Offer)

	// Publisher
	reference.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// Reference
	if source.Reference != nil {
		referenceTemp := source.Reference.Copy()
		reference.Reference = &referenceTemp
	} else {
		reference.Reference = nil
	}

	// SharedGalleryImageId
	if source.SharedGalleryImageId != nil {
		propertyBag.Add("SharedGalleryImageId", *source.SharedGalleryImageId)
	} else {
		propertyBag.Remove("SharedGalleryImageId")
	}

	// Sku
	reference.Sku = genruntime.ClonePointerToString(source.Sku)

	// Version
	reference.Version = genruntime.ClonePointerToString(source.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		reference.PropertyBag = propertyBag
	} else {
		reference.PropertyBag = nil
	}

	// Invoke the augmentConversionForImageReference interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForImageReference); ok {
		err := augmentedReference.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ImageReference populates the provided destination ImageReference from our ImageReference
func (reference *ImageReference) AssignProperties_To_ImageReference(destination *v20220301s.ImageReference) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(reference.PropertyBag)

	// CommunityGalleryImageId
	if propertyBag.Contains("CommunityGalleryImageId") {
		var communityGalleryImageId string
		err := propertyBag.Pull("CommunityGalleryImageId", &communityGalleryImageId)
		if err != nil {
			return errors.Wrap(err, "pulling 'CommunityGalleryImageId' from propertyBag")
		}

		destination.CommunityGalleryImageId = &communityGalleryImageId
	} else {
		destination.CommunityGalleryImageId = nil
	}

	// Offer
	destination.Offer = genruntime.ClonePointerToString(reference.Offer)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(reference.Publisher)

	// Reference
	if reference.Reference != nil {
		referenceTemp := reference.Reference.Copy()
		destination.Reference = &referenceTemp
	} else {
		destination.Reference = nil
	}

	// SharedGalleryImageId
	if propertyBag.Contains("SharedGalleryImageId") {
		var sharedGalleryImageId string
		err := propertyBag.Pull("SharedGalleryImageId", &sharedGalleryImageId)
		if err != nil {
			return errors.Wrap(err, "pulling 'SharedGalleryImageId' from propertyBag")
		}

		destination.SharedGalleryImageId = &sharedGalleryImageId
	} else {
		destination.SharedGalleryImageId = nil
	}

	// Sku
	destination.Sku = genruntime.ClonePointerToString(reference.Sku)

	// Version
	destination.Version = genruntime.ClonePointerToString(reference.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForImageReference interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForImageReference); ok {
		err := augmentedReference.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.ImageReference_STATUS
// Specifies information about the image to use. You can specify information about platform images, marketplace images, or
// virtual machine images. This element is required when you want to use a platform image, marketplace image, or virtual
// machine image, but is not used in other creation operations. NOTE: Image reference publisher and offer can only be set
// when you create the scale set.
type ImageReference_STATUS struct {
	ExactVersion *string                `json:"exactVersion,omitempty"`
	Id           *string                `json:"id,omitempty"`
	Offer        *string                `json:"offer,omitempty"`
	PropertyBag  genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Publisher    *string                `json:"publisher,omitempty"`
	Sku          *string                `json:"sku,omitempty"`
	Version      *string                `json:"version,omitempty"`
}

// AssignProperties_From_ImageReference_STATUS populates our ImageReference_STATUS from the provided source ImageReference_STATUS
func (reference *ImageReference_STATUS) AssignProperties_From_ImageReference_STATUS(source *v20220301s.ImageReference_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CommunityGalleryImageId
	if source.CommunityGalleryImageId != nil {
		propertyBag.Add("CommunityGalleryImageId", *source.CommunityGalleryImageId)
	} else {
		propertyBag.Remove("CommunityGalleryImageId")
	}

	// ExactVersion
	reference.ExactVersion = genruntime.ClonePointerToString(source.ExactVersion)

	// Id
	reference.Id = genruntime.ClonePointerToString(source.Id)

	// Offer
	reference.Offer = genruntime.ClonePointerToString(source.Offer)

	// Publisher
	reference.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// SharedGalleryImageId
	if source.SharedGalleryImageId != nil {
		propertyBag.Add("SharedGalleryImageId", *source.SharedGalleryImageId)
	} else {
		propertyBag.Remove("SharedGalleryImageId")
	}

	// Sku
	reference.Sku = genruntime.ClonePointerToString(source.Sku)

	// Version
	reference.Version = genruntime.ClonePointerToString(source.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		reference.PropertyBag = propertyBag
	} else {
		reference.PropertyBag = nil
	}

	// Invoke the augmentConversionForImageReference_STATUS interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForImageReference_STATUS); ok {
		err := augmentedReference.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ImageReference_STATUS populates the provided destination ImageReference_STATUS from our ImageReference_STATUS
func (reference *ImageReference_STATUS) AssignProperties_To_ImageReference_STATUS(destination *v20220301s.ImageReference_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(reference.PropertyBag)

	// CommunityGalleryImageId
	if propertyBag.Contains("CommunityGalleryImageId") {
		var communityGalleryImageId string
		err := propertyBag.Pull("CommunityGalleryImageId", &communityGalleryImageId)
		if err != nil {
			return errors.Wrap(err, "pulling 'CommunityGalleryImageId' from propertyBag")
		}

		destination.CommunityGalleryImageId = &communityGalleryImageId
	} else {
		destination.CommunityGalleryImageId = nil
	}

	// ExactVersion
	destination.ExactVersion = genruntime.ClonePointerToString(reference.ExactVersion)

	// Id
	destination.Id = genruntime.ClonePointerToString(reference.Id)

	// Offer
	destination.Offer = genruntime.ClonePointerToString(reference.Offer)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(reference.Publisher)

	// SharedGalleryImageId
	if propertyBag.Contains("SharedGalleryImageId") {
		var sharedGalleryImageId string
		err := propertyBag.Pull("SharedGalleryImageId", &sharedGalleryImageId)
		if err != nil {
			return errors.Wrap(err, "pulling 'SharedGalleryImageId' from propertyBag")
		}

		destination.SharedGalleryImageId = &sharedGalleryImageId
	} else {
		destination.SharedGalleryImageId = nil
	}

	// Sku
	destination.Sku = genruntime.ClonePointerToString(reference.Sku)

	// Version
	destination.Version = genruntime.ClonePointerToString(reference.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForImageReference_STATUS interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForImageReference_STATUS); ok {
		err := augmentedReference.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.InstanceViewStatus_STATUS
// Instance view status.
type InstanceViewStatus_STATUS struct {
	Code          *string                `json:"code,omitempty"`
	DisplayStatus *string                `json:"displayStatus,omitempty"`
	Level         *string                `json:"level,omitempty"`
	Message       *string                `json:"message,omitempty"`
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Time          *string                `json:"time,omitempty"`
}

// AssignProperties_From_InstanceViewStatus_STATUS populates our InstanceViewStatus_STATUS from the provided source InstanceViewStatus_STATUS
func (status *InstanceViewStatus_STATUS) AssignProperties_From_InstanceViewStatus_STATUS(source *v20220301s.InstanceViewStatus_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Code
	status.Code = genruntime.ClonePointerToString(source.Code)

	// DisplayStatus
	status.DisplayStatus = genruntime.ClonePointerToString(source.DisplayStatus)

	// Level
	status.Level = genruntime.ClonePointerToString(source.Level)

	// Message
	status.Message = genruntime.ClonePointerToString(source.Message)

	// Time
	status.Time = genruntime.ClonePointerToString(source.Time)

	// Update the property bag
	if len(propertyBag) > 0 {
		status.PropertyBag = propertyBag
	} else {
		status.PropertyBag = nil
	}

	// Invoke the augmentConversionForInstanceViewStatus_STATUS interface (if implemented) to customize the conversion
	var statusAsAny any = status
	if augmentedStatus, ok := statusAsAny.(augmentConversionForInstanceViewStatus_STATUS); ok {
		err := augmentedStatus.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_InstanceViewStatus_STATUS populates the provided destination InstanceViewStatus_STATUS from our InstanceViewStatus_STATUS
func (status *InstanceViewStatus_STATUS) AssignProperties_To_InstanceViewStatus_STATUS(destination *v20220301s.InstanceViewStatus_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(status.PropertyBag)

	// Code
	destination.Code = genruntime.ClonePointerToString(status.Code)

	// DisplayStatus
	destination.DisplayStatus = genruntime.ClonePointerToString(status.DisplayStatus)

	// Level
	destination.Level = genruntime.ClonePointerToString(status.Level)

	// Message
	destination.Message = genruntime.ClonePointerToString(status.Message)

	// Time
	destination.Time = genruntime.ClonePointerToString(status.Time)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForInstanceViewStatus_STATUS interface (if implemented) to customize the conversion
	var statusAsAny any = status
	if augmentedStatus, ok := statusAsAny.(augmentConversionForInstanceViewStatus_STATUS); ok {
		err := augmentedStatus.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.LinuxConfiguration
// Specifies the Linux operating system settings on the virtual machine.
// For a list of supported Linux
// distributions, see [Linux on Azure-Endorsed
// Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-endorsed-distros?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
// For running non-endorsed distributions, see [Information for Non-Endorsed
// Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-create-upload-generic?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
type LinuxConfiguration struct {
	DisablePasswordAuthentication *bool                  `json:"disablePasswordAuthentication,omitempty"`
	PatchSettings                 *LinuxPatchSettings    `json:"patchSettings,omitempty"`
	PropertyBag                   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ProvisionVMAgent              *bool                  `json:"provisionVMAgent,omitempty"`
	Ssh                           *SshConfiguration      `json:"ssh,omitempty"`
}

// AssignProperties_From_LinuxConfiguration populates our LinuxConfiguration from the provided source LinuxConfiguration
func (configuration *LinuxConfiguration) AssignProperties_From_LinuxConfiguration(source *v20220301s.LinuxConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DisablePasswordAuthentication
	if source.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *source.DisablePasswordAuthentication
		configuration.DisablePasswordAuthentication = &disablePasswordAuthentication
	} else {
		configuration.DisablePasswordAuthentication = nil
	}

	// PatchSettings
	if source.PatchSettings != nil {
		var patchSetting LinuxPatchSettings
		err := patchSetting.AssignProperties_From_LinuxPatchSettings(source.PatchSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_LinuxPatchSettings() to populate field PatchSettings")
		}
		configuration.PatchSettings = &patchSetting
	} else {
		configuration.PatchSettings = nil
	}

	// ProvisionVMAgent
	if source.ProvisionVMAgent != nil {
		provisionVMAgent := *source.ProvisionVMAgent
		configuration.ProvisionVMAgent = &provisionVMAgent
	} else {
		configuration.ProvisionVMAgent = nil
	}

	// Ssh
	if source.Ssh != nil {
		var ssh SshConfiguration
		err := ssh.AssignProperties_From_SshConfiguration(source.Ssh)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SshConfiguration() to populate field Ssh")
		}
		configuration.Ssh = &ssh
	} else {
		configuration.Ssh = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForLinuxConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForLinuxConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_LinuxConfiguration populates the provided destination LinuxConfiguration from our LinuxConfiguration
func (configuration *LinuxConfiguration) AssignProperties_To_LinuxConfiguration(destination *v20220301s.LinuxConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// DisablePasswordAuthentication
	if configuration.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *configuration.DisablePasswordAuthentication
		destination.DisablePasswordAuthentication = &disablePasswordAuthentication
	} else {
		destination.DisablePasswordAuthentication = nil
	}

	// PatchSettings
	if configuration.PatchSettings != nil {
		var patchSetting v20220301s.LinuxPatchSettings
		err := configuration.PatchSettings.AssignProperties_To_LinuxPatchSettings(&patchSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_LinuxPatchSettings() to populate field PatchSettings")
		}
		destination.PatchSettings = &patchSetting
	} else {
		destination.PatchSettings = nil
	}

	// ProvisionVMAgent
	if configuration.ProvisionVMAgent != nil {
		provisionVMAgent := *configuration.ProvisionVMAgent
		destination.ProvisionVMAgent = &provisionVMAgent
	} else {
		destination.ProvisionVMAgent = nil
	}

	// Ssh
	if configuration.Ssh != nil {
		var ssh v20220301s.SshConfiguration
		err := configuration.Ssh.AssignProperties_To_SshConfiguration(&ssh)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SshConfiguration() to populate field Ssh")
		}
		destination.Ssh = &ssh
	} else {
		destination.Ssh = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForLinuxConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForLinuxConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.LinuxConfiguration_STATUS
// Specifies the Linux operating system settings on the virtual machine.
// For a list of supported Linux
// distributions, see [Linux on Azure-Endorsed
// Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-endorsed-distros?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
// For running non-endorsed distributions, see [Information for Non-Endorsed
// Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-create-upload-generic?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
type LinuxConfiguration_STATUS struct {
	DisablePasswordAuthentication *bool                      `json:"disablePasswordAuthentication,omitempty"`
	PatchSettings                 *LinuxPatchSettings_STATUS `json:"patchSettings,omitempty"`
	PropertyBag                   genruntime.PropertyBag     `json:"$propertyBag,omitempty"`
	ProvisionVMAgent              *bool                      `json:"provisionVMAgent,omitempty"`
	Ssh                           *SshConfiguration_STATUS   `json:"ssh,omitempty"`
}

// AssignProperties_From_LinuxConfiguration_STATUS populates our LinuxConfiguration_STATUS from the provided source LinuxConfiguration_STATUS
func (configuration *LinuxConfiguration_STATUS) AssignProperties_From_LinuxConfiguration_STATUS(source *v20220301s.LinuxConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DisablePasswordAuthentication
	if source.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *source.DisablePasswordAuthentication
		configuration.DisablePasswordAuthentication = &disablePasswordAuthentication
	} else {
		configuration.DisablePasswordAuthentication = nil
	}

	// PatchSettings
	if source.PatchSettings != nil {
		var patchSetting LinuxPatchSettings_STATUS
		err := patchSetting.AssignProperties_From_LinuxPatchSettings_STATUS(source.PatchSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_LinuxPatchSettings_STATUS() to populate field PatchSettings")
		}
		configuration.PatchSettings = &patchSetting
	} else {
		configuration.PatchSettings = nil
	}

	// ProvisionVMAgent
	if source.ProvisionVMAgent != nil {
		provisionVMAgent := *source.ProvisionVMAgent
		configuration.ProvisionVMAgent = &provisionVMAgent
	} else {
		configuration.ProvisionVMAgent = nil
	}

	// Ssh
	if source.Ssh != nil {
		var ssh SshConfiguration_STATUS
		err := ssh.AssignProperties_From_SshConfiguration_STATUS(source.Ssh)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SshConfiguration_STATUS() to populate field Ssh")
		}
		configuration.Ssh = &ssh
	} else {
		configuration.Ssh = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForLinuxConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForLinuxConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_LinuxConfiguration_STATUS populates the provided destination LinuxConfiguration_STATUS from our LinuxConfiguration_STATUS
func (configuration *LinuxConfiguration_STATUS) AssignProperties_To_LinuxConfiguration_STATUS(destination *v20220301s.LinuxConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// DisablePasswordAuthentication
	if configuration.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *configuration.DisablePasswordAuthentication
		destination.DisablePasswordAuthentication = &disablePasswordAuthentication
	} else {
		destination.DisablePasswordAuthentication = nil
	}

	// PatchSettings
	if configuration.PatchSettings != nil {
		var patchSetting v20220301s.LinuxPatchSettings_STATUS
		err := configuration.PatchSettings.AssignProperties_To_LinuxPatchSettings_STATUS(&patchSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_LinuxPatchSettings_STATUS() to populate field PatchSettings")
		}
		destination.PatchSettings = &patchSetting
	} else {
		destination.PatchSettings = nil
	}

	// ProvisionVMAgent
	if configuration.ProvisionVMAgent != nil {
		provisionVMAgent := *configuration.ProvisionVMAgent
		destination.ProvisionVMAgent = &provisionVMAgent
	} else {
		destination.ProvisionVMAgent = nil
	}

	// Ssh
	if configuration.Ssh != nil {
		var ssh v20220301s.SshConfiguration_STATUS
		err := configuration.Ssh.AssignProperties_To_SshConfiguration_STATUS(&ssh)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SshConfiguration_STATUS() to populate field Ssh")
		}
		destination.Ssh = &ssh
	} else {
		destination.Ssh = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForLinuxConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForLinuxConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.MaintenanceRedeployStatus_STATUS
// Maintenance Operation Status.
type MaintenanceRedeployStatus_STATUS struct {
	IsCustomerInitiatedMaintenanceAllowed *bool                  `json:"isCustomerInitiatedMaintenanceAllowed,omitempty"`
	LastOperationMessage                  *string                `json:"lastOperationMessage,omitempty"`
	LastOperationResultCode               *string                `json:"lastOperationResultCode,omitempty"`
	MaintenanceWindowEndTime              *string                `json:"maintenanceWindowEndTime,omitempty"`
	MaintenanceWindowStartTime            *string                `json:"maintenanceWindowStartTime,omitempty"`
	PreMaintenanceWindowEndTime           *string                `json:"preMaintenanceWindowEndTime,omitempty"`
	PreMaintenanceWindowStartTime         *string                `json:"preMaintenanceWindowStartTime,omitempty"`
	PropertyBag                           genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_MaintenanceRedeployStatus_STATUS populates our MaintenanceRedeployStatus_STATUS from the provided source MaintenanceRedeployStatus_STATUS
func (status *MaintenanceRedeployStatus_STATUS) AssignProperties_From_MaintenanceRedeployStatus_STATUS(source *v20220301s.MaintenanceRedeployStatus_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// IsCustomerInitiatedMaintenanceAllowed
	if source.IsCustomerInitiatedMaintenanceAllowed != nil {
		isCustomerInitiatedMaintenanceAllowed := *source.IsCustomerInitiatedMaintenanceAllowed
		status.IsCustomerInitiatedMaintenanceAllowed = &isCustomerInitiatedMaintenanceAllowed
	} else {
		status.IsCustomerInitiatedMaintenanceAllowed = nil
	}

	// LastOperationMessage
	status.LastOperationMessage = genruntime.ClonePointerToString(source.LastOperationMessage)

	// LastOperationResultCode
	status.LastOperationResultCode = genruntime.ClonePointerToString(source.LastOperationResultCode)

	// MaintenanceWindowEndTime
	status.MaintenanceWindowEndTime = genruntime.ClonePointerToString(source.MaintenanceWindowEndTime)

	// MaintenanceWindowStartTime
	status.MaintenanceWindowStartTime = genruntime.ClonePointerToString(source.MaintenanceWindowStartTime)

	// PreMaintenanceWindowEndTime
	status.PreMaintenanceWindowEndTime = genruntime.ClonePointerToString(source.PreMaintenanceWindowEndTime)

	// PreMaintenanceWindowStartTime
	status.PreMaintenanceWindowStartTime = genruntime.ClonePointerToString(source.PreMaintenanceWindowStartTime)

	// Update the property bag
	if len(propertyBag) > 0 {
		status.PropertyBag = propertyBag
	} else {
		status.PropertyBag = nil
	}

	// Invoke the augmentConversionForMaintenanceRedeployStatus_STATUS interface (if implemented) to customize the conversion
	var statusAsAny any = status
	if augmentedStatus, ok := statusAsAny.(augmentConversionForMaintenanceRedeployStatus_STATUS); ok {
		err := augmentedStatus.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_MaintenanceRedeployStatus_STATUS populates the provided destination MaintenanceRedeployStatus_STATUS from our MaintenanceRedeployStatus_STATUS
func (status *MaintenanceRedeployStatus_STATUS) AssignProperties_To_MaintenanceRedeployStatus_STATUS(destination *v20220301s.MaintenanceRedeployStatus_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(status.PropertyBag)

	// IsCustomerInitiatedMaintenanceAllowed
	if status.IsCustomerInitiatedMaintenanceAllowed != nil {
		isCustomerInitiatedMaintenanceAllowed := *status.IsCustomerInitiatedMaintenanceAllowed
		destination.IsCustomerInitiatedMaintenanceAllowed = &isCustomerInitiatedMaintenanceAllowed
	} else {
		destination.IsCustomerInitiatedMaintenanceAllowed = nil
	}

	// LastOperationMessage
	destination.LastOperationMessage = genruntime.ClonePointerToString(status.LastOperationMessage)

	// LastOperationResultCode
	destination.LastOperationResultCode = genruntime.ClonePointerToString(status.LastOperationResultCode)

	// MaintenanceWindowEndTime
	destination.MaintenanceWindowEndTime = genruntime.ClonePointerToString(status.MaintenanceWindowEndTime)

	// MaintenanceWindowStartTime
	destination.MaintenanceWindowStartTime = genruntime.ClonePointerToString(status.MaintenanceWindowStartTime)

	// PreMaintenanceWindowEndTime
	destination.PreMaintenanceWindowEndTime = genruntime.ClonePointerToString(status.PreMaintenanceWindowEndTime)

	// PreMaintenanceWindowStartTime
	destination.PreMaintenanceWindowStartTime = genruntime.ClonePointerToString(status.PreMaintenanceWindowStartTime)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForMaintenanceRedeployStatus_STATUS interface (if implemented) to customize the conversion
	var statusAsAny any = status
	if augmentedStatus, ok := statusAsAny.(augmentConversionForMaintenanceRedeployStatus_STATUS); ok {
		err := augmentedStatus.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.NetworkInterfaceReference
// Describes a network interface reference.
type NetworkInterfaceReference struct {
	Primary     *bool                  `json:"primary,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`

	// Reference: Resource Id
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

// AssignProperties_From_NetworkInterfaceReference populates our NetworkInterfaceReference from the provided source NetworkInterfaceReference
func (reference *NetworkInterfaceReference) AssignProperties_From_NetworkInterfaceReference(source *v20220301s.NetworkInterfaceReference) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DeleteOption
	if source.DeleteOption != nil {
		propertyBag.Add("DeleteOption", *source.DeleteOption)
	} else {
		propertyBag.Remove("DeleteOption")
	}

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		reference.Primary = &primary
	} else {
		reference.Primary = nil
	}

	// Reference
	if source.Reference != nil {
		referenceTemp := source.Reference.Copy()
		reference.Reference = &referenceTemp
	} else {
		reference.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		reference.PropertyBag = propertyBag
	} else {
		reference.PropertyBag = nil
	}

	// Invoke the augmentConversionForNetworkInterfaceReference interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForNetworkInterfaceReference); ok {
		err := augmentedReference.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_NetworkInterfaceReference populates the provided destination NetworkInterfaceReference from our NetworkInterfaceReference
func (reference *NetworkInterfaceReference) AssignProperties_To_NetworkInterfaceReference(destination *v20220301s.NetworkInterfaceReference) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(reference.PropertyBag)

	// DeleteOption
	if propertyBag.Contains("DeleteOption") {
		var deleteOption string
		err := propertyBag.Pull("DeleteOption", &deleteOption)
		if err != nil {
			return errors.Wrap(err, "pulling 'DeleteOption' from propertyBag")
		}

		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// Primary
	if reference.Primary != nil {
		primary := *reference.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// Reference
	if reference.Reference != nil {
		referenceTemp := reference.Reference.Copy()
		destination.Reference = &referenceTemp
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForNetworkInterfaceReference interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForNetworkInterfaceReference); ok {
		err := augmentedReference.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.NetworkInterfaceReference_STATUS
// Describes a network interface reference.
type NetworkInterfaceReference_STATUS struct {
	Id          *string                `json:"id,omitempty"`
	Primary     *bool                  `json:"primary,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_NetworkInterfaceReference_STATUS populates our NetworkInterfaceReference_STATUS from the provided source NetworkInterfaceReference_STATUS
func (reference *NetworkInterfaceReference_STATUS) AssignProperties_From_NetworkInterfaceReference_STATUS(source *v20220301s.NetworkInterfaceReference_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DeleteOption
	if source.DeleteOption != nil {
		propertyBag.Add("DeleteOption", *source.DeleteOption)
	} else {
		propertyBag.Remove("DeleteOption")
	}

	// Id
	reference.Id = genruntime.ClonePointerToString(source.Id)

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		reference.Primary = &primary
	} else {
		reference.Primary = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		reference.PropertyBag = propertyBag
	} else {
		reference.PropertyBag = nil
	}

	// Invoke the augmentConversionForNetworkInterfaceReference_STATUS interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForNetworkInterfaceReference_STATUS); ok {
		err := augmentedReference.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_NetworkInterfaceReference_STATUS populates the provided destination NetworkInterfaceReference_STATUS from our NetworkInterfaceReference_STATUS
func (reference *NetworkInterfaceReference_STATUS) AssignProperties_To_NetworkInterfaceReference_STATUS(destination *v20220301s.NetworkInterfaceReference_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(reference.PropertyBag)

	// DeleteOption
	if propertyBag.Contains("DeleteOption") {
		var deleteOption string
		err := propertyBag.Pull("DeleteOption", &deleteOption)
		if err != nil {
			return errors.Wrap(err, "pulling 'DeleteOption' from propertyBag")
		}

		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(reference.Id)

	// Primary
	if reference.Primary != nil {
		primary := *reference.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForNetworkInterfaceReference_STATUS interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForNetworkInterfaceReference_STATUS); ok {
		err := augmentedReference.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.OSDisk
// Specifies information about the operating system disk used by the virtual machine.
// For more information about
// disks, see [About disks and VHDs for Azure virtual
// machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-about-disks-vhds?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json).
type OSDisk struct {
	Caching                 *string                 `json:"caching,omitempty"`
	CreateOption            *string                 `json:"createOption,omitempty"`
	DiffDiskSettings        *DiffDiskSettings       `json:"diffDiskSettings,omitempty"`
	DiskSizeGB              *int                    `json:"diskSizeGB,omitempty"`
	EncryptionSettings      *DiskEncryptionSettings `json:"encryptionSettings,omitempty"`
	Image                   *VirtualHardDisk        `json:"image,omitempty"`
	ManagedDisk             *ManagedDiskParameters  `json:"managedDisk,omitempty"`
	Name                    *string                 `json:"name,omitempty"`
	OsType                  *string                 `json:"osType,omitempty"`
	PropertyBag             genruntime.PropertyBag  `json:"$propertyBag,omitempty"`
	Vhd                     *VirtualHardDisk        `json:"vhd,omitempty"`
	WriteAcceleratorEnabled *bool                   `json:"writeAcceleratorEnabled,omitempty"`
}

// AssignProperties_From_OSDisk populates our OSDisk from the provided source OSDisk
func (disk *OSDisk) AssignProperties_From_OSDisk(source *v20220301s.OSDisk) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Caching
	disk.Caching = genruntime.ClonePointerToString(source.Caching)

	// CreateOption
	disk.CreateOption = genruntime.ClonePointerToString(source.CreateOption)

	// DeleteOption
	if source.DeleteOption != nil {
		propertyBag.Add("DeleteOption", *source.DeleteOption)
	} else {
		propertyBag.Remove("DeleteOption")
	}

	// DiffDiskSettings
	if source.DiffDiskSettings != nil {
		var diffDiskSetting DiffDiskSettings
		err := diffDiskSetting.AssignProperties_From_DiffDiskSettings(source.DiffDiskSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DiffDiskSettings() to populate field DiffDiskSettings")
		}
		disk.DiffDiskSettings = &diffDiskSetting
	} else {
		disk.DiffDiskSettings = nil
	}

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// EncryptionSettings
	if source.EncryptionSettings != nil {
		var encryptionSetting DiskEncryptionSettings
		err := encryptionSetting.AssignProperties_From_DiskEncryptionSettings(source.EncryptionSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DiskEncryptionSettings() to populate field EncryptionSettings")
		}
		disk.EncryptionSettings = &encryptionSetting
	} else {
		disk.EncryptionSettings = nil
	}

	// Image
	if source.Image != nil {
		var image VirtualHardDisk
		err := image.AssignProperties_From_VirtualHardDisk(source.Image)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualHardDisk() to populate field Image")
		}
		disk.Image = &image
	} else {
		disk.Image = nil
	}

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk ManagedDiskParameters
		err := managedDisk.AssignProperties_From_ManagedDiskParameters(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedDiskParameters() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// OsType
	disk.OsType = genruntime.ClonePointerToString(source.OsType)

	// Vhd
	if source.Vhd != nil {
		var vhd VirtualHardDisk
		err := vhd.AssignProperties_From_VirtualHardDisk(source.Vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualHardDisk() to populate field Vhd")
		}
		disk.Vhd = &vhd
	} else {
		disk.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		disk.PropertyBag = propertyBag
	} else {
		disk.PropertyBag = nil
	}

	// Invoke the augmentConversionForOSDisk interface (if implemented) to customize the conversion
	var diskAsAny any = disk
	if augmentedDisk, ok := diskAsAny.(augmentConversionForOSDisk); ok {
		err := augmentedDisk.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_OSDisk populates the provided destination OSDisk from our OSDisk
func (disk *OSDisk) AssignProperties_To_OSDisk(destination *v20220301s.OSDisk) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(disk.PropertyBag)

	// Caching
	destination.Caching = genruntime.ClonePointerToString(disk.Caching)

	// CreateOption
	destination.CreateOption = genruntime.ClonePointerToString(disk.CreateOption)

	// DeleteOption
	if propertyBag.Contains("DeleteOption") {
		var deleteOption string
		err := propertyBag.Pull("DeleteOption", &deleteOption)
		if err != nil {
			return errors.Wrap(err, "pulling 'DeleteOption' from propertyBag")
		}

		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// DiffDiskSettings
	if disk.DiffDiskSettings != nil {
		var diffDiskSetting v20220301s.DiffDiskSettings
		err := disk.DiffDiskSettings.AssignProperties_To_DiffDiskSettings(&diffDiskSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DiffDiskSettings() to populate field DiffDiskSettings")
		}
		destination.DiffDiskSettings = &diffDiskSetting
	} else {
		destination.DiffDiskSettings = nil
	}

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// EncryptionSettings
	if disk.EncryptionSettings != nil {
		var encryptionSetting v20220301s.DiskEncryptionSettings
		err := disk.EncryptionSettings.AssignProperties_To_DiskEncryptionSettings(&encryptionSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DiskEncryptionSettings() to populate field EncryptionSettings")
		}
		destination.EncryptionSettings = &encryptionSetting
	} else {
		destination.EncryptionSettings = nil
	}

	// Image
	if disk.Image != nil {
		var image v20220301s.VirtualHardDisk
		err := disk.Image.AssignProperties_To_VirtualHardDisk(&image)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualHardDisk() to populate field Image")
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk v20220301s.ManagedDiskParameters
		err := disk.ManagedDisk.AssignProperties_To_ManagedDiskParameters(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedDiskParameters() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// OsType
	destination.OsType = genruntime.ClonePointerToString(disk.OsType)

	// Vhd
	if disk.Vhd != nil {
		var vhd v20220301s.VirtualHardDisk
		err := disk.Vhd.AssignProperties_To_VirtualHardDisk(&vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualHardDisk() to populate field Vhd")
		}
		destination.Vhd = &vhd
	} else {
		destination.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForOSDisk interface (if implemented) to customize the conversion
	var diskAsAny any = disk
	if augmentedDisk, ok := diskAsAny.(augmentConversionForOSDisk); ok {
		err := augmentedDisk.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.OSDisk_STATUS
// Specifies information about the operating system disk used by the virtual machine.
// For more information about
// disks, see [About disks and VHDs for Azure virtual
// machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-about-disks-vhds?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json).
type OSDisk_STATUS struct {
	Caching                 *string                        `json:"caching,omitempty"`
	CreateOption            *string                        `json:"createOption,omitempty"`
	DiffDiskSettings        *DiffDiskSettings_STATUS       `json:"diffDiskSettings,omitempty"`
	DiskSizeGB              *int                           `json:"diskSizeGB,omitempty"`
	EncryptionSettings      *DiskEncryptionSettings_STATUS `json:"encryptionSettings,omitempty"`
	Image                   *VirtualHardDisk_STATUS        `json:"image,omitempty"`
	ManagedDisk             *ManagedDiskParameters_STATUS  `json:"managedDisk,omitempty"`
	Name                    *string                        `json:"name,omitempty"`
	OsType                  *string                        `json:"osType,omitempty"`
	PropertyBag             genruntime.PropertyBag         `json:"$propertyBag,omitempty"`
	Vhd                     *VirtualHardDisk_STATUS        `json:"vhd,omitempty"`
	WriteAcceleratorEnabled *bool                          `json:"writeAcceleratorEnabled,omitempty"`
}

// AssignProperties_From_OSDisk_STATUS populates our OSDisk_STATUS from the provided source OSDisk_STATUS
func (disk *OSDisk_STATUS) AssignProperties_From_OSDisk_STATUS(source *v20220301s.OSDisk_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Caching
	disk.Caching = genruntime.ClonePointerToString(source.Caching)

	// CreateOption
	disk.CreateOption = genruntime.ClonePointerToString(source.CreateOption)

	// DeleteOption
	if source.DeleteOption != nil {
		propertyBag.Add("DeleteOption", *source.DeleteOption)
	} else {
		propertyBag.Remove("DeleteOption")
	}

	// DiffDiskSettings
	if source.DiffDiskSettings != nil {
		var diffDiskSetting DiffDiskSettings_STATUS
		err := diffDiskSetting.AssignProperties_From_DiffDiskSettings_STATUS(source.DiffDiskSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DiffDiskSettings_STATUS() to populate field DiffDiskSettings")
		}
		disk.DiffDiskSettings = &diffDiskSetting
	} else {
		disk.DiffDiskSettings = nil
	}

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// EncryptionSettings
	if source.EncryptionSettings != nil {
		var encryptionSetting DiskEncryptionSettings_STATUS
		err := encryptionSetting.AssignProperties_From_DiskEncryptionSettings_STATUS(source.EncryptionSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DiskEncryptionSettings_STATUS() to populate field EncryptionSettings")
		}
		disk.EncryptionSettings = &encryptionSetting
	} else {
		disk.EncryptionSettings = nil
	}

	// Image
	if source.Image != nil {
		var image VirtualHardDisk_STATUS
		err := image.AssignProperties_From_VirtualHardDisk_STATUS(source.Image)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualHardDisk_STATUS() to populate field Image")
		}
		disk.Image = &image
	} else {
		disk.Image = nil
	}

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk ManagedDiskParameters_STATUS
		err := managedDisk.AssignProperties_From_ManagedDiskParameters_STATUS(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedDiskParameters_STATUS() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// OsType
	disk.OsType = genruntime.ClonePointerToString(source.OsType)

	// Vhd
	if source.Vhd != nil {
		var vhd VirtualHardDisk_STATUS
		err := vhd.AssignProperties_From_VirtualHardDisk_STATUS(source.Vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualHardDisk_STATUS() to populate field Vhd")
		}
		disk.Vhd = &vhd
	} else {
		disk.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		disk.PropertyBag = propertyBag
	} else {
		disk.PropertyBag = nil
	}

	// Invoke the augmentConversionForOSDisk_STATUS interface (if implemented) to customize the conversion
	var diskAsAny any = disk
	if augmentedDisk, ok := diskAsAny.(augmentConversionForOSDisk_STATUS); ok {
		err := augmentedDisk.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_OSDisk_STATUS populates the provided destination OSDisk_STATUS from our OSDisk_STATUS
func (disk *OSDisk_STATUS) AssignProperties_To_OSDisk_STATUS(destination *v20220301s.OSDisk_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(disk.PropertyBag)

	// Caching
	destination.Caching = genruntime.ClonePointerToString(disk.Caching)

	// CreateOption
	destination.CreateOption = genruntime.ClonePointerToString(disk.CreateOption)

	// DeleteOption
	if propertyBag.Contains("DeleteOption") {
		var deleteOption string
		err := propertyBag.Pull("DeleteOption", &deleteOption)
		if err != nil {
			return errors.Wrap(err, "pulling 'DeleteOption' from propertyBag")
		}

		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// DiffDiskSettings
	if disk.DiffDiskSettings != nil {
		var diffDiskSetting v20220301s.DiffDiskSettings_STATUS
		err := disk.DiffDiskSettings.AssignProperties_To_DiffDiskSettings_STATUS(&diffDiskSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DiffDiskSettings_STATUS() to populate field DiffDiskSettings")
		}
		destination.DiffDiskSettings = &diffDiskSetting
	} else {
		destination.DiffDiskSettings = nil
	}

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// EncryptionSettings
	if disk.EncryptionSettings != nil {
		var encryptionSetting v20220301s.DiskEncryptionSettings_STATUS
		err := disk.EncryptionSettings.AssignProperties_To_DiskEncryptionSettings_STATUS(&encryptionSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DiskEncryptionSettings_STATUS() to populate field EncryptionSettings")
		}
		destination.EncryptionSettings = &encryptionSetting
	} else {
		destination.EncryptionSettings = nil
	}

	// Image
	if disk.Image != nil {
		var image v20220301s.VirtualHardDisk_STATUS
		err := disk.Image.AssignProperties_To_VirtualHardDisk_STATUS(&image)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualHardDisk_STATUS() to populate field Image")
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk v20220301s.ManagedDiskParameters_STATUS
		err := disk.ManagedDisk.AssignProperties_To_ManagedDiskParameters_STATUS(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedDiskParameters_STATUS() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// OsType
	destination.OsType = genruntime.ClonePointerToString(disk.OsType)

	// Vhd
	if disk.Vhd != nil {
		var vhd v20220301s.VirtualHardDisk_STATUS
		err := disk.Vhd.AssignProperties_To_VirtualHardDisk_STATUS(&vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualHardDisk_STATUS() to populate field Vhd")
		}
		destination.Vhd = &vhd
	} else {
		destination.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForOSDisk_STATUS interface (if implemented) to customize the conversion
	var diskAsAny any = disk
	if augmentedDisk, ok := diskAsAny.(augmentConversionForOSDisk_STATUS); ok {
		err := augmentedDisk.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.UefiSettings
// Specifies the security settings like secure boot and vTPM used while creating the virtual machine.
// Minimum
// api-version: 2020-12-01
type UefiSettings struct {
	PropertyBag       genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SecureBootEnabled *bool                  `json:"secureBootEnabled,omitempty"`
	VTpmEnabled       *bool                  `json:"vTpmEnabled,omitempty"`
}

// AssignProperties_From_UefiSettings populates our UefiSettings from the provided source UefiSettings
func (settings *UefiSettings) AssignProperties_From_UefiSettings(source *v20220301s.UefiSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// SecureBootEnabled
	if source.SecureBootEnabled != nil {
		secureBootEnabled := *source.SecureBootEnabled
		settings.SecureBootEnabled = &secureBootEnabled
	} else {
		settings.SecureBootEnabled = nil
	}

	// VTpmEnabled
	if source.VTpmEnabled != nil {
		vTpmEnabled := *source.VTpmEnabled
		settings.VTpmEnabled = &vTpmEnabled
	} else {
		settings.VTpmEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForUefiSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForUefiSettings); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UefiSettings populates the provided destination UefiSettings from our UefiSettings
func (settings *UefiSettings) AssignProperties_To_UefiSettings(destination *v20220301s.UefiSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// SecureBootEnabled
	if settings.SecureBootEnabled != nil {
		secureBootEnabled := *settings.SecureBootEnabled
		destination.SecureBootEnabled = &secureBootEnabled
	} else {
		destination.SecureBootEnabled = nil
	}

	// VTpmEnabled
	if settings.VTpmEnabled != nil {
		vTpmEnabled := *settings.VTpmEnabled
		destination.VTpmEnabled = &vTpmEnabled
	} else {
		destination.VTpmEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUefiSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForUefiSettings); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.UefiSettings_STATUS
// Specifies the security settings like secure boot and vTPM used while creating the virtual machine.
// Minimum
// api-version: 2020-12-01
type UefiSettings_STATUS struct {
	PropertyBag       genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SecureBootEnabled *bool                  `json:"secureBootEnabled,omitempty"`
	VTpmEnabled       *bool                  `json:"vTpmEnabled,omitempty"`
}

// AssignProperties_From_UefiSettings_STATUS populates our UefiSettings_STATUS from the provided source UefiSettings_STATUS
func (settings *UefiSettings_STATUS) AssignProperties_From_UefiSettings_STATUS(source *v20220301s.UefiSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// SecureBootEnabled
	if source.SecureBootEnabled != nil {
		secureBootEnabled := *source.SecureBootEnabled
		settings.SecureBootEnabled = &secureBootEnabled
	} else {
		settings.SecureBootEnabled = nil
	}

	// VTpmEnabled
	if source.VTpmEnabled != nil {
		vTpmEnabled := *source.VTpmEnabled
		settings.VTpmEnabled = &vTpmEnabled
	} else {
		settings.VTpmEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForUefiSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForUefiSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UefiSettings_STATUS populates the provided destination UefiSettings_STATUS from our UefiSettings_STATUS
func (settings *UefiSettings_STATUS) AssignProperties_To_UefiSettings_STATUS(destination *v20220301s.UefiSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// SecureBootEnabled
	if settings.SecureBootEnabled != nil {
		secureBootEnabled := *settings.SecureBootEnabled
		destination.SecureBootEnabled = &secureBootEnabled
	} else {
		destination.SecureBootEnabled = nil
	}

	// VTpmEnabled
	if settings.VTpmEnabled != nil {
		vTpmEnabled := *settings.VTpmEnabled
		destination.VTpmEnabled = &vTpmEnabled
	} else {
		destination.VTpmEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUefiSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForUefiSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.UserAssignedIdentityDetails
// Information about the user assigned identity for the resource
type UserAssignedIdentityDetails struct {
	PropertyBag genruntime.PropertyBag       `json:"$propertyBag,omitempty"`
	Reference   genruntime.ResourceReference `armReference:"Reference" json:"reference,omitempty"`
}

// AssignProperties_From_UserAssignedIdentityDetails populates our UserAssignedIdentityDetails from the provided source UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_From_UserAssignedIdentityDetails(source *v20220301s.UserAssignedIdentityDetails) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Reference
	details.Reference = source.Reference.Copy()

	// Update the property bag
	if len(propertyBag) > 0 {
		details.PropertyBag = propertyBag
	} else {
		details.PropertyBag = nil
	}

	// Invoke the augmentConversionForUserAssignedIdentityDetails interface (if implemented) to customize the conversion
	var detailsAsAny any = details
	if augmentedDetails, ok := detailsAsAny.(augmentConversionForUserAssignedIdentityDetails); ok {
		err := augmentedDetails.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentityDetails populates the provided destination UserAssignedIdentityDetails from our UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_To_UserAssignedIdentityDetails(destination *v20220301s.UserAssignedIdentityDetails) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(details.PropertyBag)

	// Reference
	destination.Reference = details.Reference.Copy()

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUserAssignedIdentityDetails interface (if implemented) to customize the conversion
	var detailsAsAny any = details
	if augmentedDetails, ok := detailsAsAny.(augmentConversionForUserAssignedIdentityDetails); ok {
		err := augmentedDetails.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VaultSecretGroup
// Describes a set of certificates which are all in the same Key Vault.
type VaultSecretGroup struct {
	PropertyBag       genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SourceVault       *SubResource           `json:"sourceVault,omitempty"`
	VaultCertificates []VaultCertificate     `json:"vaultCertificates,omitempty"`
}

// AssignProperties_From_VaultSecretGroup populates our VaultSecretGroup from the provided source VaultSecretGroup
func (group *VaultSecretGroup) AssignProperties_From_VaultSecretGroup(source *v20220301s.VaultSecretGroup) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// SourceVault
	if source.SourceVault != nil {
		var subResourceStash v20210701s.SubResource
		err := subResourceStash.AssignProperties_From_SubResource(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from SourceVault")
		}
		var sourceVault SubResource
		err = sourceVault.AssignProperties_From_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SourceVault from SubResourceStash")
		}
		group.SourceVault = &sourceVault
	} else {
		group.SourceVault = nil
	}

	// VaultCertificates
	if source.VaultCertificates != nil {
		vaultCertificateList := make([]VaultCertificate, len(source.VaultCertificates))
		for vaultCertificateIndex, vaultCertificateItem := range source.VaultCertificates {
			// Shadow the loop variable to avoid aliasing
			vaultCertificateItem := vaultCertificateItem
			var vaultCertificate VaultCertificate
			err := vaultCertificate.AssignProperties_From_VaultCertificate(&vaultCertificateItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VaultCertificate() to populate field VaultCertificates")
			}
			vaultCertificateList[vaultCertificateIndex] = vaultCertificate
		}
		group.VaultCertificates = vaultCertificateList
	} else {
		group.VaultCertificates = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		group.PropertyBag = propertyBag
	} else {
		group.PropertyBag = nil
	}

	// Invoke the augmentConversionForVaultSecretGroup interface (if implemented) to customize the conversion
	var groupAsAny any = group
	if augmentedGroup, ok := groupAsAny.(augmentConversionForVaultSecretGroup); ok {
		err := augmentedGroup.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VaultSecretGroup populates the provided destination VaultSecretGroup from our VaultSecretGroup
func (group *VaultSecretGroup) AssignProperties_To_VaultSecretGroup(destination *v20220301s.VaultSecretGroup) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(group.PropertyBag)

	// SourceVault
	if group.SourceVault != nil {
		var subResourceStash v20210701s.SubResource
		err := group.SourceVault.AssignProperties_To_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from SourceVault")
		}
		var sourceVault v20220301s.SubResource
		err = subResourceStash.AssignProperties_To_SubResource(&sourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SourceVault from SubResourceStash")
		}
		destination.SourceVault = &sourceVault
	} else {
		destination.SourceVault = nil
	}

	// VaultCertificates
	if group.VaultCertificates != nil {
		vaultCertificateList := make([]v20220301s.VaultCertificate, len(group.VaultCertificates))
		for vaultCertificateIndex, vaultCertificateItem := range group.VaultCertificates {
			// Shadow the loop variable to avoid aliasing
			vaultCertificateItem := vaultCertificateItem
			var vaultCertificate v20220301s.VaultCertificate
			err := vaultCertificateItem.AssignProperties_To_VaultCertificate(&vaultCertificate)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VaultCertificate() to populate field VaultCertificates")
			}
			vaultCertificateList[vaultCertificateIndex] = vaultCertificate
		}
		destination.VaultCertificates = vaultCertificateList
	} else {
		destination.VaultCertificates = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVaultSecretGroup interface (if implemented) to customize the conversion
	var groupAsAny any = group
	if augmentedGroup, ok := groupAsAny.(augmentConversionForVaultSecretGroup); ok {
		err := augmentedGroup.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VaultSecretGroup_STATUS
// Describes a set of certificates which are all in the same Key Vault.
type VaultSecretGroup_STATUS struct {
	PropertyBag       genruntime.PropertyBag    `json:"$propertyBag,omitempty"`
	SourceVault       *SubResource_STATUS       `json:"sourceVault,omitempty"`
	VaultCertificates []VaultCertificate_STATUS `json:"vaultCertificates,omitempty"`
}

// AssignProperties_From_VaultSecretGroup_STATUS populates our VaultSecretGroup_STATUS from the provided source VaultSecretGroup_STATUS
func (group *VaultSecretGroup_STATUS) AssignProperties_From_VaultSecretGroup_STATUS(source *v20220301s.VaultSecretGroup_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// SourceVault
	if source.SourceVault != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from SourceVault")
		}
		var sourceVault SubResource_STATUS
		err = sourceVault.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SourceVault from SubResource_STATUSStash")
		}
		group.SourceVault = &sourceVault
	} else {
		group.SourceVault = nil
	}

	// VaultCertificates
	if source.VaultCertificates != nil {
		vaultCertificateList := make([]VaultCertificate_STATUS, len(source.VaultCertificates))
		for vaultCertificateIndex, vaultCertificateItem := range source.VaultCertificates {
			// Shadow the loop variable to avoid aliasing
			vaultCertificateItem := vaultCertificateItem
			var vaultCertificate VaultCertificate_STATUS
			err := vaultCertificate.AssignProperties_From_VaultCertificate_STATUS(&vaultCertificateItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VaultCertificate_STATUS() to populate field VaultCertificates")
			}
			vaultCertificateList[vaultCertificateIndex] = vaultCertificate
		}
		group.VaultCertificates = vaultCertificateList
	} else {
		group.VaultCertificates = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		group.PropertyBag = propertyBag
	} else {
		group.PropertyBag = nil
	}

	// Invoke the augmentConversionForVaultSecretGroup_STATUS interface (if implemented) to customize the conversion
	var groupAsAny any = group
	if augmentedGroup, ok := groupAsAny.(augmentConversionForVaultSecretGroup_STATUS); ok {
		err := augmentedGroup.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VaultSecretGroup_STATUS populates the provided destination VaultSecretGroup_STATUS from our VaultSecretGroup_STATUS
func (group *VaultSecretGroup_STATUS) AssignProperties_To_VaultSecretGroup_STATUS(destination *v20220301s.VaultSecretGroup_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(group.PropertyBag)

	// SourceVault
	if group.SourceVault != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := group.SourceVault.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from SourceVault")
		}
		var sourceVault v20220301s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&sourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SourceVault from SubResource_STATUSStash")
		}
		destination.SourceVault = &sourceVault
	} else {
		destination.SourceVault = nil
	}

	// VaultCertificates
	if group.VaultCertificates != nil {
		vaultCertificateList := make([]v20220301s.VaultCertificate_STATUS, len(group.VaultCertificates))
		for vaultCertificateIndex, vaultCertificateItem := range group.VaultCertificates {
			// Shadow the loop variable to avoid aliasing
			vaultCertificateItem := vaultCertificateItem
			var vaultCertificate v20220301s.VaultCertificate_STATUS
			err := vaultCertificateItem.AssignProperties_To_VaultCertificate_STATUS(&vaultCertificate)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VaultCertificate_STATUS() to populate field VaultCertificates")
			}
			vaultCertificateList[vaultCertificateIndex] = vaultCertificate
		}
		destination.VaultCertificates = vaultCertificateList
	} else {
		destination.VaultCertificates = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVaultSecretGroup_STATUS interface (if implemented) to customize the conversion
	var groupAsAny any = group
	if augmentedGroup, ok := groupAsAny.(augmentConversionForVaultSecretGroup_STATUS); ok {
		err := augmentedGroup.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineAgentInstanceView_STATUS
// The instance view of the VM Agent running on the virtual machine.
type VirtualMachineAgentInstanceView_STATUS struct {
	ExtensionHandlers []VirtualMachineExtensionHandlerInstanceView_STATUS `json:"extensionHandlers,omitempty"`
	PropertyBag       genruntime.PropertyBag                              `json:"$propertyBag,omitempty"`
	Statuses          []InstanceViewStatus_STATUS                         `json:"statuses,omitempty"`
	VmAgentVersion    *string                                             `json:"vmAgentVersion,omitempty"`
}

// AssignProperties_From_VirtualMachineAgentInstanceView_STATUS populates our VirtualMachineAgentInstanceView_STATUS from the provided source VirtualMachineAgentInstanceView_STATUS
func (view *VirtualMachineAgentInstanceView_STATUS) AssignProperties_From_VirtualMachineAgentInstanceView_STATUS(source *v20220301s.VirtualMachineAgentInstanceView_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ExtensionHandlers
	if source.ExtensionHandlers != nil {
		extensionHandlerList := make([]VirtualMachineExtensionHandlerInstanceView_STATUS, len(source.ExtensionHandlers))
		for extensionHandlerIndex, extensionHandlerItem := range source.ExtensionHandlers {
			// Shadow the loop variable to avoid aliasing
			extensionHandlerItem := extensionHandlerItem
			var extensionHandler VirtualMachineExtensionHandlerInstanceView_STATUS
			err := extensionHandler.AssignProperties_From_VirtualMachineExtensionHandlerInstanceView_STATUS(&extensionHandlerItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineExtensionHandlerInstanceView_STATUS() to populate field ExtensionHandlers")
			}
			extensionHandlerList[extensionHandlerIndex] = extensionHandler
		}
		view.ExtensionHandlers = extensionHandlerList
	} else {
		view.ExtensionHandlers = nil
	}

	// Statuses
	if source.Statuses != nil {
		statusList := make([]InstanceViewStatus_STATUS, len(source.Statuses))
		for statusIndex, statusItem := range source.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status InstanceViewStatus_STATUS
			err := status.AssignProperties_From_InstanceViewStatus_STATUS(&statusItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_InstanceViewStatus_STATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		view.Statuses = statusList
	} else {
		view.Statuses = nil
	}

	// VmAgentVersion
	view.VmAgentVersion = genruntime.ClonePointerToString(source.VmAgentVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		view.PropertyBag = propertyBag
	} else {
		view.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineAgentInstanceView_STATUS interface (if implemented) to customize the conversion
	var viewAsAny any = view
	if augmentedView, ok := viewAsAny.(augmentConversionForVirtualMachineAgentInstanceView_STATUS); ok {
		err := augmentedView.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineAgentInstanceView_STATUS populates the provided destination VirtualMachineAgentInstanceView_STATUS from our VirtualMachineAgentInstanceView_STATUS
func (view *VirtualMachineAgentInstanceView_STATUS) AssignProperties_To_VirtualMachineAgentInstanceView_STATUS(destination *v20220301s.VirtualMachineAgentInstanceView_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(view.PropertyBag)

	// ExtensionHandlers
	if view.ExtensionHandlers != nil {
		extensionHandlerList := make([]v20220301s.VirtualMachineExtensionHandlerInstanceView_STATUS, len(view.ExtensionHandlers))
		for extensionHandlerIndex, extensionHandlerItem := range view.ExtensionHandlers {
			// Shadow the loop variable to avoid aliasing
			extensionHandlerItem := extensionHandlerItem
			var extensionHandler v20220301s.VirtualMachineExtensionHandlerInstanceView_STATUS
			err := extensionHandlerItem.AssignProperties_To_VirtualMachineExtensionHandlerInstanceView_STATUS(&extensionHandler)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineExtensionHandlerInstanceView_STATUS() to populate field ExtensionHandlers")
			}
			extensionHandlerList[extensionHandlerIndex] = extensionHandler
		}
		destination.ExtensionHandlers = extensionHandlerList
	} else {
		destination.ExtensionHandlers = nil
	}

	// Statuses
	if view.Statuses != nil {
		statusList := make([]v20220301s.InstanceViewStatus_STATUS, len(view.Statuses))
		for statusIndex, statusItem := range view.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status v20220301s.InstanceViewStatus_STATUS
			err := statusItem.AssignProperties_To_InstanceViewStatus_STATUS(&status)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_InstanceViewStatus_STATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		destination.Statuses = statusList
	} else {
		destination.Statuses = nil
	}

	// VmAgentVersion
	destination.VmAgentVersion = genruntime.ClonePointerToString(view.VmAgentVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineAgentInstanceView_STATUS interface (if implemented) to customize the conversion
	var viewAsAny any = view
	if augmentedView, ok := viewAsAny.(augmentConversionForVirtualMachineAgentInstanceView_STATUS); ok {
		err := augmentedView.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineHealthStatus_STATUS
// The health status of the VM.
type VirtualMachineHealthStatus_STATUS struct {
	PropertyBag genruntime.PropertyBag     `json:"$propertyBag,omitempty"`
	Status      *InstanceViewStatus_STATUS `json:"status,omitempty"`
}

// AssignProperties_From_VirtualMachineHealthStatus_STATUS populates our VirtualMachineHealthStatus_STATUS from the provided source VirtualMachineHealthStatus_STATUS
func (status *VirtualMachineHealthStatus_STATUS) AssignProperties_From_VirtualMachineHealthStatus_STATUS(source *v20220301s.VirtualMachineHealthStatus_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Status
	if source.Status != nil {
		var statusLocal InstanceViewStatus_STATUS
		err := statusLocal.AssignProperties_From_InstanceViewStatus_STATUS(source.Status)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_InstanceViewStatus_STATUS() to populate field Status")
		}
		status.Status = &statusLocal
	} else {
		status.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		status.PropertyBag = propertyBag
	} else {
		status.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineHealthStatus_STATUS interface (if implemented) to customize the conversion
	var statusAsAny any = status
	if augmentedStatus, ok := statusAsAny.(augmentConversionForVirtualMachineHealthStatus_STATUS); ok {
		err := augmentedStatus.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineHealthStatus_STATUS populates the provided destination VirtualMachineHealthStatus_STATUS from our VirtualMachineHealthStatus_STATUS
func (status *VirtualMachineHealthStatus_STATUS) AssignProperties_To_VirtualMachineHealthStatus_STATUS(destination *v20220301s.VirtualMachineHealthStatus_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(status.PropertyBag)

	// Status
	if status.Status != nil {
		var statusLocal v20220301s.InstanceViewStatus_STATUS
		err := status.Status.AssignProperties_To_InstanceViewStatus_STATUS(&statusLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_InstanceViewStatus_STATUS() to populate field Status")
		}
		destination.Status = &statusLocal
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineHealthStatus_STATUS interface (if implemented) to customize the conversion
	var statusAsAny any = status
	if augmentedStatus, ok := statusAsAny.(augmentConversionForVirtualMachineHealthStatus_STATUS); ok {
		err := augmentedStatus.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineIdentity_UserAssignedIdentities_STATUS
type VirtualMachineIdentity_UserAssignedIdentities_STATUS struct {
	ClientId    *string                `json:"clientId,omitempty"`
	PrincipalId *string                `json:"principalId,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_VirtualMachineIdentity_UserAssignedIdentities_STATUS populates our VirtualMachineIdentity_UserAssignedIdentities_STATUS from the provided source VirtualMachineIdentity_UserAssignedIdentities_STATUS
func (identities *VirtualMachineIdentity_UserAssignedIdentities_STATUS) AssignProperties_From_VirtualMachineIdentity_UserAssignedIdentities_STATUS(source *v20220301s.VirtualMachineIdentity_UserAssignedIdentities_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ClientId
	identities.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// PrincipalId
	identities.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		identities.PropertyBag = propertyBag
	} else {
		identities.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineIdentity_UserAssignedIdentities_STATUS interface (if implemented) to customize the conversion
	var identitiesAsAny any = identities
	if augmentedIdentities, ok := identitiesAsAny.(augmentConversionForVirtualMachineIdentity_UserAssignedIdentities_STATUS); ok {
		err := augmentedIdentities.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineIdentity_UserAssignedIdentities_STATUS populates the provided destination VirtualMachineIdentity_UserAssignedIdentities_STATUS from our VirtualMachineIdentity_UserAssignedIdentities_STATUS
func (identities *VirtualMachineIdentity_UserAssignedIdentities_STATUS) AssignProperties_To_VirtualMachineIdentity_UserAssignedIdentities_STATUS(destination *v20220301s.VirtualMachineIdentity_UserAssignedIdentities_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(identities.PropertyBag)

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identities.ClientId)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identities.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineIdentity_UserAssignedIdentities_STATUS interface (if implemented) to customize the conversion
	var identitiesAsAny any = identities
	if augmentedIdentities, ok := identitiesAsAny.(augmentConversionForVirtualMachineIdentity_UserAssignedIdentities_STATUS); ok {
		err := augmentedIdentities.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachinePatchStatus_STATUS
// The status of virtual machine patch operations.
type VirtualMachinePatchStatus_STATUS struct {
	AvailablePatchSummary        *AvailablePatchSummary_STATUS        `json:"availablePatchSummary,omitempty"`
	ConfigurationStatuses        []InstanceViewStatus_STATUS          `json:"configurationStatuses,omitempty"`
	LastPatchInstallationSummary *LastPatchInstallationSummary_STATUS `json:"lastPatchInstallationSummary,omitempty"`
	PropertyBag                  genruntime.PropertyBag               `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_VirtualMachinePatchStatus_STATUS populates our VirtualMachinePatchStatus_STATUS from the provided source VirtualMachinePatchStatus_STATUS
func (status *VirtualMachinePatchStatus_STATUS) AssignProperties_From_VirtualMachinePatchStatus_STATUS(source *v20220301s.VirtualMachinePatchStatus_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AvailablePatchSummary
	if source.AvailablePatchSummary != nil {
		var availablePatchSummary AvailablePatchSummary_STATUS
		err := availablePatchSummary.AssignProperties_From_AvailablePatchSummary_STATUS(source.AvailablePatchSummary)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AvailablePatchSummary_STATUS() to populate field AvailablePatchSummary")
		}
		status.AvailablePatchSummary = &availablePatchSummary
	} else {
		status.AvailablePatchSummary = nil
	}

	// ConfigurationStatuses
	if source.ConfigurationStatuses != nil {
		configurationStatusList := make([]InstanceViewStatus_STATUS, len(source.ConfigurationStatuses))
		for configurationStatusIndex, configurationStatusItem := range source.ConfigurationStatuses {
			// Shadow the loop variable to avoid aliasing
			configurationStatusItem := configurationStatusItem
			var configurationStatus InstanceViewStatus_STATUS
			err := configurationStatus.AssignProperties_From_InstanceViewStatus_STATUS(&configurationStatusItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_InstanceViewStatus_STATUS() to populate field ConfigurationStatuses")
			}
			configurationStatusList[configurationStatusIndex] = configurationStatus
		}
		status.ConfigurationStatuses = configurationStatusList
	} else {
		status.ConfigurationStatuses = nil
	}

	// LastPatchInstallationSummary
	if source.LastPatchInstallationSummary != nil {
		var lastPatchInstallationSummary LastPatchInstallationSummary_STATUS
		err := lastPatchInstallationSummary.AssignProperties_From_LastPatchInstallationSummary_STATUS(source.LastPatchInstallationSummary)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_LastPatchInstallationSummary_STATUS() to populate field LastPatchInstallationSummary")
		}
		status.LastPatchInstallationSummary = &lastPatchInstallationSummary
	} else {
		status.LastPatchInstallationSummary = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		status.PropertyBag = propertyBag
	} else {
		status.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachinePatchStatus_STATUS interface (if implemented) to customize the conversion
	var statusAsAny any = status
	if augmentedStatus, ok := statusAsAny.(augmentConversionForVirtualMachinePatchStatus_STATUS); ok {
		err := augmentedStatus.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachinePatchStatus_STATUS populates the provided destination VirtualMachinePatchStatus_STATUS from our VirtualMachinePatchStatus_STATUS
func (status *VirtualMachinePatchStatus_STATUS) AssignProperties_To_VirtualMachinePatchStatus_STATUS(destination *v20220301s.VirtualMachinePatchStatus_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(status.PropertyBag)

	// AvailablePatchSummary
	if status.AvailablePatchSummary != nil {
		var availablePatchSummary v20220301s.AvailablePatchSummary_STATUS
		err := status.AvailablePatchSummary.AssignProperties_To_AvailablePatchSummary_STATUS(&availablePatchSummary)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AvailablePatchSummary_STATUS() to populate field AvailablePatchSummary")
		}
		destination.AvailablePatchSummary = &availablePatchSummary
	} else {
		destination.AvailablePatchSummary = nil
	}

	// ConfigurationStatuses
	if status.ConfigurationStatuses != nil {
		configurationStatusList := make([]v20220301s.InstanceViewStatus_STATUS, len(status.ConfigurationStatuses))
		for configurationStatusIndex, configurationStatusItem := range status.ConfigurationStatuses {
			// Shadow the loop variable to avoid aliasing
			configurationStatusItem := configurationStatusItem
			var configurationStatus v20220301s.InstanceViewStatus_STATUS
			err := configurationStatusItem.AssignProperties_To_InstanceViewStatus_STATUS(&configurationStatus)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_InstanceViewStatus_STATUS() to populate field ConfigurationStatuses")
			}
			configurationStatusList[configurationStatusIndex] = configurationStatus
		}
		destination.ConfigurationStatuses = configurationStatusList
	} else {
		destination.ConfigurationStatuses = nil
	}

	// LastPatchInstallationSummary
	if status.LastPatchInstallationSummary != nil {
		var lastPatchInstallationSummary v20220301s.LastPatchInstallationSummary_STATUS
		err := status.LastPatchInstallationSummary.AssignProperties_To_LastPatchInstallationSummary_STATUS(&lastPatchInstallationSummary)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_LastPatchInstallationSummary_STATUS() to populate field LastPatchInstallationSummary")
		}
		destination.LastPatchInstallationSummary = &lastPatchInstallationSummary
	} else {
		destination.LastPatchInstallationSummary = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachinePatchStatus_STATUS interface (if implemented) to customize the conversion
	var statusAsAny any = status
	if augmentedStatus, ok := statusAsAny.(augmentConversionForVirtualMachinePatchStatus_STATUS); ok {
		err := augmentedStatus.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.WindowsConfiguration
// Specifies Windows operating system settings on the virtual machine.
type WindowsConfiguration struct {
	AdditionalUnattendContent []AdditionalUnattendContent `json:"additionalUnattendContent,omitempty"`
	EnableAutomaticUpdates    *bool                       `json:"enableAutomaticUpdates,omitempty"`
	PatchSettings             *PatchSettings              `json:"patchSettings,omitempty"`
	PropertyBag               genruntime.PropertyBag      `json:"$propertyBag,omitempty"`
	ProvisionVMAgent          *bool                       `json:"provisionVMAgent,omitempty"`
	TimeZone                  *string                     `json:"timeZone,omitempty"`
	WinRM                     *WinRMConfiguration         `json:"winRM,omitempty"`
}

// AssignProperties_From_WindowsConfiguration populates our WindowsConfiguration from the provided source WindowsConfiguration
func (configuration *WindowsConfiguration) AssignProperties_From_WindowsConfiguration(source *v20220301s.WindowsConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdditionalUnattendContent
	if source.AdditionalUnattendContent != nil {
		additionalUnattendContentList := make([]AdditionalUnattendContent, len(source.AdditionalUnattendContent))
		for additionalUnattendContentIndex, additionalUnattendContentItem := range source.AdditionalUnattendContent {
			// Shadow the loop variable to avoid aliasing
			additionalUnattendContentItem := additionalUnattendContentItem
			var additionalUnattendContent AdditionalUnattendContent
			err := additionalUnattendContent.AssignProperties_From_AdditionalUnattendContent(&additionalUnattendContentItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_AdditionalUnattendContent() to populate field AdditionalUnattendContent")
			}
			additionalUnattendContentList[additionalUnattendContentIndex] = additionalUnattendContent
		}
		configuration.AdditionalUnattendContent = additionalUnattendContentList
	} else {
		configuration.AdditionalUnattendContent = nil
	}

	// EnableAutomaticUpdates
	if source.EnableAutomaticUpdates != nil {
		enableAutomaticUpdate := *source.EnableAutomaticUpdates
		configuration.EnableAutomaticUpdates = &enableAutomaticUpdate
	} else {
		configuration.EnableAutomaticUpdates = nil
	}

	// PatchSettings
	if source.PatchSettings != nil {
		var patchSetting PatchSettings
		err := patchSetting.AssignProperties_From_PatchSettings(source.PatchSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PatchSettings() to populate field PatchSettings")
		}
		configuration.PatchSettings = &patchSetting
	} else {
		configuration.PatchSettings = nil
	}

	// ProvisionVMAgent
	if source.ProvisionVMAgent != nil {
		provisionVMAgent := *source.ProvisionVMAgent
		configuration.ProvisionVMAgent = &provisionVMAgent
	} else {
		configuration.ProvisionVMAgent = nil
	}

	// TimeZone
	configuration.TimeZone = genruntime.ClonePointerToString(source.TimeZone)

	// WinRM
	if source.WinRM != nil {
		var winRM WinRMConfiguration
		err := winRM.AssignProperties_From_WinRMConfiguration(source.WinRM)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WinRMConfiguration() to populate field WinRM")
		}
		configuration.WinRM = &winRM
	} else {
		configuration.WinRM = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForWindowsConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForWindowsConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_WindowsConfiguration populates the provided destination WindowsConfiguration from our WindowsConfiguration
func (configuration *WindowsConfiguration) AssignProperties_To_WindowsConfiguration(destination *v20220301s.WindowsConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// AdditionalUnattendContent
	if configuration.AdditionalUnattendContent != nil {
		additionalUnattendContentList := make([]v20220301s.AdditionalUnattendContent, len(configuration.AdditionalUnattendContent))
		for additionalUnattendContentIndex, additionalUnattendContentItem := range configuration.AdditionalUnattendContent {
			// Shadow the loop variable to avoid aliasing
			additionalUnattendContentItem := additionalUnattendContentItem
			var additionalUnattendContent v20220301s.AdditionalUnattendContent
			err := additionalUnattendContentItem.AssignProperties_To_AdditionalUnattendContent(&additionalUnattendContent)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_AdditionalUnattendContent() to populate field AdditionalUnattendContent")
			}
			additionalUnattendContentList[additionalUnattendContentIndex] = additionalUnattendContent
		}
		destination.AdditionalUnattendContent = additionalUnattendContentList
	} else {
		destination.AdditionalUnattendContent = nil
	}

	// EnableAutomaticUpdates
	if configuration.EnableAutomaticUpdates != nil {
		enableAutomaticUpdate := *configuration.EnableAutomaticUpdates
		destination.EnableAutomaticUpdates = &enableAutomaticUpdate
	} else {
		destination.EnableAutomaticUpdates = nil
	}

	// PatchSettings
	if configuration.PatchSettings != nil {
		var patchSetting v20220301s.PatchSettings
		err := configuration.PatchSettings.AssignProperties_To_PatchSettings(&patchSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PatchSettings() to populate field PatchSettings")
		}
		destination.PatchSettings = &patchSetting
	} else {
		destination.PatchSettings = nil
	}

	// ProvisionVMAgent
	if configuration.ProvisionVMAgent != nil {
		provisionVMAgent := *configuration.ProvisionVMAgent
		destination.ProvisionVMAgent = &provisionVMAgent
	} else {
		destination.ProvisionVMAgent = nil
	}

	// TimeZone
	destination.TimeZone = genruntime.ClonePointerToString(configuration.TimeZone)

	// WinRM
	if configuration.WinRM != nil {
		var winRM v20220301s.WinRMConfiguration
		err := configuration.WinRM.AssignProperties_To_WinRMConfiguration(&winRM)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WinRMConfiguration() to populate field WinRM")
		}
		destination.WinRM = &winRM
	} else {
		destination.WinRM = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForWindowsConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForWindowsConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.WindowsConfiguration_STATUS
// Specifies Windows operating system settings on the virtual machine.
type WindowsConfiguration_STATUS struct {
	AdditionalUnattendContent []AdditionalUnattendContent_STATUS `json:"additionalUnattendContent,omitempty"`
	EnableAutomaticUpdates    *bool                              `json:"enableAutomaticUpdates,omitempty"`
	PatchSettings             *PatchSettings_STATUS              `json:"patchSettings,omitempty"`
	PropertyBag               genruntime.PropertyBag             `json:"$propertyBag,omitempty"`
	ProvisionVMAgent          *bool                              `json:"provisionVMAgent,omitempty"`
	TimeZone                  *string                            `json:"timeZone,omitempty"`
	WinRM                     *WinRMConfiguration_STATUS         `json:"winRM,omitempty"`
}

// AssignProperties_From_WindowsConfiguration_STATUS populates our WindowsConfiguration_STATUS from the provided source WindowsConfiguration_STATUS
func (configuration *WindowsConfiguration_STATUS) AssignProperties_From_WindowsConfiguration_STATUS(source *v20220301s.WindowsConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdditionalUnattendContent
	if source.AdditionalUnattendContent != nil {
		additionalUnattendContentList := make([]AdditionalUnattendContent_STATUS, len(source.AdditionalUnattendContent))
		for additionalUnattendContentIndex, additionalUnattendContentItem := range source.AdditionalUnattendContent {
			// Shadow the loop variable to avoid aliasing
			additionalUnattendContentItem := additionalUnattendContentItem
			var additionalUnattendContent AdditionalUnattendContent_STATUS
			err := additionalUnattendContent.AssignProperties_From_AdditionalUnattendContent_STATUS(&additionalUnattendContentItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_AdditionalUnattendContent_STATUS() to populate field AdditionalUnattendContent")
			}
			additionalUnattendContentList[additionalUnattendContentIndex] = additionalUnattendContent
		}
		configuration.AdditionalUnattendContent = additionalUnattendContentList
	} else {
		configuration.AdditionalUnattendContent = nil
	}

	// EnableAutomaticUpdates
	if source.EnableAutomaticUpdates != nil {
		enableAutomaticUpdate := *source.EnableAutomaticUpdates
		configuration.EnableAutomaticUpdates = &enableAutomaticUpdate
	} else {
		configuration.EnableAutomaticUpdates = nil
	}

	// PatchSettings
	if source.PatchSettings != nil {
		var patchSetting PatchSettings_STATUS
		err := patchSetting.AssignProperties_From_PatchSettings_STATUS(source.PatchSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PatchSettings_STATUS() to populate field PatchSettings")
		}
		configuration.PatchSettings = &patchSetting
	} else {
		configuration.PatchSettings = nil
	}

	// ProvisionVMAgent
	if source.ProvisionVMAgent != nil {
		provisionVMAgent := *source.ProvisionVMAgent
		configuration.ProvisionVMAgent = &provisionVMAgent
	} else {
		configuration.ProvisionVMAgent = nil
	}

	// TimeZone
	configuration.TimeZone = genruntime.ClonePointerToString(source.TimeZone)

	// WinRM
	if source.WinRM != nil {
		var winRM WinRMConfiguration_STATUS
		err := winRM.AssignProperties_From_WinRMConfiguration_STATUS(source.WinRM)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WinRMConfiguration_STATUS() to populate field WinRM")
		}
		configuration.WinRM = &winRM
	} else {
		configuration.WinRM = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForWindowsConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForWindowsConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_WindowsConfiguration_STATUS populates the provided destination WindowsConfiguration_STATUS from our WindowsConfiguration_STATUS
func (configuration *WindowsConfiguration_STATUS) AssignProperties_To_WindowsConfiguration_STATUS(destination *v20220301s.WindowsConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// AdditionalUnattendContent
	if configuration.AdditionalUnattendContent != nil {
		additionalUnattendContentList := make([]v20220301s.AdditionalUnattendContent_STATUS, len(configuration.AdditionalUnattendContent))
		for additionalUnattendContentIndex, additionalUnattendContentItem := range configuration.AdditionalUnattendContent {
			// Shadow the loop variable to avoid aliasing
			additionalUnattendContentItem := additionalUnattendContentItem
			var additionalUnattendContent v20220301s.AdditionalUnattendContent_STATUS
			err := additionalUnattendContentItem.AssignProperties_To_AdditionalUnattendContent_STATUS(&additionalUnattendContent)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_AdditionalUnattendContent_STATUS() to populate field AdditionalUnattendContent")
			}
			additionalUnattendContentList[additionalUnattendContentIndex] = additionalUnattendContent
		}
		destination.AdditionalUnattendContent = additionalUnattendContentList
	} else {
		destination.AdditionalUnattendContent = nil
	}

	// EnableAutomaticUpdates
	if configuration.EnableAutomaticUpdates != nil {
		enableAutomaticUpdate := *configuration.EnableAutomaticUpdates
		destination.EnableAutomaticUpdates = &enableAutomaticUpdate
	} else {
		destination.EnableAutomaticUpdates = nil
	}

	// PatchSettings
	if configuration.PatchSettings != nil {
		var patchSetting v20220301s.PatchSettings_STATUS
		err := configuration.PatchSettings.AssignProperties_To_PatchSettings_STATUS(&patchSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PatchSettings_STATUS() to populate field PatchSettings")
		}
		destination.PatchSettings = &patchSetting
	} else {
		destination.PatchSettings = nil
	}

	// ProvisionVMAgent
	if configuration.ProvisionVMAgent != nil {
		provisionVMAgent := *configuration.ProvisionVMAgent
		destination.ProvisionVMAgent = &provisionVMAgent
	} else {
		destination.ProvisionVMAgent = nil
	}

	// TimeZone
	destination.TimeZone = genruntime.ClonePointerToString(configuration.TimeZone)

	// WinRM
	if configuration.WinRM != nil {
		var winRM v20220301s.WinRMConfiguration_STATUS
		err := configuration.WinRM.AssignProperties_To_WinRMConfiguration_STATUS(&winRM)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WinRMConfiguration_STATUS() to populate field WinRM")
		}
		destination.WinRM = &winRM
	} else {
		destination.WinRM = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForWindowsConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForWindowsConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.AdditionalUnattendContent
// Specifies additional XML formatted information that can be included in the Unattend.xml file, which is used by Windows
// Setup. Contents are defined by setting name, component name, and the pass in which the content is applied.
type AdditionalUnattendContent struct {
	ComponentName *string                `json:"componentName,omitempty"`
	Content       *string                `json:"content,omitempty"`
	PassName      *string                `json:"passName,omitempty"`
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SettingName   *string                `json:"settingName,omitempty"`
}

// AssignProperties_From_AdditionalUnattendContent populates our AdditionalUnattendContent from the provided source AdditionalUnattendContent
func (content *AdditionalUnattendContent) AssignProperties_From_AdditionalUnattendContent(source *v20220301s.AdditionalUnattendContent) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ComponentName
	content.ComponentName = genruntime.ClonePointerToString(source.ComponentName)

	// Content
	content.Content = genruntime.ClonePointerToString(source.Content)

	// PassName
	content.PassName = genruntime.ClonePointerToString(source.PassName)

	// SettingName
	content.SettingName = genruntime.ClonePointerToString(source.SettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		content.PropertyBag = propertyBag
	} else {
		content.PropertyBag = nil
	}

	// Invoke the augmentConversionForAdditionalUnattendContent interface (if implemented) to customize the conversion
	var contentAsAny any = content
	if augmentedContent, ok := contentAsAny.(augmentConversionForAdditionalUnattendContent); ok {
		err := augmentedContent.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AdditionalUnattendContent populates the provided destination AdditionalUnattendContent from our AdditionalUnattendContent
func (content *AdditionalUnattendContent) AssignProperties_To_AdditionalUnattendContent(destination *v20220301s.AdditionalUnattendContent) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(content.PropertyBag)

	// ComponentName
	destination.ComponentName = genruntime.ClonePointerToString(content.ComponentName)

	// Content
	destination.Content = genruntime.ClonePointerToString(content.Content)

	// PassName
	destination.PassName = genruntime.ClonePointerToString(content.PassName)

	// SettingName
	destination.SettingName = genruntime.ClonePointerToString(content.SettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAdditionalUnattendContent interface (if implemented) to customize the conversion
	var contentAsAny any = content
	if augmentedContent, ok := contentAsAny.(augmentConversionForAdditionalUnattendContent); ok {
		err := augmentedContent.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.AdditionalUnattendContent_STATUS
// Specifies additional XML formatted information that can be included in the Unattend.xml file, which is used by Windows
// Setup. Contents are defined by setting name, component name, and the pass in which the content is applied.
type AdditionalUnattendContent_STATUS struct {
	ComponentName *string                `json:"componentName,omitempty"`
	Content       *string                `json:"content,omitempty"`
	PassName      *string                `json:"passName,omitempty"`
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SettingName   *string                `json:"settingName,omitempty"`
}

// AssignProperties_From_AdditionalUnattendContent_STATUS populates our AdditionalUnattendContent_STATUS from the provided source AdditionalUnattendContent_STATUS
func (content *AdditionalUnattendContent_STATUS) AssignProperties_From_AdditionalUnattendContent_STATUS(source *v20220301s.AdditionalUnattendContent_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ComponentName
	content.ComponentName = genruntime.ClonePointerToString(source.ComponentName)

	// Content
	content.Content = genruntime.ClonePointerToString(source.Content)

	// PassName
	content.PassName = genruntime.ClonePointerToString(source.PassName)

	// SettingName
	content.SettingName = genruntime.ClonePointerToString(source.SettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		content.PropertyBag = propertyBag
	} else {
		content.PropertyBag = nil
	}

	// Invoke the augmentConversionForAdditionalUnattendContent_STATUS interface (if implemented) to customize the conversion
	var contentAsAny any = content
	if augmentedContent, ok := contentAsAny.(augmentConversionForAdditionalUnattendContent_STATUS); ok {
		err := augmentedContent.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AdditionalUnattendContent_STATUS populates the provided destination AdditionalUnattendContent_STATUS from our AdditionalUnattendContent_STATUS
func (content *AdditionalUnattendContent_STATUS) AssignProperties_To_AdditionalUnattendContent_STATUS(destination *v20220301s.AdditionalUnattendContent_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(content.PropertyBag)

	// ComponentName
	destination.ComponentName = genruntime.ClonePointerToString(content.ComponentName)

	// Content
	destination.Content = genruntime.ClonePointerToString(content.Content)

	// PassName
	destination.PassName = genruntime.ClonePointerToString(content.PassName)

	// SettingName
	destination.SettingName = genruntime.ClonePointerToString(content.SettingName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAdditionalUnattendContent_STATUS interface (if implemented) to customize the conversion
	var contentAsAny any = content
	if augmentedContent, ok := contentAsAny.(augmentConversionForAdditionalUnattendContent_STATUS); ok {
		err := augmentedContent.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForBootDiagnostics interface {
	AssignPropertiesFrom(src *v20220301s.BootDiagnostics) error
	AssignPropertiesTo(dst *v20220301s.BootDiagnostics) error
}

type augmentConversionForBootDiagnostics_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.BootDiagnostics_STATUS) error
	AssignPropertiesTo(dst *v20220301s.BootDiagnostics_STATUS) error
}

type augmentConversionForBootDiagnosticsInstanceView_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.BootDiagnosticsInstanceView_STATUS) error
	AssignPropertiesTo(dst *v20220301s.BootDiagnosticsInstanceView_STATUS) error
}

type augmentConversionForDataDisk interface {
	AssignPropertiesFrom(src *v20220301s.DataDisk) error
	AssignPropertiesTo(dst *v20220301s.DataDisk) error
}

type augmentConversionForDataDisk_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.DataDisk_STATUS) error
	AssignPropertiesTo(dst *v20220301s.DataDisk_STATUS) error
}

type augmentConversionForDiskInstanceView_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.DiskInstanceView_STATUS) error
	AssignPropertiesTo(dst *v20220301s.DiskInstanceView_STATUS) error
}

type augmentConversionForImageReference interface {
	AssignPropertiesFrom(src *v20220301s.ImageReference) error
	AssignPropertiesTo(dst *v20220301s.ImageReference) error
}

type augmentConversionForImageReference_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.ImageReference_STATUS) error
	AssignPropertiesTo(dst *v20220301s.ImageReference_STATUS) error
}

type augmentConversionForInstanceViewStatus_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.InstanceViewStatus_STATUS) error
	AssignPropertiesTo(dst *v20220301s.InstanceViewStatus_STATUS) error
}

type augmentConversionForLinuxConfiguration interface {
	AssignPropertiesFrom(src *v20220301s.LinuxConfiguration) error
	AssignPropertiesTo(dst *v20220301s.LinuxConfiguration) error
}

type augmentConversionForLinuxConfiguration_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.LinuxConfiguration_STATUS) error
	AssignPropertiesTo(dst *v20220301s.LinuxConfiguration_STATUS) error
}

type augmentConversionForMaintenanceRedeployStatus_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.MaintenanceRedeployStatus_STATUS) error
	AssignPropertiesTo(dst *v20220301s.MaintenanceRedeployStatus_STATUS) error
}

type augmentConversionForNetworkInterfaceReference interface {
	AssignPropertiesFrom(src *v20220301s.NetworkInterfaceReference) error
	AssignPropertiesTo(dst *v20220301s.NetworkInterfaceReference) error
}

type augmentConversionForNetworkInterfaceReference_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.NetworkInterfaceReference_STATUS) error
	AssignPropertiesTo(dst *v20220301s.NetworkInterfaceReference_STATUS) error
}

type augmentConversionForOSDisk interface {
	AssignPropertiesFrom(src *v20220301s.OSDisk) error
	AssignPropertiesTo(dst *v20220301s.OSDisk) error
}

type augmentConversionForOSDisk_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.OSDisk_STATUS) error
	AssignPropertiesTo(dst *v20220301s.OSDisk_STATUS) error
}

type augmentConversionForUefiSettings interface {
	AssignPropertiesFrom(src *v20220301s.UefiSettings) error
	AssignPropertiesTo(dst *v20220301s.UefiSettings) error
}

type augmentConversionForUefiSettings_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.UefiSettings_STATUS) error
	AssignPropertiesTo(dst *v20220301s.UefiSettings_STATUS) error
}

type augmentConversionForUserAssignedIdentityDetails interface {
	AssignPropertiesFrom(src *v20220301s.UserAssignedIdentityDetails) error
	AssignPropertiesTo(dst *v20220301s.UserAssignedIdentityDetails) error
}

type augmentConversionForVaultSecretGroup interface {
	AssignPropertiesFrom(src *v20220301s.VaultSecretGroup) error
	AssignPropertiesTo(dst *v20220301s.VaultSecretGroup) error
}

type augmentConversionForVaultSecretGroup_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VaultSecretGroup_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VaultSecretGroup_STATUS) error
}

type augmentConversionForVirtualMachineAgentInstanceView_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineAgentInstanceView_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineAgentInstanceView_STATUS) error
}

type augmentConversionForVirtualMachineHealthStatus_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineHealthStatus_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineHealthStatus_STATUS) error
}

type augmentConversionForVirtualMachineIdentity_UserAssignedIdentities_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineIdentity_UserAssignedIdentities_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineIdentity_UserAssignedIdentities_STATUS) error
}

type augmentConversionForVirtualMachinePatchStatus_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachinePatchStatus_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachinePatchStatus_STATUS) error
}

type augmentConversionForWindowsConfiguration interface {
	AssignPropertiesFrom(src *v20220301s.WindowsConfiguration) error
	AssignPropertiesTo(dst *v20220301s.WindowsConfiguration) error
}

type augmentConversionForWindowsConfiguration_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.WindowsConfiguration_STATUS) error
	AssignPropertiesTo(dst *v20220301s.WindowsConfiguration_STATUS) error
}

// Storage version of v1api20201201.AvailablePatchSummary_STATUS
// Describes the properties of an virtual machine instance view for available patch summary.
type AvailablePatchSummary_STATUS struct {
	AssessmentActivityId          *string                `json:"assessmentActivityId,omitempty"`
	CriticalAndSecurityPatchCount *int                   `json:"criticalAndSecurityPatchCount,omitempty"`
	Error                         *ApiError_STATUS       `json:"error,omitempty"`
	LastModifiedTime              *string                `json:"lastModifiedTime,omitempty"`
	OtherPatchCount               *int                   `json:"otherPatchCount,omitempty"`
	PropertyBag                   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	RebootPending                 *bool                  `json:"rebootPending,omitempty"`
	StartTime                     *string                `json:"startTime,omitempty"`
	Status                        *string                `json:"status,omitempty"`
}

// AssignProperties_From_AvailablePatchSummary_STATUS populates our AvailablePatchSummary_STATUS from the provided source AvailablePatchSummary_STATUS
func (summary *AvailablePatchSummary_STATUS) AssignProperties_From_AvailablePatchSummary_STATUS(source *v20220301s.AvailablePatchSummary_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AssessmentActivityId
	summary.AssessmentActivityId = genruntime.ClonePointerToString(source.AssessmentActivityId)

	// CriticalAndSecurityPatchCount
	summary.CriticalAndSecurityPatchCount = genruntime.ClonePointerToInt(source.CriticalAndSecurityPatchCount)

	// Error
	if source.Error != nil {
		var error ApiError_STATUS
		err := error.AssignProperties_From_ApiError_STATUS(source.Error)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApiError_STATUS() to populate field Error")
		}
		summary.Error = &error
	} else {
		summary.Error = nil
	}

	// LastModifiedTime
	summary.LastModifiedTime = genruntime.ClonePointerToString(source.LastModifiedTime)

	// OtherPatchCount
	summary.OtherPatchCount = genruntime.ClonePointerToInt(source.OtherPatchCount)

	// RebootPending
	if source.RebootPending != nil {
		rebootPending := *source.RebootPending
		summary.RebootPending = &rebootPending
	} else {
		summary.RebootPending = nil
	}

	// StartTime
	summary.StartTime = genruntime.ClonePointerToString(source.StartTime)

	// Status
	summary.Status = genruntime.ClonePointerToString(source.Status)

	// Update the property bag
	if len(propertyBag) > 0 {
		summary.PropertyBag = propertyBag
	} else {
		summary.PropertyBag = nil
	}

	// Invoke the augmentConversionForAvailablePatchSummary_STATUS interface (if implemented) to customize the conversion
	var summaryAsAny any = summary
	if augmentedSummary, ok := summaryAsAny.(augmentConversionForAvailablePatchSummary_STATUS); ok {
		err := augmentedSummary.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AvailablePatchSummary_STATUS populates the provided destination AvailablePatchSummary_STATUS from our AvailablePatchSummary_STATUS
func (summary *AvailablePatchSummary_STATUS) AssignProperties_To_AvailablePatchSummary_STATUS(destination *v20220301s.AvailablePatchSummary_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(summary.PropertyBag)

	// AssessmentActivityId
	destination.AssessmentActivityId = genruntime.ClonePointerToString(summary.AssessmentActivityId)

	// CriticalAndSecurityPatchCount
	destination.CriticalAndSecurityPatchCount = genruntime.ClonePointerToInt(summary.CriticalAndSecurityPatchCount)

	// Error
	if summary.Error != nil {
		var error v20220301s.ApiError_STATUS
		err := summary.Error.AssignProperties_To_ApiError_STATUS(&error)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApiError_STATUS() to populate field Error")
		}
		destination.Error = &error
	} else {
		destination.Error = nil
	}

	// LastModifiedTime
	destination.LastModifiedTime = genruntime.ClonePointerToString(summary.LastModifiedTime)

	// OtherPatchCount
	destination.OtherPatchCount = genruntime.ClonePointerToInt(summary.OtherPatchCount)

	// RebootPending
	if summary.RebootPending != nil {
		rebootPending := *summary.RebootPending
		destination.RebootPending = &rebootPending
	} else {
		destination.RebootPending = nil
	}

	// StartTime
	destination.StartTime = genruntime.ClonePointerToString(summary.StartTime)

	// Status
	destination.Status = genruntime.ClonePointerToString(summary.Status)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAvailablePatchSummary_STATUS interface (if implemented) to customize the conversion
	var summaryAsAny any = summary
	if augmentedSummary, ok := summaryAsAny.(augmentConversionForAvailablePatchSummary_STATUS); ok {
		err := augmentedSummary.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.DiffDiskSettings
// Describes the parameters of ephemeral disk settings that can be specified for operating system disk.
// NOTE: The
// ephemeral disk settings can only be specified for managed disk.
type DiffDiskSettings struct {
	Option      *string                `json:"option,omitempty"`
	Placement   *string                `json:"placement,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DiffDiskSettings populates our DiffDiskSettings from the provided source DiffDiskSettings
func (settings *DiffDiskSettings) AssignProperties_From_DiffDiskSettings(source *v20220301s.DiffDiskSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Option
	settings.Option = genruntime.ClonePointerToString(source.Option)

	// Placement
	settings.Placement = genruntime.ClonePointerToString(source.Placement)

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForDiffDiskSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForDiffDiskSettings); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DiffDiskSettings populates the provided destination DiffDiskSettings from our DiffDiskSettings
func (settings *DiffDiskSettings) AssignProperties_To_DiffDiskSettings(destination *v20220301s.DiffDiskSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// Option
	destination.Option = genruntime.ClonePointerToString(settings.Option)

	// Placement
	destination.Placement = genruntime.ClonePointerToString(settings.Placement)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDiffDiskSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForDiffDiskSettings); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.DiffDiskSettings_STATUS
// Describes the parameters of ephemeral disk settings that can be specified for operating system disk.
// NOTE: The
// ephemeral disk settings can only be specified for managed disk.
type DiffDiskSettings_STATUS struct {
	Option      *string                `json:"option,omitempty"`
	Placement   *string                `json:"placement,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DiffDiskSettings_STATUS populates our DiffDiskSettings_STATUS from the provided source DiffDiskSettings_STATUS
func (settings *DiffDiskSettings_STATUS) AssignProperties_From_DiffDiskSettings_STATUS(source *v20220301s.DiffDiskSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Option
	settings.Option = genruntime.ClonePointerToString(source.Option)

	// Placement
	settings.Placement = genruntime.ClonePointerToString(source.Placement)

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForDiffDiskSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForDiffDiskSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DiffDiskSettings_STATUS populates the provided destination DiffDiskSettings_STATUS from our DiffDiskSettings_STATUS
func (settings *DiffDiskSettings_STATUS) AssignProperties_To_DiffDiskSettings_STATUS(destination *v20220301s.DiffDiskSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// Option
	destination.Option = genruntime.ClonePointerToString(settings.Option)

	// Placement
	destination.Placement = genruntime.ClonePointerToString(settings.Placement)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDiffDiskSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForDiffDiskSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.DiskEncryptionSettings
// Describes a Encryption Settings for a Disk
type DiskEncryptionSettings struct {
	DiskEncryptionKey *KeyVaultSecretReference `json:"diskEncryptionKey,omitempty"`
	Enabled           *bool                    `json:"enabled,omitempty"`
	KeyEncryptionKey  *KeyVaultKeyReference    `json:"keyEncryptionKey,omitempty"`
	PropertyBag       genruntime.PropertyBag   `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DiskEncryptionSettings populates our DiskEncryptionSettings from the provided source DiskEncryptionSettings
func (settings *DiskEncryptionSettings) AssignProperties_From_DiskEncryptionSettings(source *v20220301s.DiskEncryptionSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DiskEncryptionKey
	if source.DiskEncryptionKey != nil {
		var diskEncryptionKey KeyVaultSecretReference
		err := diskEncryptionKey.AssignProperties_From_KeyVaultSecretReference(source.DiskEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_KeyVaultSecretReference() to populate field DiskEncryptionKey")
		}
		settings.DiskEncryptionKey = &diskEncryptionKey
	} else {
		settings.DiskEncryptionKey = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		settings.Enabled = &enabled
	} else {
		settings.Enabled = nil
	}

	// KeyEncryptionKey
	if source.KeyEncryptionKey != nil {
		var keyEncryptionKey KeyVaultKeyReference
		err := keyEncryptionKey.AssignProperties_From_KeyVaultKeyReference(source.KeyEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_KeyVaultKeyReference() to populate field KeyEncryptionKey")
		}
		settings.KeyEncryptionKey = &keyEncryptionKey
	} else {
		settings.KeyEncryptionKey = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForDiskEncryptionSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForDiskEncryptionSettings); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DiskEncryptionSettings populates the provided destination DiskEncryptionSettings from our DiskEncryptionSettings
func (settings *DiskEncryptionSettings) AssignProperties_To_DiskEncryptionSettings(destination *v20220301s.DiskEncryptionSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// DiskEncryptionKey
	if settings.DiskEncryptionKey != nil {
		var diskEncryptionKey v20220301s.KeyVaultSecretReference
		err := settings.DiskEncryptionKey.AssignProperties_To_KeyVaultSecretReference(&diskEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_KeyVaultSecretReference() to populate field DiskEncryptionKey")
		}
		destination.DiskEncryptionKey = &diskEncryptionKey
	} else {
		destination.DiskEncryptionKey = nil
	}

	// Enabled
	if settings.Enabled != nil {
		enabled := *settings.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// KeyEncryptionKey
	if settings.KeyEncryptionKey != nil {
		var keyEncryptionKey v20220301s.KeyVaultKeyReference
		err := settings.KeyEncryptionKey.AssignProperties_To_KeyVaultKeyReference(&keyEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_KeyVaultKeyReference() to populate field KeyEncryptionKey")
		}
		destination.KeyEncryptionKey = &keyEncryptionKey
	} else {
		destination.KeyEncryptionKey = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDiskEncryptionSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForDiskEncryptionSettings); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.DiskEncryptionSettings_STATUS
// Describes a Encryption Settings for a Disk
type DiskEncryptionSettings_STATUS struct {
	DiskEncryptionKey *KeyVaultSecretReference_STATUS `json:"diskEncryptionKey,omitempty"`
	Enabled           *bool                           `json:"enabled,omitempty"`
	KeyEncryptionKey  *KeyVaultKeyReference_STATUS    `json:"keyEncryptionKey,omitempty"`
	PropertyBag       genruntime.PropertyBag          `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DiskEncryptionSettings_STATUS populates our DiskEncryptionSettings_STATUS from the provided source DiskEncryptionSettings_STATUS
func (settings *DiskEncryptionSettings_STATUS) AssignProperties_From_DiskEncryptionSettings_STATUS(source *v20220301s.DiskEncryptionSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DiskEncryptionKey
	if source.DiskEncryptionKey != nil {
		var diskEncryptionKey KeyVaultSecretReference_STATUS
		err := diskEncryptionKey.AssignProperties_From_KeyVaultSecretReference_STATUS(source.DiskEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_KeyVaultSecretReference_STATUS() to populate field DiskEncryptionKey")
		}
		settings.DiskEncryptionKey = &diskEncryptionKey
	} else {
		settings.DiskEncryptionKey = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		settings.Enabled = &enabled
	} else {
		settings.Enabled = nil
	}

	// KeyEncryptionKey
	if source.KeyEncryptionKey != nil {
		var keyEncryptionKey KeyVaultKeyReference_STATUS
		err := keyEncryptionKey.AssignProperties_From_KeyVaultKeyReference_STATUS(source.KeyEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_KeyVaultKeyReference_STATUS() to populate field KeyEncryptionKey")
		}
		settings.KeyEncryptionKey = &keyEncryptionKey
	} else {
		settings.KeyEncryptionKey = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForDiskEncryptionSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForDiskEncryptionSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DiskEncryptionSettings_STATUS populates the provided destination DiskEncryptionSettings_STATUS from our DiskEncryptionSettings_STATUS
func (settings *DiskEncryptionSettings_STATUS) AssignProperties_To_DiskEncryptionSettings_STATUS(destination *v20220301s.DiskEncryptionSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// DiskEncryptionKey
	if settings.DiskEncryptionKey != nil {
		var diskEncryptionKey v20220301s.KeyVaultSecretReference_STATUS
		err := settings.DiskEncryptionKey.AssignProperties_To_KeyVaultSecretReference_STATUS(&diskEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_KeyVaultSecretReference_STATUS() to populate field DiskEncryptionKey")
		}
		destination.DiskEncryptionKey = &diskEncryptionKey
	} else {
		destination.DiskEncryptionKey = nil
	}

	// Enabled
	if settings.Enabled != nil {
		enabled := *settings.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// KeyEncryptionKey
	if settings.KeyEncryptionKey != nil {
		var keyEncryptionKey v20220301s.KeyVaultKeyReference_STATUS
		err := settings.KeyEncryptionKey.AssignProperties_To_KeyVaultKeyReference_STATUS(&keyEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_KeyVaultKeyReference_STATUS() to populate field KeyEncryptionKey")
		}
		destination.KeyEncryptionKey = &keyEncryptionKey
	} else {
		destination.KeyEncryptionKey = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDiskEncryptionSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForDiskEncryptionSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.LastPatchInstallationSummary_STATUS
// Describes the properties of the last installed patch summary.
type LastPatchInstallationSummary_STATUS struct {
	Error                     *ApiError_STATUS       `json:"error,omitempty"`
	ExcludedPatchCount        *int                   `json:"excludedPatchCount,omitempty"`
	FailedPatchCount          *int                   `json:"failedPatchCount,omitempty"`
	InstallationActivityId    *string                `json:"installationActivityId,omitempty"`
	InstalledPatchCount       *int                   `json:"installedPatchCount,omitempty"`
	LastModifiedTime          *string                `json:"lastModifiedTime,omitempty"`
	MaintenanceWindowExceeded *bool                  `json:"maintenanceWindowExceeded,omitempty"`
	NotSelectedPatchCount     *int                   `json:"notSelectedPatchCount,omitempty"`
	PendingPatchCount         *int                   `json:"pendingPatchCount,omitempty"`
	PropertyBag               genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	StartTime                 *string                `json:"startTime,omitempty"`
	Status                    *string                `json:"status,omitempty"`
}

// AssignProperties_From_LastPatchInstallationSummary_STATUS populates our LastPatchInstallationSummary_STATUS from the provided source LastPatchInstallationSummary_STATUS
func (summary *LastPatchInstallationSummary_STATUS) AssignProperties_From_LastPatchInstallationSummary_STATUS(source *v20220301s.LastPatchInstallationSummary_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Error
	if source.Error != nil {
		var error ApiError_STATUS
		err := error.AssignProperties_From_ApiError_STATUS(source.Error)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApiError_STATUS() to populate field Error")
		}
		summary.Error = &error
	} else {
		summary.Error = nil
	}

	// ExcludedPatchCount
	summary.ExcludedPatchCount = genruntime.ClonePointerToInt(source.ExcludedPatchCount)

	// FailedPatchCount
	summary.FailedPatchCount = genruntime.ClonePointerToInt(source.FailedPatchCount)

	// InstallationActivityId
	summary.InstallationActivityId = genruntime.ClonePointerToString(source.InstallationActivityId)

	// InstalledPatchCount
	summary.InstalledPatchCount = genruntime.ClonePointerToInt(source.InstalledPatchCount)

	// LastModifiedTime
	summary.LastModifiedTime = genruntime.ClonePointerToString(source.LastModifiedTime)

	// MaintenanceWindowExceeded
	if source.MaintenanceWindowExceeded != nil {
		maintenanceWindowExceeded := *source.MaintenanceWindowExceeded
		summary.MaintenanceWindowExceeded = &maintenanceWindowExceeded
	} else {
		summary.MaintenanceWindowExceeded = nil
	}

	// NotSelectedPatchCount
	summary.NotSelectedPatchCount = genruntime.ClonePointerToInt(source.NotSelectedPatchCount)

	// PendingPatchCount
	summary.PendingPatchCount = genruntime.ClonePointerToInt(source.PendingPatchCount)

	// StartTime
	summary.StartTime = genruntime.ClonePointerToString(source.StartTime)

	// Status
	summary.Status = genruntime.ClonePointerToString(source.Status)

	// Update the property bag
	if len(propertyBag) > 0 {
		summary.PropertyBag = propertyBag
	} else {
		summary.PropertyBag = nil
	}

	// Invoke the augmentConversionForLastPatchInstallationSummary_STATUS interface (if implemented) to customize the conversion
	var summaryAsAny any = summary
	if augmentedSummary, ok := summaryAsAny.(augmentConversionForLastPatchInstallationSummary_STATUS); ok {
		err := augmentedSummary.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_LastPatchInstallationSummary_STATUS populates the provided destination LastPatchInstallationSummary_STATUS from our LastPatchInstallationSummary_STATUS
func (summary *LastPatchInstallationSummary_STATUS) AssignProperties_To_LastPatchInstallationSummary_STATUS(destination *v20220301s.LastPatchInstallationSummary_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(summary.PropertyBag)

	// Error
	if summary.Error != nil {
		var error v20220301s.ApiError_STATUS
		err := summary.Error.AssignProperties_To_ApiError_STATUS(&error)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApiError_STATUS() to populate field Error")
		}
		destination.Error = &error
	} else {
		destination.Error = nil
	}

	// ExcludedPatchCount
	destination.ExcludedPatchCount = genruntime.ClonePointerToInt(summary.ExcludedPatchCount)

	// FailedPatchCount
	destination.FailedPatchCount = genruntime.ClonePointerToInt(summary.FailedPatchCount)

	// InstallationActivityId
	destination.InstallationActivityId = genruntime.ClonePointerToString(summary.InstallationActivityId)

	// InstalledPatchCount
	destination.InstalledPatchCount = genruntime.ClonePointerToInt(summary.InstalledPatchCount)

	// LastModifiedTime
	destination.LastModifiedTime = genruntime.ClonePointerToString(summary.LastModifiedTime)

	// MaintenanceWindowExceeded
	if summary.MaintenanceWindowExceeded != nil {
		maintenanceWindowExceeded := *summary.MaintenanceWindowExceeded
		destination.MaintenanceWindowExceeded = &maintenanceWindowExceeded
	} else {
		destination.MaintenanceWindowExceeded = nil
	}

	// NotSelectedPatchCount
	destination.NotSelectedPatchCount = genruntime.ClonePointerToInt(summary.NotSelectedPatchCount)

	// PendingPatchCount
	destination.PendingPatchCount = genruntime.ClonePointerToInt(summary.PendingPatchCount)

	// StartTime
	destination.StartTime = genruntime.ClonePointerToString(summary.StartTime)

	// Status
	destination.Status = genruntime.ClonePointerToString(summary.Status)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForLastPatchInstallationSummary_STATUS interface (if implemented) to customize the conversion
	var summaryAsAny any = summary
	if augmentedSummary, ok := summaryAsAny.(augmentConversionForLastPatchInstallationSummary_STATUS); ok {
		err := augmentedSummary.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.LinuxPatchSettings
// Specifies settings related to VM Guest Patching on Linux.
type LinuxPatchSettings struct {
	PatchMode   *string                `json:"patchMode,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_LinuxPatchSettings populates our LinuxPatchSettings from the provided source LinuxPatchSettings
func (settings *LinuxPatchSettings) AssignProperties_From_LinuxPatchSettings(source *v20220301s.LinuxPatchSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AssessmentMode
	if source.AssessmentMode != nil {
		propertyBag.Add("AssessmentMode", *source.AssessmentMode)
	} else {
		propertyBag.Remove("AssessmentMode")
	}

	// AutomaticByPlatformSettings
	if source.AutomaticByPlatformSettings != nil {
		propertyBag.Add("AutomaticByPlatformSettings", *source.AutomaticByPlatformSettings)
	} else {
		propertyBag.Remove("AutomaticByPlatformSettings")
	}

	// PatchMode
	settings.PatchMode = genruntime.ClonePointerToString(source.PatchMode)

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForLinuxPatchSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForLinuxPatchSettings); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_LinuxPatchSettings populates the provided destination LinuxPatchSettings from our LinuxPatchSettings
func (settings *LinuxPatchSettings) AssignProperties_To_LinuxPatchSettings(destination *v20220301s.LinuxPatchSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// AssessmentMode
	if propertyBag.Contains("AssessmentMode") {
		var assessmentMode string
		err := propertyBag.Pull("AssessmentMode", &assessmentMode)
		if err != nil {
			return errors.Wrap(err, "pulling 'AssessmentMode' from propertyBag")
		}

		destination.AssessmentMode = &assessmentMode
	} else {
		destination.AssessmentMode = nil
	}

	// AutomaticByPlatformSettings
	if propertyBag.Contains("AutomaticByPlatformSettings") {
		var automaticByPlatformSetting v20220301s.LinuxVMGuestPatchAutomaticByPlatformSettings
		err := propertyBag.Pull("AutomaticByPlatformSettings", &automaticByPlatformSetting)
		if err != nil {
			return errors.Wrap(err, "pulling 'AutomaticByPlatformSettings' from propertyBag")
		}

		destination.AutomaticByPlatformSettings = &automaticByPlatformSetting
	} else {
		destination.AutomaticByPlatformSettings = nil
	}

	// PatchMode
	destination.PatchMode = genruntime.ClonePointerToString(settings.PatchMode)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForLinuxPatchSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForLinuxPatchSettings); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.LinuxPatchSettings_STATUS
// Specifies settings related to VM Guest Patching on Linux.
type LinuxPatchSettings_STATUS struct {
	PatchMode   *string                `json:"patchMode,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_LinuxPatchSettings_STATUS populates our LinuxPatchSettings_STATUS from the provided source LinuxPatchSettings_STATUS
func (settings *LinuxPatchSettings_STATUS) AssignProperties_From_LinuxPatchSettings_STATUS(source *v20220301s.LinuxPatchSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AssessmentMode
	if source.AssessmentMode != nil {
		propertyBag.Add("AssessmentMode", *source.AssessmentMode)
	} else {
		propertyBag.Remove("AssessmentMode")
	}

	// AutomaticByPlatformSettings
	if source.AutomaticByPlatformSettings != nil {
		propertyBag.Add("AutomaticByPlatformSettings", *source.AutomaticByPlatformSettings)
	} else {
		propertyBag.Remove("AutomaticByPlatformSettings")
	}

	// PatchMode
	settings.PatchMode = genruntime.ClonePointerToString(source.PatchMode)

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForLinuxPatchSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForLinuxPatchSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_LinuxPatchSettings_STATUS populates the provided destination LinuxPatchSettings_STATUS from our LinuxPatchSettings_STATUS
func (settings *LinuxPatchSettings_STATUS) AssignProperties_To_LinuxPatchSettings_STATUS(destination *v20220301s.LinuxPatchSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// AssessmentMode
	if propertyBag.Contains("AssessmentMode") {
		var assessmentMode string
		err := propertyBag.Pull("AssessmentMode", &assessmentMode)
		if err != nil {
			return errors.Wrap(err, "pulling 'AssessmentMode' from propertyBag")
		}

		destination.AssessmentMode = &assessmentMode
	} else {
		destination.AssessmentMode = nil
	}

	// AutomaticByPlatformSettings
	if propertyBag.Contains("AutomaticByPlatformSettings") {
		var automaticByPlatformSetting v20220301s.LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS
		err := propertyBag.Pull("AutomaticByPlatformSettings", &automaticByPlatformSetting)
		if err != nil {
			return errors.Wrap(err, "pulling 'AutomaticByPlatformSettings' from propertyBag")
		}

		destination.AutomaticByPlatformSettings = &automaticByPlatformSetting
	} else {
		destination.AutomaticByPlatformSettings = nil
	}

	// PatchMode
	destination.PatchMode = genruntime.ClonePointerToString(settings.PatchMode)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForLinuxPatchSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForLinuxPatchSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.ManagedDiskParameters
// The parameters of a managed disk.
type ManagedDiskParameters struct {
	DiskEncryptionSet *SubResource           `json:"diskEncryptionSet,omitempty"`
	PropertyBag       genruntime.PropertyBag `json:"$propertyBag,omitempty"`

	// Reference: Resource Id
	Reference          *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
	StorageAccountType *string                       `json:"storageAccountType,omitempty"`
}

// AssignProperties_From_ManagedDiskParameters populates our ManagedDiskParameters from the provided source ManagedDiskParameters
func (parameters *ManagedDiskParameters) AssignProperties_From_ManagedDiskParameters(source *v20220301s.ManagedDiskParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DiskEncryptionSet
	if source.DiskEncryptionSet != nil {
		var subResourceStash v20210701s.SubResource
		err := subResourceStash.AssignProperties_From_SubResource(source.DiskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from DiskEncryptionSet")
		}
		var diskEncryptionSet SubResource
		err = diskEncryptionSet.AssignProperties_From_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field DiskEncryptionSet from SubResourceStash")
		}
		parameters.DiskEncryptionSet = &diskEncryptionSet
	} else {
		parameters.DiskEncryptionSet = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		parameters.Reference = &reference
	} else {
		parameters.Reference = nil
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		propertyBag.Add("SecurityProfile", *source.SecurityProfile)
	} else {
		propertyBag.Remove("SecurityProfile")
	}

	// StorageAccountType
	parameters.StorageAccountType = genruntime.ClonePointerToString(source.StorageAccountType)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForManagedDiskParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForManagedDiskParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedDiskParameters populates the provided destination ManagedDiskParameters from our ManagedDiskParameters
func (parameters *ManagedDiskParameters) AssignProperties_To_ManagedDiskParameters(destination *v20220301s.ManagedDiskParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// DiskEncryptionSet
	if parameters.DiskEncryptionSet != nil {
		var subResourceStash v20210701s.SubResource
		err := parameters.DiskEncryptionSet.AssignProperties_To_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from DiskEncryptionSet")
		}
		var diskEncryptionSet v20220301s.SubResource
		err = subResourceStash.AssignProperties_To_SubResource(&diskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field DiskEncryptionSet from SubResourceStash")
		}
		destination.DiskEncryptionSet = &diskEncryptionSet
	} else {
		destination.DiskEncryptionSet = nil
	}

	// Reference
	if parameters.Reference != nil {
		reference := parameters.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// SecurityProfile
	if propertyBag.Contains("SecurityProfile") {
		var securityProfile v20220301s.VMDiskSecurityProfile
		err := propertyBag.Pull("SecurityProfile", &securityProfile)
		if err != nil {
			return errors.Wrap(err, "pulling 'SecurityProfile' from propertyBag")
		}

		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// StorageAccountType
	destination.StorageAccountType = genruntime.ClonePointerToString(parameters.StorageAccountType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForManagedDiskParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForManagedDiskParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.ManagedDiskParameters_STATUS
// The parameters of a managed disk.
type ManagedDiskParameters_STATUS struct {
	DiskEncryptionSet  *SubResource_STATUS    `json:"diskEncryptionSet,omitempty"`
	Id                 *string                `json:"id,omitempty"`
	PropertyBag        genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	StorageAccountType *string                `json:"storageAccountType,omitempty"`
}

// AssignProperties_From_ManagedDiskParameters_STATUS populates our ManagedDiskParameters_STATUS from the provided source ManagedDiskParameters_STATUS
func (parameters *ManagedDiskParameters_STATUS) AssignProperties_From_ManagedDiskParameters_STATUS(source *v20220301s.ManagedDiskParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DiskEncryptionSet
	if source.DiskEncryptionSet != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(source.DiskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from DiskEncryptionSet")
		}
		var diskEncryptionSet SubResource_STATUS
		err = diskEncryptionSet.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field DiskEncryptionSet from SubResource_STATUSStash")
		}
		parameters.DiskEncryptionSet = &diskEncryptionSet
	} else {
		parameters.DiskEncryptionSet = nil
	}

	// Id
	parameters.Id = genruntime.ClonePointerToString(source.Id)

	// SecurityProfile
	if source.SecurityProfile != nil {
		propertyBag.Add("SecurityProfile", *source.SecurityProfile)
	} else {
		propertyBag.Remove("SecurityProfile")
	}

	// StorageAccountType
	parameters.StorageAccountType = genruntime.ClonePointerToString(source.StorageAccountType)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForManagedDiskParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForManagedDiskParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedDiskParameters_STATUS populates the provided destination ManagedDiskParameters_STATUS from our ManagedDiskParameters_STATUS
func (parameters *ManagedDiskParameters_STATUS) AssignProperties_To_ManagedDiskParameters_STATUS(destination *v20220301s.ManagedDiskParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// DiskEncryptionSet
	if parameters.DiskEncryptionSet != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := parameters.DiskEncryptionSet.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from DiskEncryptionSet")
		}
		var diskEncryptionSet v20220301s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&diskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field DiskEncryptionSet from SubResource_STATUSStash")
		}
		destination.DiskEncryptionSet = &diskEncryptionSet
	} else {
		destination.DiskEncryptionSet = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(parameters.Id)

	// SecurityProfile
	if propertyBag.Contains("SecurityProfile") {
		var securityProfile v20220301s.VMDiskSecurityProfile_STATUS
		err := propertyBag.Pull("SecurityProfile", &securityProfile)
		if err != nil {
			return errors.Wrap(err, "pulling 'SecurityProfile' from propertyBag")
		}

		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// StorageAccountType
	destination.StorageAccountType = genruntime.ClonePointerToString(parameters.StorageAccountType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForManagedDiskParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForManagedDiskParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.PatchSettings
// Specifies settings related to VM Guest Patching on Windows.
type PatchSettings struct {
	EnableHotpatching *bool                  `json:"enableHotpatching,omitempty"`
	PatchMode         *string                `json:"patchMode,omitempty"`
	PropertyBag       genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_PatchSettings populates our PatchSettings from the provided source PatchSettings
func (settings *PatchSettings) AssignProperties_From_PatchSettings(source *v20220301s.PatchSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AssessmentMode
	if source.AssessmentMode != nil {
		propertyBag.Add("AssessmentMode", *source.AssessmentMode)
	} else {
		propertyBag.Remove("AssessmentMode")
	}

	// AutomaticByPlatformSettings
	if source.AutomaticByPlatformSettings != nil {
		propertyBag.Add("AutomaticByPlatformSettings", *source.AutomaticByPlatformSettings)
	} else {
		propertyBag.Remove("AutomaticByPlatformSettings")
	}

	// EnableHotpatching
	if source.EnableHotpatching != nil {
		enableHotpatching := *source.EnableHotpatching
		settings.EnableHotpatching = &enableHotpatching
	} else {
		settings.EnableHotpatching = nil
	}

	// PatchMode
	settings.PatchMode = genruntime.ClonePointerToString(source.PatchMode)

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForPatchSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForPatchSettings); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_PatchSettings populates the provided destination PatchSettings from our PatchSettings
func (settings *PatchSettings) AssignProperties_To_PatchSettings(destination *v20220301s.PatchSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// AssessmentMode
	if propertyBag.Contains("AssessmentMode") {
		var assessmentMode string
		err := propertyBag.Pull("AssessmentMode", &assessmentMode)
		if err != nil {
			return errors.Wrap(err, "pulling 'AssessmentMode' from propertyBag")
		}

		destination.AssessmentMode = &assessmentMode
	} else {
		destination.AssessmentMode = nil
	}

	// AutomaticByPlatformSettings
	if propertyBag.Contains("AutomaticByPlatformSettings") {
		var automaticByPlatformSetting v20220301s.WindowsVMGuestPatchAutomaticByPlatformSettings
		err := propertyBag.Pull("AutomaticByPlatformSettings", &automaticByPlatformSetting)
		if err != nil {
			return errors.Wrap(err, "pulling 'AutomaticByPlatformSettings' from propertyBag")
		}

		destination.AutomaticByPlatformSettings = &automaticByPlatformSetting
	} else {
		destination.AutomaticByPlatformSettings = nil
	}

	// EnableHotpatching
	if settings.EnableHotpatching != nil {
		enableHotpatching := *settings.EnableHotpatching
		destination.EnableHotpatching = &enableHotpatching
	} else {
		destination.EnableHotpatching = nil
	}

	// PatchMode
	destination.PatchMode = genruntime.ClonePointerToString(settings.PatchMode)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForPatchSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForPatchSettings); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.PatchSettings_STATUS
// Specifies settings related to VM Guest Patching on Windows.
type PatchSettings_STATUS struct {
	EnableHotpatching *bool                  `json:"enableHotpatching,omitempty"`
	PatchMode         *string                `json:"patchMode,omitempty"`
	PropertyBag       genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_PatchSettings_STATUS populates our PatchSettings_STATUS from the provided source PatchSettings_STATUS
func (settings *PatchSettings_STATUS) AssignProperties_From_PatchSettings_STATUS(source *v20220301s.PatchSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AssessmentMode
	if source.AssessmentMode != nil {
		propertyBag.Add("AssessmentMode", *source.AssessmentMode)
	} else {
		propertyBag.Remove("AssessmentMode")
	}

	// AutomaticByPlatformSettings
	if source.AutomaticByPlatformSettings != nil {
		propertyBag.Add("AutomaticByPlatformSettings", *source.AutomaticByPlatformSettings)
	} else {
		propertyBag.Remove("AutomaticByPlatformSettings")
	}

	// EnableHotpatching
	if source.EnableHotpatching != nil {
		enableHotpatching := *source.EnableHotpatching
		settings.EnableHotpatching = &enableHotpatching
	} else {
		settings.EnableHotpatching = nil
	}

	// PatchMode
	settings.PatchMode = genruntime.ClonePointerToString(source.PatchMode)

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForPatchSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForPatchSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_PatchSettings_STATUS populates the provided destination PatchSettings_STATUS from our PatchSettings_STATUS
func (settings *PatchSettings_STATUS) AssignProperties_To_PatchSettings_STATUS(destination *v20220301s.PatchSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// AssessmentMode
	if propertyBag.Contains("AssessmentMode") {
		var assessmentMode string
		err := propertyBag.Pull("AssessmentMode", &assessmentMode)
		if err != nil {
			return errors.Wrap(err, "pulling 'AssessmentMode' from propertyBag")
		}

		destination.AssessmentMode = &assessmentMode
	} else {
		destination.AssessmentMode = nil
	}

	// AutomaticByPlatformSettings
	if propertyBag.Contains("AutomaticByPlatformSettings") {
		var automaticByPlatformSetting v20220301s.WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS
		err := propertyBag.Pull("AutomaticByPlatformSettings", &automaticByPlatformSetting)
		if err != nil {
			return errors.Wrap(err, "pulling 'AutomaticByPlatformSettings' from propertyBag")
		}

		destination.AutomaticByPlatformSettings = &automaticByPlatformSetting
	} else {
		destination.AutomaticByPlatformSettings = nil
	}

	// EnableHotpatching
	if settings.EnableHotpatching != nil {
		enableHotpatching := *settings.EnableHotpatching
		destination.EnableHotpatching = &enableHotpatching
	} else {
		destination.EnableHotpatching = nil
	}

	// PatchMode
	destination.PatchMode = genruntime.ClonePointerToString(settings.PatchMode)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForPatchSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForPatchSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.SshConfiguration
// SSH configuration for Linux based VMs running on Azure
type SshConfiguration struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	PublicKeys  []SshPublicKeySpec     `json:"publicKeys,omitempty"`
}

// AssignProperties_From_SshConfiguration populates our SshConfiguration from the provided source SshConfiguration
func (configuration *SshConfiguration) AssignProperties_From_SshConfiguration(source *v20220301s.SshConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// PublicKeys
	if source.PublicKeys != nil {
		publicKeyList := make([]SshPublicKeySpec, len(source.PublicKeys))
		for publicKeyIndex, publicKeyItem := range source.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey SshPublicKeySpec
			err := publicKey.AssignProperties_From_SshPublicKeySpec(&publicKeyItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SshPublicKeySpec() to populate field PublicKeys")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		configuration.PublicKeys = publicKeyList
	} else {
		configuration.PublicKeys = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForSshConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForSshConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_SshConfiguration populates the provided destination SshConfiguration from our SshConfiguration
func (configuration *SshConfiguration) AssignProperties_To_SshConfiguration(destination *v20220301s.SshConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// PublicKeys
	if configuration.PublicKeys != nil {
		publicKeyList := make([]v20220301s.SshPublicKeySpec, len(configuration.PublicKeys))
		for publicKeyIndex, publicKeyItem := range configuration.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey v20220301s.SshPublicKeySpec
			err := publicKeyItem.AssignProperties_To_SshPublicKeySpec(&publicKey)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SshPublicKeySpec() to populate field PublicKeys")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		destination.PublicKeys = publicKeyList
	} else {
		destination.PublicKeys = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSshConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForSshConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.SshConfiguration_STATUS
// SSH configuration for Linux based VMs running on Azure
type SshConfiguration_STATUS struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	PublicKeys  []SshPublicKey_STATUS  `json:"publicKeys,omitempty"`
}

// AssignProperties_From_SshConfiguration_STATUS populates our SshConfiguration_STATUS from the provided source SshConfiguration_STATUS
func (configuration *SshConfiguration_STATUS) AssignProperties_From_SshConfiguration_STATUS(source *v20220301s.SshConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// PublicKeys
	if source.PublicKeys != nil {
		publicKeyList := make([]SshPublicKey_STATUS, len(source.PublicKeys))
		for publicKeyIndex, publicKeyItem := range source.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey SshPublicKey_STATUS
			err := publicKey.AssignProperties_From_SshPublicKey_STATUS(&publicKeyItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SshPublicKey_STATUS() to populate field PublicKeys")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		configuration.PublicKeys = publicKeyList
	} else {
		configuration.PublicKeys = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForSshConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForSshConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_SshConfiguration_STATUS populates the provided destination SshConfiguration_STATUS from our SshConfiguration_STATUS
func (configuration *SshConfiguration_STATUS) AssignProperties_To_SshConfiguration_STATUS(destination *v20220301s.SshConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// PublicKeys
	if configuration.PublicKeys != nil {
		publicKeyList := make([]v20220301s.SshPublicKey_STATUS, len(configuration.PublicKeys))
		for publicKeyIndex, publicKeyItem := range configuration.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey v20220301s.SshPublicKey_STATUS
			err := publicKeyItem.AssignProperties_To_SshPublicKey_STATUS(&publicKey)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SshPublicKey_STATUS() to populate field PublicKeys")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		destination.PublicKeys = publicKeyList
	} else {
		destination.PublicKeys = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSshConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForSshConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VaultCertificate
// Describes a single certificate reference in a Key Vault, and where the certificate should reside on the VM.
type VaultCertificate struct {
	CertificateStore *string                `json:"certificateStore,omitempty"`
	CertificateUrl   *string                `json:"certificateUrl,omitempty"`
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_VaultCertificate populates our VaultCertificate from the provided source VaultCertificate
func (certificate *VaultCertificate) AssignProperties_From_VaultCertificate(source *v20220301s.VaultCertificate) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CertificateStore
	certificate.CertificateStore = genruntime.ClonePointerToString(source.CertificateStore)

	// CertificateUrl
	certificate.CertificateUrl = genruntime.ClonePointerToString(source.CertificateUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		certificate.PropertyBag = propertyBag
	} else {
		certificate.PropertyBag = nil
	}

	// Invoke the augmentConversionForVaultCertificate interface (if implemented) to customize the conversion
	var certificateAsAny any = certificate
	if augmentedCertificate, ok := certificateAsAny.(augmentConversionForVaultCertificate); ok {
		err := augmentedCertificate.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VaultCertificate populates the provided destination VaultCertificate from our VaultCertificate
func (certificate *VaultCertificate) AssignProperties_To_VaultCertificate(destination *v20220301s.VaultCertificate) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(certificate.PropertyBag)

	// CertificateStore
	destination.CertificateStore = genruntime.ClonePointerToString(certificate.CertificateStore)

	// CertificateUrl
	destination.CertificateUrl = genruntime.ClonePointerToString(certificate.CertificateUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVaultCertificate interface (if implemented) to customize the conversion
	var certificateAsAny any = certificate
	if augmentedCertificate, ok := certificateAsAny.(augmentConversionForVaultCertificate); ok {
		err := augmentedCertificate.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VaultCertificate_STATUS
// Describes a single certificate reference in a Key Vault, and where the certificate should reside on the VM.
type VaultCertificate_STATUS struct {
	CertificateStore *string                `json:"certificateStore,omitempty"`
	CertificateUrl   *string                `json:"certificateUrl,omitempty"`
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_VaultCertificate_STATUS populates our VaultCertificate_STATUS from the provided source VaultCertificate_STATUS
func (certificate *VaultCertificate_STATUS) AssignProperties_From_VaultCertificate_STATUS(source *v20220301s.VaultCertificate_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CertificateStore
	certificate.CertificateStore = genruntime.ClonePointerToString(source.CertificateStore)

	// CertificateUrl
	certificate.CertificateUrl = genruntime.ClonePointerToString(source.CertificateUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		certificate.PropertyBag = propertyBag
	} else {
		certificate.PropertyBag = nil
	}

	// Invoke the augmentConversionForVaultCertificate_STATUS interface (if implemented) to customize the conversion
	var certificateAsAny any = certificate
	if augmentedCertificate, ok := certificateAsAny.(augmentConversionForVaultCertificate_STATUS); ok {
		err := augmentedCertificate.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VaultCertificate_STATUS populates the provided destination VaultCertificate_STATUS from our VaultCertificate_STATUS
func (certificate *VaultCertificate_STATUS) AssignProperties_To_VaultCertificate_STATUS(destination *v20220301s.VaultCertificate_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(certificate.PropertyBag)

	// CertificateStore
	destination.CertificateStore = genruntime.ClonePointerToString(certificate.CertificateStore)

	// CertificateUrl
	destination.CertificateUrl = genruntime.ClonePointerToString(certificate.CertificateUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVaultCertificate_STATUS interface (if implemented) to customize the conversion
	var certificateAsAny any = certificate
	if augmentedCertificate, ok := certificateAsAny.(augmentConversionForVaultCertificate_STATUS); ok {
		err := augmentedCertificate.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualHardDisk
// Describes the uri of a disk.
type VirtualHardDisk struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Uri         *string                `json:"uri,omitempty"`
}

// AssignProperties_From_VirtualHardDisk populates our VirtualHardDisk from the provided source VirtualHardDisk
func (disk *VirtualHardDisk) AssignProperties_From_VirtualHardDisk(source *v20220301s.VirtualHardDisk) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Uri
	disk.Uri = genruntime.ClonePointerToString(source.Uri)

	// Update the property bag
	if len(propertyBag) > 0 {
		disk.PropertyBag = propertyBag
	} else {
		disk.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualHardDisk interface (if implemented) to customize the conversion
	var diskAsAny any = disk
	if augmentedDisk, ok := diskAsAny.(augmentConversionForVirtualHardDisk); ok {
		err := augmentedDisk.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualHardDisk populates the provided destination VirtualHardDisk from our VirtualHardDisk
func (disk *VirtualHardDisk) AssignProperties_To_VirtualHardDisk(destination *v20220301s.VirtualHardDisk) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(disk.PropertyBag)

	// Uri
	destination.Uri = genruntime.ClonePointerToString(disk.Uri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualHardDisk interface (if implemented) to customize the conversion
	var diskAsAny any = disk
	if augmentedDisk, ok := diskAsAny.(augmentConversionForVirtualHardDisk); ok {
		err := augmentedDisk.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualHardDisk_STATUS
// Describes the uri of a disk.
type VirtualHardDisk_STATUS struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Uri         *string                `json:"uri,omitempty"`
}

// AssignProperties_From_VirtualHardDisk_STATUS populates our VirtualHardDisk_STATUS from the provided source VirtualHardDisk_STATUS
func (disk *VirtualHardDisk_STATUS) AssignProperties_From_VirtualHardDisk_STATUS(source *v20220301s.VirtualHardDisk_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Uri
	disk.Uri = genruntime.ClonePointerToString(source.Uri)

	// Update the property bag
	if len(propertyBag) > 0 {
		disk.PropertyBag = propertyBag
	} else {
		disk.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualHardDisk_STATUS interface (if implemented) to customize the conversion
	var diskAsAny any = disk
	if augmentedDisk, ok := diskAsAny.(augmentConversionForVirtualHardDisk_STATUS); ok {
		err := augmentedDisk.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualHardDisk_STATUS populates the provided destination VirtualHardDisk_STATUS from our VirtualHardDisk_STATUS
func (disk *VirtualHardDisk_STATUS) AssignProperties_To_VirtualHardDisk_STATUS(destination *v20220301s.VirtualHardDisk_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(disk.PropertyBag)

	// Uri
	destination.Uri = genruntime.ClonePointerToString(disk.Uri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualHardDisk_STATUS interface (if implemented) to customize the conversion
	var diskAsAny any = disk
	if augmentedDisk, ok := diskAsAny.(augmentConversionForVirtualHardDisk_STATUS); ok {
		err := augmentedDisk.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineExtensionHandlerInstanceView_STATUS
// The instance view of a virtual machine extension handler.
type VirtualMachineExtensionHandlerInstanceView_STATUS struct {
	PropertyBag        genruntime.PropertyBag     `json:"$propertyBag,omitempty"`
	Status             *InstanceViewStatus_STATUS `json:"status,omitempty"`
	Type               *string                    `json:"type,omitempty"`
	TypeHandlerVersion *string                    `json:"typeHandlerVersion,omitempty"`
}

// AssignProperties_From_VirtualMachineExtensionHandlerInstanceView_STATUS populates our VirtualMachineExtensionHandlerInstanceView_STATUS from the provided source VirtualMachineExtensionHandlerInstanceView_STATUS
func (view *VirtualMachineExtensionHandlerInstanceView_STATUS) AssignProperties_From_VirtualMachineExtensionHandlerInstanceView_STATUS(source *v20220301s.VirtualMachineExtensionHandlerInstanceView_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Status
	if source.Status != nil {
		var status InstanceViewStatus_STATUS
		err := status.AssignProperties_From_InstanceViewStatus_STATUS(source.Status)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_InstanceViewStatus_STATUS() to populate field Status")
		}
		view.Status = &status
	} else {
		view.Status = nil
	}

	// Type
	view.Type = genruntime.ClonePointerToString(source.Type)

	// TypeHandlerVersion
	view.TypeHandlerVersion = genruntime.ClonePointerToString(source.TypeHandlerVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		view.PropertyBag = propertyBag
	} else {
		view.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineExtensionHandlerInstanceView_STATUS interface (if implemented) to customize the conversion
	var viewAsAny any = view
	if augmentedView, ok := viewAsAny.(augmentConversionForVirtualMachineExtensionHandlerInstanceView_STATUS); ok {
		err := augmentedView.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineExtensionHandlerInstanceView_STATUS populates the provided destination VirtualMachineExtensionHandlerInstanceView_STATUS from our VirtualMachineExtensionHandlerInstanceView_STATUS
func (view *VirtualMachineExtensionHandlerInstanceView_STATUS) AssignProperties_To_VirtualMachineExtensionHandlerInstanceView_STATUS(destination *v20220301s.VirtualMachineExtensionHandlerInstanceView_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(view.PropertyBag)

	// Status
	if view.Status != nil {
		var status v20220301s.InstanceViewStatus_STATUS
		err := view.Status.AssignProperties_To_InstanceViewStatus_STATUS(&status)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_InstanceViewStatus_STATUS() to populate field Status")
		}
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(view.Type)

	// TypeHandlerVersion
	destination.TypeHandlerVersion = genruntime.ClonePointerToString(view.TypeHandlerVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineExtensionHandlerInstanceView_STATUS interface (if implemented) to customize the conversion
	var viewAsAny any = view
	if augmentedView, ok := viewAsAny.(augmentConversionForVirtualMachineExtensionHandlerInstanceView_STATUS); ok {
		err := augmentedView.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.WinRMConfiguration
// Describes Windows Remote Management configuration of the VM
type WinRMConfiguration struct {
	Listeners   []WinRMListener        `json:"listeners,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_WinRMConfiguration populates our WinRMConfiguration from the provided source WinRMConfiguration
func (configuration *WinRMConfiguration) AssignProperties_From_WinRMConfiguration(source *v20220301s.WinRMConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Listeners
	if source.Listeners != nil {
		listenerList := make([]WinRMListener, len(source.Listeners))
		for listenerIndex, listenerItem := range source.Listeners {
			// Shadow the loop variable to avoid aliasing
			listenerItem := listenerItem
			var listener WinRMListener
			err := listener.AssignProperties_From_WinRMListener(&listenerItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_WinRMListener() to populate field Listeners")
			}
			listenerList[listenerIndex] = listener
		}
		configuration.Listeners = listenerList
	} else {
		configuration.Listeners = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForWinRMConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForWinRMConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_WinRMConfiguration populates the provided destination WinRMConfiguration from our WinRMConfiguration
func (configuration *WinRMConfiguration) AssignProperties_To_WinRMConfiguration(destination *v20220301s.WinRMConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// Listeners
	if configuration.Listeners != nil {
		listenerList := make([]v20220301s.WinRMListener, len(configuration.Listeners))
		for listenerIndex, listenerItem := range configuration.Listeners {
			// Shadow the loop variable to avoid aliasing
			listenerItem := listenerItem
			var listener v20220301s.WinRMListener
			err := listenerItem.AssignProperties_To_WinRMListener(&listener)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_WinRMListener() to populate field Listeners")
			}
			listenerList[listenerIndex] = listener
		}
		destination.Listeners = listenerList
	} else {
		destination.Listeners = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForWinRMConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForWinRMConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.WinRMConfiguration_STATUS
// Describes Windows Remote Management configuration of the VM
type WinRMConfiguration_STATUS struct {
	Listeners   []WinRMListener_STATUS `json:"listeners,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_WinRMConfiguration_STATUS populates our WinRMConfiguration_STATUS from the provided source WinRMConfiguration_STATUS
func (configuration *WinRMConfiguration_STATUS) AssignProperties_From_WinRMConfiguration_STATUS(source *v20220301s.WinRMConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Listeners
	if source.Listeners != nil {
		listenerList := make([]WinRMListener_STATUS, len(source.Listeners))
		for listenerIndex, listenerItem := range source.Listeners {
			// Shadow the loop variable to avoid aliasing
			listenerItem := listenerItem
			var listener WinRMListener_STATUS
			err := listener.AssignProperties_From_WinRMListener_STATUS(&listenerItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_WinRMListener_STATUS() to populate field Listeners")
			}
			listenerList[listenerIndex] = listener
		}
		configuration.Listeners = listenerList
	} else {
		configuration.Listeners = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForWinRMConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForWinRMConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_WinRMConfiguration_STATUS populates the provided destination WinRMConfiguration_STATUS from our WinRMConfiguration_STATUS
func (configuration *WinRMConfiguration_STATUS) AssignProperties_To_WinRMConfiguration_STATUS(destination *v20220301s.WinRMConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// Listeners
	if configuration.Listeners != nil {
		listenerList := make([]v20220301s.WinRMListener_STATUS, len(configuration.Listeners))
		for listenerIndex, listenerItem := range configuration.Listeners {
			// Shadow the loop variable to avoid aliasing
			listenerItem := listenerItem
			var listener v20220301s.WinRMListener_STATUS
			err := listenerItem.AssignProperties_To_WinRMListener_STATUS(&listener)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_WinRMListener_STATUS() to populate field Listeners")
			}
			listenerList[listenerIndex] = listener
		}
		destination.Listeners = listenerList
	} else {
		destination.Listeners = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForWinRMConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForWinRMConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.ApiError_STATUS
// Api error.
type ApiError_STATUS struct {
	Code        *string                `json:"code,omitempty"`
	Details     []ApiErrorBase_STATUS  `json:"details,omitempty"`
	Innererror  *InnerError_STATUS     `json:"innererror,omitempty"`
	Message     *string                `json:"message,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Target      *string                `json:"target,omitempty"`
}

// AssignProperties_From_ApiError_STATUS populates our ApiError_STATUS from the provided source ApiError_STATUS
func (error *ApiError_STATUS) AssignProperties_From_ApiError_STATUS(source *v20220301s.ApiError_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Code
	error.Code = genruntime.ClonePointerToString(source.Code)

	// Details
	if source.Details != nil {
		detailList := make([]ApiErrorBase_STATUS, len(source.Details))
		for detailIndex, detailItem := range source.Details {
			// Shadow the loop variable to avoid aliasing
			detailItem := detailItem
			var detail ApiErrorBase_STATUS
			err := detail.AssignProperties_From_ApiErrorBase_STATUS(&detailItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApiErrorBase_STATUS() to populate field Details")
			}
			detailList[detailIndex] = detail
		}
		error.Details = detailList
	} else {
		error.Details = nil
	}

	// Innererror
	if source.Innererror != nil {
		var innererror InnerError_STATUS
		err := innererror.AssignProperties_From_InnerError_STATUS(source.Innererror)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_InnerError_STATUS() to populate field Innererror")
		}
		error.Innererror = &innererror
	} else {
		error.Innererror = nil
	}

	// Message
	error.Message = genruntime.ClonePointerToString(source.Message)

	// Target
	error.Target = genruntime.ClonePointerToString(source.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		error.PropertyBag = propertyBag
	} else {
		error.PropertyBag = nil
	}

	// Invoke the augmentConversionForApiError_STATUS interface (if implemented) to customize the conversion
	var errorAsAny any = error
	if augmentedError, ok := errorAsAny.(augmentConversionForApiError_STATUS); ok {
		err := augmentedError.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ApiError_STATUS populates the provided destination ApiError_STATUS from our ApiError_STATUS
func (error *ApiError_STATUS) AssignProperties_To_ApiError_STATUS(destination *v20220301s.ApiError_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(error.PropertyBag)

	// Code
	destination.Code = genruntime.ClonePointerToString(error.Code)

	// Details
	if error.Details != nil {
		detailList := make([]v20220301s.ApiErrorBase_STATUS, len(error.Details))
		for detailIndex, detailItem := range error.Details {
			// Shadow the loop variable to avoid aliasing
			detailItem := detailItem
			var detail v20220301s.ApiErrorBase_STATUS
			err := detailItem.AssignProperties_To_ApiErrorBase_STATUS(&detail)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApiErrorBase_STATUS() to populate field Details")
			}
			detailList[detailIndex] = detail
		}
		destination.Details = detailList
	} else {
		destination.Details = nil
	}

	// Innererror
	if error.Innererror != nil {
		var innererror v20220301s.InnerError_STATUS
		err := error.Innererror.AssignProperties_To_InnerError_STATUS(&innererror)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_InnerError_STATUS() to populate field Innererror")
		}
		destination.Innererror = &innererror
	} else {
		destination.Innererror = nil
	}

	// Message
	destination.Message = genruntime.ClonePointerToString(error.Message)

	// Target
	destination.Target = genruntime.ClonePointerToString(error.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForApiError_STATUS interface (if implemented) to customize the conversion
	var errorAsAny any = error
	if augmentedError, ok := errorAsAny.(augmentConversionForApiError_STATUS); ok {
		err := augmentedError.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForAdditionalUnattendContent interface {
	AssignPropertiesFrom(src *v20220301s.AdditionalUnattendContent) error
	AssignPropertiesTo(dst *v20220301s.AdditionalUnattendContent) error
}

type augmentConversionForAdditionalUnattendContent_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.AdditionalUnattendContent_STATUS) error
	AssignPropertiesTo(dst *v20220301s.AdditionalUnattendContent_STATUS) error
}

type augmentConversionForAvailablePatchSummary_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.AvailablePatchSummary_STATUS) error
	AssignPropertiesTo(dst *v20220301s.AvailablePatchSummary_STATUS) error
}

type augmentConversionForDiffDiskSettings interface {
	AssignPropertiesFrom(src *v20220301s.DiffDiskSettings) error
	AssignPropertiesTo(dst *v20220301s.DiffDiskSettings) error
}

type augmentConversionForDiffDiskSettings_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.DiffDiskSettings_STATUS) error
	AssignPropertiesTo(dst *v20220301s.DiffDiskSettings_STATUS) error
}

type augmentConversionForDiskEncryptionSettings interface {
	AssignPropertiesFrom(src *v20220301s.DiskEncryptionSettings) error
	AssignPropertiesTo(dst *v20220301s.DiskEncryptionSettings) error
}

type augmentConversionForDiskEncryptionSettings_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.DiskEncryptionSettings_STATUS) error
	AssignPropertiesTo(dst *v20220301s.DiskEncryptionSettings_STATUS) error
}

type augmentConversionForLastPatchInstallationSummary_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.LastPatchInstallationSummary_STATUS) error
	AssignPropertiesTo(dst *v20220301s.LastPatchInstallationSummary_STATUS) error
}

type augmentConversionForLinuxPatchSettings interface {
	AssignPropertiesFrom(src *v20220301s.LinuxPatchSettings) error
	AssignPropertiesTo(dst *v20220301s.LinuxPatchSettings) error
}

type augmentConversionForLinuxPatchSettings_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.LinuxPatchSettings_STATUS) error
	AssignPropertiesTo(dst *v20220301s.LinuxPatchSettings_STATUS) error
}

type augmentConversionForManagedDiskParameters interface {
	AssignPropertiesFrom(src *v20220301s.ManagedDiskParameters) error
	AssignPropertiesTo(dst *v20220301s.ManagedDiskParameters) error
}

type augmentConversionForManagedDiskParameters_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.ManagedDiskParameters_STATUS) error
	AssignPropertiesTo(dst *v20220301s.ManagedDiskParameters_STATUS) error
}

type augmentConversionForPatchSettings interface {
	AssignPropertiesFrom(src *v20220301s.PatchSettings) error
	AssignPropertiesTo(dst *v20220301s.PatchSettings) error
}

type augmentConversionForPatchSettings_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.PatchSettings_STATUS) error
	AssignPropertiesTo(dst *v20220301s.PatchSettings_STATUS) error
}

type augmentConversionForSshConfiguration interface {
	AssignPropertiesFrom(src *v20220301s.SshConfiguration) error
	AssignPropertiesTo(dst *v20220301s.SshConfiguration) error
}

type augmentConversionForSshConfiguration_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.SshConfiguration_STATUS) error
	AssignPropertiesTo(dst *v20220301s.SshConfiguration_STATUS) error
}

type augmentConversionForVaultCertificate interface {
	AssignPropertiesFrom(src *v20220301s.VaultCertificate) error
	AssignPropertiesTo(dst *v20220301s.VaultCertificate) error
}

type augmentConversionForVaultCertificate_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VaultCertificate_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VaultCertificate_STATUS) error
}

type augmentConversionForVirtualHardDisk interface {
	AssignPropertiesFrom(src *v20220301s.VirtualHardDisk) error
	AssignPropertiesTo(dst *v20220301s.VirtualHardDisk) error
}

type augmentConversionForVirtualHardDisk_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VirtualHardDisk_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VirtualHardDisk_STATUS) error
}

type augmentConversionForVirtualMachineExtensionHandlerInstanceView_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineExtensionHandlerInstanceView_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineExtensionHandlerInstanceView_STATUS) error
}

type augmentConversionForWinRMConfiguration interface {
	AssignPropertiesFrom(src *v20220301s.WinRMConfiguration) error
	AssignPropertiesTo(dst *v20220301s.WinRMConfiguration) error
}

type augmentConversionForWinRMConfiguration_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.WinRMConfiguration_STATUS) error
	AssignPropertiesTo(dst *v20220301s.WinRMConfiguration_STATUS) error
}

// Storage version of v1api20201201.KeyVaultKeyReference
// Describes a reference to Key Vault Key
type KeyVaultKeyReference struct {
	KeyUrl      *string                `json:"keyUrl,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SourceVault *SubResource           `json:"sourceVault,omitempty"`
}

// AssignProperties_From_KeyVaultKeyReference populates our KeyVaultKeyReference from the provided source KeyVaultKeyReference
func (reference *KeyVaultKeyReference) AssignProperties_From_KeyVaultKeyReference(source *v20220301s.KeyVaultKeyReference) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// KeyUrl
	reference.KeyUrl = genruntime.ClonePointerToString(source.KeyUrl)

	// SourceVault
	if source.SourceVault != nil {
		var subResourceStash v20210701s.SubResource
		err := subResourceStash.AssignProperties_From_SubResource(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from SourceVault")
		}
		var sourceVault SubResource
		err = sourceVault.AssignProperties_From_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SourceVault from SubResourceStash")
		}
		reference.SourceVault = &sourceVault
	} else {
		reference.SourceVault = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		reference.PropertyBag = propertyBag
	} else {
		reference.PropertyBag = nil
	}

	// Invoke the augmentConversionForKeyVaultKeyReference interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForKeyVaultKeyReference); ok {
		err := augmentedReference.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_KeyVaultKeyReference populates the provided destination KeyVaultKeyReference from our KeyVaultKeyReference
func (reference *KeyVaultKeyReference) AssignProperties_To_KeyVaultKeyReference(destination *v20220301s.KeyVaultKeyReference) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(reference.PropertyBag)

	// KeyUrl
	destination.KeyUrl = genruntime.ClonePointerToString(reference.KeyUrl)

	// SourceVault
	if reference.SourceVault != nil {
		var subResourceStash v20210701s.SubResource
		err := reference.SourceVault.AssignProperties_To_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from SourceVault")
		}
		var sourceVault v20220301s.SubResource
		err = subResourceStash.AssignProperties_To_SubResource(&sourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SourceVault from SubResourceStash")
		}
		destination.SourceVault = &sourceVault
	} else {
		destination.SourceVault = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForKeyVaultKeyReference interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForKeyVaultKeyReference); ok {
		err := augmentedReference.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.KeyVaultKeyReference_STATUS
// Describes a reference to Key Vault Key
type KeyVaultKeyReference_STATUS struct {
	KeyUrl      *string                `json:"keyUrl,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SourceVault *SubResource_STATUS    `json:"sourceVault,omitempty"`
}

// AssignProperties_From_KeyVaultKeyReference_STATUS populates our KeyVaultKeyReference_STATUS from the provided source KeyVaultKeyReference_STATUS
func (reference *KeyVaultKeyReference_STATUS) AssignProperties_From_KeyVaultKeyReference_STATUS(source *v20220301s.KeyVaultKeyReference_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// KeyUrl
	reference.KeyUrl = genruntime.ClonePointerToString(source.KeyUrl)

	// SourceVault
	if source.SourceVault != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from SourceVault")
		}
		var sourceVault SubResource_STATUS
		err = sourceVault.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SourceVault from SubResource_STATUSStash")
		}
		reference.SourceVault = &sourceVault
	} else {
		reference.SourceVault = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		reference.PropertyBag = propertyBag
	} else {
		reference.PropertyBag = nil
	}

	// Invoke the augmentConversionForKeyVaultKeyReference_STATUS interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForKeyVaultKeyReference_STATUS); ok {
		err := augmentedReference.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_KeyVaultKeyReference_STATUS populates the provided destination KeyVaultKeyReference_STATUS from our KeyVaultKeyReference_STATUS
func (reference *KeyVaultKeyReference_STATUS) AssignProperties_To_KeyVaultKeyReference_STATUS(destination *v20220301s.KeyVaultKeyReference_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(reference.PropertyBag)

	// KeyUrl
	destination.KeyUrl = genruntime.ClonePointerToString(reference.KeyUrl)

	// SourceVault
	if reference.SourceVault != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := reference.SourceVault.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from SourceVault")
		}
		var sourceVault v20220301s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&sourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SourceVault from SubResource_STATUSStash")
		}
		destination.SourceVault = &sourceVault
	} else {
		destination.SourceVault = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForKeyVaultKeyReference_STATUS interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForKeyVaultKeyReference_STATUS); ok {
		err := augmentedReference.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.KeyVaultSecretReference
// Describes a reference to Key Vault Secret
type KeyVaultSecretReference struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SecretUrl   *string                `json:"secretUrl,omitempty"`
	SourceVault *SubResource           `json:"sourceVault,omitempty"`
}

// AssignProperties_From_KeyVaultSecretReference populates our KeyVaultSecretReference from the provided source KeyVaultSecretReference
func (reference *KeyVaultSecretReference) AssignProperties_From_KeyVaultSecretReference(source *v20220301s.KeyVaultSecretReference) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// SecretUrl
	reference.SecretUrl = genruntime.ClonePointerToString(source.SecretUrl)

	// SourceVault
	if source.SourceVault != nil {
		var subResourceStash v20210701s.SubResource
		err := subResourceStash.AssignProperties_From_SubResource(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from SourceVault")
		}
		var sourceVault SubResource
		err = sourceVault.AssignProperties_From_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SourceVault from SubResourceStash")
		}
		reference.SourceVault = &sourceVault
	} else {
		reference.SourceVault = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		reference.PropertyBag = propertyBag
	} else {
		reference.PropertyBag = nil
	}

	// Invoke the augmentConversionForKeyVaultSecretReference interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForKeyVaultSecretReference); ok {
		err := augmentedReference.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_KeyVaultSecretReference populates the provided destination KeyVaultSecretReference from our KeyVaultSecretReference
func (reference *KeyVaultSecretReference) AssignProperties_To_KeyVaultSecretReference(destination *v20220301s.KeyVaultSecretReference) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(reference.PropertyBag)

	// SecretUrl
	destination.SecretUrl = genruntime.ClonePointerToString(reference.SecretUrl)

	// SourceVault
	if reference.SourceVault != nil {
		var subResourceStash v20210701s.SubResource
		err := reference.SourceVault.AssignProperties_To_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from SourceVault")
		}
		var sourceVault v20220301s.SubResource
		err = subResourceStash.AssignProperties_To_SubResource(&sourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SourceVault from SubResourceStash")
		}
		destination.SourceVault = &sourceVault
	} else {
		destination.SourceVault = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForKeyVaultSecretReference interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForKeyVaultSecretReference); ok {
		err := augmentedReference.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.KeyVaultSecretReference_STATUS
// Describes a reference to Key Vault Secret
type KeyVaultSecretReference_STATUS struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SecretUrl   *string                `json:"secretUrl,omitempty"`
	SourceVault *SubResource_STATUS    `json:"sourceVault,omitempty"`
}

// AssignProperties_From_KeyVaultSecretReference_STATUS populates our KeyVaultSecretReference_STATUS from the provided source KeyVaultSecretReference_STATUS
func (reference *KeyVaultSecretReference_STATUS) AssignProperties_From_KeyVaultSecretReference_STATUS(source *v20220301s.KeyVaultSecretReference_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// SecretUrl
	reference.SecretUrl = genruntime.ClonePointerToString(source.SecretUrl)

	// SourceVault
	if source.SourceVault != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from SourceVault")
		}
		var sourceVault SubResource_STATUS
		err = sourceVault.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SourceVault from SubResource_STATUSStash")
		}
		reference.SourceVault = &sourceVault
	} else {
		reference.SourceVault = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		reference.PropertyBag = propertyBag
	} else {
		reference.PropertyBag = nil
	}

	// Invoke the augmentConversionForKeyVaultSecretReference_STATUS interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForKeyVaultSecretReference_STATUS); ok {
		err := augmentedReference.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_KeyVaultSecretReference_STATUS populates the provided destination KeyVaultSecretReference_STATUS from our KeyVaultSecretReference_STATUS
func (reference *KeyVaultSecretReference_STATUS) AssignProperties_To_KeyVaultSecretReference_STATUS(destination *v20220301s.KeyVaultSecretReference_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(reference.PropertyBag)

	// SecretUrl
	destination.SecretUrl = genruntime.ClonePointerToString(reference.SecretUrl)

	// SourceVault
	if reference.SourceVault != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := reference.SourceVault.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from SourceVault")
		}
		var sourceVault v20220301s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&sourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SourceVault from SubResource_STATUSStash")
		}
		destination.SourceVault = &sourceVault
	} else {
		destination.SourceVault = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForKeyVaultSecretReference_STATUS interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForKeyVaultSecretReference_STATUS); ok {
		err := augmentedReference.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.SshPublicKey_STATUS
// Contains information about SSH certificate public key and the path on the Linux VM where the public key is placed.
type SshPublicKey_STATUS struct {
	KeyData     *string                `json:"keyData,omitempty"`
	Path        *string                `json:"path,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_SshPublicKey_STATUS populates our SshPublicKey_STATUS from the provided source SshPublicKey_STATUS
func (publicKey *SshPublicKey_STATUS) AssignProperties_From_SshPublicKey_STATUS(source *v20220301s.SshPublicKey_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// KeyData
	publicKey.KeyData = genruntime.ClonePointerToString(source.KeyData)

	// Path
	publicKey.Path = genruntime.ClonePointerToString(source.Path)

	// Update the property bag
	if len(propertyBag) > 0 {
		publicKey.PropertyBag = propertyBag
	} else {
		publicKey.PropertyBag = nil
	}

	// Invoke the augmentConversionForSshPublicKey_STATUS interface (if implemented) to customize the conversion
	var publicKeyAsAny any = publicKey
	if augmentedPublicKey, ok := publicKeyAsAny.(augmentConversionForSshPublicKey_STATUS); ok {
		err := augmentedPublicKey.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_SshPublicKey_STATUS populates the provided destination SshPublicKey_STATUS from our SshPublicKey_STATUS
func (publicKey *SshPublicKey_STATUS) AssignProperties_To_SshPublicKey_STATUS(destination *v20220301s.SshPublicKey_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(publicKey.PropertyBag)

	// KeyData
	destination.KeyData = genruntime.ClonePointerToString(publicKey.KeyData)

	// Path
	destination.Path = genruntime.ClonePointerToString(publicKey.Path)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSshPublicKey_STATUS interface (if implemented) to customize the conversion
	var publicKeyAsAny any = publicKey
	if augmentedPublicKey, ok := publicKeyAsAny.(augmentConversionForSshPublicKey_STATUS); ok {
		err := augmentedPublicKey.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.SshPublicKeySpec
// Contains information about SSH certificate public key and the path on the Linux VM where the public key is placed.
type SshPublicKeySpec struct {
	KeyData     *string                `json:"keyData,omitempty"`
	Path        *string                `json:"path,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_SshPublicKeySpec populates our SshPublicKeySpec from the provided source SshPublicKeySpec
func (publicKey *SshPublicKeySpec) AssignProperties_From_SshPublicKeySpec(source *v20220301s.SshPublicKeySpec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// KeyData
	publicKey.KeyData = genruntime.ClonePointerToString(source.KeyData)

	// Path
	publicKey.Path = genruntime.ClonePointerToString(source.Path)

	// Update the property bag
	if len(propertyBag) > 0 {
		publicKey.PropertyBag = propertyBag
	} else {
		publicKey.PropertyBag = nil
	}

	// Invoke the augmentConversionForSshPublicKeySpec interface (if implemented) to customize the conversion
	var publicKeyAsAny any = publicKey
	if augmentedPublicKey, ok := publicKeyAsAny.(augmentConversionForSshPublicKeySpec); ok {
		err := augmentedPublicKey.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_SshPublicKeySpec populates the provided destination SshPublicKeySpec from our SshPublicKeySpec
func (publicKey *SshPublicKeySpec) AssignProperties_To_SshPublicKeySpec(destination *v20220301s.SshPublicKeySpec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(publicKey.PropertyBag)

	// KeyData
	destination.KeyData = genruntime.ClonePointerToString(publicKey.KeyData)

	// Path
	destination.Path = genruntime.ClonePointerToString(publicKey.Path)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSshPublicKeySpec interface (if implemented) to customize the conversion
	var publicKeyAsAny any = publicKey
	if augmentedPublicKey, ok := publicKeyAsAny.(augmentConversionForSshPublicKeySpec); ok {
		err := augmentedPublicKey.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.WinRMListener
// Describes Protocol and thumbprint of Windows Remote Management listener
type WinRMListener struct {
	CertificateUrl *string                `json:"certificateUrl,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Protocol       *string                `json:"protocol,omitempty"`
}

// AssignProperties_From_WinRMListener populates our WinRMListener from the provided source WinRMListener
func (listener *WinRMListener) AssignProperties_From_WinRMListener(source *v20220301s.WinRMListener) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CertificateUrl
	listener.CertificateUrl = genruntime.ClonePointerToString(source.CertificateUrl)

	// Protocol
	listener.Protocol = genruntime.ClonePointerToString(source.Protocol)

	// Update the property bag
	if len(propertyBag) > 0 {
		listener.PropertyBag = propertyBag
	} else {
		listener.PropertyBag = nil
	}

	// Invoke the augmentConversionForWinRMListener interface (if implemented) to customize the conversion
	var listenerAsAny any = listener
	if augmentedListener, ok := listenerAsAny.(augmentConversionForWinRMListener); ok {
		err := augmentedListener.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_WinRMListener populates the provided destination WinRMListener from our WinRMListener
func (listener *WinRMListener) AssignProperties_To_WinRMListener(destination *v20220301s.WinRMListener) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(listener.PropertyBag)

	// CertificateUrl
	destination.CertificateUrl = genruntime.ClonePointerToString(listener.CertificateUrl)

	// Protocol
	destination.Protocol = genruntime.ClonePointerToString(listener.Protocol)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForWinRMListener interface (if implemented) to customize the conversion
	var listenerAsAny any = listener
	if augmentedListener, ok := listenerAsAny.(augmentConversionForWinRMListener); ok {
		err := augmentedListener.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.WinRMListener_STATUS
// Describes Protocol and thumbprint of Windows Remote Management listener
type WinRMListener_STATUS struct {
	CertificateUrl *string                `json:"certificateUrl,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Protocol       *string                `json:"protocol,omitempty"`
}

// AssignProperties_From_WinRMListener_STATUS populates our WinRMListener_STATUS from the provided source WinRMListener_STATUS
func (listener *WinRMListener_STATUS) AssignProperties_From_WinRMListener_STATUS(source *v20220301s.WinRMListener_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CertificateUrl
	listener.CertificateUrl = genruntime.ClonePointerToString(source.CertificateUrl)

	// Protocol
	listener.Protocol = genruntime.ClonePointerToString(source.Protocol)

	// Update the property bag
	if len(propertyBag) > 0 {
		listener.PropertyBag = propertyBag
	} else {
		listener.PropertyBag = nil
	}

	// Invoke the augmentConversionForWinRMListener_STATUS interface (if implemented) to customize the conversion
	var listenerAsAny any = listener
	if augmentedListener, ok := listenerAsAny.(augmentConversionForWinRMListener_STATUS); ok {
		err := augmentedListener.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_WinRMListener_STATUS populates the provided destination WinRMListener_STATUS from our WinRMListener_STATUS
func (listener *WinRMListener_STATUS) AssignProperties_To_WinRMListener_STATUS(destination *v20220301s.WinRMListener_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(listener.PropertyBag)

	// CertificateUrl
	destination.CertificateUrl = genruntime.ClonePointerToString(listener.CertificateUrl)

	// Protocol
	destination.Protocol = genruntime.ClonePointerToString(listener.Protocol)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForWinRMListener_STATUS interface (if implemented) to customize the conversion
	var listenerAsAny any = listener
	if augmentedListener, ok := listenerAsAny.(augmentConversionForWinRMListener_STATUS); ok {
		err := augmentedListener.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.ApiErrorBase_STATUS
// Api error base.
type ApiErrorBase_STATUS struct {
	Code        *string                `json:"code,omitempty"`
	Message     *string                `json:"message,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Target      *string                `json:"target,omitempty"`
}

// AssignProperties_From_ApiErrorBase_STATUS populates our ApiErrorBase_STATUS from the provided source ApiErrorBase_STATUS
func (base *ApiErrorBase_STATUS) AssignProperties_From_ApiErrorBase_STATUS(source *v20220301s.ApiErrorBase_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Code
	base.Code = genruntime.ClonePointerToString(source.Code)

	// Message
	base.Message = genruntime.ClonePointerToString(source.Message)

	// Target
	base.Target = genruntime.ClonePointerToString(source.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		base.PropertyBag = propertyBag
	} else {
		base.PropertyBag = nil
	}

	// Invoke the augmentConversionForApiErrorBase_STATUS interface (if implemented) to customize the conversion
	var baseAsAny any = base
	if augmentedBase, ok := baseAsAny.(augmentConversionForApiErrorBase_STATUS); ok {
		err := augmentedBase.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ApiErrorBase_STATUS populates the provided destination ApiErrorBase_STATUS from our ApiErrorBase_STATUS
func (base *ApiErrorBase_STATUS) AssignProperties_To_ApiErrorBase_STATUS(destination *v20220301s.ApiErrorBase_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(base.PropertyBag)

	// Code
	destination.Code = genruntime.ClonePointerToString(base.Code)

	// Message
	destination.Message = genruntime.ClonePointerToString(base.Message)

	// Target
	destination.Target = genruntime.ClonePointerToString(base.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForApiErrorBase_STATUS interface (if implemented) to customize the conversion
	var baseAsAny any = base
	if augmentedBase, ok := baseAsAny.(augmentConversionForApiErrorBase_STATUS); ok {
		err := augmentedBase.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForApiError_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.ApiError_STATUS) error
	AssignPropertiesTo(dst *v20220301s.ApiError_STATUS) error
}

type augmentConversionForKeyVaultKeyReference interface {
	AssignPropertiesFrom(src *v20220301s.KeyVaultKeyReference) error
	AssignPropertiesTo(dst *v20220301s.KeyVaultKeyReference) error
}

type augmentConversionForKeyVaultKeyReference_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.KeyVaultKeyReference_STATUS) error
	AssignPropertiesTo(dst *v20220301s.KeyVaultKeyReference_STATUS) error
}

type augmentConversionForKeyVaultSecretReference interface {
	AssignPropertiesFrom(src *v20220301s.KeyVaultSecretReference) error
	AssignPropertiesTo(dst *v20220301s.KeyVaultSecretReference) error
}

type augmentConversionForKeyVaultSecretReference_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.KeyVaultSecretReference_STATUS) error
	AssignPropertiesTo(dst *v20220301s.KeyVaultSecretReference_STATUS) error
}

type augmentConversionForSshPublicKey_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.SshPublicKey_STATUS) error
	AssignPropertiesTo(dst *v20220301s.SshPublicKey_STATUS) error
}

type augmentConversionForSshPublicKeySpec interface {
	AssignPropertiesFrom(src *v20220301s.SshPublicKeySpec) error
	AssignPropertiesTo(dst *v20220301s.SshPublicKeySpec) error
}

type augmentConversionForWinRMListener interface {
	AssignPropertiesFrom(src *v20220301s.WinRMListener) error
	AssignPropertiesTo(dst *v20220301s.WinRMListener) error
}

type augmentConversionForWinRMListener_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.WinRMListener_STATUS) error
	AssignPropertiesTo(dst *v20220301s.WinRMListener_STATUS) error
}

// Storage version of v1api20201201.InnerError_STATUS
// Inner error details.
type InnerError_STATUS struct {
	Errordetail   *string                `json:"errordetail,omitempty"`
	Exceptiontype *string                `json:"exceptiontype,omitempty"`
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_InnerError_STATUS populates our InnerError_STATUS from the provided source InnerError_STATUS
func (error *InnerError_STATUS) AssignProperties_From_InnerError_STATUS(source *v20220301s.InnerError_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Errordetail
	error.Errordetail = genruntime.ClonePointerToString(source.Errordetail)

	// Exceptiontype
	error.Exceptiontype = genruntime.ClonePointerToString(source.Exceptiontype)

	// Update the property bag
	if len(propertyBag) > 0 {
		error.PropertyBag = propertyBag
	} else {
		error.PropertyBag = nil
	}

	// Invoke the augmentConversionForInnerError_STATUS interface (if implemented) to customize the conversion
	var errorAsAny any = error
	if augmentedError, ok := errorAsAny.(augmentConversionForInnerError_STATUS); ok {
		err := augmentedError.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_InnerError_STATUS populates the provided destination InnerError_STATUS from our InnerError_STATUS
func (error *InnerError_STATUS) AssignProperties_To_InnerError_STATUS(destination *v20220301s.InnerError_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(error.PropertyBag)

	// Errordetail
	destination.Errordetail = genruntime.ClonePointerToString(error.Errordetail)

	// Exceptiontype
	destination.Exceptiontype = genruntime.ClonePointerToString(error.Exceptiontype)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForInnerError_STATUS interface (if implemented) to customize the conversion
	var errorAsAny any = error
	if augmentedError, ok := errorAsAny.(augmentConversionForInnerError_STATUS); ok {
		err := augmentedError.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForApiErrorBase_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.ApiErrorBase_STATUS) error
	AssignPropertiesTo(dst *v20220301s.ApiErrorBase_STATUS) error
}

type augmentConversionForInnerError_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.InnerError_STATUS) error
	AssignPropertiesTo(dst *v20220301s.InnerError_STATUS) error
}

func init() {
	SchemeBuilder.Register(&VirtualMachine{}, &VirtualMachineList{})
}
