// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20240401

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/machinelearningservices/v1api20240401/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/machinelearningservices/v1api20240401/storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /machinelearningservices/resource-manager/Microsoft.MachineLearningServices/stable/2024-04-01/workspaceRP.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/connections/{connectionName}
type WorkspacesConnection struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              WorkspacesConnection_Spec   `json:"spec,omitempty"`
	Status            WorkspacesConnection_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &WorkspacesConnection{}

// GetConditions returns the conditions of the resource
func (connection *WorkspacesConnection) GetConditions() conditions.Conditions {
	return connection.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (connection *WorkspacesConnection) SetConditions(conditions conditions.Conditions) {
	connection.Status.Conditions = conditions
}

var _ conversion.Convertible = &WorkspacesConnection{}

// ConvertFrom populates our WorkspacesConnection from the provided hub WorkspacesConnection
func (connection *WorkspacesConnection) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.WorkspacesConnection)
	if !ok {
		return fmt.Errorf("expected machinelearningservices/v1api20240401/storage/WorkspacesConnection but received %T instead", hub)
	}

	return connection.AssignProperties_From_WorkspacesConnection(source)
}

// ConvertTo populates the provided hub WorkspacesConnection from our WorkspacesConnection
func (connection *WorkspacesConnection) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.WorkspacesConnection)
	if !ok {
		return fmt.Errorf("expected machinelearningservices/v1api20240401/storage/WorkspacesConnection but received %T instead", hub)
	}

	return connection.AssignProperties_To_WorkspacesConnection(destination)
}

// +kubebuilder:webhook:path=/mutate-machinelearningservices-azure-com-v1api20240401-workspacesconnection,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=machinelearningservices.azure.com,resources=workspacesconnections,verbs=create;update,versions=v1api20240401,name=default.v1api20240401.workspacesconnections.machinelearningservices.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &WorkspacesConnection{}

// Default applies defaults to the WorkspacesConnection resource
func (connection *WorkspacesConnection) Default() {
	connection.defaultImpl()
	var temp any = connection
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (connection *WorkspacesConnection) defaultAzureName() {
	if connection.Spec.AzureName == "" {
		connection.Spec.AzureName = connection.Name
	}
}

// defaultImpl applies the code generated defaults to the WorkspacesConnection resource
func (connection *WorkspacesConnection) defaultImpl() { connection.defaultAzureName() }

var _ configmaps.Exporter = &WorkspacesConnection{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (connection *WorkspacesConnection) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if connection.Spec.OperatorSpec == nil {
		return nil
	}
	return connection.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &WorkspacesConnection{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (connection *WorkspacesConnection) SecretDestinationExpressions() []*core.DestinationExpression {
	if connection.Spec.OperatorSpec == nil {
		return nil
	}
	return connection.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &WorkspacesConnection{}

// InitializeSpec initializes the spec for this resource from the given status
func (connection *WorkspacesConnection) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*WorkspacesConnection_STATUS); ok {
		return connection.Spec.Initialize_From_WorkspacesConnection_STATUS(s)
	}

	return fmt.Errorf("expected Status of type WorkspacesConnection_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &WorkspacesConnection{}

// AzureName returns the Azure name of the resource
func (connection *WorkspacesConnection) AzureName() string {
	return connection.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2024-04-01"
func (connection WorkspacesConnection) GetAPIVersion() string {
	return "2024-04-01"
}

// GetResourceScope returns the scope of the resource
func (connection *WorkspacesConnection) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (connection *WorkspacesConnection) GetSpec() genruntime.ConvertibleSpec {
	return &connection.Spec
}

// GetStatus returns the status of this resource
func (connection *WorkspacesConnection) GetStatus() genruntime.ConvertibleStatus {
	return &connection.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (connection *WorkspacesConnection) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.MachineLearningServices/workspaces/connections"
func (connection *WorkspacesConnection) GetType() string {
	return "Microsoft.MachineLearningServices/workspaces/connections"
}

// NewEmptyStatus returns a new empty (blank) status
func (connection *WorkspacesConnection) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &WorkspacesConnection_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (connection *WorkspacesConnection) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(connection.Spec)
	return connection.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (connection *WorkspacesConnection) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*WorkspacesConnection_STATUS); ok {
		connection.Status = *st
		return nil
	}

	// Convert status to required version
	var st WorkspacesConnection_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	connection.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-machinelearningservices-azure-com-v1api20240401-workspacesconnection,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=machinelearningservices.azure.com,resources=workspacesconnections,verbs=create;update,versions=v1api20240401,name=validate.v1api20240401.workspacesconnections.machinelearningservices.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &WorkspacesConnection{}

// ValidateCreate validates the creation of the resource
func (connection *WorkspacesConnection) ValidateCreate() (admission.Warnings, error) {
	validations := connection.createValidations()
	var temp any = connection
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	return genruntime.ValidateCreate(validations)
}

// ValidateDelete validates the deletion of the resource
func (connection *WorkspacesConnection) ValidateDelete() (admission.Warnings, error) {
	validations := connection.deleteValidations()
	var temp any = connection
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	return genruntime.ValidateDelete(validations)
}

// ValidateUpdate validates an update of the resource
func (connection *WorkspacesConnection) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	validations := connection.updateValidations()
	var temp any = connection
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	return genruntime.ValidateUpdate(old, validations)
}

// createValidations validates the creation of the resource
func (connection *WorkspacesConnection) createValidations() []func() (admission.Warnings, error) {
	return []func() (admission.Warnings, error){connection.validateResourceReferences, connection.validateOwnerReference, connection.validateSecretDestinations, connection.validateConfigMapDestinations, connection.validateOptionalConfigMapReferences}
}

// deleteValidations validates the deletion of the resource
func (connection *WorkspacesConnection) deleteValidations() []func() (admission.Warnings, error) {
	return nil
}

// updateValidations validates the update of the resource
func (connection *WorkspacesConnection) updateValidations() []func(old runtime.Object) (admission.Warnings, error) {
	return []func(old runtime.Object) (admission.Warnings, error){
		func(old runtime.Object) (admission.Warnings, error) {
			return connection.validateResourceReferences()
		},
		connection.validateWriteOnceProperties,
		func(old runtime.Object) (admission.Warnings, error) {
			return connection.validateOwnerReference()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return connection.validateSecretDestinations()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return connection.validateConfigMapDestinations()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return connection.validateOptionalConfigMapReferences()
		},
	}
}

// validateConfigMapDestinations validates there are no colliding genruntime.ConfigMapDestinations
func (connection *WorkspacesConnection) validateConfigMapDestinations() (admission.Warnings, error) {
	if connection.Spec.OperatorSpec == nil {
		return nil, nil
	}
	return configmaps.ValidateDestinations(connection, nil, connection.Spec.OperatorSpec.ConfigMapExpressions)
}

// validateOptionalConfigMapReferences validates all optional configmap reference pairs to ensure that at most 1 is set
func (connection *WorkspacesConnection) validateOptionalConfigMapReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindOptionalConfigMapReferences(&connection.Spec)
	if err != nil {
		return nil, err
	}
	return configmaps.ValidateOptionalReferences(refs)
}

// validateOwnerReference validates the owner field
func (connection *WorkspacesConnection) validateOwnerReference() (admission.Warnings, error) {
	return genruntime.ValidateOwner(connection)
}

// validateResourceReferences validates all resource references
func (connection *WorkspacesConnection) validateResourceReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindResourceReferences(&connection.Spec)
	if err != nil {
		return nil, err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateSecretDestinations validates there are no colliding genruntime.SecretDestination's
func (connection *WorkspacesConnection) validateSecretDestinations() (admission.Warnings, error) {
	if connection.Spec.OperatorSpec == nil {
		return nil, nil
	}
	return secrets.ValidateDestinations(connection, nil, connection.Spec.OperatorSpec.SecretExpressions)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (connection *WorkspacesConnection) validateWriteOnceProperties(old runtime.Object) (admission.Warnings, error) {
	oldObj, ok := old.(*WorkspacesConnection)
	if !ok {
		return nil, nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, connection)
}

// AssignProperties_From_WorkspacesConnection populates our WorkspacesConnection from the provided source WorkspacesConnection
func (connection *WorkspacesConnection) AssignProperties_From_WorkspacesConnection(source *storage.WorkspacesConnection) error {

	// ObjectMeta
	connection.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec WorkspacesConnection_Spec
	err := spec.AssignProperties_From_WorkspacesConnection_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_WorkspacesConnection_Spec() to populate field Spec")
	}
	connection.Spec = spec

	// Status
	var status WorkspacesConnection_STATUS
	err = status.AssignProperties_From_WorkspacesConnection_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_WorkspacesConnection_STATUS() to populate field Status")
	}
	connection.Status = status

	// No error
	return nil
}

// AssignProperties_To_WorkspacesConnection populates the provided destination WorkspacesConnection from our WorkspacesConnection
func (connection *WorkspacesConnection) AssignProperties_To_WorkspacesConnection(destination *storage.WorkspacesConnection) error {

	// ObjectMeta
	destination.ObjectMeta = *connection.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.WorkspacesConnection_Spec
	err := connection.Spec.AssignProperties_To_WorkspacesConnection_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_WorkspacesConnection_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.WorkspacesConnection_STATUS
	err = connection.Status.AssignProperties_To_WorkspacesConnection_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_WorkspacesConnection_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (connection *WorkspacesConnection) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: connection.Spec.OriginalVersion(),
		Kind:    "WorkspacesConnection",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /machinelearningservices/resource-manager/Microsoft.MachineLearningServices/stable/2024-04-01/workspaceRP.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/connections/{connectionName}
type WorkspacesConnectionList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []WorkspacesConnection `json:"items"`
}

type WorkspacesConnection_Spec struct {
	// +kubebuilder:validation:Pattern="^[a-zA-Z0-9][a-zA-Z0-9_-]{2,32}$"
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *WorkspacesConnectionOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a machinelearningservices.azure.com/Workspace resource
	Owner *genruntime.KnownResourceReference `group:"machinelearningservices.azure.com" json:"owner,omitempty" kind:"Workspace"`

	// +kubebuilder:validation:Required
	Properties *WorkspaceConnectionPropertiesV2 `json:"properties,omitempty"`
}

var _ genruntime.ARMTransformer = &WorkspacesConnection_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (connection *WorkspacesConnection_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if connection == nil {
		return nil, nil
	}
	result := &arm.WorkspacesConnection_Spec{}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if connection.Properties != nil {
		properties_ARM, err := (*connection.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*arm.WorkspaceConnectionPropertiesV2)
		result.Properties = &properties
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (connection *WorkspacesConnection_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspacesConnection_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (connection *WorkspacesConnection_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspacesConnection_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspacesConnection_Spec, got %T", armInput)
	}

	// Set property "AzureName":
	connection.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	connection.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 WorkspaceConnectionPropertiesV2
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		connection.Properties = &properties
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &WorkspacesConnection_Spec{}

// ConvertSpecFrom populates our WorkspacesConnection_Spec from the provided source
func (connection *WorkspacesConnection_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.WorkspacesConnection_Spec)
	if ok {
		// Populate our instance from source
		return connection.AssignProperties_From_WorkspacesConnection_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.WorkspacesConnection_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = connection.AssignProperties_From_WorkspacesConnection_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our WorkspacesConnection_Spec
func (connection *WorkspacesConnection_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.WorkspacesConnection_Spec)
	if ok {
		// Populate destination from our instance
		return connection.AssignProperties_To_WorkspacesConnection_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.WorkspacesConnection_Spec{}
	err := connection.AssignProperties_To_WorkspacesConnection_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_WorkspacesConnection_Spec populates our WorkspacesConnection_Spec from the provided source WorkspacesConnection_Spec
func (connection *WorkspacesConnection_Spec) AssignProperties_From_WorkspacesConnection_Spec(source *storage.WorkspacesConnection_Spec) error {

	// AzureName
	connection.AzureName = source.AzureName

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec WorkspacesConnectionOperatorSpec
		err := operatorSpec.AssignProperties_From_WorkspacesConnectionOperatorSpec(source.OperatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WorkspacesConnectionOperatorSpec() to populate field OperatorSpec")
		}
		connection.OperatorSpec = &operatorSpec
	} else {
		connection.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		connection.Owner = &owner
	} else {
		connection.Owner = nil
	}

	// Properties
	if source.Properties != nil {
		var property WorkspaceConnectionPropertiesV2
		err := property.AssignProperties_From_WorkspaceConnectionPropertiesV2(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WorkspaceConnectionPropertiesV2() to populate field Properties")
		}
		connection.Properties = &property
	} else {
		connection.Properties = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WorkspacesConnection_Spec populates the provided destination WorkspacesConnection_Spec from our WorkspacesConnection_Spec
func (connection *WorkspacesConnection_Spec) AssignProperties_To_WorkspacesConnection_Spec(destination *storage.WorkspacesConnection_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = connection.AzureName

	// OperatorSpec
	if connection.OperatorSpec != nil {
		var operatorSpec storage.WorkspacesConnectionOperatorSpec
		err := connection.OperatorSpec.AssignProperties_To_WorkspacesConnectionOperatorSpec(&operatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WorkspacesConnectionOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = connection.OriginalVersion()

	// Owner
	if connection.Owner != nil {
		owner := connection.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Properties
	if connection.Properties != nil {
		var property storage.WorkspaceConnectionPropertiesV2
		err := connection.Properties.AssignProperties_To_WorkspaceConnectionPropertiesV2(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WorkspaceConnectionPropertiesV2() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_WorkspacesConnection_STATUS populates our WorkspacesConnection_Spec from the provided source WorkspacesConnection_STATUS
func (connection *WorkspacesConnection_Spec) Initialize_From_WorkspacesConnection_STATUS(source *WorkspacesConnection_STATUS) error {

	// Properties
	if source.Properties != nil {
		var property WorkspaceConnectionPropertiesV2
		err := property.Initialize_From_WorkspaceConnectionPropertiesV2_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_WorkspaceConnectionPropertiesV2_STATUS() to populate field Properties")
		}
		connection.Properties = &property
	} else {
		connection.Properties = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (connection *WorkspacesConnection_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (connection *WorkspacesConnection_Spec) SetAzureName(azureName string) {
	connection.AzureName = azureName
}

type WorkspacesConnection_STATUS struct {
	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// Id: Fully qualified resource ID for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`

	// Name: The name of the resource
	Name       *string                                 `json:"name,omitempty"`
	Properties *WorkspaceConnectionPropertiesV2_STATUS `json:"properties,omitempty"`

	// SystemData: Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData_STATUS `json:"systemData,omitempty"`

	// Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &WorkspacesConnection_STATUS{}

// ConvertStatusFrom populates our WorkspacesConnection_STATUS from the provided source
func (connection *WorkspacesConnection_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.WorkspacesConnection_STATUS)
	if ok {
		// Populate our instance from source
		return connection.AssignProperties_From_WorkspacesConnection_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.WorkspacesConnection_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = connection.AssignProperties_From_WorkspacesConnection_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our WorkspacesConnection_STATUS
func (connection *WorkspacesConnection_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.WorkspacesConnection_STATUS)
	if ok {
		// Populate destination from our instance
		return connection.AssignProperties_To_WorkspacesConnection_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.WorkspacesConnection_STATUS{}
	err := connection.AssignProperties_To_WorkspacesConnection_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &WorkspacesConnection_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (connection *WorkspacesConnection_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspacesConnection_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (connection *WorkspacesConnection_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspacesConnection_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspacesConnection_STATUS, got %T", armInput)
	}

	// no assignment for property "Conditions"

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		connection.Id = &id
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		connection.Name = &name
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 WorkspaceConnectionPropertiesV2_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		connection.Properties = &properties
	}

	// Set property "SystemData":
	if typedInput.SystemData != nil {
		var systemData1 SystemData_STATUS
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		connection.SystemData = &systemData
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		connection.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_WorkspacesConnection_STATUS populates our WorkspacesConnection_STATUS from the provided source WorkspacesConnection_STATUS
func (connection *WorkspacesConnection_STATUS) AssignProperties_From_WorkspacesConnection_STATUS(source *storage.WorkspacesConnection_STATUS) error {

	// Conditions
	connection.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// Id
	connection.Id = genruntime.ClonePointerToString(source.Id)

	// Name
	connection.Name = genruntime.ClonePointerToString(source.Name)

	// Properties
	if source.Properties != nil {
		var property WorkspaceConnectionPropertiesV2_STATUS
		err := property.AssignProperties_From_WorkspaceConnectionPropertiesV2_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WorkspaceConnectionPropertiesV2_STATUS() to populate field Properties")
		}
		connection.Properties = &property
	} else {
		connection.Properties = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		connection.SystemData = &systemDatum
	} else {
		connection.SystemData = nil
	}

	// Type
	connection.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_WorkspacesConnection_STATUS populates the provided destination WorkspacesConnection_STATUS from our WorkspacesConnection_STATUS
func (connection *WorkspacesConnection_STATUS) AssignProperties_To_WorkspacesConnection_STATUS(destination *storage.WorkspacesConnection_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(connection.Conditions)

	// Id
	destination.Id = genruntime.ClonePointerToString(connection.Id)

	// Name
	destination.Name = genruntime.ClonePointerToString(connection.Name)

	// Properties
	if connection.Properties != nil {
		var property storage.WorkspaceConnectionPropertiesV2_STATUS
		err := connection.Properties.AssignProperties_To_WorkspaceConnectionPropertiesV2_STATUS(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WorkspaceConnectionPropertiesV2_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// SystemData
	if connection.SystemData != nil {
		var systemDatum storage.SystemData_STATUS
		err := connection.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(connection.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type WorkspaceConnectionPropertiesV2 struct {
	// AAD: Mutually exclusive with all other properties
	AAD *AADAuthTypeWorkspaceConnectionProperties `json:"aad,omitempty"`

	// AccessKey: Mutually exclusive with all other properties
	AccessKey *AccessKeyAuthTypeWorkspaceConnectionProperties `json:"accessKey,omitempty"`

	// AccountKey: Mutually exclusive with all other properties
	AccountKey *AccountKeyAuthTypeWorkspaceConnectionProperties `json:"accountKey,omitempty"`

	// ApiKey: Mutually exclusive with all other properties
	ApiKey *ApiKeyAuthWorkspaceConnectionProperties `json:"apiKey,omitempty"`

	// CustomKeys: Mutually exclusive with all other properties
	CustomKeys *CustomKeysWorkspaceConnectionProperties `json:"customKeys,omitempty"`

	// ManagedIdentity: Mutually exclusive with all other properties
	ManagedIdentity *ManagedIdentityAuthTypeWorkspaceConnectionProperties `json:"managedIdentity,omitempty"`

	// None: Mutually exclusive with all other properties
	None *NoneAuthTypeWorkspaceConnectionProperties `json:"none,omitempty"`

	// OAuth2: Mutually exclusive with all other properties
	OAuth2 *OAuth2AuthTypeWorkspaceConnectionProperties `json:"oAuth2,omitempty"`

	// PAT: Mutually exclusive with all other properties
	PAT *PATAuthTypeWorkspaceConnectionProperties `json:"pat,omitempty"`

	// SAS: Mutually exclusive with all other properties
	SAS *SASAuthTypeWorkspaceConnectionProperties `json:"sas,omitempty"`

	// ServicePrincipal: Mutually exclusive with all other properties
	ServicePrincipal *ServicePrincipalAuthTypeWorkspaceConnectionProperties `json:"servicePrincipal,omitempty"`

	// UsernamePassword: Mutually exclusive with all other properties
	UsernamePassword *UsernamePasswordAuthTypeWorkspaceConnectionProperties `json:"usernamePassword,omitempty"`
}

var _ genruntime.ARMTransformer = &WorkspaceConnectionPropertiesV2{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (v2 *WorkspaceConnectionPropertiesV2) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if v2 == nil {
		return nil, nil
	}
	result := &arm.WorkspaceConnectionPropertiesV2{}

	// Set property "AAD":
	if v2.AAD != nil {
		aad_ARM, err := (*v2.AAD).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		aad := *aad_ARM.(*arm.AADAuthTypeWorkspaceConnectionProperties)
		result.AAD = &aad
	}

	// Set property "AccessKey":
	if v2.AccessKey != nil {
		accessKey_ARM, err := (*v2.AccessKey).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		accessKey := *accessKey_ARM.(*arm.AccessKeyAuthTypeWorkspaceConnectionProperties)
		result.AccessKey = &accessKey
	}

	// Set property "AccountKey":
	if v2.AccountKey != nil {
		accountKey_ARM, err := (*v2.AccountKey).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		accountKey := *accountKey_ARM.(*arm.AccountKeyAuthTypeWorkspaceConnectionProperties)
		result.AccountKey = &accountKey
	}

	// Set property "ApiKey":
	if v2.ApiKey != nil {
		apiKey_ARM, err := (*v2.ApiKey).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		apiKey := *apiKey_ARM.(*arm.ApiKeyAuthWorkspaceConnectionProperties)
		result.ApiKey = &apiKey
	}

	// Set property "CustomKeys":
	if v2.CustomKeys != nil {
		customKeys_ARM, err := (*v2.CustomKeys).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		customKeys := *customKeys_ARM.(*arm.CustomKeysWorkspaceConnectionProperties)
		result.CustomKeys = &customKeys
	}

	// Set property "ManagedIdentity":
	if v2.ManagedIdentity != nil {
		managedIdentity_ARM, err := (*v2.ManagedIdentity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		managedIdentity := *managedIdentity_ARM.(*arm.ManagedIdentityAuthTypeWorkspaceConnectionProperties)
		result.ManagedIdentity = &managedIdentity
	}

	// Set property "None":
	if v2.None != nil {
		none_ARM, err := (*v2.None).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		none := *none_ARM.(*arm.NoneAuthTypeWorkspaceConnectionProperties)
		result.None = &none
	}

	// Set property "OAuth2":
	if v2.OAuth2 != nil {
		oAuth2_ARM, err := (*v2.OAuth2).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		oAuth2 := *oAuth2_ARM.(*arm.OAuth2AuthTypeWorkspaceConnectionProperties)
		result.OAuth2 = &oAuth2
	}

	// Set property "PAT":
	if v2.PAT != nil {
		pat_ARM, err := (*v2.PAT).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		pat := *pat_ARM.(*arm.PATAuthTypeWorkspaceConnectionProperties)
		result.PAT = &pat
	}

	// Set property "SAS":
	if v2.SAS != nil {
		sas_ARM, err := (*v2.SAS).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sas := *sas_ARM.(*arm.SASAuthTypeWorkspaceConnectionProperties)
		result.SAS = &sas
	}

	// Set property "ServicePrincipal":
	if v2.ServicePrincipal != nil {
		servicePrincipal_ARM, err := (*v2.ServicePrincipal).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		servicePrincipal := *servicePrincipal_ARM.(*arm.ServicePrincipalAuthTypeWorkspaceConnectionProperties)
		result.ServicePrincipal = &servicePrincipal
	}

	// Set property "UsernamePassword":
	if v2.UsernamePassword != nil {
		usernamePassword_ARM, err := (*v2.UsernamePassword).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		usernamePassword := *usernamePassword_ARM.(*arm.UsernamePasswordAuthTypeWorkspaceConnectionProperties)
		result.UsernamePassword = &usernamePassword
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (v2 *WorkspaceConnectionPropertiesV2) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceConnectionPropertiesV2{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (v2 *WorkspaceConnectionPropertiesV2) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspaceConnectionPropertiesV2)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceConnectionPropertiesV2, got %T", armInput)
	}

	// Set property "AAD":
	if typedInput.AAD != nil {
		var aad1 AADAuthTypeWorkspaceConnectionProperties
		err := aad1.PopulateFromARM(owner, *typedInput.AAD)
		if err != nil {
			return err
		}
		aad := aad1
		v2.AAD = &aad
	}

	// Set property "AccessKey":
	if typedInput.AccessKey != nil {
		var accessKey1 AccessKeyAuthTypeWorkspaceConnectionProperties
		err := accessKey1.PopulateFromARM(owner, *typedInput.AccessKey)
		if err != nil {
			return err
		}
		accessKey := accessKey1
		v2.AccessKey = &accessKey
	}

	// Set property "AccountKey":
	if typedInput.AccountKey != nil {
		var accountKey1 AccountKeyAuthTypeWorkspaceConnectionProperties
		err := accountKey1.PopulateFromARM(owner, *typedInput.AccountKey)
		if err != nil {
			return err
		}
		accountKey := accountKey1
		v2.AccountKey = &accountKey
	}

	// Set property "ApiKey":
	if typedInput.ApiKey != nil {
		var apiKey1 ApiKeyAuthWorkspaceConnectionProperties
		err := apiKey1.PopulateFromARM(owner, *typedInput.ApiKey)
		if err != nil {
			return err
		}
		apiKey := apiKey1
		v2.ApiKey = &apiKey
	}

	// Set property "CustomKeys":
	if typedInput.CustomKeys != nil {
		var customKeys1 CustomKeysWorkspaceConnectionProperties
		err := customKeys1.PopulateFromARM(owner, *typedInput.CustomKeys)
		if err != nil {
			return err
		}
		customKeys := customKeys1
		v2.CustomKeys = &customKeys
	}

	// Set property "ManagedIdentity":
	if typedInput.ManagedIdentity != nil {
		var managedIdentity1 ManagedIdentityAuthTypeWorkspaceConnectionProperties
		err := managedIdentity1.PopulateFromARM(owner, *typedInput.ManagedIdentity)
		if err != nil {
			return err
		}
		managedIdentity := managedIdentity1
		v2.ManagedIdentity = &managedIdentity
	}

	// Set property "None":
	if typedInput.None != nil {
		var none1 NoneAuthTypeWorkspaceConnectionProperties
		err := none1.PopulateFromARM(owner, *typedInput.None)
		if err != nil {
			return err
		}
		none := none1
		v2.None = &none
	}

	// Set property "OAuth2":
	if typedInput.OAuth2 != nil {
		var oAuth OAuth2AuthTypeWorkspaceConnectionProperties
		err := oAuth.PopulateFromARM(owner, *typedInput.OAuth2)
		if err != nil {
			return err
		}
		oAuth2 := oAuth
		v2.OAuth2 = &oAuth2
	}

	// Set property "PAT":
	if typedInput.PAT != nil {
		var pat1 PATAuthTypeWorkspaceConnectionProperties
		err := pat1.PopulateFromARM(owner, *typedInput.PAT)
		if err != nil {
			return err
		}
		pat := pat1
		v2.PAT = &pat
	}

	// Set property "SAS":
	if typedInput.SAS != nil {
		var sas1 SASAuthTypeWorkspaceConnectionProperties
		err := sas1.PopulateFromARM(owner, *typedInput.SAS)
		if err != nil {
			return err
		}
		sas := sas1
		v2.SAS = &sas
	}

	// Set property "ServicePrincipal":
	if typedInput.ServicePrincipal != nil {
		var servicePrincipal1 ServicePrincipalAuthTypeWorkspaceConnectionProperties
		err := servicePrincipal1.PopulateFromARM(owner, *typedInput.ServicePrincipal)
		if err != nil {
			return err
		}
		servicePrincipal := servicePrincipal1
		v2.ServicePrincipal = &servicePrincipal
	}

	// Set property "UsernamePassword":
	if typedInput.UsernamePassword != nil {
		var usernamePassword1 UsernamePasswordAuthTypeWorkspaceConnectionProperties
		err := usernamePassword1.PopulateFromARM(owner, *typedInput.UsernamePassword)
		if err != nil {
			return err
		}
		usernamePassword := usernamePassword1
		v2.UsernamePassword = &usernamePassword
	}

	// No error
	return nil
}

// AssignProperties_From_WorkspaceConnectionPropertiesV2 populates our WorkspaceConnectionPropertiesV2 from the provided source WorkspaceConnectionPropertiesV2
func (v2 *WorkspaceConnectionPropertiesV2) AssignProperties_From_WorkspaceConnectionPropertiesV2(source *storage.WorkspaceConnectionPropertiesV2) error {

	// AAD
	if source.AAD != nil {
		var aad AADAuthTypeWorkspaceConnectionProperties
		err := aad.AssignProperties_From_AADAuthTypeWorkspaceConnectionProperties(source.AAD)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AADAuthTypeWorkspaceConnectionProperties() to populate field AAD")
		}
		v2.AAD = &aad
	} else {
		v2.AAD = nil
	}

	// AccessKey
	if source.AccessKey != nil {
		var accessKey AccessKeyAuthTypeWorkspaceConnectionProperties
		err := accessKey.AssignProperties_From_AccessKeyAuthTypeWorkspaceConnectionProperties(source.AccessKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AccessKeyAuthTypeWorkspaceConnectionProperties() to populate field AccessKey")
		}
		v2.AccessKey = &accessKey
	} else {
		v2.AccessKey = nil
	}

	// AccountKey
	if source.AccountKey != nil {
		var accountKey AccountKeyAuthTypeWorkspaceConnectionProperties
		err := accountKey.AssignProperties_From_AccountKeyAuthTypeWorkspaceConnectionProperties(source.AccountKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AccountKeyAuthTypeWorkspaceConnectionProperties() to populate field AccountKey")
		}
		v2.AccountKey = &accountKey
	} else {
		v2.AccountKey = nil
	}

	// ApiKey
	if source.ApiKey != nil {
		var apiKey ApiKeyAuthWorkspaceConnectionProperties
		err := apiKey.AssignProperties_From_ApiKeyAuthWorkspaceConnectionProperties(source.ApiKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApiKeyAuthWorkspaceConnectionProperties() to populate field ApiKey")
		}
		v2.ApiKey = &apiKey
	} else {
		v2.ApiKey = nil
	}

	// CustomKeys
	if source.CustomKeys != nil {
		var customKey CustomKeysWorkspaceConnectionProperties
		err := customKey.AssignProperties_From_CustomKeysWorkspaceConnectionProperties(source.CustomKeys)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CustomKeysWorkspaceConnectionProperties() to populate field CustomKeys")
		}
		v2.CustomKeys = &customKey
	} else {
		v2.CustomKeys = nil
	}

	// ManagedIdentity
	if source.ManagedIdentity != nil {
		var managedIdentity ManagedIdentityAuthTypeWorkspaceConnectionProperties
		err := managedIdentity.AssignProperties_From_ManagedIdentityAuthTypeWorkspaceConnectionProperties(source.ManagedIdentity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedIdentityAuthTypeWorkspaceConnectionProperties() to populate field ManagedIdentity")
		}
		v2.ManagedIdentity = &managedIdentity
	} else {
		v2.ManagedIdentity = nil
	}

	// None
	if source.None != nil {
		var none NoneAuthTypeWorkspaceConnectionProperties
		err := none.AssignProperties_From_NoneAuthTypeWorkspaceConnectionProperties(source.None)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_NoneAuthTypeWorkspaceConnectionProperties() to populate field None")
		}
		v2.None = &none
	} else {
		v2.None = nil
	}

	// OAuth2
	if source.OAuth2 != nil {
		var oAuth2 OAuth2AuthTypeWorkspaceConnectionProperties
		err := oAuth2.AssignProperties_From_OAuth2AuthTypeWorkspaceConnectionProperties(source.OAuth2)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OAuth2AuthTypeWorkspaceConnectionProperties() to populate field OAuth2")
		}
		v2.OAuth2 = &oAuth2
	} else {
		v2.OAuth2 = nil
	}

	// PAT
	if source.PAT != nil {
		var pat PATAuthTypeWorkspaceConnectionProperties
		err := pat.AssignProperties_From_PATAuthTypeWorkspaceConnectionProperties(source.PAT)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PATAuthTypeWorkspaceConnectionProperties() to populate field PAT")
		}
		v2.PAT = &pat
	} else {
		v2.PAT = nil
	}

	// SAS
	if source.SAS != nil {
		var sas SASAuthTypeWorkspaceConnectionProperties
		err := sas.AssignProperties_From_SASAuthTypeWorkspaceConnectionProperties(source.SAS)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SASAuthTypeWorkspaceConnectionProperties() to populate field SAS")
		}
		v2.SAS = &sas
	} else {
		v2.SAS = nil
	}

	// ServicePrincipal
	if source.ServicePrincipal != nil {
		var servicePrincipal ServicePrincipalAuthTypeWorkspaceConnectionProperties
		err := servicePrincipal.AssignProperties_From_ServicePrincipalAuthTypeWorkspaceConnectionProperties(source.ServicePrincipal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ServicePrincipalAuthTypeWorkspaceConnectionProperties() to populate field ServicePrincipal")
		}
		v2.ServicePrincipal = &servicePrincipal
	} else {
		v2.ServicePrincipal = nil
	}

	// UsernamePassword
	if source.UsernamePassword != nil {
		var usernamePassword UsernamePasswordAuthTypeWorkspaceConnectionProperties
		err := usernamePassword.AssignProperties_From_UsernamePasswordAuthTypeWorkspaceConnectionProperties(source.UsernamePassword)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UsernamePasswordAuthTypeWorkspaceConnectionProperties() to populate field UsernamePassword")
		}
		v2.UsernamePassword = &usernamePassword
	} else {
		v2.UsernamePassword = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WorkspaceConnectionPropertiesV2 populates the provided destination WorkspaceConnectionPropertiesV2 from our WorkspaceConnectionPropertiesV2
func (v2 *WorkspaceConnectionPropertiesV2) AssignProperties_To_WorkspaceConnectionPropertiesV2(destination *storage.WorkspaceConnectionPropertiesV2) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AAD
	if v2.AAD != nil {
		var aad storage.AADAuthTypeWorkspaceConnectionProperties
		err := v2.AAD.AssignProperties_To_AADAuthTypeWorkspaceConnectionProperties(&aad)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AADAuthTypeWorkspaceConnectionProperties() to populate field AAD")
		}
		destination.AAD = &aad
	} else {
		destination.AAD = nil
	}

	// AccessKey
	if v2.AccessKey != nil {
		var accessKey storage.AccessKeyAuthTypeWorkspaceConnectionProperties
		err := v2.AccessKey.AssignProperties_To_AccessKeyAuthTypeWorkspaceConnectionProperties(&accessKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AccessKeyAuthTypeWorkspaceConnectionProperties() to populate field AccessKey")
		}
		destination.AccessKey = &accessKey
	} else {
		destination.AccessKey = nil
	}

	// AccountKey
	if v2.AccountKey != nil {
		var accountKey storage.AccountKeyAuthTypeWorkspaceConnectionProperties
		err := v2.AccountKey.AssignProperties_To_AccountKeyAuthTypeWorkspaceConnectionProperties(&accountKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AccountKeyAuthTypeWorkspaceConnectionProperties() to populate field AccountKey")
		}
		destination.AccountKey = &accountKey
	} else {
		destination.AccountKey = nil
	}

	// ApiKey
	if v2.ApiKey != nil {
		var apiKey storage.ApiKeyAuthWorkspaceConnectionProperties
		err := v2.ApiKey.AssignProperties_To_ApiKeyAuthWorkspaceConnectionProperties(&apiKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApiKeyAuthWorkspaceConnectionProperties() to populate field ApiKey")
		}
		destination.ApiKey = &apiKey
	} else {
		destination.ApiKey = nil
	}

	// CustomKeys
	if v2.CustomKeys != nil {
		var customKey storage.CustomKeysWorkspaceConnectionProperties
		err := v2.CustomKeys.AssignProperties_To_CustomKeysWorkspaceConnectionProperties(&customKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CustomKeysWorkspaceConnectionProperties() to populate field CustomKeys")
		}
		destination.CustomKeys = &customKey
	} else {
		destination.CustomKeys = nil
	}

	// ManagedIdentity
	if v2.ManagedIdentity != nil {
		var managedIdentity storage.ManagedIdentityAuthTypeWorkspaceConnectionProperties
		err := v2.ManagedIdentity.AssignProperties_To_ManagedIdentityAuthTypeWorkspaceConnectionProperties(&managedIdentity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedIdentityAuthTypeWorkspaceConnectionProperties() to populate field ManagedIdentity")
		}
		destination.ManagedIdentity = &managedIdentity
	} else {
		destination.ManagedIdentity = nil
	}

	// None
	if v2.None != nil {
		var none storage.NoneAuthTypeWorkspaceConnectionProperties
		err := v2.None.AssignProperties_To_NoneAuthTypeWorkspaceConnectionProperties(&none)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_NoneAuthTypeWorkspaceConnectionProperties() to populate field None")
		}
		destination.None = &none
	} else {
		destination.None = nil
	}

	// OAuth2
	if v2.OAuth2 != nil {
		var oAuth2 storage.OAuth2AuthTypeWorkspaceConnectionProperties
		err := v2.OAuth2.AssignProperties_To_OAuth2AuthTypeWorkspaceConnectionProperties(&oAuth2)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OAuth2AuthTypeWorkspaceConnectionProperties() to populate field OAuth2")
		}
		destination.OAuth2 = &oAuth2
	} else {
		destination.OAuth2 = nil
	}

	// PAT
	if v2.PAT != nil {
		var pat storage.PATAuthTypeWorkspaceConnectionProperties
		err := v2.PAT.AssignProperties_To_PATAuthTypeWorkspaceConnectionProperties(&pat)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PATAuthTypeWorkspaceConnectionProperties() to populate field PAT")
		}
		destination.PAT = &pat
	} else {
		destination.PAT = nil
	}

	// SAS
	if v2.SAS != nil {
		var sas storage.SASAuthTypeWorkspaceConnectionProperties
		err := v2.SAS.AssignProperties_To_SASAuthTypeWorkspaceConnectionProperties(&sas)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SASAuthTypeWorkspaceConnectionProperties() to populate field SAS")
		}
		destination.SAS = &sas
	} else {
		destination.SAS = nil
	}

	// ServicePrincipal
	if v2.ServicePrincipal != nil {
		var servicePrincipal storage.ServicePrincipalAuthTypeWorkspaceConnectionProperties
		err := v2.ServicePrincipal.AssignProperties_To_ServicePrincipalAuthTypeWorkspaceConnectionProperties(&servicePrincipal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ServicePrincipalAuthTypeWorkspaceConnectionProperties() to populate field ServicePrincipal")
		}
		destination.ServicePrincipal = &servicePrincipal
	} else {
		destination.ServicePrincipal = nil
	}

	// UsernamePassword
	if v2.UsernamePassword != nil {
		var usernamePassword storage.UsernamePasswordAuthTypeWorkspaceConnectionProperties
		err := v2.UsernamePassword.AssignProperties_To_UsernamePasswordAuthTypeWorkspaceConnectionProperties(&usernamePassword)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UsernamePasswordAuthTypeWorkspaceConnectionProperties() to populate field UsernamePassword")
		}
		destination.UsernamePassword = &usernamePassword
	} else {
		destination.UsernamePassword = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_WorkspaceConnectionPropertiesV2_STATUS populates our WorkspaceConnectionPropertiesV2 from the provided source WorkspaceConnectionPropertiesV2_STATUS
func (v2 *WorkspaceConnectionPropertiesV2) Initialize_From_WorkspaceConnectionPropertiesV2_STATUS(source *WorkspaceConnectionPropertiesV2_STATUS) error {

	// AAD
	if source.AAD != nil {
		var aad AADAuthTypeWorkspaceConnectionProperties
		err := aad.Initialize_From_AADAuthTypeWorkspaceConnectionProperties_STATUS(source.AAD)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_AADAuthTypeWorkspaceConnectionProperties_STATUS() to populate field AAD")
		}
		v2.AAD = &aad
	} else {
		v2.AAD = nil
	}

	// AccessKey
	if source.AccessKey != nil {
		var accessKey AccessKeyAuthTypeWorkspaceConnectionProperties
		err := accessKey.Initialize_From_AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS(source.AccessKey)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS() to populate field AccessKey")
		}
		v2.AccessKey = &accessKey
	} else {
		v2.AccessKey = nil
	}

	// AccountKey
	if source.AccountKey != nil {
		var accountKey AccountKeyAuthTypeWorkspaceConnectionProperties
		err := accountKey.Initialize_From_AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS(source.AccountKey)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS() to populate field AccountKey")
		}
		v2.AccountKey = &accountKey
	} else {
		v2.AccountKey = nil
	}

	// ApiKey
	if source.ApiKey != nil {
		var apiKey ApiKeyAuthWorkspaceConnectionProperties
		err := apiKey.Initialize_From_ApiKeyAuthWorkspaceConnectionProperties_STATUS(source.ApiKey)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ApiKeyAuthWorkspaceConnectionProperties_STATUS() to populate field ApiKey")
		}
		v2.ApiKey = &apiKey
	} else {
		v2.ApiKey = nil
	}

	// CustomKeys
	if source.CustomKeys != nil {
		var customKey CustomKeysWorkspaceConnectionProperties
		err := customKey.Initialize_From_CustomKeysWorkspaceConnectionProperties_STATUS(source.CustomKeys)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_CustomKeysWorkspaceConnectionProperties_STATUS() to populate field CustomKeys")
		}
		v2.CustomKeys = &customKey
	} else {
		v2.CustomKeys = nil
	}

	// ManagedIdentity
	if source.ManagedIdentity != nil {
		var managedIdentity ManagedIdentityAuthTypeWorkspaceConnectionProperties
		err := managedIdentity.Initialize_From_ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS(source.ManagedIdentity)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS() to populate field ManagedIdentity")
		}
		v2.ManagedIdentity = &managedIdentity
	} else {
		v2.ManagedIdentity = nil
	}

	// None
	if source.None != nil {
		var none NoneAuthTypeWorkspaceConnectionProperties
		err := none.Initialize_From_NoneAuthTypeWorkspaceConnectionProperties_STATUS(source.None)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_NoneAuthTypeWorkspaceConnectionProperties_STATUS() to populate field None")
		}
		v2.None = &none
	} else {
		v2.None = nil
	}

	// OAuth2
	if source.OAuth2 != nil {
		var oAuth2 OAuth2AuthTypeWorkspaceConnectionProperties
		err := oAuth2.Initialize_From_OAuth2AuthTypeWorkspaceConnectionProperties_STATUS(source.OAuth2)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_OAuth2AuthTypeWorkspaceConnectionProperties_STATUS() to populate field OAuth2")
		}
		v2.OAuth2 = &oAuth2
	} else {
		v2.OAuth2 = nil
	}

	// PAT
	if source.PAT != nil {
		var pat PATAuthTypeWorkspaceConnectionProperties
		err := pat.Initialize_From_PATAuthTypeWorkspaceConnectionProperties_STATUS(source.PAT)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_PATAuthTypeWorkspaceConnectionProperties_STATUS() to populate field PAT")
		}
		v2.PAT = &pat
	} else {
		v2.PAT = nil
	}

	// SAS
	if source.SAS != nil {
		var sas SASAuthTypeWorkspaceConnectionProperties
		err := sas.Initialize_From_SASAuthTypeWorkspaceConnectionProperties_STATUS(source.SAS)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SASAuthTypeWorkspaceConnectionProperties_STATUS() to populate field SAS")
		}
		v2.SAS = &sas
	} else {
		v2.SAS = nil
	}

	// ServicePrincipal
	if source.ServicePrincipal != nil {
		var servicePrincipal ServicePrincipalAuthTypeWorkspaceConnectionProperties
		err := servicePrincipal.Initialize_From_ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS(source.ServicePrincipal)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS() to populate field ServicePrincipal")
		}
		v2.ServicePrincipal = &servicePrincipal
	} else {
		v2.ServicePrincipal = nil
	}

	// UsernamePassword
	if source.UsernamePassword != nil {
		var usernamePassword UsernamePasswordAuthTypeWorkspaceConnectionProperties
		err := usernamePassword.Initialize_From_UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS(source.UsernamePassword)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS() to populate field UsernamePassword")
		}
		v2.UsernamePassword = &usernamePassword
	} else {
		v2.UsernamePassword = nil
	}

	// No error
	return nil
}

type WorkspaceConnectionPropertiesV2_STATUS struct {
	// AAD: Mutually exclusive with all other properties
	AAD *AADAuthTypeWorkspaceConnectionProperties_STATUS `json:"aad,omitempty"`

	// AccessKey: Mutually exclusive with all other properties
	AccessKey *AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS `json:"accessKey,omitempty"`

	// AccountKey: Mutually exclusive with all other properties
	AccountKey *AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS `json:"accountKey,omitempty"`

	// ApiKey: Mutually exclusive with all other properties
	ApiKey *ApiKeyAuthWorkspaceConnectionProperties_STATUS `json:"apiKey,omitempty"`

	// CustomKeys: Mutually exclusive with all other properties
	CustomKeys *CustomKeysWorkspaceConnectionProperties_STATUS `json:"customKeys,omitempty"`

	// ManagedIdentity: Mutually exclusive with all other properties
	ManagedIdentity *ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS `json:"managedIdentity,omitempty"`

	// None: Mutually exclusive with all other properties
	None *NoneAuthTypeWorkspaceConnectionProperties_STATUS `json:"none,omitempty"`

	// OAuth2: Mutually exclusive with all other properties
	OAuth2 *OAuth2AuthTypeWorkspaceConnectionProperties_STATUS `json:"oAuth2,omitempty"`

	// PAT: Mutually exclusive with all other properties
	PAT *PATAuthTypeWorkspaceConnectionProperties_STATUS `json:"pat,omitempty"`

	// SAS: Mutually exclusive with all other properties
	SAS *SASAuthTypeWorkspaceConnectionProperties_STATUS `json:"sas,omitempty"`

	// ServicePrincipal: Mutually exclusive with all other properties
	ServicePrincipal *ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS `json:"servicePrincipal,omitempty"`

	// UsernamePassword: Mutually exclusive with all other properties
	UsernamePassword *UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS `json:"usernamePassword,omitempty"`
}

var _ genruntime.FromARMConverter = &WorkspaceConnectionPropertiesV2_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (v2 *WorkspaceConnectionPropertiesV2_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceConnectionPropertiesV2_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (v2 *WorkspaceConnectionPropertiesV2_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspaceConnectionPropertiesV2_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceConnectionPropertiesV2_STATUS, got %T", armInput)
	}

	// Set property "AAD":
	if typedInput.AAD != nil {
		var aad1 AADAuthTypeWorkspaceConnectionProperties_STATUS
		err := aad1.PopulateFromARM(owner, *typedInput.AAD)
		if err != nil {
			return err
		}
		aad := aad1
		v2.AAD = &aad
	}

	// Set property "AccessKey":
	if typedInput.AccessKey != nil {
		var accessKey1 AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS
		err := accessKey1.PopulateFromARM(owner, *typedInput.AccessKey)
		if err != nil {
			return err
		}
		accessKey := accessKey1
		v2.AccessKey = &accessKey
	}

	// Set property "AccountKey":
	if typedInput.AccountKey != nil {
		var accountKey1 AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS
		err := accountKey1.PopulateFromARM(owner, *typedInput.AccountKey)
		if err != nil {
			return err
		}
		accountKey := accountKey1
		v2.AccountKey = &accountKey
	}

	// Set property "ApiKey":
	if typedInput.ApiKey != nil {
		var apiKey1 ApiKeyAuthWorkspaceConnectionProperties_STATUS
		err := apiKey1.PopulateFromARM(owner, *typedInput.ApiKey)
		if err != nil {
			return err
		}
		apiKey := apiKey1
		v2.ApiKey = &apiKey
	}

	// Set property "CustomKeys":
	if typedInput.CustomKeys != nil {
		var customKeys1 CustomKeysWorkspaceConnectionProperties_STATUS
		err := customKeys1.PopulateFromARM(owner, *typedInput.CustomKeys)
		if err != nil {
			return err
		}
		customKeys := customKeys1
		v2.CustomKeys = &customKeys
	}

	// Set property "ManagedIdentity":
	if typedInput.ManagedIdentity != nil {
		var managedIdentity1 ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS
		err := managedIdentity1.PopulateFromARM(owner, *typedInput.ManagedIdentity)
		if err != nil {
			return err
		}
		managedIdentity := managedIdentity1
		v2.ManagedIdentity = &managedIdentity
	}

	// Set property "None":
	if typedInput.None != nil {
		var none1 NoneAuthTypeWorkspaceConnectionProperties_STATUS
		err := none1.PopulateFromARM(owner, *typedInput.None)
		if err != nil {
			return err
		}
		none := none1
		v2.None = &none
	}

	// Set property "OAuth2":
	if typedInput.OAuth2 != nil {
		var oAuth OAuth2AuthTypeWorkspaceConnectionProperties_STATUS
		err := oAuth.PopulateFromARM(owner, *typedInput.OAuth2)
		if err != nil {
			return err
		}
		oAuth2 := oAuth
		v2.OAuth2 = &oAuth2
	}

	// Set property "PAT":
	if typedInput.PAT != nil {
		var pat1 PATAuthTypeWorkspaceConnectionProperties_STATUS
		err := pat1.PopulateFromARM(owner, *typedInput.PAT)
		if err != nil {
			return err
		}
		pat := pat1
		v2.PAT = &pat
	}

	// Set property "SAS":
	if typedInput.SAS != nil {
		var sas1 SASAuthTypeWorkspaceConnectionProperties_STATUS
		err := sas1.PopulateFromARM(owner, *typedInput.SAS)
		if err != nil {
			return err
		}
		sas := sas1
		v2.SAS = &sas
	}

	// Set property "ServicePrincipal":
	if typedInput.ServicePrincipal != nil {
		var servicePrincipal1 ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS
		err := servicePrincipal1.PopulateFromARM(owner, *typedInput.ServicePrincipal)
		if err != nil {
			return err
		}
		servicePrincipal := servicePrincipal1
		v2.ServicePrincipal = &servicePrincipal
	}

	// Set property "UsernamePassword":
	if typedInput.UsernamePassword != nil {
		var usernamePassword1 UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS
		err := usernamePassword1.PopulateFromARM(owner, *typedInput.UsernamePassword)
		if err != nil {
			return err
		}
		usernamePassword := usernamePassword1
		v2.UsernamePassword = &usernamePassword
	}

	// No error
	return nil
}

// AssignProperties_From_WorkspaceConnectionPropertiesV2_STATUS populates our WorkspaceConnectionPropertiesV2_STATUS from the provided source WorkspaceConnectionPropertiesV2_STATUS
func (v2 *WorkspaceConnectionPropertiesV2_STATUS) AssignProperties_From_WorkspaceConnectionPropertiesV2_STATUS(source *storage.WorkspaceConnectionPropertiesV2_STATUS) error {

	// AAD
	if source.AAD != nil {
		var aad AADAuthTypeWorkspaceConnectionProperties_STATUS
		err := aad.AssignProperties_From_AADAuthTypeWorkspaceConnectionProperties_STATUS(source.AAD)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AADAuthTypeWorkspaceConnectionProperties_STATUS() to populate field AAD")
		}
		v2.AAD = &aad
	} else {
		v2.AAD = nil
	}

	// AccessKey
	if source.AccessKey != nil {
		var accessKey AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS
		err := accessKey.AssignProperties_From_AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS(source.AccessKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS() to populate field AccessKey")
		}
		v2.AccessKey = &accessKey
	} else {
		v2.AccessKey = nil
	}

	// AccountKey
	if source.AccountKey != nil {
		var accountKey AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS
		err := accountKey.AssignProperties_From_AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS(source.AccountKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS() to populate field AccountKey")
		}
		v2.AccountKey = &accountKey
	} else {
		v2.AccountKey = nil
	}

	// ApiKey
	if source.ApiKey != nil {
		var apiKey ApiKeyAuthWorkspaceConnectionProperties_STATUS
		err := apiKey.AssignProperties_From_ApiKeyAuthWorkspaceConnectionProperties_STATUS(source.ApiKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApiKeyAuthWorkspaceConnectionProperties_STATUS() to populate field ApiKey")
		}
		v2.ApiKey = &apiKey
	} else {
		v2.ApiKey = nil
	}

	// CustomKeys
	if source.CustomKeys != nil {
		var customKey CustomKeysWorkspaceConnectionProperties_STATUS
		err := customKey.AssignProperties_From_CustomKeysWorkspaceConnectionProperties_STATUS(source.CustomKeys)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CustomKeysWorkspaceConnectionProperties_STATUS() to populate field CustomKeys")
		}
		v2.CustomKeys = &customKey
	} else {
		v2.CustomKeys = nil
	}

	// ManagedIdentity
	if source.ManagedIdentity != nil {
		var managedIdentity ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS
		err := managedIdentity.AssignProperties_From_ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS(source.ManagedIdentity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS() to populate field ManagedIdentity")
		}
		v2.ManagedIdentity = &managedIdentity
	} else {
		v2.ManagedIdentity = nil
	}

	// None
	if source.None != nil {
		var none NoneAuthTypeWorkspaceConnectionProperties_STATUS
		err := none.AssignProperties_From_NoneAuthTypeWorkspaceConnectionProperties_STATUS(source.None)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_NoneAuthTypeWorkspaceConnectionProperties_STATUS() to populate field None")
		}
		v2.None = &none
	} else {
		v2.None = nil
	}

	// OAuth2
	if source.OAuth2 != nil {
		var oAuth2 OAuth2AuthTypeWorkspaceConnectionProperties_STATUS
		err := oAuth2.AssignProperties_From_OAuth2AuthTypeWorkspaceConnectionProperties_STATUS(source.OAuth2)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OAuth2AuthTypeWorkspaceConnectionProperties_STATUS() to populate field OAuth2")
		}
		v2.OAuth2 = &oAuth2
	} else {
		v2.OAuth2 = nil
	}

	// PAT
	if source.PAT != nil {
		var pat PATAuthTypeWorkspaceConnectionProperties_STATUS
		err := pat.AssignProperties_From_PATAuthTypeWorkspaceConnectionProperties_STATUS(source.PAT)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PATAuthTypeWorkspaceConnectionProperties_STATUS() to populate field PAT")
		}
		v2.PAT = &pat
	} else {
		v2.PAT = nil
	}

	// SAS
	if source.SAS != nil {
		var sas SASAuthTypeWorkspaceConnectionProperties_STATUS
		err := sas.AssignProperties_From_SASAuthTypeWorkspaceConnectionProperties_STATUS(source.SAS)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SASAuthTypeWorkspaceConnectionProperties_STATUS() to populate field SAS")
		}
		v2.SAS = &sas
	} else {
		v2.SAS = nil
	}

	// ServicePrincipal
	if source.ServicePrincipal != nil {
		var servicePrincipal ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS
		err := servicePrincipal.AssignProperties_From_ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS(source.ServicePrincipal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS() to populate field ServicePrincipal")
		}
		v2.ServicePrincipal = &servicePrincipal
	} else {
		v2.ServicePrincipal = nil
	}

	// UsernamePassword
	if source.UsernamePassword != nil {
		var usernamePassword UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS
		err := usernamePassword.AssignProperties_From_UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS(source.UsernamePassword)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS() to populate field UsernamePassword")
		}
		v2.UsernamePassword = &usernamePassword
	} else {
		v2.UsernamePassword = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WorkspaceConnectionPropertiesV2_STATUS populates the provided destination WorkspaceConnectionPropertiesV2_STATUS from our WorkspaceConnectionPropertiesV2_STATUS
func (v2 *WorkspaceConnectionPropertiesV2_STATUS) AssignProperties_To_WorkspaceConnectionPropertiesV2_STATUS(destination *storage.WorkspaceConnectionPropertiesV2_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AAD
	if v2.AAD != nil {
		var aad storage.AADAuthTypeWorkspaceConnectionProperties_STATUS
		err := v2.AAD.AssignProperties_To_AADAuthTypeWorkspaceConnectionProperties_STATUS(&aad)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AADAuthTypeWorkspaceConnectionProperties_STATUS() to populate field AAD")
		}
		destination.AAD = &aad
	} else {
		destination.AAD = nil
	}

	// AccessKey
	if v2.AccessKey != nil {
		var accessKey storage.AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS
		err := v2.AccessKey.AssignProperties_To_AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS(&accessKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS() to populate field AccessKey")
		}
		destination.AccessKey = &accessKey
	} else {
		destination.AccessKey = nil
	}

	// AccountKey
	if v2.AccountKey != nil {
		var accountKey storage.AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS
		err := v2.AccountKey.AssignProperties_To_AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS(&accountKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS() to populate field AccountKey")
		}
		destination.AccountKey = &accountKey
	} else {
		destination.AccountKey = nil
	}

	// ApiKey
	if v2.ApiKey != nil {
		var apiKey storage.ApiKeyAuthWorkspaceConnectionProperties_STATUS
		err := v2.ApiKey.AssignProperties_To_ApiKeyAuthWorkspaceConnectionProperties_STATUS(&apiKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApiKeyAuthWorkspaceConnectionProperties_STATUS() to populate field ApiKey")
		}
		destination.ApiKey = &apiKey
	} else {
		destination.ApiKey = nil
	}

	// CustomKeys
	if v2.CustomKeys != nil {
		var customKey storage.CustomKeysWorkspaceConnectionProperties_STATUS
		err := v2.CustomKeys.AssignProperties_To_CustomKeysWorkspaceConnectionProperties_STATUS(&customKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CustomKeysWorkspaceConnectionProperties_STATUS() to populate field CustomKeys")
		}
		destination.CustomKeys = &customKey
	} else {
		destination.CustomKeys = nil
	}

	// ManagedIdentity
	if v2.ManagedIdentity != nil {
		var managedIdentity storage.ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS
		err := v2.ManagedIdentity.AssignProperties_To_ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS(&managedIdentity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS() to populate field ManagedIdentity")
		}
		destination.ManagedIdentity = &managedIdentity
	} else {
		destination.ManagedIdentity = nil
	}

	// None
	if v2.None != nil {
		var none storage.NoneAuthTypeWorkspaceConnectionProperties_STATUS
		err := v2.None.AssignProperties_To_NoneAuthTypeWorkspaceConnectionProperties_STATUS(&none)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_NoneAuthTypeWorkspaceConnectionProperties_STATUS() to populate field None")
		}
		destination.None = &none
	} else {
		destination.None = nil
	}

	// OAuth2
	if v2.OAuth2 != nil {
		var oAuth2 storage.OAuth2AuthTypeWorkspaceConnectionProperties_STATUS
		err := v2.OAuth2.AssignProperties_To_OAuth2AuthTypeWorkspaceConnectionProperties_STATUS(&oAuth2)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OAuth2AuthTypeWorkspaceConnectionProperties_STATUS() to populate field OAuth2")
		}
		destination.OAuth2 = &oAuth2
	} else {
		destination.OAuth2 = nil
	}

	// PAT
	if v2.PAT != nil {
		var pat storage.PATAuthTypeWorkspaceConnectionProperties_STATUS
		err := v2.PAT.AssignProperties_To_PATAuthTypeWorkspaceConnectionProperties_STATUS(&pat)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PATAuthTypeWorkspaceConnectionProperties_STATUS() to populate field PAT")
		}
		destination.PAT = &pat
	} else {
		destination.PAT = nil
	}

	// SAS
	if v2.SAS != nil {
		var sas storage.SASAuthTypeWorkspaceConnectionProperties_STATUS
		err := v2.SAS.AssignProperties_To_SASAuthTypeWorkspaceConnectionProperties_STATUS(&sas)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SASAuthTypeWorkspaceConnectionProperties_STATUS() to populate field SAS")
		}
		destination.SAS = &sas
	} else {
		destination.SAS = nil
	}

	// ServicePrincipal
	if v2.ServicePrincipal != nil {
		var servicePrincipal storage.ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS
		err := v2.ServicePrincipal.AssignProperties_To_ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS(&servicePrincipal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS() to populate field ServicePrincipal")
		}
		destination.ServicePrincipal = &servicePrincipal
	} else {
		destination.ServicePrincipal = nil
	}

	// UsernamePassword
	if v2.UsernamePassword != nil {
		var usernamePassword storage.UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS
		err := v2.UsernamePassword.AssignProperties_To_UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS(&usernamePassword)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS() to populate field UsernamePassword")
		}
		destination.UsernamePassword = &usernamePassword
	} else {
		destination.UsernamePassword = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type WorkspacesConnectionOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_WorkspacesConnectionOperatorSpec populates our WorkspacesConnectionOperatorSpec from the provided source WorkspacesConnectionOperatorSpec
func (operator *WorkspacesConnectionOperatorSpec) AssignProperties_From_WorkspacesConnectionOperatorSpec(source *storage.WorkspacesConnectionOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WorkspacesConnectionOperatorSpec populates the provided destination WorkspacesConnectionOperatorSpec from our WorkspacesConnectionOperatorSpec
func (operator *WorkspacesConnectionOperatorSpec) AssignProperties_To_WorkspacesConnectionOperatorSpec(destination *storage.WorkspacesConnectionOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AADAuthTypeWorkspaceConnectionProperties struct {
	// +kubebuilder:validation:Required
	// AuthType: Authentication type of the connection target
	AuthType *AADAuthTypeWorkspaceConnectionProperties_AuthType `json:"authType,omitempty"`

	// Category: Category of the connection
	Category      *ConnectionCategory `json:"category,omitempty"`
	ExpiryTime    *string             `json:"expiryTime,omitempty"`
	IsSharedToAll *bool               `json:"isSharedToAll,omitempty"`

	// Metadata: Store user metadata for this connection
	Metadata       map[string]string `json:"metadata,omitempty"`
	SharedUserList []string          `json:"sharedUserList,omitempty"`
	Target         *string           `json:"target,omitempty"`

	// Value: Value details of the workspace connection.
	Value *string `json:"value,omitempty"`

	// ValueFormat: format for the workspace connection value
	ValueFormat *AADAuthTypeWorkspaceConnectionProperties_ValueFormat `json:"valueFormat,omitempty"`
}

var _ genruntime.ARMTransformer = &AADAuthTypeWorkspaceConnectionProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *AADAuthTypeWorkspaceConnectionProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.AADAuthTypeWorkspaceConnectionProperties{}

	// Set property "AuthType":
	if properties.AuthType != nil {
		var temp arm.AADAuthTypeWorkspaceConnectionProperties_AuthType
		var temp1 string
		temp1 = string(*properties.AuthType)
		temp = arm.AADAuthTypeWorkspaceConnectionProperties_AuthType(temp1)
		result.AuthType = temp
	}

	// Set property "Category":
	if properties.Category != nil {
		var temp string
		temp = string(*properties.Category)
		category := arm.ConnectionCategory(temp)
		result.Category = &category
	}

	// Set property "ExpiryTime":
	if properties.ExpiryTime != nil {
		expiryTime := *properties.ExpiryTime
		result.ExpiryTime = &expiryTime
	}

	// Set property "IsSharedToAll":
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		result.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if properties.Metadata != nil {
		result.Metadata = make(map[string]string, len(properties.Metadata))
		for key, value := range properties.Metadata {
			result.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range properties.SharedUserList {
		result.SharedUserList = append(result.SharedUserList, item)
	}

	// Set property "Target":
	if properties.Target != nil {
		target := *properties.Target
		result.Target = &target
	}

	// Set property "Value":
	if properties.Value != nil {
		value := *properties.Value
		result.Value = &value
	}

	// Set property "ValueFormat":
	if properties.ValueFormat != nil {
		var temp string
		temp = string(*properties.ValueFormat)
		valueFormat := arm.AADAuthTypeWorkspaceConnectionProperties_ValueFormat(temp)
		result.ValueFormat = &valueFormat
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *AADAuthTypeWorkspaceConnectionProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AADAuthTypeWorkspaceConnectionProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *AADAuthTypeWorkspaceConnectionProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AADAuthTypeWorkspaceConnectionProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AADAuthTypeWorkspaceConnectionProperties, got %T", armInput)
	}

	// Set property "AuthType":
	var temp AADAuthTypeWorkspaceConnectionProperties_AuthType
	var temp1 string
	temp1 = string(typedInput.AuthType)
	temp = AADAuthTypeWorkspaceConnectionProperties_AuthType(temp1)
	properties.AuthType = &temp

	// Set property "Category":
	if typedInput.Category != nil {
		var categoryTemp string
		categoryTemp = string(*typedInput.Category)
		category := ConnectionCategory(categoryTemp)
		properties.Category = &category
	}

	// Set property "ExpiryTime":
	if typedInput.ExpiryTime != nil {
		expiryTime := *typedInput.ExpiryTime
		properties.ExpiryTime = &expiryTime
	}

	// Set property "IsSharedToAll":
	if typedInput.IsSharedToAll != nil {
		isSharedToAll := *typedInput.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if typedInput.Metadata != nil {
		properties.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			properties.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range typedInput.SharedUserList {
		properties.SharedUserList = append(properties.SharedUserList, item)
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		properties.Target = &target
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		properties.Value = &value
	}

	// Set property "ValueFormat":
	if typedInput.ValueFormat != nil {
		var valueFormatTemp string
		valueFormatTemp = string(*typedInput.ValueFormat)
		valueFormat := AADAuthTypeWorkspaceConnectionProperties_ValueFormat(valueFormatTemp)
		properties.ValueFormat = &valueFormat
	}

	// No error
	return nil
}

// AssignProperties_From_AADAuthTypeWorkspaceConnectionProperties populates our AADAuthTypeWorkspaceConnectionProperties from the provided source AADAuthTypeWorkspaceConnectionProperties
func (properties *AADAuthTypeWorkspaceConnectionProperties) AssignProperties_From_AADAuthTypeWorkspaceConnectionProperties(source *storage.AADAuthTypeWorkspaceConnectionProperties) error {

	// AuthType
	if source.AuthType != nil {
		authType := *source.AuthType
		authTypeTemp := genruntime.ToEnum(authType, aADAuthTypeWorkspaceConnectionProperties_AuthType_Values)
		properties.AuthType = &authTypeTemp
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := *source.Category
		categoryTemp := genruntime.ToEnum(category, connectionCategory_Values)
		properties.Category = &categoryTemp
	} else {
		properties.Category = nil
	}

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := *source.ValueFormat
		valueFormatTemp := genruntime.ToEnum(valueFormat, aADAuthTypeWorkspaceConnectionProperties_ValueFormat_Values)
		properties.ValueFormat = &valueFormatTemp
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AADAuthTypeWorkspaceConnectionProperties populates the provided destination AADAuthTypeWorkspaceConnectionProperties from our AADAuthTypeWorkspaceConnectionProperties
func (properties *AADAuthTypeWorkspaceConnectionProperties) AssignProperties_To_AADAuthTypeWorkspaceConnectionProperties(destination *storage.AADAuthTypeWorkspaceConnectionProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthType
	if properties.AuthType != nil {
		authType := string(*properties.AuthType)
		destination.AuthType = &authType
	} else {
		destination.AuthType = nil
	}

	// Category
	if properties.Category != nil {
		category := string(*properties.Category)
		destination.Category = &category
	} else {
		destination.Category = nil
	}

	// ExpiryTime
	destination.ExpiryTime = genruntime.ClonePointerToString(properties.ExpiryTime)

	// IsSharedToAll
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		destination.IsSharedToAll = &isSharedToAll
	} else {
		destination.IsSharedToAll = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(properties.Metadata)

	// SharedUserList
	destination.SharedUserList = genruntime.CloneSliceOfString(properties.SharedUserList)

	// Target
	destination.Target = genruntime.ClonePointerToString(properties.Target)

	// Value
	destination.Value = genruntime.ClonePointerToString(properties.Value)

	// ValueFormat
	if properties.ValueFormat != nil {
		valueFormat := string(*properties.ValueFormat)
		destination.ValueFormat = &valueFormat
	} else {
		destination.ValueFormat = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AADAuthTypeWorkspaceConnectionProperties_STATUS populates our AADAuthTypeWorkspaceConnectionProperties from the provided source AADAuthTypeWorkspaceConnectionProperties_STATUS
func (properties *AADAuthTypeWorkspaceConnectionProperties) Initialize_From_AADAuthTypeWorkspaceConnectionProperties_STATUS(source *AADAuthTypeWorkspaceConnectionProperties_STATUS) error {

	// AuthType
	if source.AuthType != nil {
		authType := genruntime.ToEnum(string(*source.AuthType), aADAuthTypeWorkspaceConnectionProperties_AuthType_Values)
		properties.AuthType = &authType
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := genruntime.ToEnum(string(*source.Category), connectionCategory_Values)
		properties.Category = &category
	} else {
		properties.Category = nil
	}

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := genruntime.ToEnum(string(*source.ValueFormat), aADAuthTypeWorkspaceConnectionProperties_ValueFormat_Values)
		properties.ValueFormat = &valueFormat
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

type AADAuthTypeWorkspaceConnectionProperties_STATUS struct {
	// AuthType: Authentication type of the connection target
	AuthType *AADAuthTypeWorkspaceConnectionProperties_AuthType_STATUS `json:"authType,omitempty"`

	// Category: Category of the connection
	Category                *ConnectionCategory_STATUS `json:"category,omitempty"`
	CreatedByWorkspaceArmId *string                    `json:"createdByWorkspaceArmId,omitempty"`
	ExpiryTime              *string                    `json:"expiryTime,omitempty"`

	// Group: Group based on connection category
	Group         *ConnectionGroup_STATUS `json:"group,omitempty"`
	IsSharedToAll *bool                   `json:"isSharedToAll,omitempty"`

	// Metadata: Store user metadata for this connection
	Metadata       map[string]string `json:"metadata,omitempty"`
	SharedUserList []string          `json:"sharedUserList,omitempty"`
	Target         *string           `json:"target,omitempty"`

	// Value: Value details of the workspace connection.
	Value *string `json:"value,omitempty"`

	// ValueFormat: format for the workspace connection value
	ValueFormat *AADAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS `json:"valueFormat,omitempty"`
}

var _ genruntime.FromARMConverter = &AADAuthTypeWorkspaceConnectionProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *AADAuthTypeWorkspaceConnectionProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AADAuthTypeWorkspaceConnectionProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *AADAuthTypeWorkspaceConnectionProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AADAuthTypeWorkspaceConnectionProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AADAuthTypeWorkspaceConnectionProperties_STATUS, got %T", armInput)
	}

	// Set property "AuthType":
	var temp AADAuthTypeWorkspaceConnectionProperties_AuthType_STATUS
	var temp1 string
	temp1 = string(typedInput.AuthType)
	temp = AADAuthTypeWorkspaceConnectionProperties_AuthType_STATUS(temp1)
	properties.AuthType = &temp

	// Set property "Category":
	if typedInput.Category != nil {
		var categoryTemp string
		categoryTemp = string(*typedInput.Category)
		category := ConnectionCategory_STATUS(categoryTemp)
		properties.Category = &category
	}

	// Set property "CreatedByWorkspaceArmId":
	if typedInput.CreatedByWorkspaceArmId != nil {
		createdByWorkspaceArmId := *typedInput.CreatedByWorkspaceArmId
		properties.CreatedByWorkspaceArmId = &createdByWorkspaceArmId
	}

	// Set property "ExpiryTime":
	if typedInput.ExpiryTime != nil {
		expiryTime := *typedInput.ExpiryTime
		properties.ExpiryTime = &expiryTime
	}

	// Set property "Group":
	if typedInput.Group != nil {
		var groupTemp string
		groupTemp = string(*typedInput.Group)
		group := ConnectionGroup_STATUS(groupTemp)
		properties.Group = &group
	}

	// Set property "IsSharedToAll":
	if typedInput.IsSharedToAll != nil {
		isSharedToAll := *typedInput.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if typedInput.Metadata != nil {
		properties.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			properties.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range typedInput.SharedUserList {
		properties.SharedUserList = append(properties.SharedUserList, item)
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		properties.Target = &target
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		properties.Value = &value
	}

	// Set property "ValueFormat":
	if typedInput.ValueFormat != nil {
		var valueFormatTemp string
		valueFormatTemp = string(*typedInput.ValueFormat)
		valueFormat := AADAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS(valueFormatTemp)
		properties.ValueFormat = &valueFormat
	}

	// No error
	return nil
}

// AssignProperties_From_AADAuthTypeWorkspaceConnectionProperties_STATUS populates our AADAuthTypeWorkspaceConnectionProperties_STATUS from the provided source AADAuthTypeWorkspaceConnectionProperties_STATUS
func (properties *AADAuthTypeWorkspaceConnectionProperties_STATUS) AssignProperties_From_AADAuthTypeWorkspaceConnectionProperties_STATUS(source *storage.AADAuthTypeWorkspaceConnectionProperties_STATUS) error {

	// AuthType
	if source.AuthType != nil {
		authType := *source.AuthType
		authTypeTemp := genruntime.ToEnum(authType, aADAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_Values)
		properties.AuthType = &authTypeTemp
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := *source.Category
		categoryTemp := genruntime.ToEnum(category, connectionCategory_STATUS_Values)
		properties.Category = &categoryTemp
	} else {
		properties.Category = nil
	}

	// CreatedByWorkspaceArmId
	properties.CreatedByWorkspaceArmId = genruntime.ClonePointerToString(source.CreatedByWorkspaceArmId)

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// Group
	if source.Group != nil {
		group := *source.Group
		groupTemp := genruntime.ToEnum(group, connectionGroup_STATUS_Values)
		properties.Group = &groupTemp
	} else {
		properties.Group = nil
	}

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := *source.ValueFormat
		valueFormatTemp := genruntime.ToEnum(valueFormat, aADAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_Values)
		properties.ValueFormat = &valueFormatTemp
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AADAuthTypeWorkspaceConnectionProperties_STATUS populates the provided destination AADAuthTypeWorkspaceConnectionProperties_STATUS from our AADAuthTypeWorkspaceConnectionProperties_STATUS
func (properties *AADAuthTypeWorkspaceConnectionProperties_STATUS) AssignProperties_To_AADAuthTypeWorkspaceConnectionProperties_STATUS(destination *storage.AADAuthTypeWorkspaceConnectionProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthType
	if properties.AuthType != nil {
		authType := string(*properties.AuthType)
		destination.AuthType = &authType
	} else {
		destination.AuthType = nil
	}

	// Category
	if properties.Category != nil {
		category := string(*properties.Category)
		destination.Category = &category
	} else {
		destination.Category = nil
	}

	// CreatedByWorkspaceArmId
	destination.CreatedByWorkspaceArmId = genruntime.ClonePointerToString(properties.CreatedByWorkspaceArmId)

	// ExpiryTime
	destination.ExpiryTime = genruntime.ClonePointerToString(properties.ExpiryTime)

	// Group
	if properties.Group != nil {
		group := string(*properties.Group)
		destination.Group = &group
	} else {
		destination.Group = nil
	}

	// IsSharedToAll
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		destination.IsSharedToAll = &isSharedToAll
	} else {
		destination.IsSharedToAll = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(properties.Metadata)

	// SharedUserList
	destination.SharedUserList = genruntime.CloneSliceOfString(properties.SharedUserList)

	// Target
	destination.Target = genruntime.ClonePointerToString(properties.Target)

	// Value
	destination.Value = genruntime.ClonePointerToString(properties.Value)

	// ValueFormat
	if properties.ValueFormat != nil {
		valueFormat := string(*properties.ValueFormat)
		destination.ValueFormat = &valueFormat
	} else {
		destination.ValueFormat = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AccessKeyAuthTypeWorkspaceConnectionProperties struct {
	// +kubebuilder:validation:Required
	// AuthType: Authentication type of the connection target
	AuthType *AccessKeyAuthTypeWorkspaceConnectionProperties_AuthType `json:"authType,omitempty"`

	// Category: Category of the connection
	Category      *ConnectionCategory           `json:"category,omitempty"`
	Credentials   *WorkspaceConnectionAccessKey `json:"credentials,omitempty"`
	ExpiryTime    *string                       `json:"expiryTime,omitempty"`
	IsSharedToAll *bool                         `json:"isSharedToAll,omitempty"`

	// Metadata: Store user metadata for this connection
	Metadata       map[string]string `json:"metadata,omitempty"`
	SharedUserList []string          `json:"sharedUserList,omitempty"`
	Target         *string           `json:"target,omitempty"`

	// Value: Value details of the workspace connection.
	Value *string `json:"value,omitempty"`

	// ValueFormat: format for the workspace connection value
	ValueFormat *AccessKeyAuthTypeWorkspaceConnectionProperties_ValueFormat `json:"valueFormat,omitempty"`
}

var _ genruntime.ARMTransformer = &AccessKeyAuthTypeWorkspaceConnectionProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *AccessKeyAuthTypeWorkspaceConnectionProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.AccessKeyAuthTypeWorkspaceConnectionProperties{}

	// Set property "AuthType":
	if properties.AuthType != nil {
		var temp arm.AccessKeyAuthTypeWorkspaceConnectionProperties_AuthType
		var temp1 string
		temp1 = string(*properties.AuthType)
		temp = arm.AccessKeyAuthTypeWorkspaceConnectionProperties_AuthType(temp1)
		result.AuthType = temp
	}

	// Set property "Category":
	if properties.Category != nil {
		var temp string
		temp = string(*properties.Category)
		category := arm.ConnectionCategory(temp)
		result.Category = &category
	}

	// Set property "Credentials":
	if properties.Credentials != nil {
		credentials_ARM, err := (*properties.Credentials).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		credentials := *credentials_ARM.(*arm.WorkspaceConnectionAccessKey)
		result.Credentials = &credentials
	}

	// Set property "ExpiryTime":
	if properties.ExpiryTime != nil {
		expiryTime := *properties.ExpiryTime
		result.ExpiryTime = &expiryTime
	}

	// Set property "IsSharedToAll":
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		result.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if properties.Metadata != nil {
		result.Metadata = make(map[string]string, len(properties.Metadata))
		for key, value := range properties.Metadata {
			result.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range properties.SharedUserList {
		result.SharedUserList = append(result.SharedUserList, item)
	}

	// Set property "Target":
	if properties.Target != nil {
		target := *properties.Target
		result.Target = &target
	}

	// Set property "Value":
	if properties.Value != nil {
		value := *properties.Value
		result.Value = &value
	}

	// Set property "ValueFormat":
	if properties.ValueFormat != nil {
		var temp string
		temp = string(*properties.ValueFormat)
		valueFormat := arm.AccessKeyAuthTypeWorkspaceConnectionProperties_ValueFormat(temp)
		result.ValueFormat = &valueFormat
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *AccessKeyAuthTypeWorkspaceConnectionProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AccessKeyAuthTypeWorkspaceConnectionProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *AccessKeyAuthTypeWorkspaceConnectionProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AccessKeyAuthTypeWorkspaceConnectionProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AccessKeyAuthTypeWorkspaceConnectionProperties, got %T", armInput)
	}

	// Set property "AuthType":
	var temp AccessKeyAuthTypeWorkspaceConnectionProperties_AuthType
	var temp1 string
	temp1 = string(typedInput.AuthType)
	temp = AccessKeyAuthTypeWorkspaceConnectionProperties_AuthType(temp1)
	properties.AuthType = &temp

	// Set property "Category":
	if typedInput.Category != nil {
		var categoryTemp string
		categoryTemp = string(*typedInput.Category)
		category := ConnectionCategory(categoryTemp)
		properties.Category = &category
	}

	// Set property "Credentials":
	if typedInput.Credentials != nil {
		var credentials1 WorkspaceConnectionAccessKey
		err := credentials1.PopulateFromARM(owner, *typedInput.Credentials)
		if err != nil {
			return err
		}
		credentials := credentials1
		properties.Credentials = &credentials
	}

	// Set property "ExpiryTime":
	if typedInput.ExpiryTime != nil {
		expiryTime := *typedInput.ExpiryTime
		properties.ExpiryTime = &expiryTime
	}

	// Set property "IsSharedToAll":
	if typedInput.IsSharedToAll != nil {
		isSharedToAll := *typedInput.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if typedInput.Metadata != nil {
		properties.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			properties.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range typedInput.SharedUserList {
		properties.SharedUserList = append(properties.SharedUserList, item)
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		properties.Target = &target
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		properties.Value = &value
	}

	// Set property "ValueFormat":
	if typedInput.ValueFormat != nil {
		var valueFormatTemp string
		valueFormatTemp = string(*typedInput.ValueFormat)
		valueFormat := AccessKeyAuthTypeWorkspaceConnectionProperties_ValueFormat(valueFormatTemp)
		properties.ValueFormat = &valueFormat
	}

	// No error
	return nil
}

// AssignProperties_From_AccessKeyAuthTypeWorkspaceConnectionProperties populates our AccessKeyAuthTypeWorkspaceConnectionProperties from the provided source AccessKeyAuthTypeWorkspaceConnectionProperties
func (properties *AccessKeyAuthTypeWorkspaceConnectionProperties) AssignProperties_From_AccessKeyAuthTypeWorkspaceConnectionProperties(source *storage.AccessKeyAuthTypeWorkspaceConnectionProperties) error {

	// AuthType
	if source.AuthType != nil {
		authType := *source.AuthType
		authTypeTemp := genruntime.ToEnum(authType, accessKeyAuthTypeWorkspaceConnectionProperties_AuthType_Values)
		properties.AuthType = &authTypeTemp
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := *source.Category
		categoryTemp := genruntime.ToEnum(category, connectionCategory_Values)
		properties.Category = &categoryTemp
	} else {
		properties.Category = nil
	}

	// Credentials
	if source.Credentials != nil {
		var credential WorkspaceConnectionAccessKey
		err := credential.AssignProperties_From_WorkspaceConnectionAccessKey(source.Credentials)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WorkspaceConnectionAccessKey() to populate field Credentials")
		}
		properties.Credentials = &credential
	} else {
		properties.Credentials = nil
	}

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := *source.ValueFormat
		valueFormatTemp := genruntime.ToEnum(valueFormat, accessKeyAuthTypeWorkspaceConnectionProperties_ValueFormat_Values)
		properties.ValueFormat = &valueFormatTemp
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AccessKeyAuthTypeWorkspaceConnectionProperties populates the provided destination AccessKeyAuthTypeWorkspaceConnectionProperties from our AccessKeyAuthTypeWorkspaceConnectionProperties
func (properties *AccessKeyAuthTypeWorkspaceConnectionProperties) AssignProperties_To_AccessKeyAuthTypeWorkspaceConnectionProperties(destination *storage.AccessKeyAuthTypeWorkspaceConnectionProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthType
	if properties.AuthType != nil {
		authType := string(*properties.AuthType)
		destination.AuthType = &authType
	} else {
		destination.AuthType = nil
	}

	// Category
	if properties.Category != nil {
		category := string(*properties.Category)
		destination.Category = &category
	} else {
		destination.Category = nil
	}

	// Credentials
	if properties.Credentials != nil {
		var credential storage.WorkspaceConnectionAccessKey
		err := properties.Credentials.AssignProperties_To_WorkspaceConnectionAccessKey(&credential)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WorkspaceConnectionAccessKey() to populate field Credentials")
		}
		destination.Credentials = &credential
	} else {
		destination.Credentials = nil
	}

	// ExpiryTime
	destination.ExpiryTime = genruntime.ClonePointerToString(properties.ExpiryTime)

	// IsSharedToAll
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		destination.IsSharedToAll = &isSharedToAll
	} else {
		destination.IsSharedToAll = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(properties.Metadata)

	// SharedUserList
	destination.SharedUserList = genruntime.CloneSliceOfString(properties.SharedUserList)

	// Target
	destination.Target = genruntime.ClonePointerToString(properties.Target)

	// Value
	destination.Value = genruntime.ClonePointerToString(properties.Value)

	// ValueFormat
	if properties.ValueFormat != nil {
		valueFormat := string(*properties.ValueFormat)
		destination.ValueFormat = &valueFormat
	} else {
		destination.ValueFormat = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS populates our AccessKeyAuthTypeWorkspaceConnectionProperties from the provided source AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS
func (properties *AccessKeyAuthTypeWorkspaceConnectionProperties) Initialize_From_AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS(source *AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS) error {

	// AuthType
	if source.AuthType != nil {
		authType := genruntime.ToEnum(string(*source.AuthType), accessKeyAuthTypeWorkspaceConnectionProperties_AuthType_Values)
		properties.AuthType = &authType
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := genruntime.ToEnum(string(*source.Category), connectionCategory_Values)
		properties.Category = &category
	} else {
		properties.Category = nil
	}

	// Credentials
	if source.Credentials != nil {
		var credential WorkspaceConnectionAccessKey
		err := credential.Initialize_From_WorkspaceConnectionAccessKey_STATUS(source.Credentials)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_WorkspaceConnectionAccessKey_STATUS() to populate field Credentials")
		}
		properties.Credentials = &credential
	} else {
		properties.Credentials = nil
	}

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := genruntime.ToEnum(string(*source.ValueFormat), accessKeyAuthTypeWorkspaceConnectionProperties_ValueFormat_Values)
		properties.ValueFormat = &valueFormat
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

type AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS struct {
	// AuthType: Authentication type of the connection target
	AuthType *AccessKeyAuthTypeWorkspaceConnectionProperties_AuthType_STATUS `json:"authType,omitempty"`

	// Category: Category of the connection
	Category                *ConnectionCategory_STATUS           `json:"category,omitempty"`
	CreatedByWorkspaceArmId *string                              `json:"createdByWorkspaceArmId,omitempty"`
	Credentials             *WorkspaceConnectionAccessKey_STATUS `json:"credentials,omitempty"`
	ExpiryTime              *string                              `json:"expiryTime,omitempty"`

	// Group: Group based on connection category
	Group         *ConnectionGroup_STATUS `json:"group,omitempty"`
	IsSharedToAll *bool                   `json:"isSharedToAll,omitempty"`

	// Metadata: Store user metadata for this connection
	Metadata       map[string]string `json:"metadata,omitempty"`
	SharedUserList []string          `json:"sharedUserList,omitempty"`
	Target         *string           `json:"target,omitempty"`

	// Value: Value details of the workspace connection.
	Value *string `json:"value,omitempty"`

	// ValueFormat: format for the workspace connection value
	ValueFormat *AccessKeyAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS `json:"valueFormat,omitempty"`
}

var _ genruntime.FromARMConverter = &AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS, got %T", armInput)
	}

	// Set property "AuthType":
	var temp AccessKeyAuthTypeWorkspaceConnectionProperties_AuthType_STATUS
	var temp1 string
	temp1 = string(typedInput.AuthType)
	temp = AccessKeyAuthTypeWorkspaceConnectionProperties_AuthType_STATUS(temp1)
	properties.AuthType = &temp

	// Set property "Category":
	if typedInput.Category != nil {
		var categoryTemp string
		categoryTemp = string(*typedInput.Category)
		category := ConnectionCategory_STATUS(categoryTemp)
		properties.Category = &category
	}

	// Set property "CreatedByWorkspaceArmId":
	if typedInput.CreatedByWorkspaceArmId != nil {
		createdByWorkspaceArmId := *typedInput.CreatedByWorkspaceArmId
		properties.CreatedByWorkspaceArmId = &createdByWorkspaceArmId
	}

	// Set property "Credentials":
	if typedInput.Credentials != nil {
		var credentials1 WorkspaceConnectionAccessKey_STATUS
		err := credentials1.PopulateFromARM(owner, *typedInput.Credentials)
		if err != nil {
			return err
		}
		credentials := credentials1
		properties.Credentials = &credentials
	}

	// Set property "ExpiryTime":
	if typedInput.ExpiryTime != nil {
		expiryTime := *typedInput.ExpiryTime
		properties.ExpiryTime = &expiryTime
	}

	// Set property "Group":
	if typedInput.Group != nil {
		var groupTemp string
		groupTemp = string(*typedInput.Group)
		group := ConnectionGroup_STATUS(groupTemp)
		properties.Group = &group
	}

	// Set property "IsSharedToAll":
	if typedInput.IsSharedToAll != nil {
		isSharedToAll := *typedInput.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if typedInput.Metadata != nil {
		properties.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			properties.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range typedInput.SharedUserList {
		properties.SharedUserList = append(properties.SharedUserList, item)
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		properties.Target = &target
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		properties.Value = &value
	}

	// Set property "ValueFormat":
	if typedInput.ValueFormat != nil {
		var valueFormatTemp string
		valueFormatTemp = string(*typedInput.ValueFormat)
		valueFormat := AccessKeyAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS(valueFormatTemp)
		properties.ValueFormat = &valueFormat
	}

	// No error
	return nil
}

// AssignProperties_From_AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS populates our AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS from the provided source AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS
func (properties *AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS) AssignProperties_From_AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS(source *storage.AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS) error {

	// AuthType
	if source.AuthType != nil {
		authType := *source.AuthType
		authTypeTemp := genruntime.ToEnum(authType, accessKeyAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_Values)
		properties.AuthType = &authTypeTemp
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := *source.Category
		categoryTemp := genruntime.ToEnum(category, connectionCategory_STATUS_Values)
		properties.Category = &categoryTemp
	} else {
		properties.Category = nil
	}

	// CreatedByWorkspaceArmId
	properties.CreatedByWorkspaceArmId = genruntime.ClonePointerToString(source.CreatedByWorkspaceArmId)

	// Credentials
	if source.Credentials != nil {
		var credential WorkspaceConnectionAccessKey_STATUS
		err := credential.AssignProperties_From_WorkspaceConnectionAccessKey_STATUS(source.Credentials)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WorkspaceConnectionAccessKey_STATUS() to populate field Credentials")
		}
		properties.Credentials = &credential
	} else {
		properties.Credentials = nil
	}

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// Group
	if source.Group != nil {
		group := *source.Group
		groupTemp := genruntime.ToEnum(group, connectionGroup_STATUS_Values)
		properties.Group = &groupTemp
	} else {
		properties.Group = nil
	}

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := *source.ValueFormat
		valueFormatTemp := genruntime.ToEnum(valueFormat, accessKeyAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_Values)
		properties.ValueFormat = &valueFormatTemp
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS populates the provided destination AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS from our AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS
func (properties *AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS) AssignProperties_To_AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS(destination *storage.AccessKeyAuthTypeWorkspaceConnectionProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthType
	if properties.AuthType != nil {
		authType := string(*properties.AuthType)
		destination.AuthType = &authType
	} else {
		destination.AuthType = nil
	}

	// Category
	if properties.Category != nil {
		category := string(*properties.Category)
		destination.Category = &category
	} else {
		destination.Category = nil
	}

	// CreatedByWorkspaceArmId
	destination.CreatedByWorkspaceArmId = genruntime.ClonePointerToString(properties.CreatedByWorkspaceArmId)

	// Credentials
	if properties.Credentials != nil {
		var credential storage.WorkspaceConnectionAccessKey_STATUS
		err := properties.Credentials.AssignProperties_To_WorkspaceConnectionAccessKey_STATUS(&credential)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WorkspaceConnectionAccessKey_STATUS() to populate field Credentials")
		}
		destination.Credentials = &credential
	} else {
		destination.Credentials = nil
	}

	// ExpiryTime
	destination.ExpiryTime = genruntime.ClonePointerToString(properties.ExpiryTime)

	// Group
	if properties.Group != nil {
		group := string(*properties.Group)
		destination.Group = &group
	} else {
		destination.Group = nil
	}

	// IsSharedToAll
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		destination.IsSharedToAll = &isSharedToAll
	} else {
		destination.IsSharedToAll = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(properties.Metadata)

	// SharedUserList
	destination.SharedUserList = genruntime.CloneSliceOfString(properties.SharedUserList)

	// Target
	destination.Target = genruntime.ClonePointerToString(properties.Target)

	// Value
	destination.Value = genruntime.ClonePointerToString(properties.Value)

	// ValueFormat
	if properties.ValueFormat != nil {
		valueFormat := string(*properties.ValueFormat)
		destination.ValueFormat = &valueFormat
	} else {
		destination.ValueFormat = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AccountKeyAuthTypeWorkspaceConnectionProperties struct {
	// +kubebuilder:validation:Required
	// AuthType: Authentication type of the connection target
	AuthType *AccountKeyAuthTypeWorkspaceConnectionProperties_AuthType `json:"authType,omitempty"`

	// Category: Category of the connection
	Category      *ConnectionCategory            `json:"category,omitempty"`
	Credentials   *WorkspaceConnectionAccountKey `json:"credentials,omitempty"`
	ExpiryTime    *string                        `json:"expiryTime,omitempty"`
	IsSharedToAll *bool                          `json:"isSharedToAll,omitempty"`

	// Metadata: Store user metadata for this connection
	Metadata       map[string]string `json:"metadata,omitempty"`
	SharedUserList []string          `json:"sharedUserList,omitempty"`
	Target         *string           `json:"target,omitempty"`

	// Value: Value details of the workspace connection.
	Value *string `json:"value,omitempty"`

	// ValueFormat: format for the workspace connection value
	ValueFormat *AccountKeyAuthTypeWorkspaceConnectionProperties_ValueFormat `json:"valueFormat,omitempty"`
}

var _ genruntime.ARMTransformer = &AccountKeyAuthTypeWorkspaceConnectionProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *AccountKeyAuthTypeWorkspaceConnectionProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.AccountKeyAuthTypeWorkspaceConnectionProperties{}

	// Set property "AuthType":
	if properties.AuthType != nil {
		var temp arm.AccountKeyAuthTypeWorkspaceConnectionProperties_AuthType
		var temp1 string
		temp1 = string(*properties.AuthType)
		temp = arm.AccountKeyAuthTypeWorkspaceConnectionProperties_AuthType(temp1)
		result.AuthType = temp
	}

	// Set property "Category":
	if properties.Category != nil {
		var temp string
		temp = string(*properties.Category)
		category := arm.ConnectionCategory(temp)
		result.Category = &category
	}

	// Set property "Credentials":
	if properties.Credentials != nil {
		credentials_ARM, err := (*properties.Credentials).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		credentials := *credentials_ARM.(*arm.WorkspaceConnectionAccountKey)
		result.Credentials = &credentials
	}

	// Set property "ExpiryTime":
	if properties.ExpiryTime != nil {
		expiryTime := *properties.ExpiryTime
		result.ExpiryTime = &expiryTime
	}

	// Set property "IsSharedToAll":
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		result.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if properties.Metadata != nil {
		result.Metadata = make(map[string]string, len(properties.Metadata))
		for key, value := range properties.Metadata {
			result.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range properties.SharedUserList {
		result.SharedUserList = append(result.SharedUserList, item)
	}

	// Set property "Target":
	if properties.Target != nil {
		target := *properties.Target
		result.Target = &target
	}

	// Set property "Value":
	if properties.Value != nil {
		value := *properties.Value
		result.Value = &value
	}

	// Set property "ValueFormat":
	if properties.ValueFormat != nil {
		var temp string
		temp = string(*properties.ValueFormat)
		valueFormat := arm.AccountKeyAuthTypeWorkspaceConnectionProperties_ValueFormat(temp)
		result.ValueFormat = &valueFormat
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *AccountKeyAuthTypeWorkspaceConnectionProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AccountKeyAuthTypeWorkspaceConnectionProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *AccountKeyAuthTypeWorkspaceConnectionProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AccountKeyAuthTypeWorkspaceConnectionProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AccountKeyAuthTypeWorkspaceConnectionProperties, got %T", armInput)
	}

	// Set property "AuthType":
	var temp AccountKeyAuthTypeWorkspaceConnectionProperties_AuthType
	var temp1 string
	temp1 = string(typedInput.AuthType)
	temp = AccountKeyAuthTypeWorkspaceConnectionProperties_AuthType(temp1)
	properties.AuthType = &temp

	// Set property "Category":
	if typedInput.Category != nil {
		var categoryTemp string
		categoryTemp = string(*typedInput.Category)
		category := ConnectionCategory(categoryTemp)
		properties.Category = &category
	}

	// Set property "Credentials":
	if typedInput.Credentials != nil {
		var credentials1 WorkspaceConnectionAccountKey
		err := credentials1.PopulateFromARM(owner, *typedInput.Credentials)
		if err != nil {
			return err
		}
		credentials := credentials1
		properties.Credentials = &credentials
	}

	// Set property "ExpiryTime":
	if typedInput.ExpiryTime != nil {
		expiryTime := *typedInput.ExpiryTime
		properties.ExpiryTime = &expiryTime
	}

	// Set property "IsSharedToAll":
	if typedInput.IsSharedToAll != nil {
		isSharedToAll := *typedInput.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if typedInput.Metadata != nil {
		properties.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			properties.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range typedInput.SharedUserList {
		properties.SharedUserList = append(properties.SharedUserList, item)
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		properties.Target = &target
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		properties.Value = &value
	}

	// Set property "ValueFormat":
	if typedInput.ValueFormat != nil {
		var valueFormatTemp string
		valueFormatTemp = string(*typedInput.ValueFormat)
		valueFormat := AccountKeyAuthTypeWorkspaceConnectionProperties_ValueFormat(valueFormatTemp)
		properties.ValueFormat = &valueFormat
	}

	// No error
	return nil
}

// AssignProperties_From_AccountKeyAuthTypeWorkspaceConnectionProperties populates our AccountKeyAuthTypeWorkspaceConnectionProperties from the provided source AccountKeyAuthTypeWorkspaceConnectionProperties
func (properties *AccountKeyAuthTypeWorkspaceConnectionProperties) AssignProperties_From_AccountKeyAuthTypeWorkspaceConnectionProperties(source *storage.AccountKeyAuthTypeWorkspaceConnectionProperties) error {

	// AuthType
	if source.AuthType != nil {
		authType := *source.AuthType
		authTypeTemp := genruntime.ToEnum(authType, accountKeyAuthTypeWorkspaceConnectionProperties_AuthType_Values)
		properties.AuthType = &authTypeTemp
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := *source.Category
		categoryTemp := genruntime.ToEnum(category, connectionCategory_Values)
		properties.Category = &categoryTemp
	} else {
		properties.Category = nil
	}

	// Credentials
	if source.Credentials != nil {
		var credential WorkspaceConnectionAccountKey
		err := credential.AssignProperties_From_WorkspaceConnectionAccountKey(source.Credentials)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WorkspaceConnectionAccountKey() to populate field Credentials")
		}
		properties.Credentials = &credential
	} else {
		properties.Credentials = nil
	}

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := *source.ValueFormat
		valueFormatTemp := genruntime.ToEnum(valueFormat, accountKeyAuthTypeWorkspaceConnectionProperties_ValueFormat_Values)
		properties.ValueFormat = &valueFormatTemp
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AccountKeyAuthTypeWorkspaceConnectionProperties populates the provided destination AccountKeyAuthTypeWorkspaceConnectionProperties from our AccountKeyAuthTypeWorkspaceConnectionProperties
func (properties *AccountKeyAuthTypeWorkspaceConnectionProperties) AssignProperties_To_AccountKeyAuthTypeWorkspaceConnectionProperties(destination *storage.AccountKeyAuthTypeWorkspaceConnectionProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthType
	if properties.AuthType != nil {
		authType := string(*properties.AuthType)
		destination.AuthType = &authType
	} else {
		destination.AuthType = nil
	}

	// Category
	if properties.Category != nil {
		category := string(*properties.Category)
		destination.Category = &category
	} else {
		destination.Category = nil
	}

	// Credentials
	if properties.Credentials != nil {
		var credential storage.WorkspaceConnectionAccountKey
		err := properties.Credentials.AssignProperties_To_WorkspaceConnectionAccountKey(&credential)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WorkspaceConnectionAccountKey() to populate field Credentials")
		}
		destination.Credentials = &credential
	} else {
		destination.Credentials = nil
	}

	// ExpiryTime
	destination.ExpiryTime = genruntime.ClonePointerToString(properties.ExpiryTime)

	// IsSharedToAll
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		destination.IsSharedToAll = &isSharedToAll
	} else {
		destination.IsSharedToAll = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(properties.Metadata)

	// SharedUserList
	destination.SharedUserList = genruntime.CloneSliceOfString(properties.SharedUserList)

	// Target
	destination.Target = genruntime.ClonePointerToString(properties.Target)

	// Value
	destination.Value = genruntime.ClonePointerToString(properties.Value)

	// ValueFormat
	if properties.ValueFormat != nil {
		valueFormat := string(*properties.ValueFormat)
		destination.ValueFormat = &valueFormat
	} else {
		destination.ValueFormat = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS populates our AccountKeyAuthTypeWorkspaceConnectionProperties from the provided source AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS
func (properties *AccountKeyAuthTypeWorkspaceConnectionProperties) Initialize_From_AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS(source *AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS) error {

	// AuthType
	if source.AuthType != nil {
		authType := genruntime.ToEnum(string(*source.AuthType), accountKeyAuthTypeWorkspaceConnectionProperties_AuthType_Values)
		properties.AuthType = &authType
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := genruntime.ToEnum(string(*source.Category), connectionCategory_Values)
		properties.Category = &category
	} else {
		properties.Category = nil
	}

	// Credentials
	if source.Credentials != nil {
		var credential WorkspaceConnectionAccountKey
		err := credential.Initialize_From_WorkspaceConnectionAccountKey_STATUS(source.Credentials)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_WorkspaceConnectionAccountKey_STATUS() to populate field Credentials")
		}
		properties.Credentials = &credential
	} else {
		properties.Credentials = nil
	}

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := genruntime.ToEnum(string(*source.ValueFormat), accountKeyAuthTypeWorkspaceConnectionProperties_ValueFormat_Values)
		properties.ValueFormat = &valueFormat
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

type AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS struct {
	// AuthType: Authentication type of the connection target
	AuthType *AccountKeyAuthTypeWorkspaceConnectionProperties_AuthType_STATUS `json:"authType,omitempty"`

	// Category: Category of the connection
	Category                *ConnectionCategory_STATUS            `json:"category,omitempty"`
	CreatedByWorkspaceArmId *string                               `json:"createdByWorkspaceArmId,omitempty"`
	Credentials             *WorkspaceConnectionAccountKey_STATUS `json:"credentials,omitempty"`
	ExpiryTime              *string                               `json:"expiryTime,omitempty"`

	// Group: Group based on connection category
	Group         *ConnectionGroup_STATUS `json:"group,omitempty"`
	IsSharedToAll *bool                   `json:"isSharedToAll,omitempty"`

	// Metadata: Store user metadata for this connection
	Metadata       map[string]string `json:"metadata,omitempty"`
	SharedUserList []string          `json:"sharedUserList,omitempty"`
	Target         *string           `json:"target,omitempty"`

	// Value: Value details of the workspace connection.
	Value *string `json:"value,omitempty"`

	// ValueFormat: format for the workspace connection value
	ValueFormat *AccountKeyAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS `json:"valueFormat,omitempty"`
}

var _ genruntime.FromARMConverter = &AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS, got %T", armInput)
	}

	// Set property "AuthType":
	var temp AccountKeyAuthTypeWorkspaceConnectionProperties_AuthType_STATUS
	var temp1 string
	temp1 = string(typedInput.AuthType)
	temp = AccountKeyAuthTypeWorkspaceConnectionProperties_AuthType_STATUS(temp1)
	properties.AuthType = &temp

	// Set property "Category":
	if typedInput.Category != nil {
		var categoryTemp string
		categoryTemp = string(*typedInput.Category)
		category := ConnectionCategory_STATUS(categoryTemp)
		properties.Category = &category
	}

	// Set property "CreatedByWorkspaceArmId":
	if typedInput.CreatedByWorkspaceArmId != nil {
		createdByWorkspaceArmId := *typedInput.CreatedByWorkspaceArmId
		properties.CreatedByWorkspaceArmId = &createdByWorkspaceArmId
	}

	// Set property "Credentials":
	if typedInput.Credentials != nil {
		var credentials1 WorkspaceConnectionAccountKey_STATUS
		err := credentials1.PopulateFromARM(owner, *typedInput.Credentials)
		if err != nil {
			return err
		}
		credentials := credentials1
		properties.Credentials = &credentials
	}

	// Set property "ExpiryTime":
	if typedInput.ExpiryTime != nil {
		expiryTime := *typedInput.ExpiryTime
		properties.ExpiryTime = &expiryTime
	}

	// Set property "Group":
	if typedInput.Group != nil {
		var groupTemp string
		groupTemp = string(*typedInput.Group)
		group := ConnectionGroup_STATUS(groupTemp)
		properties.Group = &group
	}

	// Set property "IsSharedToAll":
	if typedInput.IsSharedToAll != nil {
		isSharedToAll := *typedInput.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if typedInput.Metadata != nil {
		properties.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			properties.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range typedInput.SharedUserList {
		properties.SharedUserList = append(properties.SharedUserList, item)
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		properties.Target = &target
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		properties.Value = &value
	}

	// Set property "ValueFormat":
	if typedInput.ValueFormat != nil {
		var valueFormatTemp string
		valueFormatTemp = string(*typedInput.ValueFormat)
		valueFormat := AccountKeyAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS(valueFormatTemp)
		properties.ValueFormat = &valueFormat
	}

	// No error
	return nil
}

// AssignProperties_From_AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS populates our AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS from the provided source AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS
func (properties *AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS) AssignProperties_From_AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS(source *storage.AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS) error {

	// AuthType
	if source.AuthType != nil {
		authType := *source.AuthType
		authTypeTemp := genruntime.ToEnum(authType, accountKeyAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_Values)
		properties.AuthType = &authTypeTemp
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := *source.Category
		categoryTemp := genruntime.ToEnum(category, connectionCategory_STATUS_Values)
		properties.Category = &categoryTemp
	} else {
		properties.Category = nil
	}

	// CreatedByWorkspaceArmId
	properties.CreatedByWorkspaceArmId = genruntime.ClonePointerToString(source.CreatedByWorkspaceArmId)

	// Credentials
	if source.Credentials != nil {
		var credential WorkspaceConnectionAccountKey_STATUS
		err := credential.AssignProperties_From_WorkspaceConnectionAccountKey_STATUS(source.Credentials)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WorkspaceConnectionAccountKey_STATUS() to populate field Credentials")
		}
		properties.Credentials = &credential
	} else {
		properties.Credentials = nil
	}

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// Group
	if source.Group != nil {
		group := *source.Group
		groupTemp := genruntime.ToEnum(group, connectionGroup_STATUS_Values)
		properties.Group = &groupTemp
	} else {
		properties.Group = nil
	}

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := *source.ValueFormat
		valueFormatTemp := genruntime.ToEnum(valueFormat, accountKeyAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_Values)
		properties.ValueFormat = &valueFormatTemp
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS populates the provided destination AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS from our AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS
func (properties *AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS) AssignProperties_To_AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS(destination *storage.AccountKeyAuthTypeWorkspaceConnectionProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthType
	if properties.AuthType != nil {
		authType := string(*properties.AuthType)
		destination.AuthType = &authType
	} else {
		destination.AuthType = nil
	}

	// Category
	if properties.Category != nil {
		category := string(*properties.Category)
		destination.Category = &category
	} else {
		destination.Category = nil
	}

	// CreatedByWorkspaceArmId
	destination.CreatedByWorkspaceArmId = genruntime.ClonePointerToString(properties.CreatedByWorkspaceArmId)

	// Credentials
	if properties.Credentials != nil {
		var credential storage.WorkspaceConnectionAccountKey_STATUS
		err := properties.Credentials.AssignProperties_To_WorkspaceConnectionAccountKey_STATUS(&credential)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WorkspaceConnectionAccountKey_STATUS() to populate field Credentials")
		}
		destination.Credentials = &credential
	} else {
		destination.Credentials = nil
	}

	// ExpiryTime
	destination.ExpiryTime = genruntime.ClonePointerToString(properties.ExpiryTime)

	// Group
	if properties.Group != nil {
		group := string(*properties.Group)
		destination.Group = &group
	} else {
		destination.Group = nil
	}

	// IsSharedToAll
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		destination.IsSharedToAll = &isSharedToAll
	} else {
		destination.IsSharedToAll = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(properties.Metadata)

	// SharedUserList
	destination.SharedUserList = genruntime.CloneSliceOfString(properties.SharedUserList)

	// Target
	destination.Target = genruntime.ClonePointerToString(properties.Target)

	// Value
	destination.Value = genruntime.ClonePointerToString(properties.Value)

	// ValueFormat
	if properties.ValueFormat != nil {
		valueFormat := string(*properties.ValueFormat)
		destination.ValueFormat = &valueFormat
	} else {
		destination.ValueFormat = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ApiKeyAuthWorkspaceConnectionProperties struct {
	// +kubebuilder:validation:Required
	// AuthType: Authentication type of the connection target
	AuthType *ApiKeyAuthWorkspaceConnectionProperties_AuthType `json:"authType,omitempty"`

	// Category: Category of the connection
	Category *ConnectionCategory `json:"category,omitempty"`

	// Credentials: Api key object for workspace connection credential.
	Credentials   *WorkspaceConnectionApiKey `json:"credentials,omitempty"`
	ExpiryTime    *string                    `json:"expiryTime,omitempty"`
	IsSharedToAll *bool                      `json:"isSharedToAll,omitempty"`

	// Metadata: Store user metadata for this connection
	Metadata       map[string]string `json:"metadata,omitempty"`
	SharedUserList []string          `json:"sharedUserList,omitempty"`
	Target         *string           `json:"target,omitempty"`

	// Value: Value details of the workspace connection.
	Value *string `json:"value,omitempty"`

	// ValueFormat: format for the workspace connection value
	ValueFormat *ApiKeyAuthWorkspaceConnectionProperties_ValueFormat `json:"valueFormat,omitempty"`
}

var _ genruntime.ARMTransformer = &ApiKeyAuthWorkspaceConnectionProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *ApiKeyAuthWorkspaceConnectionProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.ApiKeyAuthWorkspaceConnectionProperties{}

	// Set property "AuthType":
	if properties.AuthType != nil {
		var temp arm.ApiKeyAuthWorkspaceConnectionProperties_AuthType
		var temp1 string
		temp1 = string(*properties.AuthType)
		temp = arm.ApiKeyAuthWorkspaceConnectionProperties_AuthType(temp1)
		result.AuthType = temp
	}

	// Set property "Category":
	if properties.Category != nil {
		var temp string
		temp = string(*properties.Category)
		category := arm.ConnectionCategory(temp)
		result.Category = &category
	}

	// Set property "Credentials":
	if properties.Credentials != nil {
		credentials_ARM, err := (*properties.Credentials).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		credentials := *credentials_ARM.(*arm.WorkspaceConnectionApiKey)
		result.Credentials = &credentials
	}

	// Set property "ExpiryTime":
	if properties.ExpiryTime != nil {
		expiryTime := *properties.ExpiryTime
		result.ExpiryTime = &expiryTime
	}

	// Set property "IsSharedToAll":
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		result.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if properties.Metadata != nil {
		result.Metadata = make(map[string]string, len(properties.Metadata))
		for key, value := range properties.Metadata {
			result.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range properties.SharedUserList {
		result.SharedUserList = append(result.SharedUserList, item)
	}

	// Set property "Target":
	if properties.Target != nil {
		target := *properties.Target
		result.Target = &target
	}

	// Set property "Value":
	if properties.Value != nil {
		value := *properties.Value
		result.Value = &value
	}

	// Set property "ValueFormat":
	if properties.ValueFormat != nil {
		var temp string
		temp = string(*properties.ValueFormat)
		valueFormat := arm.ApiKeyAuthWorkspaceConnectionProperties_ValueFormat(temp)
		result.ValueFormat = &valueFormat
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *ApiKeyAuthWorkspaceConnectionProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApiKeyAuthWorkspaceConnectionProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *ApiKeyAuthWorkspaceConnectionProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApiKeyAuthWorkspaceConnectionProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApiKeyAuthWorkspaceConnectionProperties, got %T", armInput)
	}

	// Set property "AuthType":
	var temp ApiKeyAuthWorkspaceConnectionProperties_AuthType
	var temp1 string
	temp1 = string(typedInput.AuthType)
	temp = ApiKeyAuthWorkspaceConnectionProperties_AuthType(temp1)
	properties.AuthType = &temp

	// Set property "Category":
	if typedInput.Category != nil {
		var categoryTemp string
		categoryTemp = string(*typedInput.Category)
		category := ConnectionCategory(categoryTemp)
		properties.Category = &category
	}

	// Set property "Credentials":
	if typedInput.Credentials != nil {
		var credentials1 WorkspaceConnectionApiKey
		err := credentials1.PopulateFromARM(owner, *typedInput.Credentials)
		if err != nil {
			return err
		}
		credentials := credentials1
		properties.Credentials = &credentials
	}

	// Set property "ExpiryTime":
	if typedInput.ExpiryTime != nil {
		expiryTime := *typedInput.ExpiryTime
		properties.ExpiryTime = &expiryTime
	}

	// Set property "IsSharedToAll":
	if typedInput.IsSharedToAll != nil {
		isSharedToAll := *typedInput.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if typedInput.Metadata != nil {
		properties.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			properties.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range typedInput.SharedUserList {
		properties.SharedUserList = append(properties.SharedUserList, item)
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		properties.Target = &target
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		properties.Value = &value
	}

	// Set property "ValueFormat":
	if typedInput.ValueFormat != nil {
		var valueFormatTemp string
		valueFormatTemp = string(*typedInput.ValueFormat)
		valueFormat := ApiKeyAuthWorkspaceConnectionProperties_ValueFormat(valueFormatTemp)
		properties.ValueFormat = &valueFormat
	}

	// No error
	return nil
}

// AssignProperties_From_ApiKeyAuthWorkspaceConnectionProperties populates our ApiKeyAuthWorkspaceConnectionProperties from the provided source ApiKeyAuthWorkspaceConnectionProperties
func (properties *ApiKeyAuthWorkspaceConnectionProperties) AssignProperties_From_ApiKeyAuthWorkspaceConnectionProperties(source *storage.ApiKeyAuthWorkspaceConnectionProperties) error {

	// AuthType
	if source.AuthType != nil {
		authType := *source.AuthType
		authTypeTemp := genruntime.ToEnum(authType, apiKeyAuthWorkspaceConnectionProperties_AuthType_Values)
		properties.AuthType = &authTypeTemp
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := *source.Category
		categoryTemp := genruntime.ToEnum(category, connectionCategory_Values)
		properties.Category = &categoryTemp
	} else {
		properties.Category = nil
	}

	// Credentials
	if source.Credentials != nil {
		var credential WorkspaceConnectionApiKey
		err := credential.AssignProperties_From_WorkspaceConnectionApiKey(source.Credentials)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WorkspaceConnectionApiKey() to populate field Credentials")
		}
		properties.Credentials = &credential
	} else {
		properties.Credentials = nil
	}

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := *source.ValueFormat
		valueFormatTemp := genruntime.ToEnum(valueFormat, apiKeyAuthWorkspaceConnectionProperties_ValueFormat_Values)
		properties.ValueFormat = &valueFormatTemp
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApiKeyAuthWorkspaceConnectionProperties populates the provided destination ApiKeyAuthWorkspaceConnectionProperties from our ApiKeyAuthWorkspaceConnectionProperties
func (properties *ApiKeyAuthWorkspaceConnectionProperties) AssignProperties_To_ApiKeyAuthWorkspaceConnectionProperties(destination *storage.ApiKeyAuthWorkspaceConnectionProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthType
	if properties.AuthType != nil {
		authType := string(*properties.AuthType)
		destination.AuthType = &authType
	} else {
		destination.AuthType = nil
	}

	// Category
	if properties.Category != nil {
		category := string(*properties.Category)
		destination.Category = &category
	} else {
		destination.Category = nil
	}

	// Credentials
	if properties.Credentials != nil {
		var credential storage.WorkspaceConnectionApiKey
		err := properties.Credentials.AssignProperties_To_WorkspaceConnectionApiKey(&credential)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WorkspaceConnectionApiKey() to populate field Credentials")
		}
		destination.Credentials = &credential
	} else {
		destination.Credentials = nil
	}

	// ExpiryTime
	destination.ExpiryTime = genruntime.ClonePointerToString(properties.ExpiryTime)

	// IsSharedToAll
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		destination.IsSharedToAll = &isSharedToAll
	} else {
		destination.IsSharedToAll = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(properties.Metadata)

	// SharedUserList
	destination.SharedUserList = genruntime.CloneSliceOfString(properties.SharedUserList)

	// Target
	destination.Target = genruntime.ClonePointerToString(properties.Target)

	// Value
	destination.Value = genruntime.ClonePointerToString(properties.Value)

	// ValueFormat
	if properties.ValueFormat != nil {
		valueFormat := string(*properties.ValueFormat)
		destination.ValueFormat = &valueFormat
	} else {
		destination.ValueFormat = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApiKeyAuthWorkspaceConnectionProperties_STATUS populates our ApiKeyAuthWorkspaceConnectionProperties from the provided source ApiKeyAuthWorkspaceConnectionProperties_STATUS
func (properties *ApiKeyAuthWorkspaceConnectionProperties) Initialize_From_ApiKeyAuthWorkspaceConnectionProperties_STATUS(source *ApiKeyAuthWorkspaceConnectionProperties_STATUS) error {

	// AuthType
	if source.AuthType != nil {
		authType := genruntime.ToEnum(string(*source.AuthType), apiKeyAuthWorkspaceConnectionProperties_AuthType_Values)
		properties.AuthType = &authType
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := genruntime.ToEnum(string(*source.Category), connectionCategory_Values)
		properties.Category = &category
	} else {
		properties.Category = nil
	}

	// Credentials
	if source.Credentials != nil {
		var credential WorkspaceConnectionApiKey
		err := credential.Initialize_From_WorkspaceConnectionApiKey_STATUS(source.Credentials)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_WorkspaceConnectionApiKey_STATUS() to populate field Credentials")
		}
		properties.Credentials = &credential
	} else {
		properties.Credentials = nil
	}

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := genruntime.ToEnum(string(*source.ValueFormat), apiKeyAuthWorkspaceConnectionProperties_ValueFormat_Values)
		properties.ValueFormat = &valueFormat
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

type ApiKeyAuthWorkspaceConnectionProperties_STATUS struct {
	// AuthType: Authentication type of the connection target
	AuthType *ApiKeyAuthWorkspaceConnectionProperties_AuthType_STATUS `json:"authType,omitempty"`

	// Category: Category of the connection
	Category                *ConnectionCategory_STATUS `json:"category,omitempty"`
	CreatedByWorkspaceArmId *string                    `json:"createdByWorkspaceArmId,omitempty"`

	// Credentials: Api key object for workspace connection credential.
	Credentials *WorkspaceConnectionApiKey_STATUS `json:"credentials,omitempty"`
	ExpiryTime  *string                           `json:"expiryTime,omitempty"`

	// Group: Group based on connection category
	Group         *ConnectionGroup_STATUS `json:"group,omitempty"`
	IsSharedToAll *bool                   `json:"isSharedToAll,omitempty"`

	// Metadata: Store user metadata for this connection
	Metadata       map[string]string `json:"metadata,omitempty"`
	SharedUserList []string          `json:"sharedUserList,omitempty"`
	Target         *string           `json:"target,omitempty"`

	// Value: Value details of the workspace connection.
	Value *string `json:"value,omitempty"`

	// ValueFormat: format for the workspace connection value
	ValueFormat *ApiKeyAuthWorkspaceConnectionProperties_ValueFormat_STATUS `json:"valueFormat,omitempty"`
}

var _ genruntime.FromARMConverter = &ApiKeyAuthWorkspaceConnectionProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *ApiKeyAuthWorkspaceConnectionProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApiKeyAuthWorkspaceConnectionProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *ApiKeyAuthWorkspaceConnectionProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApiKeyAuthWorkspaceConnectionProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApiKeyAuthWorkspaceConnectionProperties_STATUS, got %T", armInput)
	}

	// Set property "AuthType":
	var temp ApiKeyAuthWorkspaceConnectionProperties_AuthType_STATUS
	var temp1 string
	temp1 = string(typedInput.AuthType)
	temp = ApiKeyAuthWorkspaceConnectionProperties_AuthType_STATUS(temp1)
	properties.AuthType = &temp

	// Set property "Category":
	if typedInput.Category != nil {
		var categoryTemp string
		categoryTemp = string(*typedInput.Category)
		category := ConnectionCategory_STATUS(categoryTemp)
		properties.Category = &category
	}

	// Set property "CreatedByWorkspaceArmId":
	if typedInput.CreatedByWorkspaceArmId != nil {
		createdByWorkspaceArmId := *typedInput.CreatedByWorkspaceArmId
		properties.CreatedByWorkspaceArmId = &createdByWorkspaceArmId
	}

	// Set property "Credentials":
	if typedInput.Credentials != nil {
		var credentials1 WorkspaceConnectionApiKey_STATUS
		err := credentials1.PopulateFromARM(owner, *typedInput.Credentials)
		if err != nil {
			return err
		}
		credentials := credentials1
		properties.Credentials = &credentials
	}

	// Set property "ExpiryTime":
	if typedInput.ExpiryTime != nil {
		expiryTime := *typedInput.ExpiryTime
		properties.ExpiryTime = &expiryTime
	}

	// Set property "Group":
	if typedInput.Group != nil {
		var groupTemp string
		groupTemp = string(*typedInput.Group)
		group := ConnectionGroup_STATUS(groupTemp)
		properties.Group = &group
	}

	// Set property "IsSharedToAll":
	if typedInput.IsSharedToAll != nil {
		isSharedToAll := *typedInput.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if typedInput.Metadata != nil {
		properties.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			properties.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range typedInput.SharedUserList {
		properties.SharedUserList = append(properties.SharedUserList, item)
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		properties.Target = &target
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		properties.Value = &value
	}

	// Set property "ValueFormat":
	if typedInput.ValueFormat != nil {
		var valueFormatTemp string
		valueFormatTemp = string(*typedInput.ValueFormat)
		valueFormat := ApiKeyAuthWorkspaceConnectionProperties_ValueFormat_STATUS(valueFormatTemp)
		properties.ValueFormat = &valueFormat
	}

	// No error
	return nil
}

// AssignProperties_From_ApiKeyAuthWorkspaceConnectionProperties_STATUS populates our ApiKeyAuthWorkspaceConnectionProperties_STATUS from the provided source ApiKeyAuthWorkspaceConnectionProperties_STATUS
func (properties *ApiKeyAuthWorkspaceConnectionProperties_STATUS) AssignProperties_From_ApiKeyAuthWorkspaceConnectionProperties_STATUS(source *storage.ApiKeyAuthWorkspaceConnectionProperties_STATUS) error {

	// AuthType
	if source.AuthType != nil {
		authType := *source.AuthType
		authTypeTemp := genruntime.ToEnum(authType, apiKeyAuthWorkspaceConnectionProperties_AuthType_STATUS_Values)
		properties.AuthType = &authTypeTemp
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := *source.Category
		categoryTemp := genruntime.ToEnum(category, connectionCategory_STATUS_Values)
		properties.Category = &categoryTemp
	} else {
		properties.Category = nil
	}

	// CreatedByWorkspaceArmId
	properties.CreatedByWorkspaceArmId = genruntime.ClonePointerToString(source.CreatedByWorkspaceArmId)

	// Credentials
	if source.Credentials != nil {
		var credential WorkspaceConnectionApiKey_STATUS
		err := credential.AssignProperties_From_WorkspaceConnectionApiKey_STATUS(source.Credentials)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WorkspaceConnectionApiKey_STATUS() to populate field Credentials")
		}
		properties.Credentials = &credential
	} else {
		properties.Credentials = nil
	}

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// Group
	if source.Group != nil {
		group := *source.Group
		groupTemp := genruntime.ToEnum(group, connectionGroup_STATUS_Values)
		properties.Group = &groupTemp
	} else {
		properties.Group = nil
	}

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := *source.ValueFormat
		valueFormatTemp := genruntime.ToEnum(valueFormat, apiKeyAuthWorkspaceConnectionProperties_ValueFormat_STATUS_Values)
		properties.ValueFormat = &valueFormatTemp
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApiKeyAuthWorkspaceConnectionProperties_STATUS populates the provided destination ApiKeyAuthWorkspaceConnectionProperties_STATUS from our ApiKeyAuthWorkspaceConnectionProperties_STATUS
func (properties *ApiKeyAuthWorkspaceConnectionProperties_STATUS) AssignProperties_To_ApiKeyAuthWorkspaceConnectionProperties_STATUS(destination *storage.ApiKeyAuthWorkspaceConnectionProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthType
	if properties.AuthType != nil {
		authType := string(*properties.AuthType)
		destination.AuthType = &authType
	} else {
		destination.AuthType = nil
	}

	// Category
	if properties.Category != nil {
		category := string(*properties.Category)
		destination.Category = &category
	} else {
		destination.Category = nil
	}

	// CreatedByWorkspaceArmId
	destination.CreatedByWorkspaceArmId = genruntime.ClonePointerToString(properties.CreatedByWorkspaceArmId)

	// Credentials
	if properties.Credentials != nil {
		var credential storage.WorkspaceConnectionApiKey_STATUS
		err := properties.Credentials.AssignProperties_To_WorkspaceConnectionApiKey_STATUS(&credential)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WorkspaceConnectionApiKey_STATUS() to populate field Credentials")
		}
		destination.Credentials = &credential
	} else {
		destination.Credentials = nil
	}

	// ExpiryTime
	destination.ExpiryTime = genruntime.ClonePointerToString(properties.ExpiryTime)

	// Group
	if properties.Group != nil {
		group := string(*properties.Group)
		destination.Group = &group
	} else {
		destination.Group = nil
	}

	// IsSharedToAll
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		destination.IsSharedToAll = &isSharedToAll
	} else {
		destination.IsSharedToAll = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(properties.Metadata)

	// SharedUserList
	destination.SharedUserList = genruntime.CloneSliceOfString(properties.SharedUserList)

	// Target
	destination.Target = genruntime.ClonePointerToString(properties.Target)

	// Value
	destination.Value = genruntime.ClonePointerToString(properties.Value)

	// ValueFormat
	if properties.ValueFormat != nil {
		valueFormat := string(*properties.ValueFormat)
		destination.ValueFormat = &valueFormat
	} else {
		destination.ValueFormat = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type CustomKeysWorkspaceConnectionProperties struct {
	// +kubebuilder:validation:Required
	// AuthType: Authentication type of the connection target
	AuthType *CustomKeysWorkspaceConnectionProperties_AuthType `json:"authType,omitempty"`

	// Category: Category of the connection
	Category *ConnectionCategory `json:"category,omitempty"`

	// Credentials: Custom Keys credential object
	Credentials   *CustomKeys `json:"credentials,omitempty"`
	ExpiryTime    *string     `json:"expiryTime,omitempty"`
	IsSharedToAll *bool       `json:"isSharedToAll,omitempty"`

	// Metadata: Store user metadata for this connection
	Metadata       map[string]string `json:"metadata,omitempty"`
	SharedUserList []string          `json:"sharedUserList,omitempty"`
	Target         *string           `json:"target,omitempty"`

	// Value: Value details of the workspace connection.
	Value *string `json:"value,omitempty"`

	// ValueFormat: format for the workspace connection value
	ValueFormat *CustomKeysWorkspaceConnectionProperties_ValueFormat `json:"valueFormat,omitempty"`
}

var _ genruntime.ARMTransformer = &CustomKeysWorkspaceConnectionProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *CustomKeysWorkspaceConnectionProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.CustomKeysWorkspaceConnectionProperties{}

	// Set property "AuthType":
	if properties.AuthType != nil {
		var temp arm.CustomKeysWorkspaceConnectionProperties_AuthType
		var temp1 string
		temp1 = string(*properties.AuthType)
		temp = arm.CustomKeysWorkspaceConnectionProperties_AuthType(temp1)
		result.AuthType = temp
	}

	// Set property "Category":
	if properties.Category != nil {
		var temp string
		temp = string(*properties.Category)
		category := arm.ConnectionCategory(temp)
		result.Category = &category
	}

	// Set property "Credentials":
	if properties.Credentials != nil {
		credentials_ARM, err := (*properties.Credentials).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		credentials := *credentials_ARM.(*arm.CustomKeys)
		result.Credentials = &credentials
	}

	// Set property "ExpiryTime":
	if properties.ExpiryTime != nil {
		expiryTime := *properties.ExpiryTime
		result.ExpiryTime = &expiryTime
	}

	// Set property "IsSharedToAll":
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		result.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if properties.Metadata != nil {
		result.Metadata = make(map[string]string, len(properties.Metadata))
		for key, value := range properties.Metadata {
			result.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range properties.SharedUserList {
		result.SharedUserList = append(result.SharedUserList, item)
	}

	// Set property "Target":
	if properties.Target != nil {
		target := *properties.Target
		result.Target = &target
	}

	// Set property "Value":
	if properties.Value != nil {
		value := *properties.Value
		result.Value = &value
	}

	// Set property "ValueFormat":
	if properties.ValueFormat != nil {
		var temp string
		temp = string(*properties.ValueFormat)
		valueFormat := arm.CustomKeysWorkspaceConnectionProperties_ValueFormat(temp)
		result.ValueFormat = &valueFormat
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *CustomKeysWorkspaceConnectionProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CustomKeysWorkspaceConnectionProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *CustomKeysWorkspaceConnectionProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CustomKeysWorkspaceConnectionProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CustomKeysWorkspaceConnectionProperties, got %T", armInput)
	}

	// Set property "AuthType":
	var temp CustomKeysWorkspaceConnectionProperties_AuthType
	var temp1 string
	temp1 = string(typedInput.AuthType)
	temp = CustomKeysWorkspaceConnectionProperties_AuthType(temp1)
	properties.AuthType = &temp

	// Set property "Category":
	if typedInput.Category != nil {
		var categoryTemp string
		categoryTemp = string(*typedInput.Category)
		category := ConnectionCategory(categoryTemp)
		properties.Category = &category
	}

	// Set property "Credentials":
	if typedInput.Credentials != nil {
		var credentials1 CustomKeys
		err := credentials1.PopulateFromARM(owner, *typedInput.Credentials)
		if err != nil {
			return err
		}
		credentials := credentials1
		properties.Credentials = &credentials
	}

	// Set property "ExpiryTime":
	if typedInput.ExpiryTime != nil {
		expiryTime := *typedInput.ExpiryTime
		properties.ExpiryTime = &expiryTime
	}

	// Set property "IsSharedToAll":
	if typedInput.IsSharedToAll != nil {
		isSharedToAll := *typedInput.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if typedInput.Metadata != nil {
		properties.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			properties.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range typedInput.SharedUserList {
		properties.SharedUserList = append(properties.SharedUserList, item)
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		properties.Target = &target
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		properties.Value = &value
	}

	// Set property "ValueFormat":
	if typedInput.ValueFormat != nil {
		var valueFormatTemp string
		valueFormatTemp = string(*typedInput.ValueFormat)
		valueFormat := CustomKeysWorkspaceConnectionProperties_ValueFormat(valueFormatTemp)
		properties.ValueFormat = &valueFormat
	}

	// No error
	return nil
}

// AssignProperties_From_CustomKeysWorkspaceConnectionProperties populates our CustomKeysWorkspaceConnectionProperties from the provided source CustomKeysWorkspaceConnectionProperties
func (properties *CustomKeysWorkspaceConnectionProperties) AssignProperties_From_CustomKeysWorkspaceConnectionProperties(source *storage.CustomKeysWorkspaceConnectionProperties) error {

	// AuthType
	if source.AuthType != nil {
		authType := *source.AuthType
		authTypeTemp := genruntime.ToEnum(authType, customKeysWorkspaceConnectionProperties_AuthType_Values)
		properties.AuthType = &authTypeTemp
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := *source.Category
		categoryTemp := genruntime.ToEnum(category, connectionCategory_Values)
		properties.Category = &categoryTemp
	} else {
		properties.Category = nil
	}

	// Credentials
	if source.Credentials != nil {
		var credential CustomKeys
		err := credential.AssignProperties_From_CustomKeys(source.Credentials)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CustomKeys() to populate field Credentials")
		}
		properties.Credentials = &credential
	} else {
		properties.Credentials = nil
	}

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := *source.ValueFormat
		valueFormatTemp := genruntime.ToEnum(valueFormat, customKeysWorkspaceConnectionProperties_ValueFormat_Values)
		properties.ValueFormat = &valueFormatTemp
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CustomKeysWorkspaceConnectionProperties populates the provided destination CustomKeysWorkspaceConnectionProperties from our CustomKeysWorkspaceConnectionProperties
func (properties *CustomKeysWorkspaceConnectionProperties) AssignProperties_To_CustomKeysWorkspaceConnectionProperties(destination *storage.CustomKeysWorkspaceConnectionProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthType
	if properties.AuthType != nil {
		authType := string(*properties.AuthType)
		destination.AuthType = &authType
	} else {
		destination.AuthType = nil
	}

	// Category
	if properties.Category != nil {
		category := string(*properties.Category)
		destination.Category = &category
	} else {
		destination.Category = nil
	}

	// Credentials
	if properties.Credentials != nil {
		var credential storage.CustomKeys
		err := properties.Credentials.AssignProperties_To_CustomKeys(&credential)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CustomKeys() to populate field Credentials")
		}
		destination.Credentials = &credential
	} else {
		destination.Credentials = nil
	}

	// ExpiryTime
	destination.ExpiryTime = genruntime.ClonePointerToString(properties.ExpiryTime)

	// IsSharedToAll
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		destination.IsSharedToAll = &isSharedToAll
	} else {
		destination.IsSharedToAll = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(properties.Metadata)

	// SharedUserList
	destination.SharedUserList = genruntime.CloneSliceOfString(properties.SharedUserList)

	// Target
	destination.Target = genruntime.ClonePointerToString(properties.Target)

	// Value
	destination.Value = genruntime.ClonePointerToString(properties.Value)

	// ValueFormat
	if properties.ValueFormat != nil {
		valueFormat := string(*properties.ValueFormat)
		destination.ValueFormat = &valueFormat
	} else {
		destination.ValueFormat = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_CustomKeysWorkspaceConnectionProperties_STATUS populates our CustomKeysWorkspaceConnectionProperties from the provided source CustomKeysWorkspaceConnectionProperties_STATUS
func (properties *CustomKeysWorkspaceConnectionProperties) Initialize_From_CustomKeysWorkspaceConnectionProperties_STATUS(source *CustomKeysWorkspaceConnectionProperties_STATUS) error {

	// AuthType
	if source.AuthType != nil {
		authType := genruntime.ToEnum(string(*source.AuthType), customKeysWorkspaceConnectionProperties_AuthType_Values)
		properties.AuthType = &authType
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := genruntime.ToEnum(string(*source.Category), connectionCategory_Values)
		properties.Category = &category
	} else {
		properties.Category = nil
	}

	// Credentials
	if source.Credentials != nil {
		var credential CustomKeys
		err := credential.Initialize_From_CustomKeys_STATUS(source.Credentials)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_CustomKeys_STATUS() to populate field Credentials")
		}
		properties.Credentials = &credential
	} else {
		properties.Credentials = nil
	}

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := genruntime.ToEnum(string(*source.ValueFormat), customKeysWorkspaceConnectionProperties_ValueFormat_Values)
		properties.ValueFormat = &valueFormat
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

type CustomKeysWorkspaceConnectionProperties_STATUS struct {
	// AuthType: Authentication type of the connection target
	AuthType *CustomKeysWorkspaceConnectionProperties_AuthType_STATUS `json:"authType,omitempty"`

	// Category: Category of the connection
	Category                *ConnectionCategory_STATUS `json:"category,omitempty"`
	CreatedByWorkspaceArmId *string                    `json:"createdByWorkspaceArmId,omitempty"`

	// Credentials: Custom Keys credential object
	Credentials *CustomKeys_STATUS `json:"credentials,omitempty"`
	ExpiryTime  *string            `json:"expiryTime,omitempty"`

	// Group: Group based on connection category
	Group         *ConnectionGroup_STATUS `json:"group,omitempty"`
	IsSharedToAll *bool                   `json:"isSharedToAll,omitempty"`

	// Metadata: Store user metadata for this connection
	Metadata       map[string]string `json:"metadata,omitempty"`
	SharedUserList []string          `json:"sharedUserList,omitempty"`
	Target         *string           `json:"target,omitempty"`

	// Value: Value details of the workspace connection.
	Value *string `json:"value,omitempty"`

	// ValueFormat: format for the workspace connection value
	ValueFormat *CustomKeysWorkspaceConnectionProperties_ValueFormat_STATUS `json:"valueFormat,omitempty"`
}

var _ genruntime.FromARMConverter = &CustomKeysWorkspaceConnectionProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *CustomKeysWorkspaceConnectionProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CustomKeysWorkspaceConnectionProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *CustomKeysWorkspaceConnectionProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CustomKeysWorkspaceConnectionProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CustomKeysWorkspaceConnectionProperties_STATUS, got %T", armInput)
	}

	// Set property "AuthType":
	var temp CustomKeysWorkspaceConnectionProperties_AuthType_STATUS
	var temp1 string
	temp1 = string(typedInput.AuthType)
	temp = CustomKeysWorkspaceConnectionProperties_AuthType_STATUS(temp1)
	properties.AuthType = &temp

	// Set property "Category":
	if typedInput.Category != nil {
		var categoryTemp string
		categoryTemp = string(*typedInput.Category)
		category := ConnectionCategory_STATUS(categoryTemp)
		properties.Category = &category
	}

	// Set property "CreatedByWorkspaceArmId":
	if typedInput.CreatedByWorkspaceArmId != nil {
		createdByWorkspaceArmId := *typedInput.CreatedByWorkspaceArmId
		properties.CreatedByWorkspaceArmId = &createdByWorkspaceArmId
	}

	// Set property "Credentials":
	if typedInput.Credentials != nil {
		var credentials1 CustomKeys_STATUS
		err := credentials1.PopulateFromARM(owner, *typedInput.Credentials)
		if err != nil {
			return err
		}
		credentials := credentials1
		properties.Credentials = &credentials
	}

	// Set property "ExpiryTime":
	if typedInput.ExpiryTime != nil {
		expiryTime := *typedInput.ExpiryTime
		properties.ExpiryTime = &expiryTime
	}

	// Set property "Group":
	if typedInput.Group != nil {
		var groupTemp string
		groupTemp = string(*typedInput.Group)
		group := ConnectionGroup_STATUS(groupTemp)
		properties.Group = &group
	}

	// Set property "IsSharedToAll":
	if typedInput.IsSharedToAll != nil {
		isSharedToAll := *typedInput.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if typedInput.Metadata != nil {
		properties.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			properties.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range typedInput.SharedUserList {
		properties.SharedUserList = append(properties.SharedUserList, item)
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		properties.Target = &target
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		properties.Value = &value
	}

	// Set property "ValueFormat":
	if typedInput.ValueFormat != nil {
		var valueFormatTemp string
		valueFormatTemp = string(*typedInput.ValueFormat)
		valueFormat := CustomKeysWorkspaceConnectionProperties_ValueFormat_STATUS(valueFormatTemp)
		properties.ValueFormat = &valueFormat
	}

	// No error
	return nil
}

// AssignProperties_From_CustomKeysWorkspaceConnectionProperties_STATUS populates our CustomKeysWorkspaceConnectionProperties_STATUS from the provided source CustomKeysWorkspaceConnectionProperties_STATUS
func (properties *CustomKeysWorkspaceConnectionProperties_STATUS) AssignProperties_From_CustomKeysWorkspaceConnectionProperties_STATUS(source *storage.CustomKeysWorkspaceConnectionProperties_STATUS) error {

	// AuthType
	if source.AuthType != nil {
		authType := *source.AuthType
		authTypeTemp := genruntime.ToEnum(authType, customKeysWorkspaceConnectionProperties_AuthType_STATUS_Values)
		properties.AuthType = &authTypeTemp
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := *source.Category
		categoryTemp := genruntime.ToEnum(category, connectionCategory_STATUS_Values)
		properties.Category = &categoryTemp
	} else {
		properties.Category = nil
	}

	// CreatedByWorkspaceArmId
	properties.CreatedByWorkspaceArmId = genruntime.ClonePointerToString(source.CreatedByWorkspaceArmId)

	// Credentials
	if source.Credentials != nil {
		var credential CustomKeys_STATUS
		err := credential.AssignProperties_From_CustomKeys_STATUS(source.Credentials)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CustomKeys_STATUS() to populate field Credentials")
		}
		properties.Credentials = &credential
	} else {
		properties.Credentials = nil
	}

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// Group
	if source.Group != nil {
		group := *source.Group
		groupTemp := genruntime.ToEnum(group, connectionGroup_STATUS_Values)
		properties.Group = &groupTemp
	} else {
		properties.Group = nil
	}

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := *source.ValueFormat
		valueFormatTemp := genruntime.ToEnum(valueFormat, customKeysWorkspaceConnectionProperties_ValueFormat_STATUS_Values)
		properties.ValueFormat = &valueFormatTemp
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CustomKeysWorkspaceConnectionProperties_STATUS populates the provided destination CustomKeysWorkspaceConnectionProperties_STATUS from our CustomKeysWorkspaceConnectionProperties_STATUS
func (properties *CustomKeysWorkspaceConnectionProperties_STATUS) AssignProperties_To_CustomKeysWorkspaceConnectionProperties_STATUS(destination *storage.CustomKeysWorkspaceConnectionProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthType
	if properties.AuthType != nil {
		authType := string(*properties.AuthType)
		destination.AuthType = &authType
	} else {
		destination.AuthType = nil
	}

	// Category
	if properties.Category != nil {
		category := string(*properties.Category)
		destination.Category = &category
	} else {
		destination.Category = nil
	}

	// CreatedByWorkspaceArmId
	destination.CreatedByWorkspaceArmId = genruntime.ClonePointerToString(properties.CreatedByWorkspaceArmId)

	// Credentials
	if properties.Credentials != nil {
		var credential storage.CustomKeys_STATUS
		err := properties.Credentials.AssignProperties_To_CustomKeys_STATUS(&credential)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CustomKeys_STATUS() to populate field Credentials")
		}
		destination.Credentials = &credential
	} else {
		destination.Credentials = nil
	}

	// ExpiryTime
	destination.ExpiryTime = genruntime.ClonePointerToString(properties.ExpiryTime)

	// Group
	if properties.Group != nil {
		group := string(*properties.Group)
		destination.Group = &group
	} else {
		destination.Group = nil
	}

	// IsSharedToAll
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		destination.IsSharedToAll = &isSharedToAll
	} else {
		destination.IsSharedToAll = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(properties.Metadata)

	// SharedUserList
	destination.SharedUserList = genruntime.CloneSliceOfString(properties.SharedUserList)

	// Target
	destination.Target = genruntime.ClonePointerToString(properties.Target)

	// Value
	destination.Value = genruntime.ClonePointerToString(properties.Value)

	// ValueFormat
	if properties.ValueFormat != nil {
		valueFormat := string(*properties.ValueFormat)
		destination.ValueFormat = &valueFormat
	} else {
		destination.ValueFormat = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedIdentityAuthTypeWorkspaceConnectionProperties struct {
	// +kubebuilder:validation:Required
	// AuthType: Authentication type of the connection target
	AuthType *ManagedIdentityAuthTypeWorkspaceConnectionProperties_AuthType `json:"authType,omitempty"`

	// Category: Category of the connection
	Category      *ConnectionCategory                 `json:"category,omitempty"`
	Credentials   *WorkspaceConnectionManagedIdentity `json:"credentials,omitempty"`
	ExpiryTime    *string                             `json:"expiryTime,omitempty"`
	IsSharedToAll *bool                               `json:"isSharedToAll,omitempty"`

	// Metadata: Store user metadata for this connection
	Metadata       map[string]string `json:"metadata,omitempty"`
	SharedUserList []string          `json:"sharedUserList,omitempty"`
	Target         *string           `json:"target,omitempty"`

	// Value: Value details of the workspace connection.
	Value *string `json:"value,omitempty"`

	// ValueFormat: format for the workspace connection value
	ValueFormat *ManagedIdentityAuthTypeWorkspaceConnectionProperties_ValueFormat `json:"valueFormat,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedIdentityAuthTypeWorkspaceConnectionProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *ManagedIdentityAuthTypeWorkspaceConnectionProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.ManagedIdentityAuthTypeWorkspaceConnectionProperties{}

	// Set property "AuthType":
	if properties.AuthType != nil {
		var temp arm.ManagedIdentityAuthTypeWorkspaceConnectionProperties_AuthType
		var temp1 string
		temp1 = string(*properties.AuthType)
		temp = arm.ManagedIdentityAuthTypeWorkspaceConnectionProperties_AuthType(temp1)
		result.AuthType = temp
	}

	// Set property "Category":
	if properties.Category != nil {
		var temp string
		temp = string(*properties.Category)
		category := arm.ConnectionCategory(temp)
		result.Category = &category
	}

	// Set property "Credentials":
	if properties.Credentials != nil {
		credentials_ARM, err := (*properties.Credentials).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		credentials := *credentials_ARM.(*arm.WorkspaceConnectionManagedIdentity)
		result.Credentials = &credentials
	}

	// Set property "ExpiryTime":
	if properties.ExpiryTime != nil {
		expiryTime := *properties.ExpiryTime
		result.ExpiryTime = &expiryTime
	}

	// Set property "IsSharedToAll":
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		result.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if properties.Metadata != nil {
		result.Metadata = make(map[string]string, len(properties.Metadata))
		for key, value := range properties.Metadata {
			result.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range properties.SharedUserList {
		result.SharedUserList = append(result.SharedUserList, item)
	}

	// Set property "Target":
	if properties.Target != nil {
		target := *properties.Target
		result.Target = &target
	}

	// Set property "Value":
	if properties.Value != nil {
		value := *properties.Value
		result.Value = &value
	}

	// Set property "ValueFormat":
	if properties.ValueFormat != nil {
		var temp string
		temp = string(*properties.ValueFormat)
		valueFormat := arm.ManagedIdentityAuthTypeWorkspaceConnectionProperties_ValueFormat(temp)
		result.ValueFormat = &valueFormat
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *ManagedIdentityAuthTypeWorkspaceConnectionProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedIdentityAuthTypeWorkspaceConnectionProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *ManagedIdentityAuthTypeWorkspaceConnectionProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedIdentityAuthTypeWorkspaceConnectionProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedIdentityAuthTypeWorkspaceConnectionProperties, got %T", armInput)
	}

	// Set property "AuthType":
	var temp ManagedIdentityAuthTypeWorkspaceConnectionProperties_AuthType
	var temp1 string
	temp1 = string(typedInput.AuthType)
	temp = ManagedIdentityAuthTypeWorkspaceConnectionProperties_AuthType(temp1)
	properties.AuthType = &temp

	// Set property "Category":
	if typedInput.Category != nil {
		var categoryTemp string
		categoryTemp = string(*typedInput.Category)
		category := ConnectionCategory(categoryTemp)
		properties.Category = &category
	}

	// Set property "Credentials":
	if typedInput.Credentials != nil {
		var credentials1 WorkspaceConnectionManagedIdentity
		err := credentials1.PopulateFromARM(owner, *typedInput.Credentials)
		if err != nil {
			return err
		}
		credentials := credentials1
		properties.Credentials = &credentials
	}

	// Set property "ExpiryTime":
	if typedInput.ExpiryTime != nil {
		expiryTime := *typedInput.ExpiryTime
		properties.ExpiryTime = &expiryTime
	}

	// Set property "IsSharedToAll":
	if typedInput.IsSharedToAll != nil {
		isSharedToAll := *typedInput.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if typedInput.Metadata != nil {
		properties.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			properties.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range typedInput.SharedUserList {
		properties.SharedUserList = append(properties.SharedUserList, item)
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		properties.Target = &target
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		properties.Value = &value
	}

	// Set property "ValueFormat":
	if typedInput.ValueFormat != nil {
		var valueFormatTemp string
		valueFormatTemp = string(*typedInput.ValueFormat)
		valueFormat := ManagedIdentityAuthTypeWorkspaceConnectionProperties_ValueFormat(valueFormatTemp)
		properties.ValueFormat = &valueFormat
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedIdentityAuthTypeWorkspaceConnectionProperties populates our ManagedIdentityAuthTypeWorkspaceConnectionProperties from the provided source ManagedIdentityAuthTypeWorkspaceConnectionProperties
func (properties *ManagedIdentityAuthTypeWorkspaceConnectionProperties) AssignProperties_From_ManagedIdentityAuthTypeWorkspaceConnectionProperties(source *storage.ManagedIdentityAuthTypeWorkspaceConnectionProperties) error {

	// AuthType
	if source.AuthType != nil {
		authType := *source.AuthType
		authTypeTemp := genruntime.ToEnum(authType, managedIdentityAuthTypeWorkspaceConnectionProperties_AuthType_Values)
		properties.AuthType = &authTypeTemp
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := *source.Category
		categoryTemp := genruntime.ToEnum(category, connectionCategory_Values)
		properties.Category = &categoryTemp
	} else {
		properties.Category = nil
	}

	// Credentials
	if source.Credentials != nil {
		var credential WorkspaceConnectionManagedIdentity
		err := credential.AssignProperties_From_WorkspaceConnectionManagedIdentity(source.Credentials)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WorkspaceConnectionManagedIdentity() to populate field Credentials")
		}
		properties.Credentials = &credential
	} else {
		properties.Credentials = nil
	}

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := *source.ValueFormat
		valueFormatTemp := genruntime.ToEnum(valueFormat, managedIdentityAuthTypeWorkspaceConnectionProperties_ValueFormat_Values)
		properties.ValueFormat = &valueFormatTemp
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedIdentityAuthTypeWorkspaceConnectionProperties populates the provided destination ManagedIdentityAuthTypeWorkspaceConnectionProperties from our ManagedIdentityAuthTypeWorkspaceConnectionProperties
func (properties *ManagedIdentityAuthTypeWorkspaceConnectionProperties) AssignProperties_To_ManagedIdentityAuthTypeWorkspaceConnectionProperties(destination *storage.ManagedIdentityAuthTypeWorkspaceConnectionProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthType
	if properties.AuthType != nil {
		authType := string(*properties.AuthType)
		destination.AuthType = &authType
	} else {
		destination.AuthType = nil
	}

	// Category
	if properties.Category != nil {
		category := string(*properties.Category)
		destination.Category = &category
	} else {
		destination.Category = nil
	}

	// Credentials
	if properties.Credentials != nil {
		var credential storage.WorkspaceConnectionManagedIdentity
		err := properties.Credentials.AssignProperties_To_WorkspaceConnectionManagedIdentity(&credential)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WorkspaceConnectionManagedIdentity() to populate field Credentials")
		}
		destination.Credentials = &credential
	} else {
		destination.Credentials = nil
	}

	// ExpiryTime
	destination.ExpiryTime = genruntime.ClonePointerToString(properties.ExpiryTime)

	// IsSharedToAll
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		destination.IsSharedToAll = &isSharedToAll
	} else {
		destination.IsSharedToAll = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(properties.Metadata)

	// SharedUserList
	destination.SharedUserList = genruntime.CloneSliceOfString(properties.SharedUserList)

	// Target
	destination.Target = genruntime.ClonePointerToString(properties.Target)

	// Value
	destination.Value = genruntime.ClonePointerToString(properties.Value)

	// ValueFormat
	if properties.ValueFormat != nil {
		valueFormat := string(*properties.ValueFormat)
		destination.ValueFormat = &valueFormat
	} else {
		destination.ValueFormat = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS populates our ManagedIdentityAuthTypeWorkspaceConnectionProperties from the provided source ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS
func (properties *ManagedIdentityAuthTypeWorkspaceConnectionProperties) Initialize_From_ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS(source *ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS) error {

	// AuthType
	if source.AuthType != nil {
		authType := genruntime.ToEnum(string(*source.AuthType), managedIdentityAuthTypeWorkspaceConnectionProperties_AuthType_Values)
		properties.AuthType = &authType
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := genruntime.ToEnum(string(*source.Category), connectionCategory_Values)
		properties.Category = &category
	} else {
		properties.Category = nil
	}

	// Credentials
	if source.Credentials != nil {
		var credential WorkspaceConnectionManagedIdentity
		err := credential.Initialize_From_WorkspaceConnectionManagedIdentity_STATUS(source.Credentials)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_WorkspaceConnectionManagedIdentity_STATUS() to populate field Credentials")
		}
		properties.Credentials = &credential
	} else {
		properties.Credentials = nil
	}

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := genruntime.ToEnum(string(*source.ValueFormat), managedIdentityAuthTypeWorkspaceConnectionProperties_ValueFormat_Values)
		properties.ValueFormat = &valueFormat
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

type ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS struct {
	// AuthType: Authentication type of the connection target
	AuthType *ManagedIdentityAuthTypeWorkspaceConnectionProperties_AuthType_STATUS `json:"authType,omitempty"`

	// Category: Category of the connection
	Category                *ConnectionCategory_STATUS                 `json:"category,omitempty"`
	CreatedByWorkspaceArmId *string                                    `json:"createdByWorkspaceArmId,omitempty"`
	Credentials             *WorkspaceConnectionManagedIdentity_STATUS `json:"credentials,omitempty"`
	ExpiryTime              *string                                    `json:"expiryTime,omitempty"`

	// Group: Group based on connection category
	Group         *ConnectionGroup_STATUS `json:"group,omitempty"`
	IsSharedToAll *bool                   `json:"isSharedToAll,omitempty"`

	// Metadata: Store user metadata for this connection
	Metadata       map[string]string `json:"metadata,omitempty"`
	SharedUserList []string          `json:"sharedUserList,omitempty"`
	Target         *string           `json:"target,omitempty"`

	// Value: Value details of the workspace connection.
	Value *string `json:"value,omitempty"`

	// ValueFormat: format for the workspace connection value
	ValueFormat *ManagedIdentityAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS `json:"valueFormat,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS, got %T", armInput)
	}

	// Set property "AuthType":
	var temp ManagedIdentityAuthTypeWorkspaceConnectionProperties_AuthType_STATUS
	var temp1 string
	temp1 = string(typedInput.AuthType)
	temp = ManagedIdentityAuthTypeWorkspaceConnectionProperties_AuthType_STATUS(temp1)
	properties.AuthType = &temp

	// Set property "Category":
	if typedInput.Category != nil {
		var categoryTemp string
		categoryTemp = string(*typedInput.Category)
		category := ConnectionCategory_STATUS(categoryTemp)
		properties.Category = &category
	}

	// Set property "CreatedByWorkspaceArmId":
	if typedInput.CreatedByWorkspaceArmId != nil {
		createdByWorkspaceArmId := *typedInput.CreatedByWorkspaceArmId
		properties.CreatedByWorkspaceArmId = &createdByWorkspaceArmId
	}

	// Set property "Credentials":
	if typedInput.Credentials != nil {
		var credentials1 WorkspaceConnectionManagedIdentity_STATUS
		err := credentials1.PopulateFromARM(owner, *typedInput.Credentials)
		if err != nil {
			return err
		}
		credentials := credentials1
		properties.Credentials = &credentials
	}

	// Set property "ExpiryTime":
	if typedInput.ExpiryTime != nil {
		expiryTime := *typedInput.ExpiryTime
		properties.ExpiryTime = &expiryTime
	}

	// Set property "Group":
	if typedInput.Group != nil {
		var groupTemp string
		groupTemp = string(*typedInput.Group)
		group := ConnectionGroup_STATUS(groupTemp)
		properties.Group = &group
	}

	// Set property "IsSharedToAll":
	if typedInput.IsSharedToAll != nil {
		isSharedToAll := *typedInput.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if typedInput.Metadata != nil {
		properties.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			properties.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range typedInput.SharedUserList {
		properties.SharedUserList = append(properties.SharedUserList, item)
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		properties.Target = &target
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		properties.Value = &value
	}

	// Set property "ValueFormat":
	if typedInput.ValueFormat != nil {
		var valueFormatTemp string
		valueFormatTemp = string(*typedInput.ValueFormat)
		valueFormat := ManagedIdentityAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS(valueFormatTemp)
		properties.ValueFormat = &valueFormat
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS populates our ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS from the provided source ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS
func (properties *ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS) AssignProperties_From_ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS(source *storage.ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS) error {

	// AuthType
	if source.AuthType != nil {
		authType := *source.AuthType
		authTypeTemp := genruntime.ToEnum(authType, managedIdentityAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_Values)
		properties.AuthType = &authTypeTemp
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := *source.Category
		categoryTemp := genruntime.ToEnum(category, connectionCategory_STATUS_Values)
		properties.Category = &categoryTemp
	} else {
		properties.Category = nil
	}

	// CreatedByWorkspaceArmId
	properties.CreatedByWorkspaceArmId = genruntime.ClonePointerToString(source.CreatedByWorkspaceArmId)

	// Credentials
	if source.Credentials != nil {
		var credential WorkspaceConnectionManagedIdentity_STATUS
		err := credential.AssignProperties_From_WorkspaceConnectionManagedIdentity_STATUS(source.Credentials)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WorkspaceConnectionManagedIdentity_STATUS() to populate field Credentials")
		}
		properties.Credentials = &credential
	} else {
		properties.Credentials = nil
	}

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// Group
	if source.Group != nil {
		group := *source.Group
		groupTemp := genruntime.ToEnum(group, connectionGroup_STATUS_Values)
		properties.Group = &groupTemp
	} else {
		properties.Group = nil
	}

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := *source.ValueFormat
		valueFormatTemp := genruntime.ToEnum(valueFormat, managedIdentityAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_Values)
		properties.ValueFormat = &valueFormatTemp
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS populates the provided destination ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS from our ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS
func (properties *ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS) AssignProperties_To_ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS(destination *storage.ManagedIdentityAuthTypeWorkspaceConnectionProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthType
	if properties.AuthType != nil {
		authType := string(*properties.AuthType)
		destination.AuthType = &authType
	} else {
		destination.AuthType = nil
	}

	// Category
	if properties.Category != nil {
		category := string(*properties.Category)
		destination.Category = &category
	} else {
		destination.Category = nil
	}

	// CreatedByWorkspaceArmId
	destination.CreatedByWorkspaceArmId = genruntime.ClonePointerToString(properties.CreatedByWorkspaceArmId)

	// Credentials
	if properties.Credentials != nil {
		var credential storage.WorkspaceConnectionManagedIdentity_STATUS
		err := properties.Credentials.AssignProperties_To_WorkspaceConnectionManagedIdentity_STATUS(&credential)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WorkspaceConnectionManagedIdentity_STATUS() to populate field Credentials")
		}
		destination.Credentials = &credential
	} else {
		destination.Credentials = nil
	}

	// ExpiryTime
	destination.ExpiryTime = genruntime.ClonePointerToString(properties.ExpiryTime)

	// Group
	if properties.Group != nil {
		group := string(*properties.Group)
		destination.Group = &group
	} else {
		destination.Group = nil
	}

	// IsSharedToAll
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		destination.IsSharedToAll = &isSharedToAll
	} else {
		destination.IsSharedToAll = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(properties.Metadata)

	// SharedUserList
	destination.SharedUserList = genruntime.CloneSliceOfString(properties.SharedUserList)

	// Target
	destination.Target = genruntime.ClonePointerToString(properties.Target)

	// Value
	destination.Value = genruntime.ClonePointerToString(properties.Value)

	// ValueFormat
	if properties.ValueFormat != nil {
		valueFormat := string(*properties.ValueFormat)
		destination.ValueFormat = &valueFormat
	} else {
		destination.ValueFormat = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type NoneAuthTypeWorkspaceConnectionProperties struct {
	// +kubebuilder:validation:Required
	// AuthType: Authentication type of the connection target
	AuthType *NoneAuthTypeWorkspaceConnectionProperties_AuthType `json:"authType,omitempty"`

	// Category: Category of the connection
	Category      *ConnectionCategory `json:"category,omitempty"`
	ExpiryTime    *string             `json:"expiryTime,omitempty"`
	IsSharedToAll *bool               `json:"isSharedToAll,omitempty"`

	// Metadata: Store user metadata for this connection
	Metadata       map[string]string `json:"metadata,omitempty"`
	SharedUserList []string          `json:"sharedUserList,omitempty"`
	Target         *string           `json:"target,omitempty"`

	// Value: Value details of the workspace connection.
	Value *string `json:"value,omitempty"`

	// ValueFormat: format for the workspace connection value
	ValueFormat *NoneAuthTypeWorkspaceConnectionProperties_ValueFormat `json:"valueFormat,omitempty"`
}

var _ genruntime.ARMTransformer = &NoneAuthTypeWorkspaceConnectionProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *NoneAuthTypeWorkspaceConnectionProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.NoneAuthTypeWorkspaceConnectionProperties{}

	// Set property "AuthType":
	if properties.AuthType != nil {
		var temp arm.NoneAuthTypeWorkspaceConnectionProperties_AuthType
		var temp1 string
		temp1 = string(*properties.AuthType)
		temp = arm.NoneAuthTypeWorkspaceConnectionProperties_AuthType(temp1)
		result.AuthType = temp
	}

	// Set property "Category":
	if properties.Category != nil {
		var temp string
		temp = string(*properties.Category)
		category := arm.ConnectionCategory(temp)
		result.Category = &category
	}

	// Set property "ExpiryTime":
	if properties.ExpiryTime != nil {
		expiryTime := *properties.ExpiryTime
		result.ExpiryTime = &expiryTime
	}

	// Set property "IsSharedToAll":
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		result.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if properties.Metadata != nil {
		result.Metadata = make(map[string]string, len(properties.Metadata))
		for key, value := range properties.Metadata {
			result.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range properties.SharedUserList {
		result.SharedUserList = append(result.SharedUserList, item)
	}

	// Set property "Target":
	if properties.Target != nil {
		target := *properties.Target
		result.Target = &target
	}

	// Set property "Value":
	if properties.Value != nil {
		value := *properties.Value
		result.Value = &value
	}

	// Set property "ValueFormat":
	if properties.ValueFormat != nil {
		var temp string
		temp = string(*properties.ValueFormat)
		valueFormat := arm.NoneAuthTypeWorkspaceConnectionProperties_ValueFormat(temp)
		result.ValueFormat = &valueFormat
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *NoneAuthTypeWorkspaceConnectionProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NoneAuthTypeWorkspaceConnectionProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *NoneAuthTypeWorkspaceConnectionProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NoneAuthTypeWorkspaceConnectionProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NoneAuthTypeWorkspaceConnectionProperties, got %T", armInput)
	}

	// Set property "AuthType":
	var temp NoneAuthTypeWorkspaceConnectionProperties_AuthType
	var temp1 string
	temp1 = string(typedInput.AuthType)
	temp = NoneAuthTypeWorkspaceConnectionProperties_AuthType(temp1)
	properties.AuthType = &temp

	// Set property "Category":
	if typedInput.Category != nil {
		var categoryTemp string
		categoryTemp = string(*typedInput.Category)
		category := ConnectionCategory(categoryTemp)
		properties.Category = &category
	}

	// Set property "ExpiryTime":
	if typedInput.ExpiryTime != nil {
		expiryTime := *typedInput.ExpiryTime
		properties.ExpiryTime = &expiryTime
	}

	// Set property "IsSharedToAll":
	if typedInput.IsSharedToAll != nil {
		isSharedToAll := *typedInput.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if typedInput.Metadata != nil {
		properties.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			properties.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range typedInput.SharedUserList {
		properties.SharedUserList = append(properties.SharedUserList, item)
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		properties.Target = &target
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		properties.Value = &value
	}

	// Set property "ValueFormat":
	if typedInput.ValueFormat != nil {
		var valueFormatTemp string
		valueFormatTemp = string(*typedInput.ValueFormat)
		valueFormat := NoneAuthTypeWorkspaceConnectionProperties_ValueFormat(valueFormatTemp)
		properties.ValueFormat = &valueFormat
	}

	// No error
	return nil
}

// AssignProperties_From_NoneAuthTypeWorkspaceConnectionProperties populates our NoneAuthTypeWorkspaceConnectionProperties from the provided source NoneAuthTypeWorkspaceConnectionProperties
func (properties *NoneAuthTypeWorkspaceConnectionProperties) AssignProperties_From_NoneAuthTypeWorkspaceConnectionProperties(source *storage.NoneAuthTypeWorkspaceConnectionProperties) error {

	// AuthType
	if source.AuthType != nil {
		authType := *source.AuthType
		authTypeTemp := genruntime.ToEnum(authType, noneAuthTypeWorkspaceConnectionProperties_AuthType_Values)
		properties.AuthType = &authTypeTemp
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := *source.Category
		categoryTemp := genruntime.ToEnum(category, connectionCategory_Values)
		properties.Category = &categoryTemp
	} else {
		properties.Category = nil
	}

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := *source.ValueFormat
		valueFormatTemp := genruntime.ToEnum(valueFormat, noneAuthTypeWorkspaceConnectionProperties_ValueFormat_Values)
		properties.ValueFormat = &valueFormatTemp
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

// AssignProperties_To_NoneAuthTypeWorkspaceConnectionProperties populates the provided destination NoneAuthTypeWorkspaceConnectionProperties from our NoneAuthTypeWorkspaceConnectionProperties
func (properties *NoneAuthTypeWorkspaceConnectionProperties) AssignProperties_To_NoneAuthTypeWorkspaceConnectionProperties(destination *storage.NoneAuthTypeWorkspaceConnectionProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthType
	if properties.AuthType != nil {
		authType := string(*properties.AuthType)
		destination.AuthType = &authType
	} else {
		destination.AuthType = nil
	}

	// Category
	if properties.Category != nil {
		category := string(*properties.Category)
		destination.Category = &category
	} else {
		destination.Category = nil
	}

	// ExpiryTime
	destination.ExpiryTime = genruntime.ClonePointerToString(properties.ExpiryTime)

	// IsSharedToAll
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		destination.IsSharedToAll = &isSharedToAll
	} else {
		destination.IsSharedToAll = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(properties.Metadata)

	// SharedUserList
	destination.SharedUserList = genruntime.CloneSliceOfString(properties.SharedUserList)

	// Target
	destination.Target = genruntime.ClonePointerToString(properties.Target)

	// Value
	destination.Value = genruntime.ClonePointerToString(properties.Value)

	// ValueFormat
	if properties.ValueFormat != nil {
		valueFormat := string(*properties.ValueFormat)
		destination.ValueFormat = &valueFormat
	} else {
		destination.ValueFormat = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_NoneAuthTypeWorkspaceConnectionProperties_STATUS populates our NoneAuthTypeWorkspaceConnectionProperties from the provided source NoneAuthTypeWorkspaceConnectionProperties_STATUS
func (properties *NoneAuthTypeWorkspaceConnectionProperties) Initialize_From_NoneAuthTypeWorkspaceConnectionProperties_STATUS(source *NoneAuthTypeWorkspaceConnectionProperties_STATUS) error {

	// AuthType
	if source.AuthType != nil {
		authType := genruntime.ToEnum(string(*source.AuthType), noneAuthTypeWorkspaceConnectionProperties_AuthType_Values)
		properties.AuthType = &authType
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := genruntime.ToEnum(string(*source.Category), connectionCategory_Values)
		properties.Category = &category
	} else {
		properties.Category = nil
	}

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := genruntime.ToEnum(string(*source.ValueFormat), noneAuthTypeWorkspaceConnectionProperties_ValueFormat_Values)
		properties.ValueFormat = &valueFormat
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

type NoneAuthTypeWorkspaceConnectionProperties_STATUS struct {
	// AuthType: Authentication type of the connection target
	AuthType *NoneAuthTypeWorkspaceConnectionProperties_AuthType_STATUS `json:"authType,omitempty"`

	// Category: Category of the connection
	Category                *ConnectionCategory_STATUS `json:"category,omitempty"`
	CreatedByWorkspaceArmId *string                    `json:"createdByWorkspaceArmId,omitempty"`
	ExpiryTime              *string                    `json:"expiryTime,omitempty"`

	// Group: Group based on connection category
	Group         *ConnectionGroup_STATUS `json:"group,omitempty"`
	IsSharedToAll *bool                   `json:"isSharedToAll,omitempty"`

	// Metadata: Store user metadata for this connection
	Metadata       map[string]string `json:"metadata,omitempty"`
	SharedUserList []string          `json:"sharedUserList,omitempty"`
	Target         *string           `json:"target,omitempty"`

	// Value: Value details of the workspace connection.
	Value *string `json:"value,omitempty"`

	// ValueFormat: format for the workspace connection value
	ValueFormat *NoneAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS `json:"valueFormat,omitempty"`
}

var _ genruntime.FromARMConverter = &NoneAuthTypeWorkspaceConnectionProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *NoneAuthTypeWorkspaceConnectionProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NoneAuthTypeWorkspaceConnectionProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *NoneAuthTypeWorkspaceConnectionProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NoneAuthTypeWorkspaceConnectionProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NoneAuthTypeWorkspaceConnectionProperties_STATUS, got %T", armInput)
	}

	// Set property "AuthType":
	var temp NoneAuthTypeWorkspaceConnectionProperties_AuthType_STATUS
	var temp1 string
	temp1 = string(typedInput.AuthType)
	temp = NoneAuthTypeWorkspaceConnectionProperties_AuthType_STATUS(temp1)
	properties.AuthType = &temp

	// Set property "Category":
	if typedInput.Category != nil {
		var categoryTemp string
		categoryTemp = string(*typedInput.Category)
		category := ConnectionCategory_STATUS(categoryTemp)
		properties.Category = &category
	}

	// Set property "CreatedByWorkspaceArmId":
	if typedInput.CreatedByWorkspaceArmId != nil {
		createdByWorkspaceArmId := *typedInput.CreatedByWorkspaceArmId
		properties.CreatedByWorkspaceArmId = &createdByWorkspaceArmId
	}

	// Set property "ExpiryTime":
	if typedInput.ExpiryTime != nil {
		expiryTime := *typedInput.ExpiryTime
		properties.ExpiryTime = &expiryTime
	}

	// Set property "Group":
	if typedInput.Group != nil {
		var groupTemp string
		groupTemp = string(*typedInput.Group)
		group := ConnectionGroup_STATUS(groupTemp)
		properties.Group = &group
	}

	// Set property "IsSharedToAll":
	if typedInput.IsSharedToAll != nil {
		isSharedToAll := *typedInput.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if typedInput.Metadata != nil {
		properties.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			properties.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range typedInput.SharedUserList {
		properties.SharedUserList = append(properties.SharedUserList, item)
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		properties.Target = &target
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		properties.Value = &value
	}

	// Set property "ValueFormat":
	if typedInput.ValueFormat != nil {
		var valueFormatTemp string
		valueFormatTemp = string(*typedInput.ValueFormat)
		valueFormat := NoneAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS(valueFormatTemp)
		properties.ValueFormat = &valueFormat
	}

	// No error
	return nil
}

// AssignProperties_From_NoneAuthTypeWorkspaceConnectionProperties_STATUS populates our NoneAuthTypeWorkspaceConnectionProperties_STATUS from the provided source NoneAuthTypeWorkspaceConnectionProperties_STATUS
func (properties *NoneAuthTypeWorkspaceConnectionProperties_STATUS) AssignProperties_From_NoneAuthTypeWorkspaceConnectionProperties_STATUS(source *storage.NoneAuthTypeWorkspaceConnectionProperties_STATUS) error {

	// AuthType
	if source.AuthType != nil {
		authType := *source.AuthType
		authTypeTemp := genruntime.ToEnum(authType, noneAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_Values)
		properties.AuthType = &authTypeTemp
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := *source.Category
		categoryTemp := genruntime.ToEnum(category, connectionCategory_STATUS_Values)
		properties.Category = &categoryTemp
	} else {
		properties.Category = nil
	}

	// CreatedByWorkspaceArmId
	properties.CreatedByWorkspaceArmId = genruntime.ClonePointerToString(source.CreatedByWorkspaceArmId)

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// Group
	if source.Group != nil {
		group := *source.Group
		groupTemp := genruntime.ToEnum(group, connectionGroup_STATUS_Values)
		properties.Group = &groupTemp
	} else {
		properties.Group = nil
	}

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := *source.ValueFormat
		valueFormatTemp := genruntime.ToEnum(valueFormat, noneAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_Values)
		properties.ValueFormat = &valueFormatTemp
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

// AssignProperties_To_NoneAuthTypeWorkspaceConnectionProperties_STATUS populates the provided destination NoneAuthTypeWorkspaceConnectionProperties_STATUS from our NoneAuthTypeWorkspaceConnectionProperties_STATUS
func (properties *NoneAuthTypeWorkspaceConnectionProperties_STATUS) AssignProperties_To_NoneAuthTypeWorkspaceConnectionProperties_STATUS(destination *storage.NoneAuthTypeWorkspaceConnectionProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthType
	if properties.AuthType != nil {
		authType := string(*properties.AuthType)
		destination.AuthType = &authType
	} else {
		destination.AuthType = nil
	}

	// Category
	if properties.Category != nil {
		category := string(*properties.Category)
		destination.Category = &category
	} else {
		destination.Category = nil
	}

	// CreatedByWorkspaceArmId
	destination.CreatedByWorkspaceArmId = genruntime.ClonePointerToString(properties.CreatedByWorkspaceArmId)

	// ExpiryTime
	destination.ExpiryTime = genruntime.ClonePointerToString(properties.ExpiryTime)

	// Group
	if properties.Group != nil {
		group := string(*properties.Group)
		destination.Group = &group
	} else {
		destination.Group = nil
	}

	// IsSharedToAll
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		destination.IsSharedToAll = &isSharedToAll
	} else {
		destination.IsSharedToAll = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(properties.Metadata)

	// SharedUserList
	destination.SharedUserList = genruntime.CloneSliceOfString(properties.SharedUserList)

	// Target
	destination.Target = genruntime.ClonePointerToString(properties.Target)

	// Value
	destination.Value = genruntime.ClonePointerToString(properties.Value)

	// ValueFormat
	if properties.ValueFormat != nil {
		valueFormat := string(*properties.ValueFormat)
		destination.ValueFormat = &valueFormat
	} else {
		destination.ValueFormat = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type OAuth2AuthTypeWorkspaceConnectionProperties struct {
	// +kubebuilder:validation:Required
	// AuthType: Authentication type of the connection target
	AuthType *OAuth2AuthTypeWorkspaceConnectionProperties_AuthType `json:"authType,omitempty"`

	// Category: Category of the connection
	Category *ConnectionCategory `json:"category,omitempty"`

	// Credentials: ClientId and ClientSecret are required. Other properties are optional
	// depending on each OAuth2 provider's  implementation.
	Credentials   *WorkspaceConnectionOAuth2 `json:"credentials,omitempty"`
	ExpiryTime    *string                    `json:"expiryTime,omitempty"`
	IsSharedToAll *bool                      `json:"isSharedToAll,omitempty"`

	// Metadata: Store user metadata for this connection
	Metadata       map[string]string `json:"metadata,omitempty"`
	SharedUserList []string          `json:"sharedUserList,omitempty"`
	Target         *string           `json:"target,omitempty"`

	// Value: Value details of the workspace connection.
	Value *string `json:"value,omitempty"`

	// ValueFormat: format for the workspace connection value
	ValueFormat *OAuth2AuthTypeWorkspaceConnectionProperties_ValueFormat `json:"valueFormat,omitempty"`
}

var _ genruntime.ARMTransformer = &OAuth2AuthTypeWorkspaceConnectionProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *OAuth2AuthTypeWorkspaceConnectionProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.OAuth2AuthTypeWorkspaceConnectionProperties{}

	// Set property "AuthType":
	if properties.AuthType != nil {
		var temp arm.OAuth2AuthTypeWorkspaceConnectionProperties_AuthType
		var temp1 string
		temp1 = string(*properties.AuthType)
		temp = arm.OAuth2AuthTypeWorkspaceConnectionProperties_AuthType(temp1)
		result.AuthType = temp
	}

	// Set property "Category":
	if properties.Category != nil {
		var temp string
		temp = string(*properties.Category)
		category := arm.ConnectionCategory(temp)
		result.Category = &category
	}

	// Set property "Credentials":
	if properties.Credentials != nil {
		credentials_ARM, err := (*properties.Credentials).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		credentials := *credentials_ARM.(*arm.WorkspaceConnectionOAuth2)
		result.Credentials = &credentials
	}

	// Set property "ExpiryTime":
	if properties.ExpiryTime != nil {
		expiryTime := *properties.ExpiryTime
		result.ExpiryTime = &expiryTime
	}

	// Set property "IsSharedToAll":
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		result.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if properties.Metadata != nil {
		result.Metadata = make(map[string]string, len(properties.Metadata))
		for key, value := range properties.Metadata {
			result.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range properties.SharedUserList {
		result.SharedUserList = append(result.SharedUserList, item)
	}

	// Set property "Target":
	if properties.Target != nil {
		target := *properties.Target
		result.Target = &target
	}

	// Set property "Value":
	if properties.Value != nil {
		value := *properties.Value
		result.Value = &value
	}

	// Set property "ValueFormat":
	if properties.ValueFormat != nil {
		var temp string
		temp = string(*properties.ValueFormat)
		valueFormat := arm.OAuth2AuthTypeWorkspaceConnectionProperties_ValueFormat(temp)
		result.ValueFormat = &valueFormat
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *OAuth2AuthTypeWorkspaceConnectionProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.OAuth2AuthTypeWorkspaceConnectionProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *OAuth2AuthTypeWorkspaceConnectionProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.OAuth2AuthTypeWorkspaceConnectionProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.OAuth2AuthTypeWorkspaceConnectionProperties, got %T", armInput)
	}

	// Set property "AuthType":
	var temp OAuth2AuthTypeWorkspaceConnectionProperties_AuthType
	var temp1 string
	temp1 = string(typedInput.AuthType)
	temp = OAuth2AuthTypeWorkspaceConnectionProperties_AuthType(temp1)
	properties.AuthType = &temp

	// Set property "Category":
	if typedInput.Category != nil {
		var categoryTemp string
		categoryTemp = string(*typedInput.Category)
		category := ConnectionCategory(categoryTemp)
		properties.Category = &category
	}

	// Set property "Credentials":
	if typedInput.Credentials != nil {
		var credentials1 WorkspaceConnectionOAuth2
		err := credentials1.PopulateFromARM(owner, *typedInput.Credentials)
		if err != nil {
			return err
		}
		credentials := credentials1
		properties.Credentials = &credentials
	}

	// Set property "ExpiryTime":
	if typedInput.ExpiryTime != nil {
		expiryTime := *typedInput.ExpiryTime
		properties.ExpiryTime = &expiryTime
	}

	// Set property "IsSharedToAll":
	if typedInput.IsSharedToAll != nil {
		isSharedToAll := *typedInput.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if typedInput.Metadata != nil {
		properties.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			properties.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range typedInput.SharedUserList {
		properties.SharedUserList = append(properties.SharedUserList, item)
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		properties.Target = &target
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		properties.Value = &value
	}

	// Set property "ValueFormat":
	if typedInput.ValueFormat != nil {
		var valueFormatTemp string
		valueFormatTemp = string(*typedInput.ValueFormat)
		valueFormat := OAuth2AuthTypeWorkspaceConnectionProperties_ValueFormat(valueFormatTemp)
		properties.ValueFormat = &valueFormat
	}

	// No error
	return nil
}

// AssignProperties_From_OAuth2AuthTypeWorkspaceConnectionProperties populates our OAuth2AuthTypeWorkspaceConnectionProperties from the provided source OAuth2AuthTypeWorkspaceConnectionProperties
func (properties *OAuth2AuthTypeWorkspaceConnectionProperties) AssignProperties_From_OAuth2AuthTypeWorkspaceConnectionProperties(source *storage.OAuth2AuthTypeWorkspaceConnectionProperties) error {

	// AuthType
	if source.AuthType != nil {
		authType := *source.AuthType
		authTypeTemp := genruntime.ToEnum(authType, oAuth2AuthTypeWorkspaceConnectionProperties_AuthType_Values)
		properties.AuthType = &authTypeTemp
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := *source.Category
		categoryTemp := genruntime.ToEnum(category, connectionCategory_Values)
		properties.Category = &categoryTemp
	} else {
		properties.Category = nil
	}

	// Credentials
	if source.Credentials != nil {
		var credential WorkspaceConnectionOAuth2
		err := credential.AssignProperties_From_WorkspaceConnectionOAuth2(source.Credentials)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WorkspaceConnectionOAuth2() to populate field Credentials")
		}
		properties.Credentials = &credential
	} else {
		properties.Credentials = nil
	}

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := *source.ValueFormat
		valueFormatTemp := genruntime.ToEnum(valueFormat, oAuth2AuthTypeWorkspaceConnectionProperties_ValueFormat_Values)
		properties.ValueFormat = &valueFormatTemp
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

// AssignProperties_To_OAuth2AuthTypeWorkspaceConnectionProperties populates the provided destination OAuth2AuthTypeWorkspaceConnectionProperties from our OAuth2AuthTypeWorkspaceConnectionProperties
func (properties *OAuth2AuthTypeWorkspaceConnectionProperties) AssignProperties_To_OAuth2AuthTypeWorkspaceConnectionProperties(destination *storage.OAuth2AuthTypeWorkspaceConnectionProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthType
	if properties.AuthType != nil {
		authType := string(*properties.AuthType)
		destination.AuthType = &authType
	} else {
		destination.AuthType = nil
	}

	// Category
	if properties.Category != nil {
		category := string(*properties.Category)
		destination.Category = &category
	} else {
		destination.Category = nil
	}

	// Credentials
	if properties.Credentials != nil {
		var credential storage.WorkspaceConnectionOAuth2
		err := properties.Credentials.AssignProperties_To_WorkspaceConnectionOAuth2(&credential)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WorkspaceConnectionOAuth2() to populate field Credentials")
		}
		destination.Credentials = &credential
	} else {
		destination.Credentials = nil
	}

	// ExpiryTime
	destination.ExpiryTime = genruntime.ClonePointerToString(properties.ExpiryTime)

	// IsSharedToAll
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		destination.IsSharedToAll = &isSharedToAll
	} else {
		destination.IsSharedToAll = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(properties.Metadata)

	// SharedUserList
	destination.SharedUserList = genruntime.CloneSliceOfString(properties.SharedUserList)

	// Target
	destination.Target = genruntime.ClonePointerToString(properties.Target)

	// Value
	destination.Value = genruntime.ClonePointerToString(properties.Value)

	// ValueFormat
	if properties.ValueFormat != nil {
		valueFormat := string(*properties.ValueFormat)
		destination.ValueFormat = &valueFormat
	} else {
		destination.ValueFormat = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_OAuth2AuthTypeWorkspaceConnectionProperties_STATUS populates our OAuth2AuthTypeWorkspaceConnectionProperties from the provided source OAuth2AuthTypeWorkspaceConnectionProperties_STATUS
func (properties *OAuth2AuthTypeWorkspaceConnectionProperties) Initialize_From_OAuth2AuthTypeWorkspaceConnectionProperties_STATUS(source *OAuth2AuthTypeWorkspaceConnectionProperties_STATUS) error {

	// AuthType
	if source.AuthType != nil {
		authType := genruntime.ToEnum(string(*source.AuthType), oAuth2AuthTypeWorkspaceConnectionProperties_AuthType_Values)
		properties.AuthType = &authType
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := genruntime.ToEnum(string(*source.Category), connectionCategory_Values)
		properties.Category = &category
	} else {
		properties.Category = nil
	}

	// Credentials
	if source.Credentials != nil {
		var credential WorkspaceConnectionOAuth2
		err := credential.Initialize_From_WorkspaceConnectionOAuth2_STATUS(source.Credentials)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_WorkspaceConnectionOAuth2_STATUS() to populate field Credentials")
		}
		properties.Credentials = &credential
	} else {
		properties.Credentials = nil
	}

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := genruntime.ToEnum(string(*source.ValueFormat), oAuth2AuthTypeWorkspaceConnectionProperties_ValueFormat_Values)
		properties.ValueFormat = &valueFormat
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

type OAuth2AuthTypeWorkspaceConnectionProperties_STATUS struct {
	// AuthType: Authentication type of the connection target
	AuthType *OAuth2AuthTypeWorkspaceConnectionProperties_AuthType_STATUS `json:"authType,omitempty"`

	// Category: Category of the connection
	Category                *ConnectionCategory_STATUS `json:"category,omitempty"`
	CreatedByWorkspaceArmId *string                    `json:"createdByWorkspaceArmId,omitempty"`

	// Credentials: ClientId and ClientSecret are required. Other properties are optional
	// depending on each OAuth2 provider's  implementation.
	Credentials *WorkspaceConnectionOAuth2_STATUS `json:"credentials,omitempty"`
	ExpiryTime  *string                           `json:"expiryTime,omitempty"`

	// Group: Group based on connection category
	Group         *ConnectionGroup_STATUS `json:"group,omitempty"`
	IsSharedToAll *bool                   `json:"isSharedToAll,omitempty"`

	// Metadata: Store user metadata for this connection
	Metadata       map[string]string `json:"metadata,omitempty"`
	SharedUserList []string          `json:"sharedUserList,omitempty"`
	Target         *string           `json:"target,omitempty"`

	// Value: Value details of the workspace connection.
	Value *string `json:"value,omitempty"`

	// ValueFormat: format for the workspace connection value
	ValueFormat *OAuth2AuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS `json:"valueFormat,omitempty"`
}

var _ genruntime.FromARMConverter = &OAuth2AuthTypeWorkspaceConnectionProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *OAuth2AuthTypeWorkspaceConnectionProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.OAuth2AuthTypeWorkspaceConnectionProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *OAuth2AuthTypeWorkspaceConnectionProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.OAuth2AuthTypeWorkspaceConnectionProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.OAuth2AuthTypeWorkspaceConnectionProperties_STATUS, got %T", armInput)
	}

	// Set property "AuthType":
	var temp OAuth2AuthTypeWorkspaceConnectionProperties_AuthType_STATUS
	var temp1 string
	temp1 = string(typedInput.AuthType)
	temp = OAuth2AuthTypeWorkspaceConnectionProperties_AuthType_STATUS(temp1)
	properties.AuthType = &temp

	// Set property "Category":
	if typedInput.Category != nil {
		var categoryTemp string
		categoryTemp = string(*typedInput.Category)
		category := ConnectionCategory_STATUS(categoryTemp)
		properties.Category = &category
	}

	// Set property "CreatedByWorkspaceArmId":
	if typedInput.CreatedByWorkspaceArmId != nil {
		createdByWorkspaceArmId := *typedInput.CreatedByWorkspaceArmId
		properties.CreatedByWorkspaceArmId = &createdByWorkspaceArmId
	}

	// Set property "Credentials":
	if typedInput.Credentials != nil {
		var credentials1 WorkspaceConnectionOAuth2_STATUS
		err := credentials1.PopulateFromARM(owner, *typedInput.Credentials)
		if err != nil {
			return err
		}
		credentials := credentials1
		properties.Credentials = &credentials
	}

	// Set property "ExpiryTime":
	if typedInput.ExpiryTime != nil {
		expiryTime := *typedInput.ExpiryTime
		properties.ExpiryTime = &expiryTime
	}

	// Set property "Group":
	if typedInput.Group != nil {
		var groupTemp string
		groupTemp = string(*typedInput.Group)
		group := ConnectionGroup_STATUS(groupTemp)
		properties.Group = &group
	}

	// Set property "IsSharedToAll":
	if typedInput.IsSharedToAll != nil {
		isSharedToAll := *typedInput.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if typedInput.Metadata != nil {
		properties.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			properties.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range typedInput.SharedUserList {
		properties.SharedUserList = append(properties.SharedUserList, item)
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		properties.Target = &target
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		properties.Value = &value
	}

	// Set property "ValueFormat":
	if typedInput.ValueFormat != nil {
		var valueFormatTemp string
		valueFormatTemp = string(*typedInput.ValueFormat)
		valueFormat := OAuth2AuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS(valueFormatTemp)
		properties.ValueFormat = &valueFormat
	}

	// No error
	return nil
}

// AssignProperties_From_OAuth2AuthTypeWorkspaceConnectionProperties_STATUS populates our OAuth2AuthTypeWorkspaceConnectionProperties_STATUS from the provided source OAuth2AuthTypeWorkspaceConnectionProperties_STATUS
func (properties *OAuth2AuthTypeWorkspaceConnectionProperties_STATUS) AssignProperties_From_OAuth2AuthTypeWorkspaceConnectionProperties_STATUS(source *storage.OAuth2AuthTypeWorkspaceConnectionProperties_STATUS) error {

	// AuthType
	if source.AuthType != nil {
		authType := *source.AuthType
		authTypeTemp := genruntime.ToEnum(authType, oAuth2AuthTypeWorkspaceConnectionProperties_AuthType_STATUS_Values)
		properties.AuthType = &authTypeTemp
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := *source.Category
		categoryTemp := genruntime.ToEnum(category, connectionCategory_STATUS_Values)
		properties.Category = &categoryTemp
	} else {
		properties.Category = nil
	}

	// CreatedByWorkspaceArmId
	properties.CreatedByWorkspaceArmId = genruntime.ClonePointerToString(source.CreatedByWorkspaceArmId)

	// Credentials
	if source.Credentials != nil {
		var credential WorkspaceConnectionOAuth2_STATUS
		err := credential.AssignProperties_From_WorkspaceConnectionOAuth2_STATUS(source.Credentials)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WorkspaceConnectionOAuth2_STATUS() to populate field Credentials")
		}
		properties.Credentials = &credential
	} else {
		properties.Credentials = nil
	}

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// Group
	if source.Group != nil {
		group := *source.Group
		groupTemp := genruntime.ToEnum(group, connectionGroup_STATUS_Values)
		properties.Group = &groupTemp
	} else {
		properties.Group = nil
	}

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := *source.ValueFormat
		valueFormatTemp := genruntime.ToEnum(valueFormat, oAuth2AuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_Values)
		properties.ValueFormat = &valueFormatTemp
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

// AssignProperties_To_OAuth2AuthTypeWorkspaceConnectionProperties_STATUS populates the provided destination OAuth2AuthTypeWorkspaceConnectionProperties_STATUS from our OAuth2AuthTypeWorkspaceConnectionProperties_STATUS
func (properties *OAuth2AuthTypeWorkspaceConnectionProperties_STATUS) AssignProperties_To_OAuth2AuthTypeWorkspaceConnectionProperties_STATUS(destination *storage.OAuth2AuthTypeWorkspaceConnectionProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthType
	if properties.AuthType != nil {
		authType := string(*properties.AuthType)
		destination.AuthType = &authType
	} else {
		destination.AuthType = nil
	}

	// Category
	if properties.Category != nil {
		category := string(*properties.Category)
		destination.Category = &category
	} else {
		destination.Category = nil
	}

	// CreatedByWorkspaceArmId
	destination.CreatedByWorkspaceArmId = genruntime.ClonePointerToString(properties.CreatedByWorkspaceArmId)

	// Credentials
	if properties.Credentials != nil {
		var credential storage.WorkspaceConnectionOAuth2_STATUS
		err := properties.Credentials.AssignProperties_To_WorkspaceConnectionOAuth2_STATUS(&credential)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WorkspaceConnectionOAuth2_STATUS() to populate field Credentials")
		}
		destination.Credentials = &credential
	} else {
		destination.Credentials = nil
	}

	// ExpiryTime
	destination.ExpiryTime = genruntime.ClonePointerToString(properties.ExpiryTime)

	// Group
	if properties.Group != nil {
		group := string(*properties.Group)
		destination.Group = &group
	} else {
		destination.Group = nil
	}

	// IsSharedToAll
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		destination.IsSharedToAll = &isSharedToAll
	} else {
		destination.IsSharedToAll = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(properties.Metadata)

	// SharedUserList
	destination.SharedUserList = genruntime.CloneSliceOfString(properties.SharedUserList)

	// Target
	destination.Target = genruntime.ClonePointerToString(properties.Target)

	// Value
	destination.Value = genruntime.ClonePointerToString(properties.Value)

	// ValueFormat
	if properties.ValueFormat != nil {
		valueFormat := string(*properties.ValueFormat)
		destination.ValueFormat = &valueFormat
	} else {
		destination.ValueFormat = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type PATAuthTypeWorkspaceConnectionProperties struct {
	// +kubebuilder:validation:Required
	// AuthType: Authentication type of the connection target
	AuthType *PATAuthTypeWorkspaceConnectionProperties_AuthType `json:"authType,omitempty"`

	// Category: Category of the connection
	Category      *ConnectionCategory                     `json:"category,omitempty"`
	Credentials   *WorkspaceConnectionPersonalAccessToken `json:"credentials,omitempty"`
	ExpiryTime    *string                                 `json:"expiryTime,omitempty"`
	IsSharedToAll *bool                                   `json:"isSharedToAll,omitempty"`

	// Metadata: Store user metadata for this connection
	Metadata       map[string]string `json:"metadata,omitempty"`
	SharedUserList []string          `json:"sharedUserList,omitempty"`
	Target         *string           `json:"target,omitempty"`

	// Value: Value details of the workspace connection.
	Value *string `json:"value,omitempty"`

	// ValueFormat: format for the workspace connection value
	ValueFormat *PATAuthTypeWorkspaceConnectionProperties_ValueFormat `json:"valueFormat,omitempty"`
}

var _ genruntime.ARMTransformer = &PATAuthTypeWorkspaceConnectionProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *PATAuthTypeWorkspaceConnectionProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.PATAuthTypeWorkspaceConnectionProperties{}

	// Set property "AuthType":
	if properties.AuthType != nil {
		var temp arm.PATAuthTypeWorkspaceConnectionProperties_AuthType
		var temp1 string
		temp1 = string(*properties.AuthType)
		temp = arm.PATAuthTypeWorkspaceConnectionProperties_AuthType(temp1)
		result.AuthType = temp
	}

	// Set property "Category":
	if properties.Category != nil {
		var temp string
		temp = string(*properties.Category)
		category := arm.ConnectionCategory(temp)
		result.Category = &category
	}

	// Set property "Credentials":
	if properties.Credentials != nil {
		credentials_ARM, err := (*properties.Credentials).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		credentials := *credentials_ARM.(*arm.WorkspaceConnectionPersonalAccessToken)
		result.Credentials = &credentials
	}

	// Set property "ExpiryTime":
	if properties.ExpiryTime != nil {
		expiryTime := *properties.ExpiryTime
		result.ExpiryTime = &expiryTime
	}

	// Set property "IsSharedToAll":
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		result.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if properties.Metadata != nil {
		result.Metadata = make(map[string]string, len(properties.Metadata))
		for key, value := range properties.Metadata {
			result.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range properties.SharedUserList {
		result.SharedUserList = append(result.SharedUserList, item)
	}

	// Set property "Target":
	if properties.Target != nil {
		target := *properties.Target
		result.Target = &target
	}

	// Set property "Value":
	if properties.Value != nil {
		value := *properties.Value
		result.Value = &value
	}

	// Set property "ValueFormat":
	if properties.ValueFormat != nil {
		var temp string
		temp = string(*properties.ValueFormat)
		valueFormat := arm.PATAuthTypeWorkspaceConnectionProperties_ValueFormat(temp)
		result.ValueFormat = &valueFormat
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *PATAuthTypeWorkspaceConnectionProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PATAuthTypeWorkspaceConnectionProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *PATAuthTypeWorkspaceConnectionProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PATAuthTypeWorkspaceConnectionProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PATAuthTypeWorkspaceConnectionProperties, got %T", armInput)
	}

	// Set property "AuthType":
	var temp PATAuthTypeWorkspaceConnectionProperties_AuthType
	var temp1 string
	temp1 = string(typedInput.AuthType)
	temp = PATAuthTypeWorkspaceConnectionProperties_AuthType(temp1)
	properties.AuthType = &temp

	// Set property "Category":
	if typedInput.Category != nil {
		var categoryTemp string
		categoryTemp = string(*typedInput.Category)
		category := ConnectionCategory(categoryTemp)
		properties.Category = &category
	}

	// Set property "Credentials":
	if typedInput.Credentials != nil {
		var credentials1 WorkspaceConnectionPersonalAccessToken
		err := credentials1.PopulateFromARM(owner, *typedInput.Credentials)
		if err != nil {
			return err
		}
		credentials := credentials1
		properties.Credentials = &credentials
	}

	// Set property "ExpiryTime":
	if typedInput.ExpiryTime != nil {
		expiryTime := *typedInput.ExpiryTime
		properties.ExpiryTime = &expiryTime
	}

	// Set property "IsSharedToAll":
	if typedInput.IsSharedToAll != nil {
		isSharedToAll := *typedInput.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if typedInput.Metadata != nil {
		properties.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			properties.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range typedInput.SharedUserList {
		properties.SharedUserList = append(properties.SharedUserList, item)
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		properties.Target = &target
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		properties.Value = &value
	}

	// Set property "ValueFormat":
	if typedInput.ValueFormat != nil {
		var valueFormatTemp string
		valueFormatTemp = string(*typedInput.ValueFormat)
		valueFormat := PATAuthTypeWorkspaceConnectionProperties_ValueFormat(valueFormatTemp)
		properties.ValueFormat = &valueFormat
	}

	// No error
	return nil
}

// AssignProperties_From_PATAuthTypeWorkspaceConnectionProperties populates our PATAuthTypeWorkspaceConnectionProperties from the provided source PATAuthTypeWorkspaceConnectionProperties
func (properties *PATAuthTypeWorkspaceConnectionProperties) AssignProperties_From_PATAuthTypeWorkspaceConnectionProperties(source *storage.PATAuthTypeWorkspaceConnectionProperties) error {

	// AuthType
	if source.AuthType != nil {
		authType := *source.AuthType
		authTypeTemp := genruntime.ToEnum(authType, pATAuthTypeWorkspaceConnectionProperties_AuthType_Values)
		properties.AuthType = &authTypeTemp
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := *source.Category
		categoryTemp := genruntime.ToEnum(category, connectionCategory_Values)
		properties.Category = &categoryTemp
	} else {
		properties.Category = nil
	}

	// Credentials
	if source.Credentials != nil {
		var credential WorkspaceConnectionPersonalAccessToken
		err := credential.AssignProperties_From_WorkspaceConnectionPersonalAccessToken(source.Credentials)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WorkspaceConnectionPersonalAccessToken() to populate field Credentials")
		}
		properties.Credentials = &credential
	} else {
		properties.Credentials = nil
	}

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := *source.ValueFormat
		valueFormatTemp := genruntime.ToEnum(valueFormat, pATAuthTypeWorkspaceConnectionProperties_ValueFormat_Values)
		properties.ValueFormat = &valueFormatTemp
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PATAuthTypeWorkspaceConnectionProperties populates the provided destination PATAuthTypeWorkspaceConnectionProperties from our PATAuthTypeWorkspaceConnectionProperties
func (properties *PATAuthTypeWorkspaceConnectionProperties) AssignProperties_To_PATAuthTypeWorkspaceConnectionProperties(destination *storage.PATAuthTypeWorkspaceConnectionProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthType
	if properties.AuthType != nil {
		authType := string(*properties.AuthType)
		destination.AuthType = &authType
	} else {
		destination.AuthType = nil
	}

	// Category
	if properties.Category != nil {
		category := string(*properties.Category)
		destination.Category = &category
	} else {
		destination.Category = nil
	}

	// Credentials
	if properties.Credentials != nil {
		var credential storage.WorkspaceConnectionPersonalAccessToken
		err := properties.Credentials.AssignProperties_To_WorkspaceConnectionPersonalAccessToken(&credential)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WorkspaceConnectionPersonalAccessToken() to populate field Credentials")
		}
		destination.Credentials = &credential
	} else {
		destination.Credentials = nil
	}

	// ExpiryTime
	destination.ExpiryTime = genruntime.ClonePointerToString(properties.ExpiryTime)

	// IsSharedToAll
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		destination.IsSharedToAll = &isSharedToAll
	} else {
		destination.IsSharedToAll = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(properties.Metadata)

	// SharedUserList
	destination.SharedUserList = genruntime.CloneSliceOfString(properties.SharedUserList)

	// Target
	destination.Target = genruntime.ClonePointerToString(properties.Target)

	// Value
	destination.Value = genruntime.ClonePointerToString(properties.Value)

	// ValueFormat
	if properties.ValueFormat != nil {
		valueFormat := string(*properties.ValueFormat)
		destination.ValueFormat = &valueFormat
	} else {
		destination.ValueFormat = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_PATAuthTypeWorkspaceConnectionProperties_STATUS populates our PATAuthTypeWorkspaceConnectionProperties from the provided source PATAuthTypeWorkspaceConnectionProperties_STATUS
func (properties *PATAuthTypeWorkspaceConnectionProperties) Initialize_From_PATAuthTypeWorkspaceConnectionProperties_STATUS(source *PATAuthTypeWorkspaceConnectionProperties_STATUS) error {

	// AuthType
	if source.AuthType != nil {
		authType := genruntime.ToEnum(string(*source.AuthType), pATAuthTypeWorkspaceConnectionProperties_AuthType_Values)
		properties.AuthType = &authType
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := genruntime.ToEnum(string(*source.Category), connectionCategory_Values)
		properties.Category = &category
	} else {
		properties.Category = nil
	}

	// Credentials
	if source.Credentials != nil {
		var credential WorkspaceConnectionPersonalAccessToken
		err := credential.Initialize_From_WorkspaceConnectionPersonalAccessToken_STATUS(source.Credentials)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_WorkspaceConnectionPersonalAccessToken_STATUS() to populate field Credentials")
		}
		properties.Credentials = &credential
	} else {
		properties.Credentials = nil
	}

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := genruntime.ToEnum(string(*source.ValueFormat), pATAuthTypeWorkspaceConnectionProperties_ValueFormat_Values)
		properties.ValueFormat = &valueFormat
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

type PATAuthTypeWorkspaceConnectionProperties_STATUS struct {
	// AuthType: Authentication type of the connection target
	AuthType *PATAuthTypeWorkspaceConnectionProperties_AuthType_STATUS `json:"authType,omitempty"`

	// Category: Category of the connection
	Category                *ConnectionCategory_STATUS                     `json:"category,omitempty"`
	CreatedByWorkspaceArmId *string                                        `json:"createdByWorkspaceArmId,omitempty"`
	Credentials             *WorkspaceConnectionPersonalAccessToken_STATUS `json:"credentials,omitempty"`
	ExpiryTime              *string                                        `json:"expiryTime,omitempty"`

	// Group: Group based on connection category
	Group         *ConnectionGroup_STATUS `json:"group,omitempty"`
	IsSharedToAll *bool                   `json:"isSharedToAll,omitempty"`

	// Metadata: Store user metadata for this connection
	Metadata       map[string]string `json:"metadata,omitempty"`
	SharedUserList []string          `json:"sharedUserList,omitempty"`
	Target         *string           `json:"target,omitempty"`

	// Value: Value details of the workspace connection.
	Value *string `json:"value,omitempty"`

	// ValueFormat: format for the workspace connection value
	ValueFormat *PATAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS `json:"valueFormat,omitempty"`
}

var _ genruntime.FromARMConverter = &PATAuthTypeWorkspaceConnectionProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *PATAuthTypeWorkspaceConnectionProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PATAuthTypeWorkspaceConnectionProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *PATAuthTypeWorkspaceConnectionProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PATAuthTypeWorkspaceConnectionProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PATAuthTypeWorkspaceConnectionProperties_STATUS, got %T", armInput)
	}

	// Set property "AuthType":
	var temp PATAuthTypeWorkspaceConnectionProperties_AuthType_STATUS
	var temp1 string
	temp1 = string(typedInput.AuthType)
	temp = PATAuthTypeWorkspaceConnectionProperties_AuthType_STATUS(temp1)
	properties.AuthType = &temp

	// Set property "Category":
	if typedInput.Category != nil {
		var categoryTemp string
		categoryTemp = string(*typedInput.Category)
		category := ConnectionCategory_STATUS(categoryTemp)
		properties.Category = &category
	}

	// Set property "CreatedByWorkspaceArmId":
	if typedInput.CreatedByWorkspaceArmId != nil {
		createdByWorkspaceArmId := *typedInput.CreatedByWorkspaceArmId
		properties.CreatedByWorkspaceArmId = &createdByWorkspaceArmId
	}

	// Set property "Credentials":
	if typedInput.Credentials != nil {
		var credentials1 WorkspaceConnectionPersonalAccessToken_STATUS
		err := credentials1.PopulateFromARM(owner, *typedInput.Credentials)
		if err != nil {
			return err
		}
		credentials := credentials1
		properties.Credentials = &credentials
	}

	// Set property "ExpiryTime":
	if typedInput.ExpiryTime != nil {
		expiryTime := *typedInput.ExpiryTime
		properties.ExpiryTime = &expiryTime
	}

	// Set property "Group":
	if typedInput.Group != nil {
		var groupTemp string
		groupTemp = string(*typedInput.Group)
		group := ConnectionGroup_STATUS(groupTemp)
		properties.Group = &group
	}

	// Set property "IsSharedToAll":
	if typedInput.IsSharedToAll != nil {
		isSharedToAll := *typedInput.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if typedInput.Metadata != nil {
		properties.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			properties.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range typedInput.SharedUserList {
		properties.SharedUserList = append(properties.SharedUserList, item)
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		properties.Target = &target
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		properties.Value = &value
	}

	// Set property "ValueFormat":
	if typedInput.ValueFormat != nil {
		var valueFormatTemp string
		valueFormatTemp = string(*typedInput.ValueFormat)
		valueFormat := PATAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS(valueFormatTemp)
		properties.ValueFormat = &valueFormat
	}

	// No error
	return nil
}

// AssignProperties_From_PATAuthTypeWorkspaceConnectionProperties_STATUS populates our PATAuthTypeWorkspaceConnectionProperties_STATUS from the provided source PATAuthTypeWorkspaceConnectionProperties_STATUS
func (properties *PATAuthTypeWorkspaceConnectionProperties_STATUS) AssignProperties_From_PATAuthTypeWorkspaceConnectionProperties_STATUS(source *storage.PATAuthTypeWorkspaceConnectionProperties_STATUS) error {

	// AuthType
	if source.AuthType != nil {
		authType := *source.AuthType
		authTypeTemp := genruntime.ToEnum(authType, pATAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_Values)
		properties.AuthType = &authTypeTemp
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := *source.Category
		categoryTemp := genruntime.ToEnum(category, connectionCategory_STATUS_Values)
		properties.Category = &categoryTemp
	} else {
		properties.Category = nil
	}

	// CreatedByWorkspaceArmId
	properties.CreatedByWorkspaceArmId = genruntime.ClonePointerToString(source.CreatedByWorkspaceArmId)

	// Credentials
	if source.Credentials != nil {
		var credential WorkspaceConnectionPersonalAccessToken_STATUS
		err := credential.AssignProperties_From_WorkspaceConnectionPersonalAccessToken_STATUS(source.Credentials)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WorkspaceConnectionPersonalAccessToken_STATUS() to populate field Credentials")
		}
		properties.Credentials = &credential
	} else {
		properties.Credentials = nil
	}

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// Group
	if source.Group != nil {
		group := *source.Group
		groupTemp := genruntime.ToEnum(group, connectionGroup_STATUS_Values)
		properties.Group = &groupTemp
	} else {
		properties.Group = nil
	}

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := *source.ValueFormat
		valueFormatTemp := genruntime.ToEnum(valueFormat, pATAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_Values)
		properties.ValueFormat = &valueFormatTemp
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PATAuthTypeWorkspaceConnectionProperties_STATUS populates the provided destination PATAuthTypeWorkspaceConnectionProperties_STATUS from our PATAuthTypeWorkspaceConnectionProperties_STATUS
func (properties *PATAuthTypeWorkspaceConnectionProperties_STATUS) AssignProperties_To_PATAuthTypeWorkspaceConnectionProperties_STATUS(destination *storage.PATAuthTypeWorkspaceConnectionProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthType
	if properties.AuthType != nil {
		authType := string(*properties.AuthType)
		destination.AuthType = &authType
	} else {
		destination.AuthType = nil
	}

	// Category
	if properties.Category != nil {
		category := string(*properties.Category)
		destination.Category = &category
	} else {
		destination.Category = nil
	}

	// CreatedByWorkspaceArmId
	destination.CreatedByWorkspaceArmId = genruntime.ClonePointerToString(properties.CreatedByWorkspaceArmId)

	// Credentials
	if properties.Credentials != nil {
		var credential storage.WorkspaceConnectionPersonalAccessToken_STATUS
		err := properties.Credentials.AssignProperties_To_WorkspaceConnectionPersonalAccessToken_STATUS(&credential)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WorkspaceConnectionPersonalAccessToken_STATUS() to populate field Credentials")
		}
		destination.Credentials = &credential
	} else {
		destination.Credentials = nil
	}

	// ExpiryTime
	destination.ExpiryTime = genruntime.ClonePointerToString(properties.ExpiryTime)

	// Group
	if properties.Group != nil {
		group := string(*properties.Group)
		destination.Group = &group
	} else {
		destination.Group = nil
	}

	// IsSharedToAll
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		destination.IsSharedToAll = &isSharedToAll
	} else {
		destination.IsSharedToAll = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(properties.Metadata)

	// SharedUserList
	destination.SharedUserList = genruntime.CloneSliceOfString(properties.SharedUserList)

	// Target
	destination.Target = genruntime.ClonePointerToString(properties.Target)

	// Value
	destination.Value = genruntime.ClonePointerToString(properties.Value)

	// ValueFormat
	if properties.ValueFormat != nil {
		valueFormat := string(*properties.ValueFormat)
		destination.ValueFormat = &valueFormat
	} else {
		destination.ValueFormat = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type SASAuthTypeWorkspaceConnectionProperties struct {
	// +kubebuilder:validation:Required
	// AuthType: Authentication type of the connection target
	AuthType *SASAuthTypeWorkspaceConnectionProperties_AuthType `json:"authType,omitempty"`

	// Category: Category of the connection
	Category      *ConnectionCategory                       `json:"category,omitempty"`
	Credentials   *WorkspaceConnectionSharedAccessSignature `json:"credentials,omitempty"`
	ExpiryTime    *string                                   `json:"expiryTime,omitempty"`
	IsSharedToAll *bool                                     `json:"isSharedToAll,omitempty"`

	// Metadata: Store user metadata for this connection
	Metadata       map[string]string `json:"metadata,omitempty"`
	SharedUserList []string          `json:"sharedUserList,omitempty"`
	Target         *string           `json:"target,omitempty"`

	// Value: Value details of the workspace connection.
	Value *string `json:"value,omitempty"`

	// ValueFormat: format for the workspace connection value
	ValueFormat *SASAuthTypeWorkspaceConnectionProperties_ValueFormat `json:"valueFormat,omitempty"`
}

var _ genruntime.ARMTransformer = &SASAuthTypeWorkspaceConnectionProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *SASAuthTypeWorkspaceConnectionProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.SASAuthTypeWorkspaceConnectionProperties{}

	// Set property "AuthType":
	if properties.AuthType != nil {
		var temp arm.SASAuthTypeWorkspaceConnectionProperties_AuthType
		var temp1 string
		temp1 = string(*properties.AuthType)
		temp = arm.SASAuthTypeWorkspaceConnectionProperties_AuthType(temp1)
		result.AuthType = temp
	}

	// Set property "Category":
	if properties.Category != nil {
		var temp string
		temp = string(*properties.Category)
		category := arm.ConnectionCategory(temp)
		result.Category = &category
	}

	// Set property "Credentials":
	if properties.Credentials != nil {
		credentials_ARM, err := (*properties.Credentials).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		credentials := *credentials_ARM.(*arm.WorkspaceConnectionSharedAccessSignature)
		result.Credentials = &credentials
	}

	// Set property "ExpiryTime":
	if properties.ExpiryTime != nil {
		expiryTime := *properties.ExpiryTime
		result.ExpiryTime = &expiryTime
	}

	// Set property "IsSharedToAll":
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		result.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if properties.Metadata != nil {
		result.Metadata = make(map[string]string, len(properties.Metadata))
		for key, value := range properties.Metadata {
			result.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range properties.SharedUserList {
		result.SharedUserList = append(result.SharedUserList, item)
	}

	// Set property "Target":
	if properties.Target != nil {
		target := *properties.Target
		result.Target = &target
	}

	// Set property "Value":
	if properties.Value != nil {
		value := *properties.Value
		result.Value = &value
	}

	// Set property "ValueFormat":
	if properties.ValueFormat != nil {
		var temp string
		temp = string(*properties.ValueFormat)
		valueFormat := arm.SASAuthTypeWorkspaceConnectionProperties_ValueFormat(temp)
		result.ValueFormat = &valueFormat
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *SASAuthTypeWorkspaceConnectionProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SASAuthTypeWorkspaceConnectionProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *SASAuthTypeWorkspaceConnectionProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SASAuthTypeWorkspaceConnectionProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SASAuthTypeWorkspaceConnectionProperties, got %T", armInput)
	}

	// Set property "AuthType":
	var temp SASAuthTypeWorkspaceConnectionProperties_AuthType
	var temp1 string
	temp1 = string(typedInput.AuthType)
	temp = SASAuthTypeWorkspaceConnectionProperties_AuthType(temp1)
	properties.AuthType = &temp

	// Set property "Category":
	if typedInput.Category != nil {
		var categoryTemp string
		categoryTemp = string(*typedInput.Category)
		category := ConnectionCategory(categoryTemp)
		properties.Category = &category
	}

	// Set property "Credentials":
	if typedInput.Credentials != nil {
		var credentials1 WorkspaceConnectionSharedAccessSignature
		err := credentials1.PopulateFromARM(owner, *typedInput.Credentials)
		if err != nil {
			return err
		}
		credentials := credentials1
		properties.Credentials = &credentials
	}

	// Set property "ExpiryTime":
	if typedInput.ExpiryTime != nil {
		expiryTime := *typedInput.ExpiryTime
		properties.ExpiryTime = &expiryTime
	}

	// Set property "IsSharedToAll":
	if typedInput.IsSharedToAll != nil {
		isSharedToAll := *typedInput.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if typedInput.Metadata != nil {
		properties.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			properties.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range typedInput.SharedUserList {
		properties.SharedUserList = append(properties.SharedUserList, item)
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		properties.Target = &target
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		properties.Value = &value
	}

	// Set property "ValueFormat":
	if typedInput.ValueFormat != nil {
		var valueFormatTemp string
		valueFormatTemp = string(*typedInput.ValueFormat)
		valueFormat := SASAuthTypeWorkspaceConnectionProperties_ValueFormat(valueFormatTemp)
		properties.ValueFormat = &valueFormat
	}

	// No error
	return nil
}

// AssignProperties_From_SASAuthTypeWorkspaceConnectionProperties populates our SASAuthTypeWorkspaceConnectionProperties from the provided source SASAuthTypeWorkspaceConnectionProperties
func (properties *SASAuthTypeWorkspaceConnectionProperties) AssignProperties_From_SASAuthTypeWorkspaceConnectionProperties(source *storage.SASAuthTypeWorkspaceConnectionProperties) error {

	// AuthType
	if source.AuthType != nil {
		authType := *source.AuthType
		authTypeTemp := genruntime.ToEnum(authType, sASAuthTypeWorkspaceConnectionProperties_AuthType_Values)
		properties.AuthType = &authTypeTemp
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := *source.Category
		categoryTemp := genruntime.ToEnum(category, connectionCategory_Values)
		properties.Category = &categoryTemp
	} else {
		properties.Category = nil
	}

	// Credentials
	if source.Credentials != nil {
		var credential WorkspaceConnectionSharedAccessSignature
		err := credential.AssignProperties_From_WorkspaceConnectionSharedAccessSignature(source.Credentials)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WorkspaceConnectionSharedAccessSignature() to populate field Credentials")
		}
		properties.Credentials = &credential
	} else {
		properties.Credentials = nil
	}

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := *source.ValueFormat
		valueFormatTemp := genruntime.ToEnum(valueFormat, sASAuthTypeWorkspaceConnectionProperties_ValueFormat_Values)
		properties.ValueFormat = &valueFormatTemp
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SASAuthTypeWorkspaceConnectionProperties populates the provided destination SASAuthTypeWorkspaceConnectionProperties from our SASAuthTypeWorkspaceConnectionProperties
func (properties *SASAuthTypeWorkspaceConnectionProperties) AssignProperties_To_SASAuthTypeWorkspaceConnectionProperties(destination *storage.SASAuthTypeWorkspaceConnectionProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthType
	if properties.AuthType != nil {
		authType := string(*properties.AuthType)
		destination.AuthType = &authType
	} else {
		destination.AuthType = nil
	}

	// Category
	if properties.Category != nil {
		category := string(*properties.Category)
		destination.Category = &category
	} else {
		destination.Category = nil
	}

	// Credentials
	if properties.Credentials != nil {
		var credential storage.WorkspaceConnectionSharedAccessSignature
		err := properties.Credentials.AssignProperties_To_WorkspaceConnectionSharedAccessSignature(&credential)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WorkspaceConnectionSharedAccessSignature() to populate field Credentials")
		}
		destination.Credentials = &credential
	} else {
		destination.Credentials = nil
	}

	// ExpiryTime
	destination.ExpiryTime = genruntime.ClonePointerToString(properties.ExpiryTime)

	// IsSharedToAll
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		destination.IsSharedToAll = &isSharedToAll
	} else {
		destination.IsSharedToAll = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(properties.Metadata)

	// SharedUserList
	destination.SharedUserList = genruntime.CloneSliceOfString(properties.SharedUserList)

	// Target
	destination.Target = genruntime.ClonePointerToString(properties.Target)

	// Value
	destination.Value = genruntime.ClonePointerToString(properties.Value)

	// ValueFormat
	if properties.ValueFormat != nil {
		valueFormat := string(*properties.ValueFormat)
		destination.ValueFormat = &valueFormat
	} else {
		destination.ValueFormat = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_SASAuthTypeWorkspaceConnectionProperties_STATUS populates our SASAuthTypeWorkspaceConnectionProperties from the provided source SASAuthTypeWorkspaceConnectionProperties_STATUS
func (properties *SASAuthTypeWorkspaceConnectionProperties) Initialize_From_SASAuthTypeWorkspaceConnectionProperties_STATUS(source *SASAuthTypeWorkspaceConnectionProperties_STATUS) error {

	// AuthType
	if source.AuthType != nil {
		authType := genruntime.ToEnum(string(*source.AuthType), sASAuthTypeWorkspaceConnectionProperties_AuthType_Values)
		properties.AuthType = &authType
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := genruntime.ToEnum(string(*source.Category), connectionCategory_Values)
		properties.Category = &category
	} else {
		properties.Category = nil
	}

	// Credentials
	if source.Credentials != nil {
		var credential WorkspaceConnectionSharedAccessSignature
		err := credential.Initialize_From_WorkspaceConnectionSharedAccessSignature_STATUS(source.Credentials)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_WorkspaceConnectionSharedAccessSignature_STATUS() to populate field Credentials")
		}
		properties.Credentials = &credential
	} else {
		properties.Credentials = nil
	}

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := genruntime.ToEnum(string(*source.ValueFormat), sASAuthTypeWorkspaceConnectionProperties_ValueFormat_Values)
		properties.ValueFormat = &valueFormat
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

type SASAuthTypeWorkspaceConnectionProperties_STATUS struct {
	// AuthType: Authentication type of the connection target
	AuthType *SASAuthTypeWorkspaceConnectionProperties_AuthType_STATUS `json:"authType,omitempty"`

	// Category: Category of the connection
	Category                *ConnectionCategory_STATUS                       `json:"category,omitempty"`
	CreatedByWorkspaceArmId *string                                          `json:"createdByWorkspaceArmId,omitempty"`
	Credentials             *WorkspaceConnectionSharedAccessSignature_STATUS `json:"credentials,omitempty"`
	ExpiryTime              *string                                          `json:"expiryTime,omitempty"`

	// Group: Group based on connection category
	Group         *ConnectionGroup_STATUS `json:"group,omitempty"`
	IsSharedToAll *bool                   `json:"isSharedToAll,omitempty"`

	// Metadata: Store user metadata for this connection
	Metadata       map[string]string `json:"metadata,omitempty"`
	SharedUserList []string          `json:"sharedUserList,omitempty"`
	Target         *string           `json:"target,omitempty"`

	// Value: Value details of the workspace connection.
	Value *string `json:"value,omitempty"`

	// ValueFormat: format for the workspace connection value
	ValueFormat *SASAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS `json:"valueFormat,omitempty"`
}

var _ genruntime.FromARMConverter = &SASAuthTypeWorkspaceConnectionProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *SASAuthTypeWorkspaceConnectionProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SASAuthTypeWorkspaceConnectionProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *SASAuthTypeWorkspaceConnectionProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SASAuthTypeWorkspaceConnectionProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SASAuthTypeWorkspaceConnectionProperties_STATUS, got %T", armInput)
	}

	// Set property "AuthType":
	var temp SASAuthTypeWorkspaceConnectionProperties_AuthType_STATUS
	var temp1 string
	temp1 = string(typedInput.AuthType)
	temp = SASAuthTypeWorkspaceConnectionProperties_AuthType_STATUS(temp1)
	properties.AuthType = &temp

	// Set property "Category":
	if typedInput.Category != nil {
		var categoryTemp string
		categoryTemp = string(*typedInput.Category)
		category := ConnectionCategory_STATUS(categoryTemp)
		properties.Category = &category
	}

	// Set property "CreatedByWorkspaceArmId":
	if typedInput.CreatedByWorkspaceArmId != nil {
		createdByWorkspaceArmId := *typedInput.CreatedByWorkspaceArmId
		properties.CreatedByWorkspaceArmId = &createdByWorkspaceArmId
	}

	// Set property "Credentials":
	if typedInput.Credentials != nil {
		var credentials1 WorkspaceConnectionSharedAccessSignature_STATUS
		err := credentials1.PopulateFromARM(owner, *typedInput.Credentials)
		if err != nil {
			return err
		}
		credentials := credentials1
		properties.Credentials = &credentials
	}

	// Set property "ExpiryTime":
	if typedInput.ExpiryTime != nil {
		expiryTime := *typedInput.ExpiryTime
		properties.ExpiryTime = &expiryTime
	}

	// Set property "Group":
	if typedInput.Group != nil {
		var groupTemp string
		groupTemp = string(*typedInput.Group)
		group := ConnectionGroup_STATUS(groupTemp)
		properties.Group = &group
	}

	// Set property "IsSharedToAll":
	if typedInput.IsSharedToAll != nil {
		isSharedToAll := *typedInput.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if typedInput.Metadata != nil {
		properties.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			properties.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range typedInput.SharedUserList {
		properties.SharedUserList = append(properties.SharedUserList, item)
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		properties.Target = &target
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		properties.Value = &value
	}

	// Set property "ValueFormat":
	if typedInput.ValueFormat != nil {
		var valueFormatTemp string
		valueFormatTemp = string(*typedInput.ValueFormat)
		valueFormat := SASAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS(valueFormatTemp)
		properties.ValueFormat = &valueFormat
	}

	// No error
	return nil
}

// AssignProperties_From_SASAuthTypeWorkspaceConnectionProperties_STATUS populates our SASAuthTypeWorkspaceConnectionProperties_STATUS from the provided source SASAuthTypeWorkspaceConnectionProperties_STATUS
func (properties *SASAuthTypeWorkspaceConnectionProperties_STATUS) AssignProperties_From_SASAuthTypeWorkspaceConnectionProperties_STATUS(source *storage.SASAuthTypeWorkspaceConnectionProperties_STATUS) error {

	// AuthType
	if source.AuthType != nil {
		authType := *source.AuthType
		authTypeTemp := genruntime.ToEnum(authType, sASAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_Values)
		properties.AuthType = &authTypeTemp
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := *source.Category
		categoryTemp := genruntime.ToEnum(category, connectionCategory_STATUS_Values)
		properties.Category = &categoryTemp
	} else {
		properties.Category = nil
	}

	// CreatedByWorkspaceArmId
	properties.CreatedByWorkspaceArmId = genruntime.ClonePointerToString(source.CreatedByWorkspaceArmId)

	// Credentials
	if source.Credentials != nil {
		var credential WorkspaceConnectionSharedAccessSignature_STATUS
		err := credential.AssignProperties_From_WorkspaceConnectionSharedAccessSignature_STATUS(source.Credentials)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WorkspaceConnectionSharedAccessSignature_STATUS() to populate field Credentials")
		}
		properties.Credentials = &credential
	} else {
		properties.Credentials = nil
	}

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// Group
	if source.Group != nil {
		group := *source.Group
		groupTemp := genruntime.ToEnum(group, connectionGroup_STATUS_Values)
		properties.Group = &groupTemp
	} else {
		properties.Group = nil
	}

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := *source.ValueFormat
		valueFormatTemp := genruntime.ToEnum(valueFormat, sASAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_Values)
		properties.ValueFormat = &valueFormatTemp
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SASAuthTypeWorkspaceConnectionProperties_STATUS populates the provided destination SASAuthTypeWorkspaceConnectionProperties_STATUS from our SASAuthTypeWorkspaceConnectionProperties_STATUS
func (properties *SASAuthTypeWorkspaceConnectionProperties_STATUS) AssignProperties_To_SASAuthTypeWorkspaceConnectionProperties_STATUS(destination *storage.SASAuthTypeWorkspaceConnectionProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthType
	if properties.AuthType != nil {
		authType := string(*properties.AuthType)
		destination.AuthType = &authType
	} else {
		destination.AuthType = nil
	}

	// Category
	if properties.Category != nil {
		category := string(*properties.Category)
		destination.Category = &category
	} else {
		destination.Category = nil
	}

	// CreatedByWorkspaceArmId
	destination.CreatedByWorkspaceArmId = genruntime.ClonePointerToString(properties.CreatedByWorkspaceArmId)

	// Credentials
	if properties.Credentials != nil {
		var credential storage.WorkspaceConnectionSharedAccessSignature_STATUS
		err := properties.Credentials.AssignProperties_To_WorkspaceConnectionSharedAccessSignature_STATUS(&credential)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WorkspaceConnectionSharedAccessSignature_STATUS() to populate field Credentials")
		}
		destination.Credentials = &credential
	} else {
		destination.Credentials = nil
	}

	// ExpiryTime
	destination.ExpiryTime = genruntime.ClonePointerToString(properties.ExpiryTime)

	// Group
	if properties.Group != nil {
		group := string(*properties.Group)
		destination.Group = &group
	} else {
		destination.Group = nil
	}

	// IsSharedToAll
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		destination.IsSharedToAll = &isSharedToAll
	} else {
		destination.IsSharedToAll = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(properties.Metadata)

	// SharedUserList
	destination.SharedUserList = genruntime.CloneSliceOfString(properties.SharedUserList)

	// Target
	destination.Target = genruntime.ClonePointerToString(properties.Target)

	// Value
	destination.Value = genruntime.ClonePointerToString(properties.Value)

	// ValueFormat
	if properties.ValueFormat != nil {
		valueFormat := string(*properties.ValueFormat)
		destination.ValueFormat = &valueFormat
	} else {
		destination.ValueFormat = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ServicePrincipalAuthTypeWorkspaceConnectionProperties struct {
	// +kubebuilder:validation:Required
	// AuthType: Authentication type of the connection target
	AuthType *ServicePrincipalAuthTypeWorkspaceConnectionProperties_AuthType `json:"authType,omitempty"`

	// Category: Category of the connection
	Category      *ConnectionCategory                  `json:"category,omitempty"`
	Credentials   *WorkspaceConnectionServicePrincipal `json:"credentials,omitempty"`
	ExpiryTime    *string                              `json:"expiryTime,omitempty"`
	IsSharedToAll *bool                                `json:"isSharedToAll,omitempty"`

	// Metadata: Store user metadata for this connection
	Metadata       map[string]string `json:"metadata,omitempty"`
	SharedUserList []string          `json:"sharedUserList,omitempty"`
	Target         *string           `json:"target,omitempty"`

	// Value: Value details of the workspace connection.
	Value *string `json:"value,omitempty"`

	// ValueFormat: format for the workspace connection value
	ValueFormat *ServicePrincipalAuthTypeWorkspaceConnectionProperties_ValueFormat `json:"valueFormat,omitempty"`
}

var _ genruntime.ARMTransformer = &ServicePrincipalAuthTypeWorkspaceConnectionProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *ServicePrincipalAuthTypeWorkspaceConnectionProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.ServicePrincipalAuthTypeWorkspaceConnectionProperties{}

	// Set property "AuthType":
	if properties.AuthType != nil {
		var temp arm.ServicePrincipalAuthTypeWorkspaceConnectionProperties_AuthType
		var temp1 string
		temp1 = string(*properties.AuthType)
		temp = arm.ServicePrincipalAuthTypeWorkspaceConnectionProperties_AuthType(temp1)
		result.AuthType = temp
	}

	// Set property "Category":
	if properties.Category != nil {
		var temp string
		temp = string(*properties.Category)
		category := arm.ConnectionCategory(temp)
		result.Category = &category
	}

	// Set property "Credentials":
	if properties.Credentials != nil {
		credentials_ARM, err := (*properties.Credentials).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		credentials := *credentials_ARM.(*arm.WorkspaceConnectionServicePrincipal)
		result.Credentials = &credentials
	}

	// Set property "ExpiryTime":
	if properties.ExpiryTime != nil {
		expiryTime := *properties.ExpiryTime
		result.ExpiryTime = &expiryTime
	}

	// Set property "IsSharedToAll":
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		result.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if properties.Metadata != nil {
		result.Metadata = make(map[string]string, len(properties.Metadata))
		for key, value := range properties.Metadata {
			result.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range properties.SharedUserList {
		result.SharedUserList = append(result.SharedUserList, item)
	}

	// Set property "Target":
	if properties.Target != nil {
		target := *properties.Target
		result.Target = &target
	}

	// Set property "Value":
	if properties.Value != nil {
		value := *properties.Value
		result.Value = &value
	}

	// Set property "ValueFormat":
	if properties.ValueFormat != nil {
		var temp string
		temp = string(*properties.ValueFormat)
		valueFormat := arm.ServicePrincipalAuthTypeWorkspaceConnectionProperties_ValueFormat(temp)
		result.ValueFormat = &valueFormat
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *ServicePrincipalAuthTypeWorkspaceConnectionProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ServicePrincipalAuthTypeWorkspaceConnectionProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *ServicePrincipalAuthTypeWorkspaceConnectionProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ServicePrincipalAuthTypeWorkspaceConnectionProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ServicePrincipalAuthTypeWorkspaceConnectionProperties, got %T", armInput)
	}

	// Set property "AuthType":
	var temp ServicePrincipalAuthTypeWorkspaceConnectionProperties_AuthType
	var temp1 string
	temp1 = string(typedInput.AuthType)
	temp = ServicePrincipalAuthTypeWorkspaceConnectionProperties_AuthType(temp1)
	properties.AuthType = &temp

	// Set property "Category":
	if typedInput.Category != nil {
		var categoryTemp string
		categoryTemp = string(*typedInput.Category)
		category := ConnectionCategory(categoryTemp)
		properties.Category = &category
	}

	// Set property "Credentials":
	if typedInput.Credentials != nil {
		var credentials1 WorkspaceConnectionServicePrincipal
		err := credentials1.PopulateFromARM(owner, *typedInput.Credentials)
		if err != nil {
			return err
		}
		credentials := credentials1
		properties.Credentials = &credentials
	}

	// Set property "ExpiryTime":
	if typedInput.ExpiryTime != nil {
		expiryTime := *typedInput.ExpiryTime
		properties.ExpiryTime = &expiryTime
	}

	// Set property "IsSharedToAll":
	if typedInput.IsSharedToAll != nil {
		isSharedToAll := *typedInput.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if typedInput.Metadata != nil {
		properties.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			properties.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range typedInput.SharedUserList {
		properties.SharedUserList = append(properties.SharedUserList, item)
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		properties.Target = &target
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		properties.Value = &value
	}

	// Set property "ValueFormat":
	if typedInput.ValueFormat != nil {
		var valueFormatTemp string
		valueFormatTemp = string(*typedInput.ValueFormat)
		valueFormat := ServicePrincipalAuthTypeWorkspaceConnectionProperties_ValueFormat(valueFormatTemp)
		properties.ValueFormat = &valueFormat
	}

	// No error
	return nil
}

// AssignProperties_From_ServicePrincipalAuthTypeWorkspaceConnectionProperties populates our ServicePrincipalAuthTypeWorkspaceConnectionProperties from the provided source ServicePrincipalAuthTypeWorkspaceConnectionProperties
func (properties *ServicePrincipalAuthTypeWorkspaceConnectionProperties) AssignProperties_From_ServicePrincipalAuthTypeWorkspaceConnectionProperties(source *storage.ServicePrincipalAuthTypeWorkspaceConnectionProperties) error {

	// AuthType
	if source.AuthType != nil {
		authType := *source.AuthType
		authTypeTemp := genruntime.ToEnum(authType, servicePrincipalAuthTypeWorkspaceConnectionProperties_AuthType_Values)
		properties.AuthType = &authTypeTemp
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := *source.Category
		categoryTemp := genruntime.ToEnum(category, connectionCategory_Values)
		properties.Category = &categoryTemp
	} else {
		properties.Category = nil
	}

	// Credentials
	if source.Credentials != nil {
		var credential WorkspaceConnectionServicePrincipal
		err := credential.AssignProperties_From_WorkspaceConnectionServicePrincipal(source.Credentials)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WorkspaceConnectionServicePrincipal() to populate field Credentials")
		}
		properties.Credentials = &credential
	} else {
		properties.Credentials = nil
	}

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := *source.ValueFormat
		valueFormatTemp := genruntime.ToEnum(valueFormat, servicePrincipalAuthTypeWorkspaceConnectionProperties_ValueFormat_Values)
		properties.ValueFormat = &valueFormatTemp
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ServicePrincipalAuthTypeWorkspaceConnectionProperties populates the provided destination ServicePrincipalAuthTypeWorkspaceConnectionProperties from our ServicePrincipalAuthTypeWorkspaceConnectionProperties
func (properties *ServicePrincipalAuthTypeWorkspaceConnectionProperties) AssignProperties_To_ServicePrincipalAuthTypeWorkspaceConnectionProperties(destination *storage.ServicePrincipalAuthTypeWorkspaceConnectionProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthType
	if properties.AuthType != nil {
		authType := string(*properties.AuthType)
		destination.AuthType = &authType
	} else {
		destination.AuthType = nil
	}

	// Category
	if properties.Category != nil {
		category := string(*properties.Category)
		destination.Category = &category
	} else {
		destination.Category = nil
	}

	// Credentials
	if properties.Credentials != nil {
		var credential storage.WorkspaceConnectionServicePrincipal
		err := properties.Credentials.AssignProperties_To_WorkspaceConnectionServicePrincipal(&credential)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WorkspaceConnectionServicePrincipal() to populate field Credentials")
		}
		destination.Credentials = &credential
	} else {
		destination.Credentials = nil
	}

	// ExpiryTime
	destination.ExpiryTime = genruntime.ClonePointerToString(properties.ExpiryTime)

	// IsSharedToAll
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		destination.IsSharedToAll = &isSharedToAll
	} else {
		destination.IsSharedToAll = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(properties.Metadata)

	// SharedUserList
	destination.SharedUserList = genruntime.CloneSliceOfString(properties.SharedUserList)

	// Target
	destination.Target = genruntime.ClonePointerToString(properties.Target)

	// Value
	destination.Value = genruntime.ClonePointerToString(properties.Value)

	// ValueFormat
	if properties.ValueFormat != nil {
		valueFormat := string(*properties.ValueFormat)
		destination.ValueFormat = &valueFormat
	} else {
		destination.ValueFormat = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS populates our ServicePrincipalAuthTypeWorkspaceConnectionProperties from the provided source ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS
func (properties *ServicePrincipalAuthTypeWorkspaceConnectionProperties) Initialize_From_ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS(source *ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS) error {

	// AuthType
	if source.AuthType != nil {
		authType := genruntime.ToEnum(string(*source.AuthType), servicePrincipalAuthTypeWorkspaceConnectionProperties_AuthType_Values)
		properties.AuthType = &authType
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := genruntime.ToEnum(string(*source.Category), connectionCategory_Values)
		properties.Category = &category
	} else {
		properties.Category = nil
	}

	// Credentials
	if source.Credentials != nil {
		var credential WorkspaceConnectionServicePrincipal
		err := credential.Initialize_From_WorkspaceConnectionServicePrincipal_STATUS(source.Credentials)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_WorkspaceConnectionServicePrincipal_STATUS() to populate field Credentials")
		}
		properties.Credentials = &credential
	} else {
		properties.Credentials = nil
	}

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := genruntime.ToEnum(string(*source.ValueFormat), servicePrincipalAuthTypeWorkspaceConnectionProperties_ValueFormat_Values)
		properties.ValueFormat = &valueFormat
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

type ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS struct {
	// AuthType: Authentication type of the connection target
	AuthType *ServicePrincipalAuthTypeWorkspaceConnectionProperties_AuthType_STATUS `json:"authType,omitempty"`

	// Category: Category of the connection
	Category                *ConnectionCategory_STATUS                  `json:"category,omitempty"`
	CreatedByWorkspaceArmId *string                                     `json:"createdByWorkspaceArmId,omitempty"`
	Credentials             *WorkspaceConnectionServicePrincipal_STATUS `json:"credentials,omitempty"`
	ExpiryTime              *string                                     `json:"expiryTime,omitempty"`

	// Group: Group based on connection category
	Group         *ConnectionGroup_STATUS `json:"group,omitempty"`
	IsSharedToAll *bool                   `json:"isSharedToAll,omitempty"`

	// Metadata: Store user metadata for this connection
	Metadata       map[string]string `json:"metadata,omitempty"`
	SharedUserList []string          `json:"sharedUserList,omitempty"`
	Target         *string           `json:"target,omitempty"`

	// Value: Value details of the workspace connection.
	Value *string `json:"value,omitempty"`

	// ValueFormat: format for the workspace connection value
	ValueFormat *ServicePrincipalAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS `json:"valueFormat,omitempty"`
}

var _ genruntime.FromARMConverter = &ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS, got %T", armInput)
	}

	// Set property "AuthType":
	var temp ServicePrincipalAuthTypeWorkspaceConnectionProperties_AuthType_STATUS
	var temp1 string
	temp1 = string(typedInput.AuthType)
	temp = ServicePrincipalAuthTypeWorkspaceConnectionProperties_AuthType_STATUS(temp1)
	properties.AuthType = &temp

	// Set property "Category":
	if typedInput.Category != nil {
		var categoryTemp string
		categoryTemp = string(*typedInput.Category)
		category := ConnectionCategory_STATUS(categoryTemp)
		properties.Category = &category
	}

	// Set property "CreatedByWorkspaceArmId":
	if typedInput.CreatedByWorkspaceArmId != nil {
		createdByWorkspaceArmId := *typedInput.CreatedByWorkspaceArmId
		properties.CreatedByWorkspaceArmId = &createdByWorkspaceArmId
	}

	// Set property "Credentials":
	if typedInput.Credentials != nil {
		var credentials1 WorkspaceConnectionServicePrincipal_STATUS
		err := credentials1.PopulateFromARM(owner, *typedInput.Credentials)
		if err != nil {
			return err
		}
		credentials := credentials1
		properties.Credentials = &credentials
	}

	// Set property "ExpiryTime":
	if typedInput.ExpiryTime != nil {
		expiryTime := *typedInput.ExpiryTime
		properties.ExpiryTime = &expiryTime
	}

	// Set property "Group":
	if typedInput.Group != nil {
		var groupTemp string
		groupTemp = string(*typedInput.Group)
		group := ConnectionGroup_STATUS(groupTemp)
		properties.Group = &group
	}

	// Set property "IsSharedToAll":
	if typedInput.IsSharedToAll != nil {
		isSharedToAll := *typedInput.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if typedInput.Metadata != nil {
		properties.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			properties.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range typedInput.SharedUserList {
		properties.SharedUserList = append(properties.SharedUserList, item)
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		properties.Target = &target
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		properties.Value = &value
	}

	// Set property "ValueFormat":
	if typedInput.ValueFormat != nil {
		var valueFormatTemp string
		valueFormatTemp = string(*typedInput.ValueFormat)
		valueFormat := ServicePrincipalAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS(valueFormatTemp)
		properties.ValueFormat = &valueFormat
	}

	// No error
	return nil
}

// AssignProperties_From_ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS populates our ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS from the provided source ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS
func (properties *ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS) AssignProperties_From_ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS(source *storage.ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS) error {

	// AuthType
	if source.AuthType != nil {
		authType := *source.AuthType
		authTypeTemp := genruntime.ToEnum(authType, servicePrincipalAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_Values)
		properties.AuthType = &authTypeTemp
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := *source.Category
		categoryTemp := genruntime.ToEnum(category, connectionCategory_STATUS_Values)
		properties.Category = &categoryTemp
	} else {
		properties.Category = nil
	}

	// CreatedByWorkspaceArmId
	properties.CreatedByWorkspaceArmId = genruntime.ClonePointerToString(source.CreatedByWorkspaceArmId)

	// Credentials
	if source.Credentials != nil {
		var credential WorkspaceConnectionServicePrincipal_STATUS
		err := credential.AssignProperties_From_WorkspaceConnectionServicePrincipal_STATUS(source.Credentials)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WorkspaceConnectionServicePrincipal_STATUS() to populate field Credentials")
		}
		properties.Credentials = &credential
	} else {
		properties.Credentials = nil
	}

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// Group
	if source.Group != nil {
		group := *source.Group
		groupTemp := genruntime.ToEnum(group, connectionGroup_STATUS_Values)
		properties.Group = &groupTemp
	} else {
		properties.Group = nil
	}

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := *source.ValueFormat
		valueFormatTemp := genruntime.ToEnum(valueFormat, servicePrincipalAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_Values)
		properties.ValueFormat = &valueFormatTemp
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS populates the provided destination ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS from our ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS
func (properties *ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS) AssignProperties_To_ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS(destination *storage.ServicePrincipalAuthTypeWorkspaceConnectionProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthType
	if properties.AuthType != nil {
		authType := string(*properties.AuthType)
		destination.AuthType = &authType
	} else {
		destination.AuthType = nil
	}

	// Category
	if properties.Category != nil {
		category := string(*properties.Category)
		destination.Category = &category
	} else {
		destination.Category = nil
	}

	// CreatedByWorkspaceArmId
	destination.CreatedByWorkspaceArmId = genruntime.ClonePointerToString(properties.CreatedByWorkspaceArmId)

	// Credentials
	if properties.Credentials != nil {
		var credential storage.WorkspaceConnectionServicePrincipal_STATUS
		err := properties.Credentials.AssignProperties_To_WorkspaceConnectionServicePrincipal_STATUS(&credential)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WorkspaceConnectionServicePrincipal_STATUS() to populate field Credentials")
		}
		destination.Credentials = &credential
	} else {
		destination.Credentials = nil
	}

	// ExpiryTime
	destination.ExpiryTime = genruntime.ClonePointerToString(properties.ExpiryTime)

	// Group
	if properties.Group != nil {
		group := string(*properties.Group)
		destination.Group = &group
	} else {
		destination.Group = nil
	}

	// IsSharedToAll
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		destination.IsSharedToAll = &isSharedToAll
	} else {
		destination.IsSharedToAll = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(properties.Metadata)

	// SharedUserList
	destination.SharedUserList = genruntime.CloneSliceOfString(properties.SharedUserList)

	// Target
	destination.Target = genruntime.ClonePointerToString(properties.Target)

	// Value
	destination.Value = genruntime.ClonePointerToString(properties.Value)

	// ValueFormat
	if properties.ValueFormat != nil {
		valueFormat := string(*properties.ValueFormat)
		destination.ValueFormat = &valueFormat
	} else {
		destination.ValueFormat = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type UsernamePasswordAuthTypeWorkspaceConnectionProperties struct {
	// +kubebuilder:validation:Required
	// AuthType: Authentication type of the connection target
	AuthType *UsernamePasswordAuthTypeWorkspaceConnectionProperties_AuthType `json:"authType,omitempty"`

	// Category: Category of the connection
	Category      *ConnectionCategory                  `json:"category,omitempty"`
	Credentials   *WorkspaceConnectionUsernamePassword `json:"credentials,omitempty"`
	ExpiryTime    *string                              `json:"expiryTime,omitempty"`
	IsSharedToAll *bool                                `json:"isSharedToAll,omitempty"`

	// Metadata: Store user metadata for this connection
	Metadata       map[string]string `json:"metadata,omitempty"`
	SharedUserList []string          `json:"sharedUserList,omitempty"`
	Target         *string           `json:"target,omitempty"`

	// Value: Value details of the workspace connection.
	Value *string `json:"value,omitempty"`

	// ValueFormat: format for the workspace connection value
	ValueFormat *UsernamePasswordAuthTypeWorkspaceConnectionProperties_ValueFormat `json:"valueFormat,omitempty"`
}

var _ genruntime.ARMTransformer = &UsernamePasswordAuthTypeWorkspaceConnectionProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *UsernamePasswordAuthTypeWorkspaceConnectionProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.UsernamePasswordAuthTypeWorkspaceConnectionProperties{}

	// Set property "AuthType":
	if properties.AuthType != nil {
		var temp arm.UsernamePasswordAuthTypeWorkspaceConnectionProperties_AuthType
		var temp1 string
		temp1 = string(*properties.AuthType)
		temp = arm.UsernamePasswordAuthTypeWorkspaceConnectionProperties_AuthType(temp1)
		result.AuthType = temp
	}

	// Set property "Category":
	if properties.Category != nil {
		var temp string
		temp = string(*properties.Category)
		category := arm.ConnectionCategory(temp)
		result.Category = &category
	}

	// Set property "Credentials":
	if properties.Credentials != nil {
		credentials_ARM, err := (*properties.Credentials).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		credentials := *credentials_ARM.(*arm.WorkspaceConnectionUsernamePassword)
		result.Credentials = &credentials
	}

	// Set property "ExpiryTime":
	if properties.ExpiryTime != nil {
		expiryTime := *properties.ExpiryTime
		result.ExpiryTime = &expiryTime
	}

	// Set property "IsSharedToAll":
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		result.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if properties.Metadata != nil {
		result.Metadata = make(map[string]string, len(properties.Metadata))
		for key, value := range properties.Metadata {
			result.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range properties.SharedUserList {
		result.SharedUserList = append(result.SharedUserList, item)
	}

	// Set property "Target":
	if properties.Target != nil {
		target := *properties.Target
		result.Target = &target
	}

	// Set property "Value":
	if properties.Value != nil {
		value := *properties.Value
		result.Value = &value
	}

	// Set property "ValueFormat":
	if properties.ValueFormat != nil {
		var temp string
		temp = string(*properties.ValueFormat)
		valueFormat := arm.UsernamePasswordAuthTypeWorkspaceConnectionProperties_ValueFormat(temp)
		result.ValueFormat = &valueFormat
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *UsernamePasswordAuthTypeWorkspaceConnectionProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UsernamePasswordAuthTypeWorkspaceConnectionProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *UsernamePasswordAuthTypeWorkspaceConnectionProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UsernamePasswordAuthTypeWorkspaceConnectionProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UsernamePasswordAuthTypeWorkspaceConnectionProperties, got %T", armInput)
	}

	// Set property "AuthType":
	var temp UsernamePasswordAuthTypeWorkspaceConnectionProperties_AuthType
	var temp1 string
	temp1 = string(typedInput.AuthType)
	temp = UsernamePasswordAuthTypeWorkspaceConnectionProperties_AuthType(temp1)
	properties.AuthType = &temp

	// Set property "Category":
	if typedInput.Category != nil {
		var categoryTemp string
		categoryTemp = string(*typedInput.Category)
		category := ConnectionCategory(categoryTemp)
		properties.Category = &category
	}

	// Set property "Credentials":
	if typedInput.Credentials != nil {
		var credentials1 WorkspaceConnectionUsernamePassword
		err := credentials1.PopulateFromARM(owner, *typedInput.Credentials)
		if err != nil {
			return err
		}
		credentials := credentials1
		properties.Credentials = &credentials
	}

	// Set property "ExpiryTime":
	if typedInput.ExpiryTime != nil {
		expiryTime := *typedInput.ExpiryTime
		properties.ExpiryTime = &expiryTime
	}

	// Set property "IsSharedToAll":
	if typedInput.IsSharedToAll != nil {
		isSharedToAll := *typedInput.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if typedInput.Metadata != nil {
		properties.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			properties.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range typedInput.SharedUserList {
		properties.SharedUserList = append(properties.SharedUserList, item)
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		properties.Target = &target
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		properties.Value = &value
	}

	// Set property "ValueFormat":
	if typedInput.ValueFormat != nil {
		var valueFormatTemp string
		valueFormatTemp = string(*typedInput.ValueFormat)
		valueFormat := UsernamePasswordAuthTypeWorkspaceConnectionProperties_ValueFormat(valueFormatTemp)
		properties.ValueFormat = &valueFormat
	}

	// No error
	return nil
}

// AssignProperties_From_UsernamePasswordAuthTypeWorkspaceConnectionProperties populates our UsernamePasswordAuthTypeWorkspaceConnectionProperties from the provided source UsernamePasswordAuthTypeWorkspaceConnectionProperties
func (properties *UsernamePasswordAuthTypeWorkspaceConnectionProperties) AssignProperties_From_UsernamePasswordAuthTypeWorkspaceConnectionProperties(source *storage.UsernamePasswordAuthTypeWorkspaceConnectionProperties) error {

	// AuthType
	if source.AuthType != nil {
		authType := *source.AuthType
		authTypeTemp := genruntime.ToEnum(authType, usernamePasswordAuthTypeWorkspaceConnectionProperties_AuthType_Values)
		properties.AuthType = &authTypeTemp
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := *source.Category
		categoryTemp := genruntime.ToEnum(category, connectionCategory_Values)
		properties.Category = &categoryTemp
	} else {
		properties.Category = nil
	}

	// Credentials
	if source.Credentials != nil {
		var credential WorkspaceConnectionUsernamePassword
		err := credential.AssignProperties_From_WorkspaceConnectionUsernamePassword(source.Credentials)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WorkspaceConnectionUsernamePassword() to populate field Credentials")
		}
		properties.Credentials = &credential
	} else {
		properties.Credentials = nil
	}

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := *source.ValueFormat
		valueFormatTemp := genruntime.ToEnum(valueFormat, usernamePasswordAuthTypeWorkspaceConnectionProperties_ValueFormat_Values)
		properties.ValueFormat = &valueFormatTemp
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UsernamePasswordAuthTypeWorkspaceConnectionProperties populates the provided destination UsernamePasswordAuthTypeWorkspaceConnectionProperties from our UsernamePasswordAuthTypeWorkspaceConnectionProperties
func (properties *UsernamePasswordAuthTypeWorkspaceConnectionProperties) AssignProperties_To_UsernamePasswordAuthTypeWorkspaceConnectionProperties(destination *storage.UsernamePasswordAuthTypeWorkspaceConnectionProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthType
	if properties.AuthType != nil {
		authType := string(*properties.AuthType)
		destination.AuthType = &authType
	} else {
		destination.AuthType = nil
	}

	// Category
	if properties.Category != nil {
		category := string(*properties.Category)
		destination.Category = &category
	} else {
		destination.Category = nil
	}

	// Credentials
	if properties.Credentials != nil {
		var credential storage.WorkspaceConnectionUsernamePassword
		err := properties.Credentials.AssignProperties_To_WorkspaceConnectionUsernamePassword(&credential)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WorkspaceConnectionUsernamePassword() to populate field Credentials")
		}
		destination.Credentials = &credential
	} else {
		destination.Credentials = nil
	}

	// ExpiryTime
	destination.ExpiryTime = genruntime.ClonePointerToString(properties.ExpiryTime)

	// IsSharedToAll
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		destination.IsSharedToAll = &isSharedToAll
	} else {
		destination.IsSharedToAll = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(properties.Metadata)

	// SharedUserList
	destination.SharedUserList = genruntime.CloneSliceOfString(properties.SharedUserList)

	// Target
	destination.Target = genruntime.ClonePointerToString(properties.Target)

	// Value
	destination.Value = genruntime.ClonePointerToString(properties.Value)

	// ValueFormat
	if properties.ValueFormat != nil {
		valueFormat := string(*properties.ValueFormat)
		destination.ValueFormat = &valueFormat
	} else {
		destination.ValueFormat = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS populates our UsernamePasswordAuthTypeWorkspaceConnectionProperties from the provided source UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS
func (properties *UsernamePasswordAuthTypeWorkspaceConnectionProperties) Initialize_From_UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS(source *UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS) error {

	// AuthType
	if source.AuthType != nil {
		authType := genruntime.ToEnum(string(*source.AuthType), usernamePasswordAuthTypeWorkspaceConnectionProperties_AuthType_Values)
		properties.AuthType = &authType
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := genruntime.ToEnum(string(*source.Category), connectionCategory_Values)
		properties.Category = &category
	} else {
		properties.Category = nil
	}

	// Credentials
	if source.Credentials != nil {
		var credential WorkspaceConnectionUsernamePassword
		err := credential.Initialize_From_WorkspaceConnectionUsernamePassword_STATUS(source.Credentials)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_WorkspaceConnectionUsernamePassword_STATUS() to populate field Credentials")
		}
		properties.Credentials = &credential
	} else {
		properties.Credentials = nil
	}

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := genruntime.ToEnum(string(*source.ValueFormat), usernamePasswordAuthTypeWorkspaceConnectionProperties_ValueFormat_Values)
		properties.ValueFormat = &valueFormat
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

type UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS struct {
	// AuthType: Authentication type of the connection target
	AuthType *UsernamePasswordAuthTypeWorkspaceConnectionProperties_AuthType_STATUS `json:"authType,omitempty"`

	// Category: Category of the connection
	Category                *ConnectionCategory_STATUS                  `json:"category,omitempty"`
	CreatedByWorkspaceArmId *string                                     `json:"createdByWorkspaceArmId,omitempty"`
	Credentials             *WorkspaceConnectionUsernamePassword_STATUS `json:"credentials,omitempty"`
	ExpiryTime              *string                                     `json:"expiryTime,omitempty"`

	// Group: Group based on connection category
	Group         *ConnectionGroup_STATUS `json:"group,omitempty"`
	IsSharedToAll *bool                   `json:"isSharedToAll,omitempty"`

	// Metadata: Store user metadata for this connection
	Metadata       map[string]string `json:"metadata,omitempty"`
	SharedUserList []string          `json:"sharedUserList,omitempty"`
	Target         *string           `json:"target,omitempty"`

	// Value: Value details of the workspace connection.
	Value *string `json:"value,omitempty"`

	// ValueFormat: format for the workspace connection value
	ValueFormat *UsernamePasswordAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS `json:"valueFormat,omitempty"`
}

var _ genruntime.FromARMConverter = &UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS, got %T", armInput)
	}

	// Set property "AuthType":
	var temp UsernamePasswordAuthTypeWorkspaceConnectionProperties_AuthType_STATUS
	var temp1 string
	temp1 = string(typedInput.AuthType)
	temp = UsernamePasswordAuthTypeWorkspaceConnectionProperties_AuthType_STATUS(temp1)
	properties.AuthType = &temp

	// Set property "Category":
	if typedInput.Category != nil {
		var categoryTemp string
		categoryTemp = string(*typedInput.Category)
		category := ConnectionCategory_STATUS(categoryTemp)
		properties.Category = &category
	}

	// Set property "CreatedByWorkspaceArmId":
	if typedInput.CreatedByWorkspaceArmId != nil {
		createdByWorkspaceArmId := *typedInput.CreatedByWorkspaceArmId
		properties.CreatedByWorkspaceArmId = &createdByWorkspaceArmId
	}

	// Set property "Credentials":
	if typedInput.Credentials != nil {
		var credentials1 WorkspaceConnectionUsernamePassword_STATUS
		err := credentials1.PopulateFromARM(owner, *typedInput.Credentials)
		if err != nil {
			return err
		}
		credentials := credentials1
		properties.Credentials = &credentials
	}

	// Set property "ExpiryTime":
	if typedInput.ExpiryTime != nil {
		expiryTime := *typedInput.ExpiryTime
		properties.ExpiryTime = &expiryTime
	}

	// Set property "Group":
	if typedInput.Group != nil {
		var groupTemp string
		groupTemp = string(*typedInput.Group)
		group := ConnectionGroup_STATUS(groupTemp)
		properties.Group = &group
	}

	// Set property "IsSharedToAll":
	if typedInput.IsSharedToAll != nil {
		isSharedToAll := *typedInput.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	}

	// Set property "Metadata":
	if typedInput.Metadata != nil {
		properties.Metadata = make(map[string]string, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			properties.Metadata[key] = value
		}
	}

	// Set property "SharedUserList":
	for _, item := range typedInput.SharedUserList {
		properties.SharedUserList = append(properties.SharedUserList, item)
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		properties.Target = &target
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		properties.Value = &value
	}

	// Set property "ValueFormat":
	if typedInput.ValueFormat != nil {
		var valueFormatTemp string
		valueFormatTemp = string(*typedInput.ValueFormat)
		valueFormat := UsernamePasswordAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS(valueFormatTemp)
		properties.ValueFormat = &valueFormat
	}

	// No error
	return nil
}

// AssignProperties_From_UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS populates our UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS from the provided source UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS
func (properties *UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS) AssignProperties_From_UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS(source *storage.UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS) error {

	// AuthType
	if source.AuthType != nil {
		authType := *source.AuthType
		authTypeTemp := genruntime.ToEnum(authType, usernamePasswordAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_Values)
		properties.AuthType = &authTypeTemp
	} else {
		properties.AuthType = nil
	}

	// Category
	if source.Category != nil {
		category := *source.Category
		categoryTemp := genruntime.ToEnum(category, connectionCategory_STATUS_Values)
		properties.Category = &categoryTemp
	} else {
		properties.Category = nil
	}

	// CreatedByWorkspaceArmId
	properties.CreatedByWorkspaceArmId = genruntime.ClonePointerToString(source.CreatedByWorkspaceArmId)

	// Credentials
	if source.Credentials != nil {
		var credential WorkspaceConnectionUsernamePassword_STATUS
		err := credential.AssignProperties_From_WorkspaceConnectionUsernamePassword_STATUS(source.Credentials)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WorkspaceConnectionUsernamePassword_STATUS() to populate field Credentials")
		}
		properties.Credentials = &credential
	} else {
		properties.Credentials = nil
	}

	// ExpiryTime
	properties.ExpiryTime = genruntime.ClonePointerToString(source.ExpiryTime)

	// Group
	if source.Group != nil {
		group := *source.Group
		groupTemp := genruntime.ToEnum(group, connectionGroup_STATUS_Values)
		properties.Group = &groupTemp
	} else {
		properties.Group = nil
	}

	// IsSharedToAll
	if source.IsSharedToAll != nil {
		isSharedToAll := *source.IsSharedToAll
		properties.IsSharedToAll = &isSharedToAll
	} else {
		properties.IsSharedToAll = nil
	}

	// Metadata
	properties.Metadata = genruntime.CloneMapOfStringToString(source.Metadata)

	// SharedUserList
	properties.SharedUserList = genruntime.CloneSliceOfString(source.SharedUserList)

	// Target
	properties.Target = genruntime.ClonePointerToString(source.Target)

	// Value
	properties.Value = genruntime.ClonePointerToString(source.Value)

	// ValueFormat
	if source.ValueFormat != nil {
		valueFormat := *source.ValueFormat
		valueFormatTemp := genruntime.ToEnum(valueFormat, usernamePasswordAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_Values)
		properties.ValueFormat = &valueFormatTemp
	} else {
		properties.ValueFormat = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS populates the provided destination UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS from our UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS
func (properties *UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS) AssignProperties_To_UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS(destination *storage.UsernamePasswordAuthTypeWorkspaceConnectionProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthType
	if properties.AuthType != nil {
		authType := string(*properties.AuthType)
		destination.AuthType = &authType
	} else {
		destination.AuthType = nil
	}

	// Category
	if properties.Category != nil {
		category := string(*properties.Category)
		destination.Category = &category
	} else {
		destination.Category = nil
	}

	// CreatedByWorkspaceArmId
	destination.CreatedByWorkspaceArmId = genruntime.ClonePointerToString(properties.CreatedByWorkspaceArmId)

	// Credentials
	if properties.Credentials != nil {
		var credential storage.WorkspaceConnectionUsernamePassword_STATUS
		err := properties.Credentials.AssignProperties_To_WorkspaceConnectionUsernamePassword_STATUS(&credential)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WorkspaceConnectionUsernamePassword_STATUS() to populate field Credentials")
		}
		destination.Credentials = &credential
	} else {
		destination.Credentials = nil
	}

	// ExpiryTime
	destination.ExpiryTime = genruntime.ClonePointerToString(properties.ExpiryTime)

	// Group
	if properties.Group != nil {
		group := string(*properties.Group)
		destination.Group = &group
	} else {
		destination.Group = nil
	}

	// IsSharedToAll
	if properties.IsSharedToAll != nil {
		isSharedToAll := *properties.IsSharedToAll
		destination.IsSharedToAll = &isSharedToAll
	} else {
		destination.IsSharedToAll = nil
	}

	// Metadata
	destination.Metadata = genruntime.CloneMapOfStringToString(properties.Metadata)

	// SharedUserList
	destination.SharedUserList = genruntime.CloneSliceOfString(properties.SharedUserList)

	// Target
	destination.Target = genruntime.ClonePointerToString(properties.Target)

	// Value
	destination.Value = genruntime.ClonePointerToString(properties.Value)

	// ValueFormat
	if properties.ValueFormat != nil {
		valueFormat := string(*properties.ValueFormat)
		destination.ValueFormat = &valueFormat
	} else {
		destination.ValueFormat = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"AAD"}
type AADAuthTypeWorkspaceConnectionProperties_AuthType string

const AADAuthTypeWorkspaceConnectionProperties_AuthType_AAD = AADAuthTypeWorkspaceConnectionProperties_AuthType("AAD")

// Mapping from string to AADAuthTypeWorkspaceConnectionProperties_AuthType
var aADAuthTypeWorkspaceConnectionProperties_AuthType_Values = map[string]AADAuthTypeWorkspaceConnectionProperties_AuthType{
	"aad": AADAuthTypeWorkspaceConnectionProperties_AuthType_AAD,
}

type AADAuthTypeWorkspaceConnectionProperties_AuthType_STATUS string

const AADAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_AAD = AADAuthTypeWorkspaceConnectionProperties_AuthType_STATUS("AAD")

// Mapping from string to AADAuthTypeWorkspaceConnectionProperties_AuthType_STATUS
var aADAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_Values = map[string]AADAuthTypeWorkspaceConnectionProperties_AuthType_STATUS{
	"aad": AADAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_AAD,
}

// +kubebuilder:validation:Enum={"JSON"}
type AADAuthTypeWorkspaceConnectionProperties_ValueFormat string

const AADAuthTypeWorkspaceConnectionProperties_ValueFormat_JSON = AADAuthTypeWorkspaceConnectionProperties_ValueFormat("JSON")

// Mapping from string to AADAuthTypeWorkspaceConnectionProperties_ValueFormat
var aADAuthTypeWorkspaceConnectionProperties_ValueFormat_Values = map[string]AADAuthTypeWorkspaceConnectionProperties_ValueFormat{
	"json": AADAuthTypeWorkspaceConnectionProperties_ValueFormat_JSON,
}

type AADAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS string

const AADAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_JSON = AADAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS("JSON")

// Mapping from string to AADAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS
var aADAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_Values = map[string]AADAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS{
	"json": AADAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_JSON,
}

// +kubebuilder:validation:Enum={"AccessKey"}
type AccessKeyAuthTypeWorkspaceConnectionProperties_AuthType string

const AccessKeyAuthTypeWorkspaceConnectionProperties_AuthType_AccessKey = AccessKeyAuthTypeWorkspaceConnectionProperties_AuthType("AccessKey")

// Mapping from string to AccessKeyAuthTypeWorkspaceConnectionProperties_AuthType
var accessKeyAuthTypeWorkspaceConnectionProperties_AuthType_Values = map[string]AccessKeyAuthTypeWorkspaceConnectionProperties_AuthType{
	"accesskey": AccessKeyAuthTypeWorkspaceConnectionProperties_AuthType_AccessKey,
}

type AccessKeyAuthTypeWorkspaceConnectionProperties_AuthType_STATUS string

const AccessKeyAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_AccessKey = AccessKeyAuthTypeWorkspaceConnectionProperties_AuthType_STATUS("AccessKey")

// Mapping from string to AccessKeyAuthTypeWorkspaceConnectionProperties_AuthType_STATUS
var accessKeyAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_Values = map[string]AccessKeyAuthTypeWorkspaceConnectionProperties_AuthType_STATUS{
	"accesskey": AccessKeyAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_AccessKey,
}

// +kubebuilder:validation:Enum={"JSON"}
type AccessKeyAuthTypeWorkspaceConnectionProperties_ValueFormat string

const AccessKeyAuthTypeWorkspaceConnectionProperties_ValueFormat_JSON = AccessKeyAuthTypeWorkspaceConnectionProperties_ValueFormat("JSON")

// Mapping from string to AccessKeyAuthTypeWorkspaceConnectionProperties_ValueFormat
var accessKeyAuthTypeWorkspaceConnectionProperties_ValueFormat_Values = map[string]AccessKeyAuthTypeWorkspaceConnectionProperties_ValueFormat{
	"json": AccessKeyAuthTypeWorkspaceConnectionProperties_ValueFormat_JSON,
}

type AccessKeyAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS string

const AccessKeyAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_JSON = AccessKeyAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS("JSON")

// Mapping from string to AccessKeyAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS
var accessKeyAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_Values = map[string]AccessKeyAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS{
	"json": AccessKeyAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_JSON,
}

// +kubebuilder:validation:Enum={"AccountKey"}
type AccountKeyAuthTypeWorkspaceConnectionProperties_AuthType string

const AccountKeyAuthTypeWorkspaceConnectionProperties_AuthType_AccountKey = AccountKeyAuthTypeWorkspaceConnectionProperties_AuthType("AccountKey")

// Mapping from string to AccountKeyAuthTypeWorkspaceConnectionProperties_AuthType
var accountKeyAuthTypeWorkspaceConnectionProperties_AuthType_Values = map[string]AccountKeyAuthTypeWorkspaceConnectionProperties_AuthType{
	"accountkey": AccountKeyAuthTypeWorkspaceConnectionProperties_AuthType_AccountKey,
}

type AccountKeyAuthTypeWorkspaceConnectionProperties_AuthType_STATUS string

const AccountKeyAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_AccountKey = AccountKeyAuthTypeWorkspaceConnectionProperties_AuthType_STATUS("AccountKey")

// Mapping from string to AccountKeyAuthTypeWorkspaceConnectionProperties_AuthType_STATUS
var accountKeyAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_Values = map[string]AccountKeyAuthTypeWorkspaceConnectionProperties_AuthType_STATUS{
	"accountkey": AccountKeyAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_AccountKey,
}

// +kubebuilder:validation:Enum={"JSON"}
type AccountKeyAuthTypeWorkspaceConnectionProperties_ValueFormat string

const AccountKeyAuthTypeWorkspaceConnectionProperties_ValueFormat_JSON = AccountKeyAuthTypeWorkspaceConnectionProperties_ValueFormat("JSON")

// Mapping from string to AccountKeyAuthTypeWorkspaceConnectionProperties_ValueFormat
var accountKeyAuthTypeWorkspaceConnectionProperties_ValueFormat_Values = map[string]AccountKeyAuthTypeWorkspaceConnectionProperties_ValueFormat{
	"json": AccountKeyAuthTypeWorkspaceConnectionProperties_ValueFormat_JSON,
}

type AccountKeyAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS string

const AccountKeyAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_JSON = AccountKeyAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS("JSON")

// Mapping from string to AccountKeyAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS
var accountKeyAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_Values = map[string]AccountKeyAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS{
	"json": AccountKeyAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_JSON,
}

// +kubebuilder:validation:Enum={"ApiKey"}
type ApiKeyAuthWorkspaceConnectionProperties_AuthType string

const ApiKeyAuthWorkspaceConnectionProperties_AuthType_ApiKey = ApiKeyAuthWorkspaceConnectionProperties_AuthType("ApiKey")

// Mapping from string to ApiKeyAuthWorkspaceConnectionProperties_AuthType
var apiKeyAuthWorkspaceConnectionProperties_AuthType_Values = map[string]ApiKeyAuthWorkspaceConnectionProperties_AuthType{
	"apikey": ApiKeyAuthWorkspaceConnectionProperties_AuthType_ApiKey,
}

type ApiKeyAuthWorkspaceConnectionProperties_AuthType_STATUS string

const ApiKeyAuthWorkspaceConnectionProperties_AuthType_STATUS_ApiKey = ApiKeyAuthWorkspaceConnectionProperties_AuthType_STATUS("ApiKey")

// Mapping from string to ApiKeyAuthWorkspaceConnectionProperties_AuthType_STATUS
var apiKeyAuthWorkspaceConnectionProperties_AuthType_STATUS_Values = map[string]ApiKeyAuthWorkspaceConnectionProperties_AuthType_STATUS{
	"apikey": ApiKeyAuthWorkspaceConnectionProperties_AuthType_STATUS_ApiKey,
}

// +kubebuilder:validation:Enum={"JSON"}
type ApiKeyAuthWorkspaceConnectionProperties_ValueFormat string

const ApiKeyAuthWorkspaceConnectionProperties_ValueFormat_JSON = ApiKeyAuthWorkspaceConnectionProperties_ValueFormat("JSON")

// Mapping from string to ApiKeyAuthWorkspaceConnectionProperties_ValueFormat
var apiKeyAuthWorkspaceConnectionProperties_ValueFormat_Values = map[string]ApiKeyAuthWorkspaceConnectionProperties_ValueFormat{
	"json": ApiKeyAuthWorkspaceConnectionProperties_ValueFormat_JSON,
}

type ApiKeyAuthWorkspaceConnectionProperties_ValueFormat_STATUS string

const ApiKeyAuthWorkspaceConnectionProperties_ValueFormat_STATUS_JSON = ApiKeyAuthWorkspaceConnectionProperties_ValueFormat_STATUS("JSON")

// Mapping from string to ApiKeyAuthWorkspaceConnectionProperties_ValueFormat_STATUS
var apiKeyAuthWorkspaceConnectionProperties_ValueFormat_STATUS_Values = map[string]ApiKeyAuthWorkspaceConnectionProperties_ValueFormat_STATUS{
	"json": ApiKeyAuthWorkspaceConnectionProperties_ValueFormat_STATUS_JSON,
}

// Category of the connection
// +kubebuilder:validation:Enum={"ADLSGen2","AIServices","AmazonMws","AmazonRdsForOracle","AmazonRdsForSqlServer","AmazonRedshift","AmazonS3Compatible","ApiKey","AzureBlob","AzureDataExplorer","AzureDatabricksDeltaLake","AzureMariaDb","AzureMySqlDb","AzureOneLake","AzureOpenAI","AzurePostgresDb","AzureSqlDb","AzureSqlMi","AzureSynapseAnalytics","AzureTableStorage","BingLLMSearch","Cassandra","CognitiveSearch","CognitiveService","Concur","ContainerRegistry","CosmosDb","CosmosDbMongoDbApi","Couchbase","CustomKeys","Db2","Drill","Dynamics","DynamicsAx","DynamicsCrm","Eloqua","FileServer","FtpServer","GenericContainerRegistry","GenericHttp","GenericRest","Git","GoogleAdWords","GoogleBigQuery","GoogleCloudStorage","Greenplum","Hbase","Hdfs","Hive","Hubspot","Impala","Informix","Jira","Magento","MariaDb","Marketo","MicrosoftAccess","MongoDbAtlas","MongoDbV2","MySql","Netezza","ODataRest","Odbc","Office365","OpenAI","Oracle","OracleCloudStorage","OracleServiceCloud","PayPal","Phoenix","PostgreSql","Presto","PythonFeed","QuickBooks","Redis","Responsys","S3","Salesforce","SalesforceMarketingCloud","SalesforceServiceCloud","SapBw","SapCloudForCustomer","SapEcc","SapHana","SapOpenHub","SapTable","Serp","Serverless","ServiceNow","Sftp","SharePointOnlineList","Shopify","Snowflake","Spark","SqlServer","Square","Sybase","Teradata","Vertica","WebTable","Xero","Zoho"}
type ConnectionCategory string

const (
	ConnectionCategory_ADLSGen2                 = ConnectionCategory("ADLSGen2")
	ConnectionCategory_AIServices               = ConnectionCategory("AIServices")
	ConnectionCategory_AmazonMws                = ConnectionCategory("AmazonMws")
	ConnectionCategory_AmazonRdsForOracle       = ConnectionCategory("AmazonRdsForOracle")
	ConnectionCategory_AmazonRdsForSqlServer    = ConnectionCategory("AmazonRdsForSqlServer")
	ConnectionCategory_AmazonRedshift           = ConnectionCategory("AmazonRedshift")
	ConnectionCategory_AmazonS3Compatible       = ConnectionCategory("AmazonS3Compatible")
	ConnectionCategory_ApiKey                   = ConnectionCategory("ApiKey")
	ConnectionCategory_AzureBlob                = ConnectionCategory("AzureBlob")
	ConnectionCategory_AzureDataExplorer        = ConnectionCategory("AzureDataExplorer")
	ConnectionCategory_AzureDatabricksDeltaLake = ConnectionCategory("AzureDatabricksDeltaLake")
	ConnectionCategory_AzureMariaDb             = ConnectionCategory("AzureMariaDb")
	ConnectionCategory_AzureMySqlDb             = ConnectionCategory("AzureMySqlDb")
	ConnectionCategory_AzureOneLake             = ConnectionCategory("AzureOneLake")
	ConnectionCategory_AzureOpenAI              = ConnectionCategory("AzureOpenAI")
	ConnectionCategory_AzurePostgresDb          = ConnectionCategory("AzurePostgresDb")
	ConnectionCategory_AzureSqlDb               = ConnectionCategory("AzureSqlDb")
	ConnectionCategory_AzureSqlMi               = ConnectionCategory("AzureSqlMi")
	ConnectionCategory_AzureSynapseAnalytics    = ConnectionCategory("AzureSynapseAnalytics")
	ConnectionCategory_AzureTableStorage        = ConnectionCategory("AzureTableStorage")
	ConnectionCategory_BingLLMSearch            = ConnectionCategory("BingLLMSearch")
	ConnectionCategory_Cassandra                = ConnectionCategory("Cassandra")
	ConnectionCategory_CognitiveSearch          = ConnectionCategory("CognitiveSearch")
	ConnectionCategory_CognitiveService         = ConnectionCategory("CognitiveService")
	ConnectionCategory_Concur                   = ConnectionCategory("Concur")
	ConnectionCategory_ContainerRegistry        = ConnectionCategory("ContainerRegistry")
	ConnectionCategory_CosmosDb                 = ConnectionCategory("CosmosDb")
	ConnectionCategory_CosmosDbMongoDbApi       = ConnectionCategory("CosmosDbMongoDbApi")
	ConnectionCategory_Couchbase                = ConnectionCategory("Couchbase")
	ConnectionCategory_CustomKeys               = ConnectionCategory("CustomKeys")
	ConnectionCategory_Db2                      = ConnectionCategory("Db2")
	ConnectionCategory_Drill                    = ConnectionCategory("Drill")
	ConnectionCategory_Dynamics                 = ConnectionCategory("Dynamics")
	ConnectionCategory_DynamicsAx               = ConnectionCategory("DynamicsAx")
	ConnectionCategory_DynamicsCrm              = ConnectionCategory("DynamicsCrm")
	ConnectionCategory_Eloqua                   = ConnectionCategory("Eloqua")
	ConnectionCategory_FileServer               = ConnectionCategory("FileServer")
	ConnectionCategory_FtpServer                = ConnectionCategory("FtpServer")
	ConnectionCategory_GenericContainerRegistry = ConnectionCategory("GenericContainerRegistry")
	ConnectionCategory_GenericHttp              = ConnectionCategory("GenericHttp")
	ConnectionCategory_GenericRest              = ConnectionCategory("GenericRest")
	ConnectionCategory_Git                      = ConnectionCategory("Git")
	ConnectionCategory_GoogleAdWords            = ConnectionCategory("GoogleAdWords")
	ConnectionCategory_GoogleBigQuery           = ConnectionCategory("GoogleBigQuery")
	ConnectionCategory_GoogleCloudStorage       = ConnectionCategory("GoogleCloudStorage")
	ConnectionCategory_Greenplum                = ConnectionCategory("Greenplum")
	ConnectionCategory_Hbase                    = ConnectionCategory("Hbase")
	ConnectionCategory_Hdfs                     = ConnectionCategory("Hdfs")
	ConnectionCategory_Hive                     = ConnectionCategory("Hive")
	ConnectionCategory_Hubspot                  = ConnectionCategory("Hubspot")
	ConnectionCategory_Impala                   = ConnectionCategory("Impala")
	ConnectionCategory_Informix                 = ConnectionCategory("Informix")
	ConnectionCategory_Jira                     = ConnectionCategory("Jira")
	ConnectionCategory_Magento                  = ConnectionCategory("Magento")
	ConnectionCategory_MariaDb                  = ConnectionCategory("MariaDb")
	ConnectionCategory_Marketo                  = ConnectionCategory("Marketo")
	ConnectionCategory_MicrosoftAccess          = ConnectionCategory("MicrosoftAccess")
	ConnectionCategory_MongoDbAtlas             = ConnectionCategory("MongoDbAtlas")
	ConnectionCategory_MongoDbV2                = ConnectionCategory("MongoDbV2")
	ConnectionCategory_MySql                    = ConnectionCategory("MySql")
	ConnectionCategory_Netezza                  = ConnectionCategory("Netezza")
	ConnectionCategory_ODataRest                = ConnectionCategory("ODataRest")
	ConnectionCategory_Odbc                     = ConnectionCategory("Odbc")
	ConnectionCategory_Office365                = ConnectionCategory("Office365")
	ConnectionCategory_OpenAI                   = ConnectionCategory("OpenAI")
	ConnectionCategory_Oracle                   = ConnectionCategory("Oracle")
	ConnectionCategory_OracleCloudStorage       = ConnectionCategory("OracleCloudStorage")
	ConnectionCategory_OracleServiceCloud       = ConnectionCategory("OracleServiceCloud")
	ConnectionCategory_PayPal                   = ConnectionCategory("PayPal")
	ConnectionCategory_Phoenix                  = ConnectionCategory("Phoenix")
	ConnectionCategory_PostgreSql               = ConnectionCategory("PostgreSql")
	ConnectionCategory_Presto                   = ConnectionCategory("Presto")
	ConnectionCategory_PythonFeed               = ConnectionCategory("PythonFeed")
	ConnectionCategory_QuickBooks               = ConnectionCategory("QuickBooks")
	ConnectionCategory_Redis                    = ConnectionCategory("Redis")
	ConnectionCategory_Responsys                = ConnectionCategory("Responsys")
	ConnectionCategory_S3                       = ConnectionCategory("S3")
	ConnectionCategory_Salesforce               = ConnectionCategory("Salesforce")
	ConnectionCategory_SalesforceMarketingCloud = ConnectionCategory("SalesforceMarketingCloud")
	ConnectionCategory_SalesforceServiceCloud   = ConnectionCategory("SalesforceServiceCloud")
	ConnectionCategory_SapBw                    = ConnectionCategory("SapBw")
	ConnectionCategory_SapCloudForCustomer      = ConnectionCategory("SapCloudForCustomer")
	ConnectionCategory_SapEcc                   = ConnectionCategory("SapEcc")
	ConnectionCategory_SapHana                  = ConnectionCategory("SapHana")
	ConnectionCategory_SapOpenHub               = ConnectionCategory("SapOpenHub")
	ConnectionCategory_SapTable                 = ConnectionCategory("SapTable")
	ConnectionCategory_Serp                     = ConnectionCategory("Serp")
	ConnectionCategory_Serverless               = ConnectionCategory("Serverless")
	ConnectionCategory_ServiceNow               = ConnectionCategory("ServiceNow")
	ConnectionCategory_Sftp                     = ConnectionCategory("Sftp")
	ConnectionCategory_SharePointOnlineList     = ConnectionCategory("SharePointOnlineList")
	ConnectionCategory_Shopify                  = ConnectionCategory("Shopify")
	ConnectionCategory_Snowflake                = ConnectionCategory("Snowflake")
	ConnectionCategory_Spark                    = ConnectionCategory("Spark")
	ConnectionCategory_SqlServer                = ConnectionCategory("SqlServer")
	ConnectionCategory_Square                   = ConnectionCategory("Square")
	ConnectionCategory_Sybase                   = ConnectionCategory("Sybase")
	ConnectionCategory_Teradata                 = ConnectionCategory("Teradata")
	ConnectionCategory_Vertica                  = ConnectionCategory("Vertica")
	ConnectionCategory_WebTable                 = ConnectionCategory("WebTable")
	ConnectionCategory_Xero                     = ConnectionCategory("Xero")
	ConnectionCategory_Zoho                     = ConnectionCategory("Zoho")
)

// Mapping from string to ConnectionCategory
var connectionCategory_Values = map[string]ConnectionCategory{
	"adlsgen2":                 ConnectionCategory_ADLSGen2,
	"aiservices":               ConnectionCategory_AIServices,
	"amazonmws":                ConnectionCategory_AmazonMws,
	"amazonrdsfororacle":       ConnectionCategory_AmazonRdsForOracle,
	"amazonrdsforsqlserver":    ConnectionCategory_AmazonRdsForSqlServer,
	"amazonredshift":           ConnectionCategory_AmazonRedshift,
	"amazons3compatible":       ConnectionCategory_AmazonS3Compatible,
	"apikey":                   ConnectionCategory_ApiKey,
	"azureblob":                ConnectionCategory_AzureBlob,
	"azuredataexplorer":        ConnectionCategory_AzureDataExplorer,
	"azuredatabricksdeltalake": ConnectionCategory_AzureDatabricksDeltaLake,
	"azuremariadb":             ConnectionCategory_AzureMariaDb,
	"azuremysqldb":             ConnectionCategory_AzureMySqlDb,
	"azureonelake":             ConnectionCategory_AzureOneLake,
	"azureopenai":              ConnectionCategory_AzureOpenAI,
	"azurepostgresdb":          ConnectionCategory_AzurePostgresDb,
	"azuresqldb":               ConnectionCategory_AzureSqlDb,
	"azuresqlmi":               ConnectionCategory_AzureSqlMi,
	"azuresynapseanalytics":    ConnectionCategory_AzureSynapseAnalytics,
	"azuretablestorage":        ConnectionCategory_AzureTableStorage,
	"bingllmsearch":            ConnectionCategory_BingLLMSearch,
	"cassandra":                ConnectionCategory_Cassandra,
	"cognitivesearch":          ConnectionCategory_CognitiveSearch,
	"cognitiveservice":         ConnectionCategory_CognitiveService,
	"concur":                   ConnectionCategory_Concur,
	"containerregistry":        ConnectionCategory_ContainerRegistry,
	"cosmosdb":                 ConnectionCategory_CosmosDb,
	"cosmosdbmongodbapi":       ConnectionCategory_CosmosDbMongoDbApi,
	"couchbase":                ConnectionCategory_Couchbase,
	"customkeys":               ConnectionCategory_CustomKeys,
	"db2":                      ConnectionCategory_Db2,
	"drill":                    ConnectionCategory_Drill,
	"dynamics":                 ConnectionCategory_Dynamics,
	"dynamicsax":               ConnectionCategory_DynamicsAx,
	"dynamicscrm":              ConnectionCategory_DynamicsCrm,
	"eloqua":                   ConnectionCategory_Eloqua,
	"fileserver":               ConnectionCategory_FileServer,
	"ftpserver":                ConnectionCategory_FtpServer,
	"genericcontainerregistry": ConnectionCategory_GenericContainerRegistry,
	"generichttp":              ConnectionCategory_GenericHttp,
	"genericrest":              ConnectionCategory_GenericRest,
	"git":                      ConnectionCategory_Git,
	"googleadwords":            ConnectionCategory_GoogleAdWords,
	"googlebigquery":           ConnectionCategory_GoogleBigQuery,
	"googlecloudstorage":       ConnectionCategory_GoogleCloudStorage,
	"greenplum":                ConnectionCategory_Greenplum,
	"hbase":                    ConnectionCategory_Hbase,
	"hdfs":                     ConnectionCategory_Hdfs,
	"hive":                     ConnectionCategory_Hive,
	"hubspot":                  ConnectionCategory_Hubspot,
	"impala":                   ConnectionCategory_Impala,
	"informix":                 ConnectionCategory_Informix,
	"jira":                     ConnectionCategory_Jira,
	"magento":                  ConnectionCategory_Magento,
	"mariadb":                  ConnectionCategory_MariaDb,
	"marketo":                  ConnectionCategory_Marketo,
	"microsoftaccess":          ConnectionCategory_MicrosoftAccess,
	"mongodbatlas":             ConnectionCategory_MongoDbAtlas,
	"mongodbv2":                ConnectionCategory_MongoDbV2,
	"mysql":                    ConnectionCategory_MySql,
	"netezza":                  ConnectionCategory_Netezza,
	"odatarest":                ConnectionCategory_ODataRest,
	"odbc":                     ConnectionCategory_Odbc,
	"office365":                ConnectionCategory_Office365,
	"openai":                   ConnectionCategory_OpenAI,
	"oracle":                   ConnectionCategory_Oracle,
	"oraclecloudstorage":       ConnectionCategory_OracleCloudStorage,
	"oracleservicecloud":       ConnectionCategory_OracleServiceCloud,
	"paypal":                   ConnectionCategory_PayPal,
	"phoenix":                  ConnectionCategory_Phoenix,
	"postgresql":               ConnectionCategory_PostgreSql,
	"presto":                   ConnectionCategory_Presto,
	"pythonfeed":               ConnectionCategory_PythonFeed,
	"quickbooks":               ConnectionCategory_QuickBooks,
	"redis":                    ConnectionCategory_Redis,
	"responsys":                ConnectionCategory_Responsys,
	"s3":                       ConnectionCategory_S3,
	"salesforce":               ConnectionCategory_Salesforce,
	"salesforcemarketingcloud": ConnectionCategory_SalesforceMarketingCloud,
	"salesforceservicecloud":   ConnectionCategory_SalesforceServiceCloud,
	"sapbw":                    ConnectionCategory_SapBw,
	"sapcloudforcustomer":      ConnectionCategory_SapCloudForCustomer,
	"sapecc":                   ConnectionCategory_SapEcc,
	"saphana":                  ConnectionCategory_SapHana,
	"sapopenhub":               ConnectionCategory_SapOpenHub,
	"saptable":                 ConnectionCategory_SapTable,
	"serp":                     ConnectionCategory_Serp,
	"serverless":               ConnectionCategory_Serverless,
	"servicenow":               ConnectionCategory_ServiceNow,
	"sftp":                     ConnectionCategory_Sftp,
	"sharepointonlinelist":     ConnectionCategory_SharePointOnlineList,
	"shopify":                  ConnectionCategory_Shopify,
	"snowflake":                ConnectionCategory_Snowflake,
	"spark":                    ConnectionCategory_Spark,
	"sqlserver":                ConnectionCategory_SqlServer,
	"square":                   ConnectionCategory_Square,
	"sybase":                   ConnectionCategory_Sybase,
	"teradata":                 ConnectionCategory_Teradata,
	"vertica":                  ConnectionCategory_Vertica,
	"webtable":                 ConnectionCategory_WebTable,
	"xero":                     ConnectionCategory_Xero,
	"zoho":                     ConnectionCategory_Zoho,
}

// Category of the connection
type ConnectionCategory_STATUS string

const (
	ConnectionCategory_STATUS_ADLSGen2                 = ConnectionCategory_STATUS("ADLSGen2")
	ConnectionCategory_STATUS_AIServices               = ConnectionCategory_STATUS("AIServices")
	ConnectionCategory_STATUS_AmazonMws                = ConnectionCategory_STATUS("AmazonMws")
	ConnectionCategory_STATUS_AmazonRdsForOracle       = ConnectionCategory_STATUS("AmazonRdsForOracle")
	ConnectionCategory_STATUS_AmazonRdsForSqlServer    = ConnectionCategory_STATUS("AmazonRdsForSqlServer")
	ConnectionCategory_STATUS_AmazonRedshift           = ConnectionCategory_STATUS("AmazonRedshift")
	ConnectionCategory_STATUS_AmazonS3Compatible       = ConnectionCategory_STATUS("AmazonS3Compatible")
	ConnectionCategory_STATUS_ApiKey                   = ConnectionCategory_STATUS("ApiKey")
	ConnectionCategory_STATUS_AzureBlob                = ConnectionCategory_STATUS("AzureBlob")
	ConnectionCategory_STATUS_AzureDataExplorer        = ConnectionCategory_STATUS("AzureDataExplorer")
	ConnectionCategory_STATUS_AzureDatabricksDeltaLake = ConnectionCategory_STATUS("AzureDatabricksDeltaLake")
	ConnectionCategory_STATUS_AzureMariaDb             = ConnectionCategory_STATUS("AzureMariaDb")
	ConnectionCategory_STATUS_AzureMySqlDb             = ConnectionCategory_STATUS("AzureMySqlDb")
	ConnectionCategory_STATUS_AzureOneLake             = ConnectionCategory_STATUS("AzureOneLake")
	ConnectionCategory_STATUS_AzureOpenAI              = ConnectionCategory_STATUS("AzureOpenAI")
	ConnectionCategory_STATUS_AzurePostgresDb          = ConnectionCategory_STATUS("AzurePostgresDb")
	ConnectionCategory_STATUS_AzureSqlDb               = ConnectionCategory_STATUS("AzureSqlDb")
	ConnectionCategory_STATUS_AzureSqlMi               = ConnectionCategory_STATUS("AzureSqlMi")
	ConnectionCategory_STATUS_AzureSynapseAnalytics    = ConnectionCategory_STATUS("AzureSynapseAnalytics")
	ConnectionCategory_STATUS_AzureTableStorage        = ConnectionCategory_STATUS("AzureTableStorage")
	ConnectionCategory_STATUS_BingLLMSearch            = ConnectionCategory_STATUS("BingLLMSearch")
	ConnectionCategory_STATUS_Cassandra                = ConnectionCategory_STATUS("Cassandra")
	ConnectionCategory_STATUS_CognitiveSearch          = ConnectionCategory_STATUS("CognitiveSearch")
	ConnectionCategory_STATUS_CognitiveService         = ConnectionCategory_STATUS("CognitiveService")
	ConnectionCategory_STATUS_Concur                   = ConnectionCategory_STATUS("Concur")
	ConnectionCategory_STATUS_ContainerRegistry        = ConnectionCategory_STATUS("ContainerRegistry")
	ConnectionCategory_STATUS_CosmosDb                 = ConnectionCategory_STATUS("CosmosDb")
	ConnectionCategory_STATUS_CosmosDbMongoDbApi       = ConnectionCategory_STATUS("CosmosDbMongoDbApi")
	ConnectionCategory_STATUS_Couchbase                = ConnectionCategory_STATUS("Couchbase")
	ConnectionCategory_STATUS_CustomKeys               = ConnectionCategory_STATUS("CustomKeys")
	ConnectionCategory_STATUS_Db2                      = ConnectionCategory_STATUS("Db2")
	ConnectionCategory_STATUS_Drill                    = ConnectionCategory_STATUS("Drill")
	ConnectionCategory_STATUS_Dynamics                 = ConnectionCategory_STATUS("Dynamics")
	ConnectionCategory_STATUS_DynamicsAx               = ConnectionCategory_STATUS("DynamicsAx")
	ConnectionCategory_STATUS_DynamicsCrm              = ConnectionCategory_STATUS("DynamicsCrm")
	ConnectionCategory_STATUS_Eloqua                   = ConnectionCategory_STATUS("Eloqua")
	ConnectionCategory_STATUS_FileServer               = ConnectionCategory_STATUS("FileServer")
	ConnectionCategory_STATUS_FtpServer                = ConnectionCategory_STATUS("FtpServer")
	ConnectionCategory_STATUS_GenericContainerRegistry = ConnectionCategory_STATUS("GenericContainerRegistry")
	ConnectionCategory_STATUS_GenericHttp              = ConnectionCategory_STATUS("GenericHttp")
	ConnectionCategory_STATUS_GenericRest              = ConnectionCategory_STATUS("GenericRest")
	ConnectionCategory_STATUS_Git                      = ConnectionCategory_STATUS("Git")
	ConnectionCategory_STATUS_GoogleAdWords            = ConnectionCategory_STATUS("GoogleAdWords")
	ConnectionCategory_STATUS_GoogleBigQuery           = ConnectionCategory_STATUS("GoogleBigQuery")
	ConnectionCategory_STATUS_GoogleCloudStorage       = ConnectionCategory_STATUS("GoogleCloudStorage")
	ConnectionCategory_STATUS_Greenplum                = ConnectionCategory_STATUS("Greenplum")
	ConnectionCategory_STATUS_Hbase                    = ConnectionCategory_STATUS("Hbase")
	ConnectionCategory_STATUS_Hdfs                     = ConnectionCategory_STATUS("Hdfs")
	ConnectionCategory_STATUS_Hive                     = ConnectionCategory_STATUS("Hive")
	ConnectionCategory_STATUS_Hubspot                  = ConnectionCategory_STATUS("Hubspot")
	ConnectionCategory_STATUS_Impala                   = ConnectionCategory_STATUS("Impala")
	ConnectionCategory_STATUS_Informix                 = ConnectionCategory_STATUS("Informix")
	ConnectionCategory_STATUS_Jira                     = ConnectionCategory_STATUS("Jira")
	ConnectionCategory_STATUS_Magento                  = ConnectionCategory_STATUS("Magento")
	ConnectionCategory_STATUS_MariaDb                  = ConnectionCategory_STATUS("MariaDb")
	ConnectionCategory_STATUS_Marketo                  = ConnectionCategory_STATUS("Marketo")
	ConnectionCategory_STATUS_MicrosoftAccess          = ConnectionCategory_STATUS("MicrosoftAccess")
	ConnectionCategory_STATUS_MongoDbAtlas             = ConnectionCategory_STATUS("MongoDbAtlas")
	ConnectionCategory_STATUS_MongoDbV2                = ConnectionCategory_STATUS("MongoDbV2")
	ConnectionCategory_STATUS_MySql                    = ConnectionCategory_STATUS("MySql")
	ConnectionCategory_STATUS_Netezza                  = ConnectionCategory_STATUS("Netezza")
	ConnectionCategory_STATUS_ODataRest                = ConnectionCategory_STATUS("ODataRest")
	ConnectionCategory_STATUS_Odbc                     = ConnectionCategory_STATUS("Odbc")
	ConnectionCategory_STATUS_Office365                = ConnectionCategory_STATUS("Office365")
	ConnectionCategory_STATUS_OpenAI                   = ConnectionCategory_STATUS("OpenAI")
	ConnectionCategory_STATUS_Oracle                   = ConnectionCategory_STATUS("Oracle")
	ConnectionCategory_STATUS_OracleCloudStorage       = ConnectionCategory_STATUS("OracleCloudStorage")
	ConnectionCategory_STATUS_OracleServiceCloud       = ConnectionCategory_STATUS("OracleServiceCloud")
	ConnectionCategory_STATUS_PayPal                   = ConnectionCategory_STATUS("PayPal")
	ConnectionCategory_STATUS_Phoenix                  = ConnectionCategory_STATUS("Phoenix")
	ConnectionCategory_STATUS_PostgreSql               = ConnectionCategory_STATUS("PostgreSql")
	ConnectionCategory_STATUS_Presto                   = ConnectionCategory_STATUS("Presto")
	ConnectionCategory_STATUS_PythonFeed               = ConnectionCategory_STATUS("PythonFeed")
	ConnectionCategory_STATUS_QuickBooks               = ConnectionCategory_STATUS("QuickBooks")
	ConnectionCategory_STATUS_Redis                    = ConnectionCategory_STATUS("Redis")
	ConnectionCategory_STATUS_Responsys                = ConnectionCategory_STATUS("Responsys")
	ConnectionCategory_STATUS_S3                       = ConnectionCategory_STATUS("S3")
	ConnectionCategory_STATUS_Salesforce               = ConnectionCategory_STATUS("Salesforce")
	ConnectionCategory_STATUS_SalesforceMarketingCloud = ConnectionCategory_STATUS("SalesforceMarketingCloud")
	ConnectionCategory_STATUS_SalesforceServiceCloud   = ConnectionCategory_STATUS("SalesforceServiceCloud")
	ConnectionCategory_STATUS_SapBw                    = ConnectionCategory_STATUS("SapBw")
	ConnectionCategory_STATUS_SapCloudForCustomer      = ConnectionCategory_STATUS("SapCloudForCustomer")
	ConnectionCategory_STATUS_SapEcc                   = ConnectionCategory_STATUS("SapEcc")
	ConnectionCategory_STATUS_SapHana                  = ConnectionCategory_STATUS("SapHana")
	ConnectionCategory_STATUS_SapOpenHub               = ConnectionCategory_STATUS("SapOpenHub")
	ConnectionCategory_STATUS_SapTable                 = ConnectionCategory_STATUS("SapTable")
	ConnectionCategory_STATUS_Serp                     = ConnectionCategory_STATUS("Serp")
	ConnectionCategory_STATUS_Serverless               = ConnectionCategory_STATUS("Serverless")
	ConnectionCategory_STATUS_ServiceNow               = ConnectionCategory_STATUS("ServiceNow")
	ConnectionCategory_STATUS_Sftp                     = ConnectionCategory_STATUS("Sftp")
	ConnectionCategory_STATUS_SharePointOnlineList     = ConnectionCategory_STATUS("SharePointOnlineList")
	ConnectionCategory_STATUS_Shopify                  = ConnectionCategory_STATUS("Shopify")
	ConnectionCategory_STATUS_Snowflake                = ConnectionCategory_STATUS("Snowflake")
	ConnectionCategory_STATUS_Spark                    = ConnectionCategory_STATUS("Spark")
	ConnectionCategory_STATUS_SqlServer                = ConnectionCategory_STATUS("SqlServer")
	ConnectionCategory_STATUS_Square                   = ConnectionCategory_STATUS("Square")
	ConnectionCategory_STATUS_Sybase                   = ConnectionCategory_STATUS("Sybase")
	ConnectionCategory_STATUS_Teradata                 = ConnectionCategory_STATUS("Teradata")
	ConnectionCategory_STATUS_Vertica                  = ConnectionCategory_STATUS("Vertica")
	ConnectionCategory_STATUS_WebTable                 = ConnectionCategory_STATUS("WebTable")
	ConnectionCategory_STATUS_Xero                     = ConnectionCategory_STATUS("Xero")
	ConnectionCategory_STATUS_Zoho                     = ConnectionCategory_STATUS("Zoho")
)

// Mapping from string to ConnectionCategory_STATUS
var connectionCategory_STATUS_Values = map[string]ConnectionCategory_STATUS{
	"adlsgen2":                 ConnectionCategory_STATUS_ADLSGen2,
	"aiservices":               ConnectionCategory_STATUS_AIServices,
	"amazonmws":                ConnectionCategory_STATUS_AmazonMws,
	"amazonrdsfororacle":       ConnectionCategory_STATUS_AmazonRdsForOracle,
	"amazonrdsforsqlserver":    ConnectionCategory_STATUS_AmazonRdsForSqlServer,
	"amazonredshift":           ConnectionCategory_STATUS_AmazonRedshift,
	"amazons3compatible":       ConnectionCategory_STATUS_AmazonS3Compatible,
	"apikey":                   ConnectionCategory_STATUS_ApiKey,
	"azureblob":                ConnectionCategory_STATUS_AzureBlob,
	"azuredataexplorer":        ConnectionCategory_STATUS_AzureDataExplorer,
	"azuredatabricksdeltalake": ConnectionCategory_STATUS_AzureDatabricksDeltaLake,
	"azuremariadb":             ConnectionCategory_STATUS_AzureMariaDb,
	"azuremysqldb":             ConnectionCategory_STATUS_AzureMySqlDb,
	"azureonelake":             ConnectionCategory_STATUS_AzureOneLake,
	"azureopenai":              ConnectionCategory_STATUS_AzureOpenAI,
	"azurepostgresdb":          ConnectionCategory_STATUS_AzurePostgresDb,
	"azuresqldb":               ConnectionCategory_STATUS_AzureSqlDb,
	"azuresqlmi":               ConnectionCategory_STATUS_AzureSqlMi,
	"azuresynapseanalytics":    ConnectionCategory_STATUS_AzureSynapseAnalytics,
	"azuretablestorage":        ConnectionCategory_STATUS_AzureTableStorage,
	"bingllmsearch":            ConnectionCategory_STATUS_BingLLMSearch,
	"cassandra":                ConnectionCategory_STATUS_Cassandra,
	"cognitivesearch":          ConnectionCategory_STATUS_CognitiveSearch,
	"cognitiveservice":         ConnectionCategory_STATUS_CognitiveService,
	"concur":                   ConnectionCategory_STATUS_Concur,
	"containerregistry":        ConnectionCategory_STATUS_ContainerRegistry,
	"cosmosdb":                 ConnectionCategory_STATUS_CosmosDb,
	"cosmosdbmongodbapi":       ConnectionCategory_STATUS_CosmosDbMongoDbApi,
	"couchbase":                ConnectionCategory_STATUS_Couchbase,
	"customkeys":               ConnectionCategory_STATUS_CustomKeys,
	"db2":                      ConnectionCategory_STATUS_Db2,
	"drill":                    ConnectionCategory_STATUS_Drill,
	"dynamics":                 ConnectionCategory_STATUS_Dynamics,
	"dynamicsax":               ConnectionCategory_STATUS_DynamicsAx,
	"dynamicscrm":              ConnectionCategory_STATUS_DynamicsCrm,
	"eloqua":                   ConnectionCategory_STATUS_Eloqua,
	"fileserver":               ConnectionCategory_STATUS_FileServer,
	"ftpserver":                ConnectionCategory_STATUS_FtpServer,
	"genericcontainerregistry": ConnectionCategory_STATUS_GenericContainerRegistry,
	"generichttp":              ConnectionCategory_STATUS_GenericHttp,
	"genericrest":              ConnectionCategory_STATUS_GenericRest,
	"git":                      ConnectionCategory_STATUS_Git,
	"googleadwords":            ConnectionCategory_STATUS_GoogleAdWords,
	"googlebigquery":           ConnectionCategory_STATUS_GoogleBigQuery,
	"googlecloudstorage":       ConnectionCategory_STATUS_GoogleCloudStorage,
	"greenplum":                ConnectionCategory_STATUS_Greenplum,
	"hbase":                    ConnectionCategory_STATUS_Hbase,
	"hdfs":                     ConnectionCategory_STATUS_Hdfs,
	"hive":                     ConnectionCategory_STATUS_Hive,
	"hubspot":                  ConnectionCategory_STATUS_Hubspot,
	"impala":                   ConnectionCategory_STATUS_Impala,
	"informix":                 ConnectionCategory_STATUS_Informix,
	"jira":                     ConnectionCategory_STATUS_Jira,
	"magento":                  ConnectionCategory_STATUS_Magento,
	"mariadb":                  ConnectionCategory_STATUS_MariaDb,
	"marketo":                  ConnectionCategory_STATUS_Marketo,
	"microsoftaccess":          ConnectionCategory_STATUS_MicrosoftAccess,
	"mongodbatlas":             ConnectionCategory_STATUS_MongoDbAtlas,
	"mongodbv2":                ConnectionCategory_STATUS_MongoDbV2,
	"mysql":                    ConnectionCategory_STATUS_MySql,
	"netezza":                  ConnectionCategory_STATUS_Netezza,
	"odatarest":                ConnectionCategory_STATUS_ODataRest,
	"odbc":                     ConnectionCategory_STATUS_Odbc,
	"office365":                ConnectionCategory_STATUS_Office365,
	"openai":                   ConnectionCategory_STATUS_OpenAI,
	"oracle":                   ConnectionCategory_STATUS_Oracle,
	"oraclecloudstorage":       ConnectionCategory_STATUS_OracleCloudStorage,
	"oracleservicecloud":       ConnectionCategory_STATUS_OracleServiceCloud,
	"paypal":                   ConnectionCategory_STATUS_PayPal,
	"phoenix":                  ConnectionCategory_STATUS_Phoenix,
	"postgresql":               ConnectionCategory_STATUS_PostgreSql,
	"presto":                   ConnectionCategory_STATUS_Presto,
	"pythonfeed":               ConnectionCategory_STATUS_PythonFeed,
	"quickbooks":               ConnectionCategory_STATUS_QuickBooks,
	"redis":                    ConnectionCategory_STATUS_Redis,
	"responsys":                ConnectionCategory_STATUS_Responsys,
	"s3":                       ConnectionCategory_STATUS_S3,
	"salesforce":               ConnectionCategory_STATUS_Salesforce,
	"salesforcemarketingcloud": ConnectionCategory_STATUS_SalesforceMarketingCloud,
	"salesforceservicecloud":   ConnectionCategory_STATUS_SalesforceServiceCloud,
	"sapbw":                    ConnectionCategory_STATUS_SapBw,
	"sapcloudforcustomer":      ConnectionCategory_STATUS_SapCloudForCustomer,
	"sapecc":                   ConnectionCategory_STATUS_SapEcc,
	"saphana":                  ConnectionCategory_STATUS_SapHana,
	"sapopenhub":               ConnectionCategory_STATUS_SapOpenHub,
	"saptable":                 ConnectionCategory_STATUS_SapTable,
	"serp":                     ConnectionCategory_STATUS_Serp,
	"serverless":               ConnectionCategory_STATUS_Serverless,
	"servicenow":               ConnectionCategory_STATUS_ServiceNow,
	"sftp":                     ConnectionCategory_STATUS_Sftp,
	"sharepointonlinelist":     ConnectionCategory_STATUS_SharePointOnlineList,
	"shopify":                  ConnectionCategory_STATUS_Shopify,
	"snowflake":                ConnectionCategory_STATUS_Snowflake,
	"spark":                    ConnectionCategory_STATUS_Spark,
	"sqlserver":                ConnectionCategory_STATUS_SqlServer,
	"square":                   ConnectionCategory_STATUS_Square,
	"sybase":                   ConnectionCategory_STATUS_Sybase,
	"teradata":                 ConnectionCategory_STATUS_Teradata,
	"vertica":                  ConnectionCategory_STATUS_Vertica,
	"webtable":                 ConnectionCategory_STATUS_WebTable,
	"xero":                     ConnectionCategory_STATUS_Xero,
	"zoho":                     ConnectionCategory_STATUS_Zoho,
}

// Group based on connection category
type ConnectionGroup_STATUS string

const (
	ConnectionGroup_STATUS_Azure           = ConnectionGroup_STATUS("Azure")
	ConnectionGroup_STATUS_AzureAI         = ConnectionGroup_STATUS("AzureAI")
	ConnectionGroup_STATUS_Database        = ConnectionGroup_STATUS("Database")
	ConnectionGroup_STATUS_File            = ConnectionGroup_STATUS("File")
	ConnectionGroup_STATUS_GenericProtocol = ConnectionGroup_STATUS("GenericProtocol")
	ConnectionGroup_STATUS_NoSQL           = ConnectionGroup_STATUS("NoSQL")
	ConnectionGroup_STATUS_ServicesAndApps = ConnectionGroup_STATUS("ServicesAndApps")
)

// Mapping from string to ConnectionGroup_STATUS
var connectionGroup_STATUS_Values = map[string]ConnectionGroup_STATUS{
	"azure":           ConnectionGroup_STATUS_Azure,
	"azureai":         ConnectionGroup_STATUS_AzureAI,
	"database":        ConnectionGroup_STATUS_Database,
	"file":            ConnectionGroup_STATUS_File,
	"genericprotocol": ConnectionGroup_STATUS_GenericProtocol,
	"nosql":           ConnectionGroup_STATUS_NoSQL,
	"servicesandapps": ConnectionGroup_STATUS_ServicesAndApps,
}

// Custom Keys credential object
type CustomKeys struct {
	Keys *genruntime.SecretMapReference `json:"keys,omitempty"`
}

var _ genruntime.ARMTransformer = &CustomKeys{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (keys *CustomKeys) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if keys == nil {
		return nil, nil
	}
	result := &arm.CustomKeys{}

	// Set property "Keys":
	if keys.Keys != nil {
		var temp map[string]string
		tempSecret, err := resolved.ResolvedSecretMaps.Lookup(*keys.Keys)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property temp")
		}
		temp = tempSecret
		result.Keys = temp
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (keys *CustomKeys) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CustomKeys{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (keys *CustomKeys) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(arm.CustomKeys)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CustomKeys, got %T", armInput)
	}

	// no assignment for property "Keys"

	// No error
	return nil
}

// AssignProperties_From_CustomKeys populates our CustomKeys from the provided source CustomKeys
func (keys *CustomKeys) AssignProperties_From_CustomKeys(source *storage.CustomKeys) error {

	// Keys
	if source.Keys != nil {
		key := source.Keys.Copy()
		keys.Keys = &key
	} else {
		keys.Keys = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CustomKeys populates the provided destination CustomKeys from our CustomKeys
func (keys *CustomKeys) AssignProperties_To_CustomKeys(destination *storage.CustomKeys) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Keys
	if keys.Keys != nil {
		key := keys.Keys.Copy()
		destination.Keys = &key
	} else {
		destination.Keys = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_CustomKeys_STATUS populates our CustomKeys from the provided source CustomKeys_STATUS
func (keys *CustomKeys) Initialize_From_CustomKeys_STATUS(source *CustomKeys_STATUS) error {

	// No error
	return nil
}

// Custom Keys credential object
type CustomKeys_STATUS struct {
	Keys map[string]string `json:"keys,omitempty"`
}

var _ genruntime.FromARMConverter = &CustomKeys_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (keys *CustomKeys_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CustomKeys_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (keys *CustomKeys_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CustomKeys_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CustomKeys_STATUS, got %T", armInput)
	}

	// Set property "Keys":
	if typedInput.Keys != nil {
		keys.Keys = make(map[string]string, len(typedInput.Keys))
		for key, value := range typedInput.Keys {
			keys.Keys[key] = value
		}
	}

	// No error
	return nil
}

// AssignProperties_From_CustomKeys_STATUS populates our CustomKeys_STATUS from the provided source CustomKeys_STATUS
func (keys *CustomKeys_STATUS) AssignProperties_From_CustomKeys_STATUS(source *storage.CustomKeys_STATUS) error {

	// Keys
	keys.Keys = genruntime.CloneMapOfStringToString(source.Keys)

	// No error
	return nil
}

// AssignProperties_To_CustomKeys_STATUS populates the provided destination CustomKeys_STATUS from our CustomKeys_STATUS
func (keys *CustomKeys_STATUS) AssignProperties_To_CustomKeys_STATUS(destination *storage.CustomKeys_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Keys
	destination.Keys = genruntime.CloneMapOfStringToString(keys.Keys)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"CustomKeys"}
type CustomKeysWorkspaceConnectionProperties_AuthType string

const CustomKeysWorkspaceConnectionProperties_AuthType_CustomKeys = CustomKeysWorkspaceConnectionProperties_AuthType("CustomKeys")

// Mapping from string to CustomKeysWorkspaceConnectionProperties_AuthType
var customKeysWorkspaceConnectionProperties_AuthType_Values = map[string]CustomKeysWorkspaceConnectionProperties_AuthType{
	"customkeys": CustomKeysWorkspaceConnectionProperties_AuthType_CustomKeys,
}

type CustomKeysWorkspaceConnectionProperties_AuthType_STATUS string

const CustomKeysWorkspaceConnectionProperties_AuthType_STATUS_CustomKeys = CustomKeysWorkspaceConnectionProperties_AuthType_STATUS("CustomKeys")

// Mapping from string to CustomKeysWorkspaceConnectionProperties_AuthType_STATUS
var customKeysWorkspaceConnectionProperties_AuthType_STATUS_Values = map[string]CustomKeysWorkspaceConnectionProperties_AuthType_STATUS{
	"customkeys": CustomKeysWorkspaceConnectionProperties_AuthType_STATUS_CustomKeys,
}

// +kubebuilder:validation:Enum={"JSON"}
type CustomKeysWorkspaceConnectionProperties_ValueFormat string

const CustomKeysWorkspaceConnectionProperties_ValueFormat_JSON = CustomKeysWorkspaceConnectionProperties_ValueFormat("JSON")

// Mapping from string to CustomKeysWorkspaceConnectionProperties_ValueFormat
var customKeysWorkspaceConnectionProperties_ValueFormat_Values = map[string]CustomKeysWorkspaceConnectionProperties_ValueFormat{
	"json": CustomKeysWorkspaceConnectionProperties_ValueFormat_JSON,
}

type CustomKeysWorkspaceConnectionProperties_ValueFormat_STATUS string

const CustomKeysWorkspaceConnectionProperties_ValueFormat_STATUS_JSON = CustomKeysWorkspaceConnectionProperties_ValueFormat_STATUS("JSON")

// Mapping from string to CustomKeysWorkspaceConnectionProperties_ValueFormat_STATUS
var customKeysWorkspaceConnectionProperties_ValueFormat_STATUS_Values = map[string]CustomKeysWorkspaceConnectionProperties_ValueFormat_STATUS{
	"json": CustomKeysWorkspaceConnectionProperties_ValueFormat_STATUS_JSON,
}

// +kubebuilder:validation:Enum={"ManagedIdentity"}
type ManagedIdentityAuthTypeWorkspaceConnectionProperties_AuthType string

const ManagedIdentityAuthTypeWorkspaceConnectionProperties_AuthType_ManagedIdentity = ManagedIdentityAuthTypeWorkspaceConnectionProperties_AuthType("ManagedIdentity")

// Mapping from string to ManagedIdentityAuthTypeWorkspaceConnectionProperties_AuthType
var managedIdentityAuthTypeWorkspaceConnectionProperties_AuthType_Values = map[string]ManagedIdentityAuthTypeWorkspaceConnectionProperties_AuthType{
	"managedidentity": ManagedIdentityAuthTypeWorkspaceConnectionProperties_AuthType_ManagedIdentity,
}

type ManagedIdentityAuthTypeWorkspaceConnectionProperties_AuthType_STATUS string

const ManagedIdentityAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_ManagedIdentity = ManagedIdentityAuthTypeWorkspaceConnectionProperties_AuthType_STATUS("ManagedIdentity")

// Mapping from string to ManagedIdentityAuthTypeWorkspaceConnectionProperties_AuthType_STATUS
var managedIdentityAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_Values = map[string]ManagedIdentityAuthTypeWorkspaceConnectionProperties_AuthType_STATUS{
	"managedidentity": ManagedIdentityAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_ManagedIdentity,
}

// +kubebuilder:validation:Enum={"JSON"}
type ManagedIdentityAuthTypeWorkspaceConnectionProperties_ValueFormat string

const ManagedIdentityAuthTypeWorkspaceConnectionProperties_ValueFormat_JSON = ManagedIdentityAuthTypeWorkspaceConnectionProperties_ValueFormat("JSON")

// Mapping from string to ManagedIdentityAuthTypeWorkspaceConnectionProperties_ValueFormat
var managedIdentityAuthTypeWorkspaceConnectionProperties_ValueFormat_Values = map[string]ManagedIdentityAuthTypeWorkspaceConnectionProperties_ValueFormat{
	"json": ManagedIdentityAuthTypeWorkspaceConnectionProperties_ValueFormat_JSON,
}

type ManagedIdentityAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS string

const ManagedIdentityAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_JSON = ManagedIdentityAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS("JSON")

// Mapping from string to ManagedIdentityAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS
var managedIdentityAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_Values = map[string]ManagedIdentityAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS{
	"json": ManagedIdentityAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_JSON,
}

// +kubebuilder:validation:Enum={"None"}
type NoneAuthTypeWorkspaceConnectionProperties_AuthType string

const NoneAuthTypeWorkspaceConnectionProperties_AuthType_None = NoneAuthTypeWorkspaceConnectionProperties_AuthType("None")

// Mapping from string to NoneAuthTypeWorkspaceConnectionProperties_AuthType
var noneAuthTypeWorkspaceConnectionProperties_AuthType_Values = map[string]NoneAuthTypeWorkspaceConnectionProperties_AuthType{
	"none": NoneAuthTypeWorkspaceConnectionProperties_AuthType_None,
}

type NoneAuthTypeWorkspaceConnectionProperties_AuthType_STATUS string

const NoneAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_None = NoneAuthTypeWorkspaceConnectionProperties_AuthType_STATUS("None")

// Mapping from string to NoneAuthTypeWorkspaceConnectionProperties_AuthType_STATUS
var noneAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_Values = map[string]NoneAuthTypeWorkspaceConnectionProperties_AuthType_STATUS{
	"none": NoneAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_None,
}

// +kubebuilder:validation:Enum={"JSON"}
type NoneAuthTypeWorkspaceConnectionProperties_ValueFormat string

const NoneAuthTypeWorkspaceConnectionProperties_ValueFormat_JSON = NoneAuthTypeWorkspaceConnectionProperties_ValueFormat("JSON")

// Mapping from string to NoneAuthTypeWorkspaceConnectionProperties_ValueFormat
var noneAuthTypeWorkspaceConnectionProperties_ValueFormat_Values = map[string]NoneAuthTypeWorkspaceConnectionProperties_ValueFormat{
	"json": NoneAuthTypeWorkspaceConnectionProperties_ValueFormat_JSON,
}

type NoneAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS string

const NoneAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_JSON = NoneAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS("JSON")

// Mapping from string to NoneAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS
var noneAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_Values = map[string]NoneAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS{
	"json": NoneAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_JSON,
}

// +kubebuilder:validation:Enum={"OAuth2"}
type OAuth2AuthTypeWorkspaceConnectionProperties_AuthType string

const OAuth2AuthTypeWorkspaceConnectionProperties_AuthType_OAuth2 = OAuth2AuthTypeWorkspaceConnectionProperties_AuthType("OAuth2")

// Mapping from string to OAuth2AuthTypeWorkspaceConnectionProperties_AuthType
var oAuth2AuthTypeWorkspaceConnectionProperties_AuthType_Values = map[string]OAuth2AuthTypeWorkspaceConnectionProperties_AuthType{
	"oauth2": OAuth2AuthTypeWorkspaceConnectionProperties_AuthType_OAuth2,
}

type OAuth2AuthTypeWorkspaceConnectionProperties_AuthType_STATUS string

const OAuth2AuthTypeWorkspaceConnectionProperties_AuthType_STATUS_OAuth2 = OAuth2AuthTypeWorkspaceConnectionProperties_AuthType_STATUS("OAuth2")

// Mapping from string to OAuth2AuthTypeWorkspaceConnectionProperties_AuthType_STATUS
var oAuth2AuthTypeWorkspaceConnectionProperties_AuthType_STATUS_Values = map[string]OAuth2AuthTypeWorkspaceConnectionProperties_AuthType_STATUS{
	"oauth2": OAuth2AuthTypeWorkspaceConnectionProperties_AuthType_STATUS_OAuth2,
}

// +kubebuilder:validation:Enum={"JSON"}
type OAuth2AuthTypeWorkspaceConnectionProperties_ValueFormat string

const OAuth2AuthTypeWorkspaceConnectionProperties_ValueFormat_JSON = OAuth2AuthTypeWorkspaceConnectionProperties_ValueFormat("JSON")

// Mapping from string to OAuth2AuthTypeWorkspaceConnectionProperties_ValueFormat
var oAuth2AuthTypeWorkspaceConnectionProperties_ValueFormat_Values = map[string]OAuth2AuthTypeWorkspaceConnectionProperties_ValueFormat{
	"json": OAuth2AuthTypeWorkspaceConnectionProperties_ValueFormat_JSON,
}

type OAuth2AuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS string

const OAuth2AuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_JSON = OAuth2AuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS("JSON")

// Mapping from string to OAuth2AuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS
var oAuth2AuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_Values = map[string]OAuth2AuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS{
	"json": OAuth2AuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_JSON,
}

// +kubebuilder:validation:Enum={"PAT"}
type PATAuthTypeWorkspaceConnectionProperties_AuthType string

const PATAuthTypeWorkspaceConnectionProperties_AuthType_PAT = PATAuthTypeWorkspaceConnectionProperties_AuthType("PAT")

// Mapping from string to PATAuthTypeWorkspaceConnectionProperties_AuthType
var pATAuthTypeWorkspaceConnectionProperties_AuthType_Values = map[string]PATAuthTypeWorkspaceConnectionProperties_AuthType{
	"pat": PATAuthTypeWorkspaceConnectionProperties_AuthType_PAT,
}

type PATAuthTypeWorkspaceConnectionProperties_AuthType_STATUS string

const PATAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_PAT = PATAuthTypeWorkspaceConnectionProperties_AuthType_STATUS("PAT")

// Mapping from string to PATAuthTypeWorkspaceConnectionProperties_AuthType_STATUS
var pATAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_Values = map[string]PATAuthTypeWorkspaceConnectionProperties_AuthType_STATUS{
	"pat": PATAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_PAT,
}

// +kubebuilder:validation:Enum={"JSON"}
type PATAuthTypeWorkspaceConnectionProperties_ValueFormat string

const PATAuthTypeWorkspaceConnectionProperties_ValueFormat_JSON = PATAuthTypeWorkspaceConnectionProperties_ValueFormat("JSON")

// Mapping from string to PATAuthTypeWorkspaceConnectionProperties_ValueFormat
var pATAuthTypeWorkspaceConnectionProperties_ValueFormat_Values = map[string]PATAuthTypeWorkspaceConnectionProperties_ValueFormat{
	"json": PATAuthTypeWorkspaceConnectionProperties_ValueFormat_JSON,
}

type PATAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS string

const PATAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_JSON = PATAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS("JSON")

// Mapping from string to PATAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS
var pATAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_Values = map[string]PATAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS{
	"json": PATAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_JSON,
}

// +kubebuilder:validation:Enum={"SAS"}
type SASAuthTypeWorkspaceConnectionProperties_AuthType string

const SASAuthTypeWorkspaceConnectionProperties_AuthType_SAS = SASAuthTypeWorkspaceConnectionProperties_AuthType("SAS")

// Mapping from string to SASAuthTypeWorkspaceConnectionProperties_AuthType
var sASAuthTypeWorkspaceConnectionProperties_AuthType_Values = map[string]SASAuthTypeWorkspaceConnectionProperties_AuthType{
	"sas": SASAuthTypeWorkspaceConnectionProperties_AuthType_SAS,
}

type SASAuthTypeWorkspaceConnectionProperties_AuthType_STATUS string

const SASAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_SAS = SASAuthTypeWorkspaceConnectionProperties_AuthType_STATUS("SAS")

// Mapping from string to SASAuthTypeWorkspaceConnectionProperties_AuthType_STATUS
var sASAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_Values = map[string]SASAuthTypeWorkspaceConnectionProperties_AuthType_STATUS{
	"sas": SASAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_SAS,
}

// +kubebuilder:validation:Enum={"JSON"}
type SASAuthTypeWorkspaceConnectionProperties_ValueFormat string

const SASAuthTypeWorkspaceConnectionProperties_ValueFormat_JSON = SASAuthTypeWorkspaceConnectionProperties_ValueFormat("JSON")

// Mapping from string to SASAuthTypeWorkspaceConnectionProperties_ValueFormat
var sASAuthTypeWorkspaceConnectionProperties_ValueFormat_Values = map[string]SASAuthTypeWorkspaceConnectionProperties_ValueFormat{
	"json": SASAuthTypeWorkspaceConnectionProperties_ValueFormat_JSON,
}

type SASAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS string

const SASAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_JSON = SASAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS("JSON")

// Mapping from string to SASAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS
var sASAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_Values = map[string]SASAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS{
	"json": SASAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_JSON,
}

// +kubebuilder:validation:Enum={"ServicePrincipal"}
type ServicePrincipalAuthTypeWorkspaceConnectionProperties_AuthType string

const ServicePrincipalAuthTypeWorkspaceConnectionProperties_AuthType_ServicePrincipal = ServicePrincipalAuthTypeWorkspaceConnectionProperties_AuthType("ServicePrincipal")

// Mapping from string to ServicePrincipalAuthTypeWorkspaceConnectionProperties_AuthType
var servicePrincipalAuthTypeWorkspaceConnectionProperties_AuthType_Values = map[string]ServicePrincipalAuthTypeWorkspaceConnectionProperties_AuthType{
	"serviceprincipal": ServicePrincipalAuthTypeWorkspaceConnectionProperties_AuthType_ServicePrincipal,
}

type ServicePrincipalAuthTypeWorkspaceConnectionProperties_AuthType_STATUS string

const ServicePrincipalAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_ServicePrincipal = ServicePrincipalAuthTypeWorkspaceConnectionProperties_AuthType_STATUS("ServicePrincipal")

// Mapping from string to ServicePrincipalAuthTypeWorkspaceConnectionProperties_AuthType_STATUS
var servicePrincipalAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_Values = map[string]ServicePrincipalAuthTypeWorkspaceConnectionProperties_AuthType_STATUS{
	"serviceprincipal": ServicePrincipalAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_ServicePrincipal,
}

// +kubebuilder:validation:Enum={"JSON"}
type ServicePrincipalAuthTypeWorkspaceConnectionProperties_ValueFormat string

const ServicePrincipalAuthTypeWorkspaceConnectionProperties_ValueFormat_JSON = ServicePrincipalAuthTypeWorkspaceConnectionProperties_ValueFormat("JSON")

// Mapping from string to ServicePrincipalAuthTypeWorkspaceConnectionProperties_ValueFormat
var servicePrincipalAuthTypeWorkspaceConnectionProperties_ValueFormat_Values = map[string]ServicePrincipalAuthTypeWorkspaceConnectionProperties_ValueFormat{
	"json": ServicePrincipalAuthTypeWorkspaceConnectionProperties_ValueFormat_JSON,
}

type ServicePrincipalAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS string

const ServicePrincipalAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_JSON = ServicePrincipalAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS("JSON")

// Mapping from string to ServicePrincipalAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS
var servicePrincipalAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_Values = map[string]ServicePrincipalAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS{
	"json": ServicePrincipalAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_JSON,
}

// +kubebuilder:validation:Enum={"UsernamePassword"}
type UsernamePasswordAuthTypeWorkspaceConnectionProperties_AuthType string

const UsernamePasswordAuthTypeWorkspaceConnectionProperties_AuthType_UsernamePassword = UsernamePasswordAuthTypeWorkspaceConnectionProperties_AuthType("UsernamePassword")

// Mapping from string to UsernamePasswordAuthTypeWorkspaceConnectionProperties_AuthType
var usernamePasswordAuthTypeWorkspaceConnectionProperties_AuthType_Values = map[string]UsernamePasswordAuthTypeWorkspaceConnectionProperties_AuthType{
	"usernamepassword": UsernamePasswordAuthTypeWorkspaceConnectionProperties_AuthType_UsernamePassword,
}

type UsernamePasswordAuthTypeWorkspaceConnectionProperties_AuthType_STATUS string

const UsernamePasswordAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_UsernamePassword = UsernamePasswordAuthTypeWorkspaceConnectionProperties_AuthType_STATUS("UsernamePassword")

// Mapping from string to UsernamePasswordAuthTypeWorkspaceConnectionProperties_AuthType_STATUS
var usernamePasswordAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_Values = map[string]UsernamePasswordAuthTypeWorkspaceConnectionProperties_AuthType_STATUS{
	"usernamepassword": UsernamePasswordAuthTypeWorkspaceConnectionProperties_AuthType_STATUS_UsernamePassword,
}

// +kubebuilder:validation:Enum={"JSON"}
type UsernamePasswordAuthTypeWorkspaceConnectionProperties_ValueFormat string

const UsernamePasswordAuthTypeWorkspaceConnectionProperties_ValueFormat_JSON = UsernamePasswordAuthTypeWorkspaceConnectionProperties_ValueFormat("JSON")

// Mapping from string to UsernamePasswordAuthTypeWorkspaceConnectionProperties_ValueFormat
var usernamePasswordAuthTypeWorkspaceConnectionProperties_ValueFormat_Values = map[string]UsernamePasswordAuthTypeWorkspaceConnectionProperties_ValueFormat{
	"json": UsernamePasswordAuthTypeWorkspaceConnectionProperties_ValueFormat_JSON,
}

type UsernamePasswordAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS string

const UsernamePasswordAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_JSON = UsernamePasswordAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS("JSON")

// Mapping from string to UsernamePasswordAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS
var usernamePasswordAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_Values = map[string]UsernamePasswordAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS{
	"json": UsernamePasswordAuthTypeWorkspaceConnectionProperties_ValueFormat_STATUS_JSON,
}

type WorkspaceConnectionAccessKey struct {
	AccessKeyId     *string                     `json:"accessKeyId,omitempty"`
	SecretAccessKey *genruntime.SecretReference `json:"secretAccessKey,omitempty"`
}

var _ genruntime.ARMTransformer = &WorkspaceConnectionAccessKey{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (accessKey *WorkspaceConnectionAccessKey) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if accessKey == nil {
		return nil, nil
	}
	result := &arm.WorkspaceConnectionAccessKey{}

	// Set property "AccessKeyId":
	if accessKey.AccessKeyId != nil {
		accessKeyId := *accessKey.AccessKeyId
		result.AccessKeyId = &accessKeyId
	}

	// Set property "SecretAccessKey":
	if accessKey.SecretAccessKey != nil {
		secretAccessKeySecret, err := resolved.ResolvedSecrets.Lookup(*accessKey.SecretAccessKey)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property SecretAccessKey")
		}
		secretAccessKey := secretAccessKeySecret
		result.SecretAccessKey = &secretAccessKey
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (accessKey *WorkspaceConnectionAccessKey) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceConnectionAccessKey{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (accessKey *WorkspaceConnectionAccessKey) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspaceConnectionAccessKey)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceConnectionAccessKey, got %T", armInput)
	}

	// Set property "AccessKeyId":
	if typedInput.AccessKeyId != nil {
		accessKeyId := *typedInput.AccessKeyId
		accessKey.AccessKeyId = &accessKeyId
	}

	// no assignment for property "SecretAccessKey"

	// No error
	return nil
}

// AssignProperties_From_WorkspaceConnectionAccessKey populates our WorkspaceConnectionAccessKey from the provided source WorkspaceConnectionAccessKey
func (accessKey *WorkspaceConnectionAccessKey) AssignProperties_From_WorkspaceConnectionAccessKey(source *storage.WorkspaceConnectionAccessKey) error {

	// AccessKeyId
	accessKey.AccessKeyId = genruntime.ClonePointerToString(source.AccessKeyId)

	// SecretAccessKey
	if source.SecretAccessKey != nil {
		secretAccessKey := source.SecretAccessKey.Copy()
		accessKey.SecretAccessKey = &secretAccessKey
	} else {
		accessKey.SecretAccessKey = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WorkspaceConnectionAccessKey populates the provided destination WorkspaceConnectionAccessKey from our WorkspaceConnectionAccessKey
func (accessKey *WorkspaceConnectionAccessKey) AssignProperties_To_WorkspaceConnectionAccessKey(destination *storage.WorkspaceConnectionAccessKey) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AccessKeyId
	destination.AccessKeyId = genruntime.ClonePointerToString(accessKey.AccessKeyId)

	// SecretAccessKey
	if accessKey.SecretAccessKey != nil {
		secretAccessKey := accessKey.SecretAccessKey.Copy()
		destination.SecretAccessKey = &secretAccessKey
	} else {
		destination.SecretAccessKey = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_WorkspaceConnectionAccessKey_STATUS populates our WorkspaceConnectionAccessKey from the provided source WorkspaceConnectionAccessKey_STATUS
func (accessKey *WorkspaceConnectionAccessKey) Initialize_From_WorkspaceConnectionAccessKey_STATUS(source *WorkspaceConnectionAccessKey_STATUS) error {

	// AccessKeyId
	accessKey.AccessKeyId = genruntime.ClonePointerToString(source.AccessKeyId)

	// No error
	return nil
}

type WorkspaceConnectionAccessKey_STATUS struct {
	AccessKeyId *string `json:"accessKeyId,omitempty"`
}

var _ genruntime.FromARMConverter = &WorkspaceConnectionAccessKey_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (accessKey *WorkspaceConnectionAccessKey_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceConnectionAccessKey_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (accessKey *WorkspaceConnectionAccessKey_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspaceConnectionAccessKey_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceConnectionAccessKey_STATUS, got %T", armInput)
	}

	// Set property "AccessKeyId":
	if typedInput.AccessKeyId != nil {
		accessKeyId := *typedInput.AccessKeyId
		accessKey.AccessKeyId = &accessKeyId
	}

	// No error
	return nil
}

// AssignProperties_From_WorkspaceConnectionAccessKey_STATUS populates our WorkspaceConnectionAccessKey_STATUS from the provided source WorkspaceConnectionAccessKey_STATUS
func (accessKey *WorkspaceConnectionAccessKey_STATUS) AssignProperties_From_WorkspaceConnectionAccessKey_STATUS(source *storage.WorkspaceConnectionAccessKey_STATUS) error {

	// AccessKeyId
	accessKey.AccessKeyId = genruntime.ClonePointerToString(source.AccessKeyId)

	// No error
	return nil
}

// AssignProperties_To_WorkspaceConnectionAccessKey_STATUS populates the provided destination WorkspaceConnectionAccessKey_STATUS from our WorkspaceConnectionAccessKey_STATUS
func (accessKey *WorkspaceConnectionAccessKey_STATUS) AssignProperties_To_WorkspaceConnectionAccessKey_STATUS(destination *storage.WorkspaceConnectionAccessKey_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AccessKeyId
	destination.AccessKeyId = genruntime.ClonePointerToString(accessKey.AccessKeyId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type WorkspaceConnectionAccountKey struct {
	Key *genruntime.SecretReference `json:"key,omitempty"`
}

var _ genruntime.ARMTransformer = &WorkspaceConnectionAccountKey{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (accountKey *WorkspaceConnectionAccountKey) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if accountKey == nil {
		return nil, nil
	}
	result := &arm.WorkspaceConnectionAccountKey{}

	// Set property "Key":
	if accountKey.Key != nil {
		keySecret, err := resolved.ResolvedSecrets.Lookup(*accountKey.Key)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property Key")
		}
		key := keySecret
		result.Key = &key
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (accountKey *WorkspaceConnectionAccountKey) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceConnectionAccountKey{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (accountKey *WorkspaceConnectionAccountKey) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(arm.WorkspaceConnectionAccountKey)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceConnectionAccountKey, got %T", armInput)
	}

	// no assignment for property "Key"

	// No error
	return nil
}

// AssignProperties_From_WorkspaceConnectionAccountKey populates our WorkspaceConnectionAccountKey from the provided source WorkspaceConnectionAccountKey
func (accountKey *WorkspaceConnectionAccountKey) AssignProperties_From_WorkspaceConnectionAccountKey(source *storage.WorkspaceConnectionAccountKey) error {

	// Key
	if source.Key != nil {
		key := source.Key.Copy()
		accountKey.Key = &key
	} else {
		accountKey.Key = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WorkspaceConnectionAccountKey populates the provided destination WorkspaceConnectionAccountKey from our WorkspaceConnectionAccountKey
func (accountKey *WorkspaceConnectionAccountKey) AssignProperties_To_WorkspaceConnectionAccountKey(destination *storage.WorkspaceConnectionAccountKey) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Key
	if accountKey.Key != nil {
		key := accountKey.Key.Copy()
		destination.Key = &key
	} else {
		destination.Key = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_WorkspaceConnectionAccountKey_STATUS populates our WorkspaceConnectionAccountKey from the provided source WorkspaceConnectionAccountKey_STATUS
func (accountKey *WorkspaceConnectionAccountKey) Initialize_From_WorkspaceConnectionAccountKey_STATUS(source *WorkspaceConnectionAccountKey_STATUS) error {

	// No error
	return nil
}

type WorkspaceConnectionAccountKey_STATUS struct {
}

var _ genruntime.FromARMConverter = &WorkspaceConnectionAccountKey_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (accountKey *WorkspaceConnectionAccountKey_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceConnectionAccountKey_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (accountKey *WorkspaceConnectionAccountKey_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(arm.WorkspaceConnectionAccountKey_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceConnectionAccountKey_STATUS, got %T", armInput)
	}

	// No error
	return nil
}

// AssignProperties_From_WorkspaceConnectionAccountKey_STATUS populates our WorkspaceConnectionAccountKey_STATUS from the provided source WorkspaceConnectionAccountKey_STATUS
func (accountKey *WorkspaceConnectionAccountKey_STATUS) AssignProperties_From_WorkspaceConnectionAccountKey_STATUS(source *storage.WorkspaceConnectionAccountKey_STATUS) error {

	// No error
	return nil
}

// AssignProperties_To_WorkspaceConnectionAccountKey_STATUS populates the provided destination WorkspaceConnectionAccountKey_STATUS from our WorkspaceConnectionAccountKey_STATUS
func (accountKey *WorkspaceConnectionAccountKey_STATUS) AssignProperties_To_WorkspaceConnectionAccountKey_STATUS(destination *storage.WorkspaceConnectionAccountKey_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Api key object for workspace connection credential.
type WorkspaceConnectionApiKey struct {
	Key *genruntime.SecretReference `json:"key,omitempty"`
}

var _ genruntime.ARMTransformer = &WorkspaceConnectionApiKey{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (apiKey *WorkspaceConnectionApiKey) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if apiKey == nil {
		return nil, nil
	}
	result := &arm.WorkspaceConnectionApiKey{}

	// Set property "Key":
	if apiKey.Key != nil {
		keySecret, err := resolved.ResolvedSecrets.Lookup(*apiKey.Key)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property Key")
		}
		key := keySecret
		result.Key = &key
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (apiKey *WorkspaceConnectionApiKey) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceConnectionApiKey{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (apiKey *WorkspaceConnectionApiKey) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(arm.WorkspaceConnectionApiKey)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceConnectionApiKey, got %T", armInput)
	}

	// no assignment for property "Key"

	// No error
	return nil
}

// AssignProperties_From_WorkspaceConnectionApiKey populates our WorkspaceConnectionApiKey from the provided source WorkspaceConnectionApiKey
func (apiKey *WorkspaceConnectionApiKey) AssignProperties_From_WorkspaceConnectionApiKey(source *storage.WorkspaceConnectionApiKey) error {

	// Key
	if source.Key != nil {
		key := source.Key.Copy()
		apiKey.Key = &key
	} else {
		apiKey.Key = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WorkspaceConnectionApiKey populates the provided destination WorkspaceConnectionApiKey from our WorkspaceConnectionApiKey
func (apiKey *WorkspaceConnectionApiKey) AssignProperties_To_WorkspaceConnectionApiKey(destination *storage.WorkspaceConnectionApiKey) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Key
	if apiKey.Key != nil {
		key := apiKey.Key.Copy()
		destination.Key = &key
	} else {
		destination.Key = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_WorkspaceConnectionApiKey_STATUS populates our WorkspaceConnectionApiKey from the provided source WorkspaceConnectionApiKey_STATUS
func (apiKey *WorkspaceConnectionApiKey) Initialize_From_WorkspaceConnectionApiKey_STATUS(source *WorkspaceConnectionApiKey_STATUS) error {

	// No error
	return nil
}

// Api key object for workspace connection credential.
type WorkspaceConnectionApiKey_STATUS struct {
}

var _ genruntime.FromARMConverter = &WorkspaceConnectionApiKey_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (apiKey *WorkspaceConnectionApiKey_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceConnectionApiKey_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (apiKey *WorkspaceConnectionApiKey_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(arm.WorkspaceConnectionApiKey_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceConnectionApiKey_STATUS, got %T", armInput)
	}

	// No error
	return nil
}

// AssignProperties_From_WorkspaceConnectionApiKey_STATUS populates our WorkspaceConnectionApiKey_STATUS from the provided source WorkspaceConnectionApiKey_STATUS
func (apiKey *WorkspaceConnectionApiKey_STATUS) AssignProperties_From_WorkspaceConnectionApiKey_STATUS(source *storage.WorkspaceConnectionApiKey_STATUS) error {

	// No error
	return nil
}

// AssignProperties_To_WorkspaceConnectionApiKey_STATUS populates the provided destination WorkspaceConnectionApiKey_STATUS from our WorkspaceConnectionApiKey_STATUS
func (apiKey *WorkspaceConnectionApiKey_STATUS) AssignProperties_To_WorkspaceConnectionApiKey_STATUS(destination *storage.WorkspaceConnectionApiKey_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type WorkspaceConnectionManagedIdentity struct {
	ClientId           *string                        `json:"clientId,omitempty" optionalConfigMapPair:"ClientId"`
	ClientIdFromConfig *genruntime.ConfigMapReference `json:"clientIdFromConfig,omitempty" optionalConfigMapPair:"ClientId"`
	ResourceReference  *genruntime.ResourceReference  `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &WorkspaceConnectionManagedIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *WorkspaceConnectionManagedIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &arm.WorkspaceConnectionManagedIdentity{}

	// Set property "ClientId":
	if identity.ClientId != nil {
		clientId := *identity.ClientId
		result.ClientId = &clientId
	}
	if identity.ClientIdFromConfig != nil {
		clientIdValue, err := resolved.ResolvedConfigMaps.Lookup(*identity.ClientIdFromConfig)
		if err != nil {
			return nil, errors.Wrap(err, "looking up configmap for property ClientId")
		}
		clientId := clientIdValue
		result.ClientId = &clientId
	}

	// Set property "ResourceId":
	if identity.ResourceReference != nil {
		resourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*identity.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceReference := resourceReferenceARMID
		result.ResourceId = &resourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *WorkspaceConnectionManagedIdentity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceConnectionManagedIdentity{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *WorkspaceConnectionManagedIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspaceConnectionManagedIdentity)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceConnectionManagedIdentity, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		identity.ClientId = &clientId
	}

	// no assignment for property "ClientIdFromConfig"

	// no assignment for property "ResourceReference"

	// No error
	return nil
}

// AssignProperties_From_WorkspaceConnectionManagedIdentity populates our WorkspaceConnectionManagedIdentity from the provided source WorkspaceConnectionManagedIdentity
func (identity *WorkspaceConnectionManagedIdentity) AssignProperties_From_WorkspaceConnectionManagedIdentity(source *storage.WorkspaceConnectionManagedIdentity) error {

	// ClientId
	identity.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// ClientIdFromConfig
	if source.ClientIdFromConfig != nil {
		clientIdFromConfig := source.ClientIdFromConfig.Copy()
		identity.ClientIdFromConfig = &clientIdFromConfig
	} else {
		identity.ClientIdFromConfig = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		identity.ResourceReference = &resourceReference
	} else {
		identity.ResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WorkspaceConnectionManagedIdentity populates the provided destination WorkspaceConnectionManagedIdentity from our WorkspaceConnectionManagedIdentity
func (identity *WorkspaceConnectionManagedIdentity) AssignProperties_To_WorkspaceConnectionManagedIdentity(destination *storage.WorkspaceConnectionManagedIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identity.ClientId)

	// ClientIdFromConfig
	if identity.ClientIdFromConfig != nil {
		clientIdFromConfig := identity.ClientIdFromConfig.Copy()
		destination.ClientIdFromConfig = &clientIdFromConfig
	} else {
		destination.ClientIdFromConfig = nil
	}

	// ResourceReference
	if identity.ResourceReference != nil {
		resourceReference := identity.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_WorkspaceConnectionManagedIdentity_STATUS populates our WorkspaceConnectionManagedIdentity from the provided source WorkspaceConnectionManagedIdentity_STATUS
func (identity *WorkspaceConnectionManagedIdentity) Initialize_From_WorkspaceConnectionManagedIdentity_STATUS(source *WorkspaceConnectionManagedIdentity_STATUS) error {

	// ClientId
	identity.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// ResourceReference
	if source.ResourceId != nil {
		resourceReference := genruntime.CreateResourceReferenceFromARMID(*source.ResourceId)
		identity.ResourceReference = &resourceReference
	} else {
		identity.ResourceReference = nil
	}

	// No error
	return nil
}

type WorkspaceConnectionManagedIdentity_STATUS struct {
	ClientId   *string `json:"clientId,omitempty"`
	ResourceId *string `json:"resourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &WorkspaceConnectionManagedIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *WorkspaceConnectionManagedIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceConnectionManagedIdentity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *WorkspaceConnectionManagedIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspaceConnectionManagedIdentity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceConnectionManagedIdentity_STATUS, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		identity.ClientId = &clientId
	}

	// Set property "ResourceId":
	if typedInput.ResourceId != nil {
		resourceId := *typedInput.ResourceId
		identity.ResourceId = &resourceId
	}

	// No error
	return nil
}

// AssignProperties_From_WorkspaceConnectionManagedIdentity_STATUS populates our WorkspaceConnectionManagedIdentity_STATUS from the provided source WorkspaceConnectionManagedIdentity_STATUS
func (identity *WorkspaceConnectionManagedIdentity_STATUS) AssignProperties_From_WorkspaceConnectionManagedIdentity_STATUS(source *storage.WorkspaceConnectionManagedIdentity_STATUS) error {

	// ClientId
	identity.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// ResourceId
	identity.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// No error
	return nil
}

// AssignProperties_To_WorkspaceConnectionManagedIdentity_STATUS populates the provided destination WorkspaceConnectionManagedIdentity_STATUS from our WorkspaceConnectionManagedIdentity_STATUS
func (identity *WorkspaceConnectionManagedIdentity_STATUS) AssignProperties_To_WorkspaceConnectionManagedIdentity_STATUS(destination *storage.WorkspaceConnectionManagedIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identity.ClientId)

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(identity.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// ClientId and ClientSecret are required. Other properties are optional
// depending on each OAuth2 provider's
// implementation.
type WorkspaceConnectionOAuth2 struct {
	// AuthUrl: Required by Concur connection category
	AuthUrl *string `json:"authUrl,omitempty"`

	// +kubebuilder:validation:Pattern="^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$"
	// ClientId: Client id in the format of UUID
	ClientId *string `json:"clientId,omitempty" optionalConfigMapPair:"ClientId"`

	// ClientIdFromConfig: Client id in the format of UUID
	ClientIdFromConfig *genruntime.ConfigMapReference `json:"clientIdFromConfig,omitempty" optionalConfigMapPair:"ClientId"`
	ClientSecret       *genruntime.SecretReference    `json:"clientSecret,omitempty"`

	// DeveloperToken: Required by GoogleAdWords connection category
	DeveloperToken *genruntime.SecretReference `json:"developerToken,omitempty"`
	Password       *genruntime.SecretReference `json:"password,omitempty"`

	// RefreshToken: Required by GoogleBigQuery, GoogleAdWords, Hubspot, QuickBooks, Square, Xero, Zoho
	// where user needs to get RefreshToken offline
	RefreshToken *genruntime.SecretReference `json:"refreshToken,omitempty"`

	// TenantId: Required by QuickBooks and Xero connection categories
	TenantId *string `json:"tenantId,omitempty" optionalConfigMapPair:"TenantId"`

	// TenantIdFromConfig: Required by QuickBooks and Xero connection categories
	TenantIdFromConfig *genruntime.ConfigMapReference `json:"tenantIdFromConfig,omitempty" optionalConfigMapPair:"TenantId"`

	// Username: Concur, ServiceNow auth server AccessToken grant type is 'Password'
	// which requires UsernamePassword
	Username *string `json:"username,omitempty"`
}

var _ genruntime.ARMTransformer = &WorkspaceConnectionOAuth2{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (auth2 *WorkspaceConnectionOAuth2) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if auth2 == nil {
		return nil, nil
	}
	result := &arm.WorkspaceConnectionOAuth2{}

	// Set property "AuthUrl":
	if auth2.AuthUrl != nil {
		authUrl := *auth2.AuthUrl
		result.AuthUrl = &authUrl
	}

	// Set property "ClientId":
	if auth2.ClientId != nil {
		clientId := *auth2.ClientId
		result.ClientId = &clientId
	}
	if auth2.ClientIdFromConfig != nil {
		clientIdValue, err := resolved.ResolvedConfigMaps.Lookup(*auth2.ClientIdFromConfig)
		if err != nil {
			return nil, errors.Wrap(err, "looking up configmap for property ClientId")
		}
		clientId := clientIdValue
		result.ClientId = &clientId
	}

	// Set property "ClientSecret":
	if auth2.ClientSecret != nil {
		clientSecretSecret, err := resolved.ResolvedSecrets.Lookup(*auth2.ClientSecret)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property ClientSecret")
		}
		clientSecret := clientSecretSecret
		result.ClientSecret = &clientSecret
	}

	// Set property "DeveloperToken":
	if auth2.DeveloperToken != nil {
		developerTokenSecret, err := resolved.ResolvedSecrets.Lookup(*auth2.DeveloperToken)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property DeveloperToken")
		}
		developerToken := developerTokenSecret
		result.DeveloperToken = &developerToken
	}

	// Set property "Password":
	if auth2.Password != nil {
		passwordSecret, err := resolved.ResolvedSecrets.Lookup(*auth2.Password)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property Password")
		}
		password := passwordSecret
		result.Password = &password
	}

	// Set property "RefreshToken":
	if auth2.RefreshToken != nil {
		refreshTokenSecret, err := resolved.ResolvedSecrets.Lookup(*auth2.RefreshToken)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property RefreshToken")
		}
		refreshToken := refreshTokenSecret
		result.RefreshToken = &refreshToken
	}

	// Set property "TenantId":
	if auth2.TenantId != nil {
		tenantId := *auth2.TenantId
		result.TenantId = &tenantId
	}
	if auth2.TenantIdFromConfig != nil {
		tenantIdValue, err := resolved.ResolvedConfigMaps.Lookup(*auth2.TenantIdFromConfig)
		if err != nil {
			return nil, errors.Wrap(err, "looking up configmap for property TenantId")
		}
		tenantId := tenantIdValue
		result.TenantId = &tenantId
	}

	// Set property "Username":
	if auth2.Username != nil {
		username := *auth2.Username
		result.Username = &username
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (auth2 *WorkspaceConnectionOAuth2) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceConnectionOAuth2{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (auth2 *WorkspaceConnectionOAuth2) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspaceConnectionOAuth2)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceConnectionOAuth2, got %T", armInput)
	}

	// Set property "AuthUrl":
	if typedInput.AuthUrl != nil {
		authUrl := *typedInput.AuthUrl
		auth2.AuthUrl = &authUrl
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		auth2.ClientId = &clientId
	}

	// no assignment for property "ClientIdFromConfig"

	// no assignment for property "ClientSecret"

	// no assignment for property "DeveloperToken"

	// no assignment for property "Password"

	// no assignment for property "RefreshToken"

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		auth2.TenantId = &tenantId
	}

	// no assignment for property "TenantIdFromConfig"

	// Set property "Username":
	if typedInput.Username != nil {
		username := *typedInput.Username
		auth2.Username = &username
	}

	// No error
	return nil
}

// AssignProperties_From_WorkspaceConnectionOAuth2 populates our WorkspaceConnectionOAuth2 from the provided source WorkspaceConnectionOAuth2
func (auth2 *WorkspaceConnectionOAuth2) AssignProperties_From_WorkspaceConnectionOAuth2(source *storage.WorkspaceConnectionOAuth2) error {

	// AuthUrl
	auth2.AuthUrl = genruntime.ClonePointerToString(source.AuthUrl)

	// ClientId
	if source.ClientId != nil {
		clientId := *source.ClientId
		auth2.ClientId = &clientId
	} else {
		auth2.ClientId = nil
	}

	// ClientIdFromConfig
	if source.ClientIdFromConfig != nil {
		clientIdFromConfig := source.ClientIdFromConfig.Copy()
		auth2.ClientIdFromConfig = &clientIdFromConfig
	} else {
		auth2.ClientIdFromConfig = nil
	}

	// ClientSecret
	if source.ClientSecret != nil {
		clientSecret := source.ClientSecret.Copy()
		auth2.ClientSecret = &clientSecret
	} else {
		auth2.ClientSecret = nil
	}

	// DeveloperToken
	if source.DeveloperToken != nil {
		developerToken := source.DeveloperToken.Copy()
		auth2.DeveloperToken = &developerToken
	} else {
		auth2.DeveloperToken = nil
	}

	// Password
	if source.Password != nil {
		password := source.Password.Copy()
		auth2.Password = &password
	} else {
		auth2.Password = nil
	}

	// RefreshToken
	if source.RefreshToken != nil {
		refreshToken := source.RefreshToken.Copy()
		auth2.RefreshToken = &refreshToken
	} else {
		auth2.RefreshToken = nil
	}

	// TenantId
	auth2.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// TenantIdFromConfig
	if source.TenantIdFromConfig != nil {
		tenantIdFromConfig := source.TenantIdFromConfig.Copy()
		auth2.TenantIdFromConfig = &tenantIdFromConfig
	} else {
		auth2.TenantIdFromConfig = nil
	}

	// Username
	auth2.Username = genruntime.ClonePointerToString(source.Username)

	// No error
	return nil
}

// AssignProperties_To_WorkspaceConnectionOAuth2 populates the provided destination WorkspaceConnectionOAuth2 from our WorkspaceConnectionOAuth2
func (auth2 *WorkspaceConnectionOAuth2) AssignProperties_To_WorkspaceConnectionOAuth2(destination *storage.WorkspaceConnectionOAuth2) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthUrl
	destination.AuthUrl = genruntime.ClonePointerToString(auth2.AuthUrl)

	// ClientId
	if auth2.ClientId != nil {
		clientId := *auth2.ClientId
		destination.ClientId = &clientId
	} else {
		destination.ClientId = nil
	}

	// ClientIdFromConfig
	if auth2.ClientIdFromConfig != nil {
		clientIdFromConfig := auth2.ClientIdFromConfig.Copy()
		destination.ClientIdFromConfig = &clientIdFromConfig
	} else {
		destination.ClientIdFromConfig = nil
	}

	// ClientSecret
	if auth2.ClientSecret != nil {
		clientSecret := auth2.ClientSecret.Copy()
		destination.ClientSecret = &clientSecret
	} else {
		destination.ClientSecret = nil
	}

	// DeveloperToken
	if auth2.DeveloperToken != nil {
		developerToken := auth2.DeveloperToken.Copy()
		destination.DeveloperToken = &developerToken
	} else {
		destination.DeveloperToken = nil
	}

	// Password
	if auth2.Password != nil {
		password := auth2.Password.Copy()
		destination.Password = &password
	} else {
		destination.Password = nil
	}

	// RefreshToken
	if auth2.RefreshToken != nil {
		refreshToken := auth2.RefreshToken.Copy()
		destination.RefreshToken = &refreshToken
	} else {
		destination.RefreshToken = nil
	}

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(auth2.TenantId)

	// TenantIdFromConfig
	if auth2.TenantIdFromConfig != nil {
		tenantIdFromConfig := auth2.TenantIdFromConfig.Copy()
		destination.TenantIdFromConfig = &tenantIdFromConfig
	} else {
		destination.TenantIdFromConfig = nil
	}

	// Username
	destination.Username = genruntime.ClonePointerToString(auth2.Username)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_WorkspaceConnectionOAuth2_STATUS populates our WorkspaceConnectionOAuth2 from the provided source WorkspaceConnectionOAuth2_STATUS
func (auth2 *WorkspaceConnectionOAuth2) Initialize_From_WorkspaceConnectionOAuth2_STATUS(source *WorkspaceConnectionOAuth2_STATUS) error {

	// AuthUrl
	auth2.AuthUrl = genruntime.ClonePointerToString(source.AuthUrl)

	// ClientId
	if source.ClientId != nil {
		clientId := *source.ClientId
		auth2.ClientId = &clientId
	} else {
		auth2.ClientId = nil
	}

	// TenantId
	auth2.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Username
	auth2.Username = genruntime.ClonePointerToString(source.Username)

	// No error
	return nil
}

// ClientId and ClientSecret are required. Other properties are optional
// depending on each OAuth2 provider's
// implementation.
type WorkspaceConnectionOAuth2_STATUS struct {
	// AuthUrl: Required by Concur connection category
	AuthUrl *string `json:"authUrl,omitempty"`

	// ClientId: Client id in the format of UUID
	ClientId *string `json:"clientId,omitempty"`

	// TenantId: Required by QuickBooks and Xero connection categories
	TenantId *string `json:"tenantId,omitempty"`

	// Username: Concur, ServiceNow auth server AccessToken grant type is 'Password'
	// which requires UsernamePassword
	Username *string `json:"username,omitempty"`
}

var _ genruntime.FromARMConverter = &WorkspaceConnectionOAuth2_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (auth2 *WorkspaceConnectionOAuth2_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceConnectionOAuth2_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (auth2 *WorkspaceConnectionOAuth2_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspaceConnectionOAuth2_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceConnectionOAuth2_STATUS, got %T", armInput)
	}

	// Set property "AuthUrl":
	if typedInput.AuthUrl != nil {
		authUrl := *typedInput.AuthUrl
		auth2.AuthUrl = &authUrl
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		auth2.ClientId = &clientId
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		auth2.TenantId = &tenantId
	}

	// Set property "Username":
	if typedInput.Username != nil {
		username := *typedInput.Username
		auth2.Username = &username
	}

	// No error
	return nil
}

// AssignProperties_From_WorkspaceConnectionOAuth2_STATUS populates our WorkspaceConnectionOAuth2_STATUS from the provided source WorkspaceConnectionOAuth2_STATUS
func (auth2 *WorkspaceConnectionOAuth2_STATUS) AssignProperties_From_WorkspaceConnectionOAuth2_STATUS(source *storage.WorkspaceConnectionOAuth2_STATUS) error {

	// AuthUrl
	auth2.AuthUrl = genruntime.ClonePointerToString(source.AuthUrl)

	// ClientId
	auth2.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// TenantId
	auth2.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Username
	auth2.Username = genruntime.ClonePointerToString(source.Username)

	// No error
	return nil
}

// AssignProperties_To_WorkspaceConnectionOAuth2_STATUS populates the provided destination WorkspaceConnectionOAuth2_STATUS from our WorkspaceConnectionOAuth2_STATUS
func (auth2 *WorkspaceConnectionOAuth2_STATUS) AssignProperties_To_WorkspaceConnectionOAuth2_STATUS(destination *storage.WorkspaceConnectionOAuth2_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthUrl
	destination.AuthUrl = genruntime.ClonePointerToString(auth2.AuthUrl)

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(auth2.ClientId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(auth2.TenantId)

	// Username
	destination.Username = genruntime.ClonePointerToString(auth2.Username)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type WorkspaceConnectionPersonalAccessToken struct {
	Pat *genruntime.SecretReference `json:"pat,omitempty"`
}

var _ genruntime.ARMTransformer = &WorkspaceConnectionPersonalAccessToken{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (token *WorkspaceConnectionPersonalAccessToken) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if token == nil {
		return nil, nil
	}
	result := &arm.WorkspaceConnectionPersonalAccessToken{}

	// Set property "Pat":
	if token.Pat != nil {
		patSecret, err := resolved.ResolvedSecrets.Lookup(*token.Pat)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property Pat")
		}
		pat := patSecret
		result.Pat = &pat
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (token *WorkspaceConnectionPersonalAccessToken) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceConnectionPersonalAccessToken{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (token *WorkspaceConnectionPersonalAccessToken) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(arm.WorkspaceConnectionPersonalAccessToken)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceConnectionPersonalAccessToken, got %T", armInput)
	}

	// no assignment for property "Pat"

	// No error
	return nil
}

// AssignProperties_From_WorkspaceConnectionPersonalAccessToken populates our WorkspaceConnectionPersonalAccessToken from the provided source WorkspaceConnectionPersonalAccessToken
func (token *WorkspaceConnectionPersonalAccessToken) AssignProperties_From_WorkspaceConnectionPersonalAccessToken(source *storage.WorkspaceConnectionPersonalAccessToken) error {

	// Pat
	if source.Pat != nil {
		pat := source.Pat.Copy()
		token.Pat = &pat
	} else {
		token.Pat = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WorkspaceConnectionPersonalAccessToken populates the provided destination WorkspaceConnectionPersonalAccessToken from our WorkspaceConnectionPersonalAccessToken
func (token *WorkspaceConnectionPersonalAccessToken) AssignProperties_To_WorkspaceConnectionPersonalAccessToken(destination *storage.WorkspaceConnectionPersonalAccessToken) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Pat
	if token.Pat != nil {
		pat := token.Pat.Copy()
		destination.Pat = &pat
	} else {
		destination.Pat = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_WorkspaceConnectionPersonalAccessToken_STATUS populates our WorkspaceConnectionPersonalAccessToken from the provided source WorkspaceConnectionPersonalAccessToken_STATUS
func (token *WorkspaceConnectionPersonalAccessToken) Initialize_From_WorkspaceConnectionPersonalAccessToken_STATUS(source *WorkspaceConnectionPersonalAccessToken_STATUS) error {

	// No error
	return nil
}

type WorkspaceConnectionPersonalAccessToken_STATUS struct {
}

var _ genruntime.FromARMConverter = &WorkspaceConnectionPersonalAccessToken_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (token *WorkspaceConnectionPersonalAccessToken_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceConnectionPersonalAccessToken_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (token *WorkspaceConnectionPersonalAccessToken_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(arm.WorkspaceConnectionPersonalAccessToken_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceConnectionPersonalAccessToken_STATUS, got %T", armInput)
	}

	// No error
	return nil
}

// AssignProperties_From_WorkspaceConnectionPersonalAccessToken_STATUS populates our WorkspaceConnectionPersonalAccessToken_STATUS from the provided source WorkspaceConnectionPersonalAccessToken_STATUS
func (token *WorkspaceConnectionPersonalAccessToken_STATUS) AssignProperties_From_WorkspaceConnectionPersonalAccessToken_STATUS(source *storage.WorkspaceConnectionPersonalAccessToken_STATUS) error {

	// No error
	return nil
}

// AssignProperties_To_WorkspaceConnectionPersonalAccessToken_STATUS populates the provided destination WorkspaceConnectionPersonalAccessToken_STATUS from our WorkspaceConnectionPersonalAccessToken_STATUS
func (token *WorkspaceConnectionPersonalAccessToken_STATUS) AssignProperties_To_WorkspaceConnectionPersonalAccessToken_STATUS(destination *storage.WorkspaceConnectionPersonalAccessToken_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type WorkspaceConnectionServicePrincipal struct {
	ClientId           *string                        `json:"clientId,omitempty" optionalConfigMapPair:"ClientId"`
	ClientIdFromConfig *genruntime.ConfigMapReference `json:"clientIdFromConfig,omitempty" optionalConfigMapPair:"ClientId"`
	ClientSecret       *genruntime.SecretReference    `json:"clientSecret,omitempty"`
	TenantId           *string                        `json:"tenantId,omitempty" optionalConfigMapPair:"TenantId"`
	TenantIdFromConfig *genruntime.ConfigMapReference `json:"tenantIdFromConfig,omitempty" optionalConfigMapPair:"TenantId"`
}

var _ genruntime.ARMTransformer = &WorkspaceConnectionServicePrincipal{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (principal *WorkspaceConnectionServicePrincipal) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if principal == nil {
		return nil, nil
	}
	result := &arm.WorkspaceConnectionServicePrincipal{}

	// Set property "ClientId":
	if principal.ClientId != nil {
		clientId := *principal.ClientId
		result.ClientId = &clientId
	}
	if principal.ClientIdFromConfig != nil {
		clientIdValue, err := resolved.ResolvedConfigMaps.Lookup(*principal.ClientIdFromConfig)
		if err != nil {
			return nil, errors.Wrap(err, "looking up configmap for property ClientId")
		}
		clientId := clientIdValue
		result.ClientId = &clientId
	}

	// Set property "ClientSecret":
	if principal.ClientSecret != nil {
		clientSecretSecret, err := resolved.ResolvedSecrets.Lookup(*principal.ClientSecret)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property ClientSecret")
		}
		clientSecret := clientSecretSecret
		result.ClientSecret = &clientSecret
	}

	// Set property "TenantId":
	if principal.TenantId != nil {
		tenantId := *principal.TenantId
		result.TenantId = &tenantId
	}
	if principal.TenantIdFromConfig != nil {
		tenantIdValue, err := resolved.ResolvedConfigMaps.Lookup(*principal.TenantIdFromConfig)
		if err != nil {
			return nil, errors.Wrap(err, "looking up configmap for property TenantId")
		}
		tenantId := tenantIdValue
		result.TenantId = &tenantId
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (principal *WorkspaceConnectionServicePrincipal) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceConnectionServicePrincipal{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (principal *WorkspaceConnectionServicePrincipal) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspaceConnectionServicePrincipal)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceConnectionServicePrincipal, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		principal.ClientId = &clientId
	}

	// no assignment for property "ClientIdFromConfig"

	// no assignment for property "ClientSecret"

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		principal.TenantId = &tenantId
	}

	// no assignment for property "TenantIdFromConfig"

	// No error
	return nil
}

// AssignProperties_From_WorkspaceConnectionServicePrincipal populates our WorkspaceConnectionServicePrincipal from the provided source WorkspaceConnectionServicePrincipal
func (principal *WorkspaceConnectionServicePrincipal) AssignProperties_From_WorkspaceConnectionServicePrincipal(source *storage.WorkspaceConnectionServicePrincipal) error {

	// ClientId
	principal.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// ClientIdFromConfig
	if source.ClientIdFromConfig != nil {
		clientIdFromConfig := source.ClientIdFromConfig.Copy()
		principal.ClientIdFromConfig = &clientIdFromConfig
	} else {
		principal.ClientIdFromConfig = nil
	}

	// ClientSecret
	if source.ClientSecret != nil {
		clientSecret := source.ClientSecret.Copy()
		principal.ClientSecret = &clientSecret
	} else {
		principal.ClientSecret = nil
	}

	// TenantId
	principal.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// TenantIdFromConfig
	if source.TenantIdFromConfig != nil {
		tenantIdFromConfig := source.TenantIdFromConfig.Copy()
		principal.TenantIdFromConfig = &tenantIdFromConfig
	} else {
		principal.TenantIdFromConfig = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WorkspaceConnectionServicePrincipal populates the provided destination WorkspaceConnectionServicePrincipal from our WorkspaceConnectionServicePrincipal
func (principal *WorkspaceConnectionServicePrincipal) AssignProperties_To_WorkspaceConnectionServicePrincipal(destination *storage.WorkspaceConnectionServicePrincipal) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(principal.ClientId)

	// ClientIdFromConfig
	if principal.ClientIdFromConfig != nil {
		clientIdFromConfig := principal.ClientIdFromConfig.Copy()
		destination.ClientIdFromConfig = &clientIdFromConfig
	} else {
		destination.ClientIdFromConfig = nil
	}

	// ClientSecret
	if principal.ClientSecret != nil {
		clientSecret := principal.ClientSecret.Copy()
		destination.ClientSecret = &clientSecret
	} else {
		destination.ClientSecret = nil
	}

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(principal.TenantId)

	// TenantIdFromConfig
	if principal.TenantIdFromConfig != nil {
		tenantIdFromConfig := principal.TenantIdFromConfig.Copy()
		destination.TenantIdFromConfig = &tenantIdFromConfig
	} else {
		destination.TenantIdFromConfig = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_WorkspaceConnectionServicePrincipal_STATUS populates our WorkspaceConnectionServicePrincipal from the provided source WorkspaceConnectionServicePrincipal_STATUS
func (principal *WorkspaceConnectionServicePrincipal) Initialize_From_WorkspaceConnectionServicePrincipal_STATUS(source *WorkspaceConnectionServicePrincipal_STATUS) error {

	// ClientId
	principal.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// TenantId
	principal.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// No error
	return nil
}

type WorkspaceConnectionServicePrincipal_STATUS struct {
	ClientId *string `json:"clientId,omitempty"`
	TenantId *string `json:"tenantId,omitempty"`
}

var _ genruntime.FromARMConverter = &WorkspaceConnectionServicePrincipal_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (principal *WorkspaceConnectionServicePrincipal_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceConnectionServicePrincipal_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (principal *WorkspaceConnectionServicePrincipal_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspaceConnectionServicePrincipal_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceConnectionServicePrincipal_STATUS, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		principal.ClientId = &clientId
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		principal.TenantId = &tenantId
	}

	// No error
	return nil
}

// AssignProperties_From_WorkspaceConnectionServicePrincipal_STATUS populates our WorkspaceConnectionServicePrincipal_STATUS from the provided source WorkspaceConnectionServicePrincipal_STATUS
func (principal *WorkspaceConnectionServicePrincipal_STATUS) AssignProperties_From_WorkspaceConnectionServicePrincipal_STATUS(source *storage.WorkspaceConnectionServicePrincipal_STATUS) error {

	// ClientId
	principal.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// TenantId
	principal.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// No error
	return nil
}

// AssignProperties_To_WorkspaceConnectionServicePrincipal_STATUS populates the provided destination WorkspaceConnectionServicePrincipal_STATUS from our WorkspaceConnectionServicePrincipal_STATUS
func (principal *WorkspaceConnectionServicePrincipal_STATUS) AssignProperties_To_WorkspaceConnectionServicePrincipal_STATUS(destination *storage.WorkspaceConnectionServicePrincipal_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(principal.ClientId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(principal.TenantId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type WorkspaceConnectionSharedAccessSignature struct {
	Sas *genruntime.SecretReference `json:"sas,omitempty"`
}

var _ genruntime.ARMTransformer = &WorkspaceConnectionSharedAccessSignature{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (signature *WorkspaceConnectionSharedAccessSignature) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if signature == nil {
		return nil, nil
	}
	result := &arm.WorkspaceConnectionSharedAccessSignature{}

	// Set property "Sas":
	if signature.Sas != nil {
		sasSecret, err := resolved.ResolvedSecrets.Lookup(*signature.Sas)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property Sas")
		}
		sas := sasSecret
		result.Sas = &sas
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (signature *WorkspaceConnectionSharedAccessSignature) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceConnectionSharedAccessSignature{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (signature *WorkspaceConnectionSharedAccessSignature) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(arm.WorkspaceConnectionSharedAccessSignature)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceConnectionSharedAccessSignature, got %T", armInput)
	}

	// no assignment for property "Sas"

	// No error
	return nil
}

// AssignProperties_From_WorkspaceConnectionSharedAccessSignature populates our WorkspaceConnectionSharedAccessSignature from the provided source WorkspaceConnectionSharedAccessSignature
func (signature *WorkspaceConnectionSharedAccessSignature) AssignProperties_From_WorkspaceConnectionSharedAccessSignature(source *storage.WorkspaceConnectionSharedAccessSignature) error {

	// Sas
	if source.Sas != nil {
		sa := source.Sas.Copy()
		signature.Sas = &sa
	} else {
		signature.Sas = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WorkspaceConnectionSharedAccessSignature populates the provided destination WorkspaceConnectionSharedAccessSignature from our WorkspaceConnectionSharedAccessSignature
func (signature *WorkspaceConnectionSharedAccessSignature) AssignProperties_To_WorkspaceConnectionSharedAccessSignature(destination *storage.WorkspaceConnectionSharedAccessSignature) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Sas
	if signature.Sas != nil {
		sa := signature.Sas.Copy()
		destination.Sas = &sa
	} else {
		destination.Sas = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_WorkspaceConnectionSharedAccessSignature_STATUS populates our WorkspaceConnectionSharedAccessSignature from the provided source WorkspaceConnectionSharedAccessSignature_STATUS
func (signature *WorkspaceConnectionSharedAccessSignature) Initialize_From_WorkspaceConnectionSharedAccessSignature_STATUS(source *WorkspaceConnectionSharedAccessSignature_STATUS) error {

	// No error
	return nil
}

type WorkspaceConnectionSharedAccessSignature_STATUS struct {
}

var _ genruntime.FromARMConverter = &WorkspaceConnectionSharedAccessSignature_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (signature *WorkspaceConnectionSharedAccessSignature_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceConnectionSharedAccessSignature_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (signature *WorkspaceConnectionSharedAccessSignature_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(arm.WorkspaceConnectionSharedAccessSignature_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceConnectionSharedAccessSignature_STATUS, got %T", armInput)
	}

	// No error
	return nil
}

// AssignProperties_From_WorkspaceConnectionSharedAccessSignature_STATUS populates our WorkspaceConnectionSharedAccessSignature_STATUS from the provided source WorkspaceConnectionSharedAccessSignature_STATUS
func (signature *WorkspaceConnectionSharedAccessSignature_STATUS) AssignProperties_From_WorkspaceConnectionSharedAccessSignature_STATUS(source *storage.WorkspaceConnectionSharedAccessSignature_STATUS) error {

	// No error
	return nil
}

// AssignProperties_To_WorkspaceConnectionSharedAccessSignature_STATUS populates the provided destination WorkspaceConnectionSharedAccessSignature_STATUS from our WorkspaceConnectionSharedAccessSignature_STATUS
func (signature *WorkspaceConnectionSharedAccessSignature_STATUS) AssignProperties_To_WorkspaceConnectionSharedAccessSignature_STATUS(destination *storage.WorkspaceConnectionSharedAccessSignature_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type WorkspaceConnectionUsernamePassword struct {
	Password *genruntime.SecretReference `json:"password,omitempty"`

	// SecurityToken: Optional, required by connections like SalesForce for extra security in addition to UsernamePassword
	SecurityToken *genruntime.SecretReference `json:"securityToken,omitempty"`
	Username      *string                     `json:"username,omitempty"`
}

var _ genruntime.ARMTransformer = &WorkspaceConnectionUsernamePassword{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (password *WorkspaceConnectionUsernamePassword) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if password == nil {
		return nil, nil
	}
	result := &arm.WorkspaceConnectionUsernamePassword{}

	// Set property "Password":
	if password.Password != nil {
		passwordSecret, err := resolved.ResolvedSecrets.Lookup(*password.Password)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property Password")
		}
		password1 := passwordSecret
		result.Password = &password1
	}

	// Set property "SecurityToken":
	if password.SecurityToken != nil {
		securityTokenSecret, err := resolved.ResolvedSecrets.Lookup(*password.SecurityToken)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property SecurityToken")
		}
		securityToken := securityTokenSecret
		result.SecurityToken = &securityToken
	}

	// Set property "Username":
	if password.Username != nil {
		username := *password.Username
		result.Username = &username
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (password *WorkspaceConnectionUsernamePassword) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceConnectionUsernamePassword{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (password *WorkspaceConnectionUsernamePassword) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspaceConnectionUsernamePassword)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceConnectionUsernamePassword, got %T", armInput)
	}

	// no assignment for property "Password"

	// no assignment for property "SecurityToken"

	// Set property "Username":
	if typedInput.Username != nil {
		username := *typedInput.Username
		password.Username = &username
	}

	// No error
	return nil
}

// AssignProperties_From_WorkspaceConnectionUsernamePassword populates our WorkspaceConnectionUsernamePassword from the provided source WorkspaceConnectionUsernamePassword
func (password *WorkspaceConnectionUsernamePassword) AssignProperties_From_WorkspaceConnectionUsernamePassword(source *storage.WorkspaceConnectionUsernamePassword) error {

	// Password
	if source.Password != nil {
		passwordTemp := source.Password.Copy()
		password.Password = &passwordTemp
	} else {
		password.Password = nil
	}

	// SecurityToken
	if source.SecurityToken != nil {
		securityToken := source.SecurityToken.Copy()
		password.SecurityToken = &securityToken
	} else {
		password.SecurityToken = nil
	}

	// Username
	password.Username = genruntime.ClonePointerToString(source.Username)

	// No error
	return nil
}

// AssignProperties_To_WorkspaceConnectionUsernamePassword populates the provided destination WorkspaceConnectionUsernamePassword from our WorkspaceConnectionUsernamePassword
func (password *WorkspaceConnectionUsernamePassword) AssignProperties_To_WorkspaceConnectionUsernamePassword(destination *storage.WorkspaceConnectionUsernamePassword) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Password
	if password.Password != nil {
		passwordTemp := password.Password.Copy()
		destination.Password = &passwordTemp
	} else {
		destination.Password = nil
	}

	// SecurityToken
	if password.SecurityToken != nil {
		securityToken := password.SecurityToken.Copy()
		destination.SecurityToken = &securityToken
	} else {
		destination.SecurityToken = nil
	}

	// Username
	destination.Username = genruntime.ClonePointerToString(password.Username)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_WorkspaceConnectionUsernamePassword_STATUS populates our WorkspaceConnectionUsernamePassword from the provided source WorkspaceConnectionUsernamePassword_STATUS
func (password *WorkspaceConnectionUsernamePassword) Initialize_From_WorkspaceConnectionUsernamePassword_STATUS(source *WorkspaceConnectionUsernamePassword_STATUS) error {

	// Username
	password.Username = genruntime.ClonePointerToString(source.Username)

	// No error
	return nil
}

type WorkspaceConnectionUsernamePassword_STATUS struct {
	Username *string `json:"username,omitempty"`
}

var _ genruntime.FromARMConverter = &WorkspaceConnectionUsernamePassword_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (password *WorkspaceConnectionUsernamePassword_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceConnectionUsernamePassword_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (password *WorkspaceConnectionUsernamePassword_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspaceConnectionUsernamePassword_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceConnectionUsernamePassword_STATUS, got %T", armInput)
	}

	// Set property "Username":
	if typedInput.Username != nil {
		username := *typedInput.Username
		password.Username = &username
	}

	// No error
	return nil
}

// AssignProperties_From_WorkspaceConnectionUsernamePassword_STATUS populates our WorkspaceConnectionUsernamePassword_STATUS from the provided source WorkspaceConnectionUsernamePassword_STATUS
func (password *WorkspaceConnectionUsernamePassword_STATUS) AssignProperties_From_WorkspaceConnectionUsernamePassword_STATUS(source *storage.WorkspaceConnectionUsernamePassword_STATUS) error {

	// Username
	password.Username = genruntime.ClonePointerToString(source.Username)

	// No error
	return nil
}

// AssignProperties_To_WorkspaceConnectionUsernamePassword_STATUS populates the provided destination WorkspaceConnectionUsernamePassword_STATUS from our WorkspaceConnectionUsernamePassword_STATUS
func (password *WorkspaceConnectionUsernamePassword_STATUS) AssignProperties_To_WorkspaceConnectionUsernamePassword_STATUS(destination *storage.WorkspaceConnectionUsernamePassword_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Username
	destination.Username = genruntime.ClonePointerToString(password.Username)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&WorkspacesConnection{}, &WorkspacesConnectionList{})
}
