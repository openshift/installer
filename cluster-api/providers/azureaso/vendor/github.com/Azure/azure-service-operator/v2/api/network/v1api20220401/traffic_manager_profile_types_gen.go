// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20220401

import (
	"context"
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/network/v1api20220401/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/network/v1api20220401/storage"
	"github.com/Azure/azure-service-operator/v2/internal/genericarmclient"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/go-logr/logr"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /trafficmanager/resource-manager/Microsoft.Network/stable/2022-04-01/trafficmanager.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficmanagerprofiles/{profileName}
type TrafficManagerProfile struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              TrafficManagerProfile_Spec   `json:"spec,omitempty"`
	Status            TrafficManagerProfile_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &TrafficManagerProfile{}

// GetConditions returns the conditions of the resource
func (profile *TrafficManagerProfile) GetConditions() conditions.Conditions {
	return profile.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (profile *TrafficManagerProfile) SetConditions(conditions conditions.Conditions) {
	profile.Status.Conditions = conditions
}

var _ conversion.Convertible = &TrafficManagerProfile{}

// ConvertFrom populates our TrafficManagerProfile from the provided hub TrafficManagerProfile
func (profile *TrafficManagerProfile) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.TrafficManagerProfile)
	if !ok {
		return fmt.Errorf("expected network/v1api20220401/storage/TrafficManagerProfile but received %T instead", hub)
	}

	return profile.AssignProperties_From_TrafficManagerProfile(source)
}

// ConvertTo populates the provided hub TrafficManagerProfile from our TrafficManagerProfile
func (profile *TrafficManagerProfile) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.TrafficManagerProfile)
	if !ok {
		return fmt.Errorf("expected network/v1api20220401/storage/TrafficManagerProfile but received %T instead", hub)
	}

	return profile.AssignProperties_To_TrafficManagerProfile(destination)
}

// +kubebuilder:webhook:path=/mutate-network-azure-com-v1api20220401-trafficmanagerprofile,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=network.azure.com,resources=trafficmanagerprofiles,verbs=create;update,versions=v1api20220401,name=default.v1api20220401.trafficmanagerprofiles.network.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &TrafficManagerProfile{}

// Default applies defaults to the TrafficManagerProfile resource
func (profile *TrafficManagerProfile) Default() {
	profile.defaultImpl()
	var temp any = profile
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (profile *TrafficManagerProfile) defaultAzureName() {
	if profile.Spec.AzureName == "" {
		profile.Spec.AzureName = profile.Name
	}
}

// defaultImpl applies the code generated defaults to the TrafficManagerProfile resource
func (profile *TrafficManagerProfile) defaultImpl() { profile.defaultAzureName() }

var _ configmaps.Exporter = &TrafficManagerProfile{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (profile *TrafficManagerProfile) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if profile.Spec.OperatorSpec == nil {
		return nil
	}
	return profile.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &TrafficManagerProfile{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (profile *TrafficManagerProfile) SecretDestinationExpressions() []*core.DestinationExpression {
	if profile.Spec.OperatorSpec == nil {
		return nil
	}
	return profile.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &TrafficManagerProfile{}

// InitializeSpec initializes the spec for this resource from the given status
func (profile *TrafficManagerProfile) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*TrafficManagerProfile_STATUS); ok {
		return profile.Spec.Initialize_From_TrafficManagerProfile_STATUS(s)
	}

	return fmt.Errorf("expected Status of type TrafficManagerProfile_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesConfigExporter = &TrafficManagerProfile{}

// ExportKubernetesConfigMaps defines a resource which can create ConfigMaps in Kubernetes.
func (profile *TrafficManagerProfile) ExportKubernetesConfigMaps(_ context.Context, _ genruntime.MetaObject, _ *genericarmclient.GenericClient, _ logr.Logger) ([]client.Object, error) {
	collector := configmaps.NewCollector(profile.Namespace)
	if profile.Spec.OperatorSpec != nil && profile.Spec.OperatorSpec.ConfigMaps != nil {
		if profile.Status.DnsConfig != nil {
			if profile.Status.DnsConfig.Fqdn != nil {
				collector.AddValue(profile.Spec.OperatorSpec.ConfigMaps.DnsConfigFqdn, *profile.Status.DnsConfig.Fqdn)
			}
		}
	}
	result, err := collector.Values()
	if err != nil {
		return nil, err
	}
	return configmaps.SliceToClientObjectSlice(result), nil
}

var _ genruntime.KubernetesResource = &TrafficManagerProfile{}

// AzureName returns the Azure name of the resource
func (profile *TrafficManagerProfile) AzureName() string {
	return profile.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2022-04-01"
func (profile TrafficManagerProfile) GetAPIVersion() string {
	return "2022-04-01"
}

// GetResourceScope returns the scope of the resource
func (profile *TrafficManagerProfile) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (profile *TrafficManagerProfile) GetSpec() genruntime.ConvertibleSpec {
	return &profile.Spec
}

// GetStatus returns the status of this resource
func (profile *TrafficManagerProfile) GetStatus() genruntime.ConvertibleStatus {
	return &profile.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (profile *TrafficManagerProfile) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Network/trafficmanagerprofiles"
func (profile *TrafficManagerProfile) GetType() string {
	return "Microsoft.Network/trafficmanagerprofiles"
}

// NewEmptyStatus returns a new empty (blank) status
func (profile *TrafficManagerProfile) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &TrafficManagerProfile_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (profile *TrafficManagerProfile) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(profile.Spec)
	return profile.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (profile *TrafficManagerProfile) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*TrafficManagerProfile_STATUS); ok {
		profile.Status = *st
		return nil
	}

	// Convert status to required version
	var st TrafficManagerProfile_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	profile.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-network-azure-com-v1api20220401-trafficmanagerprofile,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=network.azure.com,resources=trafficmanagerprofiles,verbs=create;update,versions=v1api20220401,name=validate.v1api20220401.trafficmanagerprofiles.network.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &TrafficManagerProfile{}

// ValidateCreate validates the creation of the resource
func (profile *TrafficManagerProfile) ValidateCreate() (admission.Warnings, error) {
	validations := profile.createValidations()
	var temp any = profile
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	return genruntime.ValidateCreate(validations)
}

// ValidateDelete validates the deletion of the resource
func (profile *TrafficManagerProfile) ValidateDelete() (admission.Warnings, error) {
	validations := profile.deleteValidations()
	var temp any = profile
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	return genruntime.ValidateDelete(validations)
}

// ValidateUpdate validates an update of the resource
func (profile *TrafficManagerProfile) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	validations := profile.updateValidations()
	var temp any = profile
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	return genruntime.ValidateUpdate(old, validations)
}

// createValidations validates the creation of the resource
func (profile *TrafficManagerProfile) createValidations() []func() (admission.Warnings, error) {
	return []func() (admission.Warnings, error){profile.validateResourceReferences, profile.validateOwnerReference, profile.validateSecretDestinations, profile.validateConfigMapDestinations}
}

// deleteValidations validates the deletion of the resource
func (profile *TrafficManagerProfile) deleteValidations() []func() (admission.Warnings, error) {
	return nil
}

// updateValidations validates the update of the resource
func (profile *TrafficManagerProfile) updateValidations() []func(old runtime.Object) (admission.Warnings, error) {
	return []func(old runtime.Object) (admission.Warnings, error){
		func(old runtime.Object) (admission.Warnings, error) {
			return profile.validateResourceReferences()
		},
		profile.validateWriteOnceProperties,
		func(old runtime.Object) (admission.Warnings, error) {
			return profile.validateOwnerReference()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return profile.validateSecretDestinations()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return profile.validateConfigMapDestinations()
		},
	}
}

// validateConfigMapDestinations validates there are no colliding genruntime.ConfigMapDestinations
func (profile *TrafficManagerProfile) validateConfigMapDestinations() (admission.Warnings, error) {
	if profile.Spec.OperatorSpec == nil {
		return nil, nil
	}
	var toValidate []*genruntime.ConfigMapDestination
	if profile.Spec.OperatorSpec.ConfigMaps != nil {
		toValidate = []*genruntime.ConfigMapDestination{
			profile.Spec.OperatorSpec.ConfigMaps.DnsConfigFqdn,
		}
	}
	return configmaps.ValidateDestinations(profile, toValidate, profile.Spec.OperatorSpec.ConfigMapExpressions)
}

// validateOwnerReference validates the owner field
func (profile *TrafficManagerProfile) validateOwnerReference() (admission.Warnings, error) {
	return genruntime.ValidateOwner(profile)
}

// validateResourceReferences validates all resource references
func (profile *TrafficManagerProfile) validateResourceReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindResourceReferences(&profile.Spec)
	if err != nil {
		return nil, err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateSecretDestinations validates there are no colliding genruntime.SecretDestination's
func (profile *TrafficManagerProfile) validateSecretDestinations() (admission.Warnings, error) {
	if profile.Spec.OperatorSpec == nil {
		return nil, nil
	}
	return secrets.ValidateDestinations(profile, nil, profile.Spec.OperatorSpec.SecretExpressions)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (profile *TrafficManagerProfile) validateWriteOnceProperties(old runtime.Object) (admission.Warnings, error) {
	oldObj, ok := old.(*TrafficManagerProfile)
	if !ok {
		return nil, nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, profile)
}

// AssignProperties_From_TrafficManagerProfile populates our TrafficManagerProfile from the provided source TrafficManagerProfile
func (profile *TrafficManagerProfile) AssignProperties_From_TrafficManagerProfile(source *storage.TrafficManagerProfile) error {

	// ObjectMeta
	profile.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec TrafficManagerProfile_Spec
	err := spec.AssignProperties_From_TrafficManagerProfile_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_TrafficManagerProfile_Spec() to populate field Spec")
	}
	profile.Spec = spec

	// Status
	var status TrafficManagerProfile_STATUS
	err = status.AssignProperties_From_TrafficManagerProfile_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_TrafficManagerProfile_STATUS() to populate field Status")
	}
	profile.Status = status

	// No error
	return nil
}

// AssignProperties_To_TrafficManagerProfile populates the provided destination TrafficManagerProfile from our TrafficManagerProfile
func (profile *TrafficManagerProfile) AssignProperties_To_TrafficManagerProfile(destination *storage.TrafficManagerProfile) error {

	// ObjectMeta
	destination.ObjectMeta = *profile.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.TrafficManagerProfile_Spec
	err := profile.Spec.AssignProperties_To_TrafficManagerProfile_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_TrafficManagerProfile_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.TrafficManagerProfile_STATUS
	err = profile.Status.AssignProperties_To_TrafficManagerProfile_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_TrafficManagerProfile_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (profile *TrafficManagerProfile) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: profile.Spec.OriginalVersion(),
		Kind:    "TrafficManagerProfile",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /trafficmanager/resource-manager/Microsoft.Network/stable/2022-04-01/trafficmanager.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficmanagerprofiles/{profileName}
type TrafficManagerProfileList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []TrafficManagerProfile `json:"items"`
}

// +kubebuilder:validation:Enum={"2022-04-01"}
type APIVersion string

const APIVersion_Value = APIVersion("2022-04-01")

type TrafficManagerProfile_Spec struct {
	// AllowedEndpointRecordTypes: The list of allowed endpoint record types.
	AllowedEndpointRecordTypes []AllowedEndpointRecordType `json:"allowedEndpointRecordTypes,omitempty"`

	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// DnsConfig: The DNS settings of the Traffic Manager profile.
	DnsConfig *DnsConfig `json:"dnsConfig,omitempty"`

	// Location: The Azure Region where the resource lives
	Location *string `json:"location,omitempty"`

	// MaxReturn: Maximum number of endpoints to be returned for MultiValue routing type.
	MaxReturn *int `json:"maxReturn,omitempty"`

	// MonitorConfig: The endpoint monitoring settings of the Traffic Manager profile.
	MonitorConfig *MonitorConfig `json:"monitorConfig,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *TrafficManagerProfileOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// ProfileStatus: The status of the Traffic Manager profile.
	ProfileStatus *ProfileProperties_ProfileStatus `json:"profileStatus,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// TrafficRoutingMethod: The traffic routing method of the Traffic Manager profile.
	TrafficRoutingMethod *ProfileProperties_TrafficRoutingMethod `json:"trafficRoutingMethod,omitempty"`

	// TrafficViewEnrollmentStatus: Indicates whether Traffic View is 'Enabled' or 'Disabled' for the Traffic Manager profile.
	// Null, indicates 'Disabled'. Enabling this feature will increase the cost of the Traffic Manage profile.
	TrafficViewEnrollmentStatus *ProfileProperties_TrafficViewEnrollmentStatus `json:"trafficViewEnrollmentStatus,omitempty"`

	// Type: The type of the resource. Ex- Microsoft.Network/trafficManagerProfiles.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &TrafficManagerProfile_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *TrafficManagerProfile_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.TrafficManagerProfile_Spec{}

	// Set property "Location":
	if profile.Location != nil {
		location := *profile.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if profile.AllowedEndpointRecordTypes != nil ||
		profile.DnsConfig != nil ||
		profile.MaxReturn != nil ||
		profile.MonitorConfig != nil ||
		profile.ProfileStatus != nil ||
		profile.TrafficRoutingMethod != nil ||
		profile.TrafficViewEnrollmentStatus != nil {
		result.Properties = &arm.ProfileProperties{}
	}
	for _, item := range profile.AllowedEndpointRecordTypes {
		var temp string
		temp = string(item)
		result.Properties.AllowedEndpointRecordTypes = append(result.Properties.AllowedEndpointRecordTypes, arm.AllowedEndpointRecordType(temp))
	}
	if profile.DnsConfig != nil {
		dnsConfig_ARM, err := (*profile.DnsConfig).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dnsConfig := *dnsConfig_ARM.(*arm.DnsConfig)
		result.Properties.DnsConfig = &dnsConfig
	}
	if profile.MaxReturn != nil {
		maxReturn := *profile.MaxReturn
		result.Properties.MaxReturn = &maxReturn
	}
	if profile.MonitorConfig != nil {
		monitorConfig_ARM, err := (*profile.MonitorConfig).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		monitorConfig := *monitorConfig_ARM.(*arm.MonitorConfig)
		result.Properties.MonitorConfig = &monitorConfig
	}
	if profile.ProfileStatus != nil {
		var temp string
		temp = string(*profile.ProfileStatus)
		profileStatus := arm.ProfileProperties_ProfileStatus(temp)
		result.Properties.ProfileStatus = &profileStatus
	}
	if profile.TrafficRoutingMethod != nil {
		var temp string
		temp = string(*profile.TrafficRoutingMethod)
		trafficRoutingMethod := arm.ProfileProperties_TrafficRoutingMethod(temp)
		result.Properties.TrafficRoutingMethod = &trafficRoutingMethod
	}
	if profile.TrafficViewEnrollmentStatus != nil {
		var temp string
		temp = string(*profile.TrafficViewEnrollmentStatus)
		trafficViewEnrollmentStatus := arm.ProfileProperties_TrafficViewEnrollmentStatus(temp)
		result.Properties.TrafficViewEnrollmentStatus = &trafficViewEnrollmentStatus
	}

	// Set property "Tags":
	if profile.Tags != nil {
		result.Tags = make(map[string]string, len(profile.Tags))
		for key, value := range profile.Tags {
			result.Tags[key] = value
		}
	}

	// Set property "Type":
	if profile.Type != nil {
		typeVar := *profile.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *TrafficManagerProfile_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TrafficManagerProfile_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *TrafficManagerProfile_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TrafficManagerProfile_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TrafficManagerProfile_Spec, got %T", armInput)
	}

	// Set property "AllowedEndpointRecordTypes":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.AllowedEndpointRecordTypes {
			var temp string
			temp = string(item)
			profile.AllowedEndpointRecordTypes = append(profile.AllowedEndpointRecordTypes, AllowedEndpointRecordType(temp))
		}
	}

	// Set property "AzureName":
	profile.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "DnsConfig":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsConfig != nil {
			var dnsConfig1 DnsConfig
			err := dnsConfig1.PopulateFromARM(owner, *typedInput.Properties.DnsConfig)
			if err != nil {
				return err
			}
			dnsConfig := dnsConfig1
			profile.DnsConfig = &dnsConfig
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		profile.Location = &location
	}

	// Set property "MaxReturn":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MaxReturn != nil {
			maxReturn := *typedInput.Properties.MaxReturn
			profile.MaxReturn = &maxReturn
		}
	}

	// Set property "MonitorConfig":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MonitorConfig != nil {
			var monitorConfig1 MonitorConfig
			err := monitorConfig1.PopulateFromARM(owner, *typedInput.Properties.MonitorConfig)
			if err != nil {
				return err
			}
			monitorConfig := monitorConfig1
			profile.MonitorConfig = &monitorConfig
		}
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	profile.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "ProfileStatus":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProfileStatus != nil {
			var temp string
			temp = string(*typedInput.Properties.ProfileStatus)
			profileStatus := ProfileProperties_ProfileStatus(temp)
			profile.ProfileStatus = &profileStatus
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		profile.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			profile.Tags[key] = value
		}
	}

	// Set property "TrafficRoutingMethod":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TrafficRoutingMethod != nil {
			var temp string
			temp = string(*typedInput.Properties.TrafficRoutingMethod)
			trafficRoutingMethod := ProfileProperties_TrafficRoutingMethod(temp)
			profile.TrafficRoutingMethod = &trafficRoutingMethod
		}
	}

	// Set property "TrafficViewEnrollmentStatus":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TrafficViewEnrollmentStatus != nil {
			var temp string
			temp = string(*typedInput.Properties.TrafficViewEnrollmentStatus)
			trafficViewEnrollmentStatus := ProfileProperties_TrafficViewEnrollmentStatus(temp)
			profile.TrafficViewEnrollmentStatus = &trafficViewEnrollmentStatus
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		profile.Type = &typeVar
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &TrafficManagerProfile_Spec{}

// ConvertSpecFrom populates our TrafficManagerProfile_Spec from the provided source
func (profile *TrafficManagerProfile_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.TrafficManagerProfile_Spec)
	if ok {
		// Populate our instance from source
		return profile.AssignProperties_From_TrafficManagerProfile_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.TrafficManagerProfile_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = profile.AssignProperties_From_TrafficManagerProfile_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our TrafficManagerProfile_Spec
func (profile *TrafficManagerProfile_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.TrafficManagerProfile_Spec)
	if ok {
		// Populate destination from our instance
		return profile.AssignProperties_To_TrafficManagerProfile_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.TrafficManagerProfile_Spec{}
	err := profile.AssignProperties_To_TrafficManagerProfile_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_TrafficManagerProfile_Spec populates our TrafficManagerProfile_Spec from the provided source TrafficManagerProfile_Spec
func (profile *TrafficManagerProfile_Spec) AssignProperties_From_TrafficManagerProfile_Spec(source *storage.TrafficManagerProfile_Spec) error {

	// AllowedEndpointRecordTypes
	if source.AllowedEndpointRecordTypes != nil {
		allowedEndpointRecordTypeList := make([]AllowedEndpointRecordType, len(source.AllowedEndpointRecordTypes))
		for allowedEndpointRecordTypeIndex, allowedEndpointRecordTypeItem := range source.AllowedEndpointRecordTypes {
			// Shadow the loop variable to avoid aliasing
			allowedEndpointRecordTypeItem := allowedEndpointRecordTypeItem
			allowedEndpointRecordTypeList[allowedEndpointRecordTypeIndex] = genruntime.ToEnum(allowedEndpointRecordTypeItem, allowedEndpointRecordType_Values)
		}
		profile.AllowedEndpointRecordTypes = allowedEndpointRecordTypeList
	} else {
		profile.AllowedEndpointRecordTypes = nil
	}

	// AzureName
	profile.AzureName = source.AzureName

	// DnsConfig
	if source.DnsConfig != nil {
		var dnsConfig DnsConfig
		err := dnsConfig.AssignProperties_From_DnsConfig(source.DnsConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DnsConfig() to populate field DnsConfig")
		}
		profile.DnsConfig = &dnsConfig
	} else {
		profile.DnsConfig = nil
	}

	// Location
	profile.Location = genruntime.ClonePointerToString(source.Location)

	// MaxReturn
	profile.MaxReturn = genruntime.ClonePointerToInt(source.MaxReturn)

	// MonitorConfig
	if source.MonitorConfig != nil {
		var monitorConfig MonitorConfig
		err := monitorConfig.AssignProperties_From_MonitorConfig(source.MonitorConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_MonitorConfig() to populate field MonitorConfig")
		}
		profile.MonitorConfig = &monitorConfig
	} else {
		profile.MonitorConfig = nil
	}

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec TrafficManagerProfileOperatorSpec
		err := operatorSpec.AssignProperties_From_TrafficManagerProfileOperatorSpec(source.OperatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_TrafficManagerProfileOperatorSpec() to populate field OperatorSpec")
		}
		profile.OperatorSpec = &operatorSpec
	} else {
		profile.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		profile.Owner = &owner
	} else {
		profile.Owner = nil
	}

	// ProfileStatus
	if source.ProfileStatus != nil {
		profileStatus := *source.ProfileStatus
		profileStatusTemp := genruntime.ToEnum(profileStatus, profileProperties_ProfileStatus_Values)
		profile.ProfileStatus = &profileStatusTemp
	} else {
		profile.ProfileStatus = nil
	}

	// Tags
	profile.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TrafficRoutingMethod
	if source.TrafficRoutingMethod != nil {
		trafficRoutingMethod := *source.TrafficRoutingMethod
		trafficRoutingMethodTemp := genruntime.ToEnum(trafficRoutingMethod, profileProperties_TrafficRoutingMethod_Values)
		profile.TrafficRoutingMethod = &trafficRoutingMethodTemp
	} else {
		profile.TrafficRoutingMethod = nil
	}

	// TrafficViewEnrollmentStatus
	if source.TrafficViewEnrollmentStatus != nil {
		trafficViewEnrollmentStatus := *source.TrafficViewEnrollmentStatus
		trafficViewEnrollmentStatusTemp := genruntime.ToEnum(trafficViewEnrollmentStatus, profileProperties_TrafficViewEnrollmentStatus_Values)
		profile.TrafficViewEnrollmentStatus = &trafficViewEnrollmentStatusTemp
	} else {
		profile.TrafficViewEnrollmentStatus = nil
	}

	// Type
	profile.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_TrafficManagerProfile_Spec populates the provided destination TrafficManagerProfile_Spec from our TrafficManagerProfile_Spec
func (profile *TrafficManagerProfile_Spec) AssignProperties_To_TrafficManagerProfile_Spec(destination *storage.TrafficManagerProfile_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowedEndpointRecordTypes
	if profile.AllowedEndpointRecordTypes != nil {
		allowedEndpointRecordTypeList := make([]string, len(profile.AllowedEndpointRecordTypes))
		for allowedEndpointRecordTypeIndex, allowedEndpointRecordTypeItem := range profile.AllowedEndpointRecordTypes {
			// Shadow the loop variable to avoid aliasing
			allowedEndpointRecordTypeItem := allowedEndpointRecordTypeItem
			allowedEndpointRecordTypeList[allowedEndpointRecordTypeIndex] = string(allowedEndpointRecordTypeItem)
		}
		destination.AllowedEndpointRecordTypes = allowedEndpointRecordTypeList
	} else {
		destination.AllowedEndpointRecordTypes = nil
	}

	// AzureName
	destination.AzureName = profile.AzureName

	// DnsConfig
	if profile.DnsConfig != nil {
		var dnsConfig storage.DnsConfig
		err := profile.DnsConfig.AssignProperties_To_DnsConfig(&dnsConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DnsConfig() to populate field DnsConfig")
		}
		destination.DnsConfig = &dnsConfig
	} else {
		destination.DnsConfig = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(profile.Location)

	// MaxReturn
	destination.MaxReturn = genruntime.ClonePointerToInt(profile.MaxReturn)

	// MonitorConfig
	if profile.MonitorConfig != nil {
		var monitorConfig storage.MonitorConfig
		err := profile.MonitorConfig.AssignProperties_To_MonitorConfig(&monitorConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_MonitorConfig() to populate field MonitorConfig")
		}
		destination.MonitorConfig = &monitorConfig
	} else {
		destination.MonitorConfig = nil
	}

	// OperatorSpec
	if profile.OperatorSpec != nil {
		var operatorSpec storage.TrafficManagerProfileOperatorSpec
		err := profile.OperatorSpec.AssignProperties_To_TrafficManagerProfileOperatorSpec(&operatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_TrafficManagerProfileOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = profile.OriginalVersion()

	// Owner
	if profile.Owner != nil {
		owner := profile.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// ProfileStatus
	if profile.ProfileStatus != nil {
		profileStatus := string(*profile.ProfileStatus)
		destination.ProfileStatus = &profileStatus
	} else {
		destination.ProfileStatus = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(profile.Tags)

	// TrafficRoutingMethod
	if profile.TrafficRoutingMethod != nil {
		trafficRoutingMethod := string(*profile.TrafficRoutingMethod)
		destination.TrafficRoutingMethod = &trafficRoutingMethod
	} else {
		destination.TrafficRoutingMethod = nil
	}

	// TrafficViewEnrollmentStatus
	if profile.TrafficViewEnrollmentStatus != nil {
		trafficViewEnrollmentStatus := string(*profile.TrafficViewEnrollmentStatus)
		destination.TrafficViewEnrollmentStatus = &trafficViewEnrollmentStatus
	} else {
		destination.TrafficViewEnrollmentStatus = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(profile.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_TrafficManagerProfile_STATUS populates our TrafficManagerProfile_Spec from the provided source TrafficManagerProfile_STATUS
func (profile *TrafficManagerProfile_Spec) Initialize_From_TrafficManagerProfile_STATUS(source *TrafficManagerProfile_STATUS) error {

	// AllowedEndpointRecordTypes
	if source.AllowedEndpointRecordTypes != nil {
		allowedEndpointRecordTypeList := make([]AllowedEndpointRecordType, len(source.AllowedEndpointRecordTypes))
		for allowedEndpointRecordTypeIndex, allowedEndpointRecordTypeItem := range source.AllowedEndpointRecordTypes {
			// Shadow the loop variable to avoid aliasing
			allowedEndpointRecordTypeItem := allowedEndpointRecordTypeItem
			allowedEndpointRecordType := genruntime.ToEnum(string(allowedEndpointRecordTypeItem), allowedEndpointRecordType_Values)
			allowedEndpointRecordTypeList[allowedEndpointRecordTypeIndex] = allowedEndpointRecordType
		}
		profile.AllowedEndpointRecordTypes = allowedEndpointRecordTypeList
	} else {
		profile.AllowedEndpointRecordTypes = nil
	}

	// DnsConfig
	if source.DnsConfig != nil {
		var dnsConfig DnsConfig
		err := dnsConfig.Initialize_From_DnsConfig_STATUS(source.DnsConfig)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DnsConfig_STATUS() to populate field DnsConfig")
		}
		profile.DnsConfig = &dnsConfig
	} else {
		profile.DnsConfig = nil
	}

	// Location
	profile.Location = genruntime.ClonePointerToString(source.Location)

	// MaxReturn
	profile.MaxReturn = genruntime.ClonePointerToInt(source.MaxReturn)

	// MonitorConfig
	if source.MonitorConfig != nil {
		var monitorConfig MonitorConfig
		err := monitorConfig.Initialize_From_MonitorConfig_STATUS(source.MonitorConfig)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_MonitorConfig_STATUS() to populate field MonitorConfig")
		}
		profile.MonitorConfig = &monitorConfig
	} else {
		profile.MonitorConfig = nil
	}

	// ProfileStatus
	if source.ProfileStatus != nil {
		profileStatus := genruntime.ToEnum(string(*source.ProfileStatus), profileProperties_ProfileStatus_Values)
		profile.ProfileStatus = &profileStatus
	} else {
		profile.ProfileStatus = nil
	}

	// Tags
	profile.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TrafficRoutingMethod
	if source.TrafficRoutingMethod != nil {
		trafficRoutingMethod := genruntime.ToEnum(string(*source.TrafficRoutingMethod), profileProperties_TrafficRoutingMethod_Values)
		profile.TrafficRoutingMethod = &trafficRoutingMethod
	} else {
		profile.TrafficRoutingMethod = nil
	}

	// TrafficViewEnrollmentStatus
	if source.TrafficViewEnrollmentStatus != nil {
		trafficViewEnrollmentStatus := genruntime.ToEnum(string(*source.TrafficViewEnrollmentStatus), profileProperties_TrafficViewEnrollmentStatus_Values)
		profile.TrafficViewEnrollmentStatus = &trafficViewEnrollmentStatus
	} else {
		profile.TrafficViewEnrollmentStatus = nil
	}

	// Type
	profile.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (profile *TrafficManagerProfile_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (profile *TrafficManagerProfile_Spec) SetAzureName(azureName string) {
	profile.AzureName = azureName
}

type TrafficManagerProfile_STATUS struct {
	// AllowedEndpointRecordTypes: The list of allowed endpoint record types.
	AllowedEndpointRecordTypes []AllowedEndpointRecordType_STATUS `json:"allowedEndpointRecordTypes,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// DnsConfig: The DNS settings of the Traffic Manager profile.
	DnsConfig *DnsConfig_STATUS `json:"dnsConfig,omitempty"`

	// Endpoints: The list of endpoints in the Traffic Manager profile.
	Endpoints []Endpoint_STATUS `json:"endpoints,omitempty"`

	// Id: Fully qualified resource Id for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{resourceName}
	Id *string `json:"id,omitempty"`

	// Location: The Azure Region where the resource lives
	Location *string `json:"location,omitempty"`

	// MaxReturn: Maximum number of endpoints to be returned for MultiValue routing type.
	MaxReturn *int `json:"maxReturn,omitempty"`

	// MonitorConfig: The endpoint monitoring settings of the Traffic Manager profile.
	MonitorConfig *MonitorConfig_STATUS `json:"monitorConfig,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// ProfileStatus: The status of the Traffic Manager profile.
	ProfileStatus *ProfileProperties_ProfileStatus_STATUS `json:"profileStatus,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// TrafficRoutingMethod: The traffic routing method of the Traffic Manager profile.
	TrafficRoutingMethod *ProfileProperties_TrafficRoutingMethod_STATUS `json:"trafficRoutingMethod,omitempty"`

	// TrafficViewEnrollmentStatus: Indicates whether Traffic View is 'Enabled' or 'Disabled' for the Traffic Manager profile.
	// Null, indicates 'Disabled'. Enabling this feature will increase the cost of the Traffic Manage profile.
	TrafficViewEnrollmentStatus *ProfileProperties_TrafficViewEnrollmentStatus_STATUS `json:"trafficViewEnrollmentStatus,omitempty"`

	// Type: The type of the resource. Ex- Microsoft.Network/trafficManagerProfiles.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &TrafficManagerProfile_STATUS{}

// ConvertStatusFrom populates our TrafficManagerProfile_STATUS from the provided source
func (profile *TrafficManagerProfile_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.TrafficManagerProfile_STATUS)
	if ok {
		// Populate our instance from source
		return profile.AssignProperties_From_TrafficManagerProfile_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.TrafficManagerProfile_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = profile.AssignProperties_From_TrafficManagerProfile_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our TrafficManagerProfile_STATUS
func (profile *TrafficManagerProfile_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.TrafficManagerProfile_STATUS)
	if ok {
		// Populate destination from our instance
		return profile.AssignProperties_To_TrafficManagerProfile_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.TrafficManagerProfile_STATUS{}
	err := profile.AssignProperties_To_TrafficManagerProfile_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &TrafficManagerProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *TrafficManagerProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TrafficManagerProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *TrafficManagerProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TrafficManagerProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TrafficManagerProfile_STATUS, got %T", armInput)
	}

	// Set property "AllowedEndpointRecordTypes":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.AllowedEndpointRecordTypes {
			var temp string
			temp = string(item)
			profile.AllowedEndpointRecordTypes = append(profile.AllowedEndpointRecordTypes, AllowedEndpointRecordType_STATUS(temp))
		}
	}

	// no assignment for property "Conditions"

	// Set property "DnsConfig":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsConfig != nil {
			var dnsConfig1 DnsConfig_STATUS
			err := dnsConfig1.PopulateFromARM(owner, *typedInput.Properties.DnsConfig)
			if err != nil {
				return err
			}
			dnsConfig := dnsConfig1
			profile.DnsConfig = &dnsConfig
		}
	}

	// Set property "Endpoints":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Endpoints {
			var item1 Endpoint_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			profile.Endpoints = append(profile.Endpoints, item1)
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		profile.Id = &id
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		profile.Location = &location
	}

	// Set property "MaxReturn":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MaxReturn != nil {
			maxReturn := *typedInput.Properties.MaxReturn
			profile.MaxReturn = &maxReturn
		}
	}

	// Set property "MonitorConfig":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MonitorConfig != nil {
			var monitorConfig1 MonitorConfig_STATUS
			err := monitorConfig1.PopulateFromARM(owner, *typedInput.Properties.MonitorConfig)
			if err != nil {
				return err
			}
			monitorConfig := monitorConfig1
			profile.MonitorConfig = &monitorConfig
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		profile.Name = &name
	}

	// Set property "ProfileStatus":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProfileStatus != nil {
			var temp string
			temp = string(*typedInput.Properties.ProfileStatus)
			profileStatus := ProfileProperties_ProfileStatus_STATUS(temp)
			profile.ProfileStatus = &profileStatus
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		profile.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			profile.Tags[key] = value
		}
	}

	// Set property "TrafficRoutingMethod":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TrafficRoutingMethod != nil {
			var temp string
			temp = string(*typedInput.Properties.TrafficRoutingMethod)
			trafficRoutingMethod := ProfileProperties_TrafficRoutingMethod_STATUS(temp)
			profile.TrafficRoutingMethod = &trafficRoutingMethod
		}
	}

	// Set property "TrafficViewEnrollmentStatus":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TrafficViewEnrollmentStatus != nil {
			var temp string
			temp = string(*typedInput.Properties.TrafficViewEnrollmentStatus)
			trafficViewEnrollmentStatus := ProfileProperties_TrafficViewEnrollmentStatus_STATUS(temp)
			profile.TrafficViewEnrollmentStatus = &trafficViewEnrollmentStatus
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		profile.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_TrafficManagerProfile_STATUS populates our TrafficManagerProfile_STATUS from the provided source TrafficManagerProfile_STATUS
func (profile *TrafficManagerProfile_STATUS) AssignProperties_From_TrafficManagerProfile_STATUS(source *storage.TrafficManagerProfile_STATUS) error {

	// AllowedEndpointRecordTypes
	if source.AllowedEndpointRecordTypes != nil {
		allowedEndpointRecordTypeList := make([]AllowedEndpointRecordType_STATUS, len(source.AllowedEndpointRecordTypes))
		for allowedEndpointRecordTypeIndex, allowedEndpointRecordTypeItem := range source.AllowedEndpointRecordTypes {
			// Shadow the loop variable to avoid aliasing
			allowedEndpointRecordTypeItem := allowedEndpointRecordTypeItem
			allowedEndpointRecordTypeList[allowedEndpointRecordTypeIndex] = genruntime.ToEnum(allowedEndpointRecordTypeItem, allowedEndpointRecordType_STATUS_Values)
		}
		profile.AllowedEndpointRecordTypes = allowedEndpointRecordTypeList
	} else {
		profile.AllowedEndpointRecordTypes = nil
	}

	// Conditions
	profile.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// DnsConfig
	if source.DnsConfig != nil {
		var dnsConfig DnsConfig_STATUS
		err := dnsConfig.AssignProperties_From_DnsConfig_STATUS(source.DnsConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DnsConfig_STATUS() to populate field DnsConfig")
		}
		profile.DnsConfig = &dnsConfig
	} else {
		profile.DnsConfig = nil
	}

	// Endpoints
	if source.Endpoints != nil {
		endpointList := make([]Endpoint_STATUS, len(source.Endpoints))
		for endpointIndex, endpointItem := range source.Endpoints {
			// Shadow the loop variable to avoid aliasing
			endpointItem := endpointItem
			var endpoint Endpoint_STATUS
			err := endpoint.AssignProperties_From_Endpoint_STATUS(&endpointItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_Endpoint_STATUS() to populate field Endpoints")
			}
			endpointList[endpointIndex] = endpoint
		}
		profile.Endpoints = endpointList
	} else {
		profile.Endpoints = nil
	}

	// Id
	profile.Id = genruntime.ClonePointerToString(source.Id)

	// Location
	profile.Location = genruntime.ClonePointerToString(source.Location)

	// MaxReturn
	profile.MaxReturn = genruntime.ClonePointerToInt(source.MaxReturn)

	// MonitorConfig
	if source.MonitorConfig != nil {
		var monitorConfig MonitorConfig_STATUS
		err := monitorConfig.AssignProperties_From_MonitorConfig_STATUS(source.MonitorConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_MonitorConfig_STATUS() to populate field MonitorConfig")
		}
		profile.MonitorConfig = &monitorConfig
	} else {
		profile.MonitorConfig = nil
	}

	// Name
	profile.Name = genruntime.ClonePointerToString(source.Name)

	// ProfileStatus
	if source.ProfileStatus != nil {
		profileStatus := *source.ProfileStatus
		profileStatusTemp := genruntime.ToEnum(profileStatus, profileProperties_ProfileStatus_STATUS_Values)
		profile.ProfileStatus = &profileStatusTemp
	} else {
		profile.ProfileStatus = nil
	}

	// Tags
	profile.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TrafficRoutingMethod
	if source.TrafficRoutingMethod != nil {
		trafficRoutingMethod := *source.TrafficRoutingMethod
		trafficRoutingMethodTemp := genruntime.ToEnum(trafficRoutingMethod, profileProperties_TrafficRoutingMethod_STATUS_Values)
		profile.TrafficRoutingMethod = &trafficRoutingMethodTemp
	} else {
		profile.TrafficRoutingMethod = nil
	}

	// TrafficViewEnrollmentStatus
	if source.TrafficViewEnrollmentStatus != nil {
		trafficViewEnrollmentStatus := *source.TrafficViewEnrollmentStatus
		trafficViewEnrollmentStatusTemp := genruntime.ToEnum(trafficViewEnrollmentStatus, profileProperties_TrafficViewEnrollmentStatus_STATUS_Values)
		profile.TrafficViewEnrollmentStatus = &trafficViewEnrollmentStatusTemp
	} else {
		profile.TrafficViewEnrollmentStatus = nil
	}

	// Type
	profile.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_TrafficManagerProfile_STATUS populates the provided destination TrafficManagerProfile_STATUS from our TrafficManagerProfile_STATUS
func (profile *TrafficManagerProfile_STATUS) AssignProperties_To_TrafficManagerProfile_STATUS(destination *storage.TrafficManagerProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowedEndpointRecordTypes
	if profile.AllowedEndpointRecordTypes != nil {
		allowedEndpointRecordTypeList := make([]string, len(profile.AllowedEndpointRecordTypes))
		for allowedEndpointRecordTypeIndex, allowedEndpointRecordTypeItem := range profile.AllowedEndpointRecordTypes {
			// Shadow the loop variable to avoid aliasing
			allowedEndpointRecordTypeItem := allowedEndpointRecordTypeItem
			allowedEndpointRecordTypeList[allowedEndpointRecordTypeIndex] = string(allowedEndpointRecordTypeItem)
		}
		destination.AllowedEndpointRecordTypes = allowedEndpointRecordTypeList
	} else {
		destination.AllowedEndpointRecordTypes = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(profile.Conditions)

	// DnsConfig
	if profile.DnsConfig != nil {
		var dnsConfig storage.DnsConfig_STATUS
		err := profile.DnsConfig.AssignProperties_To_DnsConfig_STATUS(&dnsConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DnsConfig_STATUS() to populate field DnsConfig")
		}
		destination.DnsConfig = &dnsConfig
	} else {
		destination.DnsConfig = nil
	}

	// Endpoints
	if profile.Endpoints != nil {
		endpointList := make([]storage.Endpoint_STATUS, len(profile.Endpoints))
		for endpointIndex, endpointItem := range profile.Endpoints {
			// Shadow the loop variable to avoid aliasing
			endpointItem := endpointItem
			var endpoint storage.Endpoint_STATUS
			err := endpointItem.AssignProperties_To_Endpoint_STATUS(&endpoint)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_Endpoint_STATUS() to populate field Endpoints")
			}
			endpointList[endpointIndex] = endpoint
		}
		destination.Endpoints = endpointList
	} else {
		destination.Endpoints = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(profile.Id)

	// Location
	destination.Location = genruntime.ClonePointerToString(profile.Location)

	// MaxReturn
	destination.MaxReturn = genruntime.ClonePointerToInt(profile.MaxReturn)

	// MonitorConfig
	if profile.MonitorConfig != nil {
		var monitorConfig storage.MonitorConfig_STATUS
		err := profile.MonitorConfig.AssignProperties_To_MonitorConfig_STATUS(&monitorConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_MonitorConfig_STATUS() to populate field MonitorConfig")
		}
		destination.MonitorConfig = &monitorConfig
	} else {
		destination.MonitorConfig = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(profile.Name)

	// ProfileStatus
	if profile.ProfileStatus != nil {
		profileStatus := string(*profile.ProfileStatus)
		destination.ProfileStatus = &profileStatus
	} else {
		destination.ProfileStatus = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(profile.Tags)

	// TrafficRoutingMethod
	if profile.TrafficRoutingMethod != nil {
		trafficRoutingMethod := string(*profile.TrafficRoutingMethod)
		destination.TrafficRoutingMethod = &trafficRoutingMethod
	} else {
		destination.TrafficRoutingMethod = nil
	}

	// TrafficViewEnrollmentStatus
	if profile.TrafficViewEnrollmentStatus != nil {
		trafficViewEnrollmentStatus := string(*profile.TrafficViewEnrollmentStatus)
		destination.TrafficViewEnrollmentStatus = &trafficViewEnrollmentStatus
	} else {
		destination.TrafficViewEnrollmentStatus = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(profile.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The allowed type DNS record types for this profile.
// +kubebuilder:validation:Enum={"Any","DomainName","IPv4Address","IPv6Address"}
type AllowedEndpointRecordType string

const (
	AllowedEndpointRecordType_Any         = AllowedEndpointRecordType("Any")
	AllowedEndpointRecordType_DomainName  = AllowedEndpointRecordType("DomainName")
	AllowedEndpointRecordType_IPv4Address = AllowedEndpointRecordType("IPv4Address")
	AllowedEndpointRecordType_IPv6Address = AllowedEndpointRecordType("IPv6Address")
)

// Mapping from string to AllowedEndpointRecordType
var allowedEndpointRecordType_Values = map[string]AllowedEndpointRecordType{
	"any":         AllowedEndpointRecordType_Any,
	"domainname":  AllowedEndpointRecordType_DomainName,
	"ipv4address": AllowedEndpointRecordType_IPv4Address,
	"ipv6address": AllowedEndpointRecordType_IPv6Address,
}

// The allowed type DNS record types for this profile.
type AllowedEndpointRecordType_STATUS string

const (
	AllowedEndpointRecordType_STATUS_Any         = AllowedEndpointRecordType_STATUS("Any")
	AllowedEndpointRecordType_STATUS_DomainName  = AllowedEndpointRecordType_STATUS("DomainName")
	AllowedEndpointRecordType_STATUS_IPv4Address = AllowedEndpointRecordType_STATUS("IPv4Address")
	AllowedEndpointRecordType_STATUS_IPv6Address = AllowedEndpointRecordType_STATUS("IPv6Address")
)

// Mapping from string to AllowedEndpointRecordType_STATUS
var allowedEndpointRecordType_STATUS_Values = map[string]AllowedEndpointRecordType_STATUS{
	"any":         AllowedEndpointRecordType_STATUS_Any,
	"domainname":  AllowedEndpointRecordType_STATUS_DomainName,
	"ipv4address": AllowedEndpointRecordType_STATUS_IPv4Address,
	"ipv6address": AllowedEndpointRecordType_STATUS_IPv6Address,
}

// Class containing DNS settings in a Traffic Manager profile.
type DnsConfig struct {
	// RelativeName: The relative DNS name provided by this Traffic Manager profile. This value is combined with the DNS domain
	// name used by Azure Traffic Manager to form the fully-qualified domain name (FQDN) of the profile.
	RelativeName *string `json:"relativeName,omitempty"`

	// Ttl: The DNS Time-To-Live (TTL), in seconds. This informs the local DNS resolvers and DNS clients how long to cache DNS
	// responses provided by this Traffic Manager profile.
	Ttl *int `json:"ttl,omitempty"`
}

var _ genruntime.ARMTransformer = &DnsConfig{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (config *DnsConfig) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if config == nil {
		return nil, nil
	}
	result := &arm.DnsConfig{}

	// Set property "RelativeName":
	if config.RelativeName != nil {
		relativeName := *config.RelativeName
		result.RelativeName = &relativeName
	}

	// Set property "Ttl":
	if config.Ttl != nil {
		ttl := *config.Ttl
		result.Ttl = &ttl
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *DnsConfig) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DnsConfig{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *DnsConfig) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DnsConfig)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DnsConfig, got %T", armInput)
	}

	// Set property "RelativeName":
	if typedInput.RelativeName != nil {
		relativeName := *typedInput.RelativeName
		config.RelativeName = &relativeName
	}

	// Set property "Ttl":
	if typedInput.Ttl != nil {
		ttl := *typedInput.Ttl
		config.Ttl = &ttl
	}

	// No error
	return nil
}

// AssignProperties_From_DnsConfig populates our DnsConfig from the provided source DnsConfig
func (config *DnsConfig) AssignProperties_From_DnsConfig(source *storage.DnsConfig) error {

	// RelativeName
	config.RelativeName = genruntime.ClonePointerToString(source.RelativeName)

	// Ttl
	config.Ttl = genruntime.ClonePointerToInt(source.Ttl)

	// No error
	return nil
}

// AssignProperties_To_DnsConfig populates the provided destination DnsConfig from our DnsConfig
func (config *DnsConfig) AssignProperties_To_DnsConfig(destination *storage.DnsConfig) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RelativeName
	destination.RelativeName = genruntime.ClonePointerToString(config.RelativeName)

	// Ttl
	destination.Ttl = genruntime.ClonePointerToInt(config.Ttl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DnsConfig_STATUS populates our DnsConfig from the provided source DnsConfig_STATUS
func (config *DnsConfig) Initialize_From_DnsConfig_STATUS(source *DnsConfig_STATUS) error {

	// RelativeName
	config.RelativeName = genruntime.ClonePointerToString(source.RelativeName)

	// Ttl
	config.Ttl = genruntime.ClonePointerToInt(source.Ttl)

	// No error
	return nil
}

// Class containing DNS settings in a Traffic Manager profile.
type DnsConfig_STATUS struct {
	// Fqdn: The fully-qualified domain name (FQDN) of the Traffic Manager profile. This is formed from the concatenation of
	// the RelativeName with the DNS domain used by Azure Traffic Manager.
	Fqdn *string `json:"fqdn,omitempty"`

	// RelativeName: The relative DNS name provided by this Traffic Manager profile. This value is combined with the DNS domain
	// name used by Azure Traffic Manager to form the fully-qualified domain name (FQDN) of the profile.
	RelativeName *string `json:"relativeName,omitempty"`

	// Ttl: The DNS Time-To-Live (TTL), in seconds. This informs the local DNS resolvers and DNS clients how long to cache DNS
	// responses provided by this Traffic Manager profile.
	Ttl *int `json:"ttl,omitempty"`
}

var _ genruntime.FromARMConverter = &DnsConfig_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *DnsConfig_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DnsConfig_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *DnsConfig_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DnsConfig_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DnsConfig_STATUS, got %T", armInput)
	}

	// Set property "Fqdn":
	if typedInput.Fqdn != nil {
		fqdn := *typedInput.Fqdn
		config.Fqdn = &fqdn
	}

	// Set property "RelativeName":
	if typedInput.RelativeName != nil {
		relativeName := *typedInput.RelativeName
		config.RelativeName = &relativeName
	}

	// Set property "Ttl":
	if typedInput.Ttl != nil {
		ttl := *typedInput.Ttl
		config.Ttl = &ttl
	}

	// No error
	return nil
}

// AssignProperties_From_DnsConfig_STATUS populates our DnsConfig_STATUS from the provided source DnsConfig_STATUS
func (config *DnsConfig_STATUS) AssignProperties_From_DnsConfig_STATUS(source *storage.DnsConfig_STATUS) error {

	// Fqdn
	config.Fqdn = genruntime.ClonePointerToString(source.Fqdn)

	// RelativeName
	config.RelativeName = genruntime.ClonePointerToString(source.RelativeName)

	// Ttl
	config.Ttl = genruntime.ClonePointerToInt(source.Ttl)

	// No error
	return nil
}

// AssignProperties_To_DnsConfig_STATUS populates the provided destination DnsConfig_STATUS from our DnsConfig_STATUS
func (config *DnsConfig_STATUS) AssignProperties_To_DnsConfig_STATUS(destination *storage.DnsConfig_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Fqdn
	destination.Fqdn = genruntime.ClonePointerToString(config.Fqdn)

	// RelativeName
	destination.RelativeName = genruntime.ClonePointerToString(config.RelativeName)

	// Ttl
	destination.Ttl = genruntime.ClonePointerToInt(config.Ttl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Class representing a Traffic Manager endpoint.
type Endpoint_STATUS struct {
	// Id: Fully qualified resource Id for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{resourceName}
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &Endpoint_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (endpoint *Endpoint_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Endpoint_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (endpoint *Endpoint_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Endpoint_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Endpoint_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		endpoint.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_Endpoint_STATUS populates our Endpoint_STATUS from the provided source Endpoint_STATUS
func (endpoint *Endpoint_STATUS) AssignProperties_From_Endpoint_STATUS(source *storage.Endpoint_STATUS) error {

	// Id
	endpoint.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_Endpoint_STATUS populates the provided destination Endpoint_STATUS from our Endpoint_STATUS
func (endpoint *Endpoint_STATUS) AssignProperties_To_Endpoint_STATUS(destination *storage.Endpoint_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(endpoint.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Class containing endpoint monitoring settings in a Traffic Manager profile.
type MonitorConfig struct {
	// CustomHeaders: List of custom headers.
	CustomHeaders []MonitorConfig_CustomHeaders `json:"customHeaders,omitempty"`

	// ExpectedStatusCodeRanges: List of expected status code ranges.
	ExpectedStatusCodeRanges []MonitorConfig_ExpectedStatusCodeRanges `json:"expectedStatusCodeRanges,omitempty"`

	// IntervalInSeconds: The monitor interval for endpoints in this profile. This is the interval at which Traffic Manager
	// will check the health of each endpoint in this profile.
	IntervalInSeconds *int `json:"intervalInSeconds,omitempty"`

	// Path: The path relative to the endpoint domain name used to probe for endpoint health.
	Path *string `json:"path,omitempty"`

	// Port: The TCP port used to probe for endpoint health.
	Port *int `json:"port,omitempty"`

	// ProfileMonitorStatus: The profile-level monitoring status of the Traffic Manager profile.
	ProfileMonitorStatus *MonitorConfig_ProfileMonitorStatus `json:"profileMonitorStatus,omitempty"`

	// Protocol: The protocol (HTTP, HTTPS or TCP) used to probe for endpoint health.
	Protocol *MonitorConfig_Protocol `json:"protocol,omitempty"`

	// TimeoutInSeconds: The monitor timeout for endpoints in this profile. This is the time that Traffic Manager allows
	// endpoints in this profile to response to the health check.
	TimeoutInSeconds *int `json:"timeoutInSeconds,omitempty"`

	// ToleratedNumberOfFailures: The number of consecutive failed health check that Traffic Manager tolerates before declaring
	// an endpoint in this profile Degraded after the next failed health check.
	ToleratedNumberOfFailures *int `json:"toleratedNumberOfFailures,omitempty"`
}

var _ genruntime.ARMTransformer = &MonitorConfig{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (config *MonitorConfig) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if config == nil {
		return nil, nil
	}
	result := &arm.MonitorConfig{}

	// Set property "CustomHeaders":
	for _, item := range config.CustomHeaders {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.CustomHeaders = append(result.CustomHeaders, *item_ARM.(*arm.MonitorConfig_CustomHeaders))
	}

	// Set property "ExpectedStatusCodeRanges":
	for _, item := range config.ExpectedStatusCodeRanges {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.ExpectedStatusCodeRanges = append(result.ExpectedStatusCodeRanges, *item_ARM.(*arm.MonitorConfig_ExpectedStatusCodeRanges))
	}

	// Set property "IntervalInSeconds":
	if config.IntervalInSeconds != nil {
		intervalInSeconds := *config.IntervalInSeconds
		result.IntervalInSeconds = &intervalInSeconds
	}

	// Set property "Path":
	if config.Path != nil {
		path := *config.Path
		result.Path = &path
	}

	// Set property "Port":
	if config.Port != nil {
		port := *config.Port
		result.Port = &port
	}

	// Set property "ProfileMonitorStatus":
	if config.ProfileMonitorStatus != nil {
		var temp string
		temp = string(*config.ProfileMonitorStatus)
		profileMonitorStatus := arm.MonitorConfig_ProfileMonitorStatus(temp)
		result.ProfileMonitorStatus = &profileMonitorStatus
	}

	// Set property "Protocol":
	if config.Protocol != nil {
		var temp string
		temp = string(*config.Protocol)
		protocol := arm.MonitorConfig_Protocol(temp)
		result.Protocol = &protocol
	}

	// Set property "TimeoutInSeconds":
	if config.TimeoutInSeconds != nil {
		timeoutInSeconds := *config.TimeoutInSeconds
		result.TimeoutInSeconds = &timeoutInSeconds
	}

	// Set property "ToleratedNumberOfFailures":
	if config.ToleratedNumberOfFailures != nil {
		toleratedNumberOfFailures := *config.ToleratedNumberOfFailures
		result.ToleratedNumberOfFailures = &toleratedNumberOfFailures
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *MonitorConfig) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.MonitorConfig{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *MonitorConfig) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.MonitorConfig)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.MonitorConfig, got %T", armInput)
	}

	// Set property "CustomHeaders":
	for _, item := range typedInput.CustomHeaders {
		var item1 MonitorConfig_CustomHeaders
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.CustomHeaders = append(config.CustomHeaders, item1)
	}

	// Set property "ExpectedStatusCodeRanges":
	for _, item := range typedInput.ExpectedStatusCodeRanges {
		var item1 MonitorConfig_ExpectedStatusCodeRanges
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.ExpectedStatusCodeRanges = append(config.ExpectedStatusCodeRanges, item1)
	}

	// Set property "IntervalInSeconds":
	if typedInput.IntervalInSeconds != nil {
		intervalInSeconds := *typedInput.IntervalInSeconds
		config.IntervalInSeconds = &intervalInSeconds
	}

	// Set property "Path":
	if typedInput.Path != nil {
		path := *typedInput.Path
		config.Path = &path
	}

	// Set property "Port":
	if typedInput.Port != nil {
		port := *typedInput.Port
		config.Port = &port
	}

	// Set property "ProfileMonitorStatus":
	if typedInput.ProfileMonitorStatus != nil {
		var temp string
		temp = string(*typedInput.ProfileMonitorStatus)
		profileMonitorStatus := MonitorConfig_ProfileMonitorStatus(temp)
		config.ProfileMonitorStatus = &profileMonitorStatus
	}

	// Set property "Protocol":
	if typedInput.Protocol != nil {
		var temp string
		temp = string(*typedInput.Protocol)
		protocol := MonitorConfig_Protocol(temp)
		config.Protocol = &protocol
	}

	// Set property "TimeoutInSeconds":
	if typedInput.TimeoutInSeconds != nil {
		timeoutInSeconds := *typedInput.TimeoutInSeconds
		config.TimeoutInSeconds = &timeoutInSeconds
	}

	// Set property "ToleratedNumberOfFailures":
	if typedInput.ToleratedNumberOfFailures != nil {
		toleratedNumberOfFailures := *typedInput.ToleratedNumberOfFailures
		config.ToleratedNumberOfFailures = &toleratedNumberOfFailures
	}

	// No error
	return nil
}

// AssignProperties_From_MonitorConfig populates our MonitorConfig from the provided source MonitorConfig
func (config *MonitorConfig) AssignProperties_From_MonitorConfig(source *storage.MonitorConfig) error {

	// CustomHeaders
	if source.CustomHeaders != nil {
		customHeaderList := make([]MonitorConfig_CustomHeaders, len(source.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range source.CustomHeaders {
			// Shadow the loop variable to avoid aliasing
			customHeaderItem := customHeaderItem
			var customHeader MonitorConfig_CustomHeaders
			err := customHeader.AssignProperties_From_MonitorConfig_CustomHeaders(&customHeaderItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_MonitorConfig_CustomHeaders() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		config.CustomHeaders = customHeaderList
	} else {
		config.CustomHeaders = nil
	}

	// ExpectedStatusCodeRanges
	if source.ExpectedStatusCodeRanges != nil {
		expectedStatusCodeRangeList := make([]MonitorConfig_ExpectedStatusCodeRanges, len(source.ExpectedStatusCodeRanges))
		for expectedStatusCodeRangeIndex, expectedStatusCodeRangeItem := range source.ExpectedStatusCodeRanges {
			// Shadow the loop variable to avoid aliasing
			expectedStatusCodeRangeItem := expectedStatusCodeRangeItem
			var expectedStatusCodeRange MonitorConfig_ExpectedStatusCodeRanges
			err := expectedStatusCodeRange.AssignProperties_From_MonitorConfig_ExpectedStatusCodeRanges(&expectedStatusCodeRangeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_MonitorConfig_ExpectedStatusCodeRanges() to populate field ExpectedStatusCodeRanges")
			}
			expectedStatusCodeRangeList[expectedStatusCodeRangeIndex] = expectedStatusCodeRange
		}
		config.ExpectedStatusCodeRanges = expectedStatusCodeRangeList
	} else {
		config.ExpectedStatusCodeRanges = nil
	}

	// IntervalInSeconds
	config.IntervalInSeconds = genruntime.ClonePointerToInt(source.IntervalInSeconds)

	// Path
	config.Path = genruntime.ClonePointerToString(source.Path)

	// Port
	config.Port = genruntime.ClonePointerToInt(source.Port)

	// ProfileMonitorStatus
	if source.ProfileMonitorStatus != nil {
		profileMonitorStatus := *source.ProfileMonitorStatus
		profileMonitorStatusTemp := genruntime.ToEnum(profileMonitorStatus, monitorConfig_ProfileMonitorStatus_Values)
		config.ProfileMonitorStatus = &profileMonitorStatusTemp
	} else {
		config.ProfileMonitorStatus = nil
	}

	// Protocol
	if source.Protocol != nil {
		protocol := *source.Protocol
		protocolTemp := genruntime.ToEnum(protocol, monitorConfig_Protocol_Values)
		config.Protocol = &protocolTemp
	} else {
		config.Protocol = nil
	}

	// TimeoutInSeconds
	config.TimeoutInSeconds = genruntime.ClonePointerToInt(source.TimeoutInSeconds)

	// ToleratedNumberOfFailures
	config.ToleratedNumberOfFailures = genruntime.ClonePointerToInt(source.ToleratedNumberOfFailures)

	// No error
	return nil
}

// AssignProperties_To_MonitorConfig populates the provided destination MonitorConfig from our MonitorConfig
func (config *MonitorConfig) AssignProperties_To_MonitorConfig(destination *storage.MonitorConfig) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CustomHeaders
	if config.CustomHeaders != nil {
		customHeaderList := make([]storage.MonitorConfig_CustomHeaders, len(config.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range config.CustomHeaders {
			// Shadow the loop variable to avoid aliasing
			customHeaderItem := customHeaderItem
			var customHeader storage.MonitorConfig_CustomHeaders
			err := customHeaderItem.AssignProperties_To_MonitorConfig_CustomHeaders(&customHeader)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_MonitorConfig_CustomHeaders() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		destination.CustomHeaders = customHeaderList
	} else {
		destination.CustomHeaders = nil
	}

	// ExpectedStatusCodeRanges
	if config.ExpectedStatusCodeRanges != nil {
		expectedStatusCodeRangeList := make([]storage.MonitorConfig_ExpectedStatusCodeRanges, len(config.ExpectedStatusCodeRanges))
		for expectedStatusCodeRangeIndex, expectedStatusCodeRangeItem := range config.ExpectedStatusCodeRanges {
			// Shadow the loop variable to avoid aliasing
			expectedStatusCodeRangeItem := expectedStatusCodeRangeItem
			var expectedStatusCodeRange storage.MonitorConfig_ExpectedStatusCodeRanges
			err := expectedStatusCodeRangeItem.AssignProperties_To_MonitorConfig_ExpectedStatusCodeRanges(&expectedStatusCodeRange)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_MonitorConfig_ExpectedStatusCodeRanges() to populate field ExpectedStatusCodeRanges")
			}
			expectedStatusCodeRangeList[expectedStatusCodeRangeIndex] = expectedStatusCodeRange
		}
		destination.ExpectedStatusCodeRanges = expectedStatusCodeRangeList
	} else {
		destination.ExpectedStatusCodeRanges = nil
	}

	// IntervalInSeconds
	destination.IntervalInSeconds = genruntime.ClonePointerToInt(config.IntervalInSeconds)

	// Path
	destination.Path = genruntime.ClonePointerToString(config.Path)

	// Port
	destination.Port = genruntime.ClonePointerToInt(config.Port)

	// ProfileMonitorStatus
	if config.ProfileMonitorStatus != nil {
		profileMonitorStatus := string(*config.ProfileMonitorStatus)
		destination.ProfileMonitorStatus = &profileMonitorStatus
	} else {
		destination.ProfileMonitorStatus = nil
	}

	// Protocol
	if config.Protocol != nil {
		protocol := string(*config.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// TimeoutInSeconds
	destination.TimeoutInSeconds = genruntime.ClonePointerToInt(config.TimeoutInSeconds)

	// ToleratedNumberOfFailures
	destination.ToleratedNumberOfFailures = genruntime.ClonePointerToInt(config.ToleratedNumberOfFailures)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_MonitorConfig_STATUS populates our MonitorConfig from the provided source MonitorConfig_STATUS
func (config *MonitorConfig) Initialize_From_MonitorConfig_STATUS(source *MonitorConfig_STATUS) error {

	// CustomHeaders
	if source.CustomHeaders != nil {
		customHeaderList := make([]MonitorConfig_CustomHeaders, len(source.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range source.CustomHeaders {
			// Shadow the loop variable to avoid aliasing
			customHeaderItem := customHeaderItem
			var customHeader MonitorConfig_CustomHeaders
			err := customHeader.Initialize_From_MonitorConfig_CustomHeaders_STATUS(&customHeaderItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_MonitorConfig_CustomHeaders_STATUS() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		config.CustomHeaders = customHeaderList
	} else {
		config.CustomHeaders = nil
	}

	// ExpectedStatusCodeRanges
	if source.ExpectedStatusCodeRanges != nil {
		expectedStatusCodeRangeList := make([]MonitorConfig_ExpectedStatusCodeRanges, len(source.ExpectedStatusCodeRanges))
		for expectedStatusCodeRangeIndex, expectedStatusCodeRangeItem := range source.ExpectedStatusCodeRanges {
			// Shadow the loop variable to avoid aliasing
			expectedStatusCodeRangeItem := expectedStatusCodeRangeItem
			var expectedStatusCodeRange MonitorConfig_ExpectedStatusCodeRanges
			err := expectedStatusCodeRange.Initialize_From_MonitorConfig_ExpectedStatusCodeRanges_STATUS(&expectedStatusCodeRangeItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_MonitorConfig_ExpectedStatusCodeRanges_STATUS() to populate field ExpectedStatusCodeRanges")
			}
			expectedStatusCodeRangeList[expectedStatusCodeRangeIndex] = expectedStatusCodeRange
		}
		config.ExpectedStatusCodeRanges = expectedStatusCodeRangeList
	} else {
		config.ExpectedStatusCodeRanges = nil
	}

	// IntervalInSeconds
	config.IntervalInSeconds = genruntime.ClonePointerToInt(source.IntervalInSeconds)

	// Path
	config.Path = genruntime.ClonePointerToString(source.Path)

	// Port
	config.Port = genruntime.ClonePointerToInt(source.Port)

	// ProfileMonitorStatus
	if source.ProfileMonitorStatus != nil {
		profileMonitorStatus := genruntime.ToEnum(string(*source.ProfileMonitorStatus), monitorConfig_ProfileMonitorStatus_Values)
		config.ProfileMonitorStatus = &profileMonitorStatus
	} else {
		config.ProfileMonitorStatus = nil
	}

	// Protocol
	if source.Protocol != nil {
		protocol := genruntime.ToEnum(string(*source.Protocol), monitorConfig_Protocol_Values)
		config.Protocol = &protocol
	} else {
		config.Protocol = nil
	}

	// TimeoutInSeconds
	config.TimeoutInSeconds = genruntime.ClonePointerToInt(source.TimeoutInSeconds)

	// ToleratedNumberOfFailures
	config.ToleratedNumberOfFailures = genruntime.ClonePointerToInt(source.ToleratedNumberOfFailures)

	// No error
	return nil
}

// Class containing endpoint monitoring settings in a Traffic Manager profile.
type MonitorConfig_STATUS struct {
	// CustomHeaders: List of custom headers.
	CustomHeaders []MonitorConfig_CustomHeaders_STATUS `json:"customHeaders,omitempty"`

	// ExpectedStatusCodeRanges: List of expected status code ranges.
	ExpectedStatusCodeRanges []MonitorConfig_ExpectedStatusCodeRanges_STATUS `json:"expectedStatusCodeRanges,omitempty"`

	// IntervalInSeconds: The monitor interval for endpoints in this profile. This is the interval at which Traffic Manager
	// will check the health of each endpoint in this profile.
	IntervalInSeconds *int `json:"intervalInSeconds,omitempty"`

	// Path: The path relative to the endpoint domain name used to probe for endpoint health.
	Path *string `json:"path,omitempty"`

	// Port: The TCP port used to probe for endpoint health.
	Port *int `json:"port,omitempty"`

	// ProfileMonitorStatus: The profile-level monitoring status of the Traffic Manager profile.
	ProfileMonitorStatus *MonitorConfig_ProfileMonitorStatus_STATUS `json:"profileMonitorStatus,omitempty"`

	// Protocol: The protocol (HTTP, HTTPS or TCP) used to probe for endpoint health.
	Protocol *MonitorConfig_Protocol_STATUS `json:"protocol,omitempty"`

	// TimeoutInSeconds: The monitor timeout for endpoints in this profile. This is the time that Traffic Manager allows
	// endpoints in this profile to response to the health check.
	TimeoutInSeconds *int `json:"timeoutInSeconds,omitempty"`

	// ToleratedNumberOfFailures: The number of consecutive failed health check that Traffic Manager tolerates before declaring
	// an endpoint in this profile Degraded after the next failed health check.
	ToleratedNumberOfFailures *int `json:"toleratedNumberOfFailures,omitempty"`
}

var _ genruntime.FromARMConverter = &MonitorConfig_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *MonitorConfig_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.MonitorConfig_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *MonitorConfig_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.MonitorConfig_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.MonitorConfig_STATUS, got %T", armInput)
	}

	// Set property "CustomHeaders":
	for _, item := range typedInput.CustomHeaders {
		var item1 MonitorConfig_CustomHeaders_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.CustomHeaders = append(config.CustomHeaders, item1)
	}

	// Set property "ExpectedStatusCodeRanges":
	for _, item := range typedInput.ExpectedStatusCodeRanges {
		var item1 MonitorConfig_ExpectedStatusCodeRanges_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		config.ExpectedStatusCodeRanges = append(config.ExpectedStatusCodeRanges, item1)
	}

	// Set property "IntervalInSeconds":
	if typedInput.IntervalInSeconds != nil {
		intervalInSeconds := *typedInput.IntervalInSeconds
		config.IntervalInSeconds = &intervalInSeconds
	}

	// Set property "Path":
	if typedInput.Path != nil {
		path := *typedInput.Path
		config.Path = &path
	}

	// Set property "Port":
	if typedInput.Port != nil {
		port := *typedInput.Port
		config.Port = &port
	}

	// Set property "ProfileMonitorStatus":
	if typedInput.ProfileMonitorStatus != nil {
		var temp string
		temp = string(*typedInput.ProfileMonitorStatus)
		profileMonitorStatus := MonitorConfig_ProfileMonitorStatus_STATUS(temp)
		config.ProfileMonitorStatus = &profileMonitorStatus
	}

	// Set property "Protocol":
	if typedInput.Protocol != nil {
		var temp string
		temp = string(*typedInput.Protocol)
		protocol := MonitorConfig_Protocol_STATUS(temp)
		config.Protocol = &protocol
	}

	// Set property "TimeoutInSeconds":
	if typedInput.TimeoutInSeconds != nil {
		timeoutInSeconds := *typedInput.TimeoutInSeconds
		config.TimeoutInSeconds = &timeoutInSeconds
	}

	// Set property "ToleratedNumberOfFailures":
	if typedInput.ToleratedNumberOfFailures != nil {
		toleratedNumberOfFailures := *typedInput.ToleratedNumberOfFailures
		config.ToleratedNumberOfFailures = &toleratedNumberOfFailures
	}

	// No error
	return nil
}

// AssignProperties_From_MonitorConfig_STATUS populates our MonitorConfig_STATUS from the provided source MonitorConfig_STATUS
func (config *MonitorConfig_STATUS) AssignProperties_From_MonitorConfig_STATUS(source *storage.MonitorConfig_STATUS) error {

	// CustomHeaders
	if source.CustomHeaders != nil {
		customHeaderList := make([]MonitorConfig_CustomHeaders_STATUS, len(source.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range source.CustomHeaders {
			// Shadow the loop variable to avoid aliasing
			customHeaderItem := customHeaderItem
			var customHeader MonitorConfig_CustomHeaders_STATUS
			err := customHeader.AssignProperties_From_MonitorConfig_CustomHeaders_STATUS(&customHeaderItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_MonitorConfig_CustomHeaders_STATUS() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		config.CustomHeaders = customHeaderList
	} else {
		config.CustomHeaders = nil
	}

	// ExpectedStatusCodeRanges
	if source.ExpectedStatusCodeRanges != nil {
		expectedStatusCodeRangeList := make([]MonitorConfig_ExpectedStatusCodeRanges_STATUS, len(source.ExpectedStatusCodeRanges))
		for expectedStatusCodeRangeIndex, expectedStatusCodeRangeItem := range source.ExpectedStatusCodeRanges {
			// Shadow the loop variable to avoid aliasing
			expectedStatusCodeRangeItem := expectedStatusCodeRangeItem
			var expectedStatusCodeRange MonitorConfig_ExpectedStatusCodeRanges_STATUS
			err := expectedStatusCodeRange.AssignProperties_From_MonitorConfig_ExpectedStatusCodeRanges_STATUS(&expectedStatusCodeRangeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_MonitorConfig_ExpectedStatusCodeRanges_STATUS() to populate field ExpectedStatusCodeRanges")
			}
			expectedStatusCodeRangeList[expectedStatusCodeRangeIndex] = expectedStatusCodeRange
		}
		config.ExpectedStatusCodeRanges = expectedStatusCodeRangeList
	} else {
		config.ExpectedStatusCodeRanges = nil
	}

	// IntervalInSeconds
	config.IntervalInSeconds = genruntime.ClonePointerToInt(source.IntervalInSeconds)

	// Path
	config.Path = genruntime.ClonePointerToString(source.Path)

	// Port
	config.Port = genruntime.ClonePointerToInt(source.Port)

	// ProfileMonitorStatus
	if source.ProfileMonitorStatus != nil {
		profileMonitorStatus := *source.ProfileMonitorStatus
		profileMonitorStatusTemp := genruntime.ToEnum(profileMonitorStatus, monitorConfig_ProfileMonitorStatus_STATUS_Values)
		config.ProfileMonitorStatus = &profileMonitorStatusTemp
	} else {
		config.ProfileMonitorStatus = nil
	}

	// Protocol
	if source.Protocol != nil {
		protocol := *source.Protocol
		protocolTemp := genruntime.ToEnum(protocol, monitorConfig_Protocol_STATUS_Values)
		config.Protocol = &protocolTemp
	} else {
		config.Protocol = nil
	}

	// TimeoutInSeconds
	config.TimeoutInSeconds = genruntime.ClonePointerToInt(source.TimeoutInSeconds)

	// ToleratedNumberOfFailures
	config.ToleratedNumberOfFailures = genruntime.ClonePointerToInt(source.ToleratedNumberOfFailures)

	// No error
	return nil
}

// AssignProperties_To_MonitorConfig_STATUS populates the provided destination MonitorConfig_STATUS from our MonitorConfig_STATUS
func (config *MonitorConfig_STATUS) AssignProperties_To_MonitorConfig_STATUS(destination *storage.MonitorConfig_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CustomHeaders
	if config.CustomHeaders != nil {
		customHeaderList := make([]storage.MonitorConfig_CustomHeaders_STATUS, len(config.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range config.CustomHeaders {
			// Shadow the loop variable to avoid aliasing
			customHeaderItem := customHeaderItem
			var customHeader storage.MonitorConfig_CustomHeaders_STATUS
			err := customHeaderItem.AssignProperties_To_MonitorConfig_CustomHeaders_STATUS(&customHeader)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_MonitorConfig_CustomHeaders_STATUS() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		destination.CustomHeaders = customHeaderList
	} else {
		destination.CustomHeaders = nil
	}

	// ExpectedStatusCodeRanges
	if config.ExpectedStatusCodeRanges != nil {
		expectedStatusCodeRangeList := make([]storage.MonitorConfig_ExpectedStatusCodeRanges_STATUS, len(config.ExpectedStatusCodeRanges))
		for expectedStatusCodeRangeIndex, expectedStatusCodeRangeItem := range config.ExpectedStatusCodeRanges {
			// Shadow the loop variable to avoid aliasing
			expectedStatusCodeRangeItem := expectedStatusCodeRangeItem
			var expectedStatusCodeRange storage.MonitorConfig_ExpectedStatusCodeRanges_STATUS
			err := expectedStatusCodeRangeItem.AssignProperties_To_MonitorConfig_ExpectedStatusCodeRanges_STATUS(&expectedStatusCodeRange)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_MonitorConfig_ExpectedStatusCodeRanges_STATUS() to populate field ExpectedStatusCodeRanges")
			}
			expectedStatusCodeRangeList[expectedStatusCodeRangeIndex] = expectedStatusCodeRange
		}
		destination.ExpectedStatusCodeRanges = expectedStatusCodeRangeList
	} else {
		destination.ExpectedStatusCodeRanges = nil
	}

	// IntervalInSeconds
	destination.IntervalInSeconds = genruntime.ClonePointerToInt(config.IntervalInSeconds)

	// Path
	destination.Path = genruntime.ClonePointerToString(config.Path)

	// Port
	destination.Port = genruntime.ClonePointerToInt(config.Port)

	// ProfileMonitorStatus
	if config.ProfileMonitorStatus != nil {
		profileMonitorStatus := string(*config.ProfileMonitorStatus)
		destination.ProfileMonitorStatus = &profileMonitorStatus
	} else {
		destination.ProfileMonitorStatus = nil
	}

	// Protocol
	if config.Protocol != nil {
		protocol := string(*config.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// TimeoutInSeconds
	destination.TimeoutInSeconds = genruntime.ClonePointerToInt(config.TimeoutInSeconds)

	// ToleratedNumberOfFailures
	destination.ToleratedNumberOfFailures = genruntime.ClonePointerToInt(config.ToleratedNumberOfFailures)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type ProfileProperties_ProfileStatus string

const (
	ProfileProperties_ProfileStatus_Disabled = ProfileProperties_ProfileStatus("Disabled")
	ProfileProperties_ProfileStatus_Enabled  = ProfileProperties_ProfileStatus("Enabled")
)

// Mapping from string to ProfileProperties_ProfileStatus
var profileProperties_ProfileStatus_Values = map[string]ProfileProperties_ProfileStatus{
	"disabled": ProfileProperties_ProfileStatus_Disabled,
	"enabled":  ProfileProperties_ProfileStatus_Enabled,
}

type ProfileProperties_ProfileStatus_STATUS string

const (
	ProfileProperties_ProfileStatus_STATUS_Disabled = ProfileProperties_ProfileStatus_STATUS("Disabled")
	ProfileProperties_ProfileStatus_STATUS_Enabled  = ProfileProperties_ProfileStatus_STATUS("Enabled")
)

// Mapping from string to ProfileProperties_ProfileStatus_STATUS
var profileProperties_ProfileStatus_STATUS_Values = map[string]ProfileProperties_ProfileStatus_STATUS{
	"disabled": ProfileProperties_ProfileStatus_STATUS_Disabled,
	"enabled":  ProfileProperties_ProfileStatus_STATUS_Enabled,
}

// +kubebuilder:validation:Enum={"Geographic","MultiValue","Performance","Priority","Subnet","Weighted"}
type ProfileProperties_TrafficRoutingMethod string

const (
	ProfileProperties_TrafficRoutingMethod_Geographic  = ProfileProperties_TrafficRoutingMethod("Geographic")
	ProfileProperties_TrafficRoutingMethod_MultiValue  = ProfileProperties_TrafficRoutingMethod("MultiValue")
	ProfileProperties_TrafficRoutingMethod_Performance = ProfileProperties_TrafficRoutingMethod("Performance")
	ProfileProperties_TrafficRoutingMethod_Priority    = ProfileProperties_TrafficRoutingMethod("Priority")
	ProfileProperties_TrafficRoutingMethod_Subnet      = ProfileProperties_TrafficRoutingMethod("Subnet")
	ProfileProperties_TrafficRoutingMethod_Weighted    = ProfileProperties_TrafficRoutingMethod("Weighted")
)

// Mapping from string to ProfileProperties_TrafficRoutingMethod
var profileProperties_TrafficRoutingMethod_Values = map[string]ProfileProperties_TrafficRoutingMethod{
	"geographic":  ProfileProperties_TrafficRoutingMethod_Geographic,
	"multivalue":  ProfileProperties_TrafficRoutingMethod_MultiValue,
	"performance": ProfileProperties_TrafficRoutingMethod_Performance,
	"priority":    ProfileProperties_TrafficRoutingMethod_Priority,
	"subnet":      ProfileProperties_TrafficRoutingMethod_Subnet,
	"weighted":    ProfileProperties_TrafficRoutingMethod_Weighted,
}

type ProfileProperties_TrafficRoutingMethod_STATUS string

const (
	ProfileProperties_TrafficRoutingMethod_STATUS_Geographic  = ProfileProperties_TrafficRoutingMethod_STATUS("Geographic")
	ProfileProperties_TrafficRoutingMethod_STATUS_MultiValue  = ProfileProperties_TrafficRoutingMethod_STATUS("MultiValue")
	ProfileProperties_TrafficRoutingMethod_STATUS_Performance = ProfileProperties_TrafficRoutingMethod_STATUS("Performance")
	ProfileProperties_TrafficRoutingMethod_STATUS_Priority    = ProfileProperties_TrafficRoutingMethod_STATUS("Priority")
	ProfileProperties_TrafficRoutingMethod_STATUS_Subnet      = ProfileProperties_TrafficRoutingMethod_STATUS("Subnet")
	ProfileProperties_TrafficRoutingMethod_STATUS_Weighted    = ProfileProperties_TrafficRoutingMethod_STATUS("Weighted")
)

// Mapping from string to ProfileProperties_TrafficRoutingMethod_STATUS
var profileProperties_TrafficRoutingMethod_STATUS_Values = map[string]ProfileProperties_TrafficRoutingMethod_STATUS{
	"geographic":  ProfileProperties_TrafficRoutingMethod_STATUS_Geographic,
	"multivalue":  ProfileProperties_TrafficRoutingMethod_STATUS_MultiValue,
	"performance": ProfileProperties_TrafficRoutingMethod_STATUS_Performance,
	"priority":    ProfileProperties_TrafficRoutingMethod_STATUS_Priority,
	"subnet":      ProfileProperties_TrafficRoutingMethod_STATUS_Subnet,
	"weighted":    ProfileProperties_TrafficRoutingMethod_STATUS_Weighted,
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type ProfileProperties_TrafficViewEnrollmentStatus string

const (
	ProfileProperties_TrafficViewEnrollmentStatus_Disabled = ProfileProperties_TrafficViewEnrollmentStatus("Disabled")
	ProfileProperties_TrafficViewEnrollmentStatus_Enabled  = ProfileProperties_TrafficViewEnrollmentStatus("Enabled")
)

// Mapping from string to ProfileProperties_TrafficViewEnrollmentStatus
var profileProperties_TrafficViewEnrollmentStatus_Values = map[string]ProfileProperties_TrafficViewEnrollmentStatus{
	"disabled": ProfileProperties_TrafficViewEnrollmentStatus_Disabled,
	"enabled":  ProfileProperties_TrafficViewEnrollmentStatus_Enabled,
}

type ProfileProperties_TrafficViewEnrollmentStatus_STATUS string

const (
	ProfileProperties_TrafficViewEnrollmentStatus_STATUS_Disabled = ProfileProperties_TrafficViewEnrollmentStatus_STATUS("Disabled")
	ProfileProperties_TrafficViewEnrollmentStatus_STATUS_Enabled  = ProfileProperties_TrafficViewEnrollmentStatus_STATUS("Enabled")
)

// Mapping from string to ProfileProperties_TrafficViewEnrollmentStatus_STATUS
var profileProperties_TrafficViewEnrollmentStatus_STATUS_Values = map[string]ProfileProperties_TrafficViewEnrollmentStatus_STATUS{
	"disabled": ProfileProperties_TrafficViewEnrollmentStatus_STATUS_Disabled,
	"enabled":  ProfileProperties_TrafficViewEnrollmentStatus_STATUS_Enabled,
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type TrafficManagerProfileOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// ConfigMaps: configures where to place operator written ConfigMaps.
	ConfigMaps *TrafficManagerProfileOperatorConfigMaps `json:"configMaps,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_TrafficManagerProfileOperatorSpec populates our TrafficManagerProfileOperatorSpec from the provided source TrafficManagerProfileOperatorSpec
func (operator *TrafficManagerProfileOperatorSpec) AssignProperties_From_TrafficManagerProfileOperatorSpec(source *storage.TrafficManagerProfileOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// ConfigMaps
	if source.ConfigMaps != nil {
		var configMap TrafficManagerProfileOperatorConfigMaps
		err := configMap.AssignProperties_From_TrafficManagerProfileOperatorConfigMaps(source.ConfigMaps)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_TrafficManagerProfileOperatorConfigMaps() to populate field ConfigMaps")
		}
		operator.ConfigMaps = &configMap
	} else {
		operator.ConfigMaps = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_TrafficManagerProfileOperatorSpec populates the provided destination TrafficManagerProfileOperatorSpec from our TrafficManagerProfileOperatorSpec
func (operator *TrafficManagerProfileOperatorSpec) AssignProperties_To_TrafficManagerProfileOperatorSpec(destination *storage.TrafficManagerProfileOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// ConfigMaps
	if operator.ConfigMaps != nil {
		var configMap storage.TrafficManagerProfileOperatorConfigMaps
		err := operator.ConfigMaps.AssignProperties_To_TrafficManagerProfileOperatorConfigMaps(&configMap)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_TrafficManagerProfileOperatorConfigMaps() to populate field ConfigMaps")
		}
		destination.ConfigMaps = &configMap
	} else {
		destination.ConfigMaps = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type MonitorConfig_CustomHeaders struct {
	// Name: Header name.
	Name *string `json:"name,omitempty"`

	// Value: Header value.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &MonitorConfig_CustomHeaders{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (headers *MonitorConfig_CustomHeaders) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if headers == nil {
		return nil, nil
	}
	result := &arm.MonitorConfig_CustomHeaders{}

	// Set property "Name":
	if headers.Name != nil {
		name := *headers.Name
		result.Name = &name
	}

	// Set property "Value":
	if headers.Value != nil {
		value := *headers.Value
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (headers *MonitorConfig_CustomHeaders) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.MonitorConfig_CustomHeaders{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (headers *MonitorConfig_CustomHeaders) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.MonitorConfig_CustomHeaders)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.MonitorConfig_CustomHeaders, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		headers.Name = &name
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		headers.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_MonitorConfig_CustomHeaders populates our MonitorConfig_CustomHeaders from the provided source MonitorConfig_CustomHeaders
func (headers *MonitorConfig_CustomHeaders) AssignProperties_From_MonitorConfig_CustomHeaders(source *storage.MonitorConfig_CustomHeaders) error {

	// Name
	headers.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	headers.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_MonitorConfig_CustomHeaders populates the provided destination MonitorConfig_CustomHeaders from our MonitorConfig_CustomHeaders
func (headers *MonitorConfig_CustomHeaders) AssignProperties_To_MonitorConfig_CustomHeaders(destination *storage.MonitorConfig_CustomHeaders) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(headers.Name)

	// Value
	destination.Value = genruntime.ClonePointerToString(headers.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_MonitorConfig_CustomHeaders_STATUS populates our MonitorConfig_CustomHeaders from the provided source MonitorConfig_CustomHeaders_STATUS
func (headers *MonitorConfig_CustomHeaders) Initialize_From_MonitorConfig_CustomHeaders_STATUS(source *MonitorConfig_CustomHeaders_STATUS) error {

	// Name
	headers.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	headers.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

type MonitorConfig_CustomHeaders_STATUS struct {
	// Name: Header name.
	Name *string `json:"name,omitempty"`

	// Value: Header value.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &MonitorConfig_CustomHeaders_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (headers *MonitorConfig_CustomHeaders_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.MonitorConfig_CustomHeaders_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (headers *MonitorConfig_CustomHeaders_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.MonitorConfig_CustomHeaders_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.MonitorConfig_CustomHeaders_STATUS, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		headers.Name = &name
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		headers.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_MonitorConfig_CustomHeaders_STATUS populates our MonitorConfig_CustomHeaders_STATUS from the provided source MonitorConfig_CustomHeaders_STATUS
func (headers *MonitorConfig_CustomHeaders_STATUS) AssignProperties_From_MonitorConfig_CustomHeaders_STATUS(source *storage.MonitorConfig_CustomHeaders_STATUS) error {

	// Name
	headers.Name = genruntime.ClonePointerToString(source.Name)

	// Value
	headers.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_MonitorConfig_CustomHeaders_STATUS populates the provided destination MonitorConfig_CustomHeaders_STATUS from our MonitorConfig_CustomHeaders_STATUS
func (headers *MonitorConfig_CustomHeaders_STATUS) AssignProperties_To_MonitorConfig_CustomHeaders_STATUS(destination *storage.MonitorConfig_CustomHeaders_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(headers.Name)

	// Value
	destination.Value = genruntime.ClonePointerToString(headers.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type MonitorConfig_ExpectedStatusCodeRanges struct {
	// Max: Max status code.
	Max *int `json:"max,omitempty"`

	// Min: Min status code.
	Min *int `json:"min,omitempty"`
}

var _ genruntime.ARMTransformer = &MonitorConfig_ExpectedStatusCodeRanges{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (ranges *MonitorConfig_ExpectedStatusCodeRanges) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if ranges == nil {
		return nil, nil
	}
	result := &arm.MonitorConfig_ExpectedStatusCodeRanges{}

	// Set property "Max":
	if ranges.Max != nil {
		max := *ranges.Max
		result.Max = &max
	}

	// Set property "Min":
	if ranges.Min != nil {
		min := *ranges.Min
		result.Min = &min
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (ranges *MonitorConfig_ExpectedStatusCodeRanges) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.MonitorConfig_ExpectedStatusCodeRanges{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (ranges *MonitorConfig_ExpectedStatusCodeRanges) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.MonitorConfig_ExpectedStatusCodeRanges)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.MonitorConfig_ExpectedStatusCodeRanges, got %T", armInput)
	}

	// Set property "Max":
	if typedInput.Max != nil {
		max := *typedInput.Max
		ranges.Max = &max
	}

	// Set property "Min":
	if typedInput.Min != nil {
		min := *typedInput.Min
		ranges.Min = &min
	}

	// No error
	return nil
}

// AssignProperties_From_MonitorConfig_ExpectedStatusCodeRanges populates our MonitorConfig_ExpectedStatusCodeRanges from the provided source MonitorConfig_ExpectedStatusCodeRanges
func (ranges *MonitorConfig_ExpectedStatusCodeRanges) AssignProperties_From_MonitorConfig_ExpectedStatusCodeRanges(source *storage.MonitorConfig_ExpectedStatusCodeRanges) error {

	// Max
	ranges.Max = genruntime.ClonePointerToInt(source.Max)

	// Min
	ranges.Min = genruntime.ClonePointerToInt(source.Min)

	// No error
	return nil
}

// AssignProperties_To_MonitorConfig_ExpectedStatusCodeRanges populates the provided destination MonitorConfig_ExpectedStatusCodeRanges from our MonitorConfig_ExpectedStatusCodeRanges
func (ranges *MonitorConfig_ExpectedStatusCodeRanges) AssignProperties_To_MonitorConfig_ExpectedStatusCodeRanges(destination *storage.MonitorConfig_ExpectedStatusCodeRanges) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Max
	destination.Max = genruntime.ClonePointerToInt(ranges.Max)

	// Min
	destination.Min = genruntime.ClonePointerToInt(ranges.Min)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_MonitorConfig_ExpectedStatusCodeRanges_STATUS populates our MonitorConfig_ExpectedStatusCodeRanges from the provided source MonitorConfig_ExpectedStatusCodeRanges_STATUS
func (ranges *MonitorConfig_ExpectedStatusCodeRanges) Initialize_From_MonitorConfig_ExpectedStatusCodeRanges_STATUS(source *MonitorConfig_ExpectedStatusCodeRanges_STATUS) error {

	// Max
	ranges.Max = genruntime.ClonePointerToInt(source.Max)

	// Min
	ranges.Min = genruntime.ClonePointerToInt(source.Min)

	// No error
	return nil
}

type MonitorConfig_ExpectedStatusCodeRanges_STATUS struct {
	// Max: Max status code.
	Max *int `json:"max,omitempty"`

	// Min: Min status code.
	Min *int `json:"min,omitempty"`
}

var _ genruntime.FromARMConverter = &MonitorConfig_ExpectedStatusCodeRanges_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (ranges *MonitorConfig_ExpectedStatusCodeRanges_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.MonitorConfig_ExpectedStatusCodeRanges_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (ranges *MonitorConfig_ExpectedStatusCodeRanges_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.MonitorConfig_ExpectedStatusCodeRanges_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.MonitorConfig_ExpectedStatusCodeRanges_STATUS, got %T", armInput)
	}

	// Set property "Max":
	if typedInput.Max != nil {
		max := *typedInput.Max
		ranges.Max = &max
	}

	// Set property "Min":
	if typedInput.Min != nil {
		min := *typedInput.Min
		ranges.Min = &min
	}

	// No error
	return nil
}

// AssignProperties_From_MonitorConfig_ExpectedStatusCodeRanges_STATUS populates our MonitorConfig_ExpectedStatusCodeRanges_STATUS from the provided source MonitorConfig_ExpectedStatusCodeRanges_STATUS
func (ranges *MonitorConfig_ExpectedStatusCodeRanges_STATUS) AssignProperties_From_MonitorConfig_ExpectedStatusCodeRanges_STATUS(source *storage.MonitorConfig_ExpectedStatusCodeRanges_STATUS) error {

	// Max
	ranges.Max = genruntime.ClonePointerToInt(source.Max)

	// Min
	ranges.Min = genruntime.ClonePointerToInt(source.Min)

	// No error
	return nil
}

// AssignProperties_To_MonitorConfig_ExpectedStatusCodeRanges_STATUS populates the provided destination MonitorConfig_ExpectedStatusCodeRanges_STATUS from our MonitorConfig_ExpectedStatusCodeRanges_STATUS
func (ranges *MonitorConfig_ExpectedStatusCodeRanges_STATUS) AssignProperties_To_MonitorConfig_ExpectedStatusCodeRanges_STATUS(destination *storage.MonitorConfig_ExpectedStatusCodeRanges_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Max
	destination.Max = genruntime.ClonePointerToInt(ranges.Max)

	// Min
	destination.Min = genruntime.ClonePointerToInt(ranges.Min)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"CheckingEndpoints","Degraded","Disabled","Inactive","Online"}
type MonitorConfig_ProfileMonitorStatus string

const (
	MonitorConfig_ProfileMonitorStatus_CheckingEndpoints = MonitorConfig_ProfileMonitorStatus("CheckingEndpoints")
	MonitorConfig_ProfileMonitorStatus_Degraded          = MonitorConfig_ProfileMonitorStatus("Degraded")
	MonitorConfig_ProfileMonitorStatus_Disabled          = MonitorConfig_ProfileMonitorStatus("Disabled")
	MonitorConfig_ProfileMonitorStatus_Inactive          = MonitorConfig_ProfileMonitorStatus("Inactive")
	MonitorConfig_ProfileMonitorStatus_Online            = MonitorConfig_ProfileMonitorStatus("Online")
)

// Mapping from string to MonitorConfig_ProfileMonitorStatus
var monitorConfig_ProfileMonitorStatus_Values = map[string]MonitorConfig_ProfileMonitorStatus{
	"checkingendpoints": MonitorConfig_ProfileMonitorStatus_CheckingEndpoints,
	"degraded":          MonitorConfig_ProfileMonitorStatus_Degraded,
	"disabled":          MonitorConfig_ProfileMonitorStatus_Disabled,
	"inactive":          MonitorConfig_ProfileMonitorStatus_Inactive,
	"online":            MonitorConfig_ProfileMonitorStatus_Online,
}

type MonitorConfig_ProfileMonitorStatus_STATUS string

const (
	MonitorConfig_ProfileMonitorStatus_STATUS_CheckingEndpoints = MonitorConfig_ProfileMonitorStatus_STATUS("CheckingEndpoints")
	MonitorConfig_ProfileMonitorStatus_STATUS_Degraded          = MonitorConfig_ProfileMonitorStatus_STATUS("Degraded")
	MonitorConfig_ProfileMonitorStatus_STATUS_Disabled          = MonitorConfig_ProfileMonitorStatus_STATUS("Disabled")
	MonitorConfig_ProfileMonitorStatus_STATUS_Inactive          = MonitorConfig_ProfileMonitorStatus_STATUS("Inactive")
	MonitorConfig_ProfileMonitorStatus_STATUS_Online            = MonitorConfig_ProfileMonitorStatus_STATUS("Online")
)

// Mapping from string to MonitorConfig_ProfileMonitorStatus_STATUS
var monitorConfig_ProfileMonitorStatus_STATUS_Values = map[string]MonitorConfig_ProfileMonitorStatus_STATUS{
	"checkingendpoints": MonitorConfig_ProfileMonitorStatus_STATUS_CheckingEndpoints,
	"degraded":          MonitorConfig_ProfileMonitorStatus_STATUS_Degraded,
	"disabled":          MonitorConfig_ProfileMonitorStatus_STATUS_Disabled,
	"inactive":          MonitorConfig_ProfileMonitorStatus_STATUS_Inactive,
	"online":            MonitorConfig_ProfileMonitorStatus_STATUS_Online,
}

// +kubebuilder:validation:Enum={"HTTP","HTTPS","TCP"}
type MonitorConfig_Protocol string

const (
	MonitorConfig_Protocol_HTTP  = MonitorConfig_Protocol("HTTP")
	MonitorConfig_Protocol_HTTPS = MonitorConfig_Protocol("HTTPS")
	MonitorConfig_Protocol_TCP   = MonitorConfig_Protocol("TCP")
)

// Mapping from string to MonitorConfig_Protocol
var monitorConfig_Protocol_Values = map[string]MonitorConfig_Protocol{
	"http":  MonitorConfig_Protocol_HTTP,
	"https": MonitorConfig_Protocol_HTTPS,
	"tcp":   MonitorConfig_Protocol_TCP,
}

type MonitorConfig_Protocol_STATUS string

const (
	MonitorConfig_Protocol_STATUS_HTTP  = MonitorConfig_Protocol_STATUS("HTTP")
	MonitorConfig_Protocol_STATUS_HTTPS = MonitorConfig_Protocol_STATUS("HTTPS")
	MonitorConfig_Protocol_STATUS_TCP   = MonitorConfig_Protocol_STATUS("TCP")
)

// Mapping from string to MonitorConfig_Protocol_STATUS
var monitorConfig_Protocol_STATUS_Values = map[string]MonitorConfig_Protocol_STATUS{
	"http":  MonitorConfig_Protocol_STATUS_HTTP,
	"https": MonitorConfig_Protocol_STATUS_HTTPS,
	"tcp":   MonitorConfig_Protocol_STATUS_TCP,
}

type TrafficManagerProfileOperatorConfigMaps struct {
	// DnsConfigFqdn: indicates where the DnsConfigFqdn config map should be placed. If omitted, no config map will be created.
	DnsConfigFqdn *genruntime.ConfigMapDestination `json:"dnsConfigFqdn,omitempty"`
}

// AssignProperties_From_TrafficManagerProfileOperatorConfigMaps populates our TrafficManagerProfileOperatorConfigMaps from the provided source TrafficManagerProfileOperatorConfigMaps
func (maps *TrafficManagerProfileOperatorConfigMaps) AssignProperties_From_TrafficManagerProfileOperatorConfigMaps(source *storage.TrafficManagerProfileOperatorConfigMaps) error {

	// DnsConfigFqdn
	if source.DnsConfigFqdn != nil {
		dnsConfigFqdn := source.DnsConfigFqdn.Copy()
		maps.DnsConfigFqdn = &dnsConfigFqdn
	} else {
		maps.DnsConfigFqdn = nil
	}

	// No error
	return nil
}

// AssignProperties_To_TrafficManagerProfileOperatorConfigMaps populates the provided destination TrafficManagerProfileOperatorConfigMaps from our TrafficManagerProfileOperatorConfigMaps
func (maps *TrafficManagerProfileOperatorConfigMaps) AssignProperties_To_TrafficManagerProfileOperatorConfigMaps(destination *storage.TrafficManagerProfileOperatorConfigMaps) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsConfigFqdn
	if maps.DnsConfigFqdn != nil {
		dnsConfigFqdn := maps.DnsConfigFqdn.Copy()
		destination.DnsConfigFqdn = &dnsConfigFqdn
	} else {
		destination.DnsConfigFqdn = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&TrafficManagerProfile{}, &TrafficManagerProfileList{})
}
