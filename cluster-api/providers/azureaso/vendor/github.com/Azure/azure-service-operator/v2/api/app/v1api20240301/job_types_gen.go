// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20240301

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/app/v1api20240301/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/app/v1api20240301/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/rotisserie/eris"
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /app/resource-manager/Microsoft.App/stable/2024-03-01/Jobs.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/jobs/{jobName}
type Job struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              Job_Spec   `json:"spec,omitempty"`
	Status            Job_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &Job{}

// GetConditions returns the conditions of the resource
func (job *Job) GetConditions() conditions.Conditions {
	return job.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (job *Job) SetConditions(conditions conditions.Conditions) { job.Status.Conditions = conditions }

var _ conversion.Convertible = &Job{}

// ConvertFrom populates our Job from the provided hub Job
func (job *Job) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.Job)
	if !ok {
		return fmt.Errorf("expected app/v1api20240301/storage/Job but received %T instead", hub)
	}

	return job.AssignProperties_From_Job(source)
}

// ConvertTo populates the provided hub Job from our Job
func (job *Job) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.Job)
	if !ok {
		return fmt.Errorf("expected app/v1api20240301/storage/Job but received %T instead", hub)
	}

	return job.AssignProperties_To_Job(destination)
}

var _ configmaps.Exporter = &Job{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (job *Job) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if job.Spec.OperatorSpec == nil {
		return nil
	}
	return job.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &Job{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (job *Job) SecretDestinationExpressions() []*core.DestinationExpression {
	if job.Spec.OperatorSpec == nil {
		return nil
	}
	return job.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &Job{}

// InitializeSpec initializes the spec for this resource from the given status
func (job *Job) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*Job_STATUS); ok {
		return job.Spec.Initialize_From_Job_STATUS(s)
	}

	return fmt.Errorf("expected Status of type Job_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &Job{}

// AzureName returns the Azure name of the resource
func (job *Job) AzureName() string {
	return job.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2024-03-01"
func (job Job) GetAPIVersion() string {
	return "2024-03-01"
}

// GetResourceScope returns the scope of the resource
func (job *Job) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (job *Job) GetSpec() genruntime.ConvertibleSpec {
	return &job.Spec
}

// GetStatus returns the status of this resource
func (job *Job) GetStatus() genruntime.ConvertibleStatus {
	return &job.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (job *Job) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.App/jobs"
func (job *Job) GetType() string {
	return "Microsoft.App/jobs"
}

// NewEmptyStatus returns a new empty (blank) status
func (job *Job) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &Job_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (job *Job) Owner() *genruntime.ResourceReference {
	if job.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(job.Spec)
	return job.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (job *Job) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*Job_STATUS); ok {
		job.Status = *st
		return nil
	}

	// Convert status to required version
	var st Job_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	job.Status = st
	return nil
}

// AssignProperties_From_Job populates our Job from the provided source Job
func (job *Job) AssignProperties_From_Job(source *storage.Job) error {

	// ObjectMeta
	job.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec Job_Spec
	err := spec.AssignProperties_From_Job_Spec(&source.Spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_Job_Spec() to populate field Spec")
	}
	job.Spec = spec

	// Status
	var status Job_STATUS
	err = status.AssignProperties_From_Job_STATUS(&source.Status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_Job_STATUS() to populate field Status")
	}
	job.Status = status

	// No error
	return nil
}

// AssignProperties_To_Job populates the provided destination Job from our Job
func (job *Job) AssignProperties_To_Job(destination *storage.Job) error {

	// ObjectMeta
	destination.ObjectMeta = *job.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.Job_Spec
	err := job.Spec.AssignProperties_To_Job_Spec(&spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_Job_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.Job_STATUS
	err = job.Status.AssignProperties_To_Job_STATUS(&status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_Job_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (job *Job) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: job.Spec.OriginalVersion(),
		Kind:    "Job",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /app/resource-manager/Microsoft.App/stable/2024-03-01/Jobs.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/jobs/{jobName}
type JobList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Job `json:"items"`
}

type Job_Spec struct {
	// +kubebuilder:validation:Pattern="^[-\\w\\._\\(\\)]+$"
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// Configuration: Container Apps Job configuration properties.
	Configuration *JobConfiguration `json:"configuration,omitempty"`

	// EnvironmentReference: Resource ID of environment.
	EnvironmentReference *genruntime.ResourceReference `armReference:"EnvironmentId" json:"environmentReference,omitempty"`

	// Identity: Managed identities needed by a container app job to interact with other Azure services to not maintain any
	// secrets or credentials in code.
	Identity *ManagedServiceIdentity `json:"identity,omitempty"`

	// +kubebuilder:validation:Required
	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *JobOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Template: Container Apps job definition.
	Template *JobTemplate `json:"template,omitempty"`

	// WorkloadProfileName: Workload profile name to pin for container apps job execution.
	WorkloadProfileName *string `json:"workloadProfileName,omitempty"`
}

var _ genruntime.ARMTransformer = &Job_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (job *Job_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if job == nil {
		return nil, nil
	}
	result := &arm.Job_Spec{}

	// Set property "Identity":
	if job.Identity != nil {
		identity_ARM, err := (*job.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*arm.ManagedServiceIdentity)
		result.Identity = &identity
	}

	// Set property "Location":
	if job.Location != nil {
		location := *job.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if job.Configuration != nil ||
		job.EnvironmentReference != nil ||
		job.Template != nil ||
		job.WorkloadProfileName != nil {
		result.Properties = &arm.Job_Properties_Spec{}
	}
	if job.Configuration != nil {
		configuration_ARM, err := (*job.Configuration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		configuration := *configuration_ARM.(*arm.JobConfiguration)
		result.Properties.Configuration = &configuration
	}
	if job.EnvironmentReference != nil {
		environmentIdARMID, err := resolved.ResolvedReferences.Lookup(*job.EnvironmentReference)
		if err != nil {
			return nil, err
		}
		environmentId := environmentIdARMID
		result.Properties.EnvironmentId = &environmentId
	}
	if job.Template != nil {
		template_ARM, err := (*job.Template).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		template := *template_ARM.(*arm.JobTemplate)
		result.Properties.Template = &template
	}
	if job.WorkloadProfileName != nil {
		workloadProfileName := *job.WorkloadProfileName
		result.Properties.WorkloadProfileName = &workloadProfileName
	}

	// Set property "Tags":
	if job.Tags != nil {
		result.Tags = make(map[string]string, len(job.Tags))
		for key, value := range job.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (job *Job_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Job_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (job *Job_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Job_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Job_Spec, got %T", armInput)
	}

	// Set property "AzureName":
	job.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "Configuration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Configuration != nil {
			var configuration1 JobConfiguration
			err := configuration1.PopulateFromARM(owner, *typedInput.Properties.Configuration)
			if err != nil {
				return err
			}
			configuration := configuration1
			job.Configuration = &configuration
		}
	}

	// no assignment for property "EnvironmentReference"

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedServiceIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		job.Identity = &identity
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		job.Location = &location
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	job.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		job.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			job.Tags[key] = value
		}
	}

	// Set property "Template":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Template != nil {
			var template1 JobTemplate
			err := template1.PopulateFromARM(owner, *typedInput.Properties.Template)
			if err != nil {
				return err
			}
			template := template1
			job.Template = &template
		}
	}

	// Set property "WorkloadProfileName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.WorkloadProfileName != nil {
			workloadProfileName := *typedInput.Properties.WorkloadProfileName
			job.WorkloadProfileName = &workloadProfileName
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &Job_Spec{}

// ConvertSpecFrom populates our Job_Spec from the provided source
func (job *Job_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.Job_Spec)
	if ok {
		// Populate our instance from source
		return job.AssignProperties_From_Job_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.Job_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = job.AssignProperties_From_Job_Spec(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our Job_Spec
func (job *Job_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.Job_Spec)
	if ok {
		// Populate destination from our instance
		return job.AssignProperties_To_Job_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.Job_Spec{}
	err := job.AssignProperties_To_Job_Spec(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_Job_Spec populates our Job_Spec from the provided source Job_Spec
func (job *Job_Spec) AssignProperties_From_Job_Spec(source *storage.Job_Spec) error {

	// AzureName
	job.AzureName = source.AzureName

	// Configuration
	if source.Configuration != nil {
		var configuration JobConfiguration
		err := configuration.AssignProperties_From_JobConfiguration(source.Configuration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_JobConfiguration() to populate field Configuration")
		}
		job.Configuration = &configuration
	} else {
		job.Configuration = nil
	}

	// EnvironmentReference
	if source.EnvironmentReference != nil {
		environmentReference := source.EnvironmentReference.Copy()
		job.EnvironmentReference = &environmentReference
	} else {
		job.EnvironmentReference = nil
	}

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity
		err := identity.AssignProperties_From_ManagedServiceIdentity(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity() to populate field Identity")
		}
		job.Identity = &identity
	} else {
		job.Identity = nil
	}

	// Location
	job.Location = genruntime.ClonePointerToString(source.Location)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec JobOperatorSpec
		err := operatorSpec.AssignProperties_From_JobOperatorSpec(source.OperatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_JobOperatorSpec() to populate field OperatorSpec")
		}
		job.OperatorSpec = &operatorSpec
	} else {
		job.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		job.Owner = &owner
	} else {
		job.Owner = nil
	}

	// Tags
	job.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Template
	if source.Template != nil {
		var template JobTemplate
		err := template.AssignProperties_From_JobTemplate(source.Template)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_JobTemplate() to populate field Template")
		}
		job.Template = &template
	} else {
		job.Template = nil
	}

	// WorkloadProfileName
	job.WorkloadProfileName = genruntime.ClonePointerToString(source.WorkloadProfileName)

	// No error
	return nil
}

// AssignProperties_To_Job_Spec populates the provided destination Job_Spec from our Job_Spec
func (job *Job_Spec) AssignProperties_To_Job_Spec(destination *storage.Job_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = job.AzureName

	// Configuration
	if job.Configuration != nil {
		var configuration storage.JobConfiguration
		err := job.Configuration.AssignProperties_To_JobConfiguration(&configuration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_JobConfiguration() to populate field Configuration")
		}
		destination.Configuration = &configuration
	} else {
		destination.Configuration = nil
	}

	// EnvironmentReference
	if job.EnvironmentReference != nil {
		environmentReference := job.EnvironmentReference.Copy()
		destination.EnvironmentReference = &environmentReference
	} else {
		destination.EnvironmentReference = nil
	}

	// Identity
	if job.Identity != nil {
		var identity storage.ManagedServiceIdentity
		err := job.Identity.AssignProperties_To_ManagedServiceIdentity(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(job.Location)

	// OperatorSpec
	if job.OperatorSpec != nil {
		var operatorSpec storage.JobOperatorSpec
		err := job.OperatorSpec.AssignProperties_To_JobOperatorSpec(&operatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_JobOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = job.OriginalVersion()

	// Owner
	if job.Owner != nil {
		owner := job.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(job.Tags)

	// Template
	if job.Template != nil {
		var template storage.JobTemplate
		err := job.Template.AssignProperties_To_JobTemplate(&template)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_JobTemplate() to populate field Template")
		}
		destination.Template = &template
	} else {
		destination.Template = nil
	}

	// WorkloadProfileName
	destination.WorkloadProfileName = genruntime.ClonePointerToString(job.WorkloadProfileName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Job_STATUS populates our Job_Spec from the provided source Job_STATUS
func (job *Job_Spec) Initialize_From_Job_STATUS(source *Job_STATUS) error {

	// Configuration
	if source.Configuration != nil {
		var configuration JobConfiguration
		err := configuration.Initialize_From_JobConfiguration_STATUS(source.Configuration)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_JobConfiguration_STATUS() to populate field Configuration")
		}
		job.Configuration = &configuration
	} else {
		job.Configuration = nil
	}

	// EnvironmentReference
	if source.EnvironmentId != nil {
		environmentReference := genruntime.CreateResourceReferenceFromARMID(*source.EnvironmentId)
		job.EnvironmentReference = &environmentReference
	} else {
		job.EnvironmentReference = nil
	}

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity
		err := identity.Initialize_From_ManagedServiceIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		job.Identity = &identity
	} else {
		job.Identity = nil
	}

	// Location
	job.Location = genruntime.ClonePointerToString(source.Location)

	// Tags
	job.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Template
	if source.Template != nil {
		var template JobTemplate
		err := template.Initialize_From_JobTemplate_STATUS(source.Template)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_JobTemplate_STATUS() to populate field Template")
		}
		job.Template = &template
	} else {
		job.Template = nil
	}

	// WorkloadProfileName
	job.WorkloadProfileName = genruntime.ClonePointerToString(source.WorkloadProfileName)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (job *Job_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (job *Job_Spec) SetAzureName(azureName string) { job.AzureName = azureName }

// Container App Job
type Job_STATUS struct {
	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// Configuration: Container Apps Job configuration properties.
	Configuration *JobConfiguration_STATUS `json:"configuration,omitempty"`

	// EnvironmentId: Resource ID of environment.
	EnvironmentId *string `json:"environmentId,omitempty"`

	// EventStreamEndpoint: The endpoint of the eventstream of the container apps job.
	EventStreamEndpoint *string `json:"eventStreamEndpoint,omitempty"`

	// Id: Fully qualified resource ID for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`

	// Identity: Managed identities needed by a container app job to interact with other Azure services to not maintain any
	// secrets or credentials in code.
	Identity *ManagedServiceIdentity_STATUS `json:"identity,omitempty"`

	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// OutboundIpAddresses: Outbound IP Addresses of a container apps job.
	OutboundIpAddresses []string `json:"outboundIpAddresses,omitempty"`

	// ProvisioningState: Provisioning state of the Container Apps Job.
	ProvisioningState *Job_Properties_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// SystemData: Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData_STATUS `json:"systemData,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Template: Container Apps job definition.
	Template *JobTemplate_STATUS `json:"template,omitempty"`

	// Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`

	// WorkloadProfileName: Workload profile name to pin for container apps job execution.
	WorkloadProfileName *string `json:"workloadProfileName,omitempty"`
}

var _ genruntime.ConvertibleStatus = &Job_STATUS{}

// ConvertStatusFrom populates our Job_STATUS from the provided source
func (job *Job_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.Job_STATUS)
	if ok {
		// Populate our instance from source
		return job.AssignProperties_From_Job_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.Job_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = job.AssignProperties_From_Job_STATUS(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our Job_STATUS
func (job *Job_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.Job_STATUS)
	if ok {
		// Populate destination from our instance
		return job.AssignProperties_To_Job_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.Job_STATUS{}
	err := job.AssignProperties_To_Job_STATUS(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &Job_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (job *Job_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Job_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (job *Job_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Job_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Job_STATUS, got %T", armInput)
	}

	// no assignment for property "Conditions"

	// Set property "Configuration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Configuration != nil {
			var configuration1 JobConfiguration_STATUS
			err := configuration1.PopulateFromARM(owner, *typedInput.Properties.Configuration)
			if err != nil {
				return err
			}
			configuration := configuration1
			job.Configuration = &configuration
		}
	}

	// Set property "EnvironmentId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnvironmentId != nil {
			environmentId := *typedInput.Properties.EnvironmentId
			job.EnvironmentId = &environmentId
		}
	}

	// Set property "EventStreamEndpoint":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EventStreamEndpoint != nil {
			eventStreamEndpoint := *typedInput.Properties.EventStreamEndpoint
			job.EventStreamEndpoint = &eventStreamEndpoint
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		job.Id = &id
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedServiceIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		job.Identity = &identity
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		job.Location = &location
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		job.Name = &name
	}

	// Set property "OutboundIpAddresses":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.OutboundIpAddresses {
			job.OutboundIpAddresses = append(job.OutboundIpAddresses, item)
		}
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			var temp string
			temp = string(*typedInput.Properties.ProvisioningState)
			provisioningState := Job_Properties_ProvisioningState_STATUS(temp)
			job.ProvisioningState = &provisioningState
		}
	}

	// Set property "SystemData":
	if typedInput.SystemData != nil {
		var systemData1 SystemData_STATUS
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		job.SystemData = &systemData
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		job.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			job.Tags[key] = value
		}
	}

	// Set property "Template":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Template != nil {
			var template1 JobTemplate_STATUS
			err := template1.PopulateFromARM(owner, *typedInput.Properties.Template)
			if err != nil {
				return err
			}
			template := template1
			job.Template = &template
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		job.Type = &typeVar
	}

	// Set property "WorkloadProfileName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.WorkloadProfileName != nil {
			workloadProfileName := *typedInput.Properties.WorkloadProfileName
			job.WorkloadProfileName = &workloadProfileName
		}
	}

	// No error
	return nil
}

// AssignProperties_From_Job_STATUS populates our Job_STATUS from the provided source Job_STATUS
func (job *Job_STATUS) AssignProperties_From_Job_STATUS(source *storage.Job_STATUS) error {

	// Conditions
	job.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// Configuration
	if source.Configuration != nil {
		var configuration JobConfiguration_STATUS
		err := configuration.AssignProperties_From_JobConfiguration_STATUS(source.Configuration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_JobConfiguration_STATUS() to populate field Configuration")
		}
		job.Configuration = &configuration
	} else {
		job.Configuration = nil
	}

	// EnvironmentId
	job.EnvironmentId = genruntime.ClonePointerToString(source.EnvironmentId)

	// EventStreamEndpoint
	job.EventStreamEndpoint = genruntime.ClonePointerToString(source.EventStreamEndpoint)

	// Id
	job.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity_STATUS
		err := identity.AssignProperties_From_ManagedServiceIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		job.Identity = &identity
	} else {
		job.Identity = nil
	}

	// Location
	job.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	job.Name = genruntime.ClonePointerToString(source.Name)

	// OutboundIpAddresses
	job.OutboundIpAddresses = genruntime.CloneSliceOfString(source.OutboundIpAddresses)

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, job_Properties_ProvisioningState_STATUS_Values)
		job.ProvisioningState = &provisioningStateTemp
	} else {
		job.ProvisioningState = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		job.SystemData = &systemDatum
	} else {
		job.SystemData = nil
	}

	// Tags
	job.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Template
	if source.Template != nil {
		var template JobTemplate_STATUS
		err := template.AssignProperties_From_JobTemplate_STATUS(source.Template)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_JobTemplate_STATUS() to populate field Template")
		}
		job.Template = &template
	} else {
		job.Template = nil
	}

	// Type
	job.Type = genruntime.ClonePointerToString(source.Type)

	// WorkloadProfileName
	job.WorkloadProfileName = genruntime.ClonePointerToString(source.WorkloadProfileName)

	// No error
	return nil
}

// AssignProperties_To_Job_STATUS populates the provided destination Job_STATUS from our Job_STATUS
func (job *Job_STATUS) AssignProperties_To_Job_STATUS(destination *storage.Job_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(job.Conditions)

	// Configuration
	if job.Configuration != nil {
		var configuration storage.JobConfiguration_STATUS
		err := job.Configuration.AssignProperties_To_JobConfiguration_STATUS(&configuration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_JobConfiguration_STATUS() to populate field Configuration")
		}
		destination.Configuration = &configuration
	} else {
		destination.Configuration = nil
	}

	// EnvironmentId
	destination.EnvironmentId = genruntime.ClonePointerToString(job.EnvironmentId)

	// EventStreamEndpoint
	destination.EventStreamEndpoint = genruntime.ClonePointerToString(job.EventStreamEndpoint)

	// Id
	destination.Id = genruntime.ClonePointerToString(job.Id)

	// Identity
	if job.Identity != nil {
		var identity storage.ManagedServiceIdentity_STATUS
		err := job.Identity.AssignProperties_To_ManagedServiceIdentity_STATUS(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(job.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(job.Name)

	// OutboundIpAddresses
	destination.OutboundIpAddresses = genruntime.CloneSliceOfString(job.OutboundIpAddresses)

	// ProvisioningState
	if job.ProvisioningState != nil {
		provisioningState := string(*job.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// SystemData
	if job.SystemData != nil {
		var systemDatum storage.SystemData_STATUS
		err := job.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(job.Tags)

	// Template
	if job.Template != nil {
		var template storage.JobTemplate_STATUS
		err := job.Template.AssignProperties_To_JobTemplate_STATUS(&template)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_JobTemplate_STATUS() to populate field Template")
		}
		destination.Template = &template
	} else {
		destination.Template = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(job.Type)

	// WorkloadProfileName
	destination.WorkloadProfileName = genruntime.ClonePointerToString(job.WorkloadProfileName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Job_Properties_ProvisioningState_STATUS string

const (
	Job_Properties_ProvisioningState_STATUS_Canceled   = Job_Properties_ProvisioningState_STATUS("Canceled")
	Job_Properties_ProvisioningState_STATUS_Deleting   = Job_Properties_ProvisioningState_STATUS("Deleting")
	Job_Properties_ProvisioningState_STATUS_Failed     = Job_Properties_ProvisioningState_STATUS("Failed")
	Job_Properties_ProvisioningState_STATUS_InProgress = Job_Properties_ProvisioningState_STATUS("InProgress")
	Job_Properties_ProvisioningState_STATUS_Succeeded  = Job_Properties_ProvisioningState_STATUS("Succeeded")
)

// Mapping from string to Job_Properties_ProvisioningState_STATUS
var job_Properties_ProvisioningState_STATUS_Values = map[string]Job_Properties_ProvisioningState_STATUS{
	"canceled":   Job_Properties_ProvisioningState_STATUS_Canceled,
	"deleting":   Job_Properties_ProvisioningState_STATUS_Deleting,
	"failed":     Job_Properties_ProvisioningState_STATUS_Failed,
	"inprogress": Job_Properties_ProvisioningState_STATUS_InProgress,
	"succeeded":  Job_Properties_ProvisioningState_STATUS_Succeeded,
}

// Non versioned Container Apps Job configuration properties
type JobConfiguration struct {
	// EventTriggerConfig: Trigger configuration of an event driven job.
	EventTriggerConfig *JobConfiguration_EventTriggerConfig `json:"eventTriggerConfig,omitempty"`

	// ManualTriggerConfig: Manual trigger configuration for a single execution job. Properties replicaCompletionCount and
	// parallelism would be set to 1 by default
	ManualTriggerConfig *JobConfiguration_ManualTriggerConfig `json:"manualTriggerConfig,omitempty"`

	// Registries: Collection of private container registry credentials used by a Container apps job
	Registries []RegistryCredentials `json:"registries,omitempty"`

	// ReplicaRetryLimit: Maximum number of retries before failing the job.
	ReplicaRetryLimit *int `json:"replicaRetryLimit,omitempty"`

	// +kubebuilder:validation:Required
	// ReplicaTimeout: Maximum number of seconds a replica is allowed to run.
	ReplicaTimeout *int `json:"replicaTimeout,omitempty"`

	// ScheduleTriggerConfig: Cron formatted repeating trigger schedule ("* * * * *") for cronjobs. Properties completions and
	// parallelism would be set to 1 by default
	ScheduleTriggerConfig *JobConfiguration_ScheduleTriggerConfig `json:"scheduleTriggerConfig,omitempty"`

	// Secrets: Collection of secrets used by a Container Apps Job
	Secrets []Secret `json:"secrets,omitempty"`

	// +kubebuilder:validation:Required
	// TriggerType: Trigger type of the job
	TriggerType *JobConfiguration_TriggerType `json:"triggerType,omitempty"`
}

var _ genruntime.ARMTransformer = &JobConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *JobConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.JobConfiguration{}

	// Set property "EventTriggerConfig":
	if configuration.EventTriggerConfig != nil {
		eventTriggerConfig_ARM, err := (*configuration.EventTriggerConfig).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		eventTriggerConfig := *eventTriggerConfig_ARM.(*arm.JobConfiguration_EventTriggerConfig)
		result.EventTriggerConfig = &eventTriggerConfig
	}

	// Set property "ManualTriggerConfig":
	if configuration.ManualTriggerConfig != nil {
		manualTriggerConfig_ARM, err := (*configuration.ManualTriggerConfig).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		manualTriggerConfig := *manualTriggerConfig_ARM.(*arm.JobConfiguration_ManualTriggerConfig)
		result.ManualTriggerConfig = &manualTriggerConfig
	}

	// Set property "Registries":
	for _, item := range configuration.Registries {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Registries = append(result.Registries, *item_ARM.(*arm.RegistryCredentials))
	}

	// Set property "ReplicaRetryLimit":
	if configuration.ReplicaRetryLimit != nil {
		replicaRetryLimit := *configuration.ReplicaRetryLimit
		result.ReplicaRetryLimit = &replicaRetryLimit
	}

	// Set property "ReplicaTimeout":
	if configuration.ReplicaTimeout != nil {
		replicaTimeout := *configuration.ReplicaTimeout
		result.ReplicaTimeout = &replicaTimeout
	}

	// Set property "ScheduleTriggerConfig":
	if configuration.ScheduleTriggerConfig != nil {
		scheduleTriggerConfig_ARM, err := (*configuration.ScheduleTriggerConfig).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		scheduleTriggerConfig := *scheduleTriggerConfig_ARM.(*arm.JobConfiguration_ScheduleTriggerConfig)
		result.ScheduleTriggerConfig = &scheduleTriggerConfig
	}

	// Set property "Secrets":
	for _, item := range configuration.Secrets {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Secrets = append(result.Secrets, *item_ARM.(*arm.Secret))
	}

	// Set property "TriggerType":
	if configuration.TriggerType != nil {
		var temp string
		temp = string(*configuration.TriggerType)
		triggerType := arm.JobConfiguration_TriggerType(temp)
		result.TriggerType = &triggerType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *JobConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.JobConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *JobConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.JobConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.JobConfiguration, got %T", armInput)
	}

	// Set property "EventTriggerConfig":
	if typedInput.EventTriggerConfig != nil {
		var eventTriggerConfig1 JobConfiguration_EventTriggerConfig
		err := eventTriggerConfig1.PopulateFromARM(owner, *typedInput.EventTriggerConfig)
		if err != nil {
			return err
		}
		eventTriggerConfig := eventTriggerConfig1
		configuration.EventTriggerConfig = &eventTriggerConfig
	}

	// Set property "ManualTriggerConfig":
	if typedInput.ManualTriggerConfig != nil {
		var manualTriggerConfig1 JobConfiguration_ManualTriggerConfig
		err := manualTriggerConfig1.PopulateFromARM(owner, *typedInput.ManualTriggerConfig)
		if err != nil {
			return err
		}
		manualTriggerConfig := manualTriggerConfig1
		configuration.ManualTriggerConfig = &manualTriggerConfig
	}

	// Set property "Registries":
	for _, item := range typedInput.Registries {
		var item1 RegistryCredentials
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		configuration.Registries = append(configuration.Registries, item1)
	}

	// Set property "ReplicaRetryLimit":
	if typedInput.ReplicaRetryLimit != nil {
		replicaRetryLimit := *typedInput.ReplicaRetryLimit
		configuration.ReplicaRetryLimit = &replicaRetryLimit
	}

	// Set property "ReplicaTimeout":
	if typedInput.ReplicaTimeout != nil {
		replicaTimeout := *typedInput.ReplicaTimeout
		configuration.ReplicaTimeout = &replicaTimeout
	}

	// Set property "ScheduleTriggerConfig":
	if typedInput.ScheduleTriggerConfig != nil {
		var scheduleTriggerConfig1 JobConfiguration_ScheduleTriggerConfig
		err := scheduleTriggerConfig1.PopulateFromARM(owner, *typedInput.ScheduleTriggerConfig)
		if err != nil {
			return err
		}
		scheduleTriggerConfig := scheduleTriggerConfig1
		configuration.ScheduleTriggerConfig = &scheduleTriggerConfig
	}

	// Set property "Secrets":
	for _, item := range typedInput.Secrets {
		var item1 Secret
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		configuration.Secrets = append(configuration.Secrets, item1)
	}

	// Set property "TriggerType":
	if typedInput.TriggerType != nil {
		var temp string
		temp = string(*typedInput.TriggerType)
		triggerType := JobConfiguration_TriggerType(temp)
		configuration.TriggerType = &triggerType
	}

	// No error
	return nil
}

// AssignProperties_From_JobConfiguration populates our JobConfiguration from the provided source JobConfiguration
func (configuration *JobConfiguration) AssignProperties_From_JobConfiguration(source *storage.JobConfiguration) error {

	// EventTriggerConfig
	if source.EventTriggerConfig != nil {
		var eventTriggerConfig JobConfiguration_EventTriggerConfig
		err := eventTriggerConfig.AssignProperties_From_JobConfiguration_EventTriggerConfig(source.EventTriggerConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_JobConfiguration_EventTriggerConfig() to populate field EventTriggerConfig")
		}
		configuration.EventTriggerConfig = &eventTriggerConfig
	} else {
		configuration.EventTriggerConfig = nil
	}

	// ManualTriggerConfig
	if source.ManualTriggerConfig != nil {
		var manualTriggerConfig JobConfiguration_ManualTriggerConfig
		err := manualTriggerConfig.AssignProperties_From_JobConfiguration_ManualTriggerConfig(source.ManualTriggerConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_JobConfiguration_ManualTriggerConfig() to populate field ManualTriggerConfig")
		}
		configuration.ManualTriggerConfig = &manualTriggerConfig
	} else {
		configuration.ManualTriggerConfig = nil
	}

	// Registries
	if source.Registries != nil {
		registryList := make([]RegistryCredentials, len(source.Registries))
		for registryIndex, registryItem := range source.Registries {
			// Shadow the loop variable to avoid aliasing
			registryItem := registryItem
			var registry RegistryCredentials
			err := registry.AssignProperties_From_RegistryCredentials(&registryItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_RegistryCredentials() to populate field Registries")
			}
			registryList[registryIndex] = registry
		}
		configuration.Registries = registryList
	} else {
		configuration.Registries = nil
	}

	// ReplicaRetryLimit
	configuration.ReplicaRetryLimit = genruntime.ClonePointerToInt(source.ReplicaRetryLimit)

	// ReplicaTimeout
	configuration.ReplicaTimeout = genruntime.ClonePointerToInt(source.ReplicaTimeout)

	// ScheduleTriggerConfig
	if source.ScheduleTriggerConfig != nil {
		var scheduleTriggerConfig JobConfiguration_ScheduleTriggerConfig
		err := scheduleTriggerConfig.AssignProperties_From_JobConfiguration_ScheduleTriggerConfig(source.ScheduleTriggerConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_JobConfiguration_ScheduleTriggerConfig() to populate field ScheduleTriggerConfig")
		}
		configuration.ScheduleTriggerConfig = &scheduleTriggerConfig
	} else {
		configuration.ScheduleTriggerConfig = nil
	}

	// Secrets
	if source.Secrets != nil {
		secretList := make([]Secret, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret Secret
			err := secret.AssignProperties_From_Secret(&secretItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_Secret() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		configuration.Secrets = secretList
	} else {
		configuration.Secrets = nil
	}

	// TriggerType
	if source.TriggerType != nil {
		triggerType := *source.TriggerType
		triggerTypeTemp := genruntime.ToEnum(triggerType, jobConfiguration_TriggerType_Values)
		configuration.TriggerType = &triggerTypeTemp
	} else {
		configuration.TriggerType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_JobConfiguration populates the provided destination JobConfiguration from our JobConfiguration
func (configuration *JobConfiguration) AssignProperties_To_JobConfiguration(destination *storage.JobConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EventTriggerConfig
	if configuration.EventTriggerConfig != nil {
		var eventTriggerConfig storage.JobConfiguration_EventTriggerConfig
		err := configuration.EventTriggerConfig.AssignProperties_To_JobConfiguration_EventTriggerConfig(&eventTriggerConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_JobConfiguration_EventTriggerConfig() to populate field EventTriggerConfig")
		}
		destination.EventTriggerConfig = &eventTriggerConfig
	} else {
		destination.EventTriggerConfig = nil
	}

	// ManualTriggerConfig
	if configuration.ManualTriggerConfig != nil {
		var manualTriggerConfig storage.JobConfiguration_ManualTriggerConfig
		err := configuration.ManualTriggerConfig.AssignProperties_To_JobConfiguration_ManualTriggerConfig(&manualTriggerConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_JobConfiguration_ManualTriggerConfig() to populate field ManualTriggerConfig")
		}
		destination.ManualTriggerConfig = &manualTriggerConfig
	} else {
		destination.ManualTriggerConfig = nil
	}

	// Registries
	if configuration.Registries != nil {
		registryList := make([]storage.RegistryCredentials, len(configuration.Registries))
		for registryIndex, registryItem := range configuration.Registries {
			// Shadow the loop variable to avoid aliasing
			registryItem := registryItem
			var registry storage.RegistryCredentials
			err := registryItem.AssignProperties_To_RegistryCredentials(&registry)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_RegistryCredentials() to populate field Registries")
			}
			registryList[registryIndex] = registry
		}
		destination.Registries = registryList
	} else {
		destination.Registries = nil
	}

	// ReplicaRetryLimit
	destination.ReplicaRetryLimit = genruntime.ClonePointerToInt(configuration.ReplicaRetryLimit)

	// ReplicaTimeout
	destination.ReplicaTimeout = genruntime.ClonePointerToInt(configuration.ReplicaTimeout)

	// ScheduleTriggerConfig
	if configuration.ScheduleTriggerConfig != nil {
		var scheduleTriggerConfig storage.JobConfiguration_ScheduleTriggerConfig
		err := configuration.ScheduleTriggerConfig.AssignProperties_To_JobConfiguration_ScheduleTriggerConfig(&scheduleTriggerConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_JobConfiguration_ScheduleTriggerConfig() to populate field ScheduleTriggerConfig")
		}
		destination.ScheduleTriggerConfig = &scheduleTriggerConfig
	} else {
		destination.ScheduleTriggerConfig = nil
	}

	// Secrets
	if configuration.Secrets != nil {
		secretList := make([]storage.Secret, len(configuration.Secrets))
		for secretIndex, secretItem := range configuration.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret storage.Secret
			err := secretItem.AssignProperties_To_Secret(&secret)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_Secret() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		destination.Secrets = secretList
	} else {
		destination.Secrets = nil
	}

	// TriggerType
	if configuration.TriggerType != nil {
		triggerType := string(*configuration.TriggerType)
		destination.TriggerType = &triggerType
	} else {
		destination.TriggerType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_JobConfiguration_STATUS populates our JobConfiguration from the provided source JobConfiguration_STATUS
func (configuration *JobConfiguration) Initialize_From_JobConfiguration_STATUS(source *JobConfiguration_STATUS) error {

	// EventTriggerConfig
	if source.EventTriggerConfig != nil {
		var eventTriggerConfig JobConfiguration_EventTriggerConfig
		err := eventTriggerConfig.Initialize_From_JobConfiguration_EventTriggerConfig_STATUS(source.EventTriggerConfig)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_JobConfiguration_EventTriggerConfig_STATUS() to populate field EventTriggerConfig")
		}
		configuration.EventTriggerConfig = &eventTriggerConfig
	} else {
		configuration.EventTriggerConfig = nil
	}

	// ManualTriggerConfig
	if source.ManualTriggerConfig != nil {
		var manualTriggerConfig JobConfiguration_ManualTriggerConfig
		err := manualTriggerConfig.Initialize_From_JobConfiguration_ManualTriggerConfig_STATUS(source.ManualTriggerConfig)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_JobConfiguration_ManualTriggerConfig_STATUS() to populate field ManualTriggerConfig")
		}
		configuration.ManualTriggerConfig = &manualTriggerConfig
	} else {
		configuration.ManualTriggerConfig = nil
	}

	// Registries
	if source.Registries != nil {
		registryList := make([]RegistryCredentials, len(source.Registries))
		for registryIndex, registryItem := range source.Registries {
			// Shadow the loop variable to avoid aliasing
			registryItem := registryItem
			var registry RegistryCredentials
			err := registry.Initialize_From_RegistryCredentials_STATUS(&registryItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_RegistryCredentials_STATUS() to populate field Registries")
			}
			registryList[registryIndex] = registry
		}
		configuration.Registries = registryList
	} else {
		configuration.Registries = nil
	}

	// ReplicaRetryLimit
	configuration.ReplicaRetryLimit = genruntime.ClonePointerToInt(source.ReplicaRetryLimit)

	// ReplicaTimeout
	configuration.ReplicaTimeout = genruntime.ClonePointerToInt(source.ReplicaTimeout)

	// ScheduleTriggerConfig
	if source.ScheduleTriggerConfig != nil {
		var scheduleTriggerConfig JobConfiguration_ScheduleTriggerConfig
		err := scheduleTriggerConfig.Initialize_From_JobConfiguration_ScheduleTriggerConfig_STATUS(source.ScheduleTriggerConfig)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_JobConfiguration_ScheduleTriggerConfig_STATUS() to populate field ScheduleTriggerConfig")
		}
		configuration.ScheduleTriggerConfig = &scheduleTriggerConfig
	} else {
		configuration.ScheduleTriggerConfig = nil
	}

	// Secrets
	if source.Secrets != nil {
		secretList := make([]Secret, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret Secret
			err := secret.Initialize_From_Secret_STATUS(&secretItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_Secret_STATUS() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		configuration.Secrets = secretList
	} else {
		configuration.Secrets = nil
	}

	// TriggerType
	if source.TriggerType != nil {
		triggerType := genruntime.ToEnum(string(*source.TriggerType), jobConfiguration_TriggerType_Values)
		configuration.TriggerType = &triggerType
	} else {
		configuration.TriggerType = nil
	}

	// No error
	return nil
}

// Non versioned Container Apps Job configuration properties
type JobConfiguration_STATUS struct {
	// EventTriggerConfig: Trigger configuration of an event driven job.
	EventTriggerConfig *JobConfiguration_EventTriggerConfig_STATUS `json:"eventTriggerConfig,omitempty"`

	// ManualTriggerConfig: Manual trigger configuration for a single execution job. Properties replicaCompletionCount and
	// parallelism would be set to 1 by default
	ManualTriggerConfig *JobConfiguration_ManualTriggerConfig_STATUS `json:"manualTriggerConfig,omitempty"`

	// Registries: Collection of private container registry credentials used by a Container apps job
	Registries []RegistryCredentials_STATUS `json:"registries,omitempty"`

	// ReplicaRetryLimit: Maximum number of retries before failing the job.
	ReplicaRetryLimit *int `json:"replicaRetryLimit,omitempty"`

	// ReplicaTimeout: Maximum number of seconds a replica is allowed to run.
	ReplicaTimeout *int `json:"replicaTimeout,omitempty"`

	// ScheduleTriggerConfig: Cron formatted repeating trigger schedule ("* * * * *") for cronjobs. Properties completions and
	// parallelism would be set to 1 by default
	ScheduleTriggerConfig *JobConfiguration_ScheduleTriggerConfig_STATUS `json:"scheduleTriggerConfig,omitempty"`

	// Secrets: Collection of secrets used by a Container Apps Job
	Secrets []Secret_STATUS `json:"secrets,omitempty"`

	// TriggerType: Trigger type of the job
	TriggerType *JobConfiguration_TriggerType_STATUS `json:"triggerType,omitempty"`
}

var _ genruntime.FromARMConverter = &JobConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *JobConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.JobConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *JobConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.JobConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.JobConfiguration_STATUS, got %T", armInput)
	}

	// Set property "EventTriggerConfig":
	if typedInput.EventTriggerConfig != nil {
		var eventTriggerConfig1 JobConfiguration_EventTriggerConfig_STATUS
		err := eventTriggerConfig1.PopulateFromARM(owner, *typedInput.EventTriggerConfig)
		if err != nil {
			return err
		}
		eventTriggerConfig := eventTriggerConfig1
		configuration.EventTriggerConfig = &eventTriggerConfig
	}

	// Set property "ManualTriggerConfig":
	if typedInput.ManualTriggerConfig != nil {
		var manualTriggerConfig1 JobConfiguration_ManualTriggerConfig_STATUS
		err := manualTriggerConfig1.PopulateFromARM(owner, *typedInput.ManualTriggerConfig)
		if err != nil {
			return err
		}
		manualTriggerConfig := manualTriggerConfig1
		configuration.ManualTriggerConfig = &manualTriggerConfig
	}

	// Set property "Registries":
	for _, item := range typedInput.Registries {
		var item1 RegistryCredentials_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		configuration.Registries = append(configuration.Registries, item1)
	}

	// Set property "ReplicaRetryLimit":
	if typedInput.ReplicaRetryLimit != nil {
		replicaRetryLimit := *typedInput.ReplicaRetryLimit
		configuration.ReplicaRetryLimit = &replicaRetryLimit
	}

	// Set property "ReplicaTimeout":
	if typedInput.ReplicaTimeout != nil {
		replicaTimeout := *typedInput.ReplicaTimeout
		configuration.ReplicaTimeout = &replicaTimeout
	}

	// Set property "ScheduleTriggerConfig":
	if typedInput.ScheduleTriggerConfig != nil {
		var scheduleTriggerConfig1 JobConfiguration_ScheduleTriggerConfig_STATUS
		err := scheduleTriggerConfig1.PopulateFromARM(owner, *typedInput.ScheduleTriggerConfig)
		if err != nil {
			return err
		}
		scheduleTriggerConfig := scheduleTriggerConfig1
		configuration.ScheduleTriggerConfig = &scheduleTriggerConfig
	}

	// Set property "Secrets":
	for _, item := range typedInput.Secrets {
		var item1 Secret_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		configuration.Secrets = append(configuration.Secrets, item1)
	}

	// Set property "TriggerType":
	if typedInput.TriggerType != nil {
		var temp string
		temp = string(*typedInput.TriggerType)
		triggerType := JobConfiguration_TriggerType_STATUS(temp)
		configuration.TriggerType = &triggerType
	}

	// No error
	return nil
}

// AssignProperties_From_JobConfiguration_STATUS populates our JobConfiguration_STATUS from the provided source JobConfiguration_STATUS
func (configuration *JobConfiguration_STATUS) AssignProperties_From_JobConfiguration_STATUS(source *storage.JobConfiguration_STATUS) error {

	// EventTriggerConfig
	if source.EventTriggerConfig != nil {
		var eventTriggerConfig JobConfiguration_EventTriggerConfig_STATUS
		err := eventTriggerConfig.AssignProperties_From_JobConfiguration_EventTriggerConfig_STATUS(source.EventTriggerConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_JobConfiguration_EventTriggerConfig_STATUS() to populate field EventTriggerConfig")
		}
		configuration.EventTriggerConfig = &eventTriggerConfig
	} else {
		configuration.EventTriggerConfig = nil
	}

	// ManualTriggerConfig
	if source.ManualTriggerConfig != nil {
		var manualTriggerConfig JobConfiguration_ManualTriggerConfig_STATUS
		err := manualTriggerConfig.AssignProperties_From_JobConfiguration_ManualTriggerConfig_STATUS(source.ManualTriggerConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_JobConfiguration_ManualTriggerConfig_STATUS() to populate field ManualTriggerConfig")
		}
		configuration.ManualTriggerConfig = &manualTriggerConfig
	} else {
		configuration.ManualTriggerConfig = nil
	}

	// Registries
	if source.Registries != nil {
		registryList := make([]RegistryCredentials_STATUS, len(source.Registries))
		for registryIndex, registryItem := range source.Registries {
			// Shadow the loop variable to avoid aliasing
			registryItem := registryItem
			var registry RegistryCredentials_STATUS
			err := registry.AssignProperties_From_RegistryCredentials_STATUS(&registryItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_RegistryCredentials_STATUS() to populate field Registries")
			}
			registryList[registryIndex] = registry
		}
		configuration.Registries = registryList
	} else {
		configuration.Registries = nil
	}

	// ReplicaRetryLimit
	configuration.ReplicaRetryLimit = genruntime.ClonePointerToInt(source.ReplicaRetryLimit)

	// ReplicaTimeout
	configuration.ReplicaTimeout = genruntime.ClonePointerToInt(source.ReplicaTimeout)

	// ScheduleTriggerConfig
	if source.ScheduleTriggerConfig != nil {
		var scheduleTriggerConfig JobConfiguration_ScheduleTriggerConfig_STATUS
		err := scheduleTriggerConfig.AssignProperties_From_JobConfiguration_ScheduleTriggerConfig_STATUS(source.ScheduleTriggerConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_JobConfiguration_ScheduleTriggerConfig_STATUS() to populate field ScheduleTriggerConfig")
		}
		configuration.ScheduleTriggerConfig = &scheduleTriggerConfig
	} else {
		configuration.ScheduleTriggerConfig = nil
	}

	// Secrets
	if source.Secrets != nil {
		secretList := make([]Secret_STATUS, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret Secret_STATUS
			err := secret.AssignProperties_From_Secret_STATUS(&secretItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_Secret_STATUS() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		configuration.Secrets = secretList
	} else {
		configuration.Secrets = nil
	}

	// TriggerType
	if source.TriggerType != nil {
		triggerType := *source.TriggerType
		triggerTypeTemp := genruntime.ToEnum(triggerType, jobConfiguration_TriggerType_STATUS_Values)
		configuration.TriggerType = &triggerTypeTemp
	} else {
		configuration.TriggerType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_JobConfiguration_STATUS populates the provided destination JobConfiguration_STATUS from our JobConfiguration_STATUS
func (configuration *JobConfiguration_STATUS) AssignProperties_To_JobConfiguration_STATUS(destination *storage.JobConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EventTriggerConfig
	if configuration.EventTriggerConfig != nil {
		var eventTriggerConfig storage.JobConfiguration_EventTriggerConfig_STATUS
		err := configuration.EventTriggerConfig.AssignProperties_To_JobConfiguration_EventTriggerConfig_STATUS(&eventTriggerConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_JobConfiguration_EventTriggerConfig_STATUS() to populate field EventTriggerConfig")
		}
		destination.EventTriggerConfig = &eventTriggerConfig
	} else {
		destination.EventTriggerConfig = nil
	}

	// ManualTriggerConfig
	if configuration.ManualTriggerConfig != nil {
		var manualTriggerConfig storage.JobConfiguration_ManualTriggerConfig_STATUS
		err := configuration.ManualTriggerConfig.AssignProperties_To_JobConfiguration_ManualTriggerConfig_STATUS(&manualTriggerConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_JobConfiguration_ManualTriggerConfig_STATUS() to populate field ManualTriggerConfig")
		}
		destination.ManualTriggerConfig = &manualTriggerConfig
	} else {
		destination.ManualTriggerConfig = nil
	}

	// Registries
	if configuration.Registries != nil {
		registryList := make([]storage.RegistryCredentials_STATUS, len(configuration.Registries))
		for registryIndex, registryItem := range configuration.Registries {
			// Shadow the loop variable to avoid aliasing
			registryItem := registryItem
			var registry storage.RegistryCredentials_STATUS
			err := registryItem.AssignProperties_To_RegistryCredentials_STATUS(&registry)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_RegistryCredentials_STATUS() to populate field Registries")
			}
			registryList[registryIndex] = registry
		}
		destination.Registries = registryList
	} else {
		destination.Registries = nil
	}

	// ReplicaRetryLimit
	destination.ReplicaRetryLimit = genruntime.ClonePointerToInt(configuration.ReplicaRetryLimit)

	// ReplicaTimeout
	destination.ReplicaTimeout = genruntime.ClonePointerToInt(configuration.ReplicaTimeout)

	// ScheduleTriggerConfig
	if configuration.ScheduleTriggerConfig != nil {
		var scheduleTriggerConfig storage.JobConfiguration_ScheduleTriggerConfig_STATUS
		err := configuration.ScheduleTriggerConfig.AssignProperties_To_JobConfiguration_ScheduleTriggerConfig_STATUS(&scheduleTriggerConfig)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_JobConfiguration_ScheduleTriggerConfig_STATUS() to populate field ScheduleTriggerConfig")
		}
		destination.ScheduleTriggerConfig = &scheduleTriggerConfig
	} else {
		destination.ScheduleTriggerConfig = nil
	}

	// Secrets
	if configuration.Secrets != nil {
		secretList := make([]storage.Secret_STATUS, len(configuration.Secrets))
		for secretIndex, secretItem := range configuration.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret storage.Secret_STATUS
			err := secretItem.AssignProperties_To_Secret_STATUS(&secret)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_Secret_STATUS() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		destination.Secrets = secretList
	} else {
		destination.Secrets = nil
	}

	// TriggerType
	if configuration.TriggerType != nil {
		triggerType := string(*configuration.TriggerType)
		destination.TriggerType = &triggerType
	} else {
		destination.TriggerType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type JobOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_JobOperatorSpec populates our JobOperatorSpec from the provided source JobOperatorSpec
func (operator *JobOperatorSpec) AssignProperties_From_JobOperatorSpec(source *storage.JobOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_JobOperatorSpec populates the provided destination JobOperatorSpec from our JobOperatorSpec
func (operator *JobOperatorSpec) AssignProperties_To_JobOperatorSpec(destination *storage.JobOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Container Apps Job versioned application definition. Defines the desired state of an immutable revision. Any changes to
// this section Will result in a new revision being created
type JobTemplate struct {
	// Containers: List of container definitions for the Container App.
	Containers []Container `json:"containers,omitempty"`

	// InitContainers: List of specialized containers that run before app containers.
	InitContainers []BaseContainer `json:"initContainers,omitempty"`

	// Volumes: List of volume definitions for the Container App.
	Volumes []Volume `json:"volumes,omitempty"`
}

var _ genruntime.ARMTransformer = &JobTemplate{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (template *JobTemplate) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if template == nil {
		return nil, nil
	}
	result := &arm.JobTemplate{}

	// Set property "Containers":
	for _, item := range template.Containers {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Containers = append(result.Containers, *item_ARM.(*arm.Container))
	}

	// Set property "InitContainers":
	for _, item := range template.InitContainers {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.InitContainers = append(result.InitContainers, *item_ARM.(*arm.BaseContainer))
	}

	// Set property "Volumes":
	for _, item := range template.Volumes {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Volumes = append(result.Volumes, *item_ARM.(*arm.Volume))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (template *JobTemplate) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.JobTemplate{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (template *JobTemplate) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.JobTemplate)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.JobTemplate, got %T", armInput)
	}

	// Set property "Containers":
	for _, item := range typedInput.Containers {
		var item1 Container
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		template.Containers = append(template.Containers, item1)
	}

	// Set property "InitContainers":
	for _, item := range typedInput.InitContainers {
		var item1 BaseContainer
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		template.InitContainers = append(template.InitContainers, item1)
	}

	// Set property "Volumes":
	for _, item := range typedInput.Volumes {
		var item1 Volume
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		template.Volumes = append(template.Volumes, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_JobTemplate populates our JobTemplate from the provided source JobTemplate
func (template *JobTemplate) AssignProperties_From_JobTemplate(source *storage.JobTemplate) error {

	// Containers
	if source.Containers != nil {
		containerList := make([]Container, len(source.Containers))
		for containerIndex, containerItem := range source.Containers {
			// Shadow the loop variable to avoid aliasing
			containerItem := containerItem
			var container Container
			err := container.AssignProperties_From_Container(&containerItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_Container() to populate field Containers")
			}
			containerList[containerIndex] = container
		}
		template.Containers = containerList
	} else {
		template.Containers = nil
	}

	// InitContainers
	if source.InitContainers != nil {
		initContainerList := make([]BaseContainer, len(source.InitContainers))
		for initContainerIndex, initContainerItem := range source.InitContainers {
			// Shadow the loop variable to avoid aliasing
			initContainerItem := initContainerItem
			var initContainer BaseContainer
			err := initContainer.AssignProperties_From_BaseContainer(&initContainerItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_BaseContainer() to populate field InitContainers")
			}
			initContainerList[initContainerIndex] = initContainer
		}
		template.InitContainers = initContainerList
	} else {
		template.InitContainers = nil
	}

	// Volumes
	if source.Volumes != nil {
		volumeList := make([]Volume, len(source.Volumes))
		for volumeIndex, volumeItem := range source.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume Volume
			err := volume.AssignProperties_From_Volume(&volumeItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_Volume() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		template.Volumes = volumeList
	} else {
		template.Volumes = nil
	}

	// No error
	return nil
}

// AssignProperties_To_JobTemplate populates the provided destination JobTemplate from our JobTemplate
func (template *JobTemplate) AssignProperties_To_JobTemplate(destination *storage.JobTemplate) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Containers
	if template.Containers != nil {
		containerList := make([]storage.Container, len(template.Containers))
		for containerIndex, containerItem := range template.Containers {
			// Shadow the loop variable to avoid aliasing
			containerItem := containerItem
			var container storage.Container
			err := containerItem.AssignProperties_To_Container(&container)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_Container() to populate field Containers")
			}
			containerList[containerIndex] = container
		}
		destination.Containers = containerList
	} else {
		destination.Containers = nil
	}

	// InitContainers
	if template.InitContainers != nil {
		initContainerList := make([]storage.BaseContainer, len(template.InitContainers))
		for initContainerIndex, initContainerItem := range template.InitContainers {
			// Shadow the loop variable to avoid aliasing
			initContainerItem := initContainerItem
			var initContainer storage.BaseContainer
			err := initContainerItem.AssignProperties_To_BaseContainer(&initContainer)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_BaseContainer() to populate field InitContainers")
			}
			initContainerList[initContainerIndex] = initContainer
		}
		destination.InitContainers = initContainerList
	} else {
		destination.InitContainers = nil
	}

	// Volumes
	if template.Volumes != nil {
		volumeList := make([]storage.Volume, len(template.Volumes))
		for volumeIndex, volumeItem := range template.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume storage.Volume
			err := volumeItem.AssignProperties_To_Volume(&volume)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_Volume() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		destination.Volumes = volumeList
	} else {
		destination.Volumes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_JobTemplate_STATUS populates our JobTemplate from the provided source JobTemplate_STATUS
func (template *JobTemplate) Initialize_From_JobTemplate_STATUS(source *JobTemplate_STATUS) error {

	// Containers
	if source.Containers != nil {
		containerList := make([]Container, len(source.Containers))
		for containerIndex, containerItem := range source.Containers {
			// Shadow the loop variable to avoid aliasing
			containerItem := containerItem
			var container Container
			err := container.Initialize_From_Container_STATUS(&containerItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_Container_STATUS() to populate field Containers")
			}
			containerList[containerIndex] = container
		}
		template.Containers = containerList
	} else {
		template.Containers = nil
	}

	// InitContainers
	if source.InitContainers != nil {
		initContainerList := make([]BaseContainer, len(source.InitContainers))
		for initContainerIndex, initContainerItem := range source.InitContainers {
			// Shadow the loop variable to avoid aliasing
			initContainerItem := initContainerItem
			var initContainer BaseContainer
			err := initContainer.Initialize_From_BaseContainer_STATUS(&initContainerItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_BaseContainer_STATUS() to populate field InitContainers")
			}
			initContainerList[initContainerIndex] = initContainer
		}
		template.InitContainers = initContainerList
	} else {
		template.InitContainers = nil
	}

	// Volumes
	if source.Volumes != nil {
		volumeList := make([]Volume, len(source.Volumes))
		for volumeIndex, volumeItem := range source.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume Volume
			err := volume.Initialize_From_Volume_STATUS(&volumeItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_Volume_STATUS() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		template.Volumes = volumeList
	} else {
		template.Volumes = nil
	}

	// No error
	return nil
}

// Container Apps Job versioned application definition. Defines the desired state of an immutable revision. Any changes to
// this section Will result in a new revision being created
type JobTemplate_STATUS struct {
	// Containers: List of container definitions for the Container App.
	Containers []Container_STATUS `json:"containers,omitempty"`

	// InitContainers: List of specialized containers that run before app containers.
	InitContainers []BaseContainer_STATUS `json:"initContainers,omitempty"`

	// Volumes: List of volume definitions for the Container App.
	Volumes []Volume_STATUS `json:"volumes,omitempty"`
}

var _ genruntime.FromARMConverter = &JobTemplate_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (template *JobTemplate_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.JobTemplate_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (template *JobTemplate_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.JobTemplate_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.JobTemplate_STATUS, got %T", armInput)
	}

	// Set property "Containers":
	for _, item := range typedInput.Containers {
		var item1 Container_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		template.Containers = append(template.Containers, item1)
	}

	// Set property "InitContainers":
	for _, item := range typedInput.InitContainers {
		var item1 BaseContainer_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		template.InitContainers = append(template.InitContainers, item1)
	}

	// Set property "Volumes":
	for _, item := range typedInput.Volumes {
		var item1 Volume_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		template.Volumes = append(template.Volumes, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_JobTemplate_STATUS populates our JobTemplate_STATUS from the provided source JobTemplate_STATUS
func (template *JobTemplate_STATUS) AssignProperties_From_JobTemplate_STATUS(source *storage.JobTemplate_STATUS) error {

	// Containers
	if source.Containers != nil {
		containerList := make([]Container_STATUS, len(source.Containers))
		for containerIndex, containerItem := range source.Containers {
			// Shadow the loop variable to avoid aliasing
			containerItem := containerItem
			var container Container_STATUS
			err := container.AssignProperties_From_Container_STATUS(&containerItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_Container_STATUS() to populate field Containers")
			}
			containerList[containerIndex] = container
		}
		template.Containers = containerList
	} else {
		template.Containers = nil
	}

	// InitContainers
	if source.InitContainers != nil {
		initContainerList := make([]BaseContainer_STATUS, len(source.InitContainers))
		for initContainerIndex, initContainerItem := range source.InitContainers {
			// Shadow the loop variable to avoid aliasing
			initContainerItem := initContainerItem
			var initContainer BaseContainer_STATUS
			err := initContainer.AssignProperties_From_BaseContainer_STATUS(&initContainerItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_BaseContainer_STATUS() to populate field InitContainers")
			}
			initContainerList[initContainerIndex] = initContainer
		}
		template.InitContainers = initContainerList
	} else {
		template.InitContainers = nil
	}

	// Volumes
	if source.Volumes != nil {
		volumeList := make([]Volume_STATUS, len(source.Volumes))
		for volumeIndex, volumeItem := range source.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume Volume_STATUS
			err := volume.AssignProperties_From_Volume_STATUS(&volumeItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_Volume_STATUS() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		template.Volumes = volumeList
	} else {
		template.Volumes = nil
	}

	// No error
	return nil
}

// AssignProperties_To_JobTemplate_STATUS populates the provided destination JobTemplate_STATUS from our JobTemplate_STATUS
func (template *JobTemplate_STATUS) AssignProperties_To_JobTemplate_STATUS(destination *storage.JobTemplate_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Containers
	if template.Containers != nil {
		containerList := make([]storage.Container_STATUS, len(template.Containers))
		for containerIndex, containerItem := range template.Containers {
			// Shadow the loop variable to avoid aliasing
			containerItem := containerItem
			var container storage.Container_STATUS
			err := containerItem.AssignProperties_To_Container_STATUS(&container)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_Container_STATUS() to populate field Containers")
			}
			containerList[containerIndex] = container
		}
		destination.Containers = containerList
	} else {
		destination.Containers = nil
	}

	// InitContainers
	if template.InitContainers != nil {
		initContainerList := make([]storage.BaseContainer_STATUS, len(template.InitContainers))
		for initContainerIndex, initContainerItem := range template.InitContainers {
			// Shadow the loop variable to avoid aliasing
			initContainerItem := initContainerItem
			var initContainer storage.BaseContainer_STATUS
			err := initContainerItem.AssignProperties_To_BaseContainer_STATUS(&initContainer)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_BaseContainer_STATUS() to populate field InitContainers")
			}
			initContainerList[initContainerIndex] = initContainer
		}
		destination.InitContainers = initContainerList
	} else {
		destination.InitContainers = nil
	}

	// Volumes
	if template.Volumes != nil {
		volumeList := make([]storage.Volume_STATUS, len(template.Volumes))
		for volumeIndex, volumeItem := range template.Volumes {
			// Shadow the loop variable to avoid aliasing
			volumeItem := volumeItem
			var volume storage.Volume_STATUS
			err := volumeItem.AssignProperties_To_Volume_STATUS(&volume)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_Volume_STATUS() to populate field Volumes")
			}
			volumeList[volumeIndex] = volume
		}
		destination.Volumes = volumeList
	} else {
		destination.Volumes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type JobConfiguration_EventTriggerConfig struct {
	Parallelism            *int `json:"parallelism,omitempty"`
	ReplicaCompletionCount *int `json:"replicaCompletionCount,omitempty"`

	// Scale: Scaling configurations for event driven jobs.
	Scale *JobScale `json:"scale,omitempty"`
}

var _ genruntime.ARMTransformer = &JobConfiguration_EventTriggerConfig{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (config *JobConfiguration_EventTriggerConfig) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if config == nil {
		return nil, nil
	}
	result := &arm.JobConfiguration_EventTriggerConfig{}

	// Set property "Parallelism":
	if config.Parallelism != nil {
		parallelism := *config.Parallelism
		result.Parallelism = &parallelism
	}

	// Set property "ReplicaCompletionCount":
	if config.ReplicaCompletionCount != nil {
		replicaCompletionCount := *config.ReplicaCompletionCount
		result.ReplicaCompletionCount = &replicaCompletionCount
	}

	// Set property "Scale":
	if config.Scale != nil {
		scale_ARM, err := (*config.Scale).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		scale := *scale_ARM.(*arm.JobScale)
		result.Scale = &scale
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *JobConfiguration_EventTriggerConfig) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.JobConfiguration_EventTriggerConfig{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *JobConfiguration_EventTriggerConfig) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.JobConfiguration_EventTriggerConfig)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.JobConfiguration_EventTriggerConfig, got %T", armInput)
	}

	// Set property "Parallelism":
	if typedInput.Parallelism != nil {
		parallelism := *typedInput.Parallelism
		config.Parallelism = &parallelism
	}

	// Set property "ReplicaCompletionCount":
	if typedInput.ReplicaCompletionCount != nil {
		replicaCompletionCount := *typedInput.ReplicaCompletionCount
		config.ReplicaCompletionCount = &replicaCompletionCount
	}

	// Set property "Scale":
	if typedInput.Scale != nil {
		var scale1 JobScale
		err := scale1.PopulateFromARM(owner, *typedInput.Scale)
		if err != nil {
			return err
		}
		scale := scale1
		config.Scale = &scale
	}

	// No error
	return nil
}

// AssignProperties_From_JobConfiguration_EventTriggerConfig populates our JobConfiguration_EventTriggerConfig from the provided source JobConfiguration_EventTriggerConfig
func (config *JobConfiguration_EventTriggerConfig) AssignProperties_From_JobConfiguration_EventTriggerConfig(source *storage.JobConfiguration_EventTriggerConfig) error {

	// Parallelism
	config.Parallelism = genruntime.ClonePointerToInt(source.Parallelism)

	// ReplicaCompletionCount
	config.ReplicaCompletionCount = genruntime.ClonePointerToInt(source.ReplicaCompletionCount)

	// Scale
	if source.Scale != nil {
		var scale JobScale
		err := scale.AssignProperties_From_JobScale(source.Scale)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_JobScale() to populate field Scale")
		}
		config.Scale = &scale
	} else {
		config.Scale = nil
	}

	// No error
	return nil
}

// AssignProperties_To_JobConfiguration_EventTriggerConfig populates the provided destination JobConfiguration_EventTriggerConfig from our JobConfiguration_EventTriggerConfig
func (config *JobConfiguration_EventTriggerConfig) AssignProperties_To_JobConfiguration_EventTriggerConfig(destination *storage.JobConfiguration_EventTriggerConfig) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Parallelism
	destination.Parallelism = genruntime.ClonePointerToInt(config.Parallelism)

	// ReplicaCompletionCount
	destination.ReplicaCompletionCount = genruntime.ClonePointerToInt(config.ReplicaCompletionCount)

	// Scale
	if config.Scale != nil {
		var scale storage.JobScale
		err := config.Scale.AssignProperties_To_JobScale(&scale)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_JobScale() to populate field Scale")
		}
		destination.Scale = &scale
	} else {
		destination.Scale = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_JobConfiguration_EventTriggerConfig_STATUS populates our JobConfiguration_EventTriggerConfig from the provided source JobConfiguration_EventTriggerConfig_STATUS
func (config *JobConfiguration_EventTriggerConfig) Initialize_From_JobConfiguration_EventTriggerConfig_STATUS(source *JobConfiguration_EventTriggerConfig_STATUS) error {

	// Parallelism
	config.Parallelism = genruntime.ClonePointerToInt(source.Parallelism)

	// ReplicaCompletionCount
	config.ReplicaCompletionCount = genruntime.ClonePointerToInt(source.ReplicaCompletionCount)

	// Scale
	if source.Scale != nil {
		var scale JobScale
		err := scale.Initialize_From_JobScale_STATUS(source.Scale)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_JobScale_STATUS() to populate field Scale")
		}
		config.Scale = &scale
	} else {
		config.Scale = nil
	}

	// No error
	return nil
}

type JobConfiguration_EventTriggerConfig_STATUS struct {
	Parallelism            *int `json:"parallelism,omitempty"`
	ReplicaCompletionCount *int `json:"replicaCompletionCount,omitempty"`

	// Scale: Scaling configurations for event driven jobs.
	Scale *JobScale_STATUS `json:"scale,omitempty"`
}

var _ genruntime.FromARMConverter = &JobConfiguration_EventTriggerConfig_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *JobConfiguration_EventTriggerConfig_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.JobConfiguration_EventTriggerConfig_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *JobConfiguration_EventTriggerConfig_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.JobConfiguration_EventTriggerConfig_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.JobConfiguration_EventTriggerConfig_STATUS, got %T", armInput)
	}

	// Set property "Parallelism":
	if typedInput.Parallelism != nil {
		parallelism := *typedInput.Parallelism
		config.Parallelism = &parallelism
	}

	// Set property "ReplicaCompletionCount":
	if typedInput.ReplicaCompletionCount != nil {
		replicaCompletionCount := *typedInput.ReplicaCompletionCount
		config.ReplicaCompletionCount = &replicaCompletionCount
	}

	// Set property "Scale":
	if typedInput.Scale != nil {
		var scale1 JobScale_STATUS
		err := scale1.PopulateFromARM(owner, *typedInput.Scale)
		if err != nil {
			return err
		}
		scale := scale1
		config.Scale = &scale
	}

	// No error
	return nil
}

// AssignProperties_From_JobConfiguration_EventTriggerConfig_STATUS populates our JobConfiguration_EventTriggerConfig_STATUS from the provided source JobConfiguration_EventTriggerConfig_STATUS
func (config *JobConfiguration_EventTriggerConfig_STATUS) AssignProperties_From_JobConfiguration_EventTriggerConfig_STATUS(source *storage.JobConfiguration_EventTriggerConfig_STATUS) error {

	// Parallelism
	config.Parallelism = genruntime.ClonePointerToInt(source.Parallelism)

	// ReplicaCompletionCount
	config.ReplicaCompletionCount = genruntime.ClonePointerToInt(source.ReplicaCompletionCount)

	// Scale
	if source.Scale != nil {
		var scale JobScale_STATUS
		err := scale.AssignProperties_From_JobScale_STATUS(source.Scale)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_JobScale_STATUS() to populate field Scale")
		}
		config.Scale = &scale
	} else {
		config.Scale = nil
	}

	// No error
	return nil
}

// AssignProperties_To_JobConfiguration_EventTriggerConfig_STATUS populates the provided destination JobConfiguration_EventTriggerConfig_STATUS from our JobConfiguration_EventTriggerConfig_STATUS
func (config *JobConfiguration_EventTriggerConfig_STATUS) AssignProperties_To_JobConfiguration_EventTriggerConfig_STATUS(destination *storage.JobConfiguration_EventTriggerConfig_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Parallelism
	destination.Parallelism = genruntime.ClonePointerToInt(config.Parallelism)

	// ReplicaCompletionCount
	destination.ReplicaCompletionCount = genruntime.ClonePointerToInt(config.ReplicaCompletionCount)

	// Scale
	if config.Scale != nil {
		var scale storage.JobScale_STATUS
		err := config.Scale.AssignProperties_To_JobScale_STATUS(&scale)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_JobScale_STATUS() to populate field Scale")
		}
		destination.Scale = &scale
	} else {
		destination.Scale = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type JobConfiguration_ManualTriggerConfig struct {
	Parallelism            *int `json:"parallelism,omitempty"`
	ReplicaCompletionCount *int `json:"replicaCompletionCount,omitempty"`
}

var _ genruntime.ARMTransformer = &JobConfiguration_ManualTriggerConfig{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (config *JobConfiguration_ManualTriggerConfig) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if config == nil {
		return nil, nil
	}
	result := &arm.JobConfiguration_ManualTriggerConfig{}

	// Set property "Parallelism":
	if config.Parallelism != nil {
		parallelism := *config.Parallelism
		result.Parallelism = &parallelism
	}

	// Set property "ReplicaCompletionCount":
	if config.ReplicaCompletionCount != nil {
		replicaCompletionCount := *config.ReplicaCompletionCount
		result.ReplicaCompletionCount = &replicaCompletionCount
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *JobConfiguration_ManualTriggerConfig) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.JobConfiguration_ManualTriggerConfig{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *JobConfiguration_ManualTriggerConfig) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.JobConfiguration_ManualTriggerConfig)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.JobConfiguration_ManualTriggerConfig, got %T", armInput)
	}

	// Set property "Parallelism":
	if typedInput.Parallelism != nil {
		parallelism := *typedInput.Parallelism
		config.Parallelism = &parallelism
	}

	// Set property "ReplicaCompletionCount":
	if typedInput.ReplicaCompletionCount != nil {
		replicaCompletionCount := *typedInput.ReplicaCompletionCount
		config.ReplicaCompletionCount = &replicaCompletionCount
	}

	// No error
	return nil
}

// AssignProperties_From_JobConfiguration_ManualTriggerConfig populates our JobConfiguration_ManualTriggerConfig from the provided source JobConfiguration_ManualTriggerConfig
func (config *JobConfiguration_ManualTriggerConfig) AssignProperties_From_JobConfiguration_ManualTriggerConfig(source *storage.JobConfiguration_ManualTriggerConfig) error {

	// Parallelism
	config.Parallelism = genruntime.ClonePointerToInt(source.Parallelism)

	// ReplicaCompletionCount
	config.ReplicaCompletionCount = genruntime.ClonePointerToInt(source.ReplicaCompletionCount)

	// No error
	return nil
}

// AssignProperties_To_JobConfiguration_ManualTriggerConfig populates the provided destination JobConfiguration_ManualTriggerConfig from our JobConfiguration_ManualTriggerConfig
func (config *JobConfiguration_ManualTriggerConfig) AssignProperties_To_JobConfiguration_ManualTriggerConfig(destination *storage.JobConfiguration_ManualTriggerConfig) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Parallelism
	destination.Parallelism = genruntime.ClonePointerToInt(config.Parallelism)

	// ReplicaCompletionCount
	destination.ReplicaCompletionCount = genruntime.ClonePointerToInt(config.ReplicaCompletionCount)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_JobConfiguration_ManualTriggerConfig_STATUS populates our JobConfiguration_ManualTriggerConfig from the provided source JobConfiguration_ManualTriggerConfig_STATUS
func (config *JobConfiguration_ManualTriggerConfig) Initialize_From_JobConfiguration_ManualTriggerConfig_STATUS(source *JobConfiguration_ManualTriggerConfig_STATUS) error {

	// Parallelism
	config.Parallelism = genruntime.ClonePointerToInt(source.Parallelism)

	// ReplicaCompletionCount
	config.ReplicaCompletionCount = genruntime.ClonePointerToInt(source.ReplicaCompletionCount)

	// No error
	return nil
}

type JobConfiguration_ManualTriggerConfig_STATUS struct {
	Parallelism            *int `json:"parallelism,omitempty"`
	ReplicaCompletionCount *int `json:"replicaCompletionCount,omitempty"`
}

var _ genruntime.FromARMConverter = &JobConfiguration_ManualTriggerConfig_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *JobConfiguration_ManualTriggerConfig_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.JobConfiguration_ManualTriggerConfig_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *JobConfiguration_ManualTriggerConfig_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.JobConfiguration_ManualTriggerConfig_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.JobConfiguration_ManualTriggerConfig_STATUS, got %T", armInput)
	}

	// Set property "Parallelism":
	if typedInput.Parallelism != nil {
		parallelism := *typedInput.Parallelism
		config.Parallelism = &parallelism
	}

	// Set property "ReplicaCompletionCount":
	if typedInput.ReplicaCompletionCount != nil {
		replicaCompletionCount := *typedInput.ReplicaCompletionCount
		config.ReplicaCompletionCount = &replicaCompletionCount
	}

	// No error
	return nil
}

// AssignProperties_From_JobConfiguration_ManualTriggerConfig_STATUS populates our JobConfiguration_ManualTriggerConfig_STATUS from the provided source JobConfiguration_ManualTriggerConfig_STATUS
func (config *JobConfiguration_ManualTriggerConfig_STATUS) AssignProperties_From_JobConfiguration_ManualTriggerConfig_STATUS(source *storage.JobConfiguration_ManualTriggerConfig_STATUS) error {

	// Parallelism
	config.Parallelism = genruntime.ClonePointerToInt(source.Parallelism)

	// ReplicaCompletionCount
	config.ReplicaCompletionCount = genruntime.ClonePointerToInt(source.ReplicaCompletionCount)

	// No error
	return nil
}

// AssignProperties_To_JobConfiguration_ManualTriggerConfig_STATUS populates the provided destination JobConfiguration_ManualTriggerConfig_STATUS from our JobConfiguration_ManualTriggerConfig_STATUS
func (config *JobConfiguration_ManualTriggerConfig_STATUS) AssignProperties_To_JobConfiguration_ManualTriggerConfig_STATUS(destination *storage.JobConfiguration_ManualTriggerConfig_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Parallelism
	destination.Parallelism = genruntime.ClonePointerToInt(config.Parallelism)

	// ReplicaCompletionCount
	destination.ReplicaCompletionCount = genruntime.ClonePointerToInt(config.ReplicaCompletionCount)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type JobConfiguration_ScheduleTriggerConfig struct {
	// +kubebuilder:validation:Required
	// CronExpression: Cron formatted repeating schedule ("* * * * *") of a Cron Job.
	CronExpression         *string `json:"cronExpression,omitempty"`
	Parallelism            *int    `json:"parallelism,omitempty"`
	ReplicaCompletionCount *int    `json:"replicaCompletionCount,omitempty"`
}

var _ genruntime.ARMTransformer = &JobConfiguration_ScheduleTriggerConfig{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (config *JobConfiguration_ScheduleTriggerConfig) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if config == nil {
		return nil, nil
	}
	result := &arm.JobConfiguration_ScheduleTriggerConfig{}

	// Set property "CronExpression":
	if config.CronExpression != nil {
		cronExpression := *config.CronExpression
		result.CronExpression = &cronExpression
	}

	// Set property "Parallelism":
	if config.Parallelism != nil {
		parallelism := *config.Parallelism
		result.Parallelism = &parallelism
	}

	// Set property "ReplicaCompletionCount":
	if config.ReplicaCompletionCount != nil {
		replicaCompletionCount := *config.ReplicaCompletionCount
		result.ReplicaCompletionCount = &replicaCompletionCount
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *JobConfiguration_ScheduleTriggerConfig) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.JobConfiguration_ScheduleTriggerConfig{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *JobConfiguration_ScheduleTriggerConfig) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.JobConfiguration_ScheduleTriggerConfig)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.JobConfiguration_ScheduleTriggerConfig, got %T", armInput)
	}

	// Set property "CronExpression":
	if typedInput.CronExpression != nil {
		cronExpression := *typedInput.CronExpression
		config.CronExpression = &cronExpression
	}

	// Set property "Parallelism":
	if typedInput.Parallelism != nil {
		parallelism := *typedInput.Parallelism
		config.Parallelism = &parallelism
	}

	// Set property "ReplicaCompletionCount":
	if typedInput.ReplicaCompletionCount != nil {
		replicaCompletionCount := *typedInput.ReplicaCompletionCount
		config.ReplicaCompletionCount = &replicaCompletionCount
	}

	// No error
	return nil
}

// AssignProperties_From_JobConfiguration_ScheduleTriggerConfig populates our JobConfiguration_ScheduleTriggerConfig from the provided source JobConfiguration_ScheduleTriggerConfig
func (config *JobConfiguration_ScheduleTriggerConfig) AssignProperties_From_JobConfiguration_ScheduleTriggerConfig(source *storage.JobConfiguration_ScheduleTriggerConfig) error {

	// CronExpression
	config.CronExpression = genruntime.ClonePointerToString(source.CronExpression)

	// Parallelism
	config.Parallelism = genruntime.ClonePointerToInt(source.Parallelism)

	// ReplicaCompletionCount
	config.ReplicaCompletionCount = genruntime.ClonePointerToInt(source.ReplicaCompletionCount)

	// No error
	return nil
}

// AssignProperties_To_JobConfiguration_ScheduleTriggerConfig populates the provided destination JobConfiguration_ScheduleTriggerConfig from our JobConfiguration_ScheduleTriggerConfig
func (config *JobConfiguration_ScheduleTriggerConfig) AssignProperties_To_JobConfiguration_ScheduleTriggerConfig(destination *storage.JobConfiguration_ScheduleTriggerConfig) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CronExpression
	destination.CronExpression = genruntime.ClonePointerToString(config.CronExpression)

	// Parallelism
	destination.Parallelism = genruntime.ClonePointerToInt(config.Parallelism)

	// ReplicaCompletionCount
	destination.ReplicaCompletionCount = genruntime.ClonePointerToInt(config.ReplicaCompletionCount)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_JobConfiguration_ScheduleTriggerConfig_STATUS populates our JobConfiguration_ScheduleTriggerConfig from the provided source JobConfiguration_ScheduleTriggerConfig_STATUS
func (config *JobConfiguration_ScheduleTriggerConfig) Initialize_From_JobConfiguration_ScheduleTriggerConfig_STATUS(source *JobConfiguration_ScheduleTriggerConfig_STATUS) error {

	// CronExpression
	config.CronExpression = genruntime.ClonePointerToString(source.CronExpression)

	// Parallelism
	config.Parallelism = genruntime.ClonePointerToInt(source.Parallelism)

	// ReplicaCompletionCount
	config.ReplicaCompletionCount = genruntime.ClonePointerToInt(source.ReplicaCompletionCount)

	// No error
	return nil
}

type JobConfiguration_ScheduleTriggerConfig_STATUS struct {
	// CronExpression: Cron formatted repeating schedule ("* * * * *") of a Cron Job.
	CronExpression         *string `json:"cronExpression,omitempty"`
	Parallelism            *int    `json:"parallelism,omitempty"`
	ReplicaCompletionCount *int    `json:"replicaCompletionCount,omitempty"`
}

var _ genruntime.FromARMConverter = &JobConfiguration_ScheduleTriggerConfig_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *JobConfiguration_ScheduleTriggerConfig_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.JobConfiguration_ScheduleTriggerConfig_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *JobConfiguration_ScheduleTriggerConfig_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.JobConfiguration_ScheduleTriggerConfig_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.JobConfiguration_ScheduleTriggerConfig_STATUS, got %T", armInput)
	}

	// Set property "CronExpression":
	if typedInput.CronExpression != nil {
		cronExpression := *typedInput.CronExpression
		config.CronExpression = &cronExpression
	}

	// Set property "Parallelism":
	if typedInput.Parallelism != nil {
		parallelism := *typedInput.Parallelism
		config.Parallelism = &parallelism
	}

	// Set property "ReplicaCompletionCount":
	if typedInput.ReplicaCompletionCount != nil {
		replicaCompletionCount := *typedInput.ReplicaCompletionCount
		config.ReplicaCompletionCount = &replicaCompletionCount
	}

	// No error
	return nil
}

// AssignProperties_From_JobConfiguration_ScheduleTriggerConfig_STATUS populates our JobConfiguration_ScheduleTriggerConfig_STATUS from the provided source JobConfiguration_ScheduleTriggerConfig_STATUS
func (config *JobConfiguration_ScheduleTriggerConfig_STATUS) AssignProperties_From_JobConfiguration_ScheduleTriggerConfig_STATUS(source *storage.JobConfiguration_ScheduleTriggerConfig_STATUS) error {

	// CronExpression
	config.CronExpression = genruntime.ClonePointerToString(source.CronExpression)

	// Parallelism
	config.Parallelism = genruntime.ClonePointerToInt(source.Parallelism)

	// ReplicaCompletionCount
	config.ReplicaCompletionCount = genruntime.ClonePointerToInt(source.ReplicaCompletionCount)

	// No error
	return nil
}

// AssignProperties_To_JobConfiguration_ScheduleTriggerConfig_STATUS populates the provided destination JobConfiguration_ScheduleTriggerConfig_STATUS from our JobConfiguration_ScheduleTriggerConfig_STATUS
func (config *JobConfiguration_ScheduleTriggerConfig_STATUS) AssignProperties_To_JobConfiguration_ScheduleTriggerConfig_STATUS(destination *storage.JobConfiguration_ScheduleTriggerConfig_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CronExpression
	destination.CronExpression = genruntime.ClonePointerToString(config.CronExpression)

	// Parallelism
	destination.Parallelism = genruntime.ClonePointerToInt(config.Parallelism)

	// ReplicaCompletionCount
	destination.ReplicaCompletionCount = genruntime.ClonePointerToInt(config.ReplicaCompletionCount)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Event","Manual","Schedule"}
type JobConfiguration_TriggerType string

const (
	JobConfiguration_TriggerType_Event    = JobConfiguration_TriggerType("Event")
	JobConfiguration_TriggerType_Manual   = JobConfiguration_TriggerType("Manual")
	JobConfiguration_TriggerType_Schedule = JobConfiguration_TriggerType("Schedule")
)

// Mapping from string to JobConfiguration_TriggerType
var jobConfiguration_TriggerType_Values = map[string]JobConfiguration_TriggerType{
	"event":    JobConfiguration_TriggerType_Event,
	"manual":   JobConfiguration_TriggerType_Manual,
	"schedule": JobConfiguration_TriggerType_Schedule,
}

type JobConfiguration_TriggerType_STATUS string

const (
	JobConfiguration_TriggerType_STATUS_Event    = JobConfiguration_TriggerType_STATUS("Event")
	JobConfiguration_TriggerType_STATUS_Manual   = JobConfiguration_TriggerType_STATUS("Manual")
	JobConfiguration_TriggerType_STATUS_Schedule = JobConfiguration_TriggerType_STATUS("Schedule")
)

// Mapping from string to JobConfiguration_TriggerType_STATUS
var jobConfiguration_TriggerType_STATUS_Values = map[string]JobConfiguration_TriggerType_STATUS{
	"event":    JobConfiguration_TriggerType_STATUS_Event,
	"manual":   JobConfiguration_TriggerType_STATUS_Manual,
	"schedule": JobConfiguration_TriggerType_STATUS_Schedule,
}

// Scaling configurations for event driven jobs.
type JobScale struct {
	// MaxExecutions: Maximum number of job executions that are created for a trigger, default 100.
	MaxExecutions *int `json:"maxExecutions,omitempty"`

	// MinExecutions: Minimum number of job executions that are created for a trigger, default 0
	MinExecutions   *int `json:"minExecutions,omitempty"`
	PollingInterval *int `json:"pollingInterval,omitempty"`

	// Rules: Scaling rules.
	Rules []JobScaleRule `json:"rules,omitempty"`
}

var _ genruntime.ARMTransformer = &JobScale{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (scale *JobScale) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if scale == nil {
		return nil, nil
	}
	result := &arm.JobScale{}

	// Set property "MaxExecutions":
	if scale.MaxExecutions != nil {
		maxExecutions := *scale.MaxExecutions
		result.MaxExecutions = &maxExecutions
	}

	// Set property "MinExecutions":
	if scale.MinExecutions != nil {
		minExecutions := *scale.MinExecutions
		result.MinExecutions = &minExecutions
	}

	// Set property "PollingInterval":
	if scale.PollingInterval != nil {
		pollingInterval := *scale.PollingInterval
		result.PollingInterval = &pollingInterval
	}

	// Set property "Rules":
	for _, item := range scale.Rules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Rules = append(result.Rules, *item_ARM.(*arm.JobScaleRule))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (scale *JobScale) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.JobScale{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (scale *JobScale) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.JobScale)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.JobScale, got %T", armInput)
	}

	// Set property "MaxExecutions":
	if typedInput.MaxExecutions != nil {
		maxExecutions := *typedInput.MaxExecutions
		scale.MaxExecutions = &maxExecutions
	}

	// Set property "MinExecutions":
	if typedInput.MinExecutions != nil {
		minExecutions := *typedInput.MinExecutions
		scale.MinExecutions = &minExecutions
	}

	// Set property "PollingInterval":
	if typedInput.PollingInterval != nil {
		pollingInterval := *typedInput.PollingInterval
		scale.PollingInterval = &pollingInterval
	}

	// Set property "Rules":
	for _, item := range typedInput.Rules {
		var item1 JobScaleRule
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		scale.Rules = append(scale.Rules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_JobScale populates our JobScale from the provided source JobScale
func (scale *JobScale) AssignProperties_From_JobScale(source *storage.JobScale) error {

	// MaxExecutions
	scale.MaxExecutions = genruntime.ClonePointerToInt(source.MaxExecutions)

	// MinExecutions
	scale.MinExecutions = genruntime.ClonePointerToInt(source.MinExecutions)

	// PollingInterval
	scale.PollingInterval = genruntime.ClonePointerToInt(source.PollingInterval)

	// Rules
	if source.Rules != nil {
		ruleList := make([]JobScaleRule, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule JobScaleRule
			err := rule.AssignProperties_From_JobScaleRule(&ruleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_JobScaleRule() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		scale.Rules = ruleList
	} else {
		scale.Rules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_JobScale populates the provided destination JobScale from our JobScale
func (scale *JobScale) AssignProperties_To_JobScale(destination *storage.JobScale) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MaxExecutions
	destination.MaxExecutions = genruntime.ClonePointerToInt(scale.MaxExecutions)

	// MinExecutions
	destination.MinExecutions = genruntime.ClonePointerToInt(scale.MinExecutions)

	// PollingInterval
	destination.PollingInterval = genruntime.ClonePointerToInt(scale.PollingInterval)

	// Rules
	if scale.Rules != nil {
		ruleList := make([]storage.JobScaleRule, len(scale.Rules))
		for ruleIndex, ruleItem := range scale.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule storage.JobScaleRule
			err := ruleItem.AssignProperties_To_JobScaleRule(&rule)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_JobScaleRule() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_JobScale_STATUS populates our JobScale from the provided source JobScale_STATUS
func (scale *JobScale) Initialize_From_JobScale_STATUS(source *JobScale_STATUS) error {

	// MaxExecutions
	scale.MaxExecutions = genruntime.ClonePointerToInt(source.MaxExecutions)

	// MinExecutions
	scale.MinExecutions = genruntime.ClonePointerToInt(source.MinExecutions)

	// PollingInterval
	scale.PollingInterval = genruntime.ClonePointerToInt(source.PollingInterval)

	// Rules
	if source.Rules != nil {
		ruleList := make([]JobScaleRule, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule JobScaleRule
			err := rule.Initialize_From_JobScaleRule_STATUS(&ruleItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_JobScaleRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		scale.Rules = ruleList
	} else {
		scale.Rules = nil
	}

	// No error
	return nil
}

// Scaling configurations for event driven jobs.
type JobScale_STATUS struct {
	// MaxExecutions: Maximum number of job executions that are created for a trigger, default 100.
	MaxExecutions *int `json:"maxExecutions,omitempty"`

	// MinExecutions: Minimum number of job executions that are created for a trigger, default 0
	MinExecutions   *int `json:"minExecutions,omitempty"`
	PollingInterval *int `json:"pollingInterval,omitempty"`

	// Rules: Scaling rules.
	Rules []JobScaleRule_STATUS `json:"rules,omitempty"`
}

var _ genruntime.FromARMConverter = &JobScale_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (scale *JobScale_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.JobScale_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (scale *JobScale_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.JobScale_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.JobScale_STATUS, got %T", armInput)
	}

	// Set property "MaxExecutions":
	if typedInput.MaxExecutions != nil {
		maxExecutions := *typedInput.MaxExecutions
		scale.MaxExecutions = &maxExecutions
	}

	// Set property "MinExecutions":
	if typedInput.MinExecutions != nil {
		minExecutions := *typedInput.MinExecutions
		scale.MinExecutions = &minExecutions
	}

	// Set property "PollingInterval":
	if typedInput.PollingInterval != nil {
		pollingInterval := *typedInput.PollingInterval
		scale.PollingInterval = &pollingInterval
	}

	// Set property "Rules":
	for _, item := range typedInput.Rules {
		var item1 JobScaleRule_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		scale.Rules = append(scale.Rules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_JobScale_STATUS populates our JobScale_STATUS from the provided source JobScale_STATUS
func (scale *JobScale_STATUS) AssignProperties_From_JobScale_STATUS(source *storage.JobScale_STATUS) error {

	// MaxExecutions
	scale.MaxExecutions = genruntime.ClonePointerToInt(source.MaxExecutions)

	// MinExecutions
	scale.MinExecutions = genruntime.ClonePointerToInt(source.MinExecutions)

	// PollingInterval
	scale.PollingInterval = genruntime.ClonePointerToInt(source.PollingInterval)

	// Rules
	if source.Rules != nil {
		ruleList := make([]JobScaleRule_STATUS, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule JobScaleRule_STATUS
			err := rule.AssignProperties_From_JobScaleRule_STATUS(&ruleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_JobScaleRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		scale.Rules = ruleList
	} else {
		scale.Rules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_JobScale_STATUS populates the provided destination JobScale_STATUS from our JobScale_STATUS
func (scale *JobScale_STATUS) AssignProperties_To_JobScale_STATUS(destination *storage.JobScale_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MaxExecutions
	destination.MaxExecutions = genruntime.ClonePointerToInt(scale.MaxExecutions)

	// MinExecutions
	destination.MinExecutions = genruntime.ClonePointerToInt(scale.MinExecutions)

	// PollingInterval
	destination.PollingInterval = genruntime.ClonePointerToInt(scale.PollingInterval)

	// Rules
	if scale.Rules != nil {
		ruleList := make([]storage.JobScaleRule_STATUS, len(scale.Rules))
		for ruleIndex, ruleItem := range scale.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule storage.JobScaleRule_STATUS
			err := ruleItem.AssignProperties_To_JobScaleRule_STATUS(&rule)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_JobScaleRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Scaling rule.
type JobScaleRule struct {
	// Auth: Authentication secrets for the scale rule.
	Auth []ScaleRuleAuth `json:"auth,omitempty"`

	// Metadata: Metadata properties to describe the scale rule.
	Metadata map[string]v1.JSON `json:"metadata,omitempty"`

	// Name: Scale Rule Name
	Name *string `json:"name,omitempty"`

	// Type: Type of the scale rule
	// eg: azure-servicebus, redis etc.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &JobScaleRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *JobScaleRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.JobScaleRule{}

	// Set property "Auth":
	for _, item := range rule.Auth {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Auth = append(result.Auth, *item_ARM.(*arm.ScaleRuleAuth))
	}

	// Set property "Metadata":
	if rule.Metadata != nil {
		result.Metadata = make(map[string]v1.JSON, len(rule.Metadata))
		for key, value := range rule.Metadata {
			result.Metadata[key] = *value.DeepCopy()
		}
	}

	// Set property "Name":
	if rule.Name != nil {
		name := *rule.Name
		result.Name = &name
	}

	// Set property "Type":
	if rule.Type != nil {
		typeVar := *rule.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *JobScaleRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.JobScaleRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *JobScaleRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.JobScaleRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.JobScaleRule, got %T", armInput)
	}

	// Set property "Auth":
	for _, item := range typedInput.Auth {
		var item1 ScaleRuleAuth
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		rule.Auth = append(rule.Auth, item1)
	}

	// Set property "Metadata":
	if typedInput.Metadata != nil {
		rule.Metadata = make(map[string]v1.JSON, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			rule.Metadata[key] = *value.DeepCopy()
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		rule.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_JobScaleRule populates our JobScaleRule from the provided source JobScaleRule
func (rule *JobScaleRule) AssignProperties_From_JobScaleRule(source *storage.JobScaleRule) error {

	// Auth
	if source.Auth != nil {
		authList := make([]ScaleRuleAuth, len(source.Auth))
		for authIndex, authItem := range source.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth ScaleRuleAuth
			err := auth.AssignProperties_From_ScaleRuleAuth(&authItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ScaleRuleAuth() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		rule.Auth = authList
	} else {
		rule.Auth = nil
	}

	// Metadata
	if source.Metadata != nil {
		metadatumMap := make(map[string]v1.JSON, len(source.Metadata))
		for metadatumKey, metadatumValue := range source.Metadata {
			// Shadow the loop variable to avoid aliasing
			metadatumValue := metadatumValue
			metadatumMap[metadatumKey] = *metadatumValue.DeepCopy()
		}
		rule.Metadata = metadatumMap
	} else {
		rule.Metadata = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	rule.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_JobScaleRule populates the provided destination JobScaleRule from our JobScaleRule
func (rule *JobScaleRule) AssignProperties_To_JobScaleRule(destination *storage.JobScaleRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Auth
	if rule.Auth != nil {
		authList := make([]storage.ScaleRuleAuth, len(rule.Auth))
		for authIndex, authItem := range rule.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth storage.ScaleRuleAuth
			err := authItem.AssignProperties_To_ScaleRuleAuth(&auth)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ScaleRuleAuth() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		destination.Auth = authList
	} else {
		destination.Auth = nil
	}

	// Metadata
	if rule.Metadata != nil {
		metadatumMap := make(map[string]v1.JSON, len(rule.Metadata))
		for metadatumKey, metadatumValue := range rule.Metadata {
			// Shadow the loop variable to avoid aliasing
			metadatumValue := metadatumValue
			metadatumMap[metadatumKey] = *metadatumValue.DeepCopy()
		}
		destination.Metadata = metadatumMap
	} else {
		destination.Metadata = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Type
	destination.Type = genruntime.ClonePointerToString(rule.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_JobScaleRule_STATUS populates our JobScaleRule from the provided source JobScaleRule_STATUS
func (rule *JobScaleRule) Initialize_From_JobScaleRule_STATUS(source *JobScaleRule_STATUS) error {

	// Auth
	if source.Auth != nil {
		authList := make([]ScaleRuleAuth, len(source.Auth))
		for authIndex, authItem := range source.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth ScaleRuleAuth
			err := auth.Initialize_From_ScaleRuleAuth_STATUS(&authItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_ScaleRuleAuth_STATUS() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		rule.Auth = authList
	} else {
		rule.Auth = nil
	}

	// Metadata
	if source.Metadata != nil {
		metadatumMap := make(map[string]v1.JSON, len(source.Metadata))
		for metadatumKey, metadatumValue := range source.Metadata {
			// Shadow the loop variable to avoid aliasing
			metadatumValue := metadatumValue
			metadatumMap[metadatumKey] = *metadatumValue.DeepCopy()
		}
		rule.Metadata = metadatumMap
	} else {
		rule.Metadata = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	rule.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// Scaling rule.
type JobScaleRule_STATUS struct {
	// Auth: Authentication secrets for the scale rule.
	Auth []ScaleRuleAuth_STATUS `json:"auth,omitempty"`

	// Metadata: Metadata properties to describe the scale rule.
	Metadata map[string]v1.JSON `json:"metadata,omitempty"`

	// Name: Scale Rule Name
	Name *string `json:"name,omitempty"`

	// Type: Type of the scale rule
	// eg: azure-servicebus, redis etc.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &JobScaleRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *JobScaleRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.JobScaleRule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *JobScaleRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.JobScaleRule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.JobScaleRule_STATUS, got %T", armInput)
	}

	// Set property "Auth":
	for _, item := range typedInput.Auth {
		var item1 ScaleRuleAuth_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		rule.Auth = append(rule.Auth, item1)
	}

	// Set property "Metadata":
	if typedInput.Metadata != nil {
		rule.Metadata = make(map[string]v1.JSON, len(typedInput.Metadata))
		for key, value := range typedInput.Metadata {
			rule.Metadata[key] = *value.DeepCopy()
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		rule.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_JobScaleRule_STATUS populates our JobScaleRule_STATUS from the provided source JobScaleRule_STATUS
func (rule *JobScaleRule_STATUS) AssignProperties_From_JobScaleRule_STATUS(source *storage.JobScaleRule_STATUS) error {

	// Auth
	if source.Auth != nil {
		authList := make([]ScaleRuleAuth_STATUS, len(source.Auth))
		for authIndex, authItem := range source.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth ScaleRuleAuth_STATUS
			err := auth.AssignProperties_From_ScaleRuleAuth_STATUS(&authItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ScaleRuleAuth_STATUS() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		rule.Auth = authList
	} else {
		rule.Auth = nil
	}

	// Metadata
	if source.Metadata != nil {
		metadatumMap := make(map[string]v1.JSON, len(source.Metadata))
		for metadatumKey, metadatumValue := range source.Metadata {
			// Shadow the loop variable to avoid aliasing
			metadatumValue := metadatumValue
			metadatumMap[metadatumKey] = *metadatumValue.DeepCopy()
		}
		rule.Metadata = metadatumMap
	} else {
		rule.Metadata = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	rule.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_JobScaleRule_STATUS populates the provided destination JobScaleRule_STATUS from our JobScaleRule_STATUS
func (rule *JobScaleRule_STATUS) AssignProperties_To_JobScaleRule_STATUS(destination *storage.JobScaleRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Auth
	if rule.Auth != nil {
		authList := make([]storage.ScaleRuleAuth_STATUS, len(rule.Auth))
		for authIndex, authItem := range rule.Auth {
			// Shadow the loop variable to avoid aliasing
			authItem := authItem
			var auth storage.ScaleRuleAuth_STATUS
			err := authItem.AssignProperties_To_ScaleRuleAuth_STATUS(&auth)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ScaleRuleAuth_STATUS() to populate field Auth")
			}
			authList[authIndex] = auth
		}
		destination.Auth = authList
	} else {
		destination.Auth = nil
	}

	// Metadata
	if rule.Metadata != nil {
		metadatumMap := make(map[string]v1.JSON, len(rule.Metadata))
		for metadatumKey, metadatumValue := range rule.Metadata {
			// Shadow the loop variable to avoid aliasing
			metadatumValue := metadatumValue
			metadatumMap[metadatumKey] = *metadatumValue.DeepCopy()
		}
		destination.Metadata = metadatumMap
	} else {
		destination.Metadata = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Type
	destination.Type = genruntime.ClonePointerToString(rule.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&Job{}, &JobList{})
}
