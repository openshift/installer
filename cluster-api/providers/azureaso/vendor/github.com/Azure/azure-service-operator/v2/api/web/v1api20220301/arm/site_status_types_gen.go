// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

// A web app, a mobile app backend, or an API app.
type Site_STATUS struct {
	// ExtendedLocation: Extended Location.
	ExtendedLocation *ExtendedLocation_STATUS `json:"extendedLocation,omitempty"`

	// Id: Resource Id.
	Id *string `json:"id,omitempty"`

	// Identity: Managed service identity.
	Identity *ManagedServiceIdentity_STATUS `json:"identity,omitempty"`

	// Kind: Kind of resource.
	Kind *string `json:"kind,omitempty"`

	// Location: Resource Location.
	Location *string `json:"location,omitempty"`

	// Name: Resource Name.
	Name *string `json:"name,omitempty"`

	// Properties: Site resource specific properties
	Properties *Site_Properties_STATUS `json:"properties,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: Resource type.
	Type *string `json:"type,omitempty"`
}

// Managed service identity.
type ManagedServiceIdentity_STATUS struct {
	// PrincipalId: Principal Id of managed service identity.
	PrincipalId *string `json:"principalId,omitempty"`

	// TenantId: Tenant of managed service identity.
	TenantId *string `json:"tenantId,omitempty"`

	// Type: Type of managed service identity.
	Type *ManagedServiceIdentity_Type_STATUS `json:"type,omitempty"`

	// UserAssignedIdentities: The list of user assigned identities associated with the resource. The user identity dictionary
	// key references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}
	UserAssignedIdentities map[string]UserAssignedIdentity_STATUS `json:"userAssignedIdentities,omitempty"`
}

type Site_Properties_STATUS struct {
	// AvailabilityState: Management information availability state for the app.
	AvailabilityState *Site_Properties_AvailabilityState_STATUS `json:"availabilityState,omitempty"`

	// ClientAffinityEnabled: <code>true</code> to enable client affinity; <code>false</code> to stop sending session affinity
	// cookies, which route client requests in the same session to the same instance. Default is <code>true</code>.
	ClientAffinityEnabled *bool `json:"clientAffinityEnabled,omitempty"`

	// ClientCertEnabled: <code>true</code> to enable client certificate authentication (TLS mutual authentication); otherwise,
	// <code>false</code>. Default is <code>false</code>.
	ClientCertEnabled *bool `json:"clientCertEnabled,omitempty"`

	// ClientCertExclusionPaths: client certificate authentication comma-separated exclusion paths
	ClientCertExclusionPaths *string `json:"clientCertExclusionPaths,omitempty"`

	// ClientCertMode: This composes with ClientCertEnabled setting.
	// - ClientCertEnabled: false means ClientCert is ignored.
	// - ClientCertEnabled: true and ClientCertMode: Required means ClientCert is required.
	// - ClientCertEnabled: true and ClientCertMode: Optional means ClientCert is optional or accepted.
	ClientCertMode *Site_Properties_ClientCertMode_STATUS `json:"clientCertMode,omitempty"`

	// CloningInfo: If specified during app creation, the app is cloned from a source app.
	CloningInfo *CloningInfo_STATUS `json:"cloningInfo,omitempty"`

	// ContainerSize: Size of the function container.
	ContainerSize *int `json:"containerSize,omitempty"`

	// CustomDomainVerificationId: Unique identifier that verifies the custom domains assigned to the app. Customer will add
	// this id to a txt record for verification.
	CustomDomainVerificationId *string `json:"customDomainVerificationId,omitempty"`

	// DailyMemoryTimeQuota: Maximum allowed daily memory-time quota (applicable on dynamic apps only).
	DailyMemoryTimeQuota *int `json:"dailyMemoryTimeQuota,omitempty"`

	// DefaultHostName: Default hostname of the app. Read-only.
	DefaultHostName *string `json:"defaultHostName,omitempty"`

	// Enabled: <code>true</code> if the app is enabled; otherwise, <code>false</code>. Setting this value to false disables
	// the app (takes the app offline).
	Enabled *bool `json:"enabled,omitempty"`

	// EnabledHostNames: Enabled hostnames for the app.Hostnames need to be assigned (see HostNames) AND enabled. Otherwise,
	// the app is not served on those hostnames.
	EnabledHostNames []string `json:"enabledHostNames,omitempty"`

	// HostNameSslStates: Hostname SSL states are used to manage the SSL bindings for app's hostnames.
	HostNameSslStates []HostNameSslState_STATUS `json:"hostNameSslStates,omitempty"`

	// HostNames: Hostnames associated with the app.
	HostNames []string `json:"hostNames,omitempty"`

	// HostNamesDisabled: <code>true</code> to disable the public hostnames of the app; otherwise, <code>false</code>.
	// If <code>true</code>, the app is only accessible via API management process.
	HostNamesDisabled *bool `json:"hostNamesDisabled,omitempty"`

	// HostingEnvironmentProfile: App Service Environment to use for the app.
	HostingEnvironmentProfile *HostingEnvironmentProfile_STATUS `json:"hostingEnvironmentProfile,omitempty"`

	// HttpsOnly: HttpsOnly: configures a web site to accept only https requests. Issues redirect for
	// http requests
	HttpsOnly *bool `json:"httpsOnly,omitempty"`

	// HyperV: Hyper-V sandbox.
	HyperV *bool `json:"hyperV,omitempty"`

	// InProgressOperationId: Specifies an operation id if this site has a pending operation.
	InProgressOperationId *string `json:"inProgressOperationId,omitempty"`

	// IsDefaultContainer: <code>true</code> if the app is a default container; otherwise, <code>false</code>.
	IsDefaultContainer *bool `json:"isDefaultContainer,omitempty"`

	// IsXenon: Obsolete: Hyper-V sandbox.
	IsXenon *bool `json:"isXenon,omitempty"`

	// KeyVaultReferenceIdentity: Identity to use for Key Vault Reference authentication.
	KeyVaultReferenceIdentity *string `json:"keyVaultReferenceIdentity,omitempty"`

	// LastModifiedTimeUtc: Last time the app was modified, in UTC. Read-only.
	LastModifiedTimeUtc *string `json:"lastModifiedTimeUtc,omitempty"`

	// MaxNumberOfWorkers: Maximum number of workers.
	// This only applies to Functions container.
	MaxNumberOfWorkers *int `json:"maxNumberOfWorkers,omitempty"`

	// OutboundIpAddresses: List of IP addresses that the app uses for outbound connections (e.g. database access). Includes
	// VIPs from tenants that site can be hosted with current settings. Read-only.
	OutboundIpAddresses *string `json:"outboundIpAddresses,omitempty"`

	// PossibleOutboundIpAddresses: List of IP addresses that the app uses for outbound connections (e.g. database access).
	// Includes VIPs from all tenants except dataComponent. Read-only.
	PossibleOutboundIpAddresses *string `json:"possibleOutboundIpAddresses,omitempty"`

	// PublicNetworkAccess: Property to allow or block all public traffic. Allowed Values: 'Enabled', 'Disabled' or an empty
	// string.
	PublicNetworkAccess *string `json:"publicNetworkAccess,omitempty"`

	// RedundancyMode: Site redundancy mode
	RedundancyMode *Site_Properties_RedundancyMode_STATUS `json:"redundancyMode,omitempty"`

	// RepositorySiteName: Name of the repository site.
	RepositorySiteName *string `json:"repositorySiteName,omitempty"`

	// Reserved: <code>true</code> if reserved; otherwise, <code>false</code>.
	Reserved *bool `json:"reserved,omitempty"`

	// ResourceGroup: Name of the resource group the app belongs to. Read-only.
	ResourceGroup *string `json:"resourceGroup,omitempty"`

	// ScmSiteAlsoStopped: <code>true</code> to stop SCM (KUDU) site when the app is stopped; otherwise, <code>false</code>.
	// The default is <code>false</code>.
	ScmSiteAlsoStopped *bool `json:"scmSiteAlsoStopped,omitempty"`

	// ServerFarmId: Resource ID of the associated App Service plan, formatted as:
	// "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
	ServerFarmId *string `json:"serverFarmId,omitempty"`

	// SiteConfig: Configuration of the app.
	SiteConfig *SiteConfig_STATUS `json:"siteConfig,omitempty"`

	// SlotSwapStatus: Status of the last deployment slot swap operation.
	SlotSwapStatus *SlotSwapStatus_STATUS `json:"slotSwapStatus,omitempty"`

	// State: Current state of the app.
	State *string `json:"state,omitempty"`

	// StorageAccountRequired: Checks if Customer provided storage account is required
	StorageAccountRequired *bool `json:"storageAccountRequired,omitempty"`

	// SuspendedTill: App suspended till in case memory-time quota is exceeded.
	SuspendedTill *string `json:"suspendedTill,omitempty"`

	// TargetSwapSlot: Specifies which deployment slot this app will swap into. Read-only.
	TargetSwapSlot *string `json:"targetSwapSlot,omitempty"`

	// TrafficManagerHostNames: Azure Traffic Manager hostnames associated with the app. Read-only.
	TrafficManagerHostNames []string `json:"trafficManagerHostNames,omitempty"`

	// UsageState: State indicating whether the app has exceeded its quota usage. Read-only.
	UsageState *Site_Properties_UsageState_STATUS `json:"usageState,omitempty"`

	// VirtualNetworkSubnetId: Azure Resource Manager ID of the Virtual network and subnet to be joined by Regional VNET
	// Integration.
	// This must be of the form
	// /subscriptions/{subscriptionName}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}
	VirtualNetworkSubnetId *string `json:"virtualNetworkSubnetId,omitempty"`

	// VnetContentShareEnabled: To enable accessing content over virtual network
	VnetContentShareEnabled *bool `json:"vnetContentShareEnabled,omitempty"`

	// VnetImagePullEnabled: To enable pulling image over Virtual Network
	VnetImagePullEnabled *bool `json:"vnetImagePullEnabled,omitempty"`

	// VnetRouteAllEnabled: Virtual Network Route All enabled. This causes all outbound traffic to have Virtual Network
	// Security Groups and User Defined Routes applied.
	VnetRouteAllEnabled *bool `json:"vnetRouteAllEnabled,omitempty"`
}

// Information needed for cloning operation.
type CloningInfo_STATUS struct {
	// AppSettingsOverrides: Application setting overrides for cloned app. If specified, these settings override the settings
	// cloned
	// from source app. Otherwise, application settings from source app are retained.
	AppSettingsOverrides map[string]string `json:"appSettingsOverrides,omitempty"`

	// CloneCustomHostNames: <code>true</code> to clone custom hostnames from source app; otherwise, <code>false</code>.
	CloneCustomHostNames *bool `json:"cloneCustomHostNames,omitempty"`

	// CloneSourceControl: <code>true</code> to clone source control from source app; otherwise, <code>false</code>.
	CloneSourceControl *bool `json:"cloneSourceControl,omitempty"`

	// ConfigureLoadBalancing: <code>true</code> to configure load balancing for source and destination app.
	ConfigureLoadBalancing *bool `json:"configureLoadBalancing,omitempty"`

	// CorrelationId: Correlation ID of cloning operation. This ID ties multiple cloning operations
	// together to use the same snapshot.
	CorrelationId *string `json:"correlationId,omitempty"`

	// HostingEnvironment: App Service Environment.
	HostingEnvironment *string `json:"hostingEnvironment,omitempty"`

	// Overwrite: <code>true</code> to overwrite destination app; otherwise, <code>false</code>.
	Overwrite *bool `json:"overwrite,omitempty"`

	// SourceWebAppId: ARM resource ID of the source app. App resource ID is of the form
	// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName} for production slots
	// and
	// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName} for
	// other slots.
	SourceWebAppId *string `json:"sourceWebAppId,omitempty"`

	// SourceWebAppLocation: Location of source app ex: West US or North Europe
	SourceWebAppLocation *string `json:"sourceWebAppLocation,omitempty"`

	// TrafficManagerProfileId: ARM resource ID of the Traffic Manager profile to use, if it exists. Traffic Manager resource
	// ID is of the form
	// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
	TrafficManagerProfileId *string `json:"trafficManagerProfileId,omitempty"`

	// TrafficManagerProfileName: Name of Traffic Manager profile to create. This is only needed if Traffic Manager profile
	// does not already exist.
	TrafficManagerProfileName *string `json:"trafficManagerProfileName,omitempty"`
}

// SSL-enabled hostname.
type HostNameSslState_STATUS struct {
	// HostType: Indicates whether the hostname is a standard or repository hostname.
	HostType *HostNameSslState_HostType_STATUS `json:"hostType,omitempty"`

	// Name: Hostname.
	Name *string `json:"name,omitempty"`

	// SslState: SSL type.
	SslState *HostNameSslState_SslState_STATUS `json:"sslState,omitempty"`

	// Thumbprint: SSL certificate thumbprint.
	Thumbprint *string `json:"thumbprint,omitempty"`

	// ToUpdate: Set to <code>true</code> to update existing hostname.
	ToUpdate *bool `json:"toUpdate,omitempty"`

	// VirtualIP: Virtual IP address assigned to the hostname if IP based SSL is enabled.
	VirtualIP *string `json:"virtualIP,omitempty"`
}

type ManagedServiceIdentity_Type_STATUS string

const (
	ManagedServiceIdentity_Type_STATUS_None                       = ManagedServiceIdentity_Type_STATUS("None")
	ManagedServiceIdentity_Type_STATUS_SystemAssigned             = ManagedServiceIdentity_Type_STATUS("SystemAssigned")
	ManagedServiceIdentity_Type_STATUS_SystemAssignedUserAssigned = ManagedServiceIdentity_Type_STATUS("SystemAssigned, UserAssigned")
	ManagedServiceIdentity_Type_STATUS_UserAssigned               = ManagedServiceIdentity_Type_STATUS("UserAssigned")
)

// Mapping from string to ManagedServiceIdentity_Type_STATUS
var managedServiceIdentity_Type_STATUS_Values = map[string]ManagedServiceIdentity_Type_STATUS{
	"none":                         ManagedServiceIdentity_Type_STATUS_None,
	"systemassigned":               ManagedServiceIdentity_Type_STATUS_SystemAssigned,
	"systemassigned, userassigned": ManagedServiceIdentity_Type_STATUS_SystemAssignedUserAssigned,
	"userassigned":                 ManagedServiceIdentity_Type_STATUS_UserAssigned,
}

type Site_Properties_AvailabilityState_STATUS string

const (
	Site_Properties_AvailabilityState_STATUS_DisasterRecoveryMode = Site_Properties_AvailabilityState_STATUS("DisasterRecoveryMode")
	Site_Properties_AvailabilityState_STATUS_Limited              = Site_Properties_AvailabilityState_STATUS("Limited")
	Site_Properties_AvailabilityState_STATUS_Normal               = Site_Properties_AvailabilityState_STATUS("Normal")
)

// Mapping from string to Site_Properties_AvailabilityState_STATUS
var site_Properties_AvailabilityState_STATUS_Values = map[string]Site_Properties_AvailabilityState_STATUS{
	"disasterrecoverymode": Site_Properties_AvailabilityState_STATUS_DisasterRecoveryMode,
	"limited":              Site_Properties_AvailabilityState_STATUS_Limited,
	"normal":               Site_Properties_AvailabilityState_STATUS_Normal,
}

type Site_Properties_ClientCertMode_STATUS string

const (
	Site_Properties_ClientCertMode_STATUS_Optional                = Site_Properties_ClientCertMode_STATUS("Optional")
	Site_Properties_ClientCertMode_STATUS_OptionalInteractiveUser = Site_Properties_ClientCertMode_STATUS("OptionalInteractiveUser")
	Site_Properties_ClientCertMode_STATUS_Required                = Site_Properties_ClientCertMode_STATUS("Required")
)

// Mapping from string to Site_Properties_ClientCertMode_STATUS
var site_Properties_ClientCertMode_STATUS_Values = map[string]Site_Properties_ClientCertMode_STATUS{
	"optional":                Site_Properties_ClientCertMode_STATUS_Optional,
	"optionalinteractiveuser": Site_Properties_ClientCertMode_STATUS_OptionalInteractiveUser,
	"required":                Site_Properties_ClientCertMode_STATUS_Required,
}

type Site_Properties_RedundancyMode_STATUS string

const (
	Site_Properties_RedundancyMode_STATUS_ActiveActive = Site_Properties_RedundancyMode_STATUS("ActiveActive")
	Site_Properties_RedundancyMode_STATUS_Failover     = Site_Properties_RedundancyMode_STATUS("Failover")
	Site_Properties_RedundancyMode_STATUS_GeoRedundant = Site_Properties_RedundancyMode_STATUS("GeoRedundant")
	Site_Properties_RedundancyMode_STATUS_Manual       = Site_Properties_RedundancyMode_STATUS("Manual")
	Site_Properties_RedundancyMode_STATUS_None         = Site_Properties_RedundancyMode_STATUS("None")
)

// Mapping from string to Site_Properties_RedundancyMode_STATUS
var site_Properties_RedundancyMode_STATUS_Values = map[string]Site_Properties_RedundancyMode_STATUS{
	"activeactive": Site_Properties_RedundancyMode_STATUS_ActiveActive,
	"failover":     Site_Properties_RedundancyMode_STATUS_Failover,
	"georedundant": Site_Properties_RedundancyMode_STATUS_GeoRedundant,
	"manual":       Site_Properties_RedundancyMode_STATUS_Manual,
	"none":         Site_Properties_RedundancyMode_STATUS_None,
}

type Site_Properties_UsageState_STATUS string

const (
	Site_Properties_UsageState_STATUS_Exceeded = Site_Properties_UsageState_STATUS("Exceeded")
	Site_Properties_UsageState_STATUS_Normal   = Site_Properties_UsageState_STATUS("Normal")
)

// Mapping from string to Site_Properties_UsageState_STATUS
var site_Properties_UsageState_STATUS_Values = map[string]Site_Properties_UsageState_STATUS{
	"exceeded": Site_Properties_UsageState_STATUS_Exceeded,
	"normal":   Site_Properties_UsageState_STATUS_Normal,
}

// Configuration of an App Service app.
type SiteConfig_STATUS struct {
	// AcrUseManagedIdentityCreds: Flag to use Managed Identity Creds for ACR pull
	AcrUseManagedIdentityCreds *bool `json:"acrUseManagedIdentityCreds,omitempty"`

	// AcrUserManagedIdentityID: If using user managed identity, the user managed identity ClientId
	AcrUserManagedIdentityID *string `json:"acrUserManagedIdentityID,omitempty"`

	// AlwaysOn: <code>true</code> if Always On is enabled; otherwise, <code>false</code>.
	AlwaysOn *bool `json:"alwaysOn,omitempty"`

	// ApiDefinition: Information about the formal API definition for the app.
	ApiDefinition *ApiDefinitionInfo_STATUS `json:"apiDefinition,omitempty"`

	// ApiManagementConfig: Azure API management settings linked to the app.
	ApiManagementConfig *ApiManagementConfig_STATUS `json:"apiManagementConfig,omitempty"`

	// AppCommandLine: App command line to launch.
	AppCommandLine *string `json:"appCommandLine,omitempty"`

	// AppSettings: Application settings.
	AppSettings []NameValuePair_STATUS `json:"appSettings,omitempty"`

	// AutoHealEnabled: <code>true</code> if Auto Heal is enabled; otherwise, <code>false</code>.
	AutoHealEnabled *bool `json:"autoHealEnabled,omitempty"`

	// AutoHealRules: Auto Heal rules.
	AutoHealRules *AutoHealRules_STATUS `json:"autoHealRules,omitempty"`

	// AutoSwapSlotName: Auto-swap slot name.
	AutoSwapSlotName *string `json:"autoSwapSlotName,omitempty"`

	// AzureStorageAccounts: List of Azure Storage Accounts.
	AzureStorageAccounts map[string]AzureStorageInfoValue_STATUS `json:"azureStorageAccounts,omitempty"`

	// ConnectionStrings: Connection strings.
	ConnectionStrings []ConnStringInfo_STATUS `json:"connectionStrings,omitempty"`

	// Cors: Cross-Origin Resource Sharing (CORS) settings.
	Cors *CorsSettings_STATUS `json:"cors,omitempty"`

	// DefaultDocuments: Default documents.
	DefaultDocuments []string `json:"defaultDocuments,omitempty"`

	// DetailedErrorLoggingEnabled: <code>true</code> if detailed error logging is enabled; otherwise, <code>false</code>.
	DetailedErrorLoggingEnabled *bool `json:"detailedErrorLoggingEnabled,omitempty"`

	// DocumentRoot: Document root.
	DocumentRoot *string `json:"documentRoot,omitempty"`

	// Experiments: This is work around for polymorphic types.
	Experiments *Experiments_STATUS `json:"experiments,omitempty"`

	// FtpsState: State of FTP / FTPS service
	FtpsState *SiteConfig_FtpsState_STATUS `json:"ftpsState,omitempty"`

	// FunctionAppScaleLimit: Maximum number of workers that a site can scale out to.
	// This setting only applies to the Consumption and Elastic Premium Plans
	FunctionAppScaleLimit *int `json:"functionAppScaleLimit,omitempty"`

	// FunctionsRuntimeScaleMonitoringEnabled: Gets or sets a value indicating whether functions runtime scale monitoring is
	// enabled. When enabled,
	// the ScaleController will not monitor event sources directly, but will instead call to the
	// runtime to get scale status.
	FunctionsRuntimeScaleMonitoringEnabled *bool `json:"functionsRuntimeScaleMonitoringEnabled,omitempty"`

	// HandlerMappings: Handler mappings.
	HandlerMappings []HandlerMapping_STATUS `json:"handlerMappings,omitempty"`

	// HealthCheckPath: Health check path
	HealthCheckPath *string `json:"healthCheckPath,omitempty"`

	// Http20Enabled: Http20Enabled: configures a web site to allow clients to connect over http2.0
	Http20Enabled *bool `json:"http20Enabled,omitempty"`

	// HttpLoggingEnabled: <code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.
	HttpLoggingEnabled *bool `json:"httpLoggingEnabled,omitempty"`

	// IpSecurityRestrictions: IP security restrictions for main.
	IpSecurityRestrictions []IpSecurityRestriction_STATUS `json:"ipSecurityRestrictions,omitempty"`

	// JavaContainer: Java container.
	JavaContainer *string `json:"javaContainer,omitempty"`

	// JavaContainerVersion: Java container version.
	JavaContainerVersion *string `json:"javaContainerVersion,omitempty"`

	// JavaVersion: Java version.
	JavaVersion *string `json:"javaVersion,omitempty"`

	// KeyVaultReferenceIdentity: Identity to use for Key Vault Reference authentication.
	KeyVaultReferenceIdentity *string `json:"keyVaultReferenceIdentity,omitempty"`

	// Limits: Site limits.
	Limits *SiteLimits_STATUS `json:"limits,omitempty"`

	// LinuxFxVersion: Linux App Framework and version
	LinuxFxVersion *string `json:"linuxFxVersion,omitempty"`

	// LoadBalancing: Site load balancing.
	LoadBalancing *SiteConfig_LoadBalancing_STATUS `json:"loadBalancing,omitempty"`

	// LocalMySqlEnabled: <code>true</code> to enable local MySQL; otherwise, <code>false</code>.
	LocalMySqlEnabled *bool `json:"localMySqlEnabled,omitempty"`

	// LogsDirectorySizeLimit: HTTP logs directory size limit.
	LogsDirectorySizeLimit *int `json:"logsDirectorySizeLimit,omitempty"`

	// MachineKey: Site MachineKey.
	MachineKey *SiteMachineKey_STATUS `json:"machineKey,omitempty"`

	// ManagedPipelineMode: Managed pipeline mode.
	ManagedPipelineMode *SiteConfig_ManagedPipelineMode_STATUS `json:"managedPipelineMode,omitempty"`

	// ManagedServiceIdentityId: Managed Service Identity Id
	ManagedServiceIdentityId *int `json:"managedServiceIdentityId,omitempty"`

	// MinTlsVersion: MinTlsVersion: configures the minimum version of TLS required for SSL requests
	MinTlsVersion *SiteConfig_MinTlsVersion_STATUS `json:"minTlsVersion,omitempty"`

	// MinimumElasticInstanceCount: Number of minimum instance count for a site
	// This setting only applies to the Elastic Plans
	MinimumElasticInstanceCount *int `json:"minimumElasticInstanceCount,omitempty"`

	// NetFrameworkVersion: .NET Framework version.
	NetFrameworkVersion *string `json:"netFrameworkVersion,omitempty"`

	// NodeVersion: Version of Node.js.
	NodeVersion *string `json:"nodeVersion,omitempty"`

	// NumberOfWorkers: Number of workers.
	NumberOfWorkers *int `json:"numberOfWorkers,omitempty"`

	// PhpVersion: Version of PHP.
	PhpVersion *string `json:"phpVersion,omitempty"`

	// PowerShellVersion: Version of PowerShell.
	PowerShellVersion *string `json:"powerShellVersion,omitempty"`

	// PreWarmedInstanceCount: Number of preWarmed instances.
	// This setting only applies to the Consumption and Elastic Plans
	PreWarmedInstanceCount *int `json:"preWarmedInstanceCount,omitempty"`

	// PublicNetworkAccess: Property to allow or block all public traffic.
	PublicNetworkAccess *string `json:"publicNetworkAccess,omitempty"`

	// PublishingUsername: Publishing user name.
	PublishingUsername *string `json:"publishingUsername,omitempty"`

	// Push: Push endpoint settings.
	Push *PushSettings_STATUS `json:"push,omitempty"`

	// PythonVersion: Version of Python.
	PythonVersion *string `json:"pythonVersion,omitempty"`

	// RemoteDebuggingEnabled: <code>true</code> if remote debugging is enabled; otherwise, <code>false</code>.
	RemoteDebuggingEnabled *bool `json:"remoteDebuggingEnabled,omitempty"`

	// RemoteDebuggingVersion: Remote debugging version.
	RemoteDebuggingVersion *string `json:"remoteDebuggingVersion,omitempty"`

	// RequestTracingEnabled: <code>true</code> if request tracing is enabled; otherwise, <code>false</code>.
	RequestTracingEnabled *bool `json:"requestTracingEnabled,omitempty"`

	// RequestTracingExpirationTime: Request tracing expiration time.
	RequestTracingExpirationTime *string `json:"requestTracingExpirationTime,omitempty"`

	// ScmIpSecurityRestrictions: IP security restrictions for scm.
	ScmIpSecurityRestrictions []IpSecurityRestriction_STATUS `json:"scmIpSecurityRestrictions,omitempty"`

	// ScmIpSecurityRestrictionsUseMain: IP security restrictions for scm to use main.
	ScmIpSecurityRestrictionsUseMain *bool `json:"scmIpSecurityRestrictionsUseMain,omitempty"`

	// ScmMinTlsVersion: ScmMinTlsVersion: configures the minimum version of TLS required for SSL requests for SCM site
	ScmMinTlsVersion *SiteConfig_ScmMinTlsVersion_STATUS `json:"scmMinTlsVersion,omitempty"`

	// ScmType: SCM type.
	ScmType *SiteConfig_ScmType_STATUS `json:"scmType,omitempty"`

	// TracingOptions: Tracing options.
	TracingOptions *string `json:"tracingOptions,omitempty"`

	// Use32BitWorkerProcess: <code>true</code> to use 32-bit worker process; otherwise, <code>false</code>.
	Use32BitWorkerProcess *bool `json:"use32BitWorkerProcess,omitempty"`

	// VirtualApplications: Virtual applications.
	VirtualApplications []VirtualApplication_STATUS `json:"virtualApplications,omitempty"`

	// VnetName: Virtual Network name.
	VnetName *string `json:"vnetName,omitempty"`

	// VnetPrivatePortsCount: The number of private ports assigned to this app. These will be assigned dynamically on runtime.
	VnetPrivatePortsCount *int `json:"vnetPrivatePortsCount,omitempty"`

	// VnetRouteAllEnabled: Virtual Network Route All enabled. This causes all outbound traffic to have Virtual Network
	// Security Groups and User Defined Routes applied.
	VnetRouteAllEnabled *bool `json:"vnetRouteAllEnabled,omitempty"`

	// WebSocketsEnabled: <code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.
	WebSocketsEnabled *bool `json:"webSocketsEnabled,omitempty"`

	// WebsiteTimeZone: Sets the time zone a site uses for generating timestamps. Compatible with Linux and Windows App
	// Service. Setting the WEBSITE_TIME_ZONE app setting takes precedence over this config. For Linux, expects tz database
	// values https://www.iana.org/time-zones (for a quick reference see
	// https://en.wikipedia.org/wiki/List_of_tz_database_time_zones). For Windows, expects one of the time zones listed under
	// HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Time Zones
	WebsiteTimeZone *string `json:"websiteTimeZone,omitempty"`

	// WindowsFxVersion: Xenon App Framework and version
	WindowsFxVersion *string `json:"windowsFxVersion,omitempty"`

	// XManagedServiceIdentityId: Explicit Managed Service Identity Id
	XManagedServiceIdentityId *int `json:"xManagedServiceIdentityId,omitempty"`
}

// The status of the last successful slot swap operation.
type SlotSwapStatus_STATUS struct {
	// DestinationSlotName: The destination slot of the last swap operation.
	DestinationSlotName *string `json:"destinationSlotName,omitempty"`

	// SourceSlotName: The source slot of the last swap operation.
	SourceSlotName *string `json:"sourceSlotName,omitempty"`

	// TimestampUtc: The time the last successful slot swap completed.
	TimestampUtc *string `json:"timestampUtc,omitempty"`
}

// User Assigned identity.
type UserAssignedIdentity_STATUS struct {
	// ClientId: Client Id of user assigned identity
	ClientId *string `json:"clientId,omitempty"`

	// PrincipalId: Principal Id of user assigned identity
	PrincipalId *string `json:"principalId,omitempty"`
}

// Information about the formal API definition for the app.
type ApiDefinitionInfo_STATUS struct {
	// Url: The URL of the API definition.
	Url *string `json:"url,omitempty"`
}

// Azure API management (APIM) configuration linked to the app.
type ApiManagementConfig_STATUS struct {
	// Id: APIM-Api Identifier.
	Id *string `json:"id,omitempty"`
}

// Rules that can be defined for auto-heal.
type AutoHealRules_STATUS struct {
	// Actions: Actions to be executed when a rule is triggered.
	Actions *AutoHealActions_STATUS `json:"actions,omitempty"`

	// Triggers: Conditions that describe when to execute the auto-heal actions.
	Triggers *AutoHealTriggers_STATUS `json:"triggers,omitempty"`
}

// Azure Files or Blob Storage access information value for dictionary storage.
type AzureStorageInfoValue_STATUS struct {
	// AccountName: Name of the storage account.
	AccountName *string `json:"accountName,omitempty"`

	// MountPath: Path to mount the storage within the site's runtime environment.
	MountPath *string `json:"mountPath,omitempty"`

	// ShareName: Name of the file share (container name, for Blob storage).
	ShareName *string `json:"shareName,omitempty"`

	// State: State of the storage account.
	State *AzureStorageInfoValue_State_STATUS `json:"state,omitempty"`

	// Type: Type of storage.
	Type *AzureStorageInfoValue_Type_STATUS `json:"type,omitempty"`
}

// Database connection string information.
type ConnStringInfo_STATUS struct {
	// ConnectionString: Connection string value.
	ConnectionString *string `json:"connectionString,omitempty"`

	// Name: Name of connection string.
	Name *string `json:"name,omitempty"`

	// Type: Type of database.
	Type *ConnStringInfo_Type_STATUS `json:"type,omitempty"`
}

// Cross-Origin Resource Sharing (CORS) settings for the app.
type CorsSettings_STATUS struct {
	// AllowedOrigins: Gets or sets the list of origins that should be allowed to make cross-origin
	// calls (for example: http://example.com:12345). Use "*" to allow all.
	AllowedOrigins []string `json:"allowedOrigins,omitempty"`

	// SupportCredentials: Gets or sets whether CORS requests with credentials are allowed. See
	// https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Requests_with_credentials
	// for more details.
	SupportCredentials *bool `json:"supportCredentials,omitempty"`
}

// Routing rules in production experiments.
type Experiments_STATUS struct {
	// RampUpRules: List of ramp-up rules.
	RampUpRules []RampUpRule_STATUS `json:"rampUpRules,omitempty"`
}

// The IIS handler mappings used to define which handler processes HTTP requests with certain extension.
// For example, it
// is used to configure php-cgi.exe process to handle all HTTP requests with *.php extension.
type HandlerMapping_STATUS struct {
	// Arguments: Command-line arguments to be passed to the script processor.
	Arguments *string `json:"arguments,omitempty"`

	// Extension: Requests with this extension will be handled using the specified FastCGI application.
	Extension *string `json:"extension,omitempty"`

	// ScriptProcessor: The absolute path to the FastCGI application.
	ScriptProcessor *string `json:"scriptProcessor,omitempty"`
}

type HostNameSslState_HostType_STATUS string

const (
	HostNameSslState_HostType_STATUS_Repository = HostNameSslState_HostType_STATUS("Repository")
	HostNameSslState_HostType_STATUS_Standard   = HostNameSslState_HostType_STATUS("Standard")
)

// Mapping from string to HostNameSslState_HostType_STATUS
var hostNameSslState_HostType_STATUS_Values = map[string]HostNameSslState_HostType_STATUS{
	"repository": HostNameSslState_HostType_STATUS_Repository,
	"standard":   HostNameSslState_HostType_STATUS_Standard,
}

type HostNameSslState_SslState_STATUS string

const (
	HostNameSslState_SslState_STATUS_Disabled       = HostNameSslState_SslState_STATUS("Disabled")
	HostNameSslState_SslState_STATUS_IpBasedEnabled = HostNameSslState_SslState_STATUS("IpBasedEnabled")
	HostNameSslState_SslState_STATUS_SniEnabled     = HostNameSslState_SslState_STATUS("SniEnabled")
)

// Mapping from string to HostNameSslState_SslState_STATUS
var hostNameSslState_SslState_STATUS_Values = map[string]HostNameSslState_SslState_STATUS{
	"disabled":       HostNameSslState_SslState_STATUS_Disabled,
	"ipbasedenabled": HostNameSslState_SslState_STATUS_IpBasedEnabled,
	"snienabled":     HostNameSslState_SslState_STATUS_SniEnabled,
}

// IP security restriction on an app.
type IpSecurityRestriction_STATUS struct {
	// Action: Allow or Deny access for this IP range.
	Action *string `json:"action,omitempty"`

	// Description: IP restriction rule description.
	Description *string `json:"description,omitempty"`

	// Headers: IP restriction rule headers.
	// X-Forwarded-Host (https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Host#Examples).
	// The matching logic is ..
	// - If the property is null or empty (default), all hosts(or lack of) are allowed.
	// - A value is compared using ordinal-ignore-case (excluding port number).
	// - Subdomain wildcards are permitted but don't match the root domain. For example, *.contoso.com matches the subdomain
	// foo.contoso.com
	// but not the root domain contoso.com or multi-level foo.bar.contoso.com
	// - Unicode host names are allowed but are converted to Punycode for matching.
	// X-Forwarded-For (https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For#Examples).
	// The matching logic is ..
	// - If the property is null or empty (default), any forwarded-for chains (or lack of) are allowed.
	// - If any address (excluding port number) in the chain (comma separated) matches the CIDR defined by the property.
	// X-Azure-FDID and X-FD-HealthProbe.
	// The matching logic is exact match.
	Headers map[string][]string `json:"headers,omitempty"`

	// IpAddress: IP address the security restriction is valid for.
	// It can be in form of pure ipv4 address (required SubnetMask property) or
	// CIDR notation such as ipv4/mask (leading bit match). For CIDR,
	// SubnetMask property must not be specified.
	IpAddress *string `json:"ipAddress,omitempty"`

	// Name: IP restriction rule name.
	Name *string `json:"name,omitempty"`

	// Priority: Priority of IP restriction rule.
	Priority *int `json:"priority,omitempty"`

	// SubnetMask: Subnet mask for the range of IP addresses the restriction is valid for.
	SubnetMask *string `json:"subnetMask,omitempty"`

	// SubnetTrafficTag: (internal) Subnet traffic tag
	SubnetTrafficTag *int `json:"subnetTrafficTag,omitempty"`

	// Tag: Defines what this IP filter will be used for. This is to support IP filtering on proxies.
	Tag *IpSecurityRestriction_Tag_STATUS `json:"tag,omitempty"`

	// VnetSubnetResourceId: Virtual network resource id
	VnetSubnetResourceId *string `json:"vnetSubnetResourceId,omitempty"`

	// VnetTrafficTag: (internal) Vnet traffic tag
	VnetTrafficTag *int `json:"vnetTrafficTag,omitempty"`
}

// Name value pair.
type NameValuePair_STATUS struct {
	// Name: Pair name.
	Name *string `json:"name,omitempty"`

	// Value: Pair value.
	Value *string `json:"value,omitempty"`
}

// Push settings for the App.
type PushSettings_STATUS struct {
	// Id: Resource Id.
	Id *string `json:"id,omitempty"`

	// Kind: Kind of resource.
	Kind *string `json:"kind,omitempty"`

	// Name: Resource Name.
	Name *string `json:"name,omitempty"`

	// Properties: PushSettings resource specific properties
	Properties *PushSettings_Properties_STATUS `json:"properties,omitempty"`

	// Type: Resource type.
	Type *string `json:"type,omitempty"`
}

type SiteConfig_FtpsState_STATUS string

const (
	SiteConfig_FtpsState_STATUS_AllAllowed = SiteConfig_FtpsState_STATUS("AllAllowed")
	SiteConfig_FtpsState_STATUS_Disabled   = SiteConfig_FtpsState_STATUS("Disabled")
	SiteConfig_FtpsState_STATUS_FtpsOnly   = SiteConfig_FtpsState_STATUS("FtpsOnly")
)

// Mapping from string to SiteConfig_FtpsState_STATUS
var siteConfig_FtpsState_STATUS_Values = map[string]SiteConfig_FtpsState_STATUS{
	"allallowed": SiteConfig_FtpsState_STATUS_AllAllowed,
	"disabled":   SiteConfig_FtpsState_STATUS_Disabled,
	"ftpsonly":   SiteConfig_FtpsState_STATUS_FtpsOnly,
}

type SiteConfig_LoadBalancing_STATUS string

const (
	SiteConfig_LoadBalancing_STATUS_LeastRequests        = SiteConfig_LoadBalancing_STATUS("LeastRequests")
	SiteConfig_LoadBalancing_STATUS_LeastResponseTime    = SiteConfig_LoadBalancing_STATUS("LeastResponseTime")
	SiteConfig_LoadBalancing_STATUS_PerSiteRoundRobin    = SiteConfig_LoadBalancing_STATUS("PerSiteRoundRobin")
	SiteConfig_LoadBalancing_STATUS_RequestHash          = SiteConfig_LoadBalancing_STATUS("RequestHash")
	SiteConfig_LoadBalancing_STATUS_WeightedRoundRobin   = SiteConfig_LoadBalancing_STATUS("WeightedRoundRobin")
	SiteConfig_LoadBalancing_STATUS_WeightedTotalTraffic = SiteConfig_LoadBalancing_STATUS("WeightedTotalTraffic")
)

// Mapping from string to SiteConfig_LoadBalancing_STATUS
var siteConfig_LoadBalancing_STATUS_Values = map[string]SiteConfig_LoadBalancing_STATUS{
	"leastrequests":        SiteConfig_LoadBalancing_STATUS_LeastRequests,
	"leastresponsetime":    SiteConfig_LoadBalancing_STATUS_LeastResponseTime,
	"persiteroundrobin":    SiteConfig_LoadBalancing_STATUS_PerSiteRoundRobin,
	"requesthash":          SiteConfig_LoadBalancing_STATUS_RequestHash,
	"weightedroundrobin":   SiteConfig_LoadBalancing_STATUS_WeightedRoundRobin,
	"weightedtotaltraffic": SiteConfig_LoadBalancing_STATUS_WeightedTotalTraffic,
}

type SiteConfig_ManagedPipelineMode_STATUS string

const (
	SiteConfig_ManagedPipelineMode_STATUS_Classic    = SiteConfig_ManagedPipelineMode_STATUS("Classic")
	SiteConfig_ManagedPipelineMode_STATUS_Integrated = SiteConfig_ManagedPipelineMode_STATUS("Integrated")
)

// Mapping from string to SiteConfig_ManagedPipelineMode_STATUS
var siteConfig_ManagedPipelineMode_STATUS_Values = map[string]SiteConfig_ManagedPipelineMode_STATUS{
	"classic":    SiteConfig_ManagedPipelineMode_STATUS_Classic,
	"integrated": SiteConfig_ManagedPipelineMode_STATUS_Integrated,
}

type SiteConfig_MinTlsVersion_STATUS string

const (
	SiteConfig_MinTlsVersion_STATUS_10 = SiteConfig_MinTlsVersion_STATUS("1.0")
	SiteConfig_MinTlsVersion_STATUS_11 = SiteConfig_MinTlsVersion_STATUS("1.1")
	SiteConfig_MinTlsVersion_STATUS_12 = SiteConfig_MinTlsVersion_STATUS("1.2")
)

// Mapping from string to SiteConfig_MinTlsVersion_STATUS
var siteConfig_MinTlsVersion_STATUS_Values = map[string]SiteConfig_MinTlsVersion_STATUS{
	"1.0": SiteConfig_MinTlsVersion_STATUS_10,
	"1.1": SiteConfig_MinTlsVersion_STATUS_11,
	"1.2": SiteConfig_MinTlsVersion_STATUS_12,
}

type SiteConfig_ScmMinTlsVersion_STATUS string

const (
	SiteConfig_ScmMinTlsVersion_STATUS_10 = SiteConfig_ScmMinTlsVersion_STATUS("1.0")
	SiteConfig_ScmMinTlsVersion_STATUS_11 = SiteConfig_ScmMinTlsVersion_STATUS("1.1")
	SiteConfig_ScmMinTlsVersion_STATUS_12 = SiteConfig_ScmMinTlsVersion_STATUS("1.2")
)

// Mapping from string to SiteConfig_ScmMinTlsVersion_STATUS
var siteConfig_ScmMinTlsVersion_STATUS_Values = map[string]SiteConfig_ScmMinTlsVersion_STATUS{
	"1.0": SiteConfig_ScmMinTlsVersion_STATUS_10,
	"1.1": SiteConfig_ScmMinTlsVersion_STATUS_11,
	"1.2": SiteConfig_ScmMinTlsVersion_STATUS_12,
}

type SiteConfig_ScmType_STATUS string

const (
	SiteConfig_ScmType_STATUS_BitbucketGit = SiteConfig_ScmType_STATUS("BitbucketGit")
	SiteConfig_ScmType_STATUS_BitbucketHg  = SiteConfig_ScmType_STATUS("BitbucketHg")
	SiteConfig_ScmType_STATUS_CodePlexGit  = SiteConfig_ScmType_STATUS("CodePlexGit")
	SiteConfig_ScmType_STATUS_CodePlexHg   = SiteConfig_ScmType_STATUS("CodePlexHg")
	SiteConfig_ScmType_STATUS_Dropbox      = SiteConfig_ScmType_STATUS("Dropbox")
	SiteConfig_ScmType_STATUS_ExternalGit  = SiteConfig_ScmType_STATUS("ExternalGit")
	SiteConfig_ScmType_STATUS_ExternalHg   = SiteConfig_ScmType_STATUS("ExternalHg")
	SiteConfig_ScmType_STATUS_GitHub       = SiteConfig_ScmType_STATUS("GitHub")
	SiteConfig_ScmType_STATUS_LocalGit     = SiteConfig_ScmType_STATUS("LocalGit")
	SiteConfig_ScmType_STATUS_None         = SiteConfig_ScmType_STATUS("None")
	SiteConfig_ScmType_STATUS_OneDrive     = SiteConfig_ScmType_STATUS("OneDrive")
	SiteConfig_ScmType_STATUS_Tfs          = SiteConfig_ScmType_STATUS("Tfs")
	SiteConfig_ScmType_STATUS_VSO          = SiteConfig_ScmType_STATUS("VSO")
	SiteConfig_ScmType_STATUS_VSTSRM       = SiteConfig_ScmType_STATUS("VSTSRM")
)

// Mapping from string to SiteConfig_ScmType_STATUS
var siteConfig_ScmType_STATUS_Values = map[string]SiteConfig_ScmType_STATUS{
	"bitbucketgit": SiteConfig_ScmType_STATUS_BitbucketGit,
	"bitbuckethg":  SiteConfig_ScmType_STATUS_BitbucketHg,
	"codeplexgit":  SiteConfig_ScmType_STATUS_CodePlexGit,
	"codeplexhg":   SiteConfig_ScmType_STATUS_CodePlexHg,
	"dropbox":      SiteConfig_ScmType_STATUS_Dropbox,
	"externalgit":  SiteConfig_ScmType_STATUS_ExternalGit,
	"externalhg":   SiteConfig_ScmType_STATUS_ExternalHg,
	"github":       SiteConfig_ScmType_STATUS_GitHub,
	"localgit":     SiteConfig_ScmType_STATUS_LocalGit,
	"none":         SiteConfig_ScmType_STATUS_None,
	"onedrive":     SiteConfig_ScmType_STATUS_OneDrive,
	"tfs":          SiteConfig_ScmType_STATUS_Tfs,
	"vso":          SiteConfig_ScmType_STATUS_VSO,
	"vstsrm":       SiteConfig_ScmType_STATUS_VSTSRM,
}

// Metric limits set on an app.
type SiteLimits_STATUS struct {
	// MaxDiskSizeInMb: Maximum allowed disk size usage in MB.
	MaxDiskSizeInMb *int `json:"maxDiskSizeInMb,omitempty"`

	// MaxMemoryInMb: Maximum allowed memory usage in MB.
	MaxMemoryInMb *int `json:"maxMemoryInMb,omitempty"`

	// MaxPercentageCpu: Maximum allowed CPU usage percentage.
	MaxPercentageCpu *float64 `json:"maxPercentageCpu,omitempty"`
}

// MachineKey of an app.
type SiteMachineKey_STATUS struct {
	// Decryption: Algorithm used for decryption.
	Decryption *string `json:"decryption,omitempty"`

	// DecryptionKey: Decryption key.
	DecryptionKey *string `json:"decryptionKey,omitempty"`

	// Validation: MachineKey validation.
	Validation *string `json:"validation,omitempty"`

	// ValidationKey: Validation key.
	ValidationKey *string `json:"validationKey,omitempty"`
}

// Virtual application in an app.
type VirtualApplication_STATUS struct {
	// PhysicalPath: Physical path.
	PhysicalPath *string `json:"physicalPath,omitempty"`

	// PreloadEnabled: <code>true</code> if preloading is enabled; otherwise, <code>false</code>.
	PreloadEnabled *bool `json:"preloadEnabled,omitempty"`

	// VirtualDirectories: Virtual directories for virtual application.
	VirtualDirectories []VirtualDirectory_STATUS `json:"virtualDirectories,omitempty"`

	// VirtualPath: Virtual path.
	VirtualPath *string `json:"virtualPath,omitempty"`
}

// Actions which to take by the auto-heal module when a rule is triggered.
type AutoHealActions_STATUS struct {
	// ActionType: Predefined action to be taken.
	ActionType *AutoHealActions_ActionType_STATUS `json:"actionType,omitempty"`

	// CustomAction: Custom action to be taken.
	CustomAction *AutoHealCustomAction_STATUS `json:"customAction,omitempty"`

	// MinProcessExecutionTime: Minimum time the process must execute
	// before taking the action
	MinProcessExecutionTime *string `json:"minProcessExecutionTime,omitempty"`
}

// Triggers for auto-heal.
type AutoHealTriggers_STATUS struct {
	// PrivateBytesInKB: A rule based on private bytes.
	PrivateBytesInKB *int `json:"privateBytesInKB,omitempty"`

	// Requests: A rule based on total requests.
	Requests *RequestsBasedTrigger_STATUS `json:"requests,omitempty"`

	// SlowRequests: A rule based on request execution time.
	SlowRequests *SlowRequestsBasedTrigger_STATUS `json:"slowRequests,omitempty"`

	// SlowRequestsWithPath: A rule based on multiple Slow Requests Rule with path
	SlowRequestsWithPath []SlowRequestsBasedTrigger_STATUS `json:"slowRequestsWithPath,omitempty"`

	// StatusCodes: A rule based on status codes.
	StatusCodes []StatusCodesBasedTrigger_STATUS `json:"statusCodes,omitempty"`

	// StatusCodesRange: A rule based on status codes ranges.
	StatusCodesRange []StatusCodesRangeBasedTrigger_STATUS `json:"statusCodesRange,omitempty"`
}

type AzureStorageInfoValue_State_STATUS string

const (
	AzureStorageInfoValue_State_STATUS_InvalidCredentials = AzureStorageInfoValue_State_STATUS("InvalidCredentials")
	AzureStorageInfoValue_State_STATUS_InvalidShare       = AzureStorageInfoValue_State_STATUS("InvalidShare")
	AzureStorageInfoValue_State_STATUS_NotValidated       = AzureStorageInfoValue_State_STATUS("NotValidated")
	AzureStorageInfoValue_State_STATUS_Ok                 = AzureStorageInfoValue_State_STATUS("Ok")
)

// Mapping from string to AzureStorageInfoValue_State_STATUS
var azureStorageInfoValue_State_STATUS_Values = map[string]AzureStorageInfoValue_State_STATUS{
	"invalidcredentials": AzureStorageInfoValue_State_STATUS_InvalidCredentials,
	"invalidshare":       AzureStorageInfoValue_State_STATUS_InvalidShare,
	"notvalidated":       AzureStorageInfoValue_State_STATUS_NotValidated,
	"ok":                 AzureStorageInfoValue_State_STATUS_Ok,
}

type AzureStorageInfoValue_Type_STATUS string

const (
	AzureStorageInfoValue_Type_STATUS_AzureBlob  = AzureStorageInfoValue_Type_STATUS("AzureBlob")
	AzureStorageInfoValue_Type_STATUS_AzureFiles = AzureStorageInfoValue_Type_STATUS("AzureFiles")
)

// Mapping from string to AzureStorageInfoValue_Type_STATUS
var azureStorageInfoValue_Type_STATUS_Values = map[string]AzureStorageInfoValue_Type_STATUS{
	"azureblob":  AzureStorageInfoValue_Type_STATUS_AzureBlob,
	"azurefiles": AzureStorageInfoValue_Type_STATUS_AzureFiles,
}

type ConnStringInfo_Type_STATUS string

const (
	ConnStringInfo_Type_STATUS_ApiHub          = ConnStringInfo_Type_STATUS("ApiHub")
	ConnStringInfo_Type_STATUS_Custom          = ConnStringInfo_Type_STATUS("Custom")
	ConnStringInfo_Type_STATUS_DocDb           = ConnStringInfo_Type_STATUS("DocDb")
	ConnStringInfo_Type_STATUS_EventHub        = ConnStringInfo_Type_STATUS("EventHub")
	ConnStringInfo_Type_STATUS_MySql           = ConnStringInfo_Type_STATUS("MySql")
	ConnStringInfo_Type_STATUS_NotificationHub = ConnStringInfo_Type_STATUS("NotificationHub")
	ConnStringInfo_Type_STATUS_PostgreSQL      = ConnStringInfo_Type_STATUS("PostgreSQL")
	ConnStringInfo_Type_STATUS_RedisCache      = ConnStringInfo_Type_STATUS("RedisCache")
	ConnStringInfo_Type_STATUS_SQLAzure        = ConnStringInfo_Type_STATUS("SQLAzure")
	ConnStringInfo_Type_STATUS_SQLServer       = ConnStringInfo_Type_STATUS("SQLServer")
	ConnStringInfo_Type_STATUS_ServiceBus      = ConnStringInfo_Type_STATUS("ServiceBus")
)

// Mapping from string to ConnStringInfo_Type_STATUS
var connStringInfo_Type_STATUS_Values = map[string]ConnStringInfo_Type_STATUS{
	"apihub":          ConnStringInfo_Type_STATUS_ApiHub,
	"custom":          ConnStringInfo_Type_STATUS_Custom,
	"docdb":           ConnStringInfo_Type_STATUS_DocDb,
	"eventhub":        ConnStringInfo_Type_STATUS_EventHub,
	"mysql":           ConnStringInfo_Type_STATUS_MySql,
	"notificationhub": ConnStringInfo_Type_STATUS_NotificationHub,
	"postgresql":      ConnStringInfo_Type_STATUS_PostgreSQL,
	"rediscache":      ConnStringInfo_Type_STATUS_RedisCache,
	"sqlazure":        ConnStringInfo_Type_STATUS_SQLAzure,
	"sqlserver":       ConnStringInfo_Type_STATUS_SQLServer,
	"servicebus":      ConnStringInfo_Type_STATUS_ServiceBus,
}

type IpSecurityRestriction_Tag_STATUS string

const (
	IpSecurityRestriction_Tag_STATUS_Default    = IpSecurityRestriction_Tag_STATUS("Default")
	IpSecurityRestriction_Tag_STATUS_ServiceTag = IpSecurityRestriction_Tag_STATUS("ServiceTag")
	IpSecurityRestriction_Tag_STATUS_XffProxy   = IpSecurityRestriction_Tag_STATUS("XffProxy")
)

// Mapping from string to IpSecurityRestriction_Tag_STATUS
var ipSecurityRestriction_Tag_STATUS_Values = map[string]IpSecurityRestriction_Tag_STATUS{
	"default":    IpSecurityRestriction_Tag_STATUS_Default,
	"servicetag": IpSecurityRestriction_Tag_STATUS_ServiceTag,
	"xffproxy":   IpSecurityRestriction_Tag_STATUS_XffProxy,
}

type PushSettings_Properties_STATUS struct {
	// DynamicTagsJson: Gets or sets a JSON string containing a list of dynamic tags that will be evaluated from user claims in
	// the push registration endpoint.
	DynamicTagsJson *string `json:"dynamicTagsJson,omitempty"`

	// IsPushEnabled: Gets or sets a flag indicating whether the Push endpoint is enabled.
	IsPushEnabled *bool `json:"isPushEnabled,omitempty"`

	// TagWhitelistJson: Gets or sets a JSON string containing a list of tags that are in the allowed list for use by the push
	// registration endpoint.
	TagWhitelistJson *string `json:"tagWhitelistJson,omitempty"`

	// TagsRequiringAuth: Gets or sets a JSON string containing a list of tags that require user authentication to be used in
	// the push registration endpoint.
	// Tags can consist of alphanumeric characters and the following:
	// '_', '@', '#', '.', ':', '-'.
	// Validation should be performed at the PushRequestHandler.
	TagsRequiringAuth *string `json:"tagsRequiringAuth,omitempty"`
}

// Routing rules for ramp up testing. This rule allows to redirect static traffic % to a slot or to gradually change
// routing % based on performance.
type RampUpRule_STATUS struct {
	// ActionHostName: Hostname of a slot to which the traffic will be redirected if decided to. E.g.
	// myapp-stage.azurewebsites.net.
	ActionHostName *string `json:"actionHostName,omitempty"`

	// ChangeDecisionCallbackUrl: Custom decision algorithm can be provided in TiPCallback site extension which URL can be
	// specified.
	ChangeDecisionCallbackUrl *string `json:"changeDecisionCallbackUrl,omitempty"`

	// ChangeIntervalInMinutes: Specifies interval in minutes to reevaluate ReroutePercentage.
	ChangeIntervalInMinutes *int `json:"changeIntervalInMinutes,omitempty"`

	// ChangeStep: In auto ramp up scenario this is the step to add/remove from <code>ReroutePercentage</code> until it reaches
	// \n<code>MinReroutePercentage</code> or
	// <code>MaxReroutePercentage</code>. Site metrics are checked every N minutes specified in
	// <code>ChangeIntervalInMinutes</code>.\nCustom decision algorithm
	// can be provided in TiPCallback site extension which URL can be specified in <code>ChangeDecisionCallbackUrl</code>.
	ChangeStep *float64 `json:"changeStep,omitempty"`

	// MaxReroutePercentage: Specifies upper boundary below which ReroutePercentage will stay.
	MaxReroutePercentage *float64 `json:"maxReroutePercentage,omitempty"`

	// MinReroutePercentage: Specifies lower boundary above which ReroutePercentage will stay.
	MinReroutePercentage *float64 `json:"minReroutePercentage,omitempty"`

	// Name: Name of the routing rule. The recommended name would be to point to the slot which will receive the traffic in the
	// experiment.
	Name *string `json:"name,omitempty"`

	// ReroutePercentage: Percentage of the traffic which will be redirected to <code>ActionHostName</code>.
	ReroutePercentage *float64 `json:"reroutePercentage,omitempty"`
}

// Directory for virtual application.
type VirtualDirectory_STATUS struct {
	// PhysicalPath: Physical path.
	PhysicalPath *string `json:"physicalPath,omitempty"`

	// VirtualPath: Path to virtual application.
	VirtualPath *string `json:"virtualPath,omitempty"`
}

type AutoHealActions_ActionType_STATUS string

const (
	AutoHealActions_ActionType_STATUS_CustomAction = AutoHealActions_ActionType_STATUS("CustomAction")
	AutoHealActions_ActionType_STATUS_LogEvent     = AutoHealActions_ActionType_STATUS("LogEvent")
	AutoHealActions_ActionType_STATUS_Recycle      = AutoHealActions_ActionType_STATUS("Recycle")
)

// Mapping from string to AutoHealActions_ActionType_STATUS
var autoHealActions_ActionType_STATUS_Values = map[string]AutoHealActions_ActionType_STATUS{
	"customaction": AutoHealActions_ActionType_STATUS_CustomAction,
	"logevent":     AutoHealActions_ActionType_STATUS_LogEvent,
	"recycle":      AutoHealActions_ActionType_STATUS_Recycle,
}

// Custom action to be executed
// when an auto heal rule is triggered.
type AutoHealCustomAction_STATUS struct {
	// Exe: Executable to be run.
	Exe *string `json:"exe,omitempty"`

	// Parameters: Parameters for the executable.
	Parameters *string `json:"parameters,omitempty"`
}

// Trigger based on total requests.
type RequestsBasedTrigger_STATUS struct {
	// Count: Request Count.
	Count *int `json:"count,omitempty"`

	// TimeInterval: Time interval.
	TimeInterval *string `json:"timeInterval,omitempty"`
}

// Trigger based on request execution time.
type SlowRequestsBasedTrigger_STATUS struct {
	// Count: Request Count.
	Count *int `json:"count,omitempty"`

	// Path: Request Path.
	Path *string `json:"path,omitempty"`

	// TimeInterval: Time interval.
	TimeInterval *string `json:"timeInterval,omitempty"`

	// TimeTaken: Time taken.
	TimeTaken *string `json:"timeTaken,omitempty"`
}

// Trigger based on status code.
type StatusCodesBasedTrigger_STATUS struct {
	// Count: Request Count.
	Count *int `json:"count,omitempty"`

	// Path: Request Path
	Path *string `json:"path,omitempty"`

	// Status: HTTP status code.
	Status *int `json:"status,omitempty"`

	// SubStatus: Request Sub Status.
	SubStatus *int `json:"subStatus,omitempty"`

	// TimeInterval: Time interval.
	TimeInterval *string `json:"timeInterval,omitempty"`

	// Win32Status: Win32 error code.
	Win32Status *int `json:"win32Status,omitempty"`
}

// Trigger based on range of status codes.
type StatusCodesRangeBasedTrigger_STATUS struct {
	// Count: Request Count.
	Count *int    `json:"count,omitempty"`
	Path  *string `json:"path,omitempty"`

	// StatusCodes: HTTP status code.
	StatusCodes *string `json:"statusCodes,omitempty"`

	// TimeInterval: Time interval.
	TimeInterval *string `json:"timeInterval,omitempty"`
}
