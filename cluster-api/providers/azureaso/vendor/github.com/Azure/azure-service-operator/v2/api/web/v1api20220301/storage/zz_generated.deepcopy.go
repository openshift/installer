//go:build !ignore_autogenerated

/*
Copyright (c) Microsoft Corporation.
Licensed under the MIT license.
*/

// Code generated by controller-gen. DO NOT EDIT.

package storage

import (
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	runtime "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ApiDefinitionInfo) DeepCopyInto(out *ApiDefinitionInfo) {
	*out = *in
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Url != nil {
		in, out := &in.Url, &out.Url
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ApiDefinitionInfo.
func (in *ApiDefinitionInfo) DeepCopy() *ApiDefinitionInfo {
	if in == nil {
		return nil
	}
	out := new(ApiDefinitionInfo)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ApiDefinitionInfo_STATUS) DeepCopyInto(out *ApiDefinitionInfo_STATUS) {
	*out = *in
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Url != nil {
		in, out := &in.Url, &out.Url
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ApiDefinitionInfo_STATUS.
func (in *ApiDefinitionInfo_STATUS) DeepCopy() *ApiDefinitionInfo_STATUS {
	if in == nil {
		return nil
	}
	out := new(ApiDefinitionInfo_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ApiManagementConfig) DeepCopyInto(out *ApiManagementConfig) {
	*out = *in
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Reference != nil {
		in, out := &in.Reference, &out.Reference
		*out = new(genruntime.ResourceReference)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ApiManagementConfig.
func (in *ApiManagementConfig) DeepCopy() *ApiManagementConfig {
	if in == nil {
		return nil
	}
	out := new(ApiManagementConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ApiManagementConfig_STATUS) DeepCopyInto(out *ApiManagementConfig_STATUS) {
	*out = *in
	if in.Id != nil {
		in, out := &in.Id, &out.Id
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ApiManagementConfig_STATUS.
func (in *ApiManagementConfig_STATUS) DeepCopy() *ApiManagementConfig_STATUS {
	if in == nil {
		return nil
	}
	out := new(ApiManagementConfig_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AutoHealActions) DeepCopyInto(out *AutoHealActions) {
	*out = *in
	if in.ActionType != nil {
		in, out := &in.ActionType, &out.ActionType
		*out = new(string)
		**out = **in
	}
	if in.CustomAction != nil {
		in, out := &in.CustomAction, &out.CustomAction
		*out = new(AutoHealCustomAction)
		(*in).DeepCopyInto(*out)
	}
	if in.MinProcessExecutionTime != nil {
		in, out := &in.MinProcessExecutionTime, &out.MinProcessExecutionTime
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AutoHealActions.
func (in *AutoHealActions) DeepCopy() *AutoHealActions {
	if in == nil {
		return nil
	}
	out := new(AutoHealActions)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AutoHealActions_STATUS) DeepCopyInto(out *AutoHealActions_STATUS) {
	*out = *in
	if in.ActionType != nil {
		in, out := &in.ActionType, &out.ActionType
		*out = new(string)
		**out = **in
	}
	if in.CustomAction != nil {
		in, out := &in.CustomAction, &out.CustomAction
		*out = new(AutoHealCustomAction_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.MinProcessExecutionTime != nil {
		in, out := &in.MinProcessExecutionTime, &out.MinProcessExecutionTime
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AutoHealActions_STATUS.
func (in *AutoHealActions_STATUS) DeepCopy() *AutoHealActions_STATUS {
	if in == nil {
		return nil
	}
	out := new(AutoHealActions_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AutoHealCustomAction) DeepCopyInto(out *AutoHealCustomAction) {
	*out = *in
	if in.Exe != nil {
		in, out := &in.Exe, &out.Exe
		*out = new(string)
		**out = **in
	}
	if in.Parameters != nil {
		in, out := &in.Parameters, &out.Parameters
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AutoHealCustomAction.
func (in *AutoHealCustomAction) DeepCopy() *AutoHealCustomAction {
	if in == nil {
		return nil
	}
	out := new(AutoHealCustomAction)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AutoHealCustomAction_STATUS) DeepCopyInto(out *AutoHealCustomAction_STATUS) {
	*out = *in
	if in.Exe != nil {
		in, out := &in.Exe, &out.Exe
		*out = new(string)
		**out = **in
	}
	if in.Parameters != nil {
		in, out := &in.Parameters, &out.Parameters
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AutoHealCustomAction_STATUS.
func (in *AutoHealCustomAction_STATUS) DeepCopy() *AutoHealCustomAction_STATUS {
	if in == nil {
		return nil
	}
	out := new(AutoHealCustomAction_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AutoHealRules) DeepCopyInto(out *AutoHealRules) {
	*out = *in
	if in.Actions != nil {
		in, out := &in.Actions, &out.Actions
		*out = new(AutoHealActions)
		(*in).DeepCopyInto(*out)
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Triggers != nil {
		in, out := &in.Triggers, &out.Triggers
		*out = new(AutoHealTriggers)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AutoHealRules.
func (in *AutoHealRules) DeepCopy() *AutoHealRules {
	if in == nil {
		return nil
	}
	out := new(AutoHealRules)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AutoHealRules_STATUS) DeepCopyInto(out *AutoHealRules_STATUS) {
	*out = *in
	if in.Actions != nil {
		in, out := &in.Actions, &out.Actions
		*out = new(AutoHealActions_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Triggers != nil {
		in, out := &in.Triggers, &out.Triggers
		*out = new(AutoHealTriggers_STATUS)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AutoHealRules_STATUS.
func (in *AutoHealRules_STATUS) DeepCopy() *AutoHealRules_STATUS {
	if in == nil {
		return nil
	}
	out := new(AutoHealRules_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AutoHealTriggers) DeepCopyInto(out *AutoHealTriggers) {
	*out = *in
	if in.PrivateBytesInKB != nil {
		in, out := &in.PrivateBytesInKB, &out.PrivateBytesInKB
		*out = new(int)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Requests != nil {
		in, out := &in.Requests, &out.Requests
		*out = new(RequestsBasedTrigger)
		(*in).DeepCopyInto(*out)
	}
	if in.SlowRequests != nil {
		in, out := &in.SlowRequests, &out.SlowRequests
		*out = new(SlowRequestsBasedTrigger)
		(*in).DeepCopyInto(*out)
	}
	if in.SlowRequestsWithPath != nil {
		in, out := &in.SlowRequestsWithPath, &out.SlowRequestsWithPath
		*out = make([]SlowRequestsBasedTrigger, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.StatusCodes != nil {
		in, out := &in.StatusCodes, &out.StatusCodes
		*out = make([]StatusCodesBasedTrigger, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.StatusCodesRange != nil {
		in, out := &in.StatusCodesRange, &out.StatusCodesRange
		*out = make([]StatusCodesRangeBasedTrigger, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AutoHealTriggers.
func (in *AutoHealTriggers) DeepCopy() *AutoHealTriggers {
	if in == nil {
		return nil
	}
	out := new(AutoHealTriggers)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AutoHealTriggers_STATUS) DeepCopyInto(out *AutoHealTriggers_STATUS) {
	*out = *in
	if in.PrivateBytesInKB != nil {
		in, out := &in.PrivateBytesInKB, &out.PrivateBytesInKB
		*out = new(int)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Requests != nil {
		in, out := &in.Requests, &out.Requests
		*out = new(RequestsBasedTrigger_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.SlowRequests != nil {
		in, out := &in.SlowRequests, &out.SlowRequests
		*out = new(SlowRequestsBasedTrigger_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.SlowRequestsWithPath != nil {
		in, out := &in.SlowRequestsWithPath, &out.SlowRequestsWithPath
		*out = make([]SlowRequestsBasedTrigger_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.StatusCodes != nil {
		in, out := &in.StatusCodes, &out.StatusCodes
		*out = make([]StatusCodesBasedTrigger_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.StatusCodesRange != nil {
		in, out := &in.StatusCodesRange, &out.StatusCodesRange
		*out = make([]StatusCodesRangeBasedTrigger_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AutoHealTriggers_STATUS.
func (in *AutoHealTriggers_STATUS) DeepCopy() *AutoHealTriggers_STATUS {
	if in == nil {
		return nil
	}
	out := new(AutoHealTriggers_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureStorageInfoValue) DeepCopyInto(out *AzureStorageInfoValue) {
	*out = *in
	if in.AccessKey != nil {
		in, out := &in.AccessKey, &out.AccessKey
		*out = new(genruntime.SecretReference)
		**out = **in
	}
	if in.AccountName != nil {
		in, out := &in.AccountName, &out.AccountName
		*out = new(string)
		**out = **in
	}
	if in.MountPath != nil {
		in, out := &in.MountPath, &out.MountPath
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ShareName != nil {
		in, out := &in.ShareName, &out.ShareName
		*out = new(string)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureStorageInfoValue.
func (in *AzureStorageInfoValue) DeepCopy() *AzureStorageInfoValue {
	if in == nil {
		return nil
	}
	out := new(AzureStorageInfoValue)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AzureStorageInfoValue_STATUS) DeepCopyInto(out *AzureStorageInfoValue_STATUS) {
	*out = *in
	if in.AccountName != nil {
		in, out := &in.AccountName, &out.AccountName
		*out = new(string)
		**out = **in
	}
	if in.MountPath != nil {
		in, out := &in.MountPath, &out.MountPath
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ShareName != nil {
		in, out := &in.ShareName, &out.ShareName
		*out = new(string)
		**out = **in
	}
	if in.State != nil {
		in, out := &in.State, &out.State
		*out = new(string)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AzureStorageInfoValue_STATUS.
func (in *AzureStorageInfoValue_STATUS) DeepCopy() *AzureStorageInfoValue_STATUS {
	if in == nil {
		return nil
	}
	out := new(AzureStorageInfoValue_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Capability) DeepCopyInto(out *Capability) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Reason != nil {
		in, out := &in.Reason, &out.Reason
		*out = new(string)
		**out = **in
	}
	if in.Value != nil {
		in, out := &in.Value, &out.Value
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Capability.
func (in *Capability) DeepCopy() *Capability {
	if in == nil {
		return nil
	}
	out := new(Capability)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Capability_STATUS) DeepCopyInto(out *Capability_STATUS) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Reason != nil {
		in, out := &in.Reason, &out.Reason
		*out = new(string)
		**out = **in
	}
	if in.Value != nil {
		in, out := &in.Value, &out.Value
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Capability_STATUS.
func (in *Capability_STATUS) DeepCopy() *Capability_STATUS {
	if in == nil {
		return nil
	}
	out := new(Capability_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CloningInfo) DeepCopyInto(out *CloningInfo) {
	*out = *in
	if in.AppSettingsOverrides != nil {
		in, out := &in.AppSettingsOverrides, &out.AppSettingsOverrides
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.CloneCustomHostNames != nil {
		in, out := &in.CloneCustomHostNames, &out.CloneCustomHostNames
		*out = new(bool)
		**out = **in
	}
	if in.CloneSourceControl != nil {
		in, out := &in.CloneSourceControl, &out.CloneSourceControl
		*out = new(bool)
		**out = **in
	}
	if in.ConfigureLoadBalancing != nil {
		in, out := &in.ConfigureLoadBalancing, &out.ConfigureLoadBalancing
		*out = new(bool)
		**out = **in
	}
	if in.CorrelationId != nil {
		in, out := &in.CorrelationId, &out.CorrelationId
		*out = new(string)
		**out = **in
	}
	if in.HostingEnvironment != nil {
		in, out := &in.HostingEnvironment, &out.HostingEnvironment
		*out = new(string)
		**out = **in
	}
	if in.Overwrite != nil {
		in, out := &in.Overwrite, &out.Overwrite
		*out = new(bool)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SourceWebAppLocation != nil {
		in, out := &in.SourceWebAppLocation, &out.SourceWebAppLocation
		*out = new(string)
		**out = **in
	}
	if in.SourceWebAppReference != nil {
		in, out := &in.SourceWebAppReference, &out.SourceWebAppReference
		*out = new(genruntime.ResourceReference)
		**out = **in
	}
	if in.TrafficManagerProfileName != nil {
		in, out := &in.TrafficManagerProfileName, &out.TrafficManagerProfileName
		*out = new(string)
		**out = **in
	}
	if in.TrafficManagerProfileReference != nil {
		in, out := &in.TrafficManagerProfileReference, &out.TrafficManagerProfileReference
		*out = new(genruntime.ResourceReference)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CloningInfo.
func (in *CloningInfo) DeepCopy() *CloningInfo {
	if in == nil {
		return nil
	}
	out := new(CloningInfo)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CloningInfo_STATUS) DeepCopyInto(out *CloningInfo_STATUS) {
	*out = *in
	if in.AppSettingsOverrides != nil {
		in, out := &in.AppSettingsOverrides, &out.AppSettingsOverrides
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.CloneCustomHostNames != nil {
		in, out := &in.CloneCustomHostNames, &out.CloneCustomHostNames
		*out = new(bool)
		**out = **in
	}
	if in.CloneSourceControl != nil {
		in, out := &in.CloneSourceControl, &out.CloneSourceControl
		*out = new(bool)
		**out = **in
	}
	if in.ConfigureLoadBalancing != nil {
		in, out := &in.ConfigureLoadBalancing, &out.ConfigureLoadBalancing
		*out = new(bool)
		**out = **in
	}
	if in.CorrelationId != nil {
		in, out := &in.CorrelationId, &out.CorrelationId
		*out = new(string)
		**out = **in
	}
	if in.HostingEnvironment != nil {
		in, out := &in.HostingEnvironment, &out.HostingEnvironment
		*out = new(string)
		**out = **in
	}
	if in.Overwrite != nil {
		in, out := &in.Overwrite, &out.Overwrite
		*out = new(bool)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SourceWebAppId != nil {
		in, out := &in.SourceWebAppId, &out.SourceWebAppId
		*out = new(string)
		**out = **in
	}
	if in.SourceWebAppLocation != nil {
		in, out := &in.SourceWebAppLocation, &out.SourceWebAppLocation
		*out = new(string)
		**out = **in
	}
	if in.TrafficManagerProfileId != nil {
		in, out := &in.TrafficManagerProfileId, &out.TrafficManagerProfileId
		*out = new(string)
		**out = **in
	}
	if in.TrafficManagerProfileName != nil {
		in, out := &in.TrafficManagerProfileName, &out.TrafficManagerProfileName
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CloningInfo_STATUS.
func (in *CloningInfo_STATUS) DeepCopy() *CloningInfo_STATUS {
	if in == nil {
		return nil
	}
	out := new(CloningInfo_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ConnStringInfo) DeepCopyInto(out *ConnStringInfo) {
	*out = *in
	if in.ConnectionString != nil {
		in, out := &in.ConnectionString, &out.ConnectionString
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ConnStringInfo.
func (in *ConnStringInfo) DeepCopy() *ConnStringInfo {
	if in == nil {
		return nil
	}
	out := new(ConnStringInfo)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ConnStringInfo_STATUS) DeepCopyInto(out *ConnStringInfo_STATUS) {
	*out = *in
	if in.ConnectionString != nil {
		in, out := &in.ConnectionString, &out.ConnectionString
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ConnStringInfo_STATUS.
func (in *ConnStringInfo_STATUS) DeepCopy() *ConnStringInfo_STATUS {
	if in == nil {
		return nil
	}
	out := new(ConnStringInfo_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CorsSettings) DeepCopyInto(out *CorsSettings) {
	*out = *in
	if in.AllowedOrigins != nil {
		in, out := &in.AllowedOrigins, &out.AllowedOrigins
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SupportCredentials != nil {
		in, out := &in.SupportCredentials, &out.SupportCredentials
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CorsSettings.
func (in *CorsSettings) DeepCopy() *CorsSettings {
	if in == nil {
		return nil
	}
	out := new(CorsSettings)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CorsSettings_STATUS) DeepCopyInto(out *CorsSettings_STATUS) {
	*out = *in
	if in.AllowedOrigins != nil {
		in, out := &in.AllowedOrigins, &out.AllowedOrigins
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SupportCredentials != nil {
		in, out := &in.SupportCredentials, &out.SupportCredentials
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CorsSettings_STATUS.
func (in *CorsSettings_STATUS) DeepCopy() *CorsSettings_STATUS {
	if in == nil {
		return nil
	}
	out := new(CorsSettings_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Experiments) DeepCopyInto(out *Experiments) {
	*out = *in
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.RampUpRules != nil {
		in, out := &in.RampUpRules, &out.RampUpRules
		*out = make([]RampUpRule, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Experiments.
func (in *Experiments) DeepCopy() *Experiments {
	if in == nil {
		return nil
	}
	out := new(Experiments)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Experiments_STATUS) DeepCopyInto(out *Experiments_STATUS) {
	*out = *in
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.RampUpRules != nil {
		in, out := &in.RampUpRules, &out.RampUpRules
		*out = make([]RampUpRule_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Experiments_STATUS.
func (in *Experiments_STATUS) DeepCopy() *Experiments_STATUS {
	if in == nil {
		return nil
	}
	out := new(Experiments_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ExtendedLocation) DeepCopyInto(out *ExtendedLocation) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ExtendedLocation.
func (in *ExtendedLocation) DeepCopy() *ExtendedLocation {
	if in == nil {
		return nil
	}
	out := new(ExtendedLocation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ExtendedLocation_STATUS) DeepCopyInto(out *ExtendedLocation_STATUS) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ExtendedLocation_STATUS.
func (in *ExtendedLocation_STATUS) DeepCopy() *ExtendedLocation_STATUS {
	if in == nil {
		return nil
	}
	out := new(ExtendedLocation_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HandlerMapping) DeepCopyInto(out *HandlerMapping) {
	*out = *in
	if in.Arguments != nil {
		in, out := &in.Arguments, &out.Arguments
		*out = new(string)
		**out = **in
	}
	if in.Extension != nil {
		in, out := &in.Extension, &out.Extension
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ScriptProcessor != nil {
		in, out := &in.ScriptProcessor, &out.ScriptProcessor
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HandlerMapping.
func (in *HandlerMapping) DeepCopy() *HandlerMapping {
	if in == nil {
		return nil
	}
	out := new(HandlerMapping)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HandlerMapping_STATUS) DeepCopyInto(out *HandlerMapping_STATUS) {
	*out = *in
	if in.Arguments != nil {
		in, out := &in.Arguments, &out.Arguments
		*out = new(string)
		**out = **in
	}
	if in.Extension != nil {
		in, out := &in.Extension, &out.Extension
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ScriptProcessor != nil {
		in, out := &in.ScriptProcessor, &out.ScriptProcessor
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HandlerMapping_STATUS.
func (in *HandlerMapping_STATUS) DeepCopy() *HandlerMapping_STATUS {
	if in == nil {
		return nil
	}
	out := new(HandlerMapping_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HostNameSslState) DeepCopyInto(out *HostNameSslState) {
	*out = *in
	if in.HostType != nil {
		in, out := &in.HostType, &out.HostType
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SslState != nil {
		in, out := &in.SslState, &out.SslState
		*out = new(string)
		**out = **in
	}
	if in.Thumbprint != nil {
		in, out := &in.Thumbprint, &out.Thumbprint
		*out = new(string)
		**out = **in
	}
	if in.ToUpdate != nil {
		in, out := &in.ToUpdate, &out.ToUpdate
		*out = new(bool)
		**out = **in
	}
	if in.VirtualIP != nil {
		in, out := &in.VirtualIP, &out.VirtualIP
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HostNameSslState.
func (in *HostNameSslState) DeepCopy() *HostNameSslState {
	if in == nil {
		return nil
	}
	out := new(HostNameSslState)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HostNameSslState_STATUS) DeepCopyInto(out *HostNameSslState_STATUS) {
	*out = *in
	if in.HostType != nil {
		in, out := &in.HostType, &out.HostType
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SslState != nil {
		in, out := &in.SslState, &out.SslState
		*out = new(string)
		**out = **in
	}
	if in.Thumbprint != nil {
		in, out := &in.Thumbprint, &out.Thumbprint
		*out = new(string)
		**out = **in
	}
	if in.ToUpdate != nil {
		in, out := &in.ToUpdate, &out.ToUpdate
		*out = new(bool)
		**out = **in
	}
	if in.VirtualIP != nil {
		in, out := &in.VirtualIP, &out.VirtualIP
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HostNameSslState_STATUS.
func (in *HostNameSslState_STATUS) DeepCopy() *HostNameSslState_STATUS {
	if in == nil {
		return nil
	}
	out := new(HostNameSslState_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HostingEnvironmentProfile) DeepCopyInto(out *HostingEnvironmentProfile) {
	*out = *in
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Reference != nil {
		in, out := &in.Reference, &out.Reference
		*out = new(genruntime.ResourceReference)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HostingEnvironmentProfile.
func (in *HostingEnvironmentProfile) DeepCopy() *HostingEnvironmentProfile {
	if in == nil {
		return nil
	}
	out := new(HostingEnvironmentProfile)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HostingEnvironmentProfile_STATUS) DeepCopyInto(out *HostingEnvironmentProfile_STATUS) {
	*out = *in
	if in.Id != nil {
		in, out := &in.Id, &out.Id
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HostingEnvironmentProfile_STATUS.
func (in *HostingEnvironmentProfile_STATUS) DeepCopy() *HostingEnvironmentProfile_STATUS {
	if in == nil {
		return nil
	}
	out := new(HostingEnvironmentProfile_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *IpSecurityRestriction) DeepCopyInto(out *IpSecurityRestriction) {
	*out = *in
	if in.Action != nil {
		in, out := &in.Action, &out.Action
		*out = new(string)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.Headers != nil {
		in, out := &in.Headers, &out.Headers
		*out = make(map[string][]string, len(*in))
		for key, val := range *in {
			var outVal []string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = make([]string, len(*in))
				copy(*out, *in)
			}
			(*out)[key] = outVal
		}
	}
	if in.IpAddress != nil {
		in, out := &in.IpAddress, &out.IpAddress
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Priority != nil {
		in, out := &in.Priority, &out.Priority
		*out = new(int)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SubnetMask != nil {
		in, out := &in.SubnetMask, &out.SubnetMask
		*out = new(string)
		**out = **in
	}
	if in.SubnetTrafficTag != nil {
		in, out := &in.SubnetTrafficTag, &out.SubnetTrafficTag
		*out = new(int)
		**out = **in
	}
	if in.Tag != nil {
		in, out := &in.Tag, &out.Tag
		*out = new(string)
		**out = **in
	}
	if in.VnetSubnetResourceReference != nil {
		in, out := &in.VnetSubnetResourceReference, &out.VnetSubnetResourceReference
		*out = new(genruntime.ResourceReference)
		**out = **in
	}
	if in.VnetTrafficTag != nil {
		in, out := &in.VnetTrafficTag, &out.VnetTrafficTag
		*out = new(int)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new IpSecurityRestriction.
func (in *IpSecurityRestriction) DeepCopy() *IpSecurityRestriction {
	if in == nil {
		return nil
	}
	out := new(IpSecurityRestriction)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *IpSecurityRestriction_STATUS) DeepCopyInto(out *IpSecurityRestriction_STATUS) {
	*out = *in
	if in.Action != nil {
		in, out := &in.Action, &out.Action
		*out = new(string)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.Headers != nil {
		in, out := &in.Headers, &out.Headers
		*out = make(map[string][]string, len(*in))
		for key, val := range *in {
			var outVal []string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = make([]string, len(*in))
				copy(*out, *in)
			}
			(*out)[key] = outVal
		}
	}
	if in.IpAddress != nil {
		in, out := &in.IpAddress, &out.IpAddress
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Priority != nil {
		in, out := &in.Priority, &out.Priority
		*out = new(int)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SubnetMask != nil {
		in, out := &in.SubnetMask, &out.SubnetMask
		*out = new(string)
		**out = **in
	}
	if in.SubnetTrafficTag != nil {
		in, out := &in.SubnetTrafficTag, &out.SubnetTrafficTag
		*out = new(int)
		**out = **in
	}
	if in.Tag != nil {
		in, out := &in.Tag, &out.Tag
		*out = new(string)
		**out = **in
	}
	if in.VnetSubnetResourceId != nil {
		in, out := &in.VnetSubnetResourceId, &out.VnetSubnetResourceId
		*out = new(string)
		**out = **in
	}
	if in.VnetTrafficTag != nil {
		in, out := &in.VnetTrafficTag, &out.VnetTrafficTag
		*out = new(int)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new IpSecurityRestriction_STATUS.
func (in *IpSecurityRestriction_STATUS) DeepCopy() *IpSecurityRestriction_STATUS {
	if in == nil {
		return nil
	}
	out := new(IpSecurityRestriction_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KubeEnvironmentProfile) DeepCopyInto(out *KubeEnvironmentProfile) {
	*out = *in
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Reference != nil {
		in, out := &in.Reference, &out.Reference
		*out = new(genruntime.ResourceReference)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KubeEnvironmentProfile.
func (in *KubeEnvironmentProfile) DeepCopy() *KubeEnvironmentProfile {
	if in == nil {
		return nil
	}
	out := new(KubeEnvironmentProfile)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KubeEnvironmentProfile_STATUS) DeepCopyInto(out *KubeEnvironmentProfile_STATUS) {
	*out = *in
	if in.Id != nil {
		in, out := &in.Id, &out.Id
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KubeEnvironmentProfile_STATUS.
func (in *KubeEnvironmentProfile_STATUS) DeepCopy() *KubeEnvironmentProfile_STATUS {
	if in == nil {
		return nil
	}
	out := new(KubeEnvironmentProfile_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ManagedServiceIdentity) DeepCopyInto(out *ManagedServiceIdentity) {
	*out = *in
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
	if in.UserAssignedIdentities != nil {
		in, out := &in.UserAssignedIdentities, &out.UserAssignedIdentities
		*out = make([]UserAssignedIdentityDetails, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ManagedServiceIdentity.
func (in *ManagedServiceIdentity) DeepCopy() *ManagedServiceIdentity {
	if in == nil {
		return nil
	}
	out := new(ManagedServiceIdentity)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ManagedServiceIdentity_STATUS) DeepCopyInto(out *ManagedServiceIdentity_STATUS) {
	*out = *in
	if in.PrincipalId != nil {
		in, out := &in.PrincipalId, &out.PrincipalId
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.TenantId != nil {
		in, out := &in.TenantId, &out.TenantId
		*out = new(string)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
	if in.UserAssignedIdentities != nil {
		in, out := &in.UserAssignedIdentities, &out.UserAssignedIdentities
		*out = make(map[string]UserAssignedIdentity_STATUS, len(*in))
		for key, val := range *in {
			(*out)[key] = *val.DeepCopy()
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ManagedServiceIdentity_STATUS.
func (in *ManagedServiceIdentity_STATUS) DeepCopy() *ManagedServiceIdentity_STATUS {
	if in == nil {
		return nil
	}
	out := new(ManagedServiceIdentity_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NameValuePair) DeepCopyInto(out *NameValuePair) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Value != nil {
		in, out := &in.Value, &out.Value
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NameValuePair.
func (in *NameValuePair) DeepCopy() *NameValuePair {
	if in == nil {
		return nil
	}
	out := new(NameValuePair)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NameValuePair_STATUS) DeepCopyInto(out *NameValuePair_STATUS) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Value != nil {
		in, out := &in.Value, &out.Value
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NameValuePair_STATUS.
func (in *NameValuePair_STATUS) DeepCopy() *NameValuePair_STATUS {
	if in == nil {
		return nil
	}
	out := new(NameValuePair_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PushSettings) DeepCopyInto(out *PushSettings) {
	*out = *in
	if in.DynamicTagsJson != nil {
		in, out := &in.DynamicTagsJson, &out.DynamicTagsJson
		*out = new(string)
		**out = **in
	}
	if in.IsPushEnabled != nil {
		in, out := &in.IsPushEnabled, &out.IsPushEnabled
		*out = new(bool)
		**out = **in
	}
	if in.Kind != nil {
		in, out := &in.Kind, &out.Kind
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.TagWhitelistJson != nil {
		in, out := &in.TagWhitelistJson, &out.TagWhitelistJson
		*out = new(string)
		**out = **in
	}
	if in.TagsRequiringAuth != nil {
		in, out := &in.TagsRequiringAuth, &out.TagsRequiringAuth
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PushSettings.
func (in *PushSettings) DeepCopy() *PushSettings {
	if in == nil {
		return nil
	}
	out := new(PushSettings)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PushSettings_STATUS) DeepCopyInto(out *PushSettings_STATUS) {
	*out = *in
	if in.DynamicTagsJson != nil {
		in, out := &in.DynamicTagsJson, &out.DynamicTagsJson
		*out = new(string)
		**out = **in
	}
	if in.Id != nil {
		in, out := &in.Id, &out.Id
		*out = new(string)
		**out = **in
	}
	if in.IsPushEnabled != nil {
		in, out := &in.IsPushEnabled, &out.IsPushEnabled
		*out = new(bool)
		**out = **in
	}
	if in.Kind != nil {
		in, out := &in.Kind, &out.Kind
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.TagWhitelistJson != nil {
		in, out := &in.TagWhitelistJson, &out.TagWhitelistJson
		*out = new(string)
		**out = **in
	}
	if in.TagsRequiringAuth != nil {
		in, out := &in.TagsRequiringAuth, &out.TagsRequiringAuth
		*out = new(string)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PushSettings_STATUS.
func (in *PushSettings_STATUS) DeepCopy() *PushSettings_STATUS {
	if in == nil {
		return nil
	}
	out := new(PushSettings_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RampUpRule) DeepCopyInto(out *RampUpRule) {
	*out = *in
	if in.ActionHostName != nil {
		in, out := &in.ActionHostName, &out.ActionHostName
		*out = new(string)
		**out = **in
	}
	if in.ChangeDecisionCallbackUrl != nil {
		in, out := &in.ChangeDecisionCallbackUrl, &out.ChangeDecisionCallbackUrl
		*out = new(string)
		**out = **in
	}
	if in.ChangeIntervalInMinutes != nil {
		in, out := &in.ChangeIntervalInMinutes, &out.ChangeIntervalInMinutes
		*out = new(int)
		**out = **in
	}
	if in.ChangeStep != nil {
		in, out := &in.ChangeStep, &out.ChangeStep
		*out = new(float64)
		**out = **in
	}
	if in.MaxReroutePercentage != nil {
		in, out := &in.MaxReroutePercentage, &out.MaxReroutePercentage
		*out = new(float64)
		**out = **in
	}
	if in.MinReroutePercentage != nil {
		in, out := &in.MinReroutePercentage, &out.MinReroutePercentage
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ReroutePercentage != nil {
		in, out := &in.ReroutePercentage, &out.ReroutePercentage
		*out = new(float64)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RampUpRule.
func (in *RampUpRule) DeepCopy() *RampUpRule {
	if in == nil {
		return nil
	}
	out := new(RampUpRule)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RampUpRule_STATUS) DeepCopyInto(out *RampUpRule_STATUS) {
	*out = *in
	if in.ActionHostName != nil {
		in, out := &in.ActionHostName, &out.ActionHostName
		*out = new(string)
		**out = **in
	}
	if in.ChangeDecisionCallbackUrl != nil {
		in, out := &in.ChangeDecisionCallbackUrl, &out.ChangeDecisionCallbackUrl
		*out = new(string)
		**out = **in
	}
	if in.ChangeIntervalInMinutes != nil {
		in, out := &in.ChangeIntervalInMinutes, &out.ChangeIntervalInMinutes
		*out = new(int)
		**out = **in
	}
	if in.ChangeStep != nil {
		in, out := &in.ChangeStep, &out.ChangeStep
		*out = new(float64)
		**out = **in
	}
	if in.MaxReroutePercentage != nil {
		in, out := &in.MaxReroutePercentage, &out.MaxReroutePercentage
		*out = new(float64)
		**out = **in
	}
	if in.MinReroutePercentage != nil {
		in, out := &in.MinReroutePercentage, &out.MinReroutePercentage
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ReroutePercentage != nil {
		in, out := &in.ReroutePercentage, &out.ReroutePercentage
		*out = new(float64)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RampUpRule_STATUS.
func (in *RampUpRule_STATUS) DeepCopy() *RampUpRule_STATUS {
	if in == nil {
		return nil
	}
	out := new(RampUpRule_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RequestsBasedTrigger) DeepCopyInto(out *RequestsBasedTrigger) {
	*out = *in
	if in.Count != nil {
		in, out := &in.Count, &out.Count
		*out = new(int)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.TimeInterval != nil {
		in, out := &in.TimeInterval, &out.TimeInterval
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RequestsBasedTrigger.
func (in *RequestsBasedTrigger) DeepCopy() *RequestsBasedTrigger {
	if in == nil {
		return nil
	}
	out := new(RequestsBasedTrigger)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RequestsBasedTrigger_STATUS) DeepCopyInto(out *RequestsBasedTrigger_STATUS) {
	*out = *in
	if in.Count != nil {
		in, out := &in.Count, &out.Count
		*out = new(int)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.TimeInterval != nil {
		in, out := &in.TimeInterval, &out.TimeInterval
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RequestsBasedTrigger_STATUS.
func (in *RequestsBasedTrigger_STATUS) DeepCopy() *RequestsBasedTrigger_STATUS {
	if in == nil {
		return nil
	}
	out := new(RequestsBasedTrigger_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServerFarm) DeepCopyInto(out *ServerFarm) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServerFarm.
func (in *ServerFarm) DeepCopy() *ServerFarm {
	if in == nil {
		return nil
	}
	out := new(ServerFarm)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ServerFarm) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ServerFarmList) DeepCopyInto(out *ServerFarmList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ServerFarm, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ServerFarmList.
func (in *ServerFarmList) DeepCopy() *ServerFarmList {
	if in == nil {
		return nil
	}
	out := new(ServerFarmList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ServerFarmList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Serverfarm_STATUS) DeepCopyInto(out *Serverfarm_STATUS) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]conditions.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ElasticScaleEnabled != nil {
		in, out := &in.ElasticScaleEnabled, &out.ElasticScaleEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ExtendedLocation != nil {
		in, out := &in.ExtendedLocation, &out.ExtendedLocation
		*out = new(ExtendedLocation_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.FreeOfferExpirationTime != nil {
		in, out := &in.FreeOfferExpirationTime, &out.FreeOfferExpirationTime
		*out = new(string)
		**out = **in
	}
	if in.GeoRegion != nil {
		in, out := &in.GeoRegion, &out.GeoRegion
		*out = new(string)
		**out = **in
	}
	if in.HostingEnvironmentProfile != nil {
		in, out := &in.HostingEnvironmentProfile, &out.HostingEnvironmentProfile
		*out = new(HostingEnvironmentProfile_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.HyperV != nil {
		in, out := &in.HyperV, &out.HyperV
		*out = new(bool)
		**out = **in
	}
	if in.Id != nil {
		in, out := &in.Id, &out.Id
		*out = new(string)
		**out = **in
	}
	if in.IsSpot != nil {
		in, out := &in.IsSpot, &out.IsSpot
		*out = new(bool)
		**out = **in
	}
	if in.IsXenon != nil {
		in, out := &in.IsXenon, &out.IsXenon
		*out = new(bool)
		**out = **in
	}
	if in.Kind != nil {
		in, out := &in.Kind, &out.Kind
		*out = new(string)
		**out = **in
	}
	if in.KubeEnvironmentProfile != nil {
		in, out := &in.KubeEnvironmentProfile, &out.KubeEnvironmentProfile
		*out = new(KubeEnvironmentProfile_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.Location != nil {
		in, out := &in.Location, &out.Location
		*out = new(string)
		**out = **in
	}
	if in.MaximumElasticWorkerCount != nil {
		in, out := &in.MaximumElasticWorkerCount, &out.MaximumElasticWorkerCount
		*out = new(int)
		**out = **in
	}
	if in.MaximumNumberOfWorkers != nil {
		in, out := &in.MaximumNumberOfWorkers, &out.MaximumNumberOfWorkers
		*out = new(int)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NumberOfSites != nil {
		in, out := &in.NumberOfSites, &out.NumberOfSites
		*out = new(int)
		**out = **in
	}
	if in.NumberOfWorkers != nil {
		in, out := &in.NumberOfWorkers, &out.NumberOfWorkers
		*out = new(int)
		**out = **in
	}
	if in.PerSiteScaling != nil {
		in, out := &in.PerSiteScaling, &out.PerSiteScaling
		*out = new(bool)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ProvisioningState != nil {
		in, out := &in.ProvisioningState, &out.ProvisioningState
		*out = new(string)
		**out = **in
	}
	if in.Reserved != nil {
		in, out := &in.Reserved, &out.Reserved
		*out = new(bool)
		**out = **in
	}
	if in.ResourceGroup != nil {
		in, out := &in.ResourceGroup, &out.ResourceGroup
		*out = new(string)
		**out = **in
	}
	if in.Sku != nil {
		in, out := &in.Sku, &out.Sku
		*out = new(SkuDescription_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.SpotExpirationTime != nil {
		in, out := &in.SpotExpirationTime, &out.SpotExpirationTime
		*out = new(string)
		**out = **in
	}
	if in.Status != nil {
		in, out := &in.Status, &out.Status
		*out = new(string)
		**out = **in
	}
	if in.Subscription != nil {
		in, out := &in.Subscription, &out.Subscription
		*out = new(string)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.TargetWorkerCount != nil {
		in, out := &in.TargetWorkerCount, &out.TargetWorkerCount
		*out = new(int)
		**out = **in
	}
	if in.TargetWorkerSizeId != nil {
		in, out := &in.TargetWorkerSizeId, &out.TargetWorkerSizeId
		*out = new(int)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
	if in.WorkerTierName != nil {
		in, out := &in.WorkerTierName, &out.WorkerTierName
		*out = new(string)
		**out = **in
	}
	if in.ZoneRedundant != nil {
		in, out := &in.ZoneRedundant, &out.ZoneRedundant
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Serverfarm_STATUS.
func (in *Serverfarm_STATUS) DeepCopy() *Serverfarm_STATUS {
	if in == nil {
		return nil
	}
	out := new(Serverfarm_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Serverfarm_Spec) DeepCopyInto(out *Serverfarm_Spec) {
	*out = *in
	if in.ElasticScaleEnabled != nil {
		in, out := &in.ElasticScaleEnabled, &out.ElasticScaleEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ExtendedLocation != nil {
		in, out := &in.ExtendedLocation, &out.ExtendedLocation
		*out = new(ExtendedLocation)
		(*in).DeepCopyInto(*out)
	}
	if in.FreeOfferExpirationTime != nil {
		in, out := &in.FreeOfferExpirationTime, &out.FreeOfferExpirationTime
		*out = new(string)
		**out = **in
	}
	if in.HostingEnvironmentProfile != nil {
		in, out := &in.HostingEnvironmentProfile, &out.HostingEnvironmentProfile
		*out = new(HostingEnvironmentProfile)
		(*in).DeepCopyInto(*out)
	}
	if in.HyperV != nil {
		in, out := &in.HyperV, &out.HyperV
		*out = new(bool)
		**out = **in
	}
	if in.IsSpot != nil {
		in, out := &in.IsSpot, &out.IsSpot
		*out = new(bool)
		**out = **in
	}
	if in.IsXenon != nil {
		in, out := &in.IsXenon, &out.IsXenon
		*out = new(bool)
		**out = **in
	}
	if in.Kind != nil {
		in, out := &in.Kind, &out.Kind
		*out = new(string)
		**out = **in
	}
	if in.KubeEnvironmentProfile != nil {
		in, out := &in.KubeEnvironmentProfile, &out.KubeEnvironmentProfile
		*out = new(KubeEnvironmentProfile)
		(*in).DeepCopyInto(*out)
	}
	if in.Location != nil {
		in, out := &in.Location, &out.Location
		*out = new(string)
		**out = **in
	}
	if in.MaximumElasticWorkerCount != nil {
		in, out := &in.MaximumElasticWorkerCount, &out.MaximumElasticWorkerCount
		*out = new(int)
		**out = **in
	}
	if in.Owner != nil {
		in, out := &in.Owner, &out.Owner
		*out = new(genruntime.KnownResourceReference)
		**out = **in
	}
	if in.PerSiteScaling != nil {
		in, out := &in.PerSiteScaling, &out.PerSiteScaling
		*out = new(bool)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Reserved != nil {
		in, out := &in.Reserved, &out.Reserved
		*out = new(bool)
		**out = **in
	}
	if in.Sku != nil {
		in, out := &in.Sku, &out.Sku
		*out = new(SkuDescription)
		(*in).DeepCopyInto(*out)
	}
	if in.SpotExpirationTime != nil {
		in, out := &in.SpotExpirationTime, &out.SpotExpirationTime
		*out = new(string)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.TargetWorkerCount != nil {
		in, out := &in.TargetWorkerCount, &out.TargetWorkerCount
		*out = new(int)
		**out = **in
	}
	if in.TargetWorkerSizeId != nil {
		in, out := &in.TargetWorkerSizeId, &out.TargetWorkerSizeId
		*out = new(int)
		**out = **in
	}
	if in.WorkerTierName != nil {
		in, out := &in.WorkerTierName, &out.WorkerTierName
		*out = new(string)
		**out = **in
	}
	if in.ZoneRedundant != nil {
		in, out := &in.ZoneRedundant, &out.ZoneRedundant
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Serverfarm_Spec.
func (in *Serverfarm_Spec) DeepCopy() *Serverfarm_Spec {
	if in == nil {
		return nil
	}
	out := new(Serverfarm_Spec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Site) DeepCopyInto(out *Site) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Site.
func (in *Site) DeepCopy() *Site {
	if in == nil {
		return nil
	}
	out := new(Site)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Site) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SiteConfig) DeepCopyInto(out *SiteConfig) {
	*out = *in
	if in.AcrUseManagedIdentityCreds != nil {
		in, out := &in.AcrUseManagedIdentityCreds, &out.AcrUseManagedIdentityCreds
		*out = new(bool)
		**out = **in
	}
	if in.AcrUserManagedIdentityID != nil {
		in, out := &in.AcrUserManagedIdentityID, &out.AcrUserManagedIdentityID
		*out = new(string)
		**out = **in
	}
	if in.AlwaysOn != nil {
		in, out := &in.AlwaysOn, &out.AlwaysOn
		*out = new(bool)
		**out = **in
	}
	if in.ApiDefinition != nil {
		in, out := &in.ApiDefinition, &out.ApiDefinition
		*out = new(ApiDefinitionInfo)
		(*in).DeepCopyInto(*out)
	}
	if in.ApiManagementConfig != nil {
		in, out := &in.ApiManagementConfig, &out.ApiManagementConfig
		*out = new(ApiManagementConfig)
		(*in).DeepCopyInto(*out)
	}
	if in.AppCommandLine != nil {
		in, out := &in.AppCommandLine, &out.AppCommandLine
		*out = new(string)
		**out = **in
	}
	if in.AppSettings != nil {
		in, out := &in.AppSettings, &out.AppSettings
		*out = make([]NameValuePair, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.AutoHealEnabled != nil {
		in, out := &in.AutoHealEnabled, &out.AutoHealEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AutoHealRules != nil {
		in, out := &in.AutoHealRules, &out.AutoHealRules
		*out = new(AutoHealRules)
		(*in).DeepCopyInto(*out)
	}
	if in.AutoSwapSlotName != nil {
		in, out := &in.AutoSwapSlotName, &out.AutoSwapSlotName
		*out = new(string)
		**out = **in
	}
	if in.AzureStorageAccounts != nil {
		in, out := &in.AzureStorageAccounts, &out.AzureStorageAccounts
		*out = make(map[string]AzureStorageInfoValue, len(*in))
		for key, val := range *in {
			(*out)[key] = *val.DeepCopy()
		}
	}
	if in.ConnectionStrings != nil {
		in, out := &in.ConnectionStrings, &out.ConnectionStrings
		*out = make([]ConnStringInfo, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Cors != nil {
		in, out := &in.Cors, &out.Cors
		*out = new(CorsSettings)
		(*in).DeepCopyInto(*out)
	}
	if in.DefaultDocuments != nil {
		in, out := &in.DefaultDocuments, &out.DefaultDocuments
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.DetailedErrorLoggingEnabled != nil {
		in, out := &in.DetailedErrorLoggingEnabled, &out.DetailedErrorLoggingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.DocumentRoot != nil {
		in, out := &in.DocumentRoot, &out.DocumentRoot
		*out = new(string)
		**out = **in
	}
	if in.Experiments != nil {
		in, out := &in.Experiments, &out.Experiments
		*out = new(Experiments)
		(*in).DeepCopyInto(*out)
	}
	if in.FtpsState != nil {
		in, out := &in.FtpsState, &out.FtpsState
		*out = new(string)
		**out = **in
	}
	if in.FunctionAppScaleLimit != nil {
		in, out := &in.FunctionAppScaleLimit, &out.FunctionAppScaleLimit
		*out = new(int)
		**out = **in
	}
	if in.FunctionsRuntimeScaleMonitoringEnabled != nil {
		in, out := &in.FunctionsRuntimeScaleMonitoringEnabled, &out.FunctionsRuntimeScaleMonitoringEnabled
		*out = new(bool)
		**out = **in
	}
	if in.HandlerMappings != nil {
		in, out := &in.HandlerMappings, &out.HandlerMappings
		*out = make([]HandlerMapping, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.HealthCheckPath != nil {
		in, out := &in.HealthCheckPath, &out.HealthCheckPath
		*out = new(string)
		**out = **in
	}
	if in.Http20Enabled != nil {
		in, out := &in.Http20Enabled, &out.Http20Enabled
		*out = new(bool)
		**out = **in
	}
	if in.HttpLoggingEnabled != nil {
		in, out := &in.HttpLoggingEnabled, &out.HttpLoggingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.IpSecurityRestrictions != nil {
		in, out := &in.IpSecurityRestrictions, &out.IpSecurityRestrictions
		*out = make([]IpSecurityRestriction, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.JavaContainer != nil {
		in, out := &in.JavaContainer, &out.JavaContainer
		*out = new(string)
		**out = **in
	}
	if in.JavaContainerVersion != nil {
		in, out := &in.JavaContainerVersion, &out.JavaContainerVersion
		*out = new(string)
		**out = **in
	}
	if in.JavaVersion != nil {
		in, out := &in.JavaVersion, &out.JavaVersion
		*out = new(string)
		**out = **in
	}
	if in.KeyVaultReferenceIdentity != nil {
		in, out := &in.KeyVaultReferenceIdentity, &out.KeyVaultReferenceIdentity
		*out = new(string)
		**out = **in
	}
	if in.Limits != nil {
		in, out := &in.Limits, &out.Limits
		*out = new(SiteLimits)
		(*in).DeepCopyInto(*out)
	}
	if in.LinuxFxVersion != nil {
		in, out := &in.LinuxFxVersion, &out.LinuxFxVersion
		*out = new(string)
		**out = **in
	}
	if in.LoadBalancing != nil {
		in, out := &in.LoadBalancing, &out.LoadBalancing
		*out = new(string)
		**out = **in
	}
	if in.LocalMySqlEnabled != nil {
		in, out := &in.LocalMySqlEnabled, &out.LocalMySqlEnabled
		*out = new(bool)
		**out = **in
	}
	if in.LogsDirectorySizeLimit != nil {
		in, out := &in.LogsDirectorySizeLimit, &out.LogsDirectorySizeLimit
		*out = new(int)
		**out = **in
	}
	if in.ManagedPipelineMode != nil {
		in, out := &in.ManagedPipelineMode, &out.ManagedPipelineMode
		*out = new(string)
		**out = **in
	}
	if in.ManagedServiceIdentityId != nil {
		in, out := &in.ManagedServiceIdentityId, &out.ManagedServiceIdentityId
		*out = new(int)
		**out = **in
	}
	if in.MinTlsVersion != nil {
		in, out := &in.MinTlsVersion, &out.MinTlsVersion
		*out = new(string)
		**out = **in
	}
	if in.MinimumElasticInstanceCount != nil {
		in, out := &in.MinimumElasticInstanceCount, &out.MinimumElasticInstanceCount
		*out = new(int)
		**out = **in
	}
	if in.NetFrameworkVersion != nil {
		in, out := &in.NetFrameworkVersion, &out.NetFrameworkVersion
		*out = new(string)
		**out = **in
	}
	if in.NodeVersion != nil {
		in, out := &in.NodeVersion, &out.NodeVersion
		*out = new(string)
		**out = **in
	}
	if in.NumberOfWorkers != nil {
		in, out := &in.NumberOfWorkers, &out.NumberOfWorkers
		*out = new(int)
		**out = **in
	}
	if in.PhpVersion != nil {
		in, out := &in.PhpVersion, &out.PhpVersion
		*out = new(string)
		**out = **in
	}
	if in.PowerShellVersion != nil {
		in, out := &in.PowerShellVersion, &out.PowerShellVersion
		*out = new(string)
		**out = **in
	}
	if in.PreWarmedInstanceCount != nil {
		in, out := &in.PreWarmedInstanceCount, &out.PreWarmedInstanceCount
		*out = new(int)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.PublicNetworkAccess != nil {
		in, out := &in.PublicNetworkAccess, &out.PublicNetworkAccess
		*out = new(string)
		**out = **in
	}
	if in.PublishingUsername != nil {
		in, out := &in.PublishingUsername, &out.PublishingUsername
		*out = new(string)
		**out = **in
	}
	if in.Push != nil {
		in, out := &in.Push, &out.Push
		*out = new(PushSettings)
		(*in).DeepCopyInto(*out)
	}
	if in.PythonVersion != nil {
		in, out := &in.PythonVersion, &out.PythonVersion
		*out = new(string)
		**out = **in
	}
	if in.RemoteDebuggingEnabled != nil {
		in, out := &in.RemoteDebuggingEnabled, &out.RemoteDebuggingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.RemoteDebuggingVersion != nil {
		in, out := &in.RemoteDebuggingVersion, &out.RemoteDebuggingVersion
		*out = new(string)
		**out = **in
	}
	if in.RequestTracingEnabled != nil {
		in, out := &in.RequestTracingEnabled, &out.RequestTracingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.RequestTracingExpirationTime != nil {
		in, out := &in.RequestTracingExpirationTime, &out.RequestTracingExpirationTime
		*out = new(string)
		**out = **in
	}
	if in.ScmIpSecurityRestrictions != nil {
		in, out := &in.ScmIpSecurityRestrictions, &out.ScmIpSecurityRestrictions
		*out = make([]IpSecurityRestriction, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ScmIpSecurityRestrictionsUseMain != nil {
		in, out := &in.ScmIpSecurityRestrictionsUseMain, &out.ScmIpSecurityRestrictionsUseMain
		*out = new(bool)
		**out = **in
	}
	if in.ScmMinTlsVersion != nil {
		in, out := &in.ScmMinTlsVersion, &out.ScmMinTlsVersion
		*out = new(string)
		**out = **in
	}
	if in.ScmType != nil {
		in, out := &in.ScmType, &out.ScmType
		*out = new(string)
		**out = **in
	}
	if in.TracingOptions != nil {
		in, out := &in.TracingOptions, &out.TracingOptions
		*out = new(string)
		**out = **in
	}
	if in.Use32BitWorkerProcess != nil {
		in, out := &in.Use32BitWorkerProcess, &out.Use32BitWorkerProcess
		*out = new(bool)
		**out = **in
	}
	if in.VirtualApplications != nil {
		in, out := &in.VirtualApplications, &out.VirtualApplications
		*out = make([]VirtualApplication, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.VnetName != nil {
		in, out := &in.VnetName, &out.VnetName
		*out = new(string)
		**out = **in
	}
	if in.VnetPrivatePortsCount != nil {
		in, out := &in.VnetPrivatePortsCount, &out.VnetPrivatePortsCount
		*out = new(int)
		**out = **in
	}
	if in.VnetRouteAllEnabled != nil {
		in, out := &in.VnetRouteAllEnabled, &out.VnetRouteAllEnabled
		*out = new(bool)
		**out = **in
	}
	if in.WebSocketsEnabled != nil {
		in, out := &in.WebSocketsEnabled, &out.WebSocketsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.WebsiteTimeZone != nil {
		in, out := &in.WebsiteTimeZone, &out.WebsiteTimeZone
		*out = new(string)
		**out = **in
	}
	if in.WindowsFxVersion != nil {
		in, out := &in.WindowsFxVersion, &out.WindowsFxVersion
		*out = new(string)
		**out = **in
	}
	if in.XManagedServiceIdentityId != nil {
		in, out := &in.XManagedServiceIdentityId, &out.XManagedServiceIdentityId
		*out = new(int)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SiteConfig.
func (in *SiteConfig) DeepCopy() *SiteConfig {
	if in == nil {
		return nil
	}
	out := new(SiteConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SiteConfig_STATUS) DeepCopyInto(out *SiteConfig_STATUS) {
	*out = *in
	if in.AcrUseManagedIdentityCreds != nil {
		in, out := &in.AcrUseManagedIdentityCreds, &out.AcrUseManagedIdentityCreds
		*out = new(bool)
		**out = **in
	}
	if in.AcrUserManagedIdentityID != nil {
		in, out := &in.AcrUserManagedIdentityID, &out.AcrUserManagedIdentityID
		*out = new(string)
		**out = **in
	}
	if in.AlwaysOn != nil {
		in, out := &in.AlwaysOn, &out.AlwaysOn
		*out = new(bool)
		**out = **in
	}
	if in.ApiDefinition != nil {
		in, out := &in.ApiDefinition, &out.ApiDefinition
		*out = new(ApiDefinitionInfo_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.ApiManagementConfig != nil {
		in, out := &in.ApiManagementConfig, &out.ApiManagementConfig
		*out = new(ApiManagementConfig_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.AppCommandLine != nil {
		in, out := &in.AppCommandLine, &out.AppCommandLine
		*out = new(string)
		**out = **in
	}
	if in.AppSettings != nil {
		in, out := &in.AppSettings, &out.AppSettings
		*out = make([]NameValuePair_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.AutoHealEnabled != nil {
		in, out := &in.AutoHealEnabled, &out.AutoHealEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AutoHealRules != nil {
		in, out := &in.AutoHealRules, &out.AutoHealRules
		*out = new(AutoHealRules_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.AutoSwapSlotName != nil {
		in, out := &in.AutoSwapSlotName, &out.AutoSwapSlotName
		*out = new(string)
		**out = **in
	}
	if in.AzureStorageAccounts != nil {
		in, out := &in.AzureStorageAccounts, &out.AzureStorageAccounts
		*out = make(map[string]AzureStorageInfoValue_STATUS, len(*in))
		for key, val := range *in {
			(*out)[key] = *val.DeepCopy()
		}
	}
	if in.ConnectionStrings != nil {
		in, out := &in.ConnectionStrings, &out.ConnectionStrings
		*out = make([]ConnStringInfo_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Cors != nil {
		in, out := &in.Cors, &out.Cors
		*out = new(CorsSettings_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.DefaultDocuments != nil {
		in, out := &in.DefaultDocuments, &out.DefaultDocuments
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.DetailedErrorLoggingEnabled != nil {
		in, out := &in.DetailedErrorLoggingEnabled, &out.DetailedErrorLoggingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.DocumentRoot != nil {
		in, out := &in.DocumentRoot, &out.DocumentRoot
		*out = new(string)
		**out = **in
	}
	if in.Experiments != nil {
		in, out := &in.Experiments, &out.Experiments
		*out = new(Experiments_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.FtpsState != nil {
		in, out := &in.FtpsState, &out.FtpsState
		*out = new(string)
		**out = **in
	}
	if in.FunctionAppScaleLimit != nil {
		in, out := &in.FunctionAppScaleLimit, &out.FunctionAppScaleLimit
		*out = new(int)
		**out = **in
	}
	if in.FunctionsRuntimeScaleMonitoringEnabled != nil {
		in, out := &in.FunctionsRuntimeScaleMonitoringEnabled, &out.FunctionsRuntimeScaleMonitoringEnabled
		*out = new(bool)
		**out = **in
	}
	if in.HandlerMappings != nil {
		in, out := &in.HandlerMappings, &out.HandlerMappings
		*out = make([]HandlerMapping_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.HealthCheckPath != nil {
		in, out := &in.HealthCheckPath, &out.HealthCheckPath
		*out = new(string)
		**out = **in
	}
	if in.Http20Enabled != nil {
		in, out := &in.Http20Enabled, &out.Http20Enabled
		*out = new(bool)
		**out = **in
	}
	if in.HttpLoggingEnabled != nil {
		in, out := &in.HttpLoggingEnabled, &out.HttpLoggingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.IpSecurityRestrictions != nil {
		in, out := &in.IpSecurityRestrictions, &out.IpSecurityRestrictions
		*out = make([]IpSecurityRestriction_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.JavaContainer != nil {
		in, out := &in.JavaContainer, &out.JavaContainer
		*out = new(string)
		**out = **in
	}
	if in.JavaContainerVersion != nil {
		in, out := &in.JavaContainerVersion, &out.JavaContainerVersion
		*out = new(string)
		**out = **in
	}
	if in.JavaVersion != nil {
		in, out := &in.JavaVersion, &out.JavaVersion
		*out = new(string)
		**out = **in
	}
	if in.KeyVaultReferenceIdentity != nil {
		in, out := &in.KeyVaultReferenceIdentity, &out.KeyVaultReferenceIdentity
		*out = new(string)
		**out = **in
	}
	if in.Limits != nil {
		in, out := &in.Limits, &out.Limits
		*out = new(SiteLimits_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.LinuxFxVersion != nil {
		in, out := &in.LinuxFxVersion, &out.LinuxFxVersion
		*out = new(string)
		**out = **in
	}
	if in.LoadBalancing != nil {
		in, out := &in.LoadBalancing, &out.LoadBalancing
		*out = new(string)
		**out = **in
	}
	if in.LocalMySqlEnabled != nil {
		in, out := &in.LocalMySqlEnabled, &out.LocalMySqlEnabled
		*out = new(bool)
		**out = **in
	}
	if in.LogsDirectorySizeLimit != nil {
		in, out := &in.LogsDirectorySizeLimit, &out.LogsDirectorySizeLimit
		*out = new(int)
		**out = **in
	}
	if in.MachineKey != nil {
		in, out := &in.MachineKey, &out.MachineKey
		*out = new(SiteMachineKey_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.ManagedPipelineMode != nil {
		in, out := &in.ManagedPipelineMode, &out.ManagedPipelineMode
		*out = new(string)
		**out = **in
	}
	if in.ManagedServiceIdentityId != nil {
		in, out := &in.ManagedServiceIdentityId, &out.ManagedServiceIdentityId
		*out = new(int)
		**out = **in
	}
	if in.MinTlsVersion != nil {
		in, out := &in.MinTlsVersion, &out.MinTlsVersion
		*out = new(string)
		**out = **in
	}
	if in.MinimumElasticInstanceCount != nil {
		in, out := &in.MinimumElasticInstanceCount, &out.MinimumElasticInstanceCount
		*out = new(int)
		**out = **in
	}
	if in.NetFrameworkVersion != nil {
		in, out := &in.NetFrameworkVersion, &out.NetFrameworkVersion
		*out = new(string)
		**out = **in
	}
	if in.NodeVersion != nil {
		in, out := &in.NodeVersion, &out.NodeVersion
		*out = new(string)
		**out = **in
	}
	if in.NumberOfWorkers != nil {
		in, out := &in.NumberOfWorkers, &out.NumberOfWorkers
		*out = new(int)
		**out = **in
	}
	if in.PhpVersion != nil {
		in, out := &in.PhpVersion, &out.PhpVersion
		*out = new(string)
		**out = **in
	}
	if in.PowerShellVersion != nil {
		in, out := &in.PowerShellVersion, &out.PowerShellVersion
		*out = new(string)
		**out = **in
	}
	if in.PreWarmedInstanceCount != nil {
		in, out := &in.PreWarmedInstanceCount, &out.PreWarmedInstanceCount
		*out = new(int)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.PublicNetworkAccess != nil {
		in, out := &in.PublicNetworkAccess, &out.PublicNetworkAccess
		*out = new(string)
		**out = **in
	}
	if in.PublishingUsername != nil {
		in, out := &in.PublishingUsername, &out.PublishingUsername
		*out = new(string)
		**out = **in
	}
	if in.Push != nil {
		in, out := &in.Push, &out.Push
		*out = new(PushSettings_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.PythonVersion != nil {
		in, out := &in.PythonVersion, &out.PythonVersion
		*out = new(string)
		**out = **in
	}
	if in.RemoteDebuggingEnabled != nil {
		in, out := &in.RemoteDebuggingEnabled, &out.RemoteDebuggingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.RemoteDebuggingVersion != nil {
		in, out := &in.RemoteDebuggingVersion, &out.RemoteDebuggingVersion
		*out = new(string)
		**out = **in
	}
	if in.RequestTracingEnabled != nil {
		in, out := &in.RequestTracingEnabled, &out.RequestTracingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.RequestTracingExpirationTime != nil {
		in, out := &in.RequestTracingExpirationTime, &out.RequestTracingExpirationTime
		*out = new(string)
		**out = **in
	}
	if in.ScmIpSecurityRestrictions != nil {
		in, out := &in.ScmIpSecurityRestrictions, &out.ScmIpSecurityRestrictions
		*out = make([]IpSecurityRestriction_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ScmIpSecurityRestrictionsUseMain != nil {
		in, out := &in.ScmIpSecurityRestrictionsUseMain, &out.ScmIpSecurityRestrictionsUseMain
		*out = new(bool)
		**out = **in
	}
	if in.ScmMinTlsVersion != nil {
		in, out := &in.ScmMinTlsVersion, &out.ScmMinTlsVersion
		*out = new(string)
		**out = **in
	}
	if in.ScmType != nil {
		in, out := &in.ScmType, &out.ScmType
		*out = new(string)
		**out = **in
	}
	if in.TracingOptions != nil {
		in, out := &in.TracingOptions, &out.TracingOptions
		*out = new(string)
		**out = **in
	}
	if in.Use32BitWorkerProcess != nil {
		in, out := &in.Use32BitWorkerProcess, &out.Use32BitWorkerProcess
		*out = new(bool)
		**out = **in
	}
	if in.VirtualApplications != nil {
		in, out := &in.VirtualApplications, &out.VirtualApplications
		*out = make([]VirtualApplication_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.VnetName != nil {
		in, out := &in.VnetName, &out.VnetName
		*out = new(string)
		**out = **in
	}
	if in.VnetPrivatePortsCount != nil {
		in, out := &in.VnetPrivatePortsCount, &out.VnetPrivatePortsCount
		*out = new(int)
		**out = **in
	}
	if in.VnetRouteAllEnabled != nil {
		in, out := &in.VnetRouteAllEnabled, &out.VnetRouteAllEnabled
		*out = new(bool)
		**out = **in
	}
	if in.WebSocketsEnabled != nil {
		in, out := &in.WebSocketsEnabled, &out.WebSocketsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.WebsiteTimeZone != nil {
		in, out := &in.WebsiteTimeZone, &out.WebsiteTimeZone
		*out = new(string)
		**out = **in
	}
	if in.WindowsFxVersion != nil {
		in, out := &in.WindowsFxVersion, &out.WindowsFxVersion
		*out = new(string)
		**out = **in
	}
	if in.XManagedServiceIdentityId != nil {
		in, out := &in.XManagedServiceIdentityId, &out.XManagedServiceIdentityId
		*out = new(int)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SiteConfig_STATUS.
func (in *SiteConfig_STATUS) DeepCopy() *SiteConfig_STATUS {
	if in == nil {
		return nil
	}
	out := new(SiteConfig_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SiteLimits) DeepCopyInto(out *SiteLimits) {
	*out = *in
	if in.MaxDiskSizeInMb != nil {
		in, out := &in.MaxDiskSizeInMb, &out.MaxDiskSizeInMb
		*out = new(int)
		**out = **in
	}
	if in.MaxMemoryInMb != nil {
		in, out := &in.MaxMemoryInMb, &out.MaxMemoryInMb
		*out = new(int)
		**out = **in
	}
	if in.MaxPercentageCpu != nil {
		in, out := &in.MaxPercentageCpu, &out.MaxPercentageCpu
		*out = new(float64)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SiteLimits.
func (in *SiteLimits) DeepCopy() *SiteLimits {
	if in == nil {
		return nil
	}
	out := new(SiteLimits)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SiteLimits_STATUS) DeepCopyInto(out *SiteLimits_STATUS) {
	*out = *in
	if in.MaxDiskSizeInMb != nil {
		in, out := &in.MaxDiskSizeInMb, &out.MaxDiskSizeInMb
		*out = new(int)
		**out = **in
	}
	if in.MaxMemoryInMb != nil {
		in, out := &in.MaxMemoryInMb, &out.MaxMemoryInMb
		*out = new(int)
		**out = **in
	}
	if in.MaxPercentageCpu != nil {
		in, out := &in.MaxPercentageCpu, &out.MaxPercentageCpu
		*out = new(float64)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SiteLimits_STATUS.
func (in *SiteLimits_STATUS) DeepCopy() *SiteLimits_STATUS {
	if in == nil {
		return nil
	}
	out := new(SiteLimits_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SiteList) DeepCopyInto(out *SiteList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Site, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SiteList.
func (in *SiteList) DeepCopy() *SiteList {
	if in == nil {
		return nil
	}
	out := new(SiteList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *SiteList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SiteMachineKey_STATUS) DeepCopyInto(out *SiteMachineKey_STATUS) {
	*out = *in
	if in.Decryption != nil {
		in, out := &in.Decryption, &out.Decryption
		*out = new(string)
		**out = **in
	}
	if in.DecryptionKey != nil {
		in, out := &in.DecryptionKey, &out.DecryptionKey
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Validation != nil {
		in, out := &in.Validation, &out.Validation
		*out = new(string)
		**out = **in
	}
	if in.ValidationKey != nil {
		in, out := &in.ValidationKey, &out.ValidationKey
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SiteMachineKey_STATUS.
func (in *SiteMachineKey_STATUS) DeepCopy() *SiteMachineKey_STATUS {
	if in == nil {
		return nil
	}
	out := new(SiteMachineKey_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Site_STATUS) DeepCopyInto(out *Site_STATUS) {
	*out = *in
	if in.AvailabilityState != nil {
		in, out := &in.AvailabilityState, &out.AvailabilityState
		*out = new(string)
		**out = **in
	}
	if in.ClientAffinityEnabled != nil {
		in, out := &in.ClientAffinityEnabled, &out.ClientAffinityEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ClientCertEnabled != nil {
		in, out := &in.ClientCertEnabled, &out.ClientCertEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ClientCertExclusionPaths != nil {
		in, out := &in.ClientCertExclusionPaths, &out.ClientCertExclusionPaths
		*out = new(string)
		**out = **in
	}
	if in.ClientCertMode != nil {
		in, out := &in.ClientCertMode, &out.ClientCertMode
		*out = new(string)
		**out = **in
	}
	if in.CloningInfo != nil {
		in, out := &in.CloningInfo, &out.CloningInfo
		*out = new(CloningInfo_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]conditions.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ContainerSize != nil {
		in, out := &in.ContainerSize, &out.ContainerSize
		*out = new(int)
		**out = **in
	}
	if in.CustomDomainVerificationId != nil {
		in, out := &in.CustomDomainVerificationId, &out.CustomDomainVerificationId
		*out = new(string)
		**out = **in
	}
	if in.DailyMemoryTimeQuota != nil {
		in, out := &in.DailyMemoryTimeQuota, &out.DailyMemoryTimeQuota
		*out = new(int)
		**out = **in
	}
	if in.DefaultHostName != nil {
		in, out := &in.DefaultHostName, &out.DefaultHostName
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.EnabledHostNames != nil {
		in, out := &in.EnabledHostNames, &out.EnabledHostNames
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.ExtendedLocation != nil {
		in, out := &in.ExtendedLocation, &out.ExtendedLocation
		*out = new(ExtendedLocation_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.HostNameSslStates != nil {
		in, out := &in.HostNameSslStates, &out.HostNameSslStates
		*out = make([]HostNameSslState_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.HostNames != nil {
		in, out := &in.HostNames, &out.HostNames
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.HostNamesDisabled != nil {
		in, out := &in.HostNamesDisabled, &out.HostNamesDisabled
		*out = new(bool)
		**out = **in
	}
	if in.HostingEnvironmentProfile != nil {
		in, out := &in.HostingEnvironmentProfile, &out.HostingEnvironmentProfile
		*out = new(HostingEnvironmentProfile_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.HttpsOnly != nil {
		in, out := &in.HttpsOnly, &out.HttpsOnly
		*out = new(bool)
		**out = **in
	}
	if in.HyperV != nil {
		in, out := &in.HyperV, &out.HyperV
		*out = new(bool)
		**out = **in
	}
	if in.Id != nil {
		in, out := &in.Id, &out.Id
		*out = new(string)
		**out = **in
	}
	if in.Identity != nil {
		in, out := &in.Identity, &out.Identity
		*out = new(ManagedServiceIdentity_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.InProgressOperationId != nil {
		in, out := &in.InProgressOperationId, &out.InProgressOperationId
		*out = new(string)
		**out = **in
	}
	if in.IsDefaultContainer != nil {
		in, out := &in.IsDefaultContainer, &out.IsDefaultContainer
		*out = new(bool)
		**out = **in
	}
	if in.IsXenon != nil {
		in, out := &in.IsXenon, &out.IsXenon
		*out = new(bool)
		**out = **in
	}
	if in.KeyVaultReferenceIdentity != nil {
		in, out := &in.KeyVaultReferenceIdentity, &out.KeyVaultReferenceIdentity
		*out = new(string)
		**out = **in
	}
	if in.Kind != nil {
		in, out := &in.Kind, &out.Kind
		*out = new(string)
		**out = **in
	}
	if in.LastModifiedTimeUtc != nil {
		in, out := &in.LastModifiedTimeUtc, &out.LastModifiedTimeUtc
		*out = new(string)
		**out = **in
	}
	if in.Location != nil {
		in, out := &in.Location, &out.Location
		*out = new(string)
		**out = **in
	}
	if in.MaxNumberOfWorkers != nil {
		in, out := &in.MaxNumberOfWorkers, &out.MaxNumberOfWorkers
		*out = new(int)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.OutboundIpAddresses != nil {
		in, out := &in.OutboundIpAddresses, &out.OutboundIpAddresses
		*out = new(string)
		**out = **in
	}
	if in.PossibleOutboundIpAddresses != nil {
		in, out := &in.PossibleOutboundIpAddresses, &out.PossibleOutboundIpAddresses
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.PublicNetworkAccess != nil {
		in, out := &in.PublicNetworkAccess, &out.PublicNetworkAccess
		*out = new(string)
		**out = **in
	}
	if in.RedundancyMode != nil {
		in, out := &in.RedundancyMode, &out.RedundancyMode
		*out = new(string)
		**out = **in
	}
	if in.RepositorySiteName != nil {
		in, out := &in.RepositorySiteName, &out.RepositorySiteName
		*out = new(string)
		**out = **in
	}
	if in.Reserved != nil {
		in, out := &in.Reserved, &out.Reserved
		*out = new(bool)
		**out = **in
	}
	if in.ResourceGroup != nil {
		in, out := &in.ResourceGroup, &out.ResourceGroup
		*out = new(string)
		**out = **in
	}
	if in.ScmSiteAlsoStopped != nil {
		in, out := &in.ScmSiteAlsoStopped, &out.ScmSiteAlsoStopped
		*out = new(bool)
		**out = **in
	}
	if in.ServerFarmId != nil {
		in, out := &in.ServerFarmId, &out.ServerFarmId
		*out = new(string)
		**out = **in
	}
	if in.SiteConfig != nil {
		in, out := &in.SiteConfig, &out.SiteConfig
		*out = new(SiteConfig_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.SlotSwapStatus != nil {
		in, out := &in.SlotSwapStatus, &out.SlotSwapStatus
		*out = new(SlotSwapStatus_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.State != nil {
		in, out := &in.State, &out.State
		*out = new(string)
		**out = **in
	}
	if in.StorageAccountRequired != nil {
		in, out := &in.StorageAccountRequired, &out.StorageAccountRequired
		*out = new(bool)
		**out = **in
	}
	if in.SuspendedTill != nil {
		in, out := &in.SuspendedTill, &out.SuspendedTill
		*out = new(string)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.TargetSwapSlot != nil {
		in, out := &in.TargetSwapSlot, &out.TargetSwapSlot
		*out = new(string)
		**out = **in
	}
	if in.TrafficManagerHostNames != nil {
		in, out := &in.TrafficManagerHostNames, &out.TrafficManagerHostNames
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
	if in.UsageState != nil {
		in, out := &in.UsageState, &out.UsageState
		*out = new(string)
		**out = **in
	}
	if in.VirtualNetworkSubnetId != nil {
		in, out := &in.VirtualNetworkSubnetId, &out.VirtualNetworkSubnetId
		*out = new(string)
		**out = **in
	}
	if in.VnetContentShareEnabled != nil {
		in, out := &in.VnetContentShareEnabled, &out.VnetContentShareEnabled
		*out = new(bool)
		**out = **in
	}
	if in.VnetImagePullEnabled != nil {
		in, out := &in.VnetImagePullEnabled, &out.VnetImagePullEnabled
		*out = new(bool)
		**out = **in
	}
	if in.VnetRouteAllEnabled != nil {
		in, out := &in.VnetRouteAllEnabled, &out.VnetRouteAllEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Site_STATUS.
func (in *Site_STATUS) DeepCopy() *Site_STATUS {
	if in == nil {
		return nil
	}
	out := new(Site_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Site_Spec) DeepCopyInto(out *Site_Spec) {
	*out = *in
	if in.ClientAffinityEnabled != nil {
		in, out := &in.ClientAffinityEnabled, &out.ClientAffinityEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ClientCertEnabled != nil {
		in, out := &in.ClientCertEnabled, &out.ClientCertEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ClientCertExclusionPaths != nil {
		in, out := &in.ClientCertExclusionPaths, &out.ClientCertExclusionPaths
		*out = new(string)
		**out = **in
	}
	if in.ClientCertMode != nil {
		in, out := &in.ClientCertMode, &out.ClientCertMode
		*out = new(string)
		**out = **in
	}
	if in.CloningInfo != nil {
		in, out := &in.CloningInfo, &out.CloningInfo
		*out = new(CloningInfo)
		(*in).DeepCopyInto(*out)
	}
	if in.ContainerSize != nil {
		in, out := &in.ContainerSize, &out.ContainerSize
		*out = new(int)
		**out = **in
	}
	if in.CustomDomainVerificationId != nil {
		in, out := &in.CustomDomainVerificationId, &out.CustomDomainVerificationId
		*out = new(string)
		**out = **in
	}
	if in.DailyMemoryTimeQuota != nil {
		in, out := &in.DailyMemoryTimeQuota, &out.DailyMemoryTimeQuota
		*out = new(int)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.ExtendedLocation != nil {
		in, out := &in.ExtendedLocation, &out.ExtendedLocation
		*out = new(ExtendedLocation)
		(*in).DeepCopyInto(*out)
	}
	if in.HostNameSslStates != nil {
		in, out := &in.HostNameSslStates, &out.HostNameSslStates
		*out = make([]HostNameSslState, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.HostNamesDisabled != nil {
		in, out := &in.HostNamesDisabled, &out.HostNamesDisabled
		*out = new(bool)
		**out = **in
	}
	if in.HostingEnvironmentProfile != nil {
		in, out := &in.HostingEnvironmentProfile, &out.HostingEnvironmentProfile
		*out = new(HostingEnvironmentProfile)
		(*in).DeepCopyInto(*out)
	}
	if in.HttpsOnly != nil {
		in, out := &in.HttpsOnly, &out.HttpsOnly
		*out = new(bool)
		**out = **in
	}
	if in.HyperV != nil {
		in, out := &in.HyperV, &out.HyperV
		*out = new(bool)
		**out = **in
	}
	if in.Identity != nil {
		in, out := &in.Identity, &out.Identity
		*out = new(ManagedServiceIdentity)
		(*in).DeepCopyInto(*out)
	}
	if in.IsXenon != nil {
		in, out := &in.IsXenon, &out.IsXenon
		*out = new(bool)
		**out = **in
	}
	if in.KeyVaultReferenceIdentity != nil {
		in, out := &in.KeyVaultReferenceIdentity, &out.KeyVaultReferenceIdentity
		*out = new(string)
		**out = **in
	}
	if in.Kind != nil {
		in, out := &in.Kind, &out.Kind
		*out = new(string)
		**out = **in
	}
	if in.Location != nil {
		in, out := &in.Location, &out.Location
		*out = new(string)
		**out = **in
	}
	if in.Owner != nil {
		in, out := &in.Owner, &out.Owner
		*out = new(genruntime.KnownResourceReference)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.PublicNetworkAccess != nil {
		in, out := &in.PublicNetworkAccess, &out.PublicNetworkAccess
		*out = new(string)
		**out = **in
	}
	if in.RedundancyMode != nil {
		in, out := &in.RedundancyMode, &out.RedundancyMode
		*out = new(string)
		**out = **in
	}
	if in.Reserved != nil {
		in, out := &in.Reserved, &out.Reserved
		*out = new(bool)
		**out = **in
	}
	if in.ScmSiteAlsoStopped != nil {
		in, out := &in.ScmSiteAlsoStopped, &out.ScmSiteAlsoStopped
		*out = new(bool)
		**out = **in
	}
	if in.ServerFarmReference != nil {
		in, out := &in.ServerFarmReference, &out.ServerFarmReference
		*out = new(genruntime.ResourceReference)
		**out = **in
	}
	if in.SiteConfig != nil {
		in, out := &in.SiteConfig, &out.SiteConfig
		*out = new(SiteConfig)
		(*in).DeepCopyInto(*out)
	}
	if in.StorageAccountRequired != nil {
		in, out := &in.StorageAccountRequired, &out.StorageAccountRequired
		*out = new(bool)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.VirtualNetworkSubnetReference != nil {
		in, out := &in.VirtualNetworkSubnetReference, &out.VirtualNetworkSubnetReference
		*out = new(genruntime.ResourceReference)
		**out = **in
	}
	if in.VnetContentShareEnabled != nil {
		in, out := &in.VnetContentShareEnabled, &out.VnetContentShareEnabled
		*out = new(bool)
		**out = **in
	}
	if in.VnetImagePullEnabled != nil {
		in, out := &in.VnetImagePullEnabled, &out.VnetImagePullEnabled
		*out = new(bool)
		**out = **in
	}
	if in.VnetRouteAllEnabled != nil {
		in, out := &in.VnetRouteAllEnabled, &out.VnetRouteAllEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Site_Spec.
func (in *Site_Spec) DeepCopy() *Site_Spec {
	if in == nil {
		return nil
	}
	out := new(Site_Spec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SkuCapacity) DeepCopyInto(out *SkuCapacity) {
	*out = *in
	if in.Default != nil {
		in, out := &in.Default, &out.Default
		*out = new(int)
		**out = **in
	}
	if in.ElasticMaximum != nil {
		in, out := &in.ElasticMaximum, &out.ElasticMaximum
		*out = new(int)
		**out = **in
	}
	if in.Maximum != nil {
		in, out := &in.Maximum, &out.Maximum
		*out = new(int)
		**out = **in
	}
	if in.Minimum != nil {
		in, out := &in.Minimum, &out.Minimum
		*out = new(int)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ScaleType != nil {
		in, out := &in.ScaleType, &out.ScaleType
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SkuCapacity.
func (in *SkuCapacity) DeepCopy() *SkuCapacity {
	if in == nil {
		return nil
	}
	out := new(SkuCapacity)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SkuCapacity_STATUS) DeepCopyInto(out *SkuCapacity_STATUS) {
	*out = *in
	if in.Default != nil {
		in, out := &in.Default, &out.Default
		*out = new(int)
		**out = **in
	}
	if in.ElasticMaximum != nil {
		in, out := &in.ElasticMaximum, &out.ElasticMaximum
		*out = new(int)
		**out = **in
	}
	if in.Maximum != nil {
		in, out := &in.Maximum, &out.Maximum
		*out = new(int)
		**out = **in
	}
	if in.Minimum != nil {
		in, out := &in.Minimum, &out.Minimum
		*out = new(int)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.ScaleType != nil {
		in, out := &in.ScaleType, &out.ScaleType
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SkuCapacity_STATUS.
func (in *SkuCapacity_STATUS) DeepCopy() *SkuCapacity_STATUS {
	if in == nil {
		return nil
	}
	out := new(SkuCapacity_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SkuDescription) DeepCopyInto(out *SkuDescription) {
	*out = *in
	if in.Capabilities != nil {
		in, out := &in.Capabilities, &out.Capabilities
		*out = make([]Capability, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Capacity != nil {
		in, out := &in.Capacity, &out.Capacity
		*out = new(int)
		**out = **in
	}
	if in.Family != nil {
		in, out := &in.Family, &out.Family
		*out = new(string)
		**out = **in
	}
	if in.Locations != nil {
		in, out := &in.Locations, &out.Locations
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Size != nil {
		in, out := &in.Size, &out.Size
		*out = new(string)
		**out = **in
	}
	if in.SkuCapacity != nil {
		in, out := &in.SkuCapacity, &out.SkuCapacity
		*out = new(SkuCapacity)
		(*in).DeepCopyInto(*out)
	}
	if in.Tier != nil {
		in, out := &in.Tier, &out.Tier
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SkuDescription.
func (in *SkuDescription) DeepCopy() *SkuDescription {
	if in == nil {
		return nil
	}
	out := new(SkuDescription)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SkuDescription_STATUS) DeepCopyInto(out *SkuDescription_STATUS) {
	*out = *in
	if in.Capabilities != nil {
		in, out := &in.Capabilities, &out.Capabilities
		*out = make([]Capability_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Capacity != nil {
		in, out := &in.Capacity, &out.Capacity
		*out = new(int)
		**out = **in
	}
	if in.Family != nil {
		in, out := &in.Family, &out.Family
		*out = new(string)
		**out = **in
	}
	if in.Locations != nil {
		in, out := &in.Locations, &out.Locations
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Size != nil {
		in, out := &in.Size, &out.Size
		*out = new(string)
		**out = **in
	}
	if in.SkuCapacity != nil {
		in, out := &in.SkuCapacity, &out.SkuCapacity
		*out = new(SkuCapacity_STATUS)
		(*in).DeepCopyInto(*out)
	}
	if in.Tier != nil {
		in, out := &in.Tier, &out.Tier
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SkuDescription_STATUS.
func (in *SkuDescription_STATUS) DeepCopy() *SkuDescription_STATUS {
	if in == nil {
		return nil
	}
	out := new(SkuDescription_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SlotSwapStatus_STATUS) DeepCopyInto(out *SlotSwapStatus_STATUS) {
	*out = *in
	if in.DestinationSlotName != nil {
		in, out := &in.DestinationSlotName, &out.DestinationSlotName
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.SourceSlotName != nil {
		in, out := &in.SourceSlotName, &out.SourceSlotName
		*out = new(string)
		**out = **in
	}
	if in.TimestampUtc != nil {
		in, out := &in.TimestampUtc, &out.TimestampUtc
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SlotSwapStatus_STATUS.
func (in *SlotSwapStatus_STATUS) DeepCopy() *SlotSwapStatus_STATUS {
	if in == nil {
		return nil
	}
	out := new(SlotSwapStatus_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SlowRequestsBasedTrigger) DeepCopyInto(out *SlowRequestsBasedTrigger) {
	*out = *in
	if in.Count != nil {
		in, out := &in.Count, &out.Count
		*out = new(int)
		**out = **in
	}
	if in.Path != nil {
		in, out := &in.Path, &out.Path
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.TimeInterval != nil {
		in, out := &in.TimeInterval, &out.TimeInterval
		*out = new(string)
		**out = **in
	}
	if in.TimeTaken != nil {
		in, out := &in.TimeTaken, &out.TimeTaken
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SlowRequestsBasedTrigger.
func (in *SlowRequestsBasedTrigger) DeepCopy() *SlowRequestsBasedTrigger {
	if in == nil {
		return nil
	}
	out := new(SlowRequestsBasedTrigger)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SlowRequestsBasedTrigger_STATUS) DeepCopyInto(out *SlowRequestsBasedTrigger_STATUS) {
	*out = *in
	if in.Count != nil {
		in, out := &in.Count, &out.Count
		*out = new(int)
		**out = **in
	}
	if in.Path != nil {
		in, out := &in.Path, &out.Path
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.TimeInterval != nil {
		in, out := &in.TimeInterval, &out.TimeInterval
		*out = new(string)
		**out = **in
	}
	if in.TimeTaken != nil {
		in, out := &in.TimeTaken, &out.TimeTaken
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SlowRequestsBasedTrigger_STATUS.
func (in *SlowRequestsBasedTrigger_STATUS) DeepCopy() *SlowRequestsBasedTrigger_STATUS {
	if in == nil {
		return nil
	}
	out := new(SlowRequestsBasedTrigger_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *StatusCodesBasedTrigger) DeepCopyInto(out *StatusCodesBasedTrigger) {
	*out = *in
	if in.Count != nil {
		in, out := &in.Count, &out.Count
		*out = new(int)
		**out = **in
	}
	if in.Path != nil {
		in, out := &in.Path, &out.Path
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Status != nil {
		in, out := &in.Status, &out.Status
		*out = new(int)
		**out = **in
	}
	if in.SubStatus != nil {
		in, out := &in.SubStatus, &out.SubStatus
		*out = new(int)
		**out = **in
	}
	if in.TimeInterval != nil {
		in, out := &in.TimeInterval, &out.TimeInterval
		*out = new(string)
		**out = **in
	}
	if in.Win32Status != nil {
		in, out := &in.Win32Status, &out.Win32Status
		*out = new(int)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new StatusCodesBasedTrigger.
func (in *StatusCodesBasedTrigger) DeepCopy() *StatusCodesBasedTrigger {
	if in == nil {
		return nil
	}
	out := new(StatusCodesBasedTrigger)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *StatusCodesBasedTrigger_STATUS) DeepCopyInto(out *StatusCodesBasedTrigger_STATUS) {
	*out = *in
	if in.Count != nil {
		in, out := &in.Count, &out.Count
		*out = new(int)
		**out = **in
	}
	if in.Path != nil {
		in, out := &in.Path, &out.Path
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Status != nil {
		in, out := &in.Status, &out.Status
		*out = new(int)
		**out = **in
	}
	if in.SubStatus != nil {
		in, out := &in.SubStatus, &out.SubStatus
		*out = new(int)
		**out = **in
	}
	if in.TimeInterval != nil {
		in, out := &in.TimeInterval, &out.TimeInterval
		*out = new(string)
		**out = **in
	}
	if in.Win32Status != nil {
		in, out := &in.Win32Status, &out.Win32Status
		*out = new(int)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new StatusCodesBasedTrigger_STATUS.
func (in *StatusCodesBasedTrigger_STATUS) DeepCopy() *StatusCodesBasedTrigger_STATUS {
	if in == nil {
		return nil
	}
	out := new(StatusCodesBasedTrigger_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *StatusCodesRangeBasedTrigger) DeepCopyInto(out *StatusCodesRangeBasedTrigger) {
	*out = *in
	if in.Count != nil {
		in, out := &in.Count, &out.Count
		*out = new(int)
		**out = **in
	}
	if in.Path != nil {
		in, out := &in.Path, &out.Path
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.StatusCodes != nil {
		in, out := &in.StatusCodes, &out.StatusCodes
		*out = new(string)
		**out = **in
	}
	if in.TimeInterval != nil {
		in, out := &in.TimeInterval, &out.TimeInterval
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new StatusCodesRangeBasedTrigger.
func (in *StatusCodesRangeBasedTrigger) DeepCopy() *StatusCodesRangeBasedTrigger {
	if in == nil {
		return nil
	}
	out := new(StatusCodesRangeBasedTrigger)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *StatusCodesRangeBasedTrigger_STATUS) DeepCopyInto(out *StatusCodesRangeBasedTrigger_STATUS) {
	*out = *in
	if in.Count != nil {
		in, out := &in.Count, &out.Count
		*out = new(int)
		**out = **in
	}
	if in.Path != nil {
		in, out := &in.Path, &out.Path
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.StatusCodes != nil {
		in, out := &in.StatusCodes, &out.StatusCodes
		*out = new(string)
		**out = **in
	}
	if in.TimeInterval != nil {
		in, out := &in.TimeInterval, &out.TimeInterval
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new StatusCodesRangeBasedTrigger_STATUS.
func (in *StatusCodesRangeBasedTrigger_STATUS) DeepCopy() *StatusCodesRangeBasedTrigger_STATUS {
	if in == nil {
		return nil
	}
	out := new(StatusCodesRangeBasedTrigger_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *UserAssignedIdentityDetails) DeepCopyInto(out *UserAssignedIdentityDetails) {
	*out = *in
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	out.Reference = in.Reference
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new UserAssignedIdentityDetails.
func (in *UserAssignedIdentityDetails) DeepCopy() *UserAssignedIdentityDetails {
	if in == nil {
		return nil
	}
	out := new(UserAssignedIdentityDetails)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *UserAssignedIdentity_STATUS) DeepCopyInto(out *UserAssignedIdentity_STATUS) {
	*out = *in
	if in.ClientId != nil {
		in, out := &in.ClientId, &out.ClientId
		*out = new(string)
		**out = **in
	}
	if in.PrincipalId != nil {
		in, out := &in.PrincipalId, &out.PrincipalId
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new UserAssignedIdentity_STATUS.
func (in *UserAssignedIdentity_STATUS) DeepCopy() *UserAssignedIdentity_STATUS {
	if in == nil {
		return nil
	}
	out := new(UserAssignedIdentity_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *VirtualApplication) DeepCopyInto(out *VirtualApplication) {
	*out = *in
	if in.PhysicalPath != nil {
		in, out := &in.PhysicalPath, &out.PhysicalPath
		*out = new(string)
		**out = **in
	}
	if in.PreloadEnabled != nil {
		in, out := &in.PreloadEnabled, &out.PreloadEnabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.VirtualDirectories != nil {
		in, out := &in.VirtualDirectories, &out.VirtualDirectories
		*out = make([]VirtualDirectory, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.VirtualPath != nil {
		in, out := &in.VirtualPath, &out.VirtualPath
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VirtualApplication.
func (in *VirtualApplication) DeepCopy() *VirtualApplication {
	if in == nil {
		return nil
	}
	out := new(VirtualApplication)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *VirtualApplication_STATUS) DeepCopyInto(out *VirtualApplication_STATUS) {
	*out = *in
	if in.PhysicalPath != nil {
		in, out := &in.PhysicalPath, &out.PhysicalPath
		*out = new(string)
		**out = **in
	}
	if in.PreloadEnabled != nil {
		in, out := &in.PreloadEnabled, &out.PreloadEnabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.VirtualDirectories != nil {
		in, out := &in.VirtualDirectories, &out.VirtualDirectories
		*out = make([]VirtualDirectory_STATUS, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.VirtualPath != nil {
		in, out := &in.VirtualPath, &out.VirtualPath
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VirtualApplication_STATUS.
func (in *VirtualApplication_STATUS) DeepCopy() *VirtualApplication_STATUS {
	if in == nil {
		return nil
	}
	out := new(VirtualApplication_STATUS)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *VirtualDirectory) DeepCopyInto(out *VirtualDirectory) {
	*out = *in
	if in.PhysicalPath != nil {
		in, out := &in.PhysicalPath, &out.PhysicalPath
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.VirtualPath != nil {
		in, out := &in.VirtualPath, &out.VirtualPath
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VirtualDirectory.
func (in *VirtualDirectory) DeepCopy() *VirtualDirectory {
	if in == nil {
		return nil
	}
	out := new(VirtualDirectory)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *VirtualDirectory_STATUS) DeepCopyInto(out *VirtualDirectory_STATUS) {
	*out = *in
	if in.PhysicalPath != nil {
		in, out := &in.PhysicalPath, &out.PhysicalPath
		*out = new(string)
		**out = **in
	}
	if in.PropertyBag != nil {
		in, out := &in.PropertyBag, &out.PropertyBag
		*out = make(genruntime.PropertyBag, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.VirtualPath != nil {
		in, out := &in.VirtualPath, &out.VirtualPath
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VirtualDirectory_STATUS.
func (in *VirtualDirectory_STATUS) DeepCopy() *VirtualDirectory_STATUS {
	if in == nil {
		return nil
	}
	out := new(VirtualDirectory_STATUS)
	in.DeepCopyInto(out)
	return out
}
