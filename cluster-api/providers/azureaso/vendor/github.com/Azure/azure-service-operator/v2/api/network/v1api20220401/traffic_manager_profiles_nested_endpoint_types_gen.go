// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20220401

import (
	"fmt"
	v20220401s "github.com/Azure/azure-service-operator/v2/api/network/v1api20220401/storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /trafficmanager/resource-manager/Microsoft.Network/stable/2022-04-01/trafficmanager.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficmanagerprofiles/{profileName}/NestedEndpoints/{endpointName}
type TrafficManagerProfilesNestedEndpoint struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              Trafficmanagerprofiles_NestedEndpoint_Spec   `json:"spec,omitempty"`
	Status            Trafficmanagerprofiles_NestedEndpoint_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &TrafficManagerProfilesNestedEndpoint{}

// GetConditions returns the conditions of the resource
func (endpoint *TrafficManagerProfilesNestedEndpoint) GetConditions() conditions.Conditions {
	return endpoint.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (endpoint *TrafficManagerProfilesNestedEndpoint) SetConditions(conditions conditions.Conditions) {
	endpoint.Status.Conditions = conditions
}

var _ conversion.Convertible = &TrafficManagerProfilesNestedEndpoint{}

// ConvertFrom populates our TrafficManagerProfilesNestedEndpoint from the provided hub TrafficManagerProfilesNestedEndpoint
func (endpoint *TrafficManagerProfilesNestedEndpoint) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v20220401s.TrafficManagerProfilesNestedEndpoint)
	if !ok {
		return fmt.Errorf("expected network/v1api20220401/storage/TrafficManagerProfilesNestedEndpoint but received %T instead", hub)
	}

	return endpoint.AssignProperties_From_TrafficManagerProfilesNestedEndpoint(source)
}

// ConvertTo populates the provided hub TrafficManagerProfilesNestedEndpoint from our TrafficManagerProfilesNestedEndpoint
func (endpoint *TrafficManagerProfilesNestedEndpoint) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v20220401s.TrafficManagerProfilesNestedEndpoint)
	if !ok {
		return fmt.Errorf("expected network/v1api20220401/storage/TrafficManagerProfilesNestedEndpoint but received %T instead", hub)
	}

	return endpoint.AssignProperties_To_TrafficManagerProfilesNestedEndpoint(destination)
}

// +kubebuilder:webhook:path=/mutate-network-azure-com-v1api20220401-trafficmanagerprofilesnestedendpoint,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=network.azure.com,resources=trafficmanagerprofilesnestedendpoints,verbs=create;update,versions=v1api20220401,name=default.v1api20220401.trafficmanagerprofilesnestedendpoints.network.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &TrafficManagerProfilesNestedEndpoint{}

// Default applies defaults to the TrafficManagerProfilesNestedEndpoint resource
func (endpoint *TrafficManagerProfilesNestedEndpoint) Default() {
	endpoint.defaultImpl()
	var temp any = endpoint
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (endpoint *TrafficManagerProfilesNestedEndpoint) defaultAzureName() {
	if endpoint.Spec.AzureName == "" {
		endpoint.Spec.AzureName = endpoint.Name
	}
}

// defaultImpl applies the code generated defaults to the TrafficManagerProfilesNestedEndpoint resource
func (endpoint *TrafficManagerProfilesNestedEndpoint) defaultImpl() { endpoint.defaultAzureName() }

var _ genruntime.ImportableResource = &TrafficManagerProfilesNestedEndpoint{}

// InitializeSpec initializes the spec for this resource from the given status
func (endpoint *TrafficManagerProfilesNestedEndpoint) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*Trafficmanagerprofiles_NestedEndpoint_STATUS); ok {
		return endpoint.Spec.Initialize_From_Trafficmanagerprofiles_NestedEndpoint_STATUS(s)
	}

	return fmt.Errorf("expected Status of type Trafficmanagerprofiles_NestedEndpoint_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &TrafficManagerProfilesNestedEndpoint{}

// AzureName returns the Azure name of the resource
func (endpoint *TrafficManagerProfilesNestedEndpoint) AzureName() string {
	return endpoint.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2022-04-01"
func (endpoint TrafficManagerProfilesNestedEndpoint) GetAPIVersion() string {
	return string(APIVersion_Value)
}

// GetResourceScope returns the scope of the resource
func (endpoint *TrafficManagerProfilesNestedEndpoint) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (endpoint *TrafficManagerProfilesNestedEndpoint) GetSpec() genruntime.ConvertibleSpec {
	return &endpoint.Spec
}

// GetStatus returns the status of this resource
func (endpoint *TrafficManagerProfilesNestedEndpoint) GetStatus() genruntime.ConvertibleStatus {
	return &endpoint.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (endpoint *TrafficManagerProfilesNestedEndpoint) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Network/trafficmanagerprofiles/NestedEndpoints"
func (endpoint *TrafficManagerProfilesNestedEndpoint) GetType() string {
	return "Microsoft.Network/trafficmanagerprofiles/NestedEndpoints"
}

// NewEmptyStatus returns a new empty (blank) status
func (endpoint *TrafficManagerProfilesNestedEndpoint) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &Trafficmanagerprofiles_NestedEndpoint_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (endpoint *TrafficManagerProfilesNestedEndpoint) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(endpoint.Spec)
	return endpoint.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (endpoint *TrafficManagerProfilesNestedEndpoint) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*Trafficmanagerprofiles_NestedEndpoint_STATUS); ok {
		endpoint.Status = *st
		return nil
	}

	// Convert status to required version
	var st Trafficmanagerprofiles_NestedEndpoint_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	endpoint.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-network-azure-com-v1api20220401-trafficmanagerprofilesnestedendpoint,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=network.azure.com,resources=trafficmanagerprofilesnestedendpoints,verbs=create;update,versions=v1api20220401,name=validate.v1api20220401.trafficmanagerprofilesnestedendpoints.network.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &TrafficManagerProfilesNestedEndpoint{}

// ValidateCreate validates the creation of the resource
func (endpoint *TrafficManagerProfilesNestedEndpoint) ValidateCreate() (admission.Warnings, error) {
	validations := endpoint.createValidations()
	var temp any = endpoint
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	return genruntime.ValidateCreate(validations)
}

// ValidateDelete validates the deletion of the resource
func (endpoint *TrafficManagerProfilesNestedEndpoint) ValidateDelete() (admission.Warnings, error) {
	validations := endpoint.deleteValidations()
	var temp any = endpoint
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	return genruntime.ValidateDelete(validations)
}

// ValidateUpdate validates an update of the resource
func (endpoint *TrafficManagerProfilesNestedEndpoint) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	validations := endpoint.updateValidations()
	var temp any = endpoint
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	return genruntime.ValidateUpdate(old, validations)
}

// createValidations validates the creation of the resource
func (endpoint *TrafficManagerProfilesNestedEndpoint) createValidations() []func() (admission.Warnings, error) {
	return []func() (admission.Warnings, error){endpoint.validateResourceReferences, endpoint.validateOwnerReference}
}

// deleteValidations validates the deletion of the resource
func (endpoint *TrafficManagerProfilesNestedEndpoint) deleteValidations() []func() (admission.Warnings, error) {
	return nil
}

// updateValidations validates the update of the resource
func (endpoint *TrafficManagerProfilesNestedEndpoint) updateValidations() []func(old runtime.Object) (admission.Warnings, error) {
	return []func(old runtime.Object) (admission.Warnings, error){
		func(old runtime.Object) (admission.Warnings, error) {
			return endpoint.validateResourceReferences()
		},
		endpoint.validateWriteOnceProperties,
		func(old runtime.Object) (admission.Warnings, error) {
			return endpoint.validateOwnerReference()
		},
	}
}

// validateOwnerReference validates the owner field
func (endpoint *TrafficManagerProfilesNestedEndpoint) validateOwnerReference() (admission.Warnings, error) {
	return genruntime.ValidateOwner(endpoint)
}

// validateResourceReferences validates all resource references
func (endpoint *TrafficManagerProfilesNestedEndpoint) validateResourceReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindResourceReferences(&endpoint.Spec)
	if err != nil {
		return nil, err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (endpoint *TrafficManagerProfilesNestedEndpoint) validateWriteOnceProperties(old runtime.Object) (admission.Warnings, error) {
	oldObj, ok := old.(*TrafficManagerProfilesNestedEndpoint)
	if !ok {
		return nil, nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, endpoint)
}

// AssignProperties_From_TrafficManagerProfilesNestedEndpoint populates our TrafficManagerProfilesNestedEndpoint from the provided source TrafficManagerProfilesNestedEndpoint
func (endpoint *TrafficManagerProfilesNestedEndpoint) AssignProperties_From_TrafficManagerProfilesNestedEndpoint(source *v20220401s.TrafficManagerProfilesNestedEndpoint) error {

	// ObjectMeta
	endpoint.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec Trafficmanagerprofiles_NestedEndpoint_Spec
	err := spec.AssignProperties_From_Trafficmanagerprofiles_NestedEndpoint_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_Trafficmanagerprofiles_NestedEndpoint_Spec() to populate field Spec")
	}
	endpoint.Spec = spec

	// Status
	var status Trafficmanagerprofiles_NestedEndpoint_STATUS
	err = status.AssignProperties_From_Trafficmanagerprofiles_NestedEndpoint_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_Trafficmanagerprofiles_NestedEndpoint_STATUS() to populate field Status")
	}
	endpoint.Status = status

	// No error
	return nil
}

// AssignProperties_To_TrafficManagerProfilesNestedEndpoint populates the provided destination TrafficManagerProfilesNestedEndpoint from our TrafficManagerProfilesNestedEndpoint
func (endpoint *TrafficManagerProfilesNestedEndpoint) AssignProperties_To_TrafficManagerProfilesNestedEndpoint(destination *v20220401s.TrafficManagerProfilesNestedEndpoint) error {

	// ObjectMeta
	destination.ObjectMeta = *endpoint.ObjectMeta.DeepCopy()

	// Spec
	var spec v20220401s.Trafficmanagerprofiles_NestedEndpoint_Spec
	err := endpoint.Spec.AssignProperties_To_Trafficmanagerprofiles_NestedEndpoint_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_Trafficmanagerprofiles_NestedEndpoint_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v20220401s.Trafficmanagerprofiles_NestedEndpoint_STATUS
	err = endpoint.Status.AssignProperties_To_Trafficmanagerprofiles_NestedEndpoint_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_Trafficmanagerprofiles_NestedEndpoint_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (endpoint *TrafficManagerProfilesNestedEndpoint) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: endpoint.Spec.OriginalVersion(),
		Kind:    "TrafficManagerProfilesNestedEndpoint",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /trafficmanager/resource-manager/Microsoft.Network/stable/2022-04-01/trafficmanager.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficmanagerprofiles/{profileName}/NestedEndpoints/{endpointName}
type TrafficManagerProfilesNestedEndpointList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []TrafficManagerProfilesNestedEndpoint `json:"items"`
}

type Trafficmanagerprofiles_NestedEndpoint_Spec struct {
	// AlwaysServe: If Always Serve is enabled, probing for endpoint health will be disabled and endpoints will be included in
	// the traffic routing method.
	AlwaysServe *EndpointProperties_AlwaysServe `json:"alwaysServe,omitempty"`

	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// CustomHeaders: List of custom headers.
	CustomHeaders []EndpointProperties_CustomHeaders `json:"customHeaders,omitempty"`

	// EndpointLocation: Specifies the location of the external or nested endpoints when using the 'Performance' traffic
	// routing method.
	EndpointLocation *string `json:"endpointLocation,omitempty"`

	// EndpointMonitorStatus: The monitoring status of the endpoint.
	EndpointMonitorStatus *EndpointProperties_EndpointMonitorStatus `json:"endpointMonitorStatus,omitempty"`

	// EndpointStatus: The status of the endpoint. If the endpoint is Enabled, it is probed for endpoint health and is included
	// in the traffic routing method.
	EndpointStatus *EndpointProperties_EndpointStatus `json:"endpointStatus,omitempty"`

	// GeoMapping: The list of countries/regions mapped to this endpoint when using the 'Geographic' traffic routing method.
	// Please consult Traffic Manager Geographic documentation for a full list of accepted values.
	GeoMapping []string `json:"geoMapping,omitempty"`

	// MinChildEndpoints: The minimum number of endpoints that must be available in the child profile in order for the parent
	// profile to be considered available. Only applicable to endpoint of type 'NestedEndpoints'.
	MinChildEndpoints *int `json:"minChildEndpoints,omitempty"`

	// MinChildEndpointsIPv4: The minimum number of IPv4 (DNS record type A) endpoints that must be available in the child
	// profile in order for the parent profile to be considered available. Only applicable to endpoint of type
	// 'NestedEndpoints'.
	MinChildEndpointsIPv4 *int `json:"minChildEndpointsIPv4,omitempty"`

	// MinChildEndpointsIPv6: The minimum number of IPv6 (DNS record type AAAA) endpoints that must be available in the child
	// profile in order for the parent profile to be considered available. Only applicable to endpoint of type
	// 'NestedEndpoints'.
	MinChildEndpointsIPv6 *int `json:"minChildEndpointsIPv6,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a network.azure.com/TrafficManagerProfile resource
	Owner *genruntime.KnownResourceReference `group:"network.azure.com" json:"owner,omitempty" kind:"TrafficManagerProfile"`

	// Priority: The priority of this endpoint when using the 'Priority' traffic routing method. Possible values are from 1 to
	// 1000, lower values represent higher priority. This is an optional parameter.  If specified, it must be specified on all
	// endpoints, and no two endpoints can share the same priority value.
	Priority *int `json:"priority,omitempty"`

	// Subnets: The list of subnets, IP addresses, and/or address ranges mapped to this endpoint when using the 'Subnet'
	// traffic routing method. An empty list will match all ranges not covered by other endpoints.
	Subnets []EndpointProperties_Subnets `json:"subnets,omitempty"`

	// Target: The fully-qualified DNS name or IP address of the endpoint. Traffic Manager returns this value in DNS responses
	// to direct traffic to this endpoint.
	Target *string `json:"target,omitempty"`

	// TargetResourceReference: The Azure Resource URI of the of the endpoint. Not applicable to endpoints of type
	// 'ExternalEndpoints'.
	TargetResourceReference *genruntime.ResourceReference `armReference:"TargetResourceId" json:"targetResourceReference,omitempty"`

	// Type: The type of the resource. Ex- Microsoft.Network/trafficManagerProfiles.
	Type *string `json:"type,omitempty"`

	// Weight: The weight of this endpoint when using the 'Weighted' traffic routing method. Possible values are from 1 to 1000.
	Weight *int `json:"weight,omitempty"`
}

var _ genruntime.ARMTransformer = &Trafficmanagerprofiles_NestedEndpoint_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (endpoint *Trafficmanagerprofiles_NestedEndpoint_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if endpoint == nil {
		return nil, nil
	}
	result := &Trafficmanagerprofiles_NestedEndpoint_Spec_ARM{}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if endpoint.AlwaysServe != nil ||
		endpoint.CustomHeaders != nil ||
		endpoint.EndpointLocation != nil ||
		endpoint.EndpointMonitorStatus != nil ||
		endpoint.EndpointStatus != nil ||
		endpoint.GeoMapping != nil ||
		endpoint.MinChildEndpoints != nil ||
		endpoint.MinChildEndpointsIPv4 != nil ||
		endpoint.MinChildEndpointsIPv6 != nil ||
		endpoint.Priority != nil ||
		endpoint.Subnets != nil ||
		endpoint.Target != nil ||
		endpoint.TargetResourceReference != nil ||
		endpoint.Weight != nil {
		result.Properties = &EndpointProperties_ARM{}
	}
	if endpoint.AlwaysServe != nil {
		alwaysServe := *endpoint.AlwaysServe
		result.Properties.AlwaysServe = &alwaysServe
	}
	for _, item := range endpoint.CustomHeaders {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.CustomHeaders = append(result.Properties.CustomHeaders, *item_ARM.(*EndpointProperties_CustomHeaders_ARM))
	}
	if endpoint.EndpointLocation != nil {
		endpointLocation := *endpoint.EndpointLocation
		result.Properties.EndpointLocation = &endpointLocation
	}
	if endpoint.EndpointMonitorStatus != nil {
		endpointMonitorStatus := *endpoint.EndpointMonitorStatus
		result.Properties.EndpointMonitorStatus = &endpointMonitorStatus
	}
	if endpoint.EndpointStatus != nil {
		endpointStatus := *endpoint.EndpointStatus
		result.Properties.EndpointStatus = &endpointStatus
	}
	for _, item := range endpoint.GeoMapping {
		result.Properties.GeoMapping = append(result.Properties.GeoMapping, item)
	}
	if endpoint.MinChildEndpoints != nil {
		minChildEndpoints := *endpoint.MinChildEndpoints
		result.Properties.MinChildEndpoints = &minChildEndpoints
	}
	if endpoint.MinChildEndpointsIPv4 != nil {
		minChildEndpointsIPv4 := *endpoint.MinChildEndpointsIPv4
		result.Properties.MinChildEndpointsIPv4 = &minChildEndpointsIPv4
	}
	if endpoint.MinChildEndpointsIPv6 != nil {
		minChildEndpointsIPv6 := *endpoint.MinChildEndpointsIPv6
		result.Properties.MinChildEndpointsIPv6 = &minChildEndpointsIPv6
	}
	if endpoint.Priority != nil {
		priority := *endpoint.Priority
		result.Properties.Priority = &priority
	}
	for _, item := range endpoint.Subnets {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.Subnets = append(result.Properties.Subnets, *item_ARM.(*EndpointProperties_Subnets_ARM))
	}
	if endpoint.Target != nil {
		target := *endpoint.Target
		result.Properties.Target = &target
	}
	if endpoint.TargetResourceReference != nil {
		targetResourceIdARMID, err := resolved.ResolvedReferences.Lookup(*endpoint.TargetResourceReference)
		if err != nil {
			return nil, err
		}
		targetResourceId := targetResourceIdARMID
		result.Properties.TargetResourceId = &targetResourceId
	}
	if endpoint.Weight != nil {
		weight := *endpoint.Weight
		result.Properties.Weight = &weight
	}

	// Set property "Type":
	if endpoint.Type != nil {
		typeVar := *endpoint.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (endpoint *Trafficmanagerprofiles_NestedEndpoint_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Trafficmanagerprofiles_NestedEndpoint_Spec_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (endpoint *Trafficmanagerprofiles_NestedEndpoint_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Trafficmanagerprofiles_NestedEndpoint_Spec_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Trafficmanagerprofiles_NestedEndpoint_Spec_ARM, got %T", armInput)
	}

	// Set property "AlwaysServe":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AlwaysServe != nil {
			alwaysServe := *typedInput.Properties.AlwaysServe
			endpoint.AlwaysServe = &alwaysServe
		}
	}

	// Set property "AzureName":
	endpoint.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "CustomHeaders":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.CustomHeaders {
			var item1 EndpointProperties_CustomHeaders
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.CustomHeaders = append(endpoint.CustomHeaders, item1)
		}
	}

	// Set property "EndpointLocation":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EndpointLocation != nil {
			endpointLocation := *typedInput.Properties.EndpointLocation
			endpoint.EndpointLocation = &endpointLocation
		}
	}

	// Set property "EndpointMonitorStatus":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EndpointMonitorStatus != nil {
			endpointMonitorStatus := *typedInput.Properties.EndpointMonitorStatus
			endpoint.EndpointMonitorStatus = &endpointMonitorStatus
		}
	}

	// Set property "EndpointStatus":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EndpointStatus != nil {
			endpointStatus := *typedInput.Properties.EndpointStatus
			endpoint.EndpointStatus = &endpointStatus
		}
	}

	// Set property "GeoMapping":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.GeoMapping {
			endpoint.GeoMapping = append(endpoint.GeoMapping, item)
		}
	}

	// Set property "MinChildEndpoints":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinChildEndpoints != nil {
			minChildEndpoints := *typedInput.Properties.MinChildEndpoints
			endpoint.MinChildEndpoints = &minChildEndpoints
		}
	}

	// Set property "MinChildEndpointsIPv4":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinChildEndpointsIPv4 != nil {
			minChildEndpointsIPv4 := *typedInput.Properties.MinChildEndpointsIPv4
			endpoint.MinChildEndpointsIPv4 = &minChildEndpointsIPv4
		}
	}

	// Set property "MinChildEndpointsIPv6":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinChildEndpointsIPv6 != nil {
			minChildEndpointsIPv6 := *typedInput.Properties.MinChildEndpointsIPv6
			endpoint.MinChildEndpointsIPv6 = &minChildEndpointsIPv6
		}
	}

	// Set property "Owner":
	endpoint.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "Priority":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Priority != nil {
			priority := *typedInput.Properties.Priority
			endpoint.Priority = &priority
		}
	}

	// Set property "Subnets":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Subnets {
			var item1 EndpointProperties_Subnets
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.Subnets = append(endpoint.Subnets, item1)
		}
	}

	// Set property "Target":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Target != nil {
			target := *typedInput.Properties.Target
			endpoint.Target = &target
		}
	}

	// no assignment for property "TargetResourceReference"

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		endpoint.Type = &typeVar
	}

	// Set property "Weight":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Weight != nil {
			weight := *typedInput.Properties.Weight
			endpoint.Weight = &weight
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &Trafficmanagerprofiles_NestedEndpoint_Spec{}

// ConvertSpecFrom populates our Trafficmanagerprofiles_NestedEndpoint_Spec from the provided source
func (endpoint *Trafficmanagerprofiles_NestedEndpoint_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v20220401s.Trafficmanagerprofiles_NestedEndpoint_Spec)
	if ok {
		// Populate our instance from source
		return endpoint.AssignProperties_From_Trafficmanagerprofiles_NestedEndpoint_Spec(src)
	}

	// Convert to an intermediate form
	src = &v20220401s.Trafficmanagerprofiles_NestedEndpoint_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = endpoint.AssignProperties_From_Trafficmanagerprofiles_NestedEndpoint_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our Trafficmanagerprofiles_NestedEndpoint_Spec
func (endpoint *Trafficmanagerprofiles_NestedEndpoint_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v20220401s.Trafficmanagerprofiles_NestedEndpoint_Spec)
	if ok {
		// Populate destination from our instance
		return endpoint.AssignProperties_To_Trafficmanagerprofiles_NestedEndpoint_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &v20220401s.Trafficmanagerprofiles_NestedEndpoint_Spec{}
	err := endpoint.AssignProperties_To_Trafficmanagerprofiles_NestedEndpoint_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_Trafficmanagerprofiles_NestedEndpoint_Spec populates our Trafficmanagerprofiles_NestedEndpoint_Spec from the provided source Trafficmanagerprofiles_NestedEndpoint_Spec
func (endpoint *Trafficmanagerprofiles_NestedEndpoint_Spec) AssignProperties_From_Trafficmanagerprofiles_NestedEndpoint_Spec(source *v20220401s.Trafficmanagerprofiles_NestedEndpoint_Spec) error {

	// AlwaysServe
	if source.AlwaysServe != nil {
		alwaysServe := EndpointProperties_AlwaysServe(*source.AlwaysServe)
		endpoint.AlwaysServe = &alwaysServe
	} else {
		endpoint.AlwaysServe = nil
	}

	// AzureName
	endpoint.AzureName = source.AzureName

	// CustomHeaders
	if source.CustomHeaders != nil {
		customHeaderList := make([]EndpointProperties_CustomHeaders, len(source.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range source.CustomHeaders {
			// Shadow the loop variable to avoid aliasing
			customHeaderItem := customHeaderItem
			var customHeader EndpointProperties_CustomHeaders
			err := customHeader.AssignProperties_From_EndpointProperties_CustomHeaders(&customHeaderItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_EndpointProperties_CustomHeaders() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		endpoint.CustomHeaders = customHeaderList
	} else {
		endpoint.CustomHeaders = nil
	}

	// EndpointLocation
	endpoint.EndpointLocation = genruntime.ClonePointerToString(source.EndpointLocation)

	// EndpointMonitorStatus
	if source.EndpointMonitorStatus != nil {
		endpointMonitorStatus := EndpointProperties_EndpointMonitorStatus(*source.EndpointMonitorStatus)
		endpoint.EndpointMonitorStatus = &endpointMonitorStatus
	} else {
		endpoint.EndpointMonitorStatus = nil
	}

	// EndpointStatus
	if source.EndpointStatus != nil {
		endpointStatus := EndpointProperties_EndpointStatus(*source.EndpointStatus)
		endpoint.EndpointStatus = &endpointStatus
	} else {
		endpoint.EndpointStatus = nil
	}

	// GeoMapping
	endpoint.GeoMapping = genruntime.CloneSliceOfString(source.GeoMapping)

	// MinChildEndpoints
	endpoint.MinChildEndpoints = genruntime.ClonePointerToInt(source.MinChildEndpoints)

	// MinChildEndpointsIPv4
	endpoint.MinChildEndpointsIPv4 = genruntime.ClonePointerToInt(source.MinChildEndpointsIPv4)

	// MinChildEndpointsIPv6
	endpoint.MinChildEndpointsIPv6 = genruntime.ClonePointerToInt(source.MinChildEndpointsIPv6)

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		endpoint.Owner = &owner
	} else {
		endpoint.Owner = nil
	}

	// Priority
	endpoint.Priority = genruntime.ClonePointerToInt(source.Priority)

	// Subnets
	if source.Subnets != nil {
		subnetList := make([]EndpointProperties_Subnets, len(source.Subnets))
		for subnetIndex, subnetItem := range source.Subnets {
			// Shadow the loop variable to avoid aliasing
			subnetItem := subnetItem
			var subnet EndpointProperties_Subnets
			err := subnet.AssignProperties_From_EndpointProperties_Subnets(&subnetItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_EndpointProperties_Subnets() to populate field Subnets")
			}
			subnetList[subnetIndex] = subnet
		}
		endpoint.Subnets = subnetList
	} else {
		endpoint.Subnets = nil
	}

	// Target
	endpoint.Target = genruntime.ClonePointerToString(source.Target)

	// TargetResourceReference
	if source.TargetResourceReference != nil {
		targetResourceReference := source.TargetResourceReference.Copy()
		endpoint.TargetResourceReference = &targetResourceReference
	} else {
		endpoint.TargetResourceReference = nil
	}

	// Type
	endpoint.Type = genruntime.ClonePointerToString(source.Type)

	// Weight
	endpoint.Weight = genruntime.ClonePointerToInt(source.Weight)

	// No error
	return nil
}

// AssignProperties_To_Trafficmanagerprofiles_NestedEndpoint_Spec populates the provided destination Trafficmanagerprofiles_NestedEndpoint_Spec from our Trafficmanagerprofiles_NestedEndpoint_Spec
func (endpoint *Trafficmanagerprofiles_NestedEndpoint_Spec) AssignProperties_To_Trafficmanagerprofiles_NestedEndpoint_Spec(destination *v20220401s.Trafficmanagerprofiles_NestedEndpoint_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AlwaysServe
	if endpoint.AlwaysServe != nil {
		alwaysServe := string(*endpoint.AlwaysServe)
		destination.AlwaysServe = &alwaysServe
	} else {
		destination.AlwaysServe = nil
	}

	// AzureName
	destination.AzureName = endpoint.AzureName

	// CustomHeaders
	if endpoint.CustomHeaders != nil {
		customHeaderList := make([]v20220401s.EndpointProperties_CustomHeaders, len(endpoint.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range endpoint.CustomHeaders {
			// Shadow the loop variable to avoid aliasing
			customHeaderItem := customHeaderItem
			var customHeader v20220401s.EndpointProperties_CustomHeaders
			err := customHeaderItem.AssignProperties_To_EndpointProperties_CustomHeaders(&customHeader)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_EndpointProperties_CustomHeaders() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		destination.CustomHeaders = customHeaderList
	} else {
		destination.CustomHeaders = nil
	}

	// EndpointLocation
	destination.EndpointLocation = genruntime.ClonePointerToString(endpoint.EndpointLocation)

	// EndpointMonitorStatus
	if endpoint.EndpointMonitorStatus != nil {
		endpointMonitorStatus := string(*endpoint.EndpointMonitorStatus)
		destination.EndpointMonitorStatus = &endpointMonitorStatus
	} else {
		destination.EndpointMonitorStatus = nil
	}

	// EndpointStatus
	if endpoint.EndpointStatus != nil {
		endpointStatus := string(*endpoint.EndpointStatus)
		destination.EndpointStatus = &endpointStatus
	} else {
		destination.EndpointStatus = nil
	}

	// GeoMapping
	destination.GeoMapping = genruntime.CloneSliceOfString(endpoint.GeoMapping)

	// MinChildEndpoints
	destination.MinChildEndpoints = genruntime.ClonePointerToInt(endpoint.MinChildEndpoints)

	// MinChildEndpointsIPv4
	destination.MinChildEndpointsIPv4 = genruntime.ClonePointerToInt(endpoint.MinChildEndpointsIPv4)

	// MinChildEndpointsIPv6
	destination.MinChildEndpointsIPv6 = genruntime.ClonePointerToInt(endpoint.MinChildEndpointsIPv6)

	// OriginalVersion
	destination.OriginalVersion = endpoint.OriginalVersion()

	// Owner
	if endpoint.Owner != nil {
		owner := endpoint.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Priority
	destination.Priority = genruntime.ClonePointerToInt(endpoint.Priority)

	// Subnets
	if endpoint.Subnets != nil {
		subnetList := make([]v20220401s.EndpointProperties_Subnets, len(endpoint.Subnets))
		for subnetIndex, subnetItem := range endpoint.Subnets {
			// Shadow the loop variable to avoid aliasing
			subnetItem := subnetItem
			var subnet v20220401s.EndpointProperties_Subnets
			err := subnetItem.AssignProperties_To_EndpointProperties_Subnets(&subnet)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_EndpointProperties_Subnets() to populate field Subnets")
			}
			subnetList[subnetIndex] = subnet
		}
		destination.Subnets = subnetList
	} else {
		destination.Subnets = nil
	}

	// Target
	destination.Target = genruntime.ClonePointerToString(endpoint.Target)

	// TargetResourceReference
	if endpoint.TargetResourceReference != nil {
		targetResourceReference := endpoint.TargetResourceReference.Copy()
		destination.TargetResourceReference = &targetResourceReference
	} else {
		destination.TargetResourceReference = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(endpoint.Type)

	// Weight
	destination.Weight = genruntime.ClonePointerToInt(endpoint.Weight)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Trafficmanagerprofiles_NestedEndpoint_STATUS populates our Trafficmanagerprofiles_NestedEndpoint_Spec from the provided source Trafficmanagerprofiles_NestedEndpoint_STATUS
func (endpoint *Trafficmanagerprofiles_NestedEndpoint_Spec) Initialize_From_Trafficmanagerprofiles_NestedEndpoint_STATUS(source *Trafficmanagerprofiles_NestedEndpoint_STATUS) error {

	// AlwaysServe
	if source.AlwaysServe != nil {
		alwaysServe := EndpointProperties_AlwaysServe(*source.AlwaysServe)
		endpoint.AlwaysServe = &alwaysServe
	} else {
		endpoint.AlwaysServe = nil
	}

	// CustomHeaders
	if source.CustomHeaders != nil {
		customHeaderList := make([]EndpointProperties_CustomHeaders, len(source.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range source.CustomHeaders {
			// Shadow the loop variable to avoid aliasing
			customHeaderItem := customHeaderItem
			var customHeader EndpointProperties_CustomHeaders
			err := customHeader.Initialize_From_EndpointProperties_CustomHeaders_STATUS(&customHeaderItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_EndpointProperties_CustomHeaders_STATUS() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		endpoint.CustomHeaders = customHeaderList
	} else {
		endpoint.CustomHeaders = nil
	}

	// EndpointLocation
	endpoint.EndpointLocation = genruntime.ClonePointerToString(source.EndpointLocation)

	// EndpointMonitorStatus
	if source.EndpointMonitorStatus != nil {
		endpointMonitorStatus := EndpointProperties_EndpointMonitorStatus(*source.EndpointMonitorStatus)
		endpoint.EndpointMonitorStatus = &endpointMonitorStatus
	} else {
		endpoint.EndpointMonitorStatus = nil
	}

	// EndpointStatus
	if source.EndpointStatus != nil {
		endpointStatus := EndpointProperties_EndpointStatus(*source.EndpointStatus)
		endpoint.EndpointStatus = &endpointStatus
	} else {
		endpoint.EndpointStatus = nil
	}

	// GeoMapping
	endpoint.GeoMapping = genruntime.CloneSliceOfString(source.GeoMapping)

	// MinChildEndpoints
	endpoint.MinChildEndpoints = genruntime.ClonePointerToInt(source.MinChildEndpoints)

	// MinChildEndpointsIPv4
	endpoint.MinChildEndpointsIPv4 = genruntime.ClonePointerToInt(source.MinChildEndpointsIPv4)

	// MinChildEndpointsIPv6
	endpoint.MinChildEndpointsIPv6 = genruntime.ClonePointerToInt(source.MinChildEndpointsIPv6)

	// Priority
	endpoint.Priority = genruntime.ClonePointerToInt(source.Priority)

	// Subnets
	if source.Subnets != nil {
		subnetList := make([]EndpointProperties_Subnets, len(source.Subnets))
		for subnetIndex, subnetItem := range source.Subnets {
			// Shadow the loop variable to avoid aliasing
			subnetItem := subnetItem
			var subnet EndpointProperties_Subnets
			err := subnet.Initialize_From_EndpointProperties_Subnets_STATUS(&subnetItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_EndpointProperties_Subnets_STATUS() to populate field Subnets")
			}
			subnetList[subnetIndex] = subnet
		}
		endpoint.Subnets = subnetList
	} else {
		endpoint.Subnets = nil
	}

	// Target
	endpoint.Target = genruntime.ClonePointerToString(source.Target)

	// TargetResourceReference
	if source.TargetResourceId != nil {
		targetResourceReference := genruntime.CreateResourceReferenceFromARMID(*source.TargetResourceId)
		endpoint.TargetResourceReference = &targetResourceReference
	} else {
		endpoint.TargetResourceReference = nil
	}

	// Type
	endpoint.Type = genruntime.ClonePointerToString(source.Type)

	// Weight
	endpoint.Weight = genruntime.ClonePointerToInt(source.Weight)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (endpoint *Trafficmanagerprofiles_NestedEndpoint_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (endpoint *Trafficmanagerprofiles_NestedEndpoint_Spec) SetAzureName(azureName string) {
	endpoint.AzureName = azureName
}

type Trafficmanagerprofiles_NestedEndpoint_STATUS struct {
	// AlwaysServe: If Always Serve is enabled, probing for endpoint health will be disabled and endpoints will be included in
	// the traffic routing method.
	AlwaysServe *EndpointProperties_AlwaysServe_STATUS `json:"alwaysServe,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// CustomHeaders: List of custom headers.
	CustomHeaders []EndpointProperties_CustomHeaders_STATUS `json:"customHeaders,omitempty"`

	// EndpointLocation: Specifies the location of the external or nested endpoints when using the 'Performance' traffic
	// routing method.
	EndpointLocation *string `json:"endpointLocation,omitempty"`

	// EndpointMonitorStatus: The monitoring status of the endpoint.
	EndpointMonitorStatus *EndpointProperties_EndpointMonitorStatus_STATUS `json:"endpointMonitorStatus,omitempty"`

	// EndpointStatus: The status of the endpoint. If the endpoint is Enabled, it is probed for endpoint health and is included
	// in the traffic routing method.
	EndpointStatus *EndpointProperties_EndpointStatus_STATUS `json:"endpointStatus,omitempty"`

	// GeoMapping: The list of countries/regions mapped to this endpoint when using the 'Geographic' traffic routing method.
	// Please consult Traffic Manager Geographic documentation for a full list of accepted values.
	GeoMapping []string `json:"geoMapping,omitempty"`

	// Id: Fully qualified resource Id for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{resourceName}
	Id *string `json:"id,omitempty"`

	// MinChildEndpoints: The minimum number of endpoints that must be available in the child profile in order for the parent
	// profile to be considered available. Only applicable to endpoint of type 'NestedEndpoints'.
	MinChildEndpoints *int `json:"minChildEndpoints,omitempty"`

	// MinChildEndpointsIPv4: The minimum number of IPv4 (DNS record type A) endpoints that must be available in the child
	// profile in order for the parent profile to be considered available. Only applicable to endpoint of type
	// 'NestedEndpoints'.
	MinChildEndpointsIPv4 *int `json:"minChildEndpointsIPv4,omitempty"`

	// MinChildEndpointsIPv6: The minimum number of IPv6 (DNS record type AAAA) endpoints that must be available in the child
	// profile in order for the parent profile to be considered available. Only applicable to endpoint of type
	// 'NestedEndpoints'.
	MinChildEndpointsIPv6 *int `json:"minChildEndpointsIPv6,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// Priority: The priority of this endpoint when using the 'Priority' traffic routing method. Possible values are from 1 to
	// 1000, lower values represent higher priority. This is an optional parameter.  If specified, it must be specified on all
	// endpoints, and no two endpoints can share the same priority value.
	Priority *int `json:"priority,omitempty"`

	// Subnets: The list of subnets, IP addresses, and/or address ranges mapped to this endpoint when using the 'Subnet'
	// traffic routing method. An empty list will match all ranges not covered by other endpoints.
	Subnets []EndpointProperties_Subnets_STATUS `json:"subnets,omitempty"`

	// Target: The fully-qualified DNS name or IP address of the endpoint. Traffic Manager returns this value in DNS responses
	// to direct traffic to this endpoint.
	Target *string `json:"target,omitempty"`

	// TargetResourceId: The Azure Resource URI of the of the endpoint. Not applicable to endpoints of type 'ExternalEndpoints'.
	TargetResourceId *string `json:"targetResourceId,omitempty"`

	// Type: The type of the resource. Ex- Microsoft.Network/trafficManagerProfiles.
	Type *string `json:"type,omitempty"`

	// Weight: The weight of this endpoint when using the 'Weighted' traffic routing method. Possible values are from 1 to 1000.
	Weight *int `json:"weight,omitempty"`
}

var _ genruntime.ConvertibleStatus = &Trafficmanagerprofiles_NestedEndpoint_STATUS{}

// ConvertStatusFrom populates our Trafficmanagerprofiles_NestedEndpoint_STATUS from the provided source
func (endpoint *Trafficmanagerprofiles_NestedEndpoint_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v20220401s.Trafficmanagerprofiles_NestedEndpoint_STATUS)
	if ok {
		// Populate our instance from source
		return endpoint.AssignProperties_From_Trafficmanagerprofiles_NestedEndpoint_STATUS(src)
	}

	// Convert to an intermediate form
	src = &v20220401s.Trafficmanagerprofiles_NestedEndpoint_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = endpoint.AssignProperties_From_Trafficmanagerprofiles_NestedEndpoint_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our Trafficmanagerprofiles_NestedEndpoint_STATUS
func (endpoint *Trafficmanagerprofiles_NestedEndpoint_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v20220401s.Trafficmanagerprofiles_NestedEndpoint_STATUS)
	if ok {
		// Populate destination from our instance
		return endpoint.AssignProperties_To_Trafficmanagerprofiles_NestedEndpoint_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &v20220401s.Trafficmanagerprofiles_NestedEndpoint_STATUS{}
	err := endpoint.AssignProperties_To_Trafficmanagerprofiles_NestedEndpoint_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &Trafficmanagerprofiles_NestedEndpoint_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (endpoint *Trafficmanagerprofiles_NestedEndpoint_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Trafficmanagerprofiles_NestedEndpoint_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (endpoint *Trafficmanagerprofiles_NestedEndpoint_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Trafficmanagerprofiles_NestedEndpoint_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Trafficmanagerprofiles_NestedEndpoint_STATUS_ARM, got %T", armInput)
	}

	// Set property "AlwaysServe":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AlwaysServe != nil {
			alwaysServe := *typedInput.Properties.AlwaysServe
			endpoint.AlwaysServe = &alwaysServe
		}
	}

	// no assignment for property "Conditions"

	// Set property "CustomHeaders":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.CustomHeaders {
			var item1 EndpointProperties_CustomHeaders_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.CustomHeaders = append(endpoint.CustomHeaders, item1)
		}
	}

	// Set property "EndpointLocation":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EndpointLocation != nil {
			endpointLocation := *typedInput.Properties.EndpointLocation
			endpoint.EndpointLocation = &endpointLocation
		}
	}

	// Set property "EndpointMonitorStatus":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EndpointMonitorStatus != nil {
			endpointMonitorStatus := *typedInput.Properties.EndpointMonitorStatus
			endpoint.EndpointMonitorStatus = &endpointMonitorStatus
		}
	}

	// Set property "EndpointStatus":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EndpointStatus != nil {
			endpointStatus := *typedInput.Properties.EndpointStatus
			endpoint.EndpointStatus = &endpointStatus
		}
	}

	// Set property "GeoMapping":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.GeoMapping {
			endpoint.GeoMapping = append(endpoint.GeoMapping, item)
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		endpoint.Id = &id
	}

	// Set property "MinChildEndpoints":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinChildEndpoints != nil {
			minChildEndpoints := *typedInput.Properties.MinChildEndpoints
			endpoint.MinChildEndpoints = &minChildEndpoints
		}
	}

	// Set property "MinChildEndpointsIPv4":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinChildEndpointsIPv4 != nil {
			minChildEndpointsIPv4 := *typedInput.Properties.MinChildEndpointsIPv4
			endpoint.MinChildEndpointsIPv4 = &minChildEndpointsIPv4
		}
	}

	// Set property "MinChildEndpointsIPv6":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinChildEndpointsIPv6 != nil {
			minChildEndpointsIPv6 := *typedInput.Properties.MinChildEndpointsIPv6
			endpoint.MinChildEndpointsIPv6 = &minChildEndpointsIPv6
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		endpoint.Name = &name
	}

	// Set property "Priority":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Priority != nil {
			priority := *typedInput.Properties.Priority
			endpoint.Priority = &priority
		}
	}

	// Set property "Subnets":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Subnets {
			var item1 EndpointProperties_Subnets_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.Subnets = append(endpoint.Subnets, item1)
		}
	}

	// Set property "Target":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Target != nil {
			target := *typedInput.Properties.Target
			endpoint.Target = &target
		}
	}

	// Set property "TargetResourceId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TargetResourceId != nil {
			targetResourceId := *typedInput.Properties.TargetResourceId
			endpoint.TargetResourceId = &targetResourceId
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		endpoint.Type = &typeVar
	}

	// Set property "Weight":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Weight != nil {
			weight := *typedInput.Properties.Weight
			endpoint.Weight = &weight
		}
	}

	// No error
	return nil
}

// AssignProperties_From_Trafficmanagerprofiles_NestedEndpoint_STATUS populates our Trafficmanagerprofiles_NestedEndpoint_STATUS from the provided source Trafficmanagerprofiles_NestedEndpoint_STATUS
func (endpoint *Trafficmanagerprofiles_NestedEndpoint_STATUS) AssignProperties_From_Trafficmanagerprofiles_NestedEndpoint_STATUS(source *v20220401s.Trafficmanagerprofiles_NestedEndpoint_STATUS) error {

	// AlwaysServe
	if source.AlwaysServe != nil {
		alwaysServe := EndpointProperties_AlwaysServe_STATUS(*source.AlwaysServe)
		endpoint.AlwaysServe = &alwaysServe
	} else {
		endpoint.AlwaysServe = nil
	}

	// Conditions
	endpoint.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// CustomHeaders
	if source.CustomHeaders != nil {
		customHeaderList := make([]EndpointProperties_CustomHeaders_STATUS, len(source.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range source.CustomHeaders {
			// Shadow the loop variable to avoid aliasing
			customHeaderItem := customHeaderItem
			var customHeader EndpointProperties_CustomHeaders_STATUS
			err := customHeader.AssignProperties_From_EndpointProperties_CustomHeaders_STATUS(&customHeaderItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_EndpointProperties_CustomHeaders_STATUS() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		endpoint.CustomHeaders = customHeaderList
	} else {
		endpoint.CustomHeaders = nil
	}

	// EndpointLocation
	endpoint.EndpointLocation = genruntime.ClonePointerToString(source.EndpointLocation)

	// EndpointMonitorStatus
	if source.EndpointMonitorStatus != nil {
		endpointMonitorStatus := EndpointProperties_EndpointMonitorStatus_STATUS(*source.EndpointMonitorStatus)
		endpoint.EndpointMonitorStatus = &endpointMonitorStatus
	} else {
		endpoint.EndpointMonitorStatus = nil
	}

	// EndpointStatus
	if source.EndpointStatus != nil {
		endpointStatus := EndpointProperties_EndpointStatus_STATUS(*source.EndpointStatus)
		endpoint.EndpointStatus = &endpointStatus
	} else {
		endpoint.EndpointStatus = nil
	}

	// GeoMapping
	endpoint.GeoMapping = genruntime.CloneSliceOfString(source.GeoMapping)

	// Id
	endpoint.Id = genruntime.ClonePointerToString(source.Id)

	// MinChildEndpoints
	endpoint.MinChildEndpoints = genruntime.ClonePointerToInt(source.MinChildEndpoints)

	// MinChildEndpointsIPv4
	endpoint.MinChildEndpointsIPv4 = genruntime.ClonePointerToInt(source.MinChildEndpointsIPv4)

	// MinChildEndpointsIPv6
	endpoint.MinChildEndpointsIPv6 = genruntime.ClonePointerToInt(source.MinChildEndpointsIPv6)

	// Name
	endpoint.Name = genruntime.ClonePointerToString(source.Name)

	// Priority
	endpoint.Priority = genruntime.ClonePointerToInt(source.Priority)

	// Subnets
	if source.Subnets != nil {
		subnetList := make([]EndpointProperties_Subnets_STATUS, len(source.Subnets))
		for subnetIndex, subnetItem := range source.Subnets {
			// Shadow the loop variable to avoid aliasing
			subnetItem := subnetItem
			var subnet EndpointProperties_Subnets_STATUS
			err := subnet.AssignProperties_From_EndpointProperties_Subnets_STATUS(&subnetItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_EndpointProperties_Subnets_STATUS() to populate field Subnets")
			}
			subnetList[subnetIndex] = subnet
		}
		endpoint.Subnets = subnetList
	} else {
		endpoint.Subnets = nil
	}

	// Target
	endpoint.Target = genruntime.ClonePointerToString(source.Target)

	// TargetResourceId
	endpoint.TargetResourceId = genruntime.ClonePointerToString(source.TargetResourceId)

	// Type
	endpoint.Type = genruntime.ClonePointerToString(source.Type)

	// Weight
	endpoint.Weight = genruntime.ClonePointerToInt(source.Weight)

	// No error
	return nil
}

// AssignProperties_To_Trafficmanagerprofiles_NestedEndpoint_STATUS populates the provided destination Trafficmanagerprofiles_NestedEndpoint_STATUS from our Trafficmanagerprofiles_NestedEndpoint_STATUS
func (endpoint *Trafficmanagerprofiles_NestedEndpoint_STATUS) AssignProperties_To_Trafficmanagerprofiles_NestedEndpoint_STATUS(destination *v20220401s.Trafficmanagerprofiles_NestedEndpoint_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AlwaysServe
	if endpoint.AlwaysServe != nil {
		alwaysServe := string(*endpoint.AlwaysServe)
		destination.AlwaysServe = &alwaysServe
	} else {
		destination.AlwaysServe = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(endpoint.Conditions)

	// CustomHeaders
	if endpoint.CustomHeaders != nil {
		customHeaderList := make([]v20220401s.EndpointProperties_CustomHeaders_STATUS, len(endpoint.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range endpoint.CustomHeaders {
			// Shadow the loop variable to avoid aliasing
			customHeaderItem := customHeaderItem
			var customHeader v20220401s.EndpointProperties_CustomHeaders_STATUS
			err := customHeaderItem.AssignProperties_To_EndpointProperties_CustomHeaders_STATUS(&customHeader)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_EndpointProperties_CustomHeaders_STATUS() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		destination.CustomHeaders = customHeaderList
	} else {
		destination.CustomHeaders = nil
	}

	// EndpointLocation
	destination.EndpointLocation = genruntime.ClonePointerToString(endpoint.EndpointLocation)

	// EndpointMonitorStatus
	if endpoint.EndpointMonitorStatus != nil {
		endpointMonitorStatus := string(*endpoint.EndpointMonitorStatus)
		destination.EndpointMonitorStatus = &endpointMonitorStatus
	} else {
		destination.EndpointMonitorStatus = nil
	}

	// EndpointStatus
	if endpoint.EndpointStatus != nil {
		endpointStatus := string(*endpoint.EndpointStatus)
		destination.EndpointStatus = &endpointStatus
	} else {
		destination.EndpointStatus = nil
	}

	// GeoMapping
	destination.GeoMapping = genruntime.CloneSliceOfString(endpoint.GeoMapping)

	// Id
	destination.Id = genruntime.ClonePointerToString(endpoint.Id)

	// MinChildEndpoints
	destination.MinChildEndpoints = genruntime.ClonePointerToInt(endpoint.MinChildEndpoints)

	// MinChildEndpointsIPv4
	destination.MinChildEndpointsIPv4 = genruntime.ClonePointerToInt(endpoint.MinChildEndpointsIPv4)

	// MinChildEndpointsIPv6
	destination.MinChildEndpointsIPv6 = genruntime.ClonePointerToInt(endpoint.MinChildEndpointsIPv6)

	// Name
	destination.Name = genruntime.ClonePointerToString(endpoint.Name)

	// Priority
	destination.Priority = genruntime.ClonePointerToInt(endpoint.Priority)

	// Subnets
	if endpoint.Subnets != nil {
		subnetList := make([]v20220401s.EndpointProperties_Subnets_STATUS, len(endpoint.Subnets))
		for subnetIndex, subnetItem := range endpoint.Subnets {
			// Shadow the loop variable to avoid aliasing
			subnetItem := subnetItem
			var subnet v20220401s.EndpointProperties_Subnets_STATUS
			err := subnetItem.AssignProperties_To_EndpointProperties_Subnets_STATUS(&subnet)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_EndpointProperties_Subnets_STATUS() to populate field Subnets")
			}
			subnetList[subnetIndex] = subnet
		}
		destination.Subnets = subnetList
	} else {
		destination.Subnets = nil
	}

	// Target
	destination.Target = genruntime.ClonePointerToString(endpoint.Target)

	// TargetResourceId
	destination.TargetResourceId = genruntime.ClonePointerToString(endpoint.TargetResourceId)

	// Type
	destination.Type = genruntime.ClonePointerToString(endpoint.Type)

	// Weight
	destination.Weight = genruntime.ClonePointerToInt(endpoint.Weight)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&TrafficManagerProfilesNestedEndpoint{}, &TrafficManagerProfilesNestedEndpointList{})
}
