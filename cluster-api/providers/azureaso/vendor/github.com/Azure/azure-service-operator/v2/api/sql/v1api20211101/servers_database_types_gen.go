// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20211101

import (
	"fmt"
	v20211101s "github.com/Azure/azure-service-operator/v2/api/sql/v1api20211101/storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /sql/resource-manager/Microsoft.Sql/stable/2021-11-01/Databases.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}
type ServersDatabase struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              Servers_Database_Spec   `json:"spec,omitempty"`
	Status            Servers_Database_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &ServersDatabase{}

// GetConditions returns the conditions of the resource
func (database *ServersDatabase) GetConditions() conditions.Conditions {
	return database.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (database *ServersDatabase) SetConditions(conditions conditions.Conditions) {
	database.Status.Conditions = conditions
}

var _ conversion.Convertible = &ServersDatabase{}

// ConvertFrom populates our ServersDatabase from the provided hub ServersDatabase
func (database *ServersDatabase) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v20211101s.ServersDatabase)
	if !ok {
		return fmt.Errorf("expected sql/v1api20211101/storage/ServersDatabase but received %T instead", hub)
	}

	return database.AssignProperties_From_ServersDatabase(source)
}

// ConvertTo populates the provided hub ServersDatabase from our ServersDatabase
func (database *ServersDatabase) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v20211101s.ServersDatabase)
	if !ok {
		return fmt.Errorf("expected sql/v1api20211101/storage/ServersDatabase but received %T instead", hub)
	}

	return database.AssignProperties_To_ServersDatabase(destination)
}

// +kubebuilder:webhook:path=/mutate-sql-azure-com-v1api20211101-serversdatabase,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=sql.azure.com,resources=serversdatabases,verbs=create;update,versions=v1api20211101,name=default.v1api20211101.serversdatabases.sql.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &ServersDatabase{}

// Default applies defaults to the ServersDatabase resource
func (database *ServersDatabase) Default() {
	database.defaultImpl()
	var temp any = database
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (database *ServersDatabase) defaultAzureName() {
	if database.Spec.AzureName == "" {
		database.Spec.AzureName = database.Name
	}
}

// defaultImpl applies the code generated defaults to the ServersDatabase resource
func (database *ServersDatabase) defaultImpl() { database.defaultAzureName() }

var _ genruntime.ImportableResource = &ServersDatabase{}

// InitializeSpec initializes the spec for this resource from the given status
func (database *ServersDatabase) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*Servers_Database_STATUS); ok {
		return database.Spec.Initialize_From_Servers_Database_STATUS(s)
	}

	return fmt.Errorf("expected Status of type Servers_Database_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &ServersDatabase{}

// AzureName returns the Azure name of the resource
func (database *ServersDatabase) AzureName() string {
	return database.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2021-11-01"
func (database ServersDatabase) GetAPIVersion() string {
	return string(APIVersion_Value)
}

// GetResourceScope returns the scope of the resource
func (database *ServersDatabase) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (database *ServersDatabase) GetSpec() genruntime.ConvertibleSpec {
	return &database.Spec
}

// GetStatus returns the status of this resource
func (database *ServersDatabase) GetStatus() genruntime.ConvertibleStatus {
	return &database.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (database *ServersDatabase) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Sql/servers/databases"
func (database *ServersDatabase) GetType() string {
	return "Microsoft.Sql/servers/databases"
}

// NewEmptyStatus returns a new empty (blank) status
func (database *ServersDatabase) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &Servers_Database_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (database *ServersDatabase) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(database.Spec)
	return database.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (database *ServersDatabase) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*Servers_Database_STATUS); ok {
		database.Status = *st
		return nil
	}

	// Convert status to required version
	var st Servers_Database_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	database.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-sql-azure-com-v1api20211101-serversdatabase,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=sql.azure.com,resources=serversdatabases,verbs=create;update,versions=v1api20211101,name=validate.v1api20211101.serversdatabases.sql.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &ServersDatabase{}

// ValidateCreate validates the creation of the resource
func (database *ServersDatabase) ValidateCreate() (admission.Warnings, error) {
	validations := database.createValidations()
	var temp any = database
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	return genruntime.ValidateCreate(validations)
}

// ValidateDelete validates the deletion of the resource
func (database *ServersDatabase) ValidateDelete() (admission.Warnings, error) {
	validations := database.deleteValidations()
	var temp any = database
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	return genruntime.ValidateDelete(validations)
}

// ValidateUpdate validates an update of the resource
func (database *ServersDatabase) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	validations := database.updateValidations()
	var temp any = database
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	return genruntime.ValidateUpdate(old, validations)
}

// createValidations validates the creation of the resource
func (database *ServersDatabase) createValidations() []func() (admission.Warnings, error) {
	return []func() (admission.Warnings, error){database.validateResourceReferences, database.validateOwnerReference}
}

// deleteValidations validates the deletion of the resource
func (database *ServersDatabase) deleteValidations() []func() (admission.Warnings, error) {
	return nil
}

// updateValidations validates the update of the resource
func (database *ServersDatabase) updateValidations() []func(old runtime.Object) (admission.Warnings, error) {
	return []func(old runtime.Object) (admission.Warnings, error){
		func(old runtime.Object) (admission.Warnings, error) {
			return database.validateResourceReferences()
		},
		database.validateWriteOnceProperties,
		func(old runtime.Object) (admission.Warnings, error) {
			return database.validateOwnerReference()
		},
	}
}

// validateOwnerReference validates the owner field
func (database *ServersDatabase) validateOwnerReference() (admission.Warnings, error) {
	return genruntime.ValidateOwner(database)
}

// validateResourceReferences validates all resource references
func (database *ServersDatabase) validateResourceReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindResourceReferences(&database.Spec)
	if err != nil {
		return nil, err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (database *ServersDatabase) validateWriteOnceProperties(old runtime.Object) (admission.Warnings, error) {
	oldObj, ok := old.(*ServersDatabase)
	if !ok {
		return nil, nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, database)
}

// AssignProperties_From_ServersDatabase populates our ServersDatabase from the provided source ServersDatabase
func (database *ServersDatabase) AssignProperties_From_ServersDatabase(source *v20211101s.ServersDatabase) error {

	// ObjectMeta
	database.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec Servers_Database_Spec
	err := spec.AssignProperties_From_Servers_Database_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_Servers_Database_Spec() to populate field Spec")
	}
	database.Spec = spec

	// Status
	var status Servers_Database_STATUS
	err = status.AssignProperties_From_Servers_Database_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_Servers_Database_STATUS() to populate field Status")
	}
	database.Status = status

	// No error
	return nil
}

// AssignProperties_To_ServersDatabase populates the provided destination ServersDatabase from our ServersDatabase
func (database *ServersDatabase) AssignProperties_To_ServersDatabase(destination *v20211101s.ServersDatabase) error {

	// ObjectMeta
	destination.ObjectMeta = *database.ObjectMeta.DeepCopy()

	// Spec
	var spec v20211101s.Servers_Database_Spec
	err := database.Spec.AssignProperties_To_Servers_Database_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_Servers_Database_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v20211101s.Servers_Database_STATUS
	err = database.Status.AssignProperties_To_Servers_Database_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_Servers_Database_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (database *ServersDatabase) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: database.Spec.OriginalVersion(),
		Kind:    "ServersDatabase",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /sql/resource-manager/Microsoft.Sql/stable/2021-11-01/Databases.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}/databases/{databaseName}
type ServersDatabaseList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ServersDatabase `json:"items"`
}

type Servers_Database_Spec struct {
	// AutoPauseDelay: Time in minutes after which database is automatically paused. A value of -1 means that automatic pause
	// is disabled
	AutoPauseDelay *int `json:"autoPauseDelay,omitempty"`

	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// CatalogCollation: Collation of the metadata catalog.
	CatalogCollation *DatabaseProperties_CatalogCollation `json:"catalogCollation,omitempty"`

	// Collation: The collation of the database.
	Collation *string `json:"collation,omitempty"`

	// CreateMode: Specifies the mode of database creation.
	// Default: regular database creation.
	// Copy: creates a database as a copy of an existing database. sourceDatabaseId must be specified as the resource ID of the
	// source database.
	// Secondary: creates a database as a secondary replica of an existing database. sourceDatabaseId must be specified as the
	// resource ID of the existing primary database.
	// PointInTimeRestore: Creates a database by restoring a point in time backup of an existing database. sourceDatabaseId
	// must be specified as the resource ID of the existing database, and restorePointInTime must be specified.
	// Recovery: Creates a database by restoring a geo-replicated backup. sourceDatabaseId must be specified as the recoverable
	// database resource ID to restore.
	// Restore: Creates a database by restoring a backup of a deleted database. sourceDatabaseId must be specified. If
	// sourceDatabaseId is the database's original resource ID, then sourceDatabaseDeletionDate must be specified. Otherwise
	// sourceDatabaseId must be the restorable dropped database resource ID and sourceDatabaseDeletionDate is ignored.
	// restorePointInTime may also be specified to restore from an earlier point in time.
	// RestoreLongTermRetentionBackup: Creates a database by restoring from a long term retention vault.
	// recoveryServicesRecoveryPointResourceId must be specified as the recovery point resource ID.
	// Copy, Secondary, and RestoreLongTermRetentionBackup are not supported for DataWarehouse edition.
	CreateMode *DatabaseProperties_CreateMode `json:"createMode,omitempty"`

	// ElasticPoolReference: The resource identifier of the elastic pool containing this database.
	ElasticPoolReference *genruntime.ResourceReference `armReference:"ElasticPoolId" json:"elasticPoolReference,omitempty"`

	// +kubebuilder:validation:Pattern="^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$"
	// FederatedClientId: The Client id used for cross tenant per database CMK scenario
	FederatedClientId *string `json:"federatedClientId,omitempty"`

	// HighAvailabilityReplicaCount: The number of secondary replicas associated with the database that are used to provide
	// high availability. Not applicable to a Hyperscale database within an elastic pool.
	HighAvailabilityReplicaCount *int `json:"highAvailabilityReplicaCount,omitempty"`

	// Identity: The Azure Active Directory identity of the database.
	Identity *DatabaseIdentity `json:"identity,omitempty"`

	// IsLedgerOn: Whether or not this database is a ledger database, which means all tables in the database are ledger tables.
	// Note: the value of this property cannot be changed after the database has been created.
	IsLedgerOn *bool `json:"isLedgerOn,omitempty"`

	// LicenseType: The license type to apply for this database. `LicenseIncluded` if you need a license, or `BasePrice` if you
	// have a license and are eligible for the Azure Hybrid Benefit.
	LicenseType *DatabaseProperties_LicenseType `json:"licenseType,omitempty"`

	// +kubebuilder:validation:Required
	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// LongTermRetentionBackupResourceReference: The resource identifier of the long term retention backup associated with
	// create operation of this database.
	LongTermRetentionBackupResourceReference *genruntime.ResourceReference `armReference:"LongTermRetentionBackupResourceId" json:"longTermRetentionBackupResourceReference,omitempty"`

	// MaintenanceConfigurationId: Maintenance configuration id assigned to the database. This configuration defines the period
	// when the maintenance updates will occur.
	MaintenanceConfigurationId *string `json:"maintenanceConfigurationId,omitempty"`

	// MaxSizeBytes: The max size of the database expressed in bytes.
	MaxSizeBytes *int `json:"maxSizeBytes,omitempty"`

	// MinCapacity: Minimal capacity that database will always have allocated, if not paused
	MinCapacity *float64 `json:"minCapacity,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a sql.azure.com/Server resource
	Owner *genruntime.KnownResourceReference `group:"sql.azure.com" json:"owner,omitempty" kind:"Server"`

	// ReadScale: The state of read-only routing. If enabled, connections that have application intent set to readonly in their
	// connection string may be routed to a readonly secondary replica in the same region. Not applicable to a Hyperscale
	// database within an elastic pool.
	ReadScale *DatabaseProperties_ReadScale `json:"readScale,omitempty"`

	// RecoverableDatabaseReference: The resource identifier of the recoverable database associated with create operation of
	// this database.
	RecoverableDatabaseReference *genruntime.ResourceReference `armReference:"RecoverableDatabaseId" json:"recoverableDatabaseReference,omitempty"`

	// RecoveryServicesRecoveryPointReference: The resource identifier of the recovery point associated with create operation
	// of this database.
	RecoveryServicesRecoveryPointReference *genruntime.ResourceReference `armReference:"RecoveryServicesRecoveryPointId" json:"recoveryServicesRecoveryPointReference,omitempty"`

	// RequestedBackupStorageRedundancy: The storage account type to be used to store backups for this database.
	RequestedBackupStorageRedundancy *DatabaseProperties_RequestedBackupStorageRedundancy `json:"requestedBackupStorageRedundancy,omitempty"`

	// RestorableDroppedDatabaseReference: The resource identifier of the restorable dropped database associated with create
	// operation of this database.
	RestorableDroppedDatabaseReference *genruntime.ResourceReference `armReference:"RestorableDroppedDatabaseId" json:"restorableDroppedDatabaseReference,omitempty"`

	// RestorePointInTime: Specifies the point in time (ISO8601 format) of the source database that will be restored to create
	// the new database.
	RestorePointInTime *string `json:"restorePointInTime,omitempty"`

	// SampleName: The name of the sample schema to apply when creating this database.
	SampleName *DatabaseProperties_SampleName `json:"sampleName,omitempty"`

	// SecondaryType: The secondary type of the database if it is a secondary.  Valid values are Geo and Named.
	SecondaryType *DatabaseProperties_SecondaryType `json:"secondaryType,omitempty"`

	// Sku: The database SKU.
	// The list of SKUs may vary by region and support offer. To determine the SKUs (including the SKU name, tier/edition,
	// family, and capacity) that are available to your subscription in an Azure region, use the `Capabilities_ListByLocation`
	// REST API or one of the following commands:
	// ```azurecli
	// az sql db list-editions -l <location> -o table
	// ````
	// ```powershell
	// Get-AzSqlServerServiceObjective -Location <location>
	// ````
	Sku *Sku `json:"sku,omitempty"`

	// SourceDatabaseDeletionDate: Specifies the time that the database was deleted.
	SourceDatabaseDeletionDate *string `json:"sourceDatabaseDeletionDate,omitempty"`

	// SourceDatabaseReference: The resource identifier of the source database associated with create operation of this
	// database.
	SourceDatabaseReference *genruntime.ResourceReference `armReference:"SourceDatabaseId" json:"sourceDatabaseReference,omitempty"`

	// SourceResourceReference: The resource identifier of the source associated with the create operation of this database.
	// This property is only supported for DataWarehouse edition and allows to restore across subscriptions.
	// When sourceResourceId is specified, sourceDatabaseId, recoverableDatabaseId, restorableDroppedDatabaseId and
	// sourceDatabaseDeletionDate must not be specified and CreateMode must be PointInTimeRestore, Restore or Recover.
	// When createMode is PointInTimeRestore, sourceResourceId must be the resource ID of the existing database or existing sql
	// pool, and restorePointInTime must be specified.
	// When createMode is Restore, sourceResourceId must be the resource ID of restorable dropped database or restorable
	// dropped sql pool.
	// When createMode is Recover, sourceResourceId must be the resource ID of recoverable database or recoverable sql pool.
	// When source subscription belongs to a different tenant than target subscription, “x-ms-authorization-auxiliary”
	// header must contain authentication token for the source tenant. For more details about
	// “x-ms-authorization-auxiliary” header see
	// https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/authenticate-multi-tenant
	SourceResourceReference *genruntime.ResourceReference `armReference:"SourceResourceId" json:"sourceResourceReference,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// ZoneRedundant: Whether or not this database is zone redundant, which means the replicas of this database will be spread
	// across multiple availability zones.
	ZoneRedundant *bool `json:"zoneRedundant,omitempty"`
}

var _ genruntime.ARMTransformer = &Servers_Database_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (database *Servers_Database_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if database == nil {
		return nil, nil
	}
	result := &Servers_Database_Spec_ARM{}

	// Set property "Identity":
	if database.Identity != nil {
		identity_ARM, err := (*database.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*DatabaseIdentity_ARM)
		result.Identity = &identity
	}

	// Set property "Location":
	if database.Location != nil {
		location := *database.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if database.AutoPauseDelay != nil ||
		database.CatalogCollation != nil ||
		database.Collation != nil ||
		database.CreateMode != nil ||
		database.ElasticPoolReference != nil ||
		database.FederatedClientId != nil ||
		database.HighAvailabilityReplicaCount != nil ||
		database.IsLedgerOn != nil ||
		database.LicenseType != nil ||
		database.LongTermRetentionBackupResourceReference != nil ||
		database.MaintenanceConfigurationId != nil ||
		database.MaxSizeBytes != nil ||
		database.MinCapacity != nil ||
		database.ReadScale != nil ||
		database.RecoverableDatabaseReference != nil ||
		database.RecoveryServicesRecoveryPointReference != nil ||
		database.RequestedBackupStorageRedundancy != nil ||
		database.RestorableDroppedDatabaseReference != nil ||
		database.RestorePointInTime != nil ||
		database.SampleName != nil ||
		database.SecondaryType != nil ||
		database.SourceDatabaseDeletionDate != nil ||
		database.SourceDatabaseReference != nil ||
		database.SourceResourceReference != nil ||
		database.ZoneRedundant != nil {
		result.Properties = &DatabaseProperties_ARM{}
	}
	if database.AutoPauseDelay != nil {
		autoPauseDelay := *database.AutoPauseDelay
		result.Properties.AutoPauseDelay = &autoPauseDelay
	}
	if database.CatalogCollation != nil {
		catalogCollation := *database.CatalogCollation
		result.Properties.CatalogCollation = &catalogCollation
	}
	if database.Collation != nil {
		collation := *database.Collation
		result.Properties.Collation = &collation
	}
	if database.CreateMode != nil {
		createMode := *database.CreateMode
		result.Properties.CreateMode = &createMode
	}
	if database.ElasticPoolReference != nil {
		elasticPoolIdARMID, err := resolved.ResolvedReferences.Lookup(*database.ElasticPoolReference)
		if err != nil {
			return nil, err
		}
		elasticPoolId := elasticPoolIdARMID
		result.Properties.ElasticPoolId = &elasticPoolId
	}
	if database.FederatedClientId != nil {
		federatedClientId := *database.FederatedClientId
		result.Properties.FederatedClientId = &federatedClientId
	}
	if database.HighAvailabilityReplicaCount != nil {
		highAvailabilityReplicaCount := *database.HighAvailabilityReplicaCount
		result.Properties.HighAvailabilityReplicaCount = &highAvailabilityReplicaCount
	}
	if database.IsLedgerOn != nil {
		isLedgerOn := *database.IsLedgerOn
		result.Properties.IsLedgerOn = &isLedgerOn
	}
	if database.LicenseType != nil {
		licenseType := *database.LicenseType
		result.Properties.LicenseType = &licenseType
	}
	if database.LongTermRetentionBackupResourceReference != nil {
		longTermRetentionBackupResourceIdARMID, err := resolved.ResolvedReferences.Lookup(*database.LongTermRetentionBackupResourceReference)
		if err != nil {
			return nil, err
		}
		longTermRetentionBackupResourceId := longTermRetentionBackupResourceIdARMID
		result.Properties.LongTermRetentionBackupResourceId = &longTermRetentionBackupResourceId
	}
	if database.MaintenanceConfigurationId != nil {
		maintenanceConfigurationId := *database.MaintenanceConfigurationId
		result.Properties.MaintenanceConfigurationId = &maintenanceConfigurationId
	}
	if database.MaxSizeBytes != nil {
		maxSizeBytes := *database.MaxSizeBytes
		result.Properties.MaxSizeBytes = &maxSizeBytes
	}
	if database.MinCapacity != nil {
		minCapacity := *database.MinCapacity
		result.Properties.MinCapacity = &minCapacity
	}
	if database.ReadScale != nil {
		readScale := *database.ReadScale
		result.Properties.ReadScale = &readScale
	}
	if database.RecoverableDatabaseReference != nil {
		recoverableDatabaseIdARMID, err := resolved.ResolvedReferences.Lookup(*database.RecoverableDatabaseReference)
		if err != nil {
			return nil, err
		}
		recoverableDatabaseId := recoverableDatabaseIdARMID
		result.Properties.RecoverableDatabaseId = &recoverableDatabaseId
	}
	if database.RecoveryServicesRecoveryPointReference != nil {
		recoveryServicesRecoveryPointIdARMID, err := resolved.ResolvedReferences.Lookup(*database.RecoveryServicesRecoveryPointReference)
		if err != nil {
			return nil, err
		}
		recoveryServicesRecoveryPointId := recoveryServicesRecoveryPointIdARMID
		result.Properties.RecoveryServicesRecoveryPointId = &recoveryServicesRecoveryPointId
	}
	if database.RequestedBackupStorageRedundancy != nil {
		requestedBackupStorageRedundancy := *database.RequestedBackupStorageRedundancy
		result.Properties.RequestedBackupStorageRedundancy = &requestedBackupStorageRedundancy
	}
	if database.RestorableDroppedDatabaseReference != nil {
		restorableDroppedDatabaseIdARMID, err := resolved.ResolvedReferences.Lookup(*database.RestorableDroppedDatabaseReference)
		if err != nil {
			return nil, err
		}
		restorableDroppedDatabaseId := restorableDroppedDatabaseIdARMID
		result.Properties.RestorableDroppedDatabaseId = &restorableDroppedDatabaseId
	}
	if database.RestorePointInTime != nil {
		restorePointInTime := *database.RestorePointInTime
		result.Properties.RestorePointInTime = &restorePointInTime
	}
	if database.SampleName != nil {
		sampleName := *database.SampleName
		result.Properties.SampleName = &sampleName
	}
	if database.SecondaryType != nil {
		secondaryType := *database.SecondaryType
		result.Properties.SecondaryType = &secondaryType
	}
	if database.SourceDatabaseDeletionDate != nil {
		sourceDatabaseDeletionDate := *database.SourceDatabaseDeletionDate
		result.Properties.SourceDatabaseDeletionDate = &sourceDatabaseDeletionDate
	}
	if database.SourceDatabaseReference != nil {
		sourceDatabaseIdARMID, err := resolved.ResolvedReferences.Lookup(*database.SourceDatabaseReference)
		if err != nil {
			return nil, err
		}
		sourceDatabaseId := sourceDatabaseIdARMID
		result.Properties.SourceDatabaseId = &sourceDatabaseId
	}
	if database.SourceResourceReference != nil {
		sourceResourceIdARMID, err := resolved.ResolvedReferences.Lookup(*database.SourceResourceReference)
		if err != nil {
			return nil, err
		}
		sourceResourceId := sourceResourceIdARMID
		result.Properties.SourceResourceId = &sourceResourceId
	}
	if database.ZoneRedundant != nil {
		zoneRedundant := *database.ZoneRedundant
		result.Properties.ZoneRedundant = &zoneRedundant
	}

	// Set property "Sku":
	if database.Sku != nil {
		sku_ARM, err := (*database.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := *sku_ARM.(*Sku_ARM)
		result.Sku = &sku
	}

	// Set property "Tags":
	if database.Tags != nil {
		result.Tags = make(map[string]string, len(database.Tags))
		for key, value := range database.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (database *Servers_Database_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Servers_Database_Spec_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (database *Servers_Database_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Servers_Database_Spec_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Servers_Database_Spec_ARM, got %T", armInput)
	}

	// Set property "AutoPauseDelay":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutoPauseDelay != nil {
			autoPauseDelay := *typedInput.Properties.AutoPauseDelay
			database.AutoPauseDelay = &autoPauseDelay
		}
	}

	// Set property "AzureName":
	database.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "CatalogCollation":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CatalogCollation != nil {
			catalogCollation := *typedInput.Properties.CatalogCollation
			database.CatalogCollation = &catalogCollation
		}
	}

	// Set property "Collation":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Collation != nil {
			collation := *typedInput.Properties.Collation
			database.Collation = &collation
		}
	}

	// Set property "CreateMode":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CreateMode != nil {
			createMode := *typedInput.Properties.CreateMode
			database.CreateMode = &createMode
		}
	}

	// no assignment for property "ElasticPoolReference"

	// Set property "FederatedClientId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FederatedClientId != nil {
			federatedClientId := *typedInput.Properties.FederatedClientId
			database.FederatedClientId = &federatedClientId
		}
	}

	// Set property "HighAvailabilityReplicaCount":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HighAvailabilityReplicaCount != nil {
			highAvailabilityReplicaCount := *typedInput.Properties.HighAvailabilityReplicaCount
			database.HighAvailabilityReplicaCount = &highAvailabilityReplicaCount
		}
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 DatabaseIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		database.Identity = &identity
	}

	// Set property "IsLedgerOn":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IsLedgerOn != nil {
			isLedgerOn := *typedInput.Properties.IsLedgerOn
			database.IsLedgerOn = &isLedgerOn
		}
	}

	// Set property "LicenseType":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LicenseType != nil {
			licenseType := *typedInput.Properties.LicenseType
			database.LicenseType = &licenseType
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		database.Location = &location
	}

	// no assignment for property "LongTermRetentionBackupResourceReference"

	// Set property "MaintenanceConfigurationId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MaintenanceConfigurationId != nil {
			maintenanceConfigurationId := *typedInput.Properties.MaintenanceConfigurationId
			database.MaintenanceConfigurationId = &maintenanceConfigurationId
		}
	}

	// Set property "MaxSizeBytes":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MaxSizeBytes != nil {
			maxSizeBytes := *typedInput.Properties.MaxSizeBytes
			database.MaxSizeBytes = &maxSizeBytes
		}
	}

	// Set property "MinCapacity":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinCapacity != nil {
			minCapacity := *typedInput.Properties.MinCapacity
			database.MinCapacity = &minCapacity
		}
	}

	// Set property "Owner":
	database.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "ReadScale":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ReadScale != nil {
			readScale := *typedInput.Properties.ReadScale
			database.ReadScale = &readScale
		}
	}

	// no assignment for property "RecoverableDatabaseReference"

	// no assignment for property "RecoveryServicesRecoveryPointReference"

	// Set property "RequestedBackupStorageRedundancy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RequestedBackupStorageRedundancy != nil {
			requestedBackupStorageRedundancy := *typedInput.Properties.RequestedBackupStorageRedundancy
			database.RequestedBackupStorageRedundancy = &requestedBackupStorageRedundancy
		}
	}

	// no assignment for property "RestorableDroppedDatabaseReference"

	// Set property "RestorePointInTime":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RestorePointInTime != nil {
			restorePointInTime := *typedInput.Properties.RestorePointInTime
			database.RestorePointInTime = &restorePointInTime
		}
	}

	// Set property "SampleName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SampleName != nil {
			sampleName := *typedInput.Properties.SampleName
			database.SampleName = &sampleName
		}
	}

	// Set property "SecondaryType":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SecondaryType != nil {
			secondaryType := *typedInput.Properties.SecondaryType
			database.SecondaryType = &secondaryType
		}
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 Sku
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		database.Sku = &sku
	}

	// Set property "SourceDatabaseDeletionDate":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SourceDatabaseDeletionDate != nil {
			sourceDatabaseDeletionDate := *typedInput.Properties.SourceDatabaseDeletionDate
			database.SourceDatabaseDeletionDate = &sourceDatabaseDeletionDate
		}
	}

	// no assignment for property "SourceDatabaseReference"

	// no assignment for property "SourceResourceReference"

	// Set property "Tags":
	if typedInput.Tags != nil {
		database.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			database.Tags[key] = value
		}
	}

	// Set property "ZoneRedundant":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ZoneRedundant != nil {
			zoneRedundant := *typedInput.Properties.ZoneRedundant
			database.ZoneRedundant = &zoneRedundant
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &Servers_Database_Spec{}

// ConvertSpecFrom populates our Servers_Database_Spec from the provided source
func (database *Servers_Database_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v20211101s.Servers_Database_Spec)
	if ok {
		// Populate our instance from source
		return database.AssignProperties_From_Servers_Database_Spec(src)
	}

	// Convert to an intermediate form
	src = &v20211101s.Servers_Database_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = database.AssignProperties_From_Servers_Database_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our Servers_Database_Spec
func (database *Servers_Database_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v20211101s.Servers_Database_Spec)
	if ok {
		// Populate destination from our instance
		return database.AssignProperties_To_Servers_Database_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &v20211101s.Servers_Database_Spec{}
	err := database.AssignProperties_To_Servers_Database_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_Servers_Database_Spec populates our Servers_Database_Spec from the provided source Servers_Database_Spec
func (database *Servers_Database_Spec) AssignProperties_From_Servers_Database_Spec(source *v20211101s.Servers_Database_Spec) error {

	// AutoPauseDelay
	database.AutoPauseDelay = genruntime.ClonePointerToInt(source.AutoPauseDelay)

	// AzureName
	database.AzureName = source.AzureName

	// CatalogCollation
	if source.CatalogCollation != nil {
		catalogCollation := DatabaseProperties_CatalogCollation(*source.CatalogCollation)
		database.CatalogCollation = &catalogCollation
	} else {
		database.CatalogCollation = nil
	}

	// Collation
	database.Collation = genruntime.ClonePointerToString(source.Collation)

	// CreateMode
	if source.CreateMode != nil {
		createMode := DatabaseProperties_CreateMode(*source.CreateMode)
		database.CreateMode = &createMode
	} else {
		database.CreateMode = nil
	}

	// ElasticPoolReference
	if source.ElasticPoolReference != nil {
		elasticPoolReference := source.ElasticPoolReference.Copy()
		database.ElasticPoolReference = &elasticPoolReference
	} else {
		database.ElasticPoolReference = nil
	}

	// FederatedClientId
	if source.FederatedClientId != nil {
		federatedClientId := *source.FederatedClientId
		database.FederatedClientId = &federatedClientId
	} else {
		database.FederatedClientId = nil
	}

	// HighAvailabilityReplicaCount
	database.HighAvailabilityReplicaCount = genruntime.ClonePointerToInt(source.HighAvailabilityReplicaCount)

	// Identity
	if source.Identity != nil {
		var identity DatabaseIdentity
		err := identity.AssignProperties_From_DatabaseIdentity(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DatabaseIdentity() to populate field Identity")
		}
		database.Identity = &identity
	} else {
		database.Identity = nil
	}

	// IsLedgerOn
	if source.IsLedgerOn != nil {
		isLedgerOn := *source.IsLedgerOn
		database.IsLedgerOn = &isLedgerOn
	} else {
		database.IsLedgerOn = nil
	}

	// LicenseType
	if source.LicenseType != nil {
		licenseType := DatabaseProperties_LicenseType(*source.LicenseType)
		database.LicenseType = &licenseType
	} else {
		database.LicenseType = nil
	}

	// Location
	database.Location = genruntime.ClonePointerToString(source.Location)

	// LongTermRetentionBackupResourceReference
	if source.LongTermRetentionBackupResourceReference != nil {
		longTermRetentionBackupResourceReference := source.LongTermRetentionBackupResourceReference.Copy()
		database.LongTermRetentionBackupResourceReference = &longTermRetentionBackupResourceReference
	} else {
		database.LongTermRetentionBackupResourceReference = nil
	}

	// MaintenanceConfigurationId
	database.MaintenanceConfigurationId = genruntime.ClonePointerToString(source.MaintenanceConfigurationId)

	// MaxSizeBytes
	database.MaxSizeBytes = genruntime.ClonePointerToInt(source.MaxSizeBytes)

	// MinCapacity
	if source.MinCapacity != nil {
		minCapacity := *source.MinCapacity
		database.MinCapacity = &minCapacity
	} else {
		database.MinCapacity = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		database.Owner = &owner
	} else {
		database.Owner = nil
	}

	// ReadScale
	if source.ReadScale != nil {
		readScale := DatabaseProperties_ReadScale(*source.ReadScale)
		database.ReadScale = &readScale
	} else {
		database.ReadScale = nil
	}

	// RecoverableDatabaseReference
	if source.RecoverableDatabaseReference != nil {
		recoverableDatabaseReference := source.RecoverableDatabaseReference.Copy()
		database.RecoverableDatabaseReference = &recoverableDatabaseReference
	} else {
		database.RecoverableDatabaseReference = nil
	}

	// RecoveryServicesRecoveryPointReference
	if source.RecoveryServicesRecoveryPointReference != nil {
		recoveryServicesRecoveryPointReference := source.RecoveryServicesRecoveryPointReference.Copy()
		database.RecoveryServicesRecoveryPointReference = &recoveryServicesRecoveryPointReference
	} else {
		database.RecoveryServicesRecoveryPointReference = nil
	}

	// RequestedBackupStorageRedundancy
	if source.RequestedBackupStorageRedundancy != nil {
		requestedBackupStorageRedundancy := DatabaseProperties_RequestedBackupStorageRedundancy(*source.RequestedBackupStorageRedundancy)
		database.RequestedBackupStorageRedundancy = &requestedBackupStorageRedundancy
	} else {
		database.RequestedBackupStorageRedundancy = nil
	}

	// RestorableDroppedDatabaseReference
	if source.RestorableDroppedDatabaseReference != nil {
		restorableDroppedDatabaseReference := source.RestorableDroppedDatabaseReference.Copy()
		database.RestorableDroppedDatabaseReference = &restorableDroppedDatabaseReference
	} else {
		database.RestorableDroppedDatabaseReference = nil
	}

	// RestorePointInTime
	database.RestorePointInTime = genruntime.ClonePointerToString(source.RestorePointInTime)

	// SampleName
	if source.SampleName != nil {
		sampleName := DatabaseProperties_SampleName(*source.SampleName)
		database.SampleName = &sampleName
	} else {
		database.SampleName = nil
	}

	// SecondaryType
	if source.SecondaryType != nil {
		secondaryType := DatabaseProperties_SecondaryType(*source.SecondaryType)
		database.SecondaryType = &secondaryType
	} else {
		database.SecondaryType = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.AssignProperties_From_Sku(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Sku() to populate field Sku")
		}
		database.Sku = &sku
	} else {
		database.Sku = nil
	}

	// SourceDatabaseDeletionDate
	database.SourceDatabaseDeletionDate = genruntime.ClonePointerToString(source.SourceDatabaseDeletionDate)

	// SourceDatabaseReference
	if source.SourceDatabaseReference != nil {
		sourceDatabaseReference := source.SourceDatabaseReference.Copy()
		database.SourceDatabaseReference = &sourceDatabaseReference
	} else {
		database.SourceDatabaseReference = nil
	}

	// SourceResourceReference
	if source.SourceResourceReference != nil {
		sourceResourceReference := source.SourceResourceReference.Copy()
		database.SourceResourceReference = &sourceResourceReference
	} else {
		database.SourceResourceReference = nil
	}

	// Tags
	database.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// ZoneRedundant
	if source.ZoneRedundant != nil {
		zoneRedundant := *source.ZoneRedundant
		database.ZoneRedundant = &zoneRedundant
	} else {
		database.ZoneRedundant = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Servers_Database_Spec populates the provided destination Servers_Database_Spec from our Servers_Database_Spec
func (database *Servers_Database_Spec) AssignProperties_To_Servers_Database_Spec(destination *v20211101s.Servers_Database_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AutoPauseDelay
	destination.AutoPauseDelay = genruntime.ClonePointerToInt(database.AutoPauseDelay)

	// AzureName
	destination.AzureName = database.AzureName

	// CatalogCollation
	if database.CatalogCollation != nil {
		catalogCollation := string(*database.CatalogCollation)
		destination.CatalogCollation = &catalogCollation
	} else {
		destination.CatalogCollation = nil
	}

	// Collation
	destination.Collation = genruntime.ClonePointerToString(database.Collation)

	// CreateMode
	if database.CreateMode != nil {
		createMode := string(*database.CreateMode)
		destination.CreateMode = &createMode
	} else {
		destination.CreateMode = nil
	}

	// ElasticPoolReference
	if database.ElasticPoolReference != nil {
		elasticPoolReference := database.ElasticPoolReference.Copy()
		destination.ElasticPoolReference = &elasticPoolReference
	} else {
		destination.ElasticPoolReference = nil
	}

	// FederatedClientId
	if database.FederatedClientId != nil {
		federatedClientId := *database.FederatedClientId
		destination.FederatedClientId = &federatedClientId
	} else {
		destination.FederatedClientId = nil
	}

	// HighAvailabilityReplicaCount
	destination.HighAvailabilityReplicaCount = genruntime.ClonePointerToInt(database.HighAvailabilityReplicaCount)

	// Identity
	if database.Identity != nil {
		var identity v20211101s.DatabaseIdentity
		err := database.Identity.AssignProperties_To_DatabaseIdentity(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DatabaseIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// IsLedgerOn
	if database.IsLedgerOn != nil {
		isLedgerOn := *database.IsLedgerOn
		destination.IsLedgerOn = &isLedgerOn
	} else {
		destination.IsLedgerOn = nil
	}

	// LicenseType
	if database.LicenseType != nil {
		licenseType := string(*database.LicenseType)
		destination.LicenseType = &licenseType
	} else {
		destination.LicenseType = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(database.Location)

	// LongTermRetentionBackupResourceReference
	if database.LongTermRetentionBackupResourceReference != nil {
		longTermRetentionBackupResourceReference := database.LongTermRetentionBackupResourceReference.Copy()
		destination.LongTermRetentionBackupResourceReference = &longTermRetentionBackupResourceReference
	} else {
		destination.LongTermRetentionBackupResourceReference = nil
	}

	// MaintenanceConfigurationId
	destination.MaintenanceConfigurationId = genruntime.ClonePointerToString(database.MaintenanceConfigurationId)

	// MaxSizeBytes
	destination.MaxSizeBytes = genruntime.ClonePointerToInt(database.MaxSizeBytes)

	// MinCapacity
	if database.MinCapacity != nil {
		minCapacity := *database.MinCapacity
		destination.MinCapacity = &minCapacity
	} else {
		destination.MinCapacity = nil
	}

	// OriginalVersion
	destination.OriginalVersion = database.OriginalVersion()

	// Owner
	if database.Owner != nil {
		owner := database.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// ReadScale
	if database.ReadScale != nil {
		readScale := string(*database.ReadScale)
		destination.ReadScale = &readScale
	} else {
		destination.ReadScale = nil
	}

	// RecoverableDatabaseReference
	if database.RecoverableDatabaseReference != nil {
		recoverableDatabaseReference := database.RecoverableDatabaseReference.Copy()
		destination.RecoverableDatabaseReference = &recoverableDatabaseReference
	} else {
		destination.RecoverableDatabaseReference = nil
	}

	// RecoveryServicesRecoveryPointReference
	if database.RecoveryServicesRecoveryPointReference != nil {
		recoveryServicesRecoveryPointReference := database.RecoveryServicesRecoveryPointReference.Copy()
		destination.RecoveryServicesRecoveryPointReference = &recoveryServicesRecoveryPointReference
	} else {
		destination.RecoveryServicesRecoveryPointReference = nil
	}

	// RequestedBackupStorageRedundancy
	if database.RequestedBackupStorageRedundancy != nil {
		requestedBackupStorageRedundancy := string(*database.RequestedBackupStorageRedundancy)
		destination.RequestedBackupStorageRedundancy = &requestedBackupStorageRedundancy
	} else {
		destination.RequestedBackupStorageRedundancy = nil
	}

	// RestorableDroppedDatabaseReference
	if database.RestorableDroppedDatabaseReference != nil {
		restorableDroppedDatabaseReference := database.RestorableDroppedDatabaseReference.Copy()
		destination.RestorableDroppedDatabaseReference = &restorableDroppedDatabaseReference
	} else {
		destination.RestorableDroppedDatabaseReference = nil
	}

	// RestorePointInTime
	destination.RestorePointInTime = genruntime.ClonePointerToString(database.RestorePointInTime)

	// SampleName
	if database.SampleName != nil {
		sampleName := string(*database.SampleName)
		destination.SampleName = &sampleName
	} else {
		destination.SampleName = nil
	}

	// SecondaryType
	if database.SecondaryType != nil {
		secondaryType := string(*database.SecondaryType)
		destination.SecondaryType = &secondaryType
	} else {
		destination.SecondaryType = nil
	}

	// Sku
	if database.Sku != nil {
		var sku v20211101s.Sku
		err := database.Sku.AssignProperties_To_Sku(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Sku() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// SourceDatabaseDeletionDate
	destination.SourceDatabaseDeletionDate = genruntime.ClonePointerToString(database.SourceDatabaseDeletionDate)

	// SourceDatabaseReference
	if database.SourceDatabaseReference != nil {
		sourceDatabaseReference := database.SourceDatabaseReference.Copy()
		destination.SourceDatabaseReference = &sourceDatabaseReference
	} else {
		destination.SourceDatabaseReference = nil
	}

	// SourceResourceReference
	if database.SourceResourceReference != nil {
		sourceResourceReference := database.SourceResourceReference.Copy()
		destination.SourceResourceReference = &sourceResourceReference
	} else {
		destination.SourceResourceReference = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(database.Tags)

	// ZoneRedundant
	if database.ZoneRedundant != nil {
		zoneRedundant := *database.ZoneRedundant
		destination.ZoneRedundant = &zoneRedundant
	} else {
		destination.ZoneRedundant = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Servers_Database_STATUS populates our Servers_Database_Spec from the provided source Servers_Database_STATUS
func (database *Servers_Database_Spec) Initialize_From_Servers_Database_STATUS(source *Servers_Database_STATUS) error {

	// AutoPauseDelay
	database.AutoPauseDelay = genruntime.ClonePointerToInt(source.AutoPauseDelay)

	// CatalogCollation
	if source.CatalogCollation != nil {
		catalogCollation := DatabaseProperties_CatalogCollation(*source.CatalogCollation)
		database.CatalogCollation = &catalogCollation
	} else {
		database.CatalogCollation = nil
	}

	// Collation
	database.Collation = genruntime.ClonePointerToString(source.Collation)

	// CreateMode
	if source.CreateMode != nil {
		createMode := DatabaseProperties_CreateMode(*source.CreateMode)
		database.CreateMode = &createMode
	} else {
		database.CreateMode = nil
	}

	// ElasticPoolReference
	if source.ElasticPoolId != nil {
		elasticPoolReference := genruntime.CreateResourceReferenceFromARMID(*source.ElasticPoolId)
		database.ElasticPoolReference = &elasticPoolReference
	} else {
		database.ElasticPoolReference = nil
	}

	// FederatedClientId
	if source.FederatedClientId != nil {
		federatedClientId := *source.FederatedClientId
		database.FederatedClientId = &federatedClientId
	} else {
		database.FederatedClientId = nil
	}

	// HighAvailabilityReplicaCount
	database.HighAvailabilityReplicaCount = genruntime.ClonePointerToInt(source.HighAvailabilityReplicaCount)

	// Identity
	if source.Identity != nil {
		var identity DatabaseIdentity
		err := identity.Initialize_From_DatabaseIdentity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DatabaseIdentity_STATUS() to populate field Identity")
		}
		database.Identity = &identity
	} else {
		database.Identity = nil
	}

	// IsLedgerOn
	if source.IsLedgerOn != nil {
		isLedgerOn := *source.IsLedgerOn
		database.IsLedgerOn = &isLedgerOn
	} else {
		database.IsLedgerOn = nil
	}

	// LicenseType
	if source.LicenseType != nil {
		licenseType := DatabaseProperties_LicenseType(*source.LicenseType)
		database.LicenseType = &licenseType
	} else {
		database.LicenseType = nil
	}

	// Location
	database.Location = genruntime.ClonePointerToString(source.Location)

	// LongTermRetentionBackupResourceReference
	if source.LongTermRetentionBackupResourceId != nil {
		longTermRetentionBackupResourceReference := genruntime.CreateResourceReferenceFromARMID(*source.LongTermRetentionBackupResourceId)
		database.LongTermRetentionBackupResourceReference = &longTermRetentionBackupResourceReference
	} else {
		database.LongTermRetentionBackupResourceReference = nil
	}

	// MaintenanceConfigurationId
	database.MaintenanceConfigurationId = genruntime.ClonePointerToString(source.MaintenanceConfigurationId)

	// MaxSizeBytes
	database.MaxSizeBytes = genruntime.ClonePointerToInt(source.MaxSizeBytes)

	// MinCapacity
	if source.MinCapacity != nil {
		minCapacity := *source.MinCapacity
		database.MinCapacity = &minCapacity
	} else {
		database.MinCapacity = nil
	}

	// ReadScale
	if source.ReadScale != nil {
		readScale := DatabaseProperties_ReadScale(*source.ReadScale)
		database.ReadScale = &readScale
	} else {
		database.ReadScale = nil
	}

	// RecoverableDatabaseReference
	if source.RecoverableDatabaseId != nil {
		recoverableDatabaseReference := genruntime.CreateResourceReferenceFromARMID(*source.RecoverableDatabaseId)
		database.RecoverableDatabaseReference = &recoverableDatabaseReference
	} else {
		database.RecoverableDatabaseReference = nil
	}

	// RecoveryServicesRecoveryPointReference
	if source.RecoveryServicesRecoveryPointId != nil {
		recoveryServicesRecoveryPointReference := genruntime.CreateResourceReferenceFromARMID(*source.RecoveryServicesRecoveryPointId)
		database.RecoveryServicesRecoveryPointReference = &recoveryServicesRecoveryPointReference
	} else {
		database.RecoveryServicesRecoveryPointReference = nil
	}

	// RequestedBackupStorageRedundancy
	if source.RequestedBackupStorageRedundancy != nil {
		requestedBackupStorageRedundancy := DatabaseProperties_RequestedBackupStorageRedundancy(*source.RequestedBackupStorageRedundancy)
		database.RequestedBackupStorageRedundancy = &requestedBackupStorageRedundancy
	} else {
		database.RequestedBackupStorageRedundancy = nil
	}

	// RestorableDroppedDatabaseReference
	if source.RestorableDroppedDatabaseId != nil {
		restorableDroppedDatabaseReference := genruntime.CreateResourceReferenceFromARMID(*source.RestorableDroppedDatabaseId)
		database.RestorableDroppedDatabaseReference = &restorableDroppedDatabaseReference
	} else {
		database.RestorableDroppedDatabaseReference = nil
	}

	// RestorePointInTime
	database.RestorePointInTime = genruntime.ClonePointerToString(source.RestorePointInTime)

	// SampleName
	if source.SampleName != nil {
		sampleName := DatabaseProperties_SampleName(*source.SampleName)
		database.SampleName = &sampleName
	} else {
		database.SampleName = nil
	}

	// SecondaryType
	if source.SecondaryType != nil {
		secondaryType := DatabaseProperties_SecondaryType(*source.SecondaryType)
		database.SecondaryType = &secondaryType
	} else {
		database.SecondaryType = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.Initialize_From_Sku_STATUS(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_Sku_STATUS() to populate field Sku")
		}
		database.Sku = &sku
	} else {
		database.Sku = nil
	}

	// SourceDatabaseDeletionDate
	database.SourceDatabaseDeletionDate = genruntime.ClonePointerToString(source.SourceDatabaseDeletionDate)

	// SourceDatabaseReference
	if source.SourceDatabaseId != nil {
		sourceDatabaseReference := genruntime.CreateResourceReferenceFromARMID(*source.SourceDatabaseId)
		database.SourceDatabaseReference = &sourceDatabaseReference
	} else {
		database.SourceDatabaseReference = nil
	}

	// SourceResourceReference
	if source.SourceResourceId != nil {
		sourceResourceReference := genruntime.CreateResourceReferenceFromARMID(*source.SourceResourceId)
		database.SourceResourceReference = &sourceResourceReference
	} else {
		database.SourceResourceReference = nil
	}

	// Tags
	database.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// ZoneRedundant
	if source.ZoneRedundant != nil {
		zoneRedundant := *source.ZoneRedundant
		database.ZoneRedundant = &zoneRedundant
	} else {
		database.ZoneRedundant = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (database *Servers_Database_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (database *Servers_Database_Spec) SetAzureName(azureName string) { database.AzureName = azureName }

type Servers_Database_STATUS struct {
	// AutoPauseDelay: Time in minutes after which database is automatically paused. A value of -1 means that automatic pause
	// is disabled
	AutoPauseDelay *int `json:"autoPauseDelay,omitempty"`

	// CatalogCollation: Collation of the metadata catalog.
	CatalogCollation *DatabaseProperties_CatalogCollation_STATUS `json:"catalogCollation,omitempty"`

	// Collation: The collation of the database.
	Collation *string `json:"collation,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// CreateMode: Specifies the mode of database creation.
	// Default: regular database creation.
	// Copy: creates a database as a copy of an existing database. sourceDatabaseId must be specified as the resource ID of the
	// source database.
	// Secondary: creates a database as a secondary replica of an existing database. sourceDatabaseId must be specified as the
	// resource ID of the existing primary database.
	// PointInTimeRestore: Creates a database by restoring a point in time backup of an existing database. sourceDatabaseId
	// must be specified as the resource ID of the existing database, and restorePointInTime must be specified.
	// Recovery: Creates a database by restoring a geo-replicated backup. sourceDatabaseId must be specified as the recoverable
	// database resource ID to restore.
	// Restore: Creates a database by restoring a backup of a deleted database. sourceDatabaseId must be specified. If
	// sourceDatabaseId is the database's original resource ID, then sourceDatabaseDeletionDate must be specified. Otherwise
	// sourceDatabaseId must be the restorable dropped database resource ID and sourceDatabaseDeletionDate is ignored.
	// restorePointInTime may also be specified to restore from an earlier point in time.
	// RestoreLongTermRetentionBackup: Creates a database by restoring from a long term retention vault.
	// recoveryServicesRecoveryPointResourceId must be specified as the recovery point resource ID.
	// Copy, Secondary, and RestoreLongTermRetentionBackup are not supported for DataWarehouse edition.
	CreateMode *DatabaseProperties_CreateMode_STATUS `json:"createMode,omitempty"`

	// CreationDate: The creation date of the database (ISO8601 format).
	CreationDate *string `json:"creationDate,omitempty"`

	// CurrentBackupStorageRedundancy: The storage account type used to store backups for this database.
	CurrentBackupStorageRedundancy *DatabaseProperties_CurrentBackupStorageRedundancy_STATUS `json:"currentBackupStorageRedundancy,omitempty"`

	// CurrentServiceObjectiveName: The current service level objective name of the database.
	CurrentServiceObjectiveName *string `json:"currentServiceObjectiveName,omitempty"`

	// CurrentSku: The name and tier of the SKU.
	CurrentSku *Sku_STATUS `json:"currentSku,omitempty"`

	// DatabaseId: The ID of the database.
	DatabaseId *string `json:"databaseId,omitempty"`

	// DefaultSecondaryLocation: The default secondary region for this database.
	DefaultSecondaryLocation *string `json:"defaultSecondaryLocation,omitempty"`

	// EarliestRestoreDate: This records the earliest start date and time that restore is available for this database (ISO8601
	// format).
	EarliestRestoreDate *string `json:"earliestRestoreDate,omitempty"`

	// ElasticPoolId: The resource identifier of the elastic pool containing this database.
	ElasticPoolId *string `json:"elasticPoolId,omitempty"`

	// FailoverGroupId: Failover Group resource identifier that this database belongs to.
	FailoverGroupId *string `json:"failoverGroupId,omitempty"`

	// FederatedClientId: The Client id used for cross tenant per database CMK scenario
	FederatedClientId *string `json:"federatedClientId,omitempty"`

	// HighAvailabilityReplicaCount: The number of secondary replicas associated with the database that are used to provide
	// high availability. Not applicable to a Hyperscale database within an elastic pool.
	HighAvailabilityReplicaCount *int `json:"highAvailabilityReplicaCount,omitempty"`

	// Id: Resource ID.
	Id *string `json:"id,omitempty"`

	// Identity: The Azure Active Directory identity of the database.
	Identity *DatabaseIdentity_STATUS `json:"identity,omitempty"`

	// IsInfraEncryptionEnabled: Infra encryption is enabled for this database.
	IsInfraEncryptionEnabled *bool `json:"isInfraEncryptionEnabled,omitempty"`

	// IsLedgerOn: Whether or not this database is a ledger database, which means all tables in the database are ledger tables.
	// Note: the value of this property cannot be changed after the database has been created.
	IsLedgerOn *bool `json:"isLedgerOn,omitempty"`

	// Kind: Kind of database. This is metadata used for the Azure portal experience.
	Kind *string `json:"kind,omitempty"`

	// LicenseType: The license type to apply for this database. `LicenseIncluded` if you need a license, or `BasePrice` if you
	// have a license and are eligible for the Azure Hybrid Benefit.
	LicenseType *DatabaseProperties_LicenseType_STATUS `json:"licenseType,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// LongTermRetentionBackupResourceId: The resource identifier of the long term retention backup associated with create
	// operation of this database.
	LongTermRetentionBackupResourceId *string `json:"longTermRetentionBackupResourceId,omitempty"`

	// MaintenanceConfigurationId: Maintenance configuration id assigned to the database. This configuration defines the period
	// when the maintenance updates will occur.
	MaintenanceConfigurationId *string `json:"maintenanceConfigurationId,omitempty"`

	// ManagedBy: Resource that manages the database.
	ManagedBy *string `json:"managedBy,omitempty"`

	// MaxLogSizeBytes: The max log size for this database.
	MaxLogSizeBytes *int `json:"maxLogSizeBytes,omitempty"`

	// MaxSizeBytes: The max size of the database expressed in bytes.
	MaxSizeBytes *int `json:"maxSizeBytes,omitempty"`

	// MinCapacity: Minimal capacity that database will always have allocated, if not paused
	MinCapacity *float64 `json:"minCapacity,omitempty"`

	// Name: Resource name.
	Name *string `json:"name,omitempty"`

	// PausedDate: The date when database was paused by user configuration or action(ISO8601 format). Null if the database is
	// ready.
	PausedDate *string `json:"pausedDate,omitempty"`

	// ReadScale: The state of read-only routing. If enabled, connections that have application intent set to readonly in their
	// connection string may be routed to a readonly secondary replica in the same region. Not applicable to a Hyperscale
	// database within an elastic pool.
	ReadScale *DatabaseProperties_ReadScale_STATUS `json:"readScale,omitempty"`

	// RecoverableDatabaseId: The resource identifier of the recoverable database associated with create operation of this
	// database.
	RecoverableDatabaseId *string `json:"recoverableDatabaseId,omitempty"`

	// RecoveryServicesRecoveryPointId: The resource identifier of the recovery point associated with create operation of this
	// database.
	RecoveryServicesRecoveryPointId *string `json:"recoveryServicesRecoveryPointId,omitempty"`

	// RequestedBackupStorageRedundancy: The storage account type to be used to store backups for this database.
	RequestedBackupStorageRedundancy *DatabaseProperties_RequestedBackupStorageRedundancy_STATUS `json:"requestedBackupStorageRedundancy,omitempty"`

	// RequestedServiceObjectiveName: The requested service level objective name of the database.
	RequestedServiceObjectiveName *string `json:"requestedServiceObjectiveName,omitempty"`

	// RestorableDroppedDatabaseId: The resource identifier of the restorable dropped database associated with create operation
	// of this database.
	RestorableDroppedDatabaseId *string `json:"restorableDroppedDatabaseId,omitempty"`

	// RestorePointInTime: Specifies the point in time (ISO8601 format) of the source database that will be restored to create
	// the new database.
	RestorePointInTime *string `json:"restorePointInTime,omitempty"`

	// ResumedDate: The date when database was resumed by user action or database login (ISO8601 format). Null if the database
	// is paused.
	ResumedDate *string `json:"resumedDate,omitempty"`

	// SampleName: The name of the sample schema to apply when creating this database.
	SampleName *DatabaseProperties_SampleName_STATUS `json:"sampleName,omitempty"`

	// SecondaryType: The secondary type of the database if it is a secondary.  Valid values are Geo and Named.
	SecondaryType *DatabaseProperties_SecondaryType_STATUS `json:"secondaryType,omitempty"`

	// Sku: The database SKU.
	// The list of SKUs may vary by region and support offer. To determine the SKUs (including the SKU name, tier/edition,
	// family, and capacity) that are available to your subscription in an Azure region, use the `Capabilities_ListByLocation`
	// REST API or one of the following commands:
	// ```azurecli
	// az sql db list-editions -l <location> -o table
	// ````
	// ```powershell
	// Get-AzSqlServerServiceObjective -Location <location>
	// ````
	Sku *Sku_STATUS `json:"sku,omitempty"`

	// SourceDatabaseDeletionDate: Specifies the time that the database was deleted.
	SourceDatabaseDeletionDate *string `json:"sourceDatabaseDeletionDate,omitempty"`

	// SourceDatabaseId: The resource identifier of the source database associated with create operation of this database.
	SourceDatabaseId *string `json:"sourceDatabaseId,omitempty"`

	// SourceResourceId: The resource identifier of the source associated with the create operation of this database.
	// This property is only supported for DataWarehouse edition and allows to restore across subscriptions.
	// When sourceResourceId is specified, sourceDatabaseId, recoverableDatabaseId, restorableDroppedDatabaseId and
	// sourceDatabaseDeletionDate must not be specified and CreateMode must be PointInTimeRestore, Restore or Recover.
	// When createMode is PointInTimeRestore, sourceResourceId must be the resource ID of the existing database or existing sql
	// pool, and restorePointInTime must be specified.
	// When createMode is Restore, sourceResourceId must be the resource ID of restorable dropped database or restorable
	// dropped sql pool.
	// When createMode is Recover, sourceResourceId must be the resource ID of recoverable database or recoverable sql pool.
	// When source subscription belongs to a different tenant than target subscription, “x-ms-authorization-auxiliary”
	// header must contain authentication token for the source tenant. For more details about
	// “x-ms-authorization-auxiliary” header see
	// https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/authenticate-multi-tenant
	SourceResourceId *string `json:"sourceResourceId,omitempty"`

	// Status: The status of the database.
	Status *DatabaseProperties_Status_STATUS `json:"status,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: Resource type.
	Type *string `json:"type,omitempty"`

	// ZoneRedundant: Whether or not this database is zone redundant, which means the replicas of this database will be spread
	// across multiple availability zones.
	ZoneRedundant *bool `json:"zoneRedundant,omitempty"`
}

var _ genruntime.ConvertibleStatus = &Servers_Database_STATUS{}

// ConvertStatusFrom populates our Servers_Database_STATUS from the provided source
func (database *Servers_Database_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v20211101s.Servers_Database_STATUS)
	if ok {
		// Populate our instance from source
		return database.AssignProperties_From_Servers_Database_STATUS(src)
	}

	// Convert to an intermediate form
	src = &v20211101s.Servers_Database_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = database.AssignProperties_From_Servers_Database_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our Servers_Database_STATUS
func (database *Servers_Database_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v20211101s.Servers_Database_STATUS)
	if ok {
		// Populate destination from our instance
		return database.AssignProperties_To_Servers_Database_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &v20211101s.Servers_Database_STATUS{}
	err := database.AssignProperties_To_Servers_Database_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &Servers_Database_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (database *Servers_Database_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Servers_Database_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (database *Servers_Database_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Servers_Database_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Servers_Database_STATUS_ARM, got %T", armInput)
	}

	// Set property "AutoPauseDelay":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutoPauseDelay != nil {
			autoPauseDelay := *typedInput.Properties.AutoPauseDelay
			database.AutoPauseDelay = &autoPauseDelay
		}
	}

	// Set property "CatalogCollation":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CatalogCollation != nil {
			catalogCollation := *typedInput.Properties.CatalogCollation
			database.CatalogCollation = &catalogCollation
		}
	}

	// Set property "Collation":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Collation != nil {
			collation := *typedInput.Properties.Collation
			database.Collation = &collation
		}
	}

	// no assignment for property "Conditions"

	// Set property "CreateMode":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CreateMode != nil {
			createMode := *typedInput.Properties.CreateMode
			database.CreateMode = &createMode
		}
	}

	// Set property "CreationDate":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CreationDate != nil {
			creationDate := *typedInput.Properties.CreationDate
			database.CreationDate = &creationDate
		}
	}

	// Set property "CurrentBackupStorageRedundancy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CurrentBackupStorageRedundancy != nil {
			currentBackupStorageRedundancy := *typedInput.Properties.CurrentBackupStorageRedundancy
			database.CurrentBackupStorageRedundancy = &currentBackupStorageRedundancy
		}
	}

	// Set property "CurrentServiceObjectiveName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CurrentServiceObjectiveName != nil {
			currentServiceObjectiveName := *typedInput.Properties.CurrentServiceObjectiveName
			database.CurrentServiceObjectiveName = &currentServiceObjectiveName
		}
	}

	// Set property "CurrentSku":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CurrentSku != nil {
			var currentSku1 Sku_STATUS
			err := currentSku1.PopulateFromARM(owner, *typedInput.Properties.CurrentSku)
			if err != nil {
				return err
			}
			currentSku := currentSku1
			database.CurrentSku = &currentSku
		}
	}

	// Set property "DatabaseId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DatabaseId != nil {
			databaseId := *typedInput.Properties.DatabaseId
			database.DatabaseId = &databaseId
		}
	}

	// Set property "DefaultSecondaryLocation":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DefaultSecondaryLocation != nil {
			defaultSecondaryLocation := *typedInput.Properties.DefaultSecondaryLocation
			database.DefaultSecondaryLocation = &defaultSecondaryLocation
		}
	}

	// Set property "EarliestRestoreDate":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EarliestRestoreDate != nil {
			earliestRestoreDate := *typedInput.Properties.EarliestRestoreDate
			database.EarliestRestoreDate = &earliestRestoreDate
		}
	}

	// Set property "ElasticPoolId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ElasticPoolId != nil {
			elasticPoolId := *typedInput.Properties.ElasticPoolId
			database.ElasticPoolId = &elasticPoolId
		}
	}

	// Set property "FailoverGroupId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FailoverGroupId != nil {
			failoverGroupId := *typedInput.Properties.FailoverGroupId
			database.FailoverGroupId = &failoverGroupId
		}
	}

	// Set property "FederatedClientId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FederatedClientId != nil {
			federatedClientId := *typedInput.Properties.FederatedClientId
			database.FederatedClientId = &federatedClientId
		}
	}

	// Set property "HighAvailabilityReplicaCount":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HighAvailabilityReplicaCount != nil {
			highAvailabilityReplicaCount := *typedInput.Properties.HighAvailabilityReplicaCount
			database.HighAvailabilityReplicaCount = &highAvailabilityReplicaCount
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		database.Id = &id
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 DatabaseIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		database.Identity = &identity
	}

	// Set property "IsInfraEncryptionEnabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IsInfraEncryptionEnabled != nil {
			isInfraEncryptionEnabled := *typedInput.Properties.IsInfraEncryptionEnabled
			database.IsInfraEncryptionEnabled = &isInfraEncryptionEnabled
		}
	}

	// Set property "IsLedgerOn":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IsLedgerOn != nil {
			isLedgerOn := *typedInput.Properties.IsLedgerOn
			database.IsLedgerOn = &isLedgerOn
		}
	}

	// Set property "Kind":
	if typedInput.Kind != nil {
		kind := *typedInput.Kind
		database.Kind = &kind
	}

	// Set property "LicenseType":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LicenseType != nil {
			licenseType := *typedInput.Properties.LicenseType
			database.LicenseType = &licenseType
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		database.Location = &location
	}

	// Set property "LongTermRetentionBackupResourceId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LongTermRetentionBackupResourceId != nil {
			longTermRetentionBackupResourceId := *typedInput.Properties.LongTermRetentionBackupResourceId
			database.LongTermRetentionBackupResourceId = &longTermRetentionBackupResourceId
		}
	}

	// Set property "MaintenanceConfigurationId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MaintenanceConfigurationId != nil {
			maintenanceConfigurationId := *typedInput.Properties.MaintenanceConfigurationId
			database.MaintenanceConfigurationId = &maintenanceConfigurationId
		}
	}

	// Set property "ManagedBy":
	if typedInput.ManagedBy != nil {
		managedBy := *typedInput.ManagedBy
		database.ManagedBy = &managedBy
	}

	// Set property "MaxLogSizeBytes":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MaxLogSizeBytes != nil {
			maxLogSizeBytes := *typedInput.Properties.MaxLogSizeBytes
			database.MaxLogSizeBytes = &maxLogSizeBytes
		}
	}

	// Set property "MaxSizeBytes":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MaxSizeBytes != nil {
			maxSizeBytes := *typedInput.Properties.MaxSizeBytes
			database.MaxSizeBytes = &maxSizeBytes
		}
	}

	// Set property "MinCapacity":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinCapacity != nil {
			minCapacity := *typedInput.Properties.MinCapacity
			database.MinCapacity = &minCapacity
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		database.Name = &name
	}

	// Set property "PausedDate":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PausedDate != nil {
			pausedDate := *typedInput.Properties.PausedDate
			database.PausedDate = &pausedDate
		}
	}

	// Set property "ReadScale":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ReadScale != nil {
			readScale := *typedInput.Properties.ReadScale
			database.ReadScale = &readScale
		}
	}

	// Set property "RecoverableDatabaseId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RecoverableDatabaseId != nil {
			recoverableDatabaseId := *typedInput.Properties.RecoverableDatabaseId
			database.RecoverableDatabaseId = &recoverableDatabaseId
		}
	}

	// Set property "RecoveryServicesRecoveryPointId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RecoveryServicesRecoveryPointId != nil {
			recoveryServicesRecoveryPointId := *typedInput.Properties.RecoveryServicesRecoveryPointId
			database.RecoveryServicesRecoveryPointId = &recoveryServicesRecoveryPointId
		}
	}

	// Set property "RequestedBackupStorageRedundancy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RequestedBackupStorageRedundancy != nil {
			requestedBackupStorageRedundancy := *typedInput.Properties.RequestedBackupStorageRedundancy
			database.RequestedBackupStorageRedundancy = &requestedBackupStorageRedundancy
		}
	}

	// Set property "RequestedServiceObjectiveName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RequestedServiceObjectiveName != nil {
			requestedServiceObjectiveName := *typedInput.Properties.RequestedServiceObjectiveName
			database.RequestedServiceObjectiveName = &requestedServiceObjectiveName
		}
	}

	// Set property "RestorableDroppedDatabaseId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RestorableDroppedDatabaseId != nil {
			restorableDroppedDatabaseId := *typedInput.Properties.RestorableDroppedDatabaseId
			database.RestorableDroppedDatabaseId = &restorableDroppedDatabaseId
		}
	}

	// Set property "RestorePointInTime":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RestorePointInTime != nil {
			restorePointInTime := *typedInput.Properties.RestorePointInTime
			database.RestorePointInTime = &restorePointInTime
		}
	}

	// Set property "ResumedDate":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ResumedDate != nil {
			resumedDate := *typedInput.Properties.ResumedDate
			database.ResumedDate = &resumedDate
		}
	}

	// Set property "SampleName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SampleName != nil {
			sampleName := *typedInput.Properties.SampleName
			database.SampleName = &sampleName
		}
	}

	// Set property "SecondaryType":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SecondaryType != nil {
			secondaryType := *typedInput.Properties.SecondaryType
			database.SecondaryType = &secondaryType
		}
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 Sku_STATUS
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		database.Sku = &sku
	}

	// Set property "SourceDatabaseDeletionDate":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SourceDatabaseDeletionDate != nil {
			sourceDatabaseDeletionDate := *typedInput.Properties.SourceDatabaseDeletionDate
			database.SourceDatabaseDeletionDate = &sourceDatabaseDeletionDate
		}
	}

	// Set property "SourceDatabaseId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SourceDatabaseId != nil {
			sourceDatabaseId := *typedInput.Properties.SourceDatabaseId
			database.SourceDatabaseId = &sourceDatabaseId
		}
	}

	// Set property "SourceResourceId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SourceResourceId != nil {
			sourceResourceId := *typedInput.Properties.SourceResourceId
			database.SourceResourceId = &sourceResourceId
		}
	}

	// Set property "Status":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Status != nil {
			status := *typedInput.Properties.Status
			database.Status = &status
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		database.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			database.Tags[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		database.Type = &typeVar
	}

	// Set property "ZoneRedundant":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ZoneRedundant != nil {
			zoneRedundant := *typedInput.Properties.ZoneRedundant
			database.ZoneRedundant = &zoneRedundant
		}
	}

	// No error
	return nil
}

// AssignProperties_From_Servers_Database_STATUS populates our Servers_Database_STATUS from the provided source Servers_Database_STATUS
func (database *Servers_Database_STATUS) AssignProperties_From_Servers_Database_STATUS(source *v20211101s.Servers_Database_STATUS) error {

	// AutoPauseDelay
	database.AutoPauseDelay = genruntime.ClonePointerToInt(source.AutoPauseDelay)

	// CatalogCollation
	if source.CatalogCollation != nil {
		catalogCollation := DatabaseProperties_CatalogCollation_STATUS(*source.CatalogCollation)
		database.CatalogCollation = &catalogCollation
	} else {
		database.CatalogCollation = nil
	}

	// Collation
	database.Collation = genruntime.ClonePointerToString(source.Collation)

	// Conditions
	database.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// CreateMode
	if source.CreateMode != nil {
		createMode := DatabaseProperties_CreateMode_STATUS(*source.CreateMode)
		database.CreateMode = &createMode
	} else {
		database.CreateMode = nil
	}

	// CreationDate
	database.CreationDate = genruntime.ClonePointerToString(source.CreationDate)

	// CurrentBackupStorageRedundancy
	if source.CurrentBackupStorageRedundancy != nil {
		currentBackupStorageRedundancy := DatabaseProperties_CurrentBackupStorageRedundancy_STATUS(*source.CurrentBackupStorageRedundancy)
		database.CurrentBackupStorageRedundancy = &currentBackupStorageRedundancy
	} else {
		database.CurrentBackupStorageRedundancy = nil
	}

	// CurrentServiceObjectiveName
	database.CurrentServiceObjectiveName = genruntime.ClonePointerToString(source.CurrentServiceObjectiveName)

	// CurrentSku
	if source.CurrentSku != nil {
		var currentSku Sku_STATUS
		err := currentSku.AssignProperties_From_Sku_STATUS(source.CurrentSku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Sku_STATUS() to populate field CurrentSku")
		}
		database.CurrentSku = &currentSku
	} else {
		database.CurrentSku = nil
	}

	// DatabaseId
	database.DatabaseId = genruntime.ClonePointerToString(source.DatabaseId)

	// DefaultSecondaryLocation
	database.DefaultSecondaryLocation = genruntime.ClonePointerToString(source.DefaultSecondaryLocation)

	// EarliestRestoreDate
	database.EarliestRestoreDate = genruntime.ClonePointerToString(source.EarliestRestoreDate)

	// ElasticPoolId
	database.ElasticPoolId = genruntime.ClonePointerToString(source.ElasticPoolId)

	// FailoverGroupId
	database.FailoverGroupId = genruntime.ClonePointerToString(source.FailoverGroupId)

	// FederatedClientId
	database.FederatedClientId = genruntime.ClonePointerToString(source.FederatedClientId)

	// HighAvailabilityReplicaCount
	database.HighAvailabilityReplicaCount = genruntime.ClonePointerToInt(source.HighAvailabilityReplicaCount)

	// Id
	database.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity DatabaseIdentity_STATUS
		err := identity.AssignProperties_From_DatabaseIdentity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DatabaseIdentity_STATUS() to populate field Identity")
		}
		database.Identity = &identity
	} else {
		database.Identity = nil
	}

	// IsInfraEncryptionEnabled
	if source.IsInfraEncryptionEnabled != nil {
		isInfraEncryptionEnabled := *source.IsInfraEncryptionEnabled
		database.IsInfraEncryptionEnabled = &isInfraEncryptionEnabled
	} else {
		database.IsInfraEncryptionEnabled = nil
	}

	// IsLedgerOn
	if source.IsLedgerOn != nil {
		isLedgerOn := *source.IsLedgerOn
		database.IsLedgerOn = &isLedgerOn
	} else {
		database.IsLedgerOn = nil
	}

	// Kind
	database.Kind = genruntime.ClonePointerToString(source.Kind)

	// LicenseType
	if source.LicenseType != nil {
		licenseType := DatabaseProperties_LicenseType_STATUS(*source.LicenseType)
		database.LicenseType = &licenseType
	} else {
		database.LicenseType = nil
	}

	// Location
	database.Location = genruntime.ClonePointerToString(source.Location)

	// LongTermRetentionBackupResourceId
	database.LongTermRetentionBackupResourceId = genruntime.ClonePointerToString(source.LongTermRetentionBackupResourceId)

	// MaintenanceConfigurationId
	database.MaintenanceConfigurationId = genruntime.ClonePointerToString(source.MaintenanceConfigurationId)

	// ManagedBy
	database.ManagedBy = genruntime.ClonePointerToString(source.ManagedBy)

	// MaxLogSizeBytes
	database.MaxLogSizeBytes = genruntime.ClonePointerToInt(source.MaxLogSizeBytes)

	// MaxSizeBytes
	database.MaxSizeBytes = genruntime.ClonePointerToInt(source.MaxSizeBytes)

	// MinCapacity
	if source.MinCapacity != nil {
		minCapacity := *source.MinCapacity
		database.MinCapacity = &minCapacity
	} else {
		database.MinCapacity = nil
	}

	// Name
	database.Name = genruntime.ClonePointerToString(source.Name)

	// PausedDate
	database.PausedDate = genruntime.ClonePointerToString(source.PausedDate)

	// ReadScale
	if source.ReadScale != nil {
		readScale := DatabaseProperties_ReadScale_STATUS(*source.ReadScale)
		database.ReadScale = &readScale
	} else {
		database.ReadScale = nil
	}

	// RecoverableDatabaseId
	database.RecoverableDatabaseId = genruntime.ClonePointerToString(source.RecoverableDatabaseId)

	// RecoveryServicesRecoveryPointId
	database.RecoveryServicesRecoveryPointId = genruntime.ClonePointerToString(source.RecoveryServicesRecoveryPointId)

	// RequestedBackupStorageRedundancy
	if source.RequestedBackupStorageRedundancy != nil {
		requestedBackupStorageRedundancy := DatabaseProperties_RequestedBackupStorageRedundancy_STATUS(*source.RequestedBackupStorageRedundancy)
		database.RequestedBackupStorageRedundancy = &requestedBackupStorageRedundancy
	} else {
		database.RequestedBackupStorageRedundancy = nil
	}

	// RequestedServiceObjectiveName
	database.RequestedServiceObjectiveName = genruntime.ClonePointerToString(source.RequestedServiceObjectiveName)

	// RestorableDroppedDatabaseId
	database.RestorableDroppedDatabaseId = genruntime.ClonePointerToString(source.RestorableDroppedDatabaseId)

	// RestorePointInTime
	database.RestorePointInTime = genruntime.ClonePointerToString(source.RestorePointInTime)

	// ResumedDate
	database.ResumedDate = genruntime.ClonePointerToString(source.ResumedDate)

	// SampleName
	if source.SampleName != nil {
		sampleName := DatabaseProperties_SampleName_STATUS(*source.SampleName)
		database.SampleName = &sampleName
	} else {
		database.SampleName = nil
	}

	// SecondaryType
	if source.SecondaryType != nil {
		secondaryType := DatabaseProperties_SecondaryType_STATUS(*source.SecondaryType)
		database.SecondaryType = &secondaryType
	} else {
		database.SecondaryType = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku_STATUS
		err := sku.AssignProperties_From_Sku_STATUS(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Sku_STATUS() to populate field Sku")
		}
		database.Sku = &sku
	} else {
		database.Sku = nil
	}

	// SourceDatabaseDeletionDate
	database.SourceDatabaseDeletionDate = genruntime.ClonePointerToString(source.SourceDatabaseDeletionDate)

	// SourceDatabaseId
	database.SourceDatabaseId = genruntime.ClonePointerToString(source.SourceDatabaseId)

	// SourceResourceId
	database.SourceResourceId = genruntime.ClonePointerToString(source.SourceResourceId)

	// Status
	if source.Status != nil {
		status := DatabaseProperties_Status_STATUS(*source.Status)
		database.Status = &status
	} else {
		database.Status = nil
	}

	// Tags
	database.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	database.Type = genruntime.ClonePointerToString(source.Type)

	// ZoneRedundant
	if source.ZoneRedundant != nil {
		zoneRedundant := *source.ZoneRedundant
		database.ZoneRedundant = &zoneRedundant
	} else {
		database.ZoneRedundant = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Servers_Database_STATUS populates the provided destination Servers_Database_STATUS from our Servers_Database_STATUS
func (database *Servers_Database_STATUS) AssignProperties_To_Servers_Database_STATUS(destination *v20211101s.Servers_Database_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AutoPauseDelay
	destination.AutoPauseDelay = genruntime.ClonePointerToInt(database.AutoPauseDelay)

	// CatalogCollation
	if database.CatalogCollation != nil {
		catalogCollation := string(*database.CatalogCollation)
		destination.CatalogCollation = &catalogCollation
	} else {
		destination.CatalogCollation = nil
	}

	// Collation
	destination.Collation = genruntime.ClonePointerToString(database.Collation)

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(database.Conditions)

	// CreateMode
	if database.CreateMode != nil {
		createMode := string(*database.CreateMode)
		destination.CreateMode = &createMode
	} else {
		destination.CreateMode = nil
	}

	// CreationDate
	destination.CreationDate = genruntime.ClonePointerToString(database.CreationDate)

	// CurrentBackupStorageRedundancy
	if database.CurrentBackupStorageRedundancy != nil {
		currentBackupStorageRedundancy := string(*database.CurrentBackupStorageRedundancy)
		destination.CurrentBackupStorageRedundancy = &currentBackupStorageRedundancy
	} else {
		destination.CurrentBackupStorageRedundancy = nil
	}

	// CurrentServiceObjectiveName
	destination.CurrentServiceObjectiveName = genruntime.ClonePointerToString(database.CurrentServiceObjectiveName)

	// CurrentSku
	if database.CurrentSku != nil {
		var currentSku v20211101s.Sku_STATUS
		err := database.CurrentSku.AssignProperties_To_Sku_STATUS(&currentSku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Sku_STATUS() to populate field CurrentSku")
		}
		destination.CurrentSku = &currentSku
	} else {
		destination.CurrentSku = nil
	}

	// DatabaseId
	destination.DatabaseId = genruntime.ClonePointerToString(database.DatabaseId)

	// DefaultSecondaryLocation
	destination.DefaultSecondaryLocation = genruntime.ClonePointerToString(database.DefaultSecondaryLocation)

	// EarliestRestoreDate
	destination.EarliestRestoreDate = genruntime.ClonePointerToString(database.EarliestRestoreDate)

	// ElasticPoolId
	destination.ElasticPoolId = genruntime.ClonePointerToString(database.ElasticPoolId)

	// FailoverGroupId
	destination.FailoverGroupId = genruntime.ClonePointerToString(database.FailoverGroupId)

	// FederatedClientId
	destination.FederatedClientId = genruntime.ClonePointerToString(database.FederatedClientId)

	// HighAvailabilityReplicaCount
	destination.HighAvailabilityReplicaCount = genruntime.ClonePointerToInt(database.HighAvailabilityReplicaCount)

	// Id
	destination.Id = genruntime.ClonePointerToString(database.Id)

	// Identity
	if database.Identity != nil {
		var identity v20211101s.DatabaseIdentity_STATUS
		err := database.Identity.AssignProperties_To_DatabaseIdentity_STATUS(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DatabaseIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// IsInfraEncryptionEnabled
	if database.IsInfraEncryptionEnabled != nil {
		isInfraEncryptionEnabled := *database.IsInfraEncryptionEnabled
		destination.IsInfraEncryptionEnabled = &isInfraEncryptionEnabled
	} else {
		destination.IsInfraEncryptionEnabled = nil
	}

	// IsLedgerOn
	if database.IsLedgerOn != nil {
		isLedgerOn := *database.IsLedgerOn
		destination.IsLedgerOn = &isLedgerOn
	} else {
		destination.IsLedgerOn = nil
	}

	// Kind
	destination.Kind = genruntime.ClonePointerToString(database.Kind)

	// LicenseType
	if database.LicenseType != nil {
		licenseType := string(*database.LicenseType)
		destination.LicenseType = &licenseType
	} else {
		destination.LicenseType = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(database.Location)

	// LongTermRetentionBackupResourceId
	destination.LongTermRetentionBackupResourceId = genruntime.ClonePointerToString(database.LongTermRetentionBackupResourceId)

	// MaintenanceConfigurationId
	destination.MaintenanceConfigurationId = genruntime.ClonePointerToString(database.MaintenanceConfigurationId)

	// ManagedBy
	destination.ManagedBy = genruntime.ClonePointerToString(database.ManagedBy)

	// MaxLogSizeBytes
	destination.MaxLogSizeBytes = genruntime.ClonePointerToInt(database.MaxLogSizeBytes)

	// MaxSizeBytes
	destination.MaxSizeBytes = genruntime.ClonePointerToInt(database.MaxSizeBytes)

	// MinCapacity
	if database.MinCapacity != nil {
		minCapacity := *database.MinCapacity
		destination.MinCapacity = &minCapacity
	} else {
		destination.MinCapacity = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(database.Name)

	// PausedDate
	destination.PausedDate = genruntime.ClonePointerToString(database.PausedDate)

	// ReadScale
	if database.ReadScale != nil {
		readScale := string(*database.ReadScale)
		destination.ReadScale = &readScale
	} else {
		destination.ReadScale = nil
	}

	// RecoverableDatabaseId
	destination.RecoverableDatabaseId = genruntime.ClonePointerToString(database.RecoverableDatabaseId)

	// RecoveryServicesRecoveryPointId
	destination.RecoveryServicesRecoveryPointId = genruntime.ClonePointerToString(database.RecoveryServicesRecoveryPointId)

	// RequestedBackupStorageRedundancy
	if database.RequestedBackupStorageRedundancy != nil {
		requestedBackupStorageRedundancy := string(*database.RequestedBackupStorageRedundancy)
		destination.RequestedBackupStorageRedundancy = &requestedBackupStorageRedundancy
	} else {
		destination.RequestedBackupStorageRedundancy = nil
	}

	// RequestedServiceObjectiveName
	destination.RequestedServiceObjectiveName = genruntime.ClonePointerToString(database.RequestedServiceObjectiveName)

	// RestorableDroppedDatabaseId
	destination.RestorableDroppedDatabaseId = genruntime.ClonePointerToString(database.RestorableDroppedDatabaseId)

	// RestorePointInTime
	destination.RestorePointInTime = genruntime.ClonePointerToString(database.RestorePointInTime)

	// ResumedDate
	destination.ResumedDate = genruntime.ClonePointerToString(database.ResumedDate)

	// SampleName
	if database.SampleName != nil {
		sampleName := string(*database.SampleName)
		destination.SampleName = &sampleName
	} else {
		destination.SampleName = nil
	}

	// SecondaryType
	if database.SecondaryType != nil {
		secondaryType := string(*database.SecondaryType)
		destination.SecondaryType = &secondaryType
	} else {
		destination.SecondaryType = nil
	}

	// Sku
	if database.Sku != nil {
		var sku v20211101s.Sku_STATUS
		err := database.Sku.AssignProperties_To_Sku_STATUS(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Sku_STATUS() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// SourceDatabaseDeletionDate
	destination.SourceDatabaseDeletionDate = genruntime.ClonePointerToString(database.SourceDatabaseDeletionDate)

	// SourceDatabaseId
	destination.SourceDatabaseId = genruntime.ClonePointerToString(database.SourceDatabaseId)

	// SourceResourceId
	destination.SourceResourceId = genruntime.ClonePointerToString(database.SourceResourceId)

	// Status
	if database.Status != nil {
		status := string(*database.Status)
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(database.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(database.Type)

	// ZoneRedundant
	if database.ZoneRedundant != nil {
		zoneRedundant := *database.ZoneRedundant
		destination.ZoneRedundant = &zoneRedundant
	} else {
		destination.ZoneRedundant = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Azure Active Directory identity configuration for a resource.
type DatabaseIdentity struct {
	// Type: The identity type
	Type *DatabaseIdentity_Type `json:"type,omitempty"`

	// UserAssignedIdentities: The resource ids of the user assigned identities to use
	UserAssignedIdentities []UserAssignedIdentityDetails `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.ARMTransformer = &DatabaseIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *DatabaseIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &DatabaseIdentity_ARM{}

	// Set property "Type":
	if identity.Type != nil {
		typeVar := *identity.Type
		result.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	result.UserAssignedIdentities = make(map[string]UserAssignedIdentityDetails_ARM, len(identity.UserAssignedIdentities))
	for _, ident := range identity.UserAssignedIdentities {
		identARMID, err := resolved.ResolvedReferences.Lookup(ident.Reference)
		if err != nil {
			return nil, err
		}
		key := identARMID
		result.UserAssignedIdentities[key] = UserAssignedIdentityDetails_ARM{}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *DatabaseIdentity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DatabaseIdentity_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *DatabaseIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DatabaseIdentity_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DatabaseIdentity_ARM, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		identity.Type = &typeVar
	}

	// no assignment for property "UserAssignedIdentities"

	// No error
	return nil
}

// AssignProperties_From_DatabaseIdentity populates our DatabaseIdentity from the provided source DatabaseIdentity
func (identity *DatabaseIdentity) AssignProperties_From_DatabaseIdentity(source *v20211101s.DatabaseIdentity) error {

	// Type
	if source.Type != nil {
		typeVar := DatabaseIdentity_Type(*source.Type)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, len(source.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity UserAssignedIdentityDetails
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentityDetails(&userAssignedIdentityItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DatabaseIdentity populates the provided destination DatabaseIdentity from our DatabaseIdentity
func (identity *DatabaseIdentity) AssignProperties_To_DatabaseIdentity(destination *v20211101s.DatabaseIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]v20211101s.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity v20211101s.UserAssignedIdentityDetails
			err := userAssignedIdentityItem.AssignProperties_To_UserAssignedIdentityDetails(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityList
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DatabaseIdentity_STATUS populates our DatabaseIdentity from the provided source DatabaseIdentity_STATUS
func (identity *DatabaseIdentity) Initialize_From_DatabaseIdentity_STATUS(source *DatabaseIdentity_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := DatabaseIdentity_Type(*source.Type)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, 0, len(source.UserAssignedIdentities))
		for userAssignedIdentitiesKey := range source.UserAssignedIdentities {
			userAssignedIdentitiesRef := genruntime.CreateResourceReferenceFromARMID(userAssignedIdentitiesKey)
			userAssignedIdentityList = append(userAssignedIdentityList, UserAssignedIdentityDetails{Reference: userAssignedIdentitiesRef})
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// Azure Active Directory identity configuration for a resource.
type DatabaseIdentity_STATUS struct {
	// TenantId: The Azure Active Directory tenant id.
	TenantId *string `json:"tenantId,omitempty"`

	// Type: The identity type
	Type *DatabaseIdentity_Type_STATUS `json:"type,omitempty"`

	// UserAssignedIdentities: The resource ids of the user assigned identities to use
	UserAssignedIdentities map[string]DatabaseUserIdentity_STATUS `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.FromARMConverter = &DatabaseIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *DatabaseIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DatabaseIdentity_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *DatabaseIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DatabaseIdentity_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DatabaseIdentity_STATUS_ARM, got %T", armInput)
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		identity.TenantId = &tenantId
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		identity.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	if typedInput.UserAssignedIdentities != nil {
		identity.UserAssignedIdentities = make(map[string]DatabaseUserIdentity_STATUS, len(typedInput.UserAssignedIdentities))
		for key, value := range typedInput.UserAssignedIdentities {
			var value1 DatabaseUserIdentity_STATUS
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			identity.UserAssignedIdentities[key] = value1
		}
	}

	// No error
	return nil
}

// AssignProperties_From_DatabaseIdentity_STATUS populates our DatabaseIdentity_STATUS from the provided source DatabaseIdentity_STATUS
func (identity *DatabaseIdentity_STATUS) AssignProperties_From_DatabaseIdentity_STATUS(source *v20211101s.DatabaseIdentity_STATUS) error {

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := DatabaseIdentity_Type_STATUS(*source.Type)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]DatabaseUserIdentity_STATUS, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity DatabaseUserIdentity_STATUS
			err := userAssignedIdentity.AssignProperties_From_DatabaseUserIdentity_STATUS(&userAssignedIdentityValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DatabaseUserIdentity_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DatabaseIdentity_STATUS populates the provided destination DatabaseIdentity_STATUS from our DatabaseIdentity_STATUS
func (identity *DatabaseIdentity_STATUS) AssignProperties_To_DatabaseIdentity_STATUS(destination *v20211101s.DatabaseIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]v20211101s.DatabaseUserIdentity_STATUS, len(identity.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity v20211101s.DatabaseUserIdentity_STATUS
			err := userAssignedIdentityValue.AssignProperties_To_DatabaseUserIdentity_STATUS(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DatabaseUserIdentity_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"DATABASE_DEFAULT","SQL_Latin1_General_CP1_CI_AS"}
type DatabaseProperties_CatalogCollation string

const (
	DatabaseProperties_CatalogCollation_DATABASE_DEFAULT             = DatabaseProperties_CatalogCollation("DATABASE_DEFAULT")
	DatabaseProperties_CatalogCollation_SQL_Latin1_General_CP1_CI_AS = DatabaseProperties_CatalogCollation("SQL_Latin1_General_CP1_CI_AS")
)

type DatabaseProperties_CatalogCollation_STATUS string

const (
	DatabaseProperties_CatalogCollation_STATUS_DATABASE_DEFAULT             = DatabaseProperties_CatalogCollation_STATUS("DATABASE_DEFAULT")
	DatabaseProperties_CatalogCollation_STATUS_SQL_Latin1_General_CP1_CI_AS = DatabaseProperties_CatalogCollation_STATUS("SQL_Latin1_General_CP1_CI_AS")
)

// +kubebuilder:validation:Enum={"Copy","Default","OnlineSecondary","PointInTimeRestore","Recovery","Restore","RestoreExternalBackup","RestoreExternalBackupSecondary","RestoreLongTermRetentionBackup","Secondary"}
type DatabaseProperties_CreateMode string

const (
	DatabaseProperties_CreateMode_Copy                           = DatabaseProperties_CreateMode("Copy")
	DatabaseProperties_CreateMode_Default                        = DatabaseProperties_CreateMode("Default")
	DatabaseProperties_CreateMode_OnlineSecondary                = DatabaseProperties_CreateMode("OnlineSecondary")
	DatabaseProperties_CreateMode_PointInTimeRestore             = DatabaseProperties_CreateMode("PointInTimeRestore")
	DatabaseProperties_CreateMode_Recovery                       = DatabaseProperties_CreateMode("Recovery")
	DatabaseProperties_CreateMode_Restore                        = DatabaseProperties_CreateMode("Restore")
	DatabaseProperties_CreateMode_RestoreExternalBackup          = DatabaseProperties_CreateMode("RestoreExternalBackup")
	DatabaseProperties_CreateMode_RestoreExternalBackupSecondary = DatabaseProperties_CreateMode("RestoreExternalBackupSecondary")
	DatabaseProperties_CreateMode_RestoreLongTermRetentionBackup = DatabaseProperties_CreateMode("RestoreLongTermRetentionBackup")
	DatabaseProperties_CreateMode_Secondary                      = DatabaseProperties_CreateMode("Secondary")
)

type DatabaseProperties_CreateMode_STATUS string

const (
	DatabaseProperties_CreateMode_STATUS_Copy                           = DatabaseProperties_CreateMode_STATUS("Copy")
	DatabaseProperties_CreateMode_STATUS_Default                        = DatabaseProperties_CreateMode_STATUS("Default")
	DatabaseProperties_CreateMode_STATUS_OnlineSecondary                = DatabaseProperties_CreateMode_STATUS("OnlineSecondary")
	DatabaseProperties_CreateMode_STATUS_PointInTimeRestore             = DatabaseProperties_CreateMode_STATUS("PointInTimeRestore")
	DatabaseProperties_CreateMode_STATUS_Recovery                       = DatabaseProperties_CreateMode_STATUS("Recovery")
	DatabaseProperties_CreateMode_STATUS_Restore                        = DatabaseProperties_CreateMode_STATUS("Restore")
	DatabaseProperties_CreateMode_STATUS_RestoreExternalBackup          = DatabaseProperties_CreateMode_STATUS("RestoreExternalBackup")
	DatabaseProperties_CreateMode_STATUS_RestoreExternalBackupSecondary = DatabaseProperties_CreateMode_STATUS("RestoreExternalBackupSecondary")
	DatabaseProperties_CreateMode_STATUS_RestoreLongTermRetentionBackup = DatabaseProperties_CreateMode_STATUS("RestoreLongTermRetentionBackup")
	DatabaseProperties_CreateMode_STATUS_Secondary                      = DatabaseProperties_CreateMode_STATUS("Secondary")
)

type DatabaseProperties_CurrentBackupStorageRedundancy_STATUS string

const (
	DatabaseProperties_CurrentBackupStorageRedundancy_STATUS_Geo     = DatabaseProperties_CurrentBackupStorageRedundancy_STATUS("Geo")
	DatabaseProperties_CurrentBackupStorageRedundancy_STATUS_GeoZone = DatabaseProperties_CurrentBackupStorageRedundancy_STATUS("GeoZone")
	DatabaseProperties_CurrentBackupStorageRedundancy_STATUS_Local   = DatabaseProperties_CurrentBackupStorageRedundancy_STATUS("Local")
	DatabaseProperties_CurrentBackupStorageRedundancy_STATUS_Zone    = DatabaseProperties_CurrentBackupStorageRedundancy_STATUS("Zone")
)

// +kubebuilder:validation:Enum={"BasePrice","LicenseIncluded"}
type DatabaseProperties_LicenseType string

const (
	DatabaseProperties_LicenseType_BasePrice       = DatabaseProperties_LicenseType("BasePrice")
	DatabaseProperties_LicenseType_LicenseIncluded = DatabaseProperties_LicenseType("LicenseIncluded")
)

type DatabaseProperties_LicenseType_STATUS string

const (
	DatabaseProperties_LicenseType_STATUS_BasePrice       = DatabaseProperties_LicenseType_STATUS("BasePrice")
	DatabaseProperties_LicenseType_STATUS_LicenseIncluded = DatabaseProperties_LicenseType_STATUS("LicenseIncluded")
)

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type DatabaseProperties_ReadScale string

const (
	DatabaseProperties_ReadScale_Disabled = DatabaseProperties_ReadScale("Disabled")
	DatabaseProperties_ReadScale_Enabled  = DatabaseProperties_ReadScale("Enabled")
)

type DatabaseProperties_ReadScale_STATUS string

const (
	DatabaseProperties_ReadScale_STATUS_Disabled = DatabaseProperties_ReadScale_STATUS("Disabled")
	DatabaseProperties_ReadScale_STATUS_Enabled  = DatabaseProperties_ReadScale_STATUS("Enabled")
)

// +kubebuilder:validation:Enum={"Geo","GeoZone","Local","Zone"}
type DatabaseProperties_RequestedBackupStorageRedundancy string

const (
	DatabaseProperties_RequestedBackupStorageRedundancy_Geo     = DatabaseProperties_RequestedBackupStorageRedundancy("Geo")
	DatabaseProperties_RequestedBackupStorageRedundancy_GeoZone = DatabaseProperties_RequestedBackupStorageRedundancy("GeoZone")
	DatabaseProperties_RequestedBackupStorageRedundancy_Local   = DatabaseProperties_RequestedBackupStorageRedundancy("Local")
	DatabaseProperties_RequestedBackupStorageRedundancy_Zone    = DatabaseProperties_RequestedBackupStorageRedundancy("Zone")
)

type DatabaseProperties_RequestedBackupStorageRedundancy_STATUS string

const (
	DatabaseProperties_RequestedBackupStorageRedundancy_STATUS_Geo     = DatabaseProperties_RequestedBackupStorageRedundancy_STATUS("Geo")
	DatabaseProperties_RequestedBackupStorageRedundancy_STATUS_GeoZone = DatabaseProperties_RequestedBackupStorageRedundancy_STATUS("GeoZone")
	DatabaseProperties_RequestedBackupStorageRedundancy_STATUS_Local   = DatabaseProperties_RequestedBackupStorageRedundancy_STATUS("Local")
	DatabaseProperties_RequestedBackupStorageRedundancy_STATUS_Zone    = DatabaseProperties_RequestedBackupStorageRedundancy_STATUS("Zone")
)

// +kubebuilder:validation:Enum={"AdventureWorksLT","WideWorldImportersFull","WideWorldImportersStd"}
type DatabaseProperties_SampleName string

const (
	DatabaseProperties_SampleName_AdventureWorksLT       = DatabaseProperties_SampleName("AdventureWorksLT")
	DatabaseProperties_SampleName_WideWorldImportersFull = DatabaseProperties_SampleName("WideWorldImportersFull")
	DatabaseProperties_SampleName_WideWorldImportersStd  = DatabaseProperties_SampleName("WideWorldImportersStd")
)

type DatabaseProperties_SampleName_STATUS string

const (
	DatabaseProperties_SampleName_STATUS_AdventureWorksLT       = DatabaseProperties_SampleName_STATUS("AdventureWorksLT")
	DatabaseProperties_SampleName_STATUS_WideWorldImportersFull = DatabaseProperties_SampleName_STATUS("WideWorldImportersFull")
	DatabaseProperties_SampleName_STATUS_WideWorldImportersStd  = DatabaseProperties_SampleName_STATUS("WideWorldImportersStd")
)

// +kubebuilder:validation:Enum={"Geo","Named"}
type DatabaseProperties_SecondaryType string

const (
	DatabaseProperties_SecondaryType_Geo   = DatabaseProperties_SecondaryType("Geo")
	DatabaseProperties_SecondaryType_Named = DatabaseProperties_SecondaryType("Named")
)

type DatabaseProperties_SecondaryType_STATUS string

const (
	DatabaseProperties_SecondaryType_STATUS_Geo   = DatabaseProperties_SecondaryType_STATUS("Geo")
	DatabaseProperties_SecondaryType_STATUS_Named = DatabaseProperties_SecondaryType_STATUS("Named")
)

type DatabaseProperties_Status_STATUS string

const (
	DatabaseProperties_Status_STATUS_AutoClosed                        = DatabaseProperties_Status_STATUS("AutoClosed")
	DatabaseProperties_Status_STATUS_Copying                           = DatabaseProperties_Status_STATUS("Copying")
	DatabaseProperties_Status_STATUS_Creating                          = DatabaseProperties_Status_STATUS("Creating")
	DatabaseProperties_Status_STATUS_Disabled                          = DatabaseProperties_Status_STATUS("Disabled")
	DatabaseProperties_Status_STATUS_EmergencyMode                     = DatabaseProperties_Status_STATUS("EmergencyMode")
	DatabaseProperties_Status_STATUS_Inaccessible                      = DatabaseProperties_Status_STATUS("Inaccessible")
	DatabaseProperties_Status_STATUS_Offline                           = DatabaseProperties_Status_STATUS("Offline")
	DatabaseProperties_Status_STATUS_OfflineChangingDwPerformanceTiers = DatabaseProperties_Status_STATUS("OfflineChangingDwPerformanceTiers")
	DatabaseProperties_Status_STATUS_OfflineSecondary                  = DatabaseProperties_Status_STATUS("OfflineSecondary")
	DatabaseProperties_Status_STATUS_Online                            = DatabaseProperties_Status_STATUS("Online")
	DatabaseProperties_Status_STATUS_OnlineChangingDwPerformanceTiers  = DatabaseProperties_Status_STATUS("OnlineChangingDwPerformanceTiers")
	DatabaseProperties_Status_STATUS_Paused                            = DatabaseProperties_Status_STATUS("Paused")
	DatabaseProperties_Status_STATUS_Pausing                           = DatabaseProperties_Status_STATUS("Pausing")
	DatabaseProperties_Status_STATUS_Recovering                        = DatabaseProperties_Status_STATUS("Recovering")
	DatabaseProperties_Status_STATUS_RecoveryPending                   = DatabaseProperties_Status_STATUS("RecoveryPending")
	DatabaseProperties_Status_STATUS_Restoring                         = DatabaseProperties_Status_STATUS("Restoring")
	DatabaseProperties_Status_STATUS_Resuming                          = DatabaseProperties_Status_STATUS("Resuming")
	DatabaseProperties_Status_STATUS_Scaling                           = DatabaseProperties_Status_STATUS("Scaling")
	DatabaseProperties_Status_STATUS_Shutdown                          = DatabaseProperties_Status_STATUS("Shutdown")
	DatabaseProperties_Status_STATUS_Standby                           = DatabaseProperties_Status_STATUS("Standby")
	DatabaseProperties_Status_STATUS_Starting                          = DatabaseProperties_Status_STATUS("Starting")
	DatabaseProperties_Status_STATUS_Stopped                           = DatabaseProperties_Status_STATUS("Stopped")
	DatabaseProperties_Status_STATUS_Stopping                          = DatabaseProperties_Status_STATUS("Stopping")
	DatabaseProperties_Status_STATUS_Suspect                           = DatabaseProperties_Status_STATUS("Suspect")
)

// An ARM Resource SKU.
type Sku struct {
	// Capacity: Capacity of the particular SKU.
	Capacity *int `json:"capacity,omitempty"`

	// Family: If the service has different generations of hardware, for the same SKU, then that can be captured here.
	Family *string `json:"family,omitempty"`

	// +kubebuilder:validation:Required
	// Name: The name of the SKU, typically, a letter + Number code, e.g. P3.
	Name *string `json:"name,omitempty"`

	// Size: Size of the particular SKU
	Size *string `json:"size,omitempty"`

	// Tier: The tier or edition of the particular SKU, e.g. Basic, Premium.
	Tier *string `json:"tier,omitempty"`
}

var _ genruntime.ARMTransformer = &Sku{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (sku *Sku) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if sku == nil {
		return nil, nil
	}
	result := &Sku_ARM{}

	// Set property "Capacity":
	if sku.Capacity != nil {
		capacity := *sku.Capacity
		result.Capacity = &capacity
	}

	// Set property "Family":
	if sku.Family != nil {
		family := *sku.Family
		result.Family = &family
	}

	// Set property "Name":
	if sku.Name != nil {
		name := *sku.Name
		result.Name = &name
	}

	// Set property "Size":
	if sku.Size != nil {
		size := *sku.Size
		result.Size = &size
	}

	// Set property "Tier":
	if sku.Tier != nil {
		tier := *sku.Tier
		result.Tier = &tier
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sku *Sku) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Sku_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sku *Sku) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Sku_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Sku_ARM, got %T", armInput)
	}

	// Set property "Capacity":
	if typedInput.Capacity != nil {
		capacity := *typedInput.Capacity
		sku.Capacity = &capacity
	}

	// Set property "Family":
	if typedInput.Family != nil {
		family := *typedInput.Family
		sku.Family = &family
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		sku.Name = &name
	}

	// Set property "Size":
	if typedInput.Size != nil {
		size := *typedInput.Size
		sku.Size = &size
	}

	// Set property "Tier":
	if typedInput.Tier != nil {
		tier := *typedInput.Tier
		sku.Tier = &tier
	}

	// No error
	return nil
}

// AssignProperties_From_Sku populates our Sku from the provided source Sku
func (sku *Sku) AssignProperties_From_Sku(source *v20211101s.Sku) error {

	// Capacity
	sku.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Family
	sku.Family = genruntime.ClonePointerToString(source.Family)

	// Name
	sku.Name = genruntime.ClonePointerToString(source.Name)

	// Size
	sku.Size = genruntime.ClonePointerToString(source.Size)

	// Tier
	sku.Tier = genruntime.ClonePointerToString(source.Tier)

	// No error
	return nil
}

// AssignProperties_To_Sku populates the provided destination Sku from our Sku
func (sku *Sku) AssignProperties_To_Sku(destination *v20211101s.Sku) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Capacity
	destination.Capacity = genruntime.ClonePointerToInt(sku.Capacity)

	// Family
	destination.Family = genruntime.ClonePointerToString(sku.Family)

	// Name
	destination.Name = genruntime.ClonePointerToString(sku.Name)

	// Size
	destination.Size = genruntime.ClonePointerToString(sku.Size)

	// Tier
	destination.Tier = genruntime.ClonePointerToString(sku.Tier)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Sku_STATUS populates our Sku from the provided source Sku_STATUS
func (sku *Sku) Initialize_From_Sku_STATUS(source *Sku_STATUS) error {

	// Capacity
	sku.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Family
	sku.Family = genruntime.ClonePointerToString(source.Family)

	// Name
	sku.Name = genruntime.ClonePointerToString(source.Name)

	// Size
	sku.Size = genruntime.ClonePointerToString(source.Size)

	// Tier
	sku.Tier = genruntime.ClonePointerToString(source.Tier)

	// No error
	return nil
}

// An ARM Resource SKU.
type Sku_STATUS struct {
	// Capacity: Capacity of the particular SKU.
	Capacity *int `json:"capacity,omitempty"`

	// Family: If the service has different generations of hardware, for the same SKU, then that can be captured here.
	Family *string `json:"family,omitempty"`

	// Name: The name of the SKU, typically, a letter + Number code, e.g. P3.
	Name *string `json:"name,omitempty"`

	// Size: Size of the particular SKU
	Size *string `json:"size,omitempty"`

	// Tier: The tier or edition of the particular SKU, e.g. Basic, Premium.
	Tier *string `json:"tier,omitempty"`
}

var _ genruntime.FromARMConverter = &Sku_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sku *Sku_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Sku_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sku *Sku_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Sku_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Sku_STATUS_ARM, got %T", armInput)
	}

	// Set property "Capacity":
	if typedInput.Capacity != nil {
		capacity := *typedInput.Capacity
		sku.Capacity = &capacity
	}

	// Set property "Family":
	if typedInput.Family != nil {
		family := *typedInput.Family
		sku.Family = &family
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		sku.Name = &name
	}

	// Set property "Size":
	if typedInput.Size != nil {
		size := *typedInput.Size
		sku.Size = &size
	}

	// Set property "Tier":
	if typedInput.Tier != nil {
		tier := *typedInput.Tier
		sku.Tier = &tier
	}

	// No error
	return nil
}

// AssignProperties_From_Sku_STATUS populates our Sku_STATUS from the provided source Sku_STATUS
func (sku *Sku_STATUS) AssignProperties_From_Sku_STATUS(source *v20211101s.Sku_STATUS) error {

	// Capacity
	sku.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Family
	sku.Family = genruntime.ClonePointerToString(source.Family)

	// Name
	sku.Name = genruntime.ClonePointerToString(source.Name)

	// Size
	sku.Size = genruntime.ClonePointerToString(source.Size)

	// Tier
	sku.Tier = genruntime.ClonePointerToString(source.Tier)

	// No error
	return nil
}

// AssignProperties_To_Sku_STATUS populates the provided destination Sku_STATUS from our Sku_STATUS
func (sku *Sku_STATUS) AssignProperties_To_Sku_STATUS(destination *v20211101s.Sku_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Capacity
	destination.Capacity = genruntime.ClonePointerToInt(sku.Capacity)

	// Family
	destination.Family = genruntime.ClonePointerToString(sku.Family)

	// Name
	destination.Name = genruntime.ClonePointerToString(sku.Name)

	// Size
	destination.Size = genruntime.ClonePointerToString(sku.Size)

	// Tier
	destination.Tier = genruntime.ClonePointerToString(sku.Tier)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Azure Active Directory identity configuration for a resource.
type DatabaseUserIdentity_STATUS struct {
	// ClientId: The Azure Active Directory client id.
	ClientId *string `json:"clientId,omitempty"`

	// PrincipalId: The Azure Active Directory principal id.
	PrincipalId *string `json:"principalId,omitempty"`
}

var _ genruntime.FromARMConverter = &DatabaseUserIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *DatabaseUserIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DatabaseUserIdentity_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *DatabaseUserIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DatabaseUserIdentity_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DatabaseUserIdentity_STATUS_ARM, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		identity.ClientId = &clientId
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// No error
	return nil
}

// AssignProperties_From_DatabaseUserIdentity_STATUS populates our DatabaseUserIdentity_STATUS from the provided source DatabaseUserIdentity_STATUS
func (identity *DatabaseUserIdentity_STATUS) AssignProperties_From_DatabaseUserIdentity_STATUS(source *v20211101s.DatabaseUserIdentity_STATUS) error {

	// ClientId
	identity.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// No error
	return nil
}

// AssignProperties_To_DatabaseUserIdentity_STATUS populates the provided destination DatabaseUserIdentity_STATUS from our DatabaseUserIdentity_STATUS
func (identity *DatabaseUserIdentity_STATUS) AssignProperties_To_DatabaseUserIdentity_STATUS(destination *v20211101s.DatabaseUserIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identity.ClientId)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&ServersDatabase{}, &ServersDatabaseList{})
}
