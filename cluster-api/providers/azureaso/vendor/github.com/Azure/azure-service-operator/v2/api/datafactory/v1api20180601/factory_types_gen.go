// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20180601

import (
	"fmt"
	v20180601s "github.com/Azure/azure-service-operator/v2/api/datafactory/v1api20180601/storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /datafactory/resource-manager/Microsoft.DataFactory/stable/2018-06-01/datafactory.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}
type Factory struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              Factory_Spec   `json:"spec,omitempty"`
	Status            Factory_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &Factory{}

// GetConditions returns the conditions of the resource
func (factory *Factory) GetConditions() conditions.Conditions {
	return factory.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (factory *Factory) SetConditions(conditions conditions.Conditions) {
	factory.Status.Conditions = conditions
}

var _ conversion.Convertible = &Factory{}

// ConvertFrom populates our Factory from the provided hub Factory
func (factory *Factory) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v20180601s.Factory)
	if !ok {
		return fmt.Errorf("expected datafactory/v1api20180601/storage/Factory but received %T instead", hub)
	}

	return factory.AssignProperties_From_Factory(source)
}

// ConvertTo populates the provided hub Factory from our Factory
func (factory *Factory) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v20180601s.Factory)
	if !ok {
		return fmt.Errorf("expected datafactory/v1api20180601/storage/Factory but received %T instead", hub)
	}

	return factory.AssignProperties_To_Factory(destination)
}

// +kubebuilder:webhook:path=/mutate-datafactory-azure-com-v1api20180601-factory,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=datafactory.azure.com,resources=factories,verbs=create;update,versions=v1api20180601,name=default.v1api20180601.factories.datafactory.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &Factory{}

// Default applies defaults to the Factory resource
func (factory *Factory) Default() {
	factory.defaultImpl()
	var temp any = factory
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (factory *Factory) defaultAzureName() {
	if factory.Spec.AzureName == "" {
		factory.Spec.AzureName = factory.Name
	}
}

// defaultImpl applies the code generated defaults to the Factory resource
func (factory *Factory) defaultImpl() { factory.defaultAzureName() }

var _ genruntime.ImportableResource = &Factory{}

// InitializeSpec initializes the spec for this resource from the given status
func (factory *Factory) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*Factory_STATUS); ok {
		return factory.Spec.Initialize_From_Factory_STATUS(s)
	}

	return fmt.Errorf("expected Status of type Factory_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &Factory{}

// AzureName returns the Azure name of the resource
func (factory *Factory) AzureName() string {
	return factory.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2018-06-01"
func (factory Factory) GetAPIVersion() string {
	return string(APIVersion_Value)
}

// GetResourceScope returns the scope of the resource
func (factory *Factory) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (factory *Factory) GetSpec() genruntime.ConvertibleSpec {
	return &factory.Spec
}

// GetStatus returns the status of this resource
func (factory *Factory) GetStatus() genruntime.ConvertibleStatus {
	return &factory.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (factory *Factory) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.DataFactory/factories"
func (factory *Factory) GetType() string {
	return "Microsoft.DataFactory/factories"
}

// NewEmptyStatus returns a new empty (blank) status
func (factory *Factory) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &Factory_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (factory *Factory) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(factory.Spec)
	return factory.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (factory *Factory) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*Factory_STATUS); ok {
		factory.Status = *st
		return nil
	}

	// Convert status to required version
	var st Factory_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	factory.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-datafactory-azure-com-v1api20180601-factory,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=datafactory.azure.com,resources=factories,verbs=create;update,versions=v1api20180601,name=validate.v1api20180601.factories.datafactory.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &Factory{}

// ValidateCreate validates the creation of the resource
func (factory *Factory) ValidateCreate() (admission.Warnings, error) {
	validations := factory.createValidations()
	var temp any = factory
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	return genruntime.ValidateCreate(validations)
}

// ValidateDelete validates the deletion of the resource
func (factory *Factory) ValidateDelete() (admission.Warnings, error) {
	validations := factory.deleteValidations()
	var temp any = factory
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	return genruntime.ValidateDelete(validations)
}

// ValidateUpdate validates an update of the resource
func (factory *Factory) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	validations := factory.updateValidations()
	var temp any = factory
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	return genruntime.ValidateUpdate(old, validations)
}

// createValidations validates the creation of the resource
func (factory *Factory) createValidations() []func() (admission.Warnings, error) {
	return []func() (admission.Warnings, error){factory.validateResourceReferences, factory.validateOwnerReference}
}

// deleteValidations validates the deletion of the resource
func (factory *Factory) deleteValidations() []func() (admission.Warnings, error) {
	return nil
}

// updateValidations validates the update of the resource
func (factory *Factory) updateValidations() []func(old runtime.Object) (admission.Warnings, error) {
	return []func(old runtime.Object) (admission.Warnings, error){
		func(old runtime.Object) (admission.Warnings, error) {
			return factory.validateResourceReferences()
		},
		factory.validateWriteOnceProperties,
		func(old runtime.Object) (admission.Warnings, error) {
			return factory.validateOwnerReference()
		},
	}
}

// validateOwnerReference validates the owner field
func (factory *Factory) validateOwnerReference() (admission.Warnings, error) {
	return genruntime.ValidateOwner(factory)
}

// validateResourceReferences validates all resource references
func (factory *Factory) validateResourceReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindResourceReferences(&factory.Spec)
	if err != nil {
		return nil, err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (factory *Factory) validateWriteOnceProperties(old runtime.Object) (admission.Warnings, error) {
	oldObj, ok := old.(*Factory)
	if !ok {
		return nil, nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, factory)
}

// AssignProperties_From_Factory populates our Factory from the provided source Factory
func (factory *Factory) AssignProperties_From_Factory(source *v20180601s.Factory) error {

	// ObjectMeta
	factory.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec Factory_Spec
	err := spec.AssignProperties_From_Factory_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_Factory_Spec() to populate field Spec")
	}
	factory.Spec = spec

	// Status
	var status Factory_STATUS
	err = status.AssignProperties_From_Factory_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_Factory_STATUS() to populate field Status")
	}
	factory.Status = status

	// No error
	return nil
}

// AssignProperties_To_Factory populates the provided destination Factory from our Factory
func (factory *Factory) AssignProperties_To_Factory(destination *v20180601s.Factory) error {

	// ObjectMeta
	destination.ObjectMeta = *factory.ObjectMeta.DeepCopy()

	// Spec
	var spec v20180601s.Factory_Spec
	err := factory.Spec.AssignProperties_To_Factory_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_Factory_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v20180601s.Factory_STATUS
	err = factory.Status.AssignProperties_To_Factory_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_Factory_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (factory *Factory) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: factory.Spec.OriginalVersion(),
		Kind:    "Factory",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /datafactory/resource-manager/Microsoft.DataFactory/stable/2018-06-01/datafactory.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataFactory/factories/{factoryName}
type FactoryList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Factory `json:"items"`
}

// +kubebuilder:validation:Enum={"2018-06-01"}
type APIVersion string

const APIVersion_Value = APIVersion("2018-06-01")

type Factory_Spec struct {
	AdditionalProperties map[string]v1.JSON `json:"additionalProperties,omitempty"`

	// +kubebuilder:validation:MaxLength=63
	// +kubebuilder:validation:MinLength=3
	// +kubebuilder:validation:Pattern="^[A-Za-z0-9]+(?:-[A-Za-z0-9]+)*$"
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// Encryption: Properties to enable Customer Managed Key for the factory.
	Encryption *EncryptionConfiguration `json:"encryption,omitempty"`

	// GlobalParameters: List of parameters for factory.
	GlobalParameters map[string]GlobalParameterSpecification `json:"globalParameters,omitempty"`

	// Identity: Managed service identity of the factory.
	Identity *FactoryIdentity `json:"identity,omitempty"`

	// Location: The resource location.
	Location *string `json:"location,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// PublicNetworkAccess: Whether or not public network access is allowed for the data factory.
	PublicNetworkAccess *FactoryProperties_PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// PurviewConfiguration: Purview information of the factory.
	PurviewConfiguration *PurviewConfiguration `json:"purviewConfiguration,omitempty"`

	// RepoConfiguration: Git repo information of the factory.
	RepoConfiguration *FactoryRepoConfiguration `json:"repoConfiguration,omitempty"`

	// Tags: The resource tags.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &Factory_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (factory *Factory_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if factory == nil {
		return nil, nil
	}
	result := &Factory_Spec_ARM{}

	// Set property "AdditionalProperties":
	if factory.AdditionalProperties != nil {
		result.AdditionalProperties = make(map[string]v1.JSON, len(factory.AdditionalProperties))
		for key, value := range factory.AdditionalProperties {
			result.AdditionalProperties[key] = *value.DeepCopy()
		}
	}

	// Set property "Identity":
	if factory.Identity != nil {
		identity_ARM, err := (*factory.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*FactoryIdentity_ARM)
		result.Identity = &identity
	}

	// Set property "Location":
	if factory.Location != nil {
		location := *factory.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if factory.Encryption != nil ||
		factory.GlobalParameters != nil ||
		factory.PublicNetworkAccess != nil ||
		factory.PurviewConfiguration != nil ||
		factory.RepoConfiguration != nil {
		result.Properties = &FactoryProperties_ARM{}
	}
	if factory.Encryption != nil {
		encryption_ARM, err := (*factory.Encryption).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		encryption := *encryption_ARM.(*EncryptionConfiguration_ARM)
		result.Properties.Encryption = &encryption
	}
	if factory.GlobalParameters != nil {
		result.Properties.GlobalParameters = make(map[string]GlobalParameterSpecification_ARM, len(factory.GlobalParameters))
		for key, value := range factory.GlobalParameters {
			value_ARM, err := value.ConvertToARM(resolved)
			if err != nil {
				return nil, err
			}
			result.Properties.GlobalParameters[key] = *value_ARM.(*GlobalParameterSpecification_ARM)
		}
	}
	if factory.PublicNetworkAccess != nil {
		publicNetworkAccess := *factory.PublicNetworkAccess
		result.Properties.PublicNetworkAccess = &publicNetworkAccess
	}
	if factory.PurviewConfiguration != nil {
		purviewConfiguration_ARM, err := (*factory.PurviewConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		purviewConfiguration := *purviewConfiguration_ARM.(*PurviewConfiguration_ARM)
		result.Properties.PurviewConfiguration = &purviewConfiguration
	}
	if factory.RepoConfiguration != nil {
		repoConfiguration_ARM, err := (*factory.RepoConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		repoConfiguration := *repoConfiguration_ARM.(*FactoryRepoConfiguration_ARM)
		result.Properties.RepoConfiguration = &repoConfiguration
	}

	// Set property "Tags":
	if factory.Tags != nil {
		result.Tags = make(map[string]string, len(factory.Tags))
		for key, value := range factory.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (factory *Factory_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Factory_Spec_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (factory *Factory_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Factory_Spec_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Factory_Spec_ARM, got %T", armInput)
	}

	// Set property "AdditionalProperties":
	if typedInput.AdditionalProperties != nil {
		factory.AdditionalProperties = make(map[string]v1.JSON, len(typedInput.AdditionalProperties))
		for key, value := range typedInput.AdditionalProperties {
			factory.AdditionalProperties[key] = *value.DeepCopy()
		}
	}

	// Set property "AzureName":
	factory.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "Encryption":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Encryption != nil {
			var encryption1 EncryptionConfiguration
			err := encryption1.PopulateFromARM(owner, *typedInput.Properties.Encryption)
			if err != nil {
				return err
			}
			encryption := encryption1
			factory.Encryption = &encryption
		}
	}

	// Set property "GlobalParameters":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.GlobalParameters != nil {
			factory.GlobalParameters = make(map[string]GlobalParameterSpecification, len(typedInput.Properties.GlobalParameters))
			for key, value := range typedInput.Properties.GlobalParameters {
				var value1 GlobalParameterSpecification
				err := value1.PopulateFromARM(owner, value)
				if err != nil {
					return err
				}
				factory.GlobalParameters[key] = value1
			}
		}
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 FactoryIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		factory.Identity = &identity
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		factory.Location = &location
	}

	// Set property "Owner":
	factory.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "PublicNetworkAccess":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicNetworkAccess != nil {
			publicNetworkAccess := *typedInput.Properties.PublicNetworkAccess
			factory.PublicNetworkAccess = &publicNetworkAccess
		}
	}

	// Set property "PurviewConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PurviewConfiguration != nil {
			var purviewConfiguration1 PurviewConfiguration
			err := purviewConfiguration1.PopulateFromARM(owner, *typedInput.Properties.PurviewConfiguration)
			if err != nil {
				return err
			}
			purviewConfiguration := purviewConfiguration1
			factory.PurviewConfiguration = &purviewConfiguration
		}
	}

	// Set property "RepoConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RepoConfiguration != nil {
			var repoConfiguration1 FactoryRepoConfiguration
			err := repoConfiguration1.PopulateFromARM(owner, *typedInput.Properties.RepoConfiguration)
			if err != nil {
				return err
			}
			repoConfiguration := repoConfiguration1
			factory.RepoConfiguration = &repoConfiguration
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		factory.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			factory.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &Factory_Spec{}

// ConvertSpecFrom populates our Factory_Spec from the provided source
func (factory *Factory_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v20180601s.Factory_Spec)
	if ok {
		// Populate our instance from source
		return factory.AssignProperties_From_Factory_Spec(src)
	}

	// Convert to an intermediate form
	src = &v20180601s.Factory_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = factory.AssignProperties_From_Factory_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our Factory_Spec
func (factory *Factory_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v20180601s.Factory_Spec)
	if ok {
		// Populate destination from our instance
		return factory.AssignProperties_To_Factory_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &v20180601s.Factory_Spec{}
	err := factory.AssignProperties_To_Factory_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_Factory_Spec populates our Factory_Spec from the provided source Factory_Spec
func (factory *Factory_Spec) AssignProperties_From_Factory_Spec(source *v20180601s.Factory_Spec) error {

	// AdditionalProperties
	if source.AdditionalProperties != nil {
		additionalPropertyMap := make(map[string]v1.JSON, len(source.AdditionalProperties))
		for additionalPropertyKey, additionalPropertyValue := range source.AdditionalProperties {
			// Shadow the loop variable to avoid aliasing
			additionalPropertyValue := additionalPropertyValue
			additionalPropertyMap[additionalPropertyKey] = *additionalPropertyValue.DeepCopy()
		}
		factory.AdditionalProperties = additionalPropertyMap
	} else {
		factory.AdditionalProperties = nil
	}

	// AzureName
	factory.AzureName = source.AzureName

	// Encryption
	if source.Encryption != nil {
		var encryption EncryptionConfiguration
		err := encryption.AssignProperties_From_EncryptionConfiguration(source.Encryption)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_EncryptionConfiguration() to populate field Encryption")
		}
		factory.Encryption = &encryption
	} else {
		factory.Encryption = nil
	}

	// GlobalParameters
	if source.GlobalParameters != nil {
		globalParameterMap := make(map[string]GlobalParameterSpecification, len(source.GlobalParameters))
		for globalParameterKey, globalParameterValue := range source.GlobalParameters {
			// Shadow the loop variable to avoid aliasing
			globalParameterValue := globalParameterValue
			var globalParameter GlobalParameterSpecification
			err := globalParameter.AssignProperties_From_GlobalParameterSpecification(&globalParameterValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_GlobalParameterSpecification() to populate field GlobalParameters")
			}
			globalParameterMap[globalParameterKey] = globalParameter
		}
		factory.GlobalParameters = globalParameterMap
	} else {
		factory.GlobalParameters = nil
	}

	// Identity
	if source.Identity != nil {
		var identity FactoryIdentity
		err := identity.AssignProperties_From_FactoryIdentity(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_FactoryIdentity() to populate field Identity")
		}
		factory.Identity = &identity
	} else {
		factory.Identity = nil
	}

	// Location
	factory.Location = genruntime.ClonePointerToString(source.Location)

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		factory.Owner = &owner
	} else {
		factory.Owner = nil
	}

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := FactoryProperties_PublicNetworkAccess(*source.PublicNetworkAccess)
		factory.PublicNetworkAccess = &publicNetworkAccess
	} else {
		factory.PublicNetworkAccess = nil
	}

	// PurviewConfiguration
	if source.PurviewConfiguration != nil {
		var purviewConfiguration PurviewConfiguration
		err := purviewConfiguration.AssignProperties_From_PurviewConfiguration(source.PurviewConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PurviewConfiguration() to populate field PurviewConfiguration")
		}
		factory.PurviewConfiguration = &purviewConfiguration
	} else {
		factory.PurviewConfiguration = nil
	}

	// RepoConfiguration
	if source.RepoConfiguration != nil {
		var repoConfiguration FactoryRepoConfiguration
		err := repoConfiguration.AssignProperties_From_FactoryRepoConfiguration(source.RepoConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_FactoryRepoConfiguration() to populate field RepoConfiguration")
		}
		factory.RepoConfiguration = &repoConfiguration
	} else {
		factory.RepoConfiguration = nil
	}

	// Tags
	factory.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// AssignProperties_To_Factory_Spec populates the provided destination Factory_Spec from our Factory_Spec
func (factory *Factory_Spec) AssignProperties_To_Factory_Spec(destination *v20180601s.Factory_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalProperties
	if factory.AdditionalProperties != nil {
		additionalPropertyMap := make(map[string]v1.JSON, len(factory.AdditionalProperties))
		for additionalPropertyKey, additionalPropertyValue := range factory.AdditionalProperties {
			// Shadow the loop variable to avoid aliasing
			additionalPropertyValue := additionalPropertyValue
			additionalPropertyMap[additionalPropertyKey] = *additionalPropertyValue.DeepCopy()
		}
		destination.AdditionalProperties = additionalPropertyMap
	} else {
		destination.AdditionalProperties = nil
	}

	// AzureName
	destination.AzureName = factory.AzureName

	// Encryption
	if factory.Encryption != nil {
		var encryption v20180601s.EncryptionConfiguration
		err := factory.Encryption.AssignProperties_To_EncryptionConfiguration(&encryption)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_EncryptionConfiguration() to populate field Encryption")
		}
		destination.Encryption = &encryption
	} else {
		destination.Encryption = nil
	}

	// GlobalParameters
	if factory.GlobalParameters != nil {
		globalParameterMap := make(map[string]v20180601s.GlobalParameterSpecification, len(factory.GlobalParameters))
		for globalParameterKey, globalParameterValue := range factory.GlobalParameters {
			// Shadow the loop variable to avoid aliasing
			globalParameterValue := globalParameterValue
			var globalParameter v20180601s.GlobalParameterSpecification
			err := globalParameterValue.AssignProperties_To_GlobalParameterSpecification(&globalParameter)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_GlobalParameterSpecification() to populate field GlobalParameters")
			}
			globalParameterMap[globalParameterKey] = globalParameter
		}
		destination.GlobalParameters = globalParameterMap
	} else {
		destination.GlobalParameters = nil
	}

	// Identity
	if factory.Identity != nil {
		var identity v20180601s.FactoryIdentity
		err := factory.Identity.AssignProperties_To_FactoryIdentity(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_FactoryIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(factory.Location)

	// OriginalVersion
	destination.OriginalVersion = factory.OriginalVersion()

	// Owner
	if factory.Owner != nil {
		owner := factory.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// PublicNetworkAccess
	if factory.PublicNetworkAccess != nil {
		publicNetworkAccess := string(*factory.PublicNetworkAccess)
		destination.PublicNetworkAccess = &publicNetworkAccess
	} else {
		destination.PublicNetworkAccess = nil
	}

	// PurviewConfiguration
	if factory.PurviewConfiguration != nil {
		var purviewConfiguration v20180601s.PurviewConfiguration
		err := factory.PurviewConfiguration.AssignProperties_To_PurviewConfiguration(&purviewConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PurviewConfiguration() to populate field PurviewConfiguration")
		}
		destination.PurviewConfiguration = &purviewConfiguration
	} else {
		destination.PurviewConfiguration = nil
	}

	// RepoConfiguration
	if factory.RepoConfiguration != nil {
		var repoConfiguration v20180601s.FactoryRepoConfiguration
		err := factory.RepoConfiguration.AssignProperties_To_FactoryRepoConfiguration(&repoConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_FactoryRepoConfiguration() to populate field RepoConfiguration")
		}
		destination.RepoConfiguration = &repoConfiguration
	} else {
		destination.RepoConfiguration = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(factory.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Factory_STATUS populates our Factory_Spec from the provided source Factory_STATUS
func (factory *Factory_Spec) Initialize_From_Factory_STATUS(source *Factory_STATUS) error {

	// AdditionalProperties
	if source.AdditionalProperties != nil {
		additionalPropertyMap := make(map[string]v1.JSON, len(source.AdditionalProperties))
		for additionalPropertyKey, additionalPropertyValue := range source.AdditionalProperties {
			// Shadow the loop variable to avoid aliasing
			additionalPropertyValue := additionalPropertyValue
			additionalPropertyMap[additionalPropertyKey] = *additionalPropertyValue.DeepCopy()
		}
		factory.AdditionalProperties = additionalPropertyMap
	} else {
		factory.AdditionalProperties = nil
	}

	// Encryption
	if source.Encryption != nil {
		var encryption EncryptionConfiguration
		err := encryption.Initialize_From_EncryptionConfiguration_STATUS(source.Encryption)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_EncryptionConfiguration_STATUS() to populate field Encryption")
		}
		factory.Encryption = &encryption
	} else {
		factory.Encryption = nil
	}

	// GlobalParameters
	if source.GlobalParameters != nil {
		globalParameterMap := make(map[string]GlobalParameterSpecification, len(source.GlobalParameters))
		for globalParameterKey, globalParameterValue := range source.GlobalParameters {
			// Shadow the loop variable to avoid aliasing
			globalParameterValue := globalParameterValue
			var globalParameter GlobalParameterSpecification
			err := globalParameter.Initialize_From_GlobalParameterSpecification_STATUS(&globalParameterValue)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_GlobalParameterSpecification_STATUS() to populate field GlobalParameters")
			}
			globalParameterMap[globalParameterKey] = globalParameter
		}
		factory.GlobalParameters = globalParameterMap
	} else {
		factory.GlobalParameters = nil
	}

	// Identity
	if source.Identity != nil {
		var identity FactoryIdentity
		err := identity.Initialize_From_FactoryIdentity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_FactoryIdentity_STATUS() to populate field Identity")
		}
		factory.Identity = &identity
	} else {
		factory.Identity = nil
	}

	// Location
	factory.Location = genruntime.ClonePointerToString(source.Location)

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := FactoryProperties_PublicNetworkAccess(*source.PublicNetworkAccess)
		factory.PublicNetworkAccess = &publicNetworkAccess
	} else {
		factory.PublicNetworkAccess = nil
	}

	// PurviewConfiguration
	if source.PurviewConfiguration != nil {
		var purviewConfiguration PurviewConfiguration
		err := purviewConfiguration.Initialize_From_PurviewConfiguration_STATUS(source.PurviewConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_PurviewConfiguration_STATUS() to populate field PurviewConfiguration")
		}
		factory.PurviewConfiguration = &purviewConfiguration
	} else {
		factory.PurviewConfiguration = nil
	}

	// RepoConfiguration
	if source.RepoConfiguration != nil {
		var repoConfiguration FactoryRepoConfiguration
		err := repoConfiguration.Initialize_From_FactoryRepoConfiguration_STATUS(source.RepoConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_FactoryRepoConfiguration_STATUS() to populate field RepoConfiguration")
		}
		factory.RepoConfiguration = &repoConfiguration
	} else {
		factory.RepoConfiguration = nil
	}

	// Tags
	factory.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (factory *Factory_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (factory *Factory_Spec) SetAzureName(azureName string) { factory.AzureName = azureName }

// Factory resource type.
type Factory_STATUS struct {
	AdditionalProperties map[string]v1.JSON `json:"additionalProperties,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// CreateTime: Time the factory was created in ISO8601 format.
	CreateTime *string `json:"createTime,omitempty"`

	// ETag: Etag identifies change in the resource.
	ETag *string `json:"eTag,omitempty"`

	// Encryption: Properties to enable Customer Managed Key for the factory.
	Encryption *EncryptionConfiguration_STATUS `json:"encryption,omitempty"`

	// GlobalParameters: List of parameters for factory.
	GlobalParameters map[string]GlobalParameterSpecification_STATUS `json:"globalParameters,omitempty"`

	// Id: The resource identifier.
	Id *string `json:"id,omitempty"`

	// Identity: Managed service identity of the factory.
	Identity *FactoryIdentity_STATUS `json:"identity,omitempty"`

	// Location: The resource location.
	Location *string `json:"location,omitempty"`

	// Name: The resource name.
	Name *string `json:"name,omitempty"`

	// ProvisioningState: Factory provisioning state, example Succeeded.
	ProvisioningState *string `json:"provisioningState,omitempty"`

	// PublicNetworkAccess: Whether or not public network access is allowed for the data factory.
	PublicNetworkAccess *FactoryProperties_PublicNetworkAccess_STATUS `json:"publicNetworkAccess,omitempty"`

	// PurviewConfiguration: Purview information of the factory.
	PurviewConfiguration *PurviewConfiguration_STATUS `json:"purviewConfiguration,omitempty"`

	// RepoConfiguration: Git repo information of the factory.
	RepoConfiguration *FactoryRepoConfiguration_STATUS `json:"repoConfiguration,omitempty"`

	// Tags: The resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: The resource type.
	Type *string `json:"type,omitempty"`

	// Version: Version of the factory.
	Version *string `json:"version,omitempty"`
}

var _ genruntime.ConvertibleStatus = &Factory_STATUS{}

// ConvertStatusFrom populates our Factory_STATUS from the provided source
func (factory *Factory_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v20180601s.Factory_STATUS)
	if ok {
		// Populate our instance from source
		return factory.AssignProperties_From_Factory_STATUS(src)
	}

	// Convert to an intermediate form
	src = &v20180601s.Factory_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = factory.AssignProperties_From_Factory_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our Factory_STATUS
func (factory *Factory_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v20180601s.Factory_STATUS)
	if ok {
		// Populate destination from our instance
		return factory.AssignProperties_To_Factory_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &v20180601s.Factory_STATUS{}
	err := factory.AssignProperties_To_Factory_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &Factory_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (factory *Factory_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Factory_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (factory *Factory_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Factory_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Factory_STATUS_ARM, got %T", armInput)
	}

	// Set property "AdditionalProperties":
	if typedInput.AdditionalProperties != nil {
		factory.AdditionalProperties = make(map[string]v1.JSON, len(typedInput.AdditionalProperties))
		for key, value := range typedInput.AdditionalProperties {
			factory.AdditionalProperties[key] = *value.DeepCopy()
		}
	}

	// no assignment for property "Conditions"

	// Set property "CreateTime":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CreateTime != nil {
			createTime := *typedInput.Properties.CreateTime
			factory.CreateTime = &createTime
		}
	}

	// Set property "ETag":
	if typedInput.ETag != nil {
		eTag := *typedInput.ETag
		factory.ETag = &eTag
	}

	// Set property "Encryption":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Encryption != nil {
			var encryption1 EncryptionConfiguration_STATUS
			err := encryption1.PopulateFromARM(owner, *typedInput.Properties.Encryption)
			if err != nil {
				return err
			}
			encryption := encryption1
			factory.Encryption = &encryption
		}
	}

	// Set property "GlobalParameters":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.GlobalParameters != nil {
			factory.GlobalParameters = make(map[string]GlobalParameterSpecification_STATUS, len(typedInput.Properties.GlobalParameters))
			for key, value := range typedInput.Properties.GlobalParameters {
				var value1 GlobalParameterSpecification_STATUS
				err := value1.PopulateFromARM(owner, value)
				if err != nil {
					return err
				}
				factory.GlobalParameters[key] = value1
			}
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		factory.Id = &id
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 FactoryIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		factory.Identity = &identity
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		factory.Location = &location
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		factory.Name = &name
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			factory.ProvisioningState = &provisioningState
		}
	}

	// Set property "PublicNetworkAccess":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicNetworkAccess != nil {
			publicNetworkAccess := *typedInput.Properties.PublicNetworkAccess
			factory.PublicNetworkAccess = &publicNetworkAccess
		}
	}

	// Set property "PurviewConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PurviewConfiguration != nil {
			var purviewConfiguration1 PurviewConfiguration_STATUS
			err := purviewConfiguration1.PopulateFromARM(owner, *typedInput.Properties.PurviewConfiguration)
			if err != nil {
				return err
			}
			purviewConfiguration := purviewConfiguration1
			factory.PurviewConfiguration = &purviewConfiguration
		}
	}

	// Set property "RepoConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RepoConfiguration != nil {
			var repoConfiguration1 FactoryRepoConfiguration_STATUS
			err := repoConfiguration1.PopulateFromARM(owner, *typedInput.Properties.RepoConfiguration)
			if err != nil {
				return err
			}
			repoConfiguration := repoConfiguration1
			factory.RepoConfiguration = &repoConfiguration
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		factory.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			factory.Tags[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		factory.Type = &typeVar
	}

	// Set property "Version":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Version != nil {
			version := *typedInput.Properties.Version
			factory.Version = &version
		}
	}

	// No error
	return nil
}

// AssignProperties_From_Factory_STATUS populates our Factory_STATUS from the provided source Factory_STATUS
func (factory *Factory_STATUS) AssignProperties_From_Factory_STATUS(source *v20180601s.Factory_STATUS) error {

	// AdditionalProperties
	if source.AdditionalProperties != nil {
		additionalPropertyMap := make(map[string]v1.JSON, len(source.AdditionalProperties))
		for additionalPropertyKey, additionalPropertyValue := range source.AdditionalProperties {
			// Shadow the loop variable to avoid aliasing
			additionalPropertyValue := additionalPropertyValue
			additionalPropertyMap[additionalPropertyKey] = *additionalPropertyValue.DeepCopy()
		}
		factory.AdditionalProperties = additionalPropertyMap
	} else {
		factory.AdditionalProperties = nil
	}

	// Conditions
	factory.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// CreateTime
	factory.CreateTime = genruntime.ClonePointerToString(source.CreateTime)

	// ETag
	factory.ETag = genruntime.ClonePointerToString(source.ETag)

	// Encryption
	if source.Encryption != nil {
		var encryption EncryptionConfiguration_STATUS
		err := encryption.AssignProperties_From_EncryptionConfiguration_STATUS(source.Encryption)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_EncryptionConfiguration_STATUS() to populate field Encryption")
		}
		factory.Encryption = &encryption
	} else {
		factory.Encryption = nil
	}

	// GlobalParameters
	if source.GlobalParameters != nil {
		globalParameterMap := make(map[string]GlobalParameterSpecification_STATUS, len(source.GlobalParameters))
		for globalParameterKey, globalParameterValue := range source.GlobalParameters {
			// Shadow the loop variable to avoid aliasing
			globalParameterValue := globalParameterValue
			var globalParameter GlobalParameterSpecification_STATUS
			err := globalParameter.AssignProperties_From_GlobalParameterSpecification_STATUS(&globalParameterValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_GlobalParameterSpecification_STATUS() to populate field GlobalParameters")
			}
			globalParameterMap[globalParameterKey] = globalParameter
		}
		factory.GlobalParameters = globalParameterMap
	} else {
		factory.GlobalParameters = nil
	}

	// Id
	factory.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity FactoryIdentity_STATUS
		err := identity.AssignProperties_From_FactoryIdentity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_FactoryIdentity_STATUS() to populate field Identity")
		}
		factory.Identity = &identity
	} else {
		factory.Identity = nil
	}

	// Location
	factory.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	factory.Name = genruntime.ClonePointerToString(source.Name)

	// ProvisioningState
	factory.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := FactoryProperties_PublicNetworkAccess_STATUS(*source.PublicNetworkAccess)
		factory.PublicNetworkAccess = &publicNetworkAccess
	} else {
		factory.PublicNetworkAccess = nil
	}

	// PurviewConfiguration
	if source.PurviewConfiguration != nil {
		var purviewConfiguration PurviewConfiguration_STATUS
		err := purviewConfiguration.AssignProperties_From_PurviewConfiguration_STATUS(source.PurviewConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PurviewConfiguration_STATUS() to populate field PurviewConfiguration")
		}
		factory.PurviewConfiguration = &purviewConfiguration
	} else {
		factory.PurviewConfiguration = nil
	}

	// RepoConfiguration
	if source.RepoConfiguration != nil {
		var repoConfiguration FactoryRepoConfiguration_STATUS
		err := repoConfiguration.AssignProperties_From_FactoryRepoConfiguration_STATUS(source.RepoConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_FactoryRepoConfiguration_STATUS() to populate field RepoConfiguration")
		}
		factory.RepoConfiguration = &repoConfiguration
	} else {
		factory.RepoConfiguration = nil
	}

	// Tags
	factory.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	factory.Type = genruntime.ClonePointerToString(source.Type)

	// Version
	factory.Version = genruntime.ClonePointerToString(source.Version)

	// No error
	return nil
}

// AssignProperties_To_Factory_STATUS populates the provided destination Factory_STATUS from our Factory_STATUS
func (factory *Factory_STATUS) AssignProperties_To_Factory_STATUS(destination *v20180601s.Factory_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalProperties
	if factory.AdditionalProperties != nil {
		additionalPropertyMap := make(map[string]v1.JSON, len(factory.AdditionalProperties))
		for additionalPropertyKey, additionalPropertyValue := range factory.AdditionalProperties {
			// Shadow the loop variable to avoid aliasing
			additionalPropertyValue := additionalPropertyValue
			additionalPropertyMap[additionalPropertyKey] = *additionalPropertyValue.DeepCopy()
		}
		destination.AdditionalProperties = additionalPropertyMap
	} else {
		destination.AdditionalProperties = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(factory.Conditions)

	// CreateTime
	destination.CreateTime = genruntime.ClonePointerToString(factory.CreateTime)

	// ETag
	destination.ETag = genruntime.ClonePointerToString(factory.ETag)

	// Encryption
	if factory.Encryption != nil {
		var encryption v20180601s.EncryptionConfiguration_STATUS
		err := factory.Encryption.AssignProperties_To_EncryptionConfiguration_STATUS(&encryption)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_EncryptionConfiguration_STATUS() to populate field Encryption")
		}
		destination.Encryption = &encryption
	} else {
		destination.Encryption = nil
	}

	// GlobalParameters
	if factory.GlobalParameters != nil {
		globalParameterMap := make(map[string]v20180601s.GlobalParameterSpecification_STATUS, len(factory.GlobalParameters))
		for globalParameterKey, globalParameterValue := range factory.GlobalParameters {
			// Shadow the loop variable to avoid aliasing
			globalParameterValue := globalParameterValue
			var globalParameter v20180601s.GlobalParameterSpecification_STATUS
			err := globalParameterValue.AssignProperties_To_GlobalParameterSpecification_STATUS(&globalParameter)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_GlobalParameterSpecification_STATUS() to populate field GlobalParameters")
			}
			globalParameterMap[globalParameterKey] = globalParameter
		}
		destination.GlobalParameters = globalParameterMap
	} else {
		destination.GlobalParameters = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(factory.Id)

	// Identity
	if factory.Identity != nil {
		var identity v20180601s.FactoryIdentity_STATUS
		err := factory.Identity.AssignProperties_To_FactoryIdentity_STATUS(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_FactoryIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(factory.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(factory.Name)

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(factory.ProvisioningState)

	// PublicNetworkAccess
	if factory.PublicNetworkAccess != nil {
		publicNetworkAccess := string(*factory.PublicNetworkAccess)
		destination.PublicNetworkAccess = &publicNetworkAccess
	} else {
		destination.PublicNetworkAccess = nil
	}

	// PurviewConfiguration
	if factory.PurviewConfiguration != nil {
		var purviewConfiguration v20180601s.PurviewConfiguration_STATUS
		err := factory.PurviewConfiguration.AssignProperties_To_PurviewConfiguration_STATUS(&purviewConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PurviewConfiguration_STATUS() to populate field PurviewConfiguration")
		}
		destination.PurviewConfiguration = &purviewConfiguration
	} else {
		destination.PurviewConfiguration = nil
	}

	// RepoConfiguration
	if factory.RepoConfiguration != nil {
		var repoConfiguration v20180601s.FactoryRepoConfiguration_STATUS
		err := factory.RepoConfiguration.AssignProperties_To_FactoryRepoConfiguration_STATUS(&repoConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_FactoryRepoConfiguration_STATUS() to populate field RepoConfiguration")
		}
		destination.RepoConfiguration = &repoConfiguration
	} else {
		destination.RepoConfiguration = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(factory.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(factory.Type)

	// Version
	destination.Version = genruntime.ClonePointerToString(factory.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Definition of CMK for the factory.
type EncryptionConfiguration struct {
	// Identity: User assigned identity to use to authenticate to customer's key vault. If not provided Managed Service
	// Identity will be used.
	Identity *CMKIdentityDefinition `json:"identity,omitempty"`

	// +kubebuilder:validation:Required
	// KeyName: The name of the key in Azure Key Vault to use as Customer Managed Key.
	KeyName *string `json:"keyName,omitempty"`

	// KeyVersion: The version of the key used for CMK. If not provided, latest version will be used.
	KeyVersion *string `json:"keyVersion,omitempty"`

	// +kubebuilder:validation:Required
	// VaultBaseUrl: The url of the Azure Key Vault used for CMK.
	VaultBaseUrl *string `json:"vaultBaseUrl,omitempty"`
}

var _ genruntime.ARMTransformer = &EncryptionConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *EncryptionConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &EncryptionConfiguration_ARM{}

	// Set property "Identity":
	if configuration.Identity != nil {
		identity_ARM, err := (*configuration.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*CMKIdentityDefinition_ARM)
		result.Identity = &identity
	}

	// Set property "KeyName":
	if configuration.KeyName != nil {
		keyName := *configuration.KeyName
		result.KeyName = &keyName
	}

	// Set property "KeyVersion":
	if configuration.KeyVersion != nil {
		keyVersion := *configuration.KeyVersion
		result.KeyVersion = &keyVersion
	}

	// Set property "VaultBaseUrl":
	if configuration.VaultBaseUrl != nil {
		vaultBaseUrl := *configuration.VaultBaseUrl
		result.VaultBaseUrl = &vaultBaseUrl
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *EncryptionConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &EncryptionConfiguration_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *EncryptionConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(EncryptionConfiguration_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected EncryptionConfiguration_ARM, got %T", armInput)
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 CMKIdentityDefinition
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		configuration.Identity = &identity
	}

	// Set property "KeyName":
	if typedInput.KeyName != nil {
		keyName := *typedInput.KeyName
		configuration.KeyName = &keyName
	}

	// Set property "KeyVersion":
	if typedInput.KeyVersion != nil {
		keyVersion := *typedInput.KeyVersion
		configuration.KeyVersion = &keyVersion
	}

	// Set property "VaultBaseUrl":
	if typedInput.VaultBaseUrl != nil {
		vaultBaseUrl := *typedInput.VaultBaseUrl
		configuration.VaultBaseUrl = &vaultBaseUrl
	}

	// No error
	return nil
}

// AssignProperties_From_EncryptionConfiguration populates our EncryptionConfiguration from the provided source EncryptionConfiguration
func (configuration *EncryptionConfiguration) AssignProperties_From_EncryptionConfiguration(source *v20180601s.EncryptionConfiguration) error {

	// Identity
	if source.Identity != nil {
		var identity CMKIdentityDefinition
		err := identity.AssignProperties_From_CMKIdentityDefinition(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CMKIdentityDefinition() to populate field Identity")
		}
		configuration.Identity = &identity
	} else {
		configuration.Identity = nil
	}

	// KeyName
	configuration.KeyName = genruntime.ClonePointerToString(source.KeyName)

	// KeyVersion
	configuration.KeyVersion = genruntime.ClonePointerToString(source.KeyVersion)

	// VaultBaseUrl
	configuration.VaultBaseUrl = genruntime.ClonePointerToString(source.VaultBaseUrl)

	// No error
	return nil
}

// AssignProperties_To_EncryptionConfiguration populates the provided destination EncryptionConfiguration from our EncryptionConfiguration
func (configuration *EncryptionConfiguration) AssignProperties_To_EncryptionConfiguration(destination *v20180601s.EncryptionConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Identity
	if configuration.Identity != nil {
		var identity v20180601s.CMKIdentityDefinition
		err := configuration.Identity.AssignProperties_To_CMKIdentityDefinition(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CMKIdentityDefinition() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// KeyName
	destination.KeyName = genruntime.ClonePointerToString(configuration.KeyName)

	// KeyVersion
	destination.KeyVersion = genruntime.ClonePointerToString(configuration.KeyVersion)

	// VaultBaseUrl
	destination.VaultBaseUrl = genruntime.ClonePointerToString(configuration.VaultBaseUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_EncryptionConfiguration_STATUS populates our EncryptionConfiguration from the provided source EncryptionConfiguration_STATUS
func (configuration *EncryptionConfiguration) Initialize_From_EncryptionConfiguration_STATUS(source *EncryptionConfiguration_STATUS) error {

	// Identity
	if source.Identity != nil {
		var identity CMKIdentityDefinition
		err := identity.Initialize_From_CMKIdentityDefinition_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_CMKIdentityDefinition_STATUS() to populate field Identity")
		}
		configuration.Identity = &identity
	} else {
		configuration.Identity = nil
	}

	// KeyName
	configuration.KeyName = genruntime.ClonePointerToString(source.KeyName)

	// KeyVersion
	configuration.KeyVersion = genruntime.ClonePointerToString(source.KeyVersion)

	// VaultBaseUrl
	configuration.VaultBaseUrl = genruntime.ClonePointerToString(source.VaultBaseUrl)

	// No error
	return nil
}

// Definition of CMK for the factory.
type EncryptionConfiguration_STATUS struct {
	// Identity: User assigned identity to use to authenticate to customer's key vault. If not provided Managed Service
	// Identity will be used.
	Identity *CMKIdentityDefinition_STATUS `json:"identity,omitempty"`

	// KeyName: The name of the key in Azure Key Vault to use as Customer Managed Key.
	KeyName *string `json:"keyName,omitempty"`

	// KeyVersion: The version of the key used for CMK. If not provided, latest version will be used.
	KeyVersion *string `json:"keyVersion,omitempty"`

	// VaultBaseUrl: The url of the Azure Key Vault used for CMK.
	VaultBaseUrl *string `json:"vaultBaseUrl,omitempty"`
}

var _ genruntime.FromARMConverter = &EncryptionConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *EncryptionConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &EncryptionConfiguration_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *EncryptionConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(EncryptionConfiguration_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected EncryptionConfiguration_STATUS_ARM, got %T", armInput)
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 CMKIdentityDefinition_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		configuration.Identity = &identity
	}

	// Set property "KeyName":
	if typedInput.KeyName != nil {
		keyName := *typedInput.KeyName
		configuration.KeyName = &keyName
	}

	// Set property "KeyVersion":
	if typedInput.KeyVersion != nil {
		keyVersion := *typedInput.KeyVersion
		configuration.KeyVersion = &keyVersion
	}

	// Set property "VaultBaseUrl":
	if typedInput.VaultBaseUrl != nil {
		vaultBaseUrl := *typedInput.VaultBaseUrl
		configuration.VaultBaseUrl = &vaultBaseUrl
	}

	// No error
	return nil
}

// AssignProperties_From_EncryptionConfiguration_STATUS populates our EncryptionConfiguration_STATUS from the provided source EncryptionConfiguration_STATUS
func (configuration *EncryptionConfiguration_STATUS) AssignProperties_From_EncryptionConfiguration_STATUS(source *v20180601s.EncryptionConfiguration_STATUS) error {

	// Identity
	if source.Identity != nil {
		var identity CMKIdentityDefinition_STATUS
		err := identity.AssignProperties_From_CMKIdentityDefinition_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CMKIdentityDefinition_STATUS() to populate field Identity")
		}
		configuration.Identity = &identity
	} else {
		configuration.Identity = nil
	}

	// KeyName
	configuration.KeyName = genruntime.ClonePointerToString(source.KeyName)

	// KeyVersion
	configuration.KeyVersion = genruntime.ClonePointerToString(source.KeyVersion)

	// VaultBaseUrl
	configuration.VaultBaseUrl = genruntime.ClonePointerToString(source.VaultBaseUrl)

	// No error
	return nil
}

// AssignProperties_To_EncryptionConfiguration_STATUS populates the provided destination EncryptionConfiguration_STATUS from our EncryptionConfiguration_STATUS
func (configuration *EncryptionConfiguration_STATUS) AssignProperties_To_EncryptionConfiguration_STATUS(destination *v20180601s.EncryptionConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Identity
	if configuration.Identity != nil {
		var identity v20180601s.CMKIdentityDefinition_STATUS
		err := configuration.Identity.AssignProperties_To_CMKIdentityDefinition_STATUS(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CMKIdentityDefinition_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// KeyName
	destination.KeyName = genruntime.ClonePointerToString(configuration.KeyName)

	// KeyVersion
	destination.KeyVersion = genruntime.ClonePointerToString(configuration.KeyVersion)

	// VaultBaseUrl
	destination.VaultBaseUrl = genruntime.ClonePointerToString(configuration.VaultBaseUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Identity properties of the factory resource.
type FactoryIdentity struct {
	// +kubebuilder:validation:Required
	// Type: The identity type.
	Type *FactoryIdentity_Type `json:"type,omitempty"`

	// UserAssignedIdentities: List of user assigned identities for the factory.
	UserAssignedIdentities []UserAssignedIdentityDetails `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.ARMTransformer = &FactoryIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *FactoryIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &FactoryIdentity_ARM{}

	// Set property "Type":
	if identity.Type != nil {
		typeVar := *identity.Type
		result.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	result.UserAssignedIdentities = make(map[string]UserAssignedIdentityDetails_ARM, len(identity.UserAssignedIdentities))
	for _, ident := range identity.UserAssignedIdentities {
		identARMID, err := resolved.ResolvedReferences.Lookup(ident.Reference)
		if err != nil {
			return nil, err
		}
		key := identARMID
		result.UserAssignedIdentities[key] = UserAssignedIdentityDetails_ARM{}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *FactoryIdentity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &FactoryIdentity_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *FactoryIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(FactoryIdentity_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected FactoryIdentity_ARM, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		identity.Type = &typeVar
	}

	// no assignment for property "UserAssignedIdentities"

	// No error
	return nil
}

// AssignProperties_From_FactoryIdentity populates our FactoryIdentity from the provided source FactoryIdentity
func (identity *FactoryIdentity) AssignProperties_From_FactoryIdentity(source *v20180601s.FactoryIdentity) error {

	// Type
	if source.Type != nil {
		typeVar := FactoryIdentity_Type(*source.Type)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, len(source.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity UserAssignedIdentityDetails
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentityDetails(&userAssignedIdentityItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FactoryIdentity populates the provided destination FactoryIdentity from our FactoryIdentity
func (identity *FactoryIdentity) AssignProperties_To_FactoryIdentity(destination *v20180601s.FactoryIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]v20180601s.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity v20180601s.UserAssignedIdentityDetails
			err := userAssignedIdentityItem.AssignProperties_To_UserAssignedIdentityDetails(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityList
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_FactoryIdentity_STATUS populates our FactoryIdentity from the provided source FactoryIdentity_STATUS
func (identity *FactoryIdentity) Initialize_From_FactoryIdentity_STATUS(source *FactoryIdentity_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := FactoryIdentity_Type(*source.Type)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, 0, len(source.UserAssignedIdentities))
		for userAssignedIdentitiesKey := range source.UserAssignedIdentities {
			userAssignedIdentitiesRef := genruntime.CreateResourceReferenceFromARMID(userAssignedIdentitiesKey)
			userAssignedIdentityList = append(userAssignedIdentityList, UserAssignedIdentityDetails{Reference: userAssignedIdentitiesRef})
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// Identity properties of the factory resource.
type FactoryIdentity_STATUS struct {
	// PrincipalId: The principal id of the identity.
	PrincipalId *string `json:"principalId,omitempty"`

	// TenantId: The client tenant id of the identity.
	TenantId *string `json:"tenantId,omitempty"`

	// Type: The identity type.
	Type *FactoryIdentity_Type_STATUS `json:"type,omitempty"`

	// UserAssignedIdentities: List of user assigned identities for the factory.
	UserAssignedIdentities map[string]v1.JSON `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.FromARMConverter = &FactoryIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *FactoryIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &FactoryIdentity_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *FactoryIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(FactoryIdentity_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected FactoryIdentity_STATUS_ARM, got %T", armInput)
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		identity.TenantId = &tenantId
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		identity.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	if typedInput.UserAssignedIdentities != nil {
		identity.UserAssignedIdentities = make(map[string]v1.JSON, len(typedInput.UserAssignedIdentities))
		for key, value := range typedInput.UserAssignedIdentities {
			identity.UserAssignedIdentities[key] = *value.DeepCopy()
		}
	}

	// No error
	return nil
}

// AssignProperties_From_FactoryIdentity_STATUS populates our FactoryIdentity_STATUS from the provided source FactoryIdentity_STATUS
func (identity *FactoryIdentity_STATUS) AssignProperties_From_FactoryIdentity_STATUS(source *v20180601s.FactoryIdentity_STATUS) error {

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := FactoryIdentity_Type_STATUS(*source.Type)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]v1.JSON, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			userAssignedIdentityMap[userAssignedIdentityKey] = *userAssignedIdentityValue.DeepCopy()
		}
		identity.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FactoryIdentity_STATUS populates the provided destination FactoryIdentity_STATUS from our FactoryIdentity_STATUS
func (identity *FactoryIdentity_STATUS) AssignProperties_To_FactoryIdentity_STATUS(destination *v20180601s.FactoryIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]v1.JSON, len(identity.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			userAssignedIdentityMap[userAssignedIdentityKey] = *userAssignedIdentityValue.DeepCopy()
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type FactoryProperties_PublicNetworkAccess string

const (
	FactoryProperties_PublicNetworkAccess_Disabled = FactoryProperties_PublicNetworkAccess("Disabled")
	FactoryProperties_PublicNetworkAccess_Enabled  = FactoryProperties_PublicNetworkAccess("Enabled")
)

type FactoryProperties_PublicNetworkAccess_STATUS string

const (
	FactoryProperties_PublicNetworkAccess_STATUS_Disabled = FactoryProperties_PublicNetworkAccess_STATUS("Disabled")
	FactoryProperties_PublicNetworkAccess_STATUS_Enabled  = FactoryProperties_PublicNetworkAccess_STATUS("Enabled")
)

type FactoryRepoConfiguration struct {
	// FactoryGitHub: Mutually exclusive with all other properties
	FactoryGitHub *FactoryGitHubConfiguration `json:"factoryGitHubConfiguration,omitempty"`

	// FactoryVSTS: Mutually exclusive with all other properties
	FactoryVSTS *FactoryVSTSConfiguration `json:"factoryVSTSConfiguration,omitempty"`
}

var _ genruntime.ARMTransformer = &FactoryRepoConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *FactoryRepoConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &FactoryRepoConfiguration_ARM{}

	// Set property "FactoryGitHub":
	if configuration.FactoryGitHub != nil {
		factoryGitHub_ARM, err := (*configuration.FactoryGitHub).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		factoryGitHub := *factoryGitHub_ARM.(*FactoryGitHubConfiguration_ARM)
		result.FactoryGitHub = &factoryGitHub
	}

	// Set property "FactoryVSTS":
	if configuration.FactoryVSTS != nil {
		factoryVSTS_ARM, err := (*configuration.FactoryVSTS).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		factoryVSTS := *factoryVSTS_ARM.(*FactoryVSTSConfiguration_ARM)
		result.FactoryVSTS = &factoryVSTS
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *FactoryRepoConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &FactoryRepoConfiguration_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *FactoryRepoConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(FactoryRepoConfiguration_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected FactoryRepoConfiguration_ARM, got %T", armInput)
	}

	// Set property "FactoryGitHub":
	if typedInput.FactoryGitHub != nil {
		var factoryGitHub1 FactoryGitHubConfiguration
		err := factoryGitHub1.PopulateFromARM(owner, *typedInput.FactoryGitHub)
		if err != nil {
			return err
		}
		factoryGitHub := factoryGitHub1
		configuration.FactoryGitHub = &factoryGitHub
	}

	// Set property "FactoryVSTS":
	if typedInput.FactoryVSTS != nil {
		var factoryVSTS1 FactoryVSTSConfiguration
		err := factoryVSTS1.PopulateFromARM(owner, *typedInput.FactoryVSTS)
		if err != nil {
			return err
		}
		factoryVSTS := factoryVSTS1
		configuration.FactoryVSTS = &factoryVSTS
	}

	// No error
	return nil
}

// AssignProperties_From_FactoryRepoConfiguration populates our FactoryRepoConfiguration from the provided source FactoryRepoConfiguration
func (configuration *FactoryRepoConfiguration) AssignProperties_From_FactoryRepoConfiguration(source *v20180601s.FactoryRepoConfiguration) error {

	// FactoryGitHub
	if source.FactoryGitHub != nil {
		var factoryGitHub FactoryGitHubConfiguration
		err := factoryGitHub.AssignProperties_From_FactoryGitHubConfiguration(source.FactoryGitHub)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_FactoryGitHubConfiguration() to populate field FactoryGitHub")
		}
		configuration.FactoryGitHub = &factoryGitHub
	} else {
		configuration.FactoryGitHub = nil
	}

	// FactoryVSTS
	if source.FactoryVSTS != nil {
		var factoryVSTS FactoryVSTSConfiguration
		err := factoryVSTS.AssignProperties_From_FactoryVSTSConfiguration(source.FactoryVSTS)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_FactoryVSTSConfiguration() to populate field FactoryVSTS")
		}
		configuration.FactoryVSTS = &factoryVSTS
	} else {
		configuration.FactoryVSTS = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FactoryRepoConfiguration populates the provided destination FactoryRepoConfiguration from our FactoryRepoConfiguration
func (configuration *FactoryRepoConfiguration) AssignProperties_To_FactoryRepoConfiguration(destination *v20180601s.FactoryRepoConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// FactoryGitHub
	if configuration.FactoryGitHub != nil {
		var factoryGitHub v20180601s.FactoryGitHubConfiguration
		err := configuration.FactoryGitHub.AssignProperties_To_FactoryGitHubConfiguration(&factoryGitHub)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_FactoryGitHubConfiguration() to populate field FactoryGitHub")
		}
		destination.FactoryGitHub = &factoryGitHub
	} else {
		destination.FactoryGitHub = nil
	}

	// FactoryVSTS
	if configuration.FactoryVSTS != nil {
		var factoryVSTS v20180601s.FactoryVSTSConfiguration
		err := configuration.FactoryVSTS.AssignProperties_To_FactoryVSTSConfiguration(&factoryVSTS)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_FactoryVSTSConfiguration() to populate field FactoryVSTS")
		}
		destination.FactoryVSTS = &factoryVSTS
	} else {
		destination.FactoryVSTS = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_FactoryRepoConfiguration_STATUS populates our FactoryRepoConfiguration from the provided source FactoryRepoConfiguration_STATUS
func (configuration *FactoryRepoConfiguration) Initialize_From_FactoryRepoConfiguration_STATUS(source *FactoryRepoConfiguration_STATUS) error {

	// FactoryGitHub
	if source.FactoryGitHub != nil {
		var factoryGitHub FactoryGitHubConfiguration
		err := factoryGitHub.Initialize_From_FactoryGitHubConfiguration_STATUS(source.FactoryGitHub)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_FactoryGitHubConfiguration_STATUS() to populate field FactoryGitHub")
		}
		configuration.FactoryGitHub = &factoryGitHub
	} else {
		configuration.FactoryGitHub = nil
	}

	// FactoryVSTS
	if source.FactoryVSTS != nil {
		var factoryVSTS FactoryVSTSConfiguration
		err := factoryVSTS.Initialize_From_FactoryVSTSConfiguration_STATUS(source.FactoryVSTS)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_FactoryVSTSConfiguration_STATUS() to populate field FactoryVSTS")
		}
		configuration.FactoryVSTS = &factoryVSTS
	} else {
		configuration.FactoryVSTS = nil
	}

	// No error
	return nil
}

type FactoryRepoConfiguration_STATUS struct {
	// FactoryGitHub: Mutually exclusive with all other properties
	FactoryGitHub *FactoryGitHubConfiguration_STATUS `json:"factoryGitHubConfiguration,omitempty"`

	// FactoryVSTS: Mutually exclusive with all other properties
	FactoryVSTS *FactoryVSTSConfiguration_STATUS `json:"factoryVSTSConfiguration,omitempty"`
}

var _ genruntime.FromARMConverter = &FactoryRepoConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *FactoryRepoConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &FactoryRepoConfiguration_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *FactoryRepoConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(FactoryRepoConfiguration_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected FactoryRepoConfiguration_STATUS_ARM, got %T", armInput)
	}

	// Set property "FactoryGitHub":
	if typedInput.FactoryGitHub != nil {
		var factoryGitHub1 FactoryGitHubConfiguration_STATUS
		err := factoryGitHub1.PopulateFromARM(owner, *typedInput.FactoryGitHub)
		if err != nil {
			return err
		}
		factoryGitHub := factoryGitHub1
		configuration.FactoryGitHub = &factoryGitHub
	}

	// Set property "FactoryVSTS":
	if typedInput.FactoryVSTS != nil {
		var factoryVSTS1 FactoryVSTSConfiguration_STATUS
		err := factoryVSTS1.PopulateFromARM(owner, *typedInput.FactoryVSTS)
		if err != nil {
			return err
		}
		factoryVSTS := factoryVSTS1
		configuration.FactoryVSTS = &factoryVSTS
	}

	// No error
	return nil
}

// AssignProperties_From_FactoryRepoConfiguration_STATUS populates our FactoryRepoConfiguration_STATUS from the provided source FactoryRepoConfiguration_STATUS
func (configuration *FactoryRepoConfiguration_STATUS) AssignProperties_From_FactoryRepoConfiguration_STATUS(source *v20180601s.FactoryRepoConfiguration_STATUS) error {

	// FactoryGitHub
	if source.FactoryGitHub != nil {
		var factoryGitHub FactoryGitHubConfiguration_STATUS
		err := factoryGitHub.AssignProperties_From_FactoryGitHubConfiguration_STATUS(source.FactoryGitHub)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_FactoryGitHubConfiguration_STATUS() to populate field FactoryGitHub")
		}
		configuration.FactoryGitHub = &factoryGitHub
	} else {
		configuration.FactoryGitHub = nil
	}

	// FactoryVSTS
	if source.FactoryVSTS != nil {
		var factoryVSTS FactoryVSTSConfiguration_STATUS
		err := factoryVSTS.AssignProperties_From_FactoryVSTSConfiguration_STATUS(source.FactoryVSTS)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_FactoryVSTSConfiguration_STATUS() to populate field FactoryVSTS")
		}
		configuration.FactoryVSTS = &factoryVSTS
	} else {
		configuration.FactoryVSTS = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FactoryRepoConfiguration_STATUS populates the provided destination FactoryRepoConfiguration_STATUS from our FactoryRepoConfiguration_STATUS
func (configuration *FactoryRepoConfiguration_STATUS) AssignProperties_To_FactoryRepoConfiguration_STATUS(destination *v20180601s.FactoryRepoConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// FactoryGitHub
	if configuration.FactoryGitHub != nil {
		var factoryGitHub v20180601s.FactoryGitHubConfiguration_STATUS
		err := configuration.FactoryGitHub.AssignProperties_To_FactoryGitHubConfiguration_STATUS(&factoryGitHub)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_FactoryGitHubConfiguration_STATUS() to populate field FactoryGitHub")
		}
		destination.FactoryGitHub = &factoryGitHub
	} else {
		destination.FactoryGitHub = nil
	}

	// FactoryVSTS
	if configuration.FactoryVSTS != nil {
		var factoryVSTS v20180601s.FactoryVSTSConfiguration_STATUS
		err := configuration.FactoryVSTS.AssignProperties_To_FactoryVSTSConfiguration_STATUS(&factoryVSTS)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_FactoryVSTSConfiguration_STATUS() to populate field FactoryVSTS")
		}
		destination.FactoryVSTS = &factoryVSTS
	} else {
		destination.FactoryVSTS = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Definition of a single parameter for an entity.
type GlobalParameterSpecification struct {
	// +kubebuilder:validation:Required
	// Type: Global Parameter type.
	Type *GlobalParameterSpecification_Type `json:"type,omitempty"`

	// +kubebuilder:validation:Required
	// Value: Value of parameter.
	Value map[string]v1.JSON `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &GlobalParameterSpecification{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (specification *GlobalParameterSpecification) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if specification == nil {
		return nil, nil
	}
	result := &GlobalParameterSpecification_ARM{}

	// Set property "Type":
	if specification.Type != nil {
		typeVar := *specification.Type
		result.Type = &typeVar
	}

	// Set property "Value":
	if specification.Value != nil {
		result.Value = make(map[string]v1.JSON, len(specification.Value))
		for key, value := range specification.Value {
			result.Value[key] = *value.DeepCopy()
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (specification *GlobalParameterSpecification) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &GlobalParameterSpecification_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (specification *GlobalParameterSpecification) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(GlobalParameterSpecification_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected GlobalParameterSpecification_ARM, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		specification.Type = &typeVar
	}

	// Set property "Value":
	if typedInput.Value != nil {
		specification.Value = make(map[string]v1.JSON, len(typedInput.Value))
		for key, value := range typedInput.Value {
			specification.Value[key] = *value.DeepCopy()
		}
	}

	// No error
	return nil
}

// AssignProperties_From_GlobalParameterSpecification populates our GlobalParameterSpecification from the provided source GlobalParameterSpecification
func (specification *GlobalParameterSpecification) AssignProperties_From_GlobalParameterSpecification(source *v20180601s.GlobalParameterSpecification) error {

	// Type
	if source.Type != nil {
		typeVar := GlobalParameterSpecification_Type(*source.Type)
		specification.Type = &typeVar
	} else {
		specification.Type = nil
	}

	// Value
	if source.Value != nil {
		valueMap := make(map[string]v1.JSON, len(source.Value))
		for valueKey, value := range source.Value {
			// Shadow the loop variable to avoid aliasing
			value := value
			valueMap[valueKey] = *value.DeepCopy()
		}
		specification.Value = valueMap
	} else {
		specification.Value = nil
	}

	// No error
	return nil
}

// AssignProperties_To_GlobalParameterSpecification populates the provided destination GlobalParameterSpecification from our GlobalParameterSpecification
func (specification *GlobalParameterSpecification) AssignProperties_To_GlobalParameterSpecification(destination *v20180601s.GlobalParameterSpecification) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if specification.Type != nil {
		typeVar := string(*specification.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Value
	if specification.Value != nil {
		valueMap := make(map[string]v1.JSON, len(specification.Value))
		for valueKey, value := range specification.Value {
			// Shadow the loop variable to avoid aliasing
			value := value
			valueMap[valueKey] = *value.DeepCopy()
		}
		destination.Value = valueMap
	} else {
		destination.Value = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_GlobalParameterSpecification_STATUS populates our GlobalParameterSpecification from the provided source GlobalParameterSpecification_STATUS
func (specification *GlobalParameterSpecification) Initialize_From_GlobalParameterSpecification_STATUS(source *GlobalParameterSpecification_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := GlobalParameterSpecification_Type(*source.Type)
		specification.Type = &typeVar
	} else {
		specification.Type = nil
	}

	// Value
	if source.Value != nil {
		valueMap := make(map[string]v1.JSON, len(source.Value))
		for valueKey, value := range source.Value {
			// Shadow the loop variable to avoid aliasing
			value := value
			valueMap[valueKey] = *value.DeepCopy()
		}
		specification.Value = valueMap
	} else {
		specification.Value = nil
	}

	// No error
	return nil
}

// Definition of a single parameter for an entity.
type GlobalParameterSpecification_STATUS struct {
	// Type: Global Parameter type.
	Type *GlobalParameterSpecification_Type_STATUS `json:"type,omitempty"`

	// Value: Value of parameter.
	Value map[string]v1.JSON `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &GlobalParameterSpecification_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (specification *GlobalParameterSpecification_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &GlobalParameterSpecification_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (specification *GlobalParameterSpecification_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(GlobalParameterSpecification_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected GlobalParameterSpecification_STATUS_ARM, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		specification.Type = &typeVar
	}

	// Set property "Value":
	if typedInput.Value != nil {
		specification.Value = make(map[string]v1.JSON, len(typedInput.Value))
		for key, value := range typedInput.Value {
			specification.Value[key] = *value.DeepCopy()
		}
	}

	// No error
	return nil
}

// AssignProperties_From_GlobalParameterSpecification_STATUS populates our GlobalParameterSpecification_STATUS from the provided source GlobalParameterSpecification_STATUS
func (specification *GlobalParameterSpecification_STATUS) AssignProperties_From_GlobalParameterSpecification_STATUS(source *v20180601s.GlobalParameterSpecification_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := GlobalParameterSpecification_Type_STATUS(*source.Type)
		specification.Type = &typeVar
	} else {
		specification.Type = nil
	}

	// Value
	if source.Value != nil {
		valueMap := make(map[string]v1.JSON, len(source.Value))
		for valueKey, value := range source.Value {
			// Shadow the loop variable to avoid aliasing
			value := value
			valueMap[valueKey] = *value.DeepCopy()
		}
		specification.Value = valueMap
	} else {
		specification.Value = nil
	}

	// No error
	return nil
}

// AssignProperties_To_GlobalParameterSpecification_STATUS populates the provided destination GlobalParameterSpecification_STATUS from our GlobalParameterSpecification_STATUS
func (specification *GlobalParameterSpecification_STATUS) AssignProperties_To_GlobalParameterSpecification_STATUS(destination *v20180601s.GlobalParameterSpecification_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if specification.Type != nil {
		typeVar := string(*specification.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Value
	if specification.Value != nil {
		valueMap := make(map[string]v1.JSON, len(specification.Value))
		for valueKey, value := range specification.Value {
			// Shadow the loop variable to avoid aliasing
			value := value
			valueMap[valueKey] = *value.DeepCopy()
		}
		destination.Value = valueMap
	} else {
		destination.Value = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Purview configuration.
type PurviewConfiguration struct {
	// PurviewResourceReference: Purview resource id.
	PurviewResourceReference *genruntime.ResourceReference `armReference:"PurviewResourceId" json:"purviewResourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &PurviewConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *PurviewConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &PurviewConfiguration_ARM{}

	// Set property "PurviewResourceId":
	if configuration.PurviewResourceReference != nil {
		purviewResourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*configuration.PurviewResourceReference)
		if err != nil {
			return nil, err
		}
		purviewResourceReference := purviewResourceReferenceARMID
		result.PurviewResourceId = &purviewResourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *PurviewConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PurviewConfiguration_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *PurviewConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(PurviewConfiguration_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PurviewConfiguration_ARM, got %T", armInput)
	}

	// no assignment for property "PurviewResourceReference"

	// No error
	return nil
}

// AssignProperties_From_PurviewConfiguration populates our PurviewConfiguration from the provided source PurviewConfiguration
func (configuration *PurviewConfiguration) AssignProperties_From_PurviewConfiguration(source *v20180601s.PurviewConfiguration) error {

	// PurviewResourceReference
	if source.PurviewResourceReference != nil {
		purviewResourceReference := source.PurviewResourceReference.Copy()
		configuration.PurviewResourceReference = &purviewResourceReference
	} else {
		configuration.PurviewResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PurviewConfiguration populates the provided destination PurviewConfiguration from our PurviewConfiguration
func (configuration *PurviewConfiguration) AssignProperties_To_PurviewConfiguration(destination *v20180601s.PurviewConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PurviewResourceReference
	if configuration.PurviewResourceReference != nil {
		purviewResourceReference := configuration.PurviewResourceReference.Copy()
		destination.PurviewResourceReference = &purviewResourceReference
	} else {
		destination.PurviewResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_PurviewConfiguration_STATUS populates our PurviewConfiguration from the provided source PurviewConfiguration_STATUS
func (configuration *PurviewConfiguration) Initialize_From_PurviewConfiguration_STATUS(source *PurviewConfiguration_STATUS) error {

	// PurviewResourceReference
	if source.PurviewResourceId != nil {
		purviewResourceReference := genruntime.CreateResourceReferenceFromARMID(*source.PurviewResourceId)
		configuration.PurviewResourceReference = &purviewResourceReference
	} else {
		configuration.PurviewResourceReference = nil
	}

	// No error
	return nil
}

// Purview configuration.
type PurviewConfiguration_STATUS struct {
	// PurviewResourceId: Purview resource id.
	PurviewResourceId *string `json:"purviewResourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &PurviewConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *PurviewConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PurviewConfiguration_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *PurviewConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PurviewConfiguration_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PurviewConfiguration_STATUS_ARM, got %T", armInput)
	}

	// Set property "PurviewResourceId":
	if typedInput.PurviewResourceId != nil {
		purviewResourceId := *typedInput.PurviewResourceId
		configuration.PurviewResourceId = &purviewResourceId
	}

	// No error
	return nil
}

// AssignProperties_From_PurviewConfiguration_STATUS populates our PurviewConfiguration_STATUS from the provided source PurviewConfiguration_STATUS
func (configuration *PurviewConfiguration_STATUS) AssignProperties_From_PurviewConfiguration_STATUS(source *v20180601s.PurviewConfiguration_STATUS) error {

	// PurviewResourceId
	configuration.PurviewResourceId = genruntime.ClonePointerToString(source.PurviewResourceId)

	// No error
	return nil
}

// AssignProperties_To_PurviewConfiguration_STATUS populates the provided destination PurviewConfiguration_STATUS from our PurviewConfiguration_STATUS
func (configuration *PurviewConfiguration_STATUS) AssignProperties_To_PurviewConfiguration_STATUS(destination *v20180601s.PurviewConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PurviewResourceId
	destination.PurviewResourceId = genruntime.ClonePointerToString(configuration.PurviewResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Managed Identity used for CMK.
type CMKIdentityDefinition struct {
	// UserAssignedIdentityReference: The resource id of the user assigned identity to authenticate to customer's key vault.
	UserAssignedIdentityReference *genruntime.ResourceReference `armReference:"UserAssignedIdentity" json:"userAssignedIdentityReference,omitempty"`
}

var _ genruntime.ARMTransformer = &CMKIdentityDefinition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (definition *CMKIdentityDefinition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if definition == nil {
		return nil, nil
	}
	result := &CMKIdentityDefinition_ARM{}

	// Set property "UserAssignedIdentity":
	if definition.UserAssignedIdentityReference != nil {
		userAssignedIdentityReferenceARMID, err := resolved.ResolvedReferences.Lookup(*definition.UserAssignedIdentityReference)
		if err != nil {
			return nil, err
		}
		userAssignedIdentityReference := userAssignedIdentityReferenceARMID
		result.UserAssignedIdentity = &userAssignedIdentityReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *CMKIdentityDefinition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CMKIdentityDefinition_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *CMKIdentityDefinition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(CMKIdentityDefinition_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CMKIdentityDefinition_ARM, got %T", armInput)
	}

	// no assignment for property "UserAssignedIdentityReference"

	// No error
	return nil
}

// AssignProperties_From_CMKIdentityDefinition populates our CMKIdentityDefinition from the provided source CMKIdentityDefinition
func (definition *CMKIdentityDefinition) AssignProperties_From_CMKIdentityDefinition(source *v20180601s.CMKIdentityDefinition) error {

	// UserAssignedIdentityReference
	if source.UserAssignedIdentityReference != nil {
		userAssignedIdentityReference := source.UserAssignedIdentityReference.Copy()
		definition.UserAssignedIdentityReference = &userAssignedIdentityReference
	} else {
		definition.UserAssignedIdentityReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CMKIdentityDefinition populates the provided destination CMKIdentityDefinition from our CMKIdentityDefinition
func (definition *CMKIdentityDefinition) AssignProperties_To_CMKIdentityDefinition(destination *v20180601s.CMKIdentityDefinition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// UserAssignedIdentityReference
	if definition.UserAssignedIdentityReference != nil {
		userAssignedIdentityReference := definition.UserAssignedIdentityReference.Copy()
		destination.UserAssignedIdentityReference = &userAssignedIdentityReference
	} else {
		destination.UserAssignedIdentityReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_CMKIdentityDefinition_STATUS populates our CMKIdentityDefinition from the provided source CMKIdentityDefinition_STATUS
func (definition *CMKIdentityDefinition) Initialize_From_CMKIdentityDefinition_STATUS(source *CMKIdentityDefinition_STATUS) error {

	// No error
	return nil
}

// Managed Identity used for CMK.
type CMKIdentityDefinition_STATUS struct {
	// UserAssignedIdentity: The resource id of the user assigned identity to authenticate to customer's key vault.
	UserAssignedIdentity *string `json:"userAssignedIdentity,omitempty"`
}

var _ genruntime.FromARMConverter = &CMKIdentityDefinition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *CMKIdentityDefinition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CMKIdentityDefinition_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *CMKIdentityDefinition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CMKIdentityDefinition_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CMKIdentityDefinition_STATUS_ARM, got %T", armInput)
	}

	// Set property "UserAssignedIdentity":
	if typedInput.UserAssignedIdentity != nil {
		userAssignedIdentity := *typedInput.UserAssignedIdentity
		definition.UserAssignedIdentity = &userAssignedIdentity
	}

	// No error
	return nil
}

// AssignProperties_From_CMKIdentityDefinition_STATUS populates our CMKIdentityDefinition_STATUS from the provided source CMKIdentityDefinition_STATUS
func (definition *CMKIdentityDefinition_STATUS) AssignProperties_From_CMKIdentityDefinition_STATUS(source *v20180601s.CMKIdentityDefinition_STATUS) error {

	// UserAssignedIdentity
	definition.UserAssignedIdentity = genruntime.ClonePointerToString(source.UserAssignedIdentity)

	// No error
	return nil
}

// AssignProperties_To_CMKIdentityDefinition_STATUS populates the provided destination CMKIdentityDefinition_STATUS from our CMKIdentityDefinition_STATUS
func (definition *CMKIdentityDefinition_STATUS) AssignProperties_To_CMKIdentityDefinition_STATUS(destination *v20180601s.CMKIdentityDefinition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// UserAssignedIdentity
	destination.UserAssignedIdentity = genruntime.ClonePointerToString(definition.UserAssignedIdentity)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type FactoryGitHubConfiguration struct {
	// +kubebuilder:validation:Required
	// AccountName: Account name.
	AccountName *string `json:"accountName,omitempty"`

	// ClientId: GitHub bring your own app client id.
	ClientId *string `json:"clientId,omitempty"`

	// ClientSecret: GitHub bring your own app client secret information.
	ClientSecret *GitHubClientSecret `json:"clientSecret,omitempty"`

	// +kubebuilder:validation:Required
	// CollaborationBranch: Collaboration branch.
	CollaborationBranch *string `json:"collaborationBranch,omitempty"`

	// DisablePublish: Disable manual publish operation in ADF studio to favor automated publish.
	DisablePublish *bool `json:"disablePublish,omitempty"`

	// HostName: GitHub Enterprise host name. For example: `https://github.mydomain.com`
	HostName *string `json:"hostName,omitempty"`

	// LastCommitId: Last commit id.
	LastCommitId *string `json:"lastCommitId,omitempty"`

	// +kubebuilder:validation:Required
	// RepositoryName: Repository name.
	RepositoryName *string `json:"repositoryName,omitempty"`

	// +kubebuilder:validation:Required
	// RootFolder: Root folder.
	RootFolder *string `json:"rootFolder,omitempty"`

	// +kubebuilder:validation:Required
	// Type: Type of repo configuration.
	Type *FactoryGitHubConfiguration_Type `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &FactoryGitHubConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *FactoryGitHubConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &FactoryGitHubConfiguration_ARM{}

	// Set property "AccountName":
	if configuration.AccountName != nil {
		accountName := *configuration.AccountName
		result.AccountName = &accountName
	}

	// Set property "ClientId":
	if configuration.ClientId != nil {
		clientId := *configuration.ClientId
		result.ClientId = &clientId
	}

	// Set property "ClientSecret":
	if configuration.ClientSecret != nil {
		clientSecret_ARM, err := (*configuration.ClientSecret).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		clientSecret := *clientSecret_ARM.(*GitHubClientSecret_ARM)
		result.ClientSecret = &clientSecret
	}

	// Set property "CollaborationBranch":
	if configuration.CollaborationBranch != nil {
		collaborationBranch := *configuration.CollaborationBranch
		result.CollaborationBranch = &collaborationBranch
	}

	// Set property "DisablePublish":
	if configuration.DisablePublish != nil {
		disablePublish := *configuration.DisablePublish
		result.DisablePublish = &disablePublish
	}

	// Set property "HostName":
	if configuration.HostName != nil {
		hostName := *configuration.HostName
		result.HostName = &hostName
	}

	// Set property "LastCommitId":
	if configuration.LastCommitId != nil {
		lastCommitId := *configuration.LastCommitId
		result.LastCommitId = &lastCommitId
	}

	// Set property "RepositoryName":
	if configuration.RepositoryName != nil {
		repositoryName := *configuration.RepositoryName
		result.RepositoryName = &repositoryName
	}

	// Set property "RootFolder":
	if configuration.RootFolder != nil {
		rootFolder := *configuration.RootFolder
		result.RootFolder = &rootFolder
	}

	// Set property "Type":
	if configuration.Type != nil {
		result.Type = *configuration.Type
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *FactoryGitHubConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &FactoryGitHubConfiguration_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *FactoryGitHubConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(FactoryGitHubConfiguration_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected FactoryGitHubConfiguration_ARM, got %T", armInput)
	}

	// Set property "AccountName":
	if typedInput.AccountName != nil {
		accountName := *typedInput.AccountName
		configuration.AccountName = &accountName
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		configuration.ClientId = &clientId
	}

	// Set property "ClientSecret":
	if typedInput.ClientSecret != nil {
		var clientSecret1 GitHubClientSecret
		err := clientSecret1.PopulateFromARM(owner, *typedInput.ClientSecret)
		if err != nil {
			return err
		}
		clientSecret := clientSecret1
		configuration.ClientSecret = &clientSecret
	}

	// Set property "CollaborationBranch":
	if typedInput.CollaborationBranch != nil {
		collaborationBranch := *typedInput.CollaborationBranch
		configuration.CollaborationBranch = &collaborationBranch
	}

	// Set property "DisablePublish":
	if typedInput.DisablePublish != nil {
		disablePublish := *typedInput.DisablePublish
		configuration.DisablePublish = &disablePublish
	}

	// Set property "HostName":
	if typedInput.HostName != nil {
		hostName := *typedInput.HostName
		configuration.HostName = &hostName
	}

	// Set property "LastCommitId":
	if typedInput.LastCommitId != nil {
		lastCommitId := *typedInput.LastCommitId
		configuration.LastCommitId = &lastCommitId
	}

	// Set property "RepositoryName":
	if typedInput.RepositoryName != nil {
		repositoryName := *typedInput.RepositoryName
		configuration.RepositoryName = &repositoryName
	}

	// Set property "RootFolder":
	if typedInput.RootFolder != nil {
		rootFolder := *typedInput.RootFolder
		configuration.RootFolder = &rootFolder
	}

	// Set property "Type":
	configuration.Type = &typedInput.Type

	// No error
	return nil
}

// AssignProperties_From_FactoryGitHubConfiguration populates our FactoryGitHubConfiguration from the provided source FactoryGitHubConfiguration
func (configuration *FactoryGitHubConfiguration) AssignProperties_From_FactoryGitHubConfiguration(source *v20180601s.FactoryGitHubConfiguration) error {

	// AccountName
	configuration.AccountName = genruntime.ClonePointerToString(source.AccountName)

	// ClientId
	configuration.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// ClientSecret
	if source.ClientSecret != nil {
		var clientSecret GitHubClientSecret
		err := clientSecret.AssignProperties_From_GitHubClientSecret(source.ClientSecret)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_GitHubClientSecret() to populate field ClientSecret")
		}
		configuration.ClientSecret = &clientSecret
	} else {
		configuration.ClientSecret = nil
	}

	// CollaborationBranch
	configuration.CollaborationBranch = genruntime.ClonePointerToString(source.CollaborationBranch)

	// DisablePublish
	if source.DisablePublish != nil {
		disablePublish := *source.DisablePublish
		configuration.DisablePublish = &disablePublish
	} else {
		configuration.DisablePublish = nil
	}

	// HostName
	configuration.HostName = genruntime.ClonePointerToString(source.HostName)

	// LastCommitId
	configuration.LastCommitId = genruntime.ClonePointerToString(source.LastCommitId)

	// RepositoryName
	configuration.RepositoryName = genruntime.ClonePointerToString(source.RepositoryName)

	// RootFolder
	configuration.RootFolder = genruntime.ClonePointerToString(source.RootFolder)

	// Type
	if source.Type != nil {
		typeVar := FactoryGitHubConfiguration_Type(*source.Type)
		configuration.Type = &typeVar
	} else {
		configuration.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FactoryGitHubConfiguration populates the provided destination FactoryGitHubConfiguration from our FactoryGitHubConfiguration
func (configuration *FactoryGitHubConfiguration) AssignProperties_To_FactoryGitHubConfiguration(destination *v20180601s.FactoryGitHubConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AccountName
	destination.AccountName = genruntime.ClonePointerToString(configuration.AccountName)

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(configuration.ClientId)

	// ClientSecret
	if configuration.ClientSecret != nil {
		var clientSecret v20180601s.GitHubClientSecret
		err := configuration.ClientSecret.AssignProperties_To_GitHubClientSecret(&clientSecret)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_GitHubClientSecret() to populate field ClientSecret")
		}
		destination.ClientSecret = &clientSecret
	} else {
		destination.ClientSecret = nil
	}

	// CollaborationBranch
	destination.CollaborationBranch = genruntime.ClonePointerToString(configuration.CollaborationBranch)

	// DisablePublish
	if configuration.DisablePublish != nil {
		disablePublish := *configuration.DisablePublish
		destination.DisablePublish = &disablePublish
	} else {
		destination.DisablePublish = nil
	}

	// HostName
	destination.HostName = genruntime.ClonePointerToString(configuration.HostName)

	// LastCommitId
	destination.LastCommitId = genruntime.ClonePointerToString(configuration.LastCommitId)

	// RepositoryName
	destination.RepositoryName = genruntime.ClonePointerToString(configuration.RepositoryName)

	// RootFolder
	destination.RootFolder = genruntime.ClonePointerToString(configuration.RootFolder)

	// Type
	if configuration.Type != nil {
		typeVar := string(*configuration.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_FactoryGitHubConfiguration_STATUS populates our FactoryGitHubConfiguration from the provided source FactoryGitHubConfiguration_STATUS
func (configuration *FactoryGitHubConfiguration) Initialize_From_FactoryGitHubConfiguration_STATUS(source *FactoryGitHubConfiguration_STATUS) error {

	// AccountName
	configuration.AccountName = genruntime.ClonePointerToString(source.AccountName)

	// ClientId
	configuration.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// ClientSecret
	if source.ClientSecret != nil {
		var clientSecret GitHubClientSecret
		err := clientSecret.Initialize_From_GitHubClientSecret_STATUS(source.ClientSecret)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_GitHubClientSecret_STATUS() to populate field ClientSecret")
		}
		configuration.ClientSecret = &clientSecret
	} else {
		configuration.ClientSecret = nil
	}

	// CollaborationBranch
	configuration.CollaborationBranch = genruntime.ClonePointerToString(source.CollaborationBranch)

	// DisablePublish
	if source.DisablePublish != nil {
		disablePublish := *source.DisablePublish
		configuration.DisablePublish = &disablePublish
	} else {
		configuration.DisablePublish = nil
	}

	// HostName
	configuration.HostName = genruntime.ClonePointerToString(source.HostName)

	// LastCommitId
	configuration.LastCommitId = genruntime.ClonePointerToString(source.LastCommitId)

	// RepositoryName
	configuration.RepositoryName = genruntime.ClonePointerToString(source.RepositoryName)

	// RootFolder
	configuration.RootFolder = genruntime.ClonePointerToString(source.RootFolder)

	// Type
	if source.Type != nil {
		typeVar := FactoryGitHubConfiguration_Type(*source.Type)
		configuration.Type = &typeVar
	} else {
		configuration.Type = nil
	}

	// No error
	return nil
}

type FactoryGitHubConfiguration_STATUS struct {
	// AccountName: Account name.
	AccountName *string `json:"accountName,omitempty"`

	// ClientId: GitHub bring your own app client id.
	ClientId *string `json:"clientId,omitempty"`

	// ClientSecret: GitHub bring your own app client secret information.
	ClientSecret *GitHubClientSecret_STATUS `json:"clientSecret,omitempty"`

	// CollaborationBranch: Collaboration branch.
	CollaborationBranch *string `json:"collaborationBranch,omitempty"`

	// DisablePublish: Disable manual publish operation in ADF studio to favor automated publish.
	DisablePublish *bool `json:"disablePublish,omitempty"`

	// HostName: GitHub Enterprise host name. For example: `https://github.mydomain.com`
	HostName *string `json:"hostName,omitempty"`

	// LastCommitId: Last commit id.
	LastCommitId *string `json:"lastCommitId,omitempty"`

	// RepositoryName: Repository name.
	RepositoryName *string `json:"repositoryName,omitempty"`

	// RootFolder: Root folder.
	RootFolder *string `json:"rootFolder,omitempty"`

	// Type: Type of repo configuration.
	Type *FactoryGitHubConfiguration_Type_STATUS `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &FactoryGitHubConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *FactoryGitHubConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &FactoryGitHubConfiguration_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *FactoryGitHubConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(FactoryGitHubConfiguration_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected FactoryGitHubConfiguration_STATUS_ARM, got %T", armInput)
	}

	// Set property "AccountName":
	if typedInput.AccountName != nil {
		accountName := *typedInput.AccountName
		configuration.AccountName = &accountName
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		configuration.ClientId = &clientId
	}

	// Set property "ClientSecret":
	if typedInput.ClientSecret != nil {
		var clientSecret1 GitHubClientSecret_STATUS
		err := clientSecret1.PopulateFromARM(owner, *typedInput.ClientSecret)
		if err != nil {
			return err
		}
		clientSecret := clientSecret1
		configuration.ClientSecret = &clientSecret
	}

	// Set property "CollaborationBranch":
	if typedInput.CollaborationBranch != nil {
		collaborationBranch := *typedInput.CollaborationBranch
		configuration.CollaborationBranch = &collaborationBranch
	}

	// Set property "DisablePublish":
	if typedInput.DisablePublish != nil {
		disablePublish := *typedInput.DisablePublish
		configuration.DisablePublish = &disablePublish
	}

	// Set property "HostName":
	if typedInput.HostName != nil {
		hostName := *typedInput.HostName
		configuration.HostName = &hostName
	}

	// Set property "LastCommitId":
	if typedInput.LastCommitId != nil {
		lastCommitId := *typedInput.LastCommitId
		configuration.LastCommitId = &lastCommitId
	}

	// Set property "RepositoryName":
	if typedInput.RepositoryName != nil {
		repositoryName := *typedInput.RepositoryName
		configuration.RepositoryName = &repositoryName
	}

	// Set property "RootFolder":
	if typedInput.RootFolder != nil {
		rootFolder := *typedInput.RootFolder
		configuration.RootFolder = &rootFolder
	}

	// Set property "Type":
	configuration.Type = &typedInput.Type

	// No error
	return nil
}

// AssignProperties_From_FactoryGitHubConfiguration_STATUS populates our FactoryGitHubConfiguration_STATUS from the provided source FactoryGitHubConfiguration_STATUS
func (configuration *FactoryGitHubConfiguration_STATUS) AssignProperties_From_FactoryGitHubConfiguration_STATUS(source *v20180601s.FactoryGitHubConfiguration_STATUS) error {

	// AccountName
	configuration.AccountName = genruntime.ClonePointerToString(source.AccountName)

	// ClientId
	configuration.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// ClientSecret
	if source.ClientSecret != nil {
		var clientSecret GitHubClientSecret_STATUS
		err := clientSecret.AssignProperties_From_GitHubClientSecret_STATUS(source.ClientSecret)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_GitHubClientSecret_STATUS() to populate field ClientSecret")
		}
		configuration.ClientSecret = &clientSecret
	} else {
		configuration.ClientSecret = nil
	}

	// CollaborationBranch
	configuration.CollaborationBranch = genruntime.ClonePointerToString(source.CollaborationBranch)

	// DisablePublish
	if source.DisablePublish != nil {
		disablePublish := *source.DisablePublish
		configuration.DisablePublish = &disablePublish
	} else {
		configuration.DisablePublish = nil
	}

	// HostName
	configuration.HostName = genruntime.ClonePointerToString(source.HostName)

	// LastCommitId
	configuration.LastCommitId = genruntime.ClonePointerToString(source.LastCommitId)

	// RepositoryName
	configuration.RepositoryName = genruntime.ClonePointerToString(source.RepositoryName)

	// RootFolder
	configuration.RootFolder = genruntime.ClonePointerToString(source.RootFolder)

	// Type
	if source.Type != nil {
		typeVar := FactoryGitHubConfiguration_Type_STATUS(*source.Type)
		configuration.Type = &typeVar
	} else {
		configuration.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FactoryGitHubConfiguration_STATUS populates the provided destination FactoryGitHubConfiguration_STATUS from our FactoryGitHubConfiguration_STATUS
func (configuration *FactoryGitHubConfiguration_STATUS) AssignProperties_To_FactoryGitHubConfiguration_STATUS(destination *v20180601s.FactoryGitHubConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AccountName
	destination.AccountName = genruntime.ClonePointerToString(configuration.AccountName)

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(configuration.ClientId)

	// ClientSecret
	if configuration.ClientSecret != nil {
		var clientSecret v20180601s.GitHubClientSecret_STATUS
		err := configuration.ClientSecret.AssignProperties_To_GitHubClientSecret_STATUS(&clientSecret)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_GitHubClientSecret_STATUS() to populate field ClientSecret")
		}
		destination.ClientSecret = &clientSecret
	} else {
		destination.ClientSecret = nil
	}

	// CollaborationBranch
	destination.CollaborationBranch = genruntime.ClonePointerToString(configuration.CollaborationBranch)

	// DisablePublish
	if configuration.DisablePublish != nil {
		disablePublish := *configuration.DisablePublish
		destination.DisablePublish = &disablePublish
	} else {
		destination.DisablePublish = nil
	}

	// HostName
	destination.HostName = genruntime.ClonePointerToString(configuration.HostName)

	// LastCommitId
	destination.LastCommitId = genruntime.ClonePointerToString(configuration.LastCommitId)

	// RepositoryName
	destination.RepositoryName = genruntime.ClonePointerToString(configuration.RepositoryName)

	// RootFolder
	destination.RootFolder = genruntime.ClonePointerToString(configuration.RootFolder)

	// Type
	if configuration.Type != nil {
		typeVar := string(*configuration.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type FactoryVSTSConfiguration struct {
	// +kubebuilder:validation:Required
	// AccountName: Account name.
	AccountName *string `json:"accountName,omitempty"`

	// +kubebuilder:validation:Required
	// CollaborationBranch: Collaboration branch.
	CollaborationBranch *string `json:"collaborationBranch,omitempty"`

	// DisablePublish: Disable manual publish operation in ADF studio to favor automated publish.
	DisablePublish *bool `json:"disablePublish,omitempty"`

	// LastCommitId: Last commit id.
	LastCommitId *string `json:"lastCommitId,omitempty"`

	// +kubebuilder:validation:Required
	// ProjectName: VSTS project name.
	ProjectName *string `json:"projectName,omitempty"`

	// +kubebuilder:validation:Required
	// RepositoryName: Repository name.
	RepositoryName *string `json:"repositoryName,omitempty"`

	// +kubebuilder:validation:Required
	// RootFolder: Root folder.
	RootFolder *string `json:"rootFolder,omitempty"`

	// TenantId: VSTS tenant id.
	TenantId *string `json:"tenantId,omitempty"`

	// +kubebuilder:validation:Required
	// Type: Type of repo configuration.
	Type *FactoryVSTSConfiguration_Type `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &FactoryVSTSConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *FactoryVSTSConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &FactoryVSTSConfiguration_ARM{}

	// Set property "AccountName":
	if configuration.AccountName != nil {
		accountName := *configuration.AccountName
		result.AccountName = &accountName
	}

	// Set property "CollaborationBranch":
	if configuration.CollaborationBranch != nil {
		collaborationBranch := *configuration.CollaborationBranch
		result.CollaborationBranch = &collaborationBranch
	}

	// Set property "DisablePublish":
	if configuration.DisablePublish != nil {
		disablePublish := *configuration.DisablePublish
		result.DisablePublish = &disablePublish
	}

	// Set property "LastCommitId":
	if configuration.LastCommitId != nil {
		lastCommitId := *configuration.LastCommitId
		result.LastCommitId = &lastCommitId
	}

	// Set property "ProjectName":
	if configuration.ProjectName != nil {
		projectName := *configuration.ProjectName
		result.ProjectName = &projectName
	}

	// Set property "RepositoryName":
	if configuration.RepositoryName != nil {
		repositoryName := *configuration.RepositoryName
		result.RepositoryName = &repositoryName
	}

	// Set property "RootFolder":
	if configuration.RootFolder != nil {
		rootFolder := *configuration.RootFolder
		result.RootFolder = &rootFolder
	}

	// Set property "TenantId":
	if configuration.TenantId != nil {
		tenantId := *configuration.TenantId
		result.TenantId = &tenantId
	}

	// Set property "Type":
	if configuration.Type != nil {
		result.Type = *configuration.Type
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *FactoryVSTSConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &FactoryVSTSConfiguration_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *FactoryVSTSConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(FactoryVSTSConfiguration_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected FactoryVSTSConfiguration_ARM, got %T", armInput)
	}

	// Set property "AccountName":
	if typedInput.AccountName != nil {
		accountName := *typedInput.AccountName
		configuration.AccountName = &accountName
	}

	// Set property "CollaborationBranch":
	if typedInput.CollaborationBranch != nil {
		collaborationBranch := *typedInput.CollaborationBranch
		configuration.CollaborationBranch = &collaborationBranch
	}

	// Set property "DisablePublish":
	if typedInput.DisablePublish != nil {
		disablePublish := *typedInput.DisablePublish
		configuration.DisablePublish = &disablePublish
	}

	// Set property "LastCommitId":
	if typedInput.LastCommitId != nil {
		lastCommitId := *typedInput.LastCommitId
		configuration.LastCommitId = &lastCommitId
	}

	// Set property "ProjectName":
	if typedInput.ProjectName != nil {
		projectName := *typedInput.ProjectName
		configuration.ProjectName = &projectName
	}

	// Set property "RepositoryName":
	if typedInput.RepositoryName != nil {
		repositoryName := *typedInput.RepositoryName
		configuration.RepositoryName = &repositoryName
	}

	// Set property "RootFolder":
	if typedInput.RootFolder != nil {
		rootFolder := *typedInput.RootFolder
		configuration.RootFolder = &rootFolder
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		configuration.TenantId = &tenantId
	}

	// Set property "Type":
	configuration.Type = &typedInput.Type

	// No error
	return nil
}

// AssignProperties_From_FactoryVSTSConfiguration populates our FactoryVSTSConfiguration from the provided source FactoryVSTSConfiguration
func (configuration *FactoryVSTSConfiguration) AssignProperties_From_FactoryVSTSConfiguration(source *v20180601s.FactoryVSTSConfiguration) error {

	// AccountName
	configuration.AccountName = genruntime.ClonePointerToString(source.AccountName)

	// CollaborationBranch
	configuration.CollaborationBranch = genruntime.ClonePointerToString(source.CollaborationBranch)

	// DisablePublish
	if source.DisablePublish != nil {
		disablePublish := *source.DisablePublish
		configuration.DisablePublish = &disablePublish
	} else {
		configuration.DisablePublish = nil
	}

	// LastCommitId
	configuration.LastCommitId = genruntime.ClonePointerToString(source.LastCommitId)

	// ProjectName
	configuration.ProjectName = genruntime.ClonePointerToString(source.ProjectName)

	// RepositoryName
	configuration.RepositoryName = genruntime.ClonePointerToString(source.RepositoryName)

	// RootFolder
	configuration.RootFolder = genruntime.ClonePointerToString(source.RootFolder)

	// TenantId
	configuration.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := FactoryVSTSConfiguration_Type(*source.Type)
		configuration.Type = &typeVar
	} else {
		configuration.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FactoryVSTSConfiguration populates the provided destination FactoryVSTSConfiguration from our FactoryVSTSConfiguration
func (configuration *FactoryVSTSConfiguration) AssignProperties_To_FactoryVSTSConfiguration(destination *v20180601s.FactoryVSTSConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AccountName
	destination.AccountName = genruntime.ClonePointerToString(configuration.AccountName)

	// CollaborationBranch
	destination.CollaborationBranch = genruntime.ClonePointerToString(configuration.CollaborationBranch)

	// DisablePublish
	if configuration.DisablePublish != nil {
		disablePublish := *configuration.DisablePublish
		destination.DisablePublish = &disablePublish
	} else {
		destination.DisablePublish = nil
	}

	// LastCommitId
	destination.LastCommitId = genruntime.ClonePointerToString(configuration.LastCommitId)

	// ProjectName
	destination.ProjectName = genruntime.ClonePointerToString(configuration.ProjectName)

	// RepositoryName
	destination.RepositoryName = genruntime.ClonePointerToString(configuration.RepositoryName)

	// RootFolder
	destination.RootFolder = genruntime.ClonePointerToString(configuration.RootFolder)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(configuration.TenantId)

	// Type
	if configuration.Type != nil {
		typeVar := string(*configuration.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_FactoryVSTSConfiguration_STATUS populates our FactoryVSTSConfiguration from the provided source FactoryVSTSConfiguration_STATUS
func (configuration *FactoryVSTSConfiguration) Initialize_From_FactoryVSTSConfiguration_STATUS(source *FactoryVSTSConfiguration_STATUS) error {

	// AccountName
	configuration.AccountName = genruntime.ClonePointerToString(source.AccountName)

	// CollaborationBranch
	configuration.CollaborationBranch = genruntime.ClonePointerToString(source.CollaborationBranch)

	// DisablePublish
	if source.DisablePublish != nil {
		disablePublish := *source.DisablePublish
		configuration.DisablePublish = &disablePublish
	} else {
		configuration.DisablePublish = nil
	}

	// LastCommitId
	configuration.LastCommitId = genruntime.ClonePointerToString(source.LastCommitId)

	// ProjectName
	configuration.ProjectName = genruntime.ClonePointerToString(source.ProjectName)

	// RepositoryName
	configuration.RepositoryName = genruntime.ClonePointerToString(source.RepositoryName)

	// RootFolder
	configuration.RootFolder = genruntime.ClonePointerToString(source.RootFolder)

	// TenantId
	configuration.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := FactoryVSTSConfiguration_Type(*source.Type)
		configuration.Type = &typeVar
	} else {
		configuration.Type = nil
	}

	// No error
	return nil
}

type FactoryVSTSConfiguration_STATUS struct {
	// AccountName: Account name.
	AccountName *string `json:"accountName,omitempty"`

	// CollaborationBranch: Collaboration branch.
	CollaborationBranch *string `json:"collaborationBranch,omitempty"`

	// DisablePublish: Disable manual publish operation in ADF studio to favor automated publish.
	DisablePublish *bool `json:"disablePublish,omitempty"`

	// LastCommitId: Last commit id.
	LastCommitId *string `json:"lastCommitId,omitempty"`

	// ProjectName: VSTS project name.
	ProjectName *string `json:"projectName,omitempty"`

	// RepositoryName: Repository name.
	RepositoryName *string `json:"repositoryName,omitempty"`

	// RootFolder: Root folder.
	RootFolder *string `json:"rootFolder,omitempty"`

	// TenantId: VSTS tenant id.
	TenantId *string `json:"tenantId,omitempty"`

	// Type: Type of repo configuration.
	Type *FactoryVSTSConfiguration_Type_STATUS `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &FactoryVSTSConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *FactoryVSTSConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &FactoryVSTSConfiguration_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *FactoryVSTSConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(FactoryVSTSConfiguration_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected FactoryVSTSConfiguration_STATUS_ARM, got %T", armInput)
	}

	// Set property "AccountName":
	if typedInput.AccountName != nil {
		accountName := *typedInput.AccountName
		configuration.AccountName = &accountName
	}

	// Set property "CollaborationBranch":
	if typedInput.CollaborationBranch != nil {
		collaborationBranch := *typedInput.CollaborationBranch
		configuration.CollaborationBranch = &collaborationBranch
	}

	// Set property "DisablePublish":
	if typedInput.DisablePublish != nil {
		disablePublish := *typedInput.DisablePublish
		configuration.DisablePublish = &disablePublish
	}

	// Set property "LastCommitId":
	if typedInput.LastCommitId != nil {
		lastCommitId := *typedInput.LastCommitId
		configuration.LastCommitId = &lastCommitId
	}

	// Set property "ProjectName":
	if typedInput.ProjectName != nil {
		projectName := *typedInput.ProjectName
		configuration.ProjectName = &projectName
	}

	// Set property "RepositoryName":
	if typedInput.RepositoryName != nil {
		repositoryName := *typedInput.RepositoryName
		configuration.RepositoryName = &repositoryName
	}

	// Set property "RootFolder":
	if typedInput.RootFolder != nil {
		rootFolder := *typedInput.RootFolder
		configuration.RootFolder = &rootFolder
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		configuration.TenantId = &tenantId
	}

	// Set property "Type":
	configuration.Type = &typedInput.Type

	// No error
	return nil
}

// AssignProperties_From_FactoryVSTSConfiguration_STATUS populates our FactoryVSTSConfiguration_STATUS from the provided source FactoryVSTSConfiguration_STATUS
func (configuration *FactoryVSTSConfiguration_STATUS) AssignProperties_From_FactoryVSTSConfiguration_STATUS(source *v20180601s.FactoryVSTSConfiguration_STATUS) error {

	// AccountName
	configuration.AccountName = genruntime.ClonePointerToString(source.AccountName)

	// CollaborationBranch
	configuration.CollaborationBranch = genruntime.ClonePointerToString(source.CollaborationBranch)

	// DisablePublish
	if source.DisablePublish != nil {
		disablePublish := *source.DisablePublish
		configuration.DisablePublish = &disablePublish
	} else {
		configuration.DisablePublish = nil
	}

	// LastCommitId
	configuration.LastCommitId = genruntime.ClonePointerToString(source.LastCommitId)

	// ProjectName
	configuration.ProjectName = genruntime.ClonePointerToString(source.ProjectName)

	// RepositoryName
	configuration.RepositoryName = genruntime.ClonePointerToString(source.RepositoryName)

	// RootFolder
	configuration.RootFolder = genruntime.ClonePointerToString(source.RootFolder)

	// TenantId
	configuration.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := FactoryVSTSConfiguration_Type_STATUS(*source.Type)
		configuration.Type = &typeVar
	} else {
		configuration.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FactoryVSTSConfiguration_STATUS populates the provided destination FactoryVSTSConfiguration_STATUS from our FactoryVSTSConfiguration_STATUS
func (configuration *FactoryVSTSConfiguration_STATUS) AssignProperties_To_FactoryVSTSConfiguration_STATUS(destination *v20180601s.FactoryVSTSConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AccountName
	destination.AccountName = genruntime.ClonePointerToString(configuration.AccountName)

	// CollaborationBranch
	destination.CollaborationBranch = genruntime.ClonePointerToString(configuration.CollaborationBranch)

	// DisablePublish
	if configuration.DisablePublish != nil {
		disablePublish := *configuration.DisablePublish
		destination.DisablePublish = &disablePublish
	} else {
		destination.DisablePublish = nil
	}

	// LastCommitId
	destination.LastCommitId = genruntime.ClonePointerToString(configuration.LastCommitId)

	// ProjectName
	destination.ProjectName = genruntime.ClonePointerToString(configuration.ProjectName)

	// RepositoryName
	destination.RepositoryName = genruntime.ClonePointerToString(configuration.RepositoryName)

	// RootFolder
	destination.RootFolder = genruntime.ClonePointerToString(configuration.RootFolder)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(configuration.TenantId)

	// Type
	if configuration.Type != nil {
		typeVar := string(*configuration.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Array","Bool","Float","Int","Object","String"}
type GlobalParameterSpecification_Type string

const (
	GlobalParameterSpecification_Type_Array  = GlobalParameterSpecification_Type("Array")
	GlobalParameterSpecification_Type_Bool   = GlobalParameterSpecification_Type("Bool")
	GlobalParameterSpecification_Type_Float  = GlobalParameterSpecification_Type("Float")
	GlobalParameterSpecification_Type_Int    = GlobalParameterSpecification_Type("Int")
	GlobalParameterSpecification_Type_Object = GlobalParameterSpecification_Type("Object")
	GlobalParameterSpecification_Type_String = GlobalParameterSpecification_Type("String")
)

type GlobalParameterSpecification_Type_STATUS string

const (
	GlobalParameterSpecification_Type_STATUS_Array  = GlobalParameterSpecification_Type_STATUS("Array")
	GlobalParameterSpecification_Type_STATUS_Bool   = GlobalParameterSpecification_Type_STATUS("Bool")
	GlobalParameterSpecification_Type_STATUS_Float  = GlobalParameterSpecification_Type_STATUS("Float")
	GlobalParameterSpecification_Type_STATUS_Int    = GlobalParameterSpecification_Type_STATUS("Int")
	GlobalParameterSpecification_Type_STATUS_Object = GlobalParameterSpecification_Type_STATUS("Object")
	GlobalParameterSpecification_Type_STATUS_String = GlobalParameterSpecification_Type_STATUS("String")
)

// Information about the user assigned identity for the resource
type UserAssignedIdentityDetails struct {
	Reference genruntime.ResourceReference `armReference:"Reference" json:"reference,omitempty"`
}

// AssignProperties_From_UserAssignedIdentityDetails populates our UserAssignedIdentityDetails from the provided source UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_From_UserAssignedIdentityDetails(source *v20180601s.UserAssignedIdentityDetails) error {

	// Reference
	details.Reference = source.Reference.Copy()

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentityDetails populates the provided destination UserAssignedIdentityDetails from our UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_To_UserAssignedIdentityDetails(destination *v20180601s.UserAssignedIdentityDetails) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	destination.Reference = details.Reference.Copy()

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"FactoryGitHubConfiguration"}
type FactoryGitHubConfiguration_Type string

const FactoryGitHubConfiguration_Type_FactoryGitHubConfiguration = FactoryGitHubConfiguration_Type("FactoryGitHubConfiguration")

type FactoryGitHubConfiguration_Type_STATUS string

const FactoryGitHubConfiguration_Type_STATUS_FactoryGitHubConfiguration = FactoryGitHubConfiguration_Type_STATUS("FactoryGitHubConfiguration")

// +kubebuilder:validation:Enum={"FactoryVSTSConfiguration"}
type FactoryVSTSConfiguration_Type string

const FactoryVSTSConfiguration_Type_FactoryVSTSConfiguration = FactoryVSTSConfiguration_Type("FactoryVSTSConfiguration")

type FactoryVSTSConfiguration_Type_STATUS string

const FactoryVSTSConfiguration_Type_STATUS_FactoryVSTSConfiguration = FactoryVSTSConfiguration_Type_STATUS("FactoryVSTSConfiguration")

// Client secret information for factory's bring your own app repository configuration.
type GitHubClientSecret struct {
	// ByoaSecretAkvUrl: Bring your own app client secret AKV URL.
	ByoaSecretAkvUrl *string `json:"byoaSecretAkvUrl,omitempty"`

	// ByoaSecretName: Bring your own app client secret name in AKV.
	ByoaSecretName *string `json:"byoaSecretName,omitempty"`
}

var _ genruntime.ARMTransformer = &GitHubClientSecret{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (secret *GitHubClientSecret) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if secret == nil {
		return nil, nil
	}
	result := &GitHubClientSecret_ARM{}

	// Set property "ByoaSecretAkvUrl":
	if secret.ByoaSecretAkvUrl != nil {
		byoaSecretAkvUrl := *secret.ByoaSecretAkvUrl
		result.ByoaSecretAkvUrl = &byoaSecretAkvUrl
	}

	// Set property "ByoaSecretName":
	if secret.ByoaSecretName != nil {
		byoaSecretName := *secret.ByoaSecretName
		result.ByoaSecretName = &byoaSecretName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (secret *GitHubClientSecret) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &GitHubClientSecret_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (secret *GitHubClientSecret) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(GitHubClientSecret_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected GitHubClientSecret_ARM, got %T", armInput)
	}

	// Set property "ByoaSecretAkvUrl":
	if typedInput.ByoaSecretAkvUrl != nil {
		byoaSecretAkvUrl := *typedInput.ByoaSecretAkvUrl
		secret.ByoaSecretAkvUrl = &byoaSecretAkvUrl
	}

	// Set property "ByoaSecretName":
	if typedInput.ByoaSecretName != nil {
		byoaSecretName := *typedInput.ByoaSecretName
		secret.ByoaSecretName = &byoaSecretName
	}

	// No error
	return nil
}

// AssignProperties_From_GitHubClientSecret populates our GitHubClientSecret from the provided source GitHubClientSecret
func (secret *GitHubClientSecret) AssignProperties_From_GitHubClientSecret(source *v20180601s.GitHubClientSecret) error {

	// ByoaSecretAkvUrl
	secret.ByoaSecretAkvUrl = genruntime.ClonePointerToString(source.ByoaSecretAkvUrl)

	// ByoaSecretName
	secret.ByoaSecretName = genruntime.ClonePointerToString(source.ByoaSecretName)

	// No error
	return nil
}

// AssignProperties_To_GitHubClientSecret populates the provided destination GitHubClientSecret from our GitHubClientSecret
func (secret *GitHubClientSecret) AssignProperties_To_GitHubClientSecret(destination *v20180601s.GitHubClientSecret) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ByoaSecretAkvUrl
	destination.ByoaSecretAkvUrl = genruntime.ClonePointerToString(secret.ByoaSecretAkvUrl)

	// ByoaSecretName
	destination.ByoaSecretName = genruntime.ClonePointerToString(secret.ByoaSecretName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_GitHubClientSecret_STATUS populates our GitHubClientSecret from the provided source GitHubClientSecret_STATUS
func (secret *GitHubClientSecret) Initialize_From_GitHubClientSecret_STATUS(source *GitHubClientSecret_STATUS) error {

	// ByoaSecretAkvUrl
	secret.ByoaSecretAkvUrl = genruntime.ClonePointerToString(source.ByoaSecretAkvUrl)

	// ByoaSecretName
	secret.ByoaSecretName = genruntime.ClonePointerToString(source.ByoaSecretName)

	// No error
	return nil
}

// Client secret information for factory's bring your own app repository configuration.
type GitHubClientSecret_STATUS struct {
	// ByoaSecretAkvUrl: Bring your own app client secret AKV URL.
	ByoaSecretAkvUrl *string `json:"byoaSecretAkvUrl,omitempty"`

	// ByoaSecretName: Bring your own app client secret name in AKV.
	ByoaSecretName *string `json:"byoaSecretName,omitempty"`
}

var _ genruntime.FromARMConverter = &GitHubClientSecret_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (secret *GitHubClientSecret_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &GitHubClientSecret_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (secret *GitHubClientSecret_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(GitHubClientSecret_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected GitHubClientSecret_STATUS_ARM, got %T", armInput)
	}

	// Set property "ByoaSecretAkvUrl":
	if typedInput.ByoaSecretAkvUrl != nil {
		byoaSecretAkvUrl := *typedInput.ByoaSecretAkvUrl
		secret.ByoaSecretAkvUrl = &byoaSecretAkvUrl
	}

	// Set property "ByoaSecretName":
	if typedInput.ByoaSecretName != nil {
		byoaSecretName := *typedInput.ByoaSecretName
		secret.ByoaSecretName = &byoaSecretName
	}

	// No error
	return nil
}

// AssignProperties_From_GitHubClientSecret_STATUS populates our GitHubClientSecret_STATUS from the provided source GitHubClientSecret_STATUS
func (secret *GitHubClientSecret_STATUS) AssignProperties_From_GitHubClientSecret_STATUS(source *v20180601s.GitHubClientSecret_STATUS) error {

	// ByoaSecretAkvUrl
	secret.ByoaSecretAkvUrl = genruntime.ClonePointerToString(source.ByoaSecretAkvUrl)

	// ByoaSecretName
	secret.ByoaSecretName = genruntime.ClonePointerToString(source.ByoaSecretName)

	// No error
	return nil
}

// AssignProperties_To_GitHubClientSecret_STATUS populates the provided destination GitHubClientSecret_STATUS from our GitHubClientSecret_STATUS
func (secret *GitHubClientSecret_STATUS) AssignProperties_To_GitHubClientSecret_STATUS(destination *v20180601s.GitHubClientSecret_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ByoaSecretAkvUrl
	destination.ByoaSecretAkvUrl = genruntime.ClonePointerToString(secret.ByoaSecretAkvUrl)

	// ByoaSecretName
	destination.ByoaSecretName = genruntime.ClonePointerToString(secret.ByoaSecretName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&Factory{}, &FactoryList{})
}
