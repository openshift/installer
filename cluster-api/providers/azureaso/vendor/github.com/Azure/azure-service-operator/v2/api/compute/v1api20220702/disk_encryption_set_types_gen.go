// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20220702

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/compute/v1api20220702/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/compute/v1api20220702/storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /compute/resource-manager/Microsoft.Compute/DiskRP/stable/2022-07-02/diskEncryptionSet.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskEncryptionSets/{diskEncryptionSetName}
type DiskEncryptionSet struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              DiskEncryptionSet_Spec   `json:"spec,omitempty"`
	Status            DiskEncryptionSet_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &DiskEncryptionSet{}

// GetConditions returns the conditions of the resource
func (encryptionSet *DiskEncryptionSet) GetConditions() conditions.Conditions {
	return encryptionSet.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (encryptionSet *DiskEncryptionSet) SetConditions(conditions conditions.Conditions) {
	encryptionSet.Status.Conditions = conditions
}

var _ conversion.Convertible = &DiskEncryptionSet{}

// ConvertFrom populates our DiskEncryptionSet from the provided hub DiskEncryptionSet
func (encryptionSet *DiskEncryptionSet) ConvertFrom(hub conversion.Hub) error {
	// intermediate variable for conversion
	var source storage.DiskEncryptionSet

	err := source.ConvertFrom(hub)
	if err != nil {
		return errors.Wrap(err, "converting from hub to source")
	}

	err = encryptionSet.AssignProperties_From_DiskEncryptionSet(&source)
	if err != nil {
		return errors.Wrap(err, "converting from source to encryptionSet")
	}

	return nil
}

// ConvertTo populates the provided hub DiskEncryptionSet from our DiskEncryptionSet
func (encryptionSet *DiskEncryptionSet) ConvertTo(hub conversion.Hub) error {
	// intermediate variable for conversion
	var destination storage.DiskEncryptionSet
	err := encryptionSet.AssignProperties_To_DiskEncryptionSet(&destination)
	if err != nil {
		return errors.Wrap(err, "converting to destination from encryptionSet")
	}
	err = destination.ConvertTo(hub)
	if err != nil {
		return errors.Wrap(err, "converting from destination to hub")
	}

	return nil
}

// +kubebuilder:webhook:path=/mutate-compute-azure-com-v1api20220702-diskencryptionset,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=compute.azure.com,resources=diskencryptionsets,verbs=create;update,versions=v1api20220702,name=default.v1api20220702.diskencryptionsets.compute.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &DiskEncryptionSet{}

// Default applies defaults to the DiskEncryptionSet resource
func (encryptionSet *DiskEncryptionSet) Default() {
	encryptionSet.defaultImpl()
	var temp any = encryptionSet
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (encryptionSet *DiskEncryptionSet) defaultAzureName() {
	if encryptionSet.Spec.AzureName == "" {
		encryptionSet.Spec.AzureName = encryptionSet.Name
	}
}

// defaultImpl applies the code generated defaults to the DiskEncryptionSet resource
func (encryptionSet *DiskEncryptionSet) defaultImpl() { encryptionSet.defaultAzureName() }

var _ configmaps.Exporter = &DiskEncryptionSet{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (encryptionSet *DiskEncryptionSet) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if encryptionSet.Spec.OperatorSpec == nil {
		return nil
	}
	return encryptionSet.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &DiskEncryptionSet{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (encryptionSet *DiskEncryptionSet) SecretDestinationExpressions() []*core.DestinationExpression {
	if encryptionSet.Spec.OperatorSpec == nil {
		return nil
	}
	return encryptionSet.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.KubernetesResource = &DiskEncryptionSet{}

// AzureName returns the Azure name of the resource
func (encryptionSet *DiskEncryptionSet) AzureName() string {
	return encryptionSet.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2022-07-02"
func (encryptionSet DiskEncryptionSet) GetAPIVersion() string {
	return "2022-07-02"
}

// GetResourceScope returns the scope of the resource
func (encryptionSet *DiskEncryptionSet) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (encryptionSet *DiskEncryptionSet) GetSpec() genruntime.ConvertibleSpec {
	return &encryptionSet.Spec
}

// GetStatus returns the status of this resource
func (encryptionSet *DiskEncryptionSet) GetStatus() genruntime.ConvertibleStatus {
	return &encryptionSet.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (encryptionSet *DiskEncryptionSet) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Compute/diskEncryptionSets"
func (encryptionSet *DiskEncryptionSet) GetType() string {
	return "Microsoft.Compute/diskEncryptionSets"
}

// NewEmptyStatus returns a new empty (blank) status
func (encryptionSet *DiskEncryptionSet) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &DiskEncryptionSet_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (encryptionSet *DiskEncryptionSet) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(encryptionSet.Spec)
	return encryptionSet.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (encryptionSet *DiskEncryptionSet) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*DiskEncryptionSet_STATUS); ok {
		encryptionSet.Status = *st
		return nil
	}

	// Convert status to required version
	var st DiskEncryptionSet_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	encryptionSet.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-compute-azure-com-v1api20220702-diskencryptionset,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=compute.azure.com,resources=diskencryptionsets,verbs=create;update,versions=v1api20220702,name=validate.v1api20220702.diskencryptionsets.compute.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &DiskEncryptionSet{}

// ValidateCreate validates the creation of the resource
func (encryptionSet *DiskEncryptionSet) ValidateCreate() (admission.Warnings, error) {
	validations := encryptionSet.createValidations()
	var temp any = encryptionSet
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	return genruntime.ValidateCreate(validations)
}

// ValidateDelete validates the deletion of the resource
func (encryptionSet *DiskEncryptionSet) ValidateDelete() (admission.Warnings, error) {
	validations := encryptionSet.deleteValidations()
	var temp any = encryptionSet
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	return genruntime.ValidateDelete(validations)
}

// ValidateUpdate validates an update of the resource
func (encryptionSet *DiskEncryptionSet) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	validations := encryptionSet.updateValidations()
	var temp any = encryptionSet
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	return genruntime.ValidateUpdate(old, validations)
}

// createValidations validates the creation of the resource
func (encryptionSet *DiskEncryptionSet) createValidations() []func() (admission.Warnings, error) {
	return []func() (admission.Warnings, error){encryptionSet.validateResourceReferences, encryptionSet.validateOwnerReference, encryptionSet.validateSecretDestinations, encryptionSet.validateConfigMapDestinations, encryptionSet.validateOptionalConfigMapReferences}
}

// deleteValidations validates the deletion of the resource
func (encryptionSet *DiskEncryptionSet) deleteValidations() []func() (admission.Warnings, error) {
	return nil
}

// updateValidations validates the update of the resource
func (encryptionSet *DiskEncryptionSet) updateValidations() []func(old runtime.Object) (admission.Warnings, error) {
	return []func(old runtime.Object) (admission.Warnings, error){
		func(old runtime.Object) (admission.Warnings, error) {
			return encryptionSet.validateResourceReferences()
		},
		encryptionSet.validateWriteOnceProperties,
		func(old runtime.Object) (admission.Warnings, error) {
			return encryptionSet.validateOwnerReference()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return encryptionSet.validateSecretDestinations()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return encryptionSet.validateConfigMapDestinations()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return encryptionSet.validateOptionalConfigMapReferences()
		},
	}
}

// validateConfigMapDestinations validates there are no colliding genruntime.ConfigMapDestinations
func (encryptionSet *DiskEncryptionSet) validateConfigMapDestinations() (admission.Warnings, error) {
	if encryptionSet.Spec.OperatorSpec == nil {
		return nil, nil
	}
	return configmaps.ValidateDestinations(encryptionSet, nil, encryptionSet.Spec.OperatorSpec.ConfigMapExpressions)
}

// validateOptionalConfigMapReferences validates all optional configmap reference pairs to ensure that at most 1 is set
func (encryptionSet *DiskEncryptionSet) validateOptionalConfigMapReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindOptionalConfigMapReferences(&encryptionSet.Spec)
	if err != nil {
		return nil, err
	}
	return configmaps.ValidateOptionalReferences(refs)
}

// validateOwnerReference validates the owner field
func (encryptionSet *DiskEncryptionSet) validateOwnerReference() (admission.Warnings, error) {
	return genruntime.ValidateOwner(encryptionSet)
}

// validateResourceReferences validates all resource references
func (encryptionSet *DiskEncryptionSet) validateResourceReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindResourceReferences(&encryptionSet.Spec)
	if err != nil {
		return nil, err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateSecretDestinations validates there are no colliding genruntime.SecretDestination's
func (encryptionSet *DiskEncryptionSet) validateSecretDestinations() (admission.Warnings, error) {
	if encryptionSet.Spec.OperatorSpec == nil {
		return nil, nil
	}
	return secrets.ValidateDestinations(encryptionSet, nil, encryptionSet.Spec.OperatorSpec.SecretExpressions)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (encryptionSet *DiskEncryptionSet) validateWriteOnceProperties(old runtime.Object) (admission.Warnings, error) {
	oldObj, ok := old.(*DiskEncryptionSet)
	if !ok {
		return nil, nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, encryptionSet)
}

// AssignProperties_From_DiskEncryptionSet populates our DiskEncryptionSet from the provided source DiskEncryptionSet
func (encryptionSet *DiskEncryptionSet) AssignProperties_From_DiskEncryptionSet(source *storage.DiskEncryptionSet) error {

	// ObjectMeta
	encryptionSet.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec DiskEncryptionSet_Spec
	err := spec.AssignProperties_From_DiskEncryptionSet_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_DiskEncryptionSet_Spec() to populate field Spec")
	}
	encryptionSet.Spec = spec

	// Status
	var status DiskEncryptionSet_STATUS
	err = status.AssignProperties_From_DiskEncryptionSet_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_DiskEncryptionSet_STATUS() to populate field Status")
	}
	encryptionSet.Status = status

	// No error
	return nil
}

// AssignProperties_To_DiskEncryptionSet populates the provided destination DiskEncryptionSet from our DiskEncryptionSet
func (encryptionSet *DiskEncryptionSet) AssignProperties_To_DiskEncryptionSet(destination *storage.DiskEncryptionSet) error {

	// ObjectMeta
	destination.ObjectMeta = *encryptionSet.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.DiskEncryptionSet_Spec
	err := encryptionSet.Spec.AssignProperties_To_DiskEncryptionSet_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_DiskEncryptionSet_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.DiskEncryptionSet_STATUS
	err = encryptionSet.Status.AssignProperties_To_DiskEncryptionSet_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_DiskEncryptionSet_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (encryptionSet *DiskEncryptionSet) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: encryptionSet.Spec.OriginalVersion(),
		Kind:    "DiskEncryptionSet",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /compute/resource-manager/Microsoft.Compute/DiskRP/stable/2022-07-02/diskEncryptionSet.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskEncryptionSets/{diskEncryptionSetName}
type DiskEncryptionSetList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []DiskEncryptionSet `json:"items"`
}

// +kubebuilder:validation:Enum={"2022-07-02"}
type APIVersion string

const APIVersion_Value = APIVersion("2022-07-02")

type DiskEncryptionSet_Spec struct {
	// ActiveKey: The key vault key which is currently used by this disk encryption set.
	ActiveKey *KeyForDiskEncryptionSet `json:"activeKey,omitempty"`

	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// EncryptionType: The type of key used to encrypt the data of the disk.
	EncryptionType *DiskEncryptionSetType `json:"encryptionType,omitempty"`

	// FederatedClientId: Multi-tenant application client id to access key vault in a different tenant. Setting the value to
	// 'None' will clear the property.
	FederatedClientId *string `json:"federatedClientId,omitempty" optionalConfigMapPair:"FederatedClientId"`

	// FederatedClientIdFromConfig: Multi-tenant application client id to access key vault in a different tenant. Setting the
	// value to 'None' will clear the property.
	FederatedClientIdFromConfig *genruntime.ConfigMapReference `json:"federatedClientIdFromConfig,omitempty" optionalConfigMapPair:"FederatedClientId"`

	// Identity: The managed identity for the disk encryption set. It should be given permission on the key vault before it can
	// be used  to encrypt disks.
	Identity *EncryptionSetIdentity `json:"identity,omitempty"`

	// +kubebuilder:validation:Required
	// Location: Resource location
	Location *string `json:"location,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *DiskEncryptionSetOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// RotationToLatestKeyVersionEnabled: Set this flag to true to enable auto-updating of this disk encryption set to the
	// latest key version.
	RotationToLatestKeyVersionEnabled *bool `json:"rotationToLatestKeyVersionEnabled,omitempty"`

	// Tags: Resource tags
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &DiskEncryptionSet_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (encryptionSet *DiskEncryptionSet_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if encryptionSet == nil {
		return nil, nil
	}
	result := &arm.DiskEncryptionSet_Spec{}

	// Set property "Identity":
	if encryptionSet.Identity != nil {
		identity_ARM, err := (*encryptionSet.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*arm.EncryptionSetIdentity)
		result.Identity = &identity
	}

	// Set property "Location":
	if encryptionSet.Location != nil {
		location := *encryptionSet.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if encryptionSet.ActiveKey != nil ||
		encryptionSet.EncryptionType != nil ||
		encryptionSet.FederatedClientId != nil ||
		encryptionSet.FederatedClientIdFromConfig != nil ||
		encryptionSet.RotationToLatestKeyVersionEnabled != nil {
		result.Properties = &arm.EncryptionSetProperties{}
	}
	if encryptionSet.ActiveKey != nil {
		activeKey_ARM, err := (*encryptionSet.ActiveKey).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		activeKey := *activeKey_ARM.(*arm.KeyForDiskEncryptionSet)
		result.Properties.ActiveKey = &activeKey
	}
	if encryptionSet.EncryptionType != nil {
		var temp string
		temp = string(*encryptionSet.EncryptionType)
		encryptionType := arm.DiskEncryptionSetType(temp)
		result.Properties.EncryptionType = &encryptionType
	}
	if encryptionSet.FederatedClientId != nil {
		federatedClientId := *encryptionSet.FederatedClientId
		result.Properties.FederatedClientId = &federatedClientId
	}
	if encryptionSet.FederatedClientIdFromConfig != nil {
		federatedClientIdValue, err := resolved.ResolvedConfigMaps.Lookup(*encryptionSet.FederatedClientIdFromConfig)
		if err != nil {
			return nil, errors.Wrap(err, "looking up configmap for property FederatedClientId")
		}
		federatedClientId := federatedClientIdValue
		result.Properties.FederatedClientId = &federatedClientId
	}
	if encryptionSet.RotationToLatestKeyVersionEnabled != nil {
		rotationToLatestKeyVersionEnabled := *encryptionSet.RotationToLatestKeyVersionEnabled
		result.Properties.RotationToLatestKeyVersionEnabled = &rotationToLatestKeyVersionEnabled
	}

	// Set property "Tags":
	if encryptionSet.Tags != nil {
		result.Tags = make(map[string]string, len(encryptionSet.Tags))
		for key, value := range encryptionSet.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (encryptionSet *DiskEncryptionSet_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DiskEncryptionSet_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (encryptionSet *DiskEncryptionSet_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DiskEncryptionSet_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DiskEncryptionSet_Spec, got %T", armInput)
	}

	// Set property "ActiveKey":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ActiveKey != nil {
			var activeKey1 KeyForDiskEncryptionSet
			err := activeKey1.PopulateFromARM(owner, *typedInput.Properties.ActiveKey)
			if err != nil {
				return err
			}
			activeKey := activeKey1
			encryptionSet.ActiveKey = &activeKey
		}
	}

	// Set property "AzureName":
	encryptionSet.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "EncryptionType":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EncryptionType != nil {
			var temp string
			temp = string(*typedInput.Properties.EncryptionType)
			encryptionType := DiskEncryptionSetType(temp)
			encryptionSet.EncryptionType = &encryptionType
		}
	}

	// Set property "FederatedClientId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FederatedClientId != nil {
			federatedClientId := *typedInput.Properties.FederatedClientId
			encryptionSet.FederatedClientId = &federatedClientId
		}
	}

	// no assignment for property "FederatedClientIdFromConfig"

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 EncryptionSetIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		encryptionSet.Identity = &identity
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		encryptionSet.Location = &location
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	encryptionSet.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "RotationToLatestKeyVersionEnabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RotationToLatestKeyVersionEnabled != nil {
			rotationToLatestKeyVersionEnabled := *typedInput.Properties.RotationToLatestKeyVersionEnabled
			encryptionSet.RotationToLatestKeyVersionEnabled = &rotationToLatestKeyVersionEnabled
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		encryptionSet.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			encryptionSet.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &DiskEncryptionSet_Spec{}

// ConvertSpecFrom populates our DiskEncryptionSet_Spec from the provided source
func (encryptionSet *DiskEncryptionSet_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.DiskEncryptionSet_Spec)
	if ok {
		// Populate our instance from source
		return encryptionSet.AssignProperties_From_DiskEncryptionSet_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.DiskEncryptionSet_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = encryptionSet.AssignProperties_From_DiskEncryptionSet_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our DiskEncryptionSet_Spec
func (encryptionSet *DiskEncryptionSet_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.DiskEncryptionSet_Spec)
	if ok {
		// Populate destination from our instance
		return encryptionSet.AssignProperties_To_DiskEncryptionSet_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.DiskEncryptionSet_Spec{}
	err := encryptionSet.AssignProperties_To_DiskEncryptionSet_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_DiskEncryptionSet_Spec populates our DiskEncryptionSet_Spec from the provided source DiskEncryptionSet_Spec
func (encryptionSet *DiskEncryptionSet_Spec) AssignProperties_From_DiskEncryptionSet_Spec(source *storage.DiskEncryptionSet_Spec) error {

	// ActiveKey
	if source.ActiveKey != nil {
		var activeKey KeyForDiskEncryptionSet
		err := activeKey.AssignProperties_From_KeyForDiskEncryptionSet(source.ActiveKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_KeyForDiskEncryptionSet() to populate field ActiveKey")
		}
		encryptionSet.ActiveKey = &activeKey
	} else {
		encryptionSet.ActiveKey = nil
	}

	// AzureName
	encryptionSet.AzureName = source.AzureName

	// EncryptionType
	if source.EncryptionType != nil {
		encryptionType := *source.EncryptionType
		encryptionTypeTemp := genruntime.ToEnum(encryptionType, diskEncryptionSetType_Values)
		encryptionSet.EncryptionType = &encryptionTypeTemp
	} else {
		encryptionSet.EncryptionType = nil
	}

	// FederatedClientId
	encryptionSet.FederatedClientId = genruntime.ClonePointerToString(source.FederatedClientId)

	// FederatedClientIdFromConfig
	if source.FederatedClientIdFromConfig != nil {
		federatedClientIdFromConfig := source.FederatedClientIdFromConfig.Copy()
		encryptionSet.FederatedClientIdFromConfig = &federatedClientIdFromConfig
	} else {
		encryptionSet.FederatedClientIdFromConfig = nil
	}

	// Identity
	if source.Identity != nil {
		var identity EncryptionSetIdentity
		err := identity.AssignProperties_From_EncryptionSetIdentity(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_EncryptionSetIdentity() to populate field Identity")
		}
		encryptionSet.Identity = &identity
	} else {
		encryptionSet.Identity = nil
	}

	// Location
	encryptionSet.Location = genruntime.ClonePointerToString(source.Location)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec DiskEncryptionSetOperatorSpec
		err := operatorSpec.AssignProperties_From_DiskEncryptionSetOperatorSpec(source.OperatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DiskEncryptionSetOperatorSpec() to populate field OperatorSpec")
		}
		encryptionSet.OperatorSpec = &operatorSpec
	} else {
		encryptionSet.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		encryptionSet.Owner = &owner
	} else {
		encryptionSet.Owner = nil
	}

	// RotationToLatestKeyVersionEnabled
	if source.RotationToLatestKeyVersionEnabled != nil {
		rotationToLatestKeyVersionEnabled := *source.RotationToLatestKeyVersionEnabled
		encryptionSet.RotationToLatestKeyVersionEnabled = &rotationToLatestKeyVersionEnabled
	} else {
		encryptionSet.RotationToLatestKeyVersionEnabled = nil
	}

	// Tags
	encryptionSet.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// AssignProperties_To_DiskEncryptionSet_Spec populates the provided destination DiskEncryptionSet_Spec from our DiskEncryptionSet_Spec
func (encryptionSet *DiskEncryptionSet_Spec) AssignProperties_To_DiskEncryptionSet_Spec(destination *storage.DiskEncryptionSet_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ActiveKey
	if encryptionSet.ActiveKey != nil {
		var activeKey storage.KeyForDiskEncryptionSet
		err := encryptionSet.ActiveKey.AssignProperties_To_KeyForDiskEncryptionSet(&activeKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_KeyForDiskEncryptionSet() to populate field ActiveKey")
		}
		destination.ActiveKey = &activeKey
	} else {
		destination.ActiveKey = nil
	}

	// AzureName
	destination.AzureName = encryptionSet.AzureName

	// EncryptionType
	if encryptionSet.EncryptionType != nil {
		encryptionType := string(*encryptionSet.EncryptionType)
		destination.EncryptionType = &encryptionType
	} else {
		destination.EncryptionType = nil
	}

	// FederatedClientId
	destination.FederatedClientId = genruntime.ClonePointerToString(encryptionSet.FederatedClientId)

	// FederatedClientIdFromConfig
	if encryptionSet.FederatedClientIdFromConfig != nil {
		federatedClientIdFromConfig := encryptionSet.FederatedClientIdFromConfig.Copy()
		destination.FederatedClientIdFromConfig = &federatedClientIdFromConfig
	} else {
		destination.FederatedClientIdFromConfig = nil
	}

	// Identity
	if encryptionSet.Identity != nil {
		var identity storage.EncryptionSetIdentity
		err := encryptionSet.Identity.AssignProperties_To_EncryptionSetIdentity(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_EncryptionSetIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(encryptionSet.Location)

	// OperatorSpec
	if encryptionSet.OperatorSpec != nil {
		var operatorSpec storage.DiskEncryptionSetOperatorSpec
		err := encryptionSet.OperatorSpec.AssignProperties_To_DiskEncryptionSetOperatorSpec(&operatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DiskEncryptionSetOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = encryptionSet.OriginalVersion()

	// Owner
	if encryptionSet.Owner != nil {
		owner := encryptionSet.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// RotationToLatestKeyVersionEnabled
	if encryptionSet.RotationToLatestKeyVersionEnabled != nil {
		rotationToLatestKeyVersionEnabled := *encryptionSet.RotationToLatestKeyVersionEnabled
		destination.RotationToLatestKeyVersionEnabled = &rotationToLatestKeyVersionEnabled
	} else {
		destination.RotationToLatestKeyVersionEnabled = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(encryptionSet.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (encryptionSet *DiskEncryptionSet_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (encryptionSet *DiskEncryptionSet_Spec) SetAzureName(azureName string) {
	encryptionSet.AzureName = azureName
}

// disk encryption set resource.
type DiskEncryptionSet_STATUS struct {
	// ActiveKey: The key vault key which is currently used by this disk encryption set.
	ActiveKey *KeyForDiskEncryptionSet_STATUS `json:"activeKey,omitempty"`

	// AutoKeyRotationError: The error that was encountered during auto-key rotation. If an error is present, then auto-key
	// rotation will not be attempted until the error on this disk encryption set is fixed.
	AutoKeyRotationError *ApiError_STATUS `json:"autoKeyRotationError,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// EncryptionType: The type of key used to encrypt the data of the disk.
	EncryptionType *DiskEncryptionSetType_STATUS `json:"encryptionType,omitempty"`

	// FederatedClientId: Multi-tenant application client id to access key vault in a different tenant. Setting the value to
	// 'None' will clear the property.
	FederatedClientId *string `json:"federatedClientId,omitempty"`

	// Id: Resource Id
	Id *string `json:"id,omitempty"`

	// Identity: The managed identity for the disk encryption set. It should be given permission on the key vault before it can
	// be used  to encrypt disks.
	Identity *EncryptionSetIdentity_STATUS `json:"identity,omitempty"`

	// LastKeyRotationTimestamp: The time when the active key of this disk encryption set was updated.
	LastKeyRotationTimestamp *string `json:"lastKeyRotationTimestamp,omitempty"`

	// Location: Resource location
	Location *string `json:"location,omitempty"`

	// Name: Resource name
	Name *string `json:"name,omitempty"`

	// PreviousKeys: A readonly collection of key vault keys previously used by this disk encryption set while a key rotation
	// is in progress. It will be empty if there is no ongoing key rotation.
	PreviousKeys []KeyForDiskEncryptionSet_STATUS `json:"previousKeys,omitempty"`

	// ProvisioningState: The disk encryption set provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty"`

	// RotationToLatestKeyVersionEnabled: Set this flag to true to enable auto-updating of this disk encryption set to the
	// latest key version.
	RotationToLatestKeyVersionEnabled *bool `json:"rotationToLatestKeyVersionEnabled,omitempty"`

	// Tags: Resource tags
	Tags map[string]string `json:"tags,omitempty"`

	// Type: Resource type
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &DiskEncryptionSet_STATUS{}

// ConvertStatusFrom populates our DiskEncryptionSet_STATUS from the provided source
func (encryptionSet *DiskEncryptionSet_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.DiskEncryptionSet_STATUS)
	if ok {
		// Populate our instance from source
		return encryptionSet.AssignProperties_From_DiskEncryptionSet_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.DiskEncryptionSet_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = encryptionSet.AssignProperties_From_DiskEncryptionSet_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our DiskEncryptionSet_STATUS
func (encryptionSet *DiskEncryptionSet_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.DiskEncryptionSet_STATUS)
	if ok {
		// Populate destination from our instance
		return encryptionSet.AssignProperties_To_DiskEncryptionSet_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.DiskEncryptionSet_STATUS{}
	err := encryptionSet.AssignProperties_To_DiskEncryptionSet_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &DiskEncryptionSet_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (encryptionSet *DiskEncryptionSet_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DiskEncryptionSet_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (encryptionSet *DiskEncryptionSet_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DiskEncryptionSet_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DiskEncryptionSet_STATUS, got %T", armInput)
	}

	// Set property "ActiveKey":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ActiveKey != nil {
			var activeKey1 KeyForDiskEncryptionSet_STATUS
			err := activeKey1.PopulateFromARM(owner, *typedInput.Properties.ActiveKey)
			if err != nil {
				return err
			}
			activeKey := activeKey1
			encryptionSet.ActiveKey = &activeKey
		}
	}

	// Set property "AutoKeyRotationError":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutoKeyRotationError != nil {
			var autoKeyRotationError1 ApiError_STATUS
			err := autoKeyRotationError1.PopulateFromARM(owner, *typedInput.Properties.AutoKeyRotationError)
			if err != nil {
				return err
			}
			autoKeyRotationError := autoKeyRotationError1
			encryptionSet.AutoKeyRotationError = &autoKeyRotationError
		}
	}

	// no assignment for property "Conditions"

	// Set property "EncryptionType":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EncryptionType != nil {
			var temp string
			temp = string(*typedInput.Properties.EncryptionType)
			encryptionType := DiskEncryptionSetType_STATUS(temp)
			encryptionSet.EncryptionType = &encryptionType
		}
	}

	// Set property "FederatedClientId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FederatedClientId != nil {
			federatedClientId := *typedInput.Properties.FederatedClientId
			encryptionSet.FederatedClientId = &federatedClientId
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		encryptionSet.Id = &id
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 EncryptionSetIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		encryptionSet.Identity = &identity
	}

	// Set property "LastKeyRotationTimestamp":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LastKeyRotationTimestamp != nil {
			lastKeyRotationTimestamp := *typedInput.Properties.LastKeyRotationTimestamp
			encryptionSet.LastKeyRotationTimestamp = &lastKeyRotationTimestamp
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		encryptionSet.Location = &location
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		encryptionSet.Name = &name
	}

	// Set property "PreviousKeys":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.PreviousKeys {
			var item1 KeyForDiskEncryptionSet_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			encryptionSet.PreviousKeys = append(encryptionSet.PreviousKeys, item1)
		}
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			encryptionSet.ProvisioningState = &provisioningState
		}
	}

	// Set property "RotationToLatestKeyVersionEnabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RotationToLatestKeyVersionEnabled != nil {
			rotationToLatestKeyVersionEnabled := *typedInput.Properties.RotationToLatestKeyVersionEnabled
			encryptionSet.RotationToLatestKeyVersionEnabled = &rotationToLatestKeyVersionEnabled
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		encryptionSet.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			encryptionSet.Tags[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		encryptionSet.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_DiskEncryptionSet_STATUS populates our DiskEncryptionSet_STATUS from the provided source DiskEncryptionSet_STATUS
func (encryptionSet *DiskEncryptionSet_STATUS) AssignProperties_From_DiskEncryptionSet_STATUS(source *storage.DiskEncryptionSet_STATUS) error {

	// ActiveKey
	if source.ActiveKey != nil {
		var activeKey KeyForDiskEncryptionSet_STATUS
		err := activeKey.AssignProperties_From_KeyForDiskEncryptionSet_STATUS(source.ActiveKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_KeyForDiskEncryptionSet_STATUS() to populate field ActiveKey")
		}
		encryptionSet.ActiveKey = &activeKey
	} else {
		encryptionSet.ActiveKey = nil
	}

	// AutoKeyRotationError
	if source.AutoKeyRotationError != nil {
		var autoKeyRotationError ApiError_STATUS
		err := autoKeyRotationError.AssignProperties_From_ApiError_STATUS(source.AutoKeyRotationError)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApiError_STATUS() to populate field AutoKeyRotationError")
		}
		encryptionSet.AutoKeyRotationError = &autoKeyRotationError
	} else {
		encryptionSet.AutoKeyRotationError = nil
	}

	// Conditions
	encryptionSet.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// EncryptionType
	if source.EncryptionType != nil {
		encryptionType := *source.EncryptionType
		encryptionTypeTemp := genruntime.ToEnum(encryptionType, diskEncryptionSetType_STATUS_Values)
		encryptionSet.EncryptionType = &encryptionTypeTemp
	} else {
		encryptionSet.EncryptionType = nil
	}

	// FederatedClientId
	encryptionSet.FederatedClientId = genruntime.ClonePointerToString(source.FederatedClientId)

	// Id
	encryptionSet.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity EncryptionSetIdentity_STATUS
		err := identity.AssignProperties_From_EncryptionSetIdentity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_EncryptionSetIdentity_STATUS() to populate field Identity")
		}
		encryptionSet.Identity = &identity
	} else {
		encryptionSet.Identity = nil
	}

	// LastKeyRotationTimestamp
	encryptionSet.LastKeyRotationTimestamp = genruntime.ClonePointerToString(source.LastKeyRotationTimestamp)

	// Location
	encryptionSet.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	encryptionSet.Name = genruntime.ClonePointerToString(source.Name)

	// PreviousKeys
	if source.PreviousKeys != nil {
		previousKeyList := make([]KeyForDiskEncryptionSet_STATUS, len(source.PreviousKeys))
		for previousKeyIndex, previousKeyItem := range source.PreviousKeys {
			// Shadow the loop variable to avoid aliasing
			previousKeyItem := previousKeyItem
			var previousKey KeyForDiskEncryptionSet_STATUS
			err := previousKey.AssignProperties_From_KeyForDiskEncryptionSet_STATUS(&previousKeyItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_KeyForDiskEncryptionSet_STATUS() to populate field PreviousKeys")
			}
			previousKeyList[previousKeyIndex] = previousKey
		}
		encryptionSet.PreviousKeys = previousKeyList
	} else {
		encryptionSet.PreviousKeys = nil
	}

	// ProvisioningState
	encryptionSet.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// RotationToLatestKeyVersionEnabled
	if source.RotationToLatestKeyVersionEnabled != nil {
		rotationToLatestKeyVersionEnabled := *source.RotationToLatestKeyVersionEnabled
		encryptionSet.RotationToLatestKeyVersionEnabled = &rotationToLatestKeyVersionEnabled
	} else {
		encryptionSet.RotationToLatestKeyVersionEnabled = nil
	}

	// Tags
	encryptionSet.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	encryptionSet.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_DiskEncryptionSet_STATUS populates the provided destination DiskEncryptionSet_STATUS from our DiskEncryptionSet_STATUS
func (encryptionSet *DiskEncryptionSet_STATUS) AssignProperties_To_DiskEncryptionSet_STATUS(destination *storage.DiskEncryptionSet_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ActiveKey
	if encryptionSet.ActiveKey != nil {
		var activeKey storage.KeyForDiskEncryptionSet_STATUS
		err := encryptionSet.ActiveKey.AssignProperties_To_KeyForDiskEncryptionSet_STATUS(&activeKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_KeyForDiskEncryptionSet_STATUS() to populate field ActiveKey")
		}
		destination.ActiveKey = &activeKey
	} else {
		destination.ActiveKey = nil
	}

	// AutoKeyRotationError
	if encryptionSet.AutoKeyRotationError != nil {
		var autoKeyRotationError storage.ApiError_STATUS
		err := encryptionSet.AutoKeyRotationError.AssignProperties_To_ApiError_STATUS(&autoKeyRotationError)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApiError_STATUS() to populate field AutoKeyRotationError")
		}
		destination.AutoKeyRotationError = &autoKeyRotationError
	} else {
		destination.AutoKeyRotationError = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(encryptionSet.Conditions)

	// EncryptionType
	if encryptionSet.EncryptionType != nil {
		encryptionType := string(*encryptionSet.EncryptionType)
		destination.EncryptionType = &encryptionType
	} else {
		destination.EncryptionType = nil
	}

	// FederatedClientId
	destination.FederatedClientId = genruntime.ClonePointerToString(encryptionSet.FederatedClientId)

	// Id
	destination.Id = genruntime.ClonePointerToString(encryptionSet.Id)

	// Identity
	if encryptionSet.Identity != nil {
		var identity storage.EncryptionSetIdentity_STATUS
		err := encryptionSet.Identity.AssignProperties_To_EncryptionSetIdentity_STATUS(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_EncryptionSetIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// LastKeyRotationTimestamp
	destination.LastKeyRotationTimestamp = genruntime.ClonePointerToString(encryptionSet.LastKeyRotationTimestamp)

	// Location
	destination.Location = genruntime.ClonePointerToString(encryptionSet.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(encryptionSet.Name)

	// PreviousKeys
	if encryptionSet.PreviousKeys != nil {
		previousKeyList := make([]storage.KeyForDiskEncryptionSet_STATUS, len(encryptionSet.PreviousKeys))
		for previousKeyIndex, previousKeyItem := range encryptionSet.PreviousKeys {
			// Shadow the loop variable to avoid aliasing
			previousKeyItem := previousKeyItem
			var previousKey storage.KeyForDiskEncryptionSet_STATUS
			err := previousKeyItem.AssignProperties_To_KeyForDiskEncryptionSet_STATUS(&previousKey)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_KeyForDiskEncryptionSet_STATUS() to populate field PreviousKeys")
			}
			previousKeyList[previousKeyIndex] = previousKey
		}
		destination.PreviousKeys = previousKeyList
	} else {
		destination.PreviousKeys = nil
	}

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(encryptionSet.ProvisioningState)

	// RotationToLatestKeyVersionEnabled
	if encryptionSet.RotationToLatestKeyVersionEnabled != nil {
		rotationToLatestKeyVersionEnabled := *encryptionSet.RotationToLatestKeyVersionEnabled
		destination.RotationToLatestKeyVersionEnabled = &rotationToLatestKeyVersionEnabled
	} else {
		destination.RotationToLatestKeyVersionEnabled = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(encryptionSet.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(encryptionSet.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Api error.
type ApiError_STATUS struct {
	// Code: The error code.
	Code *string `json:"code,omitempty"`

	// Details: The Api error details
	Details []ApiErrorBase_STATUS `json:"details,omitempty"`

	// Innererror: The Api inner error
	Innererror *InnerError_STATUS `json:"innererror,omitempty"`

	// Message: The error message.
	Message *string `json:"message,omitempty"`

	// Target: The target of the particular error.
	Target *string `json:"target,omitempty"`
}

var _ genruntime.FromARMConverter = &ApiError_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (error *ApiError_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApiError_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (error *ApiError_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApiError_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApiError_STATUS, got %T", armInput)
	}

	// Set property "Code":
	if typedInput.Code != nil {
		code := *typedInput.Code
		error.Code = &code
	}

	// Set property "Details":
	for _, item := range typedInput.Details {
		var item1 ApiErrorBase_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		error.Details = append(error.Details, item1)
	}

	// Set property "Innererror":
	if typedInput.Innererror != nil {
		var innererror1 InnerError_STATUS
		err := innererror1.PopulateFromARM(owner, *typedInput.Innererror)
		if err != nil {
			return err
		}
		innererror := innererror1
		error.Innererror = &innererror
	}

	// Set property "Message":
	if typedInput.Message != nil {
		message := *typedInput.Message
		error.Message = &message
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		error.Target = &target
	}

	// No error
	return nil
}

// AssignProperties_From_ApiError_STATUS populates our ApiError_STATUS from the provided source ApiError_STATUS
func (error *ApiError_STATUS) AssignProperties_From_ApiError_STATUS(source *storage.ApiError_STATUS) error {

	// Code
	error.Code = genruntime.ClonePointerToString(source.Code)

	// Details
	if source.Details != nil {
		detailList := make([]ApiErrorBase_STATUS, len(source.Details))
		for detailIndex, detailItem := range source.Details {
			// Shadow the loop variable to avoid aliasing
			detailItem := detailItem
			var detail ApiErrorBase_STATUS
			err := detail.AssignProperties_From_ApiErrorBase_STATUS(&detailItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApiErrorBase_STATUS() to populate field Details")
			}
			detailList[detailIndex] = detail
		}
		error.Details = detailList
	} else {
		error.Details = nil
	}

	// Innererror
	if source.Innererror != nil {
		var innererror InnerError_STATUS
		err := innererror.AssignProperties_From_InnerError_STATUS(source.Innererror)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_InnerError_STATUS() to populate field Innererror")
		}
		error.Innererror = &innererror
	} else {
		error.Innererror = nil
	}

	// Message
	error.Message = genruntime.ClonePointerToString(source.Message)

	// Target
	error.Target = genruntime.ClonePointerToString(source.Target)

	// No error
	return nil
}

// AssignProperties_To_ApiError_STATUS populates the provided destination ApiError_STATUS from our ApiError_STATUS
func (error *ApiError_STATUS) AssignProperties_To_ApiError_STATUS(destination *storage.ApiError_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Code
	destination.Code = genruntime.ClonePointerToString(error.Code)

	// Details
	if error.Details != nil {
		detailList := make([]storage.ApiErrorBase_STATUS, len(error.Details))
		for detailIndex, detailItem := range error.Details {
			// Shadow the loop variable to avoid aliasing
			detailItem := detailItem
			var detail storage.ApiErrorBase_STATUS
			err := detailItem.AssignProperties_To_ApiErrorBase_STATUS(&detail)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApiErrorBase_STATUS() to populate field Details")
			}
			detailList[detailIndex] = detail
		}
		destination.Details = detailList
	} else {
		destination.Details = nil
	}

	// Innererror
	if error.Innererror != nil {
		var innererror storage.InnerError_STATUS
		err := error.Innererror.AssignProperties_To_InnerError_STATUS(&innererror)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_InnerError_STATUS() to populate field Innererror")
		}
		destination.Innererror = &innererror
	} else {
		destination.Innererror = nil
	}

	// Message
	destination.Message = genruntime.ClonePointerToString(error.Message)

	// Target
	destination.Target = genruntime.ClonePointerToString(error.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type DiskEncryptionSetOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_DiskEncryptionSetOperatorSpec populates our DiskEncryptionSetOperatorSpec from the provided source DiskEncryptionSetOperatorSpec
func (operator *DiskEncryptionSetOperatorSpec) AssignProperties_From_DiskEncryptionSetOperatorSpec(source *storage.DiskEncryptionSetOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DiskEncryptionSetOperatorSpec populates the provided destination DiskEncryptionSetOperatorSpec from our DiskEncryptionSetOperatorSpec
func (operator *DiskEncryptionSetOperatorSpec) AssignProperties_To_DiskEncryptionSetOperatorSpec(destination *storage.DiskEncryptionSetOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The type of key used to encrypt the data of the disk.
// +kubebuilder:validation:Enum={"ConfidentialVmEncryptedWithCustomerKey","EncryptionAtRestWithCustomerKey","EncryptionAtRestWithPlatformAndCustomerKeys"}
type DiskEncryptionSetType string

const (
	DiskEncryptionSetType_ConfidentialVmEncryptedWithCustomerKey      = DiskEncryptionSetType("ConfidentialVmEncryptedWithCustomerKey")
	DiskEncryptionSetType_EncryptionAtRestWithCustomerKey             = DiskEncryptionSetType("EncryptionAtRestWithCustomerKey")
	DiskEncryptionSetType_EncryptionAtRestWithPlatformAndCustomerKeys = DiskEncryptionSetType("EncryptionAtRestWithPlatformAndCustomerKeys")
)

// Mapping from string to DiskEncryptionSetType
var diskEncryptionSetType_Values = map[string]DiskEncryptionSetType{
	"confidentialvmencryptedwithcustomerkey":      DiskEncryptionSetType_ConfidentialVmEncryptedWithCustomerKey,
	"encryptionatrestwithcustomerkey":             DiskEncryptionSetType_EncryptionAtRestWithCustomerKey,
	"encryptionatrestwithplatformandcustomerkeys": DiskEncryptionSetType_EncryptionAtRestWithPlatformAndCustomerKeys,
}

// The type of key used to encrypt the data of the disk.
type DiskEncryptionSetType_STATUS string

const (
	DiskEncryptionSetType_STATUS_ConfidentialVmEncryptedWithCustomerKey      = DiskEncryptionSetType_STATUS("ConfidentialVmEncryptedWithCustomerKey")
	DiskEncryptionSetType_STATUS_EncryptionAtRestWithCustomerKey             = DiskEncryptionSetType_STATUS("EncryptionAtRestWithCustomerKey")
	DiskEncryptionSetType_STATUS_EncryptionAtRestWithPlatformAndCustomerKeys = DiskEncryptionSetType_STATUS("EncryptionAtRestWithPlatformAndCustomerKeys")
)

// Mapping from string to DiskEncryptionSetType_STATUS
var diskEncryptionSetType_STATUS_Values = map[string]DiskEncryptionSetType_STATUS{
	"confidentialvmencryptedwithcustomerkey":      DiskEncryptionSetType_STATUS_ConfidentialVmEncryptedWithCustomerKey,
	"encryptionatrestwithcustomerkey":             DiskEncryptionSetType_STATUS_EncryptionAtRestWithCustomerKey,
	"encryptionatrestwithplatformandcustomerkeys": DiskEncryptionSetType_STATUS_EncryptionAtRestWithPlatformAndCustomerKeys,
}

// The managed identity for the disk encryption set. It should be given permission on the key vault before it can be used
// to encrypt disks.
type EncryptionSetIdentity struct {
	// Type: The type of Managed Identity used by the DiskEncryptionSet. Only SystemAssigned is supported for new creations.
	// Disk Encryption Sets can be updated with Identity type None during migration of subscription to a new Azure Active
	// Directory tenant; it will cause the encrypted resources to lose access to the keys.
	Type *EncryptionSetIdentity_Type `json:"type,omitempty"`

	// UserAssignedIdentities: The list of user identities associated with the disk encryption set. The user identity
	// dictionary key references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities []UserAssignedIdentityDetails `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.ARMTransformer = &EncryptionSetIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *EncryptionSetIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &arm.EncryptionSetIdentity{}

	// Set property "Type":
	if identity.Type != nil {
		var temp string
		temp = string(*identity.Type)
		typeVar := arm.EncryptionSetIdentity_Type(temp)
		result.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	result.UserAssignedIdentities = make(map[string]arm.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
	for _, ident := range identity.UserAssignedIdentities {
		identARMID, err := resolved.ResolvedReferences.Lookup(ident.Reference)
		if err != nil {
			return nil, err
		}
		key := identARMID
		result.UserAssignedIdentities[key] = arm.UserAssignedIdentityDetails{}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *EncryptionSetIdentity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EncryptionSetIdentity{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *EncryptionSetIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EncryptionSetIdentity)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EncryptionSetIdentity, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := EncryptionSetIdentity_Type(temp)
		identity.Type = &typeVar
	}

	// no assignment for property "UserAssignedIdentities"

	// No error
	return nil
}

// AssignProperties_From_EncryptionSetIdentity populates our EncryptionSetIdentity from the provided source EncryptionSetIdentity
func (identity *EncryptionSetIdentity) AssignProperties_From_EncryptionSetIdentity(source *storage.EncryptionSetIdentity) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, encryptionSetIdentity_Type_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, len(source.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity UserAssignedIdentityDetails
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentityDetails(&userAssignedIdentityItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_EncryptionSetIdentity populates the provided destination EncryptionSetIdentity from our EncryptionSetIdentity
func (identity *EncryptionSetIdentity) AssignProperties_To_EncryptionSetIdentity(destination *storage.EncryptionSetIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]storage.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity storage.UserAssignedIdentityDetails
			err := userAssignedIdentityItem.AssignProperties_To_UserAssignedIdentityDetails(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityList
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The managed identity for the disk encryption set. It should be given permission on the key vault before it can be used
// to encrypt disks.
type EncryptionSetIdentity_STATUS struct {
	// PrincipalId: The object id of the Managed Identity Resource. This will be sent to the RP from ARM via the
	// x-ms-identity-principal-id header in the PUT request if the resource has a systemAssigned(implicit) identity
	PrincipalId *string `json:"principalId,omitempty"`

	// TenantId: The tenant id of the Managed Identity Resource. This will be sent to the RP from ARM via the
	// x-ms-client-tenant-id header in the PUT request if the resource has a systemAssigned(implicit) identity
	TenantId *string `json:"tenantId,omitempty"`

	// Type: The type of Managed Identity used by the DiskEncryptionSet. Only SystemAssigned is supported for new creations.
	// Disk Encryption Sets can be updated with Identity type None during migration of subscription to a new Azure Active
	// Directory tenant; it will cause the encrypted resources to lose access to the keys.
	Type *EncryptionSetIdentity_Type_STATUS `json:"type,omitempty"`

	// UserAssignedIdentities: The list of user identities associated with the disk encryption set. The user identity
	// dictionary key references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities map[string]EncryptionSetIdentity_UserAssignedIdentities_STATUS `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.FromARMConverter = &EncryptionSetIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *EncryptionSetIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EncryptionSetIdentity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *EncryptionSetIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EncryptionSetIdentity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EncryptionSetIdentity_STATUS, got %T", armInput)
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		identity.TenantId = &tenantId
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := EncryptionSetIdentity_Type_STATUS(temp)
		identity.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	if typedInput.UserAssignedIdentities != nil {
		identity.UserAssignedIdentities = make(map[string]EncryptionSetIdentity_UserAssignedIdentities_STATUS, len(typedInput.UserAssignedIdentities))
		for key, value := range typedInput.UserAssignedIdentities {
			var value1 EncryptionSetIdentity_UserAssignedIdentities_STATUS
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			identity.UserAssignedIdentities[key] = value1
		}
	}

	// No error
	return nil
}

// AssignProperties_From_EncryptionSetIdentity_STATUS populates our EncryptionSetIdentity_STATUS from the provided source EncryptionSetIdentity_STATUS
func (identity *EncryptionSetIdentity_STATUS) AssignProperties_From_EncryptionSetIdentity_STATUS(source *storage.EncryptionSetIdentity_STATUS) error {

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, encryptionSetIdentity_Type_STATUS_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]EncryptionSetIdentity_UserAssignedIdentities_STATUS, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity EncryptionSetIdentity_UserAssignedIdentities_STATUS
			err := userAssignedIdentity.AssignProperties_From_EncryptionSetIdentity_UserAssignedIdentities_STATUS(&userAssignedIdentityValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_EncryptionSetIdentity_UserAssignedIdentities_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_EncryptionSetIdentity_STATUS populates the provided destination EncryptionSetIdentity_STATUS from our EncryptionSetIdentity_STATUS
func (identity *EncryptionSetIdentity_STATUS) AssignProperties_To_EncryptionSetIdentity_STATUS(destination *storage.EncryptionSetIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]storage.EncryptionSetIdentity_UserAssignedIdentities_STATUS, len(identity.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity storage.EncryptionSetIdentity_UserAssignedIdentities_STATUS
			err := userAssignedIdentityValue.AssignProperties_To_EncryptionSetIdentity_UserAssignedIdentities_STATUS(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_EncryptionSetIdentity_UserAssignedIdentities_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Key Vault Key Url to be used for server side encryption of Managed Disks and Snapshots
type KeyForDiskEncryptionSet struct {
	// KeyUrl: Fully versioned Key Url pointing to a key in KeyVault. Version segment of the Url is required regardless of
	// rotationToLatestKeyVersionEnabled value.
	KeyUrl *string `json:"keyUrl,omitempty" optionalConfigMapPair:"KeyUrl"`

	// KeyUrlFromConfig: Fully versioned Key Url pointing to a key in KeyVault. Version segment of the Url is required
	// regardless of rotationToLatestKeyVersionEnabled value.
	KeyUrlFromConfig *genruntime.ConfigMapReference `json:"keyUrlFromConfig,omitempty" optionalConfigMapPair:"KeyUrl"`

	// SourceVault: Resource id of the KeyVault containing the key or secret. This property is optional and cannot be used if
	// the KeyVault subscription is not the same as the Disk Encryption Set subscription.
	SourceVault *SourceVault `json:"sourceVault,omitempty"`
}

var _ genruntime.ARMTransformer = &KeyForDiskEncryptionSet{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (encryptionSet *KeyForDiskEncryptionSet) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if encryptionSet == nil {
		return nil, nil
	}
	result := &arm.KeyForDiskEncryptionSet{}

	// Set property "KeyUrl":
	if encryptionSet.KeyUrl != nil {
		keyUrl := *encryptionSet.KeyUrl
		result.KeyUrl = &keyUrl
	}
	if encryptionSet.KeyUrlFromConfig != nil {
		keyUrlValue, err := resolved.ResolvedConfigMaps.Lookup(*encryptionSet.KeyUrlFromConfig)
		if err != nil {
			return nil, errors.Wrap(err, "looking up configmap for property KeyUrl")
		}
		keyUrl := keyUrlValue
		result.KeyUrl = &keyUrl
	}

	// Set property "SourceVault":
	if encryptionSet.SourceVault != nil {
		sourceVault_ARM, err := (*encryptionSet.SourceVault).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sourceVault := *sourceVault_ARM.(*arm.SourceVault)
		result.SourceVault = &sourceVault
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (encryptionSet *KeyForDiskEncryptionSet) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KeyForDiskEncryptionSet{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (encryptionSet *KeyForDiskEncryptionSet) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KeyForDiskEncryptionSet)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KeyForDiskEncryptionSet, got %T", armInput)
	}

	// Set property "KeyUrl":
	if typedInput.KeyUrl != nil {
		keyUrl := *typedInput.KeyUrl
		encryptionSet.KeyUrl = &keyUrl
	}

	// no assignment for property "KeyUrlFromConfig"

	// Set property "SourceVault":
	if typedInput.SourceVault != nil {
		var sourceVault1 SourceVault
		err := sourceVault1.PopulateFromARM(owner, *typedInput.SourceVault)
		if err != nil {
			return err
		}
		sourceVault := sourceVault1
		encryptionSet.SourceVault = &sourceVault
	}

	// No error
	return nil
}

// AssignProperties_From_KeyForDiskEncryptionSet populates our KeyForDiskEncryptionSet from the provided source KeyForDiskEncryptionSet
func (encryptionSet *KeyForDiskEncryptionSet) AssignProperties_From_KeyForDiskEncryptionSet(source *storage.KeyForDiskEncryptionSet) error {

	// KeyUrl
	encryptionSet.KeyUrl = genruntime.ClonePointerToString(source.KeyUrl)

	// KeyUrlFromConfig
	if source.KeyUrlFromConfig != nil {
		keyUrlFromConfig := source.KeyUrlFromConfig.Copy()
		encryptionSet.KeyUrlFromConfig = &keyUrlFromConfig
	} else {
		encryptionSet.KeyUrlFromConfig = nil
	}

	// SourceVault
	if source.SourceVault != nil {
		var sourceVault SourceVault
		err := sourceVault.AssignProperties_From_SourceVault(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SourceVault() to populate field SourceVault")
		}
		encryptionSet.SourceVault = &sourceVault
	} else {
		encryptionSet.SourceVault = nil
	}

	// No error
	return nil
}

// AssignProperties_To_KeyForDiskEncryptionSet populates the provided destination KeyForDiskEncryptionSet from our KeyForDiskEncryptionSet
func (encryptionSet *KeyForDiskEncryptionSet) AssignProperties_To_KeyForDiskEncryptionSet(destination *storage.KeyForDiskEncryptionSet) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyUrl
	destination.KeyUrl = genruntime.ClonePointerToString(encryptionSet.KeyUrl)

	// KeyUrlFromConfig
	if encryptionSet.KeyUrlFromConfig != nil {
		keyUrlFromConfig := encryptionSet.KeyUrlFromConfig.Copy()
		destination.KeyUrlFromConfig = &keyUrlFromConfig
	} else {
		destination.KeyUrlFromConfig = nil
	}

	// SourceVault
	if encryptionSet.SourceVault != nil {
		var sourceVault storage.SourceVault
		err := encryptionSet.SourceVault.AssignProperties_To_SourceVault(&sourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SourceVault() to populate field SourceVault")
		}
		destination.SourceVault = &sourceVault
	} else {
		destination.SourceVault = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Key Vault Key Url to be used for server side encryption of Managed Disks and Snapshots
type KeyForDiskEncryptionSet_STATUS struct {
	// KeyUrl: Fully versioned Key Url pointing to a key in KeyVault. Version segment of the Url is required regardless of
	// rotationToLatestKeyVersionEnabled value.
	KeyUrl *string `json:"keyUrl,omitempty"`

	// SourceVault: Resource id of the KeyVault containing the key or secret. This property is optional and cannot be used if
	// the KeyVault subscription is not the same as the Disk Encryption Set subscription.
	SourceVault *SourceVault_STATUS `json:"sourceVault,omitempty"`
}

var _ genruntime.FromARMConverter = &KeyForDiskEncryptionSet_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (encryptionSet *KeyForDiskEncryptionSet_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KeyForDiskEncryptionSet_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (encryptionSet *KeyForDiskEncryptionSet_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KeyForDiskEncryptionSet_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KeyForDiskEncryptionSet_STATUS, got %T", armInput)
	}

	// Set property "KeyUrl":
	if typedInput.KeyUrl != nil {
		keyUrl := *typedInput.KeyUrl
		encryptionSet.KeyUrl = &keyUrl
	}

	// Set property "SourceVault":
	if typedInput.SourceVault != nil {
		var sourceVault1 SourceVault_STATUS
		err := sourceVault1.PopulateFromARM(owner, *typedInput.SourceVault)
		if err != nil {
			return err
		}
		sourceVault := sourceVault1
		encryptionSet.SourceVault = &sourceVault
	}

	// No error
	return nil
}

// AssignProperties_From_KeyForDiskEncryptionSet_STATUS populates our KeyForDiskEncryptionSet_STATUS from the provided source KeyForDiskEncryptionSet_STATUS
func (encryptionSet *KeyForDiskEncryptionSet_STATUS) AssignProperties_From_KeyForDiskEncryptionSet_STATUS(source *storage.KeyForDiskEncryptionSet_STATUS) error {

	// KeyUrl
	encryptionSet.KeyUrl = genruntime.ClonePointerToString(source.KeyUrl)

	// SourceVault
	if source.SourceVault != nil {
		var sourceVault SourceVault_STATUS
		err := sourceVault.AssignProperties_From_SourceVault_STATUS(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SourceVault_STATUS() to populate field SourceVault")
		}
		encryptionSet.SourceVault = &sourceVault
	} else {
		encryptionSet.SourceVault = nil
	}

	// No error
	return nil
}

// AssignProperties_To_KeyForDiskEncryptionSet_STATUS populates the provided destination KeyForDiskEncryptionSet_STATUS from our KeyForDiskEncryptionSet_STATUS
func (encryptionSet *KeyForDiskEncryptionSet_STATUS) AssignProperties_To_KeyForDiskEncryptionSet_STATUS(destination *storage.KeyForDiskEncryptionSet_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyUrl
	destination.KeyUrl = genruntime.ClonePointerToString(encryptionSet.KeyUrl)

	// SourceVault
	if encryptionSet.SourceVault != nil {
		var sourceVault storage.SourceVault_STATUS
		err := encryptionSet.SourceVault.AssignProperties_To_SourceVault_STATUS(&sourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SourceVault_STATUS() to populate field SourceVault")
		}
		destination.SourceVault = &sourceVault
	} else {
		destination.SourceVault = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Api error base.
type ApiErrorBase_STATUS struct {
	// Code: The error code.
	Code *string `json:"code,omitempty"`

	// Message: The error message.
	Message *string `json:"message,omitempty"`

	// Target: The target of the particular error.
	Target *string `json:"target,omitempty"`
}

var _ genruntime.FromARMConverter = &ApiErrorBase_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (base *ApiErrorBase_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApiErrorBase_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (base *ApiErrorBase_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApiErrorBase_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApiErrorBase_STATUS, got %T", armInput)
	}

	// Set property "Code":
	if typedInput.Code != nil {
		code := *typedInput.Code
		base.Code = &code
	}

	// Set property "Message":
	if typedInput.Message != nil {
		message := *typedInput.Message
		base.Message = &message
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		base.Target = &target
	}

	// No error
	return nil
}

// AssignProperties_From_ApiErrorBase_STATUS populates our ApiErrorBase_STATUS from the provided source ApiErrorBase_STATUS
func (base *ApiErrorBase_STATUS) AssignProperties_From_ApiErrorBase_STATUS(source *storage.ApiErrorBase_STATUS) error {

	// Code
	base.Code = genruntime.ClonePointerToString(source.Code)

	// Message
	base.Message = genruntime.ClonePointerToString(source.Message)

	// Target
	base.Target = genruntime.ClonePointerToString(source.Target)

	// No error
	return nil
}

// AssignProperties_To_ApiErrorBase_STATUS populates the provided destination ApiErrorBase_STATUS from our ApiErrorBase_STATUS
func (base *ApiErrorBase_STATUS) AssignProperties_To_ApiErrorBase_STATUS(destination *storage.ApiErrorBase_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Code
	destination.Code = genruntime.ClonePointerToString(base.Code)

	// Message
	destination.Message = genruntime.ClonePointerToString(base.Message)

	// Target
	destination.Target = genruntime.ClonePointerToString(base.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"None","SystemAssigned","SystemAssigned, UserAssigned","UserAssigned"}
type EncryptionSetIdentity_Type string

const (
	EncryptionSetIdentity_Type_None                       = EncryptionSetIdentity_Type("None")
	EncryptionSetIdentity_Type_SystemAssigned             = EncryptionSetIdentity_Type("SystemAssigned")
	EncryptionSetIdentity_Type_SystemAssignedUserAssigned = EncryptionSetIdentity_Type("SystemAssigned, UserAssigned")
	EncryptionSetIdentity_Type_UserAssigned               = EncryptionSetIdentity_Type("UserAssigned")
)

// Mapping from string to EncryptionSetIdentity_Type
var encryptionSetIdentity_Type_Values = map[string]EncryptionSetIdentity_Type{
	"none":                         EncryptionSetIdentity_Type_None,
	"systemassigned":               EncryptionSetIdentity_Type_SystemAssigned,
	"systemassigned, userassigned": EncryptionSetIdentity_Type_SystemAssignedUserAssigned,
	"userassigned":                 EncryptionSetIdentity_Type_UserAssigned,
}

type EncryptionSetIdentity_Type_STATUS string

const (
	EncryptionSetIdentity_Type_STATUS_None                       = EncryptionSetIdentity_Type_STATUS("None")
	EncryptionSetIdentity_Type_STATUS_SystemAssigned             = EncryptionSetIdentity_Type_STATUS("SystemAssigned")
	EncryptionSetIdentity_Type_STATUS_SystemAssignedUserAssigned = EncryptionSetIdentity_Type_STATUS("SystemAssigned, UserAssigned")
	EncryptionSetIdentity_Type_STATUS_UserAssigned               = EncryptionSetIdentity_Type_STATUS("UserAssigned")
)

// Mapping from string to EncryptionSetIdentity_Type_STATUS
var encryptionSetIdentity_Type_STATUS_Values = map[string]EncryptionSetIdentity_Type_STATUS{
	"none":                         EncryptionSetIdentity_Type_STATUS_None,
	"systemassigned":               EncryptionSetIdentity_Type_STATUS_SystemAssigned,
	"systemassigned, userassigned": EncryptionSetIdentity_Type_STATUS_SystemAssignedUserAssigned,
	"userassigned":                 EncryptionSetIdentity_Type_STATUS_UserAssigned,
}

type EncryptionSetIdentity_UserAssignedIdentities_STATUS struct {
	// ClientId: The client id of user assigned identity.
	ClientId *string `json:"clientId,omitempty"`

	// PrincipalId: The principal id of user assigned identity.
	PrincipalId *string `json:"principalId,omitempty"`
}

var _ genruntime.FromARMConverter = &EncryptionSetIdentity_UserAssignedIdentities_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identities *EncryptionSetIdentity_UserAssignedIdentities_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EncryptionSetIdentity_UserAssignedIdentities_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identities *EncryptionSetIdentity_UserAssignedIdentities_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EncryptionSetIdentity_UserAssignedIdentities_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EncryptionSetIdentity_UserAssignedIdentities_STATUS, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		identities.ClientId = &clientId
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identities.PrincipalId = &principalId
	}

	// No error
	return nil
}

// AssignProperties_From_EncryptionSetIdentity_UserAssignedIdentities_STATUS populates our EncryptionSetIdentity_UserAssignedIdentities_STATUS from the provided source EncryptionSetIdentity_UserAssignedIdentities_STATUS
func (identities *EncryptionSetIdentity_UserAssignedIdentities_STATUS) AssignProperties_From_EncryptionSetIdentity_UserAssignedIdentities_STATUS(source *storage.EncryptionSetIdentity_UserAssignedIdentities_STATUS) error {

	// ClientId
	identities.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// PrincipalId
	identities.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// No error
	return nil
}

// AssignProperties_To_EncryptionSetIdentity_UserAssignedIdentities_STATUS populates the provided destination EncryptionSetIdentity_UserAssignedIdentities_STATUS from our EncryptionSetIdentity_UserAssignedIdentities_STATUS
func (identities *EncryptionSetIdentity_UserAssignedIdentities_STATUS) AssignProperties_To_EncryptionSetIdentity_UserAssignedIdentities_STATUS(destination *storage.EncryptionSetIdentity_UserAssignedIdentities_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identities.ClientId)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identities.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Inner error details.
type InnerError_STATUS struct {
	// Errordetail: The internal error message or exception dump.
	Errordetail *string `json:"errordetail,omitempty"`

	// Exceptiontype: The exception type.
	Exceptiontype *string `json:"exceptiontype,omitempty"`
}

var _ genruntime.FromARMConverter = &InnerError_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (error *InnerError_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.InnerError_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (error *InnerError_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.InnerError_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.InnerError_STATUS, got %T", armInput)
	}

	// Set property "Errordetail":
	if typedInput.Errordetail != nil {
		errordetail := *typedInput.Errordetail
		error.Errordetail = &errordetail
	}

	// Set property "Exceptiontype":
	if typedInput.Exceptiontype != nil {
		exceptiontype := *typedInput.Exceptiontype
		error.Exceptiontype = &exceptiontype
	}

	// No error
	return nil
}

// AssignProperties_From_InnerError_STATUS populates our InnerError_STATUS from the provided source InnerError_STATUS
func (error *InnerError_STATUS) AssignProperties_From_InnerError_STATUS(source *storage.InnerError_STATUS) error {

	// Errordetail
	error.Errordetail = genruntime.ClonePointerToString(source.Errordetail)

	// Exceptiontype
	error.Exceptiontype = genruntime.ClonePointerToString(source.Exceptiontype)

	// No error
	return nil
}

// AssignProperties_To_InnerError_STATUS populates the provided destination InnerError_STATUS from our InnerError_STATUS
func (error *InnerError_STATUS) AssignProperties_To_InnerError_STATUS(destination *storage.InnerError_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Errordetail
	destination.Errordetail = genruntime.ClonePointerToString(error.Errordetail)

	// Exceptiontype
	destination.Exceptiontype = genruntime.ClonePointerToString(error.Exceptiontype)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The vault id is an Azure Resource Manager Resource id in the form
// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}
type SourceVault struct {
	// Reference: Resource Id
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &SourceVault{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (vault *SourceVault) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if vault == nil {
		return nil, nil
	}
	result := &arm.SourceVault{}

	// Set property "Id":
	if vault.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*vault.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (vault *SourceVault) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SourceVault{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (vault *SourceVault) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(arm.SourceVault)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SourceVault, got %T", armInput)
	}

	// no assignment for property "Reference"

	// No error
	return nil
}

// AssignProperties_From_SourceVault populates our SourceVault from the provided source SourceVault
func (vault *SourceVault) AssignProperties_From_SourceVault(source *storage.SourceVault) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		vault.Reference = &reference
	} else {
		vault.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SourceVault populates the provided destination SourceVault from our SourceVault
func (vault *SourceVault) AssignProperties_To_SourceVault(destination *storage.SourceVault) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if vault.Reference != nil {
		reference := vault.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The vault id is an Azure Resource Manager Resource id in the form
// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}
type SourceVault_STATUS struct {
	// Id: Resource Id
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &SourceVault_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (vault *SourceVault_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SourceVault_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (vault *SourceVault_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SourceVault_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SourceVault_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		vault.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_SourceVault_STATUS populates our SourceVault_STATUS from the provided source SourceVault_STATUS
func (vault *SourceVault_STATUS) AssignProperties_From_SourceVault_STATUS(source *storage.SourceVault_STATUS) error {

	// Id
	vault.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_SourceVault_STATUS populates the provided destination SourceVault_STATUS from our SourceVault_STATUS
func (vault *SourceVault_STATUS) AssignProperties_To_SourceVault_STATUS(destination *storage.SourceVault_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(vault.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Information about the user assigned identity for the resource
type UserAssignedIdentityDetails struct {
	Reference genruntime.ResourceReference `armReference:"Reference" json:"reference,omitempty"`
}

// AssignProperties_From_UserAssignedIdentityDetails populates our UserAssignedIdentityDetails from the provided source UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_From_UserAssignedIdentityDetails(source *storage.UserAssignedIdentityDetails) error {

	// Reference
	details.Reference = source.Reference.Copy()

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentityDetails populates the provided destination UserAssignedIdentityDetails from our UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_To_UserAssignedIdentityDetails(destination *storage.UserAssignedIdentityDetails) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	destination.Reference = details.Reference.Copy()

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&DiskEncryptionSet{}, &DiskEncryptionSetList{})
}
