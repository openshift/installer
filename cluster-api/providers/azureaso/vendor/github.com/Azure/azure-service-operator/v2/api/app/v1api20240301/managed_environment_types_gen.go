// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20240301

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/app/v1api20240301/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/app/v1api20240301/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/rotisserie/eris"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /app/resource-manager/Microsoft.App/stable/2024-03-01/ManagedEnvironments.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/managedEnvironments/{environmentName}
type ManagedEnvironment struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ManagedEnvironment_Spec   `json:"spec,omitempty"`
	Status            ManagedEnvironment_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &ManagedEnvironment{}

// GetConditions returns the conditions of the resource
func (environment *ManagedEnvironment) GetConditions() conditions.Conditions {
	return environment.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (environment *ManagedEnvironment) SetConditions(conditions conditions.Conditions) {
	environment.Status.Conditions = conditions
}

var _ conversion.Convertible = &ManagedEnvironment{}

// ConvertFrom populates our ManagedEnvironment from the provided hub ManagedEnvironment
func (environment *ManagedEnvironment) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.ManagedEnvironment)
	if !ok {
		return fmt.Errorf("expected app/v1api20240301/storage/ManagedEnvironment but received %T instead", hub)
	}

	return environment.AssignProperties_From_ManagedEnvironment(source)
}

// ConvertTo populates the provided hub ManagedEnvironment from our ManagedEnvironment
func (environment *ManagedEnvironment) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.ManagedEnvironment)
	if !ok {
		return fmt.Errorf("expected app/v1api20240301/storage/ManagedEnvironment but received %T instead", hub)
	}

	return environment.AssignProperties_To_ManagedEnvironment(destination)
}

var _ configmaps.Exporter = &ManagedEnvironment{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (environment *ManagedEnvironment) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if environment.Spec.OperatorSpec == nil {
		return nil
	}
	return environment.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &ManagedEnvironment{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (environment *ManagedEnvironment) SecretDestinationExpressions() []*core.DestinationExpression {
	if environment.Spec.OperatorSpec == nil {
		return nil
	}
	return environment.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &ManagedEnvironment{}

// InitializeSpec initializes the spec for this resource from the given status
func (environment *ManagedEnvironment) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*ManagedEnvironment_STATUS); ok {
		return environment.Spec.Initialize_From_ManagedEnvironment_STATUS(s)
	}

	return fmt.Errorf("expected Status of type ManagedEnvironment_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &ManagedEnvironment{}

// AzureName returns the Azure name of the resource
func (environment *ManagedEnvironment) AzureName() string {
	return environment.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2024-03-01"
func (environment ManagedEnvironment) GetAPIVersion() string {
	return "2024-03-01"
}

// GetResourceScope returns the scope of the resource
func (environment *ManagedEnvironment) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (environment *ManagedEnvironment) GetSpec() genruntime.ConvertibleSpec {
	return &environment.Spec
}

// GetStatus returns the status of this resource
func (environment *ManagedEnvironment) GetStatus() genruntime.ConvertibleStatus {
	return &environment.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (environment *ManagedEnvironment) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.App/managedEnvironments"
func (environment *ManagedEnvironment) GetType() string {
	return "Microsoft.App/managedEnvironments"
}

// NewEmptyStatus returns a new empty (blank) status
func (environment *ManagedEnvironment) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &ManagedEnvironment_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (environment *ManagedEnvironment) Owner() *genruntime.ResourceReference {
	if environment.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(environment.Spec)
	return environment.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (environment *ManagedEnvironment) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*ManagedEnvironment_STATUS); ok {
		environment.Status = *st
		return nil
	}

	// Convert status to required version
	var st ManagedEnvironment_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	environment.Status = st
	return nil
}

// AssignProperties_From_ManagedEnvironment populates our ManagedEnvironment from the provided source ManagedEnvironment
func (environment *ManagedEnvironment) AssignProperties_From_ManagedEnvironment(source *storage.ManagedEnvironment) error {

	// ObjectMeta
	environment.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec ManagedEnvironment_Spec
	err := spec.AssignProperties_From_ManagedEnvironment_Spec(&source.Spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_ManagedEnvironment_Spec() to populate field Spec")
	}
	environment.Spec = spec

	// Status
	var status ManagedEnvironment_STATUS
	err = status.AssignProperties_From_ManagedEnvironment_STATUS(&source.Status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_ManagedEnvironment_STATUS() to populate field Status")
	}
	environment.Status = status

	// No error
	return nil
}

// AssignProperties_To_ManagedEnvironment populates the provided destination ManagedEnvironment from our ManagedEnvironment
func (environment *ManagedEnvironment) AssignProperties_To_ManagedEnvironment(destination *storage.ManagedEnvironment) error {

	// ObjectMeta
	destination.ObjectMeta = *environment.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.ManagedEnvironment_Spec
	err := environment.Spec.AssignProperties_To_ManagedEnvironment_Spec(&spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_ManagedEnvironment_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.ManagedEnvironment_STATUS
	err = environment.Status.AssignProperties_To_ManagedEnvironment_STATUS(&status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_ManagedEnvironment_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (environment *ManagedEnvironment) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: environment.Spec.OriginalVersion(),
		Kind:    "ManagedEnvironment",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /app/resource-manager/Microsoft.App/stable/2024-03-01/ManagedEnvironments.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/managedEnvironments/{environmentName}
type ManagedEnvironmentList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ManagedEnvironment `json:"items"`
}

type ManagedEnvironment_Spec struct {
	// AppLogsConfiguration: Cluster configuration which enables the log daemon to export app logs to configured destination.
	AppLogsConfiguration *AppLogsConfiguration `json:"appLogsConfiguration,omitempty"`

	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// CustomDomainConfiguration: Custom domain configuration for the environment
	CustomDomainConfiguration *CustomDomainConfiguration `json:"customDomainConfiguration,omitempty"`

	// DaprAIConnectionString: Application Insights connection string used by Dapr to export Service to Service communication
	// telemetry
	DaprAIConnectionString *genruntime.SecretReference `json:"daprAIConnectionString,omitempty"`

	// DaprAIInstrumentationKey: Azure Monitor instrumentation key used by Dapr to export Service to Service communication
	// telemetry
	DaprAIInstrumentationKey *genruntime.SecretReference `json:"daprAIInstrumentationKey,omitempty"`

	// InfrastructureResourceGroup: Name of the platform-managed resource group created for the Managed Environment to host
	// infrastructure resources. If a subnet ID is provided, this resource group will be created in the same subscription as
	// the subnet.
	InfrastructureResourceGroup *string `json:"infrastructureResourceGroup,omitempty"`

	// Kind: Kind of the Environment.
	Kind *string `json:"kind,omitempty"`

	// +kubebuilder:validation:Required
	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *ManagedEnvironmentOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// PeerAuthentication: Peer authentication settings for the Managed Environment
	PeerAuthentication *ManagedEnvironment_Properties_PeerAuthentication_Spec `json:"peerAuthentication,omitempty"`

	// PeerTrafficConfiguration: Peer traffic settings for the Managed Environment
	PeerTrafficConfiguration *ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec `json:"peerTrafficConfiguration,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// VnetConfiguration: Vnet configuration for the environment
	VnetConfiguration *VnetConfiguration `json:"vnetConfiguration,omitempty"`

	// WorkloadProfiles: Workload profiles configured for the Managed Environment.
	WorkloadProfiles []WorkloadProfile `json:"workloadProfiles,omitempty"`

	// ZoneRedundant: Whether or not this Managed Environment is zone-redundant.
	ZoneRedundant *bool `json:"zoneRedundant,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedEnvironment_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (environment *ManagedEnvironment_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if environment == nil {
		return nil, nil
	}
	result := &arm.ManagedEnvironment_Spec{}

	// Set property "Kind":
	if environment.Kind != nil {
		kind := *environment.Kind
		result.Kind = &kind
	}

	// Set property "Location":
	if environment.Location != nil {
		location := *environment.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if environment.AppLogsConfiguration != nil ||
		environment.CustomDomainConfiguration != nil ||
		environment.DaprAIConnectionString != nil ||
		environment.DaprAIInstrumentationKey != nil ||
		environment.InfrastructureResourceGroup != nil ||
		environment.PeerAuthentication != nil ||
		environment.PeerTrafficConfiguration != nil ||
		environment.VnetConfiguration != nil ||
		environment.WorkloadProfiles != nil ||
		environment.ZoneRedundant != nil {
		result.Properties = &arm.ManagedEnvironment_Properties_Spec{}
	}
	if environment.AppLogsConfiguration != nil {
		appLogsConfiguration_ARM, err := (*environment.AppLogsConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		appLogsConfiguration := *appLogsConfiguration_ARM.(*arm.AppLogsConfiguration)
		result.Properties.AppLogsConfiguration = &appLogsConfiguration
	}
	if environment.CustomDomainConfiguration != nil {
		customDomainConfiguration_ARM, err := (*environment.CustomDomainConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		customDomainConfiguration := *customDomainConfiguration_ARM.(*arm.CustomDomainConfiguration)
		result.Properties.CustomDomainConfiguration = &customDomainConfiguration
	}
	if environment.DaprAIConnectionString != nil {
		daprAIConnectionStringSecret, err := resolved.ResolvedSecrets.Lookup(*environment.DaprAIConnectionString)
		if err != nil {
			return nil, eris.Wrap(err, "looking up secret for property DaprAIConnectionString")
		}
		daprAIConnectionString := daprAIConnectionStringSecret
		result.Properties.DaprAIConnectionString = &daprAIConnectionString
	}
	if environment.DaprAIInstrumentationKey != nil {
		daprAIInstrumentationKeySecret, err := resolved.ResolvedSecrets.Lookup(*environment.DaprAIInstrumentationKey)
		if err != nil {
			return nil, eris.Wrap(err, "looking up secret for property DaprAIInstrumentationKey")
		}
		daprAIInstrumentationKey := daprAIInstrumentationKeySecret
		result.Properties.DaprAIInstrumentationKey = &daprAIInstrumentationKey
	}
	if environment.InfrastructureResourceGroup != nil {
		infrastructureResourceGroup := *environment.InfrastructureResourceGroup
		result.Properties.InfrastructureResourceGroup = &infrastructureResourceGroup
	}
	if environment.PeerAuthentication != nil {
		peerAuthentication_ARM, err := (*environment.PeerAuthentication).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		peerAuthentication := *peerAuthentication_ARM.(*arm.ManagedEnvironment_Properties_PeerAuthentication_Spec)
		result.Properties.PeerAuthentication = &peerAuthentication
	}
	if environment.PeerTrafficConfiguration != nil {
		peerTrafficConfiguration_ARM, err := (*environment.PeerTrafficConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		peerTrafficConfiguration := *peerTrafficConfiguration_ARM.(*arm.ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec)
		result.Properties.PeerTrafficConfiguration = &peerTrafficConfiguration
	}
	if environment.VnetConfiguration != nil {
		vnetConfiguration_ARM, err := (*environment.VnetConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		vnetConfiguration := *vnetConfiguration_ARM.(*arm.VnetConfiguration)
		result.Properties.VnetConfiguration = &vnetConfiguration
	}
	for _, item := range environment.WorkloadProfiles {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.WorkloadProfiles = append(result.Properties.WorkloadProfiles, *item_ARM.(*arm.WorkloadProfile))
	}
	if environment.ZoneRedundant != nil {
		zoneRedundant := *environment.ZoneRedundant
		result.Properties.ZoneRedundant = &zoneRedundant
	}

	// Set property "Tags":
	if environment.Tags != nil {
		result.Tags = make(map[string]string, len(environment.Tags))
		for key, value := range environment.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (environment *ManagedEnvironment_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedEnvironment_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (environment *ManagedEnvironment_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedEnvironment_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedEnvironment_Spec, got %T", armInput)
	}

	// Set property "AppLogsConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AppLogsConfiguration != nil {
			var appLogsConfiguration1 AppLogsConfiguration
			err := appLogsConfiguration1.PopulateFromARM(owner, *typedInput.Properties.AppLogsConfiguration)
			if err != nil {
				return err
			}
			appLogsConfiguration := appLogsConfiguration1
			environment.AppLogsConfiguration = &appLogsConfiguration
		}
	}

	// Set property "AzureName":
	environment.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "CustomDomainConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CustomDomainConfiguration != nil {
			var customDomainConfiguration1 CustomDomainConfiguration
			err := customDomainConfiguration1.PopulateFromARM(owner, *typedInput.Properties.CustomDomainConfiguration)
			if err != nil {
				return err
			}
			customDomainConfiguration := customDomainConfiguration1
			environment.CustomDomainConfiguration = &customDomainConfiguration
		}
	}

	// no assignment for property "DaprAIConnectionString"

	// no assignment for property "DaprAIInstrumentationKey"

	// Set property "InfrastructureResourceGroup":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.InfrastructureResourceGroup != nil {
			infrastructureResourceGroup := *typedInput.Properties.InfrastructureResourceGroup
			environment.InfrastructureResourceGroup = &infrastructureResourceGroup
		}
	}

	// Set property "Kind":
	if typedInput.Kind != nil {
		kind := *typedInput.Kind
		environment.Kind = &kind
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		environment.Location = &location
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	environment.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "PeerAuthentication":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PeerAuthentication != nil {
			var peerAuthentication1 ManagedEnvironment_Properties_PeerAuthentication_Spec
			err := peerAuthentication1.PopulateFromARM(owner, *typedInput.Properties.PeerAuthentication)
			if err != nil {
				return err
			}
			peerAuthentication := peerAuthentication1
			environment.PeerAuthentication = &peerAuthentication
		}
	}

	// Set property "PeerTrafficConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PeerTrafficConfiguration != nil {
			var peerTrafficConfiguration1 ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec
			err := peerTrafficConfiguration1.PopulateFromARM(owner, *typedInput.Properties.PeerTrafficConfiguration)
			if err != nil {
				return err
			}
			peerTrafficConfiguration := peerTrafficConfiguration1
			environment.PeerTrafficConfiguration = &peerTrafficConfiguration
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		environment.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			environment.Tags[key] = value
		}
	}

	// Set property "VnetConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VnetConfiguration != nil {
			var vnetConfiguration1 VnetConfiguration
			err := vnetConfiguration1.PopulateFromARM(owner, *typedInput.Properties.VnetConfiguration)
			if err != nil {
				return err
			}
			vnetConfiguration := vnetConfiguration1
			environment.VnetConfiguration = &vnetConfiguration
		}
	}

	// Set property "WorkloadProfiles":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.WorkloadProfiles {
			var item1 WorkloadProfile
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			environment.WorkloadProfiles = append(environment.WorkloadProfiles, item1)
		}
	}

	// Set property "ZoneRedundant":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ZoneRedundant != nil {
			zoneRedundant := *typedInput.Properties.ZoneRedundant
			environment.ZoneRedundant = &zoneRedundant
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &ManagedEnvironment_Spec{}

// ConvertSpecFrom populates our ManagedEnvironment_Spec from the provided source
func (environment *ManagedEnvironment_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.ManagedEnvironment_Spec)
	if ok {
		// Populate our instance from source
		return environment.AssignProperties_From_ManagedEnvironment_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.ManagedEnvironment_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = environment.AssignProperties_From_ManagedEnvironment_Spec(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our ManagedEnvironment_Spec
func (environment *ManagedEnvironment_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.ManagedEnvironment_Spec)
	if ok {
		// Populate destination from our instance
		return environment.AssignProperties_To_ManagedEnvironment_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.ManagedEnvironment_Spec{}
	err := environment.AssignProperties_To_ManagedEnvironment_Spec(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_ManagedEnvironment_Spec populates our ManagedEnvironment_Spec from the provided source ManagedEnvironment_Spec
func (environment *ManagedEnvironment_Spec) AssignProperties_From_ManagedEnvironment_Spec(source *storage.ManagedEnvironment_Spec) error {

	// AppLogsConfiguration
	if source.AppLogsConfiguration != nil {
		var appLogsConfiguration AppLogsConfiguration
		err := appLogsConfiguration.AssignProperties_From_AppLogsConfiguration(source.AppLogsConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AppLogsConfiguration() to populate field AppLogsConfiguration")
		}
		environment.AppLogsConfiguration = &appLogsConfiguration
	} else {
		environment.AppLogsConfiguration = nil
	}

	// AzureName
	environment.AzureName = source.AzureName

	// CustomDomainConfiguration
	if source.CustomDomainConfiguration != nil {
		var customDomainConfiguration CustomDomainConfiguration
		err := customDomainConfiguration.AssignProperties_From_CustomDomainConfiguration(source.CustomDomainConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CustomDomainConfiguration() to populate field CustomDomainConfiguration")
		}
		environment.CustomDomainConfiguration = &customDomainConfiguration
	} else {
		environment.CustomDomainConfiguration = nil
	}

	// DaprAIConnectionString
	if source.DaprAIConnectionString != nil {
		daprAIConnectionString := source.DaprAIConnectionString.Copy()
		environment.DaprAIConnectionString = &daprAIConnectionString
	} else {
		environment.DaprAIConnectionString = nil
	}

	// DaprAIInstrumentationKey
	if source.DaprAIInstrumentationKey != nil {
		daprAIInstrumentationKey := source.DaprAIInstrumentationKey.Copy()
		environment.DaprAIInstrumentationKey = &daprAIInstrumentationKey
	} else {
		environment.DaprAIInstrumentationKey = nil
	}

	// InfrastructureResourceGroup
	environment.InfrastructureResourceGroup = genruntime.ClonePointerToString(source.InfrastructureResourceGroup)

	// Kind
	environment.Kind = genruntime.ClonePointerToString(source.Kind)

	// Location
	environment.Location = genruntime.ClonePointerToString(source.Location)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec ManagedEnvironmentOperatorSpec
		err := operatorSpec.AssignProperties_From_ManagedEnvironmentOperatorSpec(source.OperatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedEnvironmentOperatorSpec() to populate field OperatorSpec")
		}
		environment.OperatorSpec = &operatorSpec
	} else {
		environment.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		environment.Owner = &owner
	} else {
		environment.Owner = nil
	}

	// PeerAuthentication
	if source.PeerAuthentication != nil {
		var peerAuthentication ManagedEnvironment_Properties_PeerAuthentication_Spec
		err := peerAuthentication.AssignProperties_From_ManagedEnvironment_Properties_PeerAuthentication_Spec(source.PeerAuthentication)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedEnvironment_Properties_PeerAuthentication_Spec() to populate field PeerAuthentication")
		}
		environment.PeerAuthentication = &peerAuthentication
	} else {
		environment.PeerAuthentication = nil
	}

	// PeerTrafficConfiguration
	if source.PeerTrafficConfiguration != nil {
		var peerTrafficConfiguration ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec
		err := peerTrafficConfiguration.AssignProperties_From_ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec(source.PeerTrafficConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec() to populate field PeerTrafficConfiguration")
		}
		environment.PeerTrafficConfiguration = &peerTrafficConfiguration
	} else {
		environment.PeerTrafficConfiguration = nil
	}

	// Tags
	environment.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// VnetConfiguration
	if source.VnetConfiguration != nil {
		var vnetConfiguration VnetConfiguration
		err := vnetConfiguration.AssignProperties_From_VnetConfiguration(source.VnetConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VnetConfiguration() to populate field VnetConfiguration")
		}
		environment.VnetConfiguration = &vnetConfiguration
	} else {
		environment.VnetConfiguration = nil
	}

	// WorkloadProfiles
	if source.WorkloadProfiles != nil {
		workloadProfileList := make([]WorkloadProfile, len(source.WorkloadProfiles))
		for workloadProfileIndex, workloadProfileItem := range source.WorkloadProfiles {
			// Shadow the loop variable to avoid aliasing
			workloadProfileItem := workloadProfileItem
			var workloadProfile WorkloadProfile
			err := workloadProfile.AssignProperties_From_WorkloadProfile(&workloadProfileItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_WorkloadProfile() to populate field WorkloadProfiles")
			}
			workloadProfileList[workloadProfileIndex] = workloadProfile
		}
		environment.WorkloadProfiles = workloadProfileList
	} else {
		environment.WorkloadProfiles = nil
	}

	// ZoneRedundant
	if source.ZoneRedundant != nil {
		zoneRedundant := *source.ZoneRedundant
		environment.ZoneRedundant = &zoneRedundant
	} else {
		environment.ZoneRedundant = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedEnvironment_Spec populates the provided destination ManagedEnvironment_Spec from our ManagedEnvironment_Spec
func (environment *ManagedEnvironment_Spec) AssignProperties_To_ManagedEnvironment_Spec(destination *storage.ManagedEnvironment_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AppLogsConfiguration
	if environment.AppLogsConfiguration != nil {
		var appLogsConfiguration storage.AppLogsConfiguration
		err := environment.AppLogsConfiguration.AssignProperties_To_AppLogsConfiguration(&appLogsConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AppLogsConfiguration() to populate field AppLogsConfiguration")
		}
		destination.AppLogsConfiguration = &appLogsConfiguration
	} else {
		destination.AppLogsConfiguration = nil
	}

	// AzureName
	destination.AzureName = environment.AzureName

	// CustomDomainConfiguration
	if environment.CustomDomainConfiguration != nil {
		var customDomainConfiguration storage.CustomDomainConfiguration
		err := environment.CustomDomainConfiguration.AssignProperties_To_CustomDomainConfiguration(&customDomainConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CustomDomainConfiguration() to populate field CustomDomainConfiguration")
		}
		destination.CustomDomainConfiguration = &customDomainConfiguration
	} else {
		destination.CustomDomainConfiguration = nil
	}

	// DaprAIConnectionString
	if environment.DaprAIConnectionString != nil {
		daprAIConnectionString := environment.DaprAIConnectionString.Copy()
		destination.DaprAIConnectionString = &daprAIConnectionString
	} else {
		destination.DaprAIConnectionString = nil
	}

	// DaprAIInstrumentationKey
	if environment.DaprAIInstrumentationKey != nil {
		daprAIInstrumentationKey := environment.DaprAIInstrumentationKey.Copy()
		destination.DaprAIInstrumentationKey = &daprAIInstrumentationKey
	} else {
		destination.DaprAIInstrumentationKey = nil
	}

	// InfrastructureResourceGroup
	destination.InfrastructureResourceGroup = genruntime.ClonePointerToString(environment.InfrastructureResourceGroup)

	// Kind
	destination.Kind = genruntime.ClonePointerToString(environment.Kind)

	// Location
	destination.Location = genruntime.ClonePointerToString(environment.Location)

	// OperatorSpec
	if environment.OperatorSpec != nil {
		var operatorSpec storage.ManagedEnvironmentOperatorSpec
		err := environment.OperatorSpec.AssignProperties_To_ManagedEnvironmentOperatorSpec(&operatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedEnvironmentOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = environment.OriginalVersion()

	// Owner
	if environment.Owner != nil {
		owner := environment.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// PeerAuthentication
	if environment.PeerAuthentication != nil {
		var peerAuthentication storage.ManagedEnvironment_Properties_PeerAuthentication_Spec
		err := environment.PeerAuthentication.AssignProperties_To_ManagedEnvironment_Properties_PeerAuthentication_Spec(&peerAuthentication)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedEnvironment_Properties_PeerAuthentication_Spec() to populate field PeerAuthentication")
		}
		destination.PeerAuthentication = &peerAuthentication
	} else {
		destination.PeerAuthentication = nil
	}

	// PeerTrafficConfiguration
	if environment.PeerTrafficConfiguration != nil {
		var peerTrafficConfiguration storage.ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec
		err := environment.PeerTrafficConfiguration.AssignProperties_To_ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec(&peerTrafficConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec() to populate field PeerTrafficConfiguration")
		}
		destination.PeerTrafficConfiguration = &peerTrafficConfiguration
	} else {
		destination.PeerTrafficConfiguration = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(environment.Tags)

	// VnetConfiguration
	if environment.VnetConfiguration != nil {
		var vnetConfiguration storage.VnetConfiguration
		err := environment.VnetConfiguration.AssignProperties_To_VnetConfiguration(&vnetConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VnetConfiguration() to populate field VnetConfiguration")
		}
		destination.VnetConfiguration = &vnetConfiguration
	} else {
		destination.VnetConfiguration = nil
	}

	// WorkloadProfiles
	if environment.WorkloadProfiles != nil {
		workloadProfileList := make([]storage.WorkloadProfile, len(environment.WorkloadProfiles))
		for workloadProfileIndex, workloadProfileItem := range environment.WorkloadProfiles {
			// Shadow the loop variable to avoid aliasing
			workloadProfileItem := workloadProfileItem
			var workloadProfile storage.WorkloadProfile
			err := workloadProfileItem.AssignProperties_To_WorkloadProfile(&workloadProfile)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_WorkloadProfile() to populate field WorkloadProfiles")
			}
			workloadProfileList[workloadProfileIndex] = workloadProfile
		}
		destination.WorkloadProfiles = workloadProfileList
	} else {
		destination.WorkloadProfiles = nil
	}

	// ZoneRedundant
	if environment.ZoneRedundant != nil {
		zoneRedundant := *environment.ZoneRedundant
		destination.ZoneRedundant = &zoneRedundant
	} else {
		destination.ZoneRedundant = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ManagedEnvironment_STATUS populates our ManagedEnvironment_Spec from the provided source ManagedEnvironment_STATUS
func (environment *ManagedEnvironment_Spec) Initialize_From_ManagedEnvironment_STATUS(source *ManagedEnvironment_STATUS) error {

	// AppLogsConfiguration
	if source.AppLogsConfiguration != nil {
		var appLogsConfiguration AppLogsConfiguration
		err := appLogsConfiguration.Initialize_From_AppLogsConfiguration_STATUS(source.AppLogsConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_AppLogsConfiguration_STATUS() to populate field AppLogsConfiguration")
		}
		environment.AppLogsConfiguration = &appLogsConfiguration
	} else {
		environment.AppLogsConfiguration = nil
	}

	// CustomDomainConfiguration
	if source.CustomDomainConfiguration != nil {
		var customDomainConfiguration CustomDomainConfiguration
		err := customDomainConfiguration.Initialize_From_CustomDomainConfiguration_STATUS(source.CustomDomainConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_CustomDomainConfiguration_STATUS() to populate field CustomDomainConfiguration")
		}
		environment.CustomDomainConfiguration = &customDomainConfiguration
	} else {
		environment.CustomDomainConfiguration = nil
	}

	// InfrastructureResourceGroup
	environment.InfrastructureResourceGroup = genruntime.ClonePointerToString(source.InfrastructureResourceGroup)

	// Kind
	environment.Kind = genruntime.ClonePointerToString(source.Kind)

	// Location
	environment.Location = genruntime.ClonePointerToString(source.Location)

	// PeerAuthentication
	if source.PeerAuthentication != nil {
		var peerAuthentication ManagedEnvironment_Properties_PeerAuthentication_Spec
		err := peerAuthentication.Initialize_From_ManagedEnvironment_Properties_PeerAuthentication_STATUS(source.PeerAuthentication)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ManagedEnvironment_Properties_PeerAuthentication_STATUS() to populate field PeerAuthentication")
		}
		environment.PeerAuthentication = &peerAuthentication
	} else {
		environment.PeerAuthentication = nil
	}

	// PeerTrafficConfiguration
	if source.PeerTrafficConfiguration != nil {
		var peerTrafficConfiguration ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec
		err := peerTrafficConfiguration.Initialize_From_ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS(source.PeerTrafficConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS() to populate field PeerTrafficConfiguration")
		}
		environment.PeerTrafficConfiguration = &peerTrafficConfiguration
	} else {
		environment.PeerTrafficConfiguration = nil
	}

	// Tags
	environment.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// VnetConfiguration
	if source.VnetConfiguration != nil {
		var vnetConfiguration VnetConfiguration
		err := vnetConfiguration.Initialize_From_VnetConfiguration_STATUS(source.VnetConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_VnetConfiguration_STATUS() to populate field VnetConfiguration")
		}
		environment.VnetConfiguration = &vnetConfiguration
	} else {
		environment.VnetConfiguration = nil
	}

	// WorkloadProfiles
	if source.WorkloadProfiles != nil {
		workloadProfileList := make([]WorkloadProfile, len(source.WorkloadProfiles))
		for workloadProfileIndex, workloadProfileItem := range source.WorkloadProfiles {
			// Shadow the loop variable to avoid aliasing
			workloadProfileItem := workloadProfileItem
			var workloadProfile WorkloadProfile
			err := workloadProfile.Initialize_From_WorkloadProfile_STATUS(&workloadProfileItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_WorkloadProfile_STATUS() to populate field WorkloadProfiles")
			}
			workloadProfileList[workloadProfileIndex] = workloadProfile
		}
		environment.WorkloadProfiles = workloadProfileList
	} else {
		environment.WorkloadProfiles = nil
	}

	// ZoneRedundant
	if source.ZoneRedundant != nil {
		zoneRedundant := *source.ZoneRedundant
		environment.ZoneRedundant = &zoneRedundant
	} else {
		environment.ZoneRedundant = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (environment *ManagedEnvironment_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (environment *ManagedEnvironment_Spec) SetAzureName(azureName string) {
	environment.AzureName = azureName
}

// An environment for hosting container apps
type ManagedEnvironment_STATUS struct {
	// AppLogsConfiguration: Cluster configuration which enables the log daemon to export app logs to configured destination.
	AppLogsConfiguration *AppLogsConfiguration_STATUS `json:"appLogsConfiguration,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// CustomDomainConfiguration: Custom domain configuration for the environment
	CustomDomainConfiguration *CustomDomainConfiguration_STATUS `json:"customDomainConfiguration,omitempty"`

	// DaprConfiguration: The configuration of Dapr component.
	DaprConfiguration *DaprConfiguration_STATUS `json:"daprConfiguration,omitempty"`

	// DefaultDomain: Default Domain Name for the cluster
	DefaultDomain *string `json:"defaultDomain,omitempty"`

	// DeploymentErrors: Any errors that occurred during deployment or deployment validation
	DeploymentErrors *string `json:"deploymentErrors,omitempty"`

	// EventStreamEndpoint: The endpoint of the eventstream of the Environment.
	EventStreamEndpoint *string `json:"eventStreamEndpoint,omitempty"`

	// Id: Fully qualified resource ID for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`

	// InfrastructureResourceGroup: Name of the platform-managed resource group created for the Managed Environment to host
	// infrastructure resources. If a subnet ID is provided, this resource group will be created in the same subscription as
	// the subnet.
	InfrastructureResourceGroup *string `json:"infrastructureResourceGroup,omitempty"`

	// KedaConfiguration: The configuration of Keda component.
	KedaConfiguration *KedaConfiguration_STATUS `json:"kedaConfiguration,omitempty"`

	// Kind: Kind of the Environment.
	Kind *string `json:"kind,omitempty"`

	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// PeerAuthentication: Peer authentication settings for the Managed Environment
	PeerAuthentication *ManagedEnvironment_Properties_PeerAuthentication_STATUS `json:"peerAuthentication,omitempty"`

	// PeerTrafficConfiguration: Peer traffic settings for the Managed Environment
	PeerTrafficConfiguration *ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS `json:"peerTrafficConfiguration,omitempty"`

	// ProvisioningState: Provisioning state of the Environment.
	ProvisioningState *ManagedEnvironment_Properties_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// StaticIp: Static IP of the Environment
	StaticIp *string `json:"staticIp,omitempty"`

	// SystemData: Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData_STATUS `json:"systemData,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`

	// VnetConfiguration: Vnet configuration for the environment
	VnetConfiguration *VnetConfiguration_STATUS `json:"vnetConfiguration,omitempty"`

	// WorkloadProfiles: Workload profiles configured for the Managed Environment.
	WorkloadProfiles []WorkloadProfile_STATUS `json:"workloadProfiles,omitempty"`

	// ZoneRedundant: Whether or not this Managed Environment is zone-redundant.
	ZoneRedundant *bool `json:"zoneRedundant,omitempty"`
}

var _ genruntime.ConvertibleStatus = &ManagedEnvironment_STATUS{}

// ConvertStatusFrom populates our ManagedEnvironment_STATUS from the provided source
func (environment *ManagedEnvironment_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.ManagedEnvironment_STATUS)
	if ok {
		// Populate our instance from source
		return environment.AssignProperties_From_ManagedEnvironment_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.ManagedEnvironment_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = environment.AssignProperties_From_ManagedEnvironment_STATUS(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our ManagedEnvironment_STATUS
func (environment *ManagedEnvironment_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.ManagedEnvironment_STATUS)
	if ok {
		// Populate destination from our instance
		return environment.AssignProperties_To_ManagedEnvironment_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.ManagedEnvironment_STATUS{}
	err := environment.AssignProperties_To_ManagedEnvironment_STATUS(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &ManagedEnvironment_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (environment *ManagedEnvironment_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedEnvironment_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (environment *ManagedEnvironment_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedEnvironment_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedEnvironment_STATUS, got %T", armInput)
	}

	// Set property "AppLogsConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AppLogsConfiguration != nil {
			var appLogsConfiguration1 AppLogsConfiguration_STATUS
			err := appLogsConfiguration1.PopulateFromARM(owner, *typedInput.Properties.AppLogsConfiguration)
			if err != nil {
				return err
			}
			appLogsConfiguration := appLogsConfiguration1
			environment.AppLogsConfiguration = &appLogsConfiguration
		}
	}

	// no assignment for property "Conditions"

	// Set property "CustomDomainConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CustomDomainConfiguration != nil {
			var customDomainConfiguration1 CustomDomainConfiguration_STATUS
			err := customDomainConfiguration1.PopulateFromARM(owner, *typedInput.Properties.CustomDomainConfiguration)
			if err != nil {
				return err
			}
			customDomainConfiguration := customDomainConfiguration1
			environment.CustomDomainConfiguration = &customDomainConfiguration
		}
	}

	// Set property "DaprConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DaprConfiguration != nil {
			var daprConfiguration1 DaprConfiguration_STATUS
			err := daprConfiguration1.PopulateFromARM(owner, *typedInput.Properties.DaprConfiguration)
			if err != nil {
				return err
			}
			daprConfiguration := daprConfiguration1
			environment.DaprConfiguration = &daprConfiguration
		}
	}

	// Set property "DefaultDomain":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DefaultDomain != nil {
			defaultDomain := *typedInput.Properties.DefaultDomain
			environment.DefaultDomain = &defaultDomain
		}
	}

	// Set property "DeploymentErrors":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DeploymentErrors != nil {
			deploymentErrors := *typedInput.Properties.DeploymentErrors
			environment.DeploymentErrors = &deploymentErrors
		}
	}

	// Set property "EventStreamEndpoint":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EventStreamEndpoint != nil {
			eventStreamEndpoint := *typedInput.Properties.EventStreamEndpoint
			environment.EventStreamEndpoint = &eventStreamEndpoint
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		environment.Id = &id
	}

	// Set property "InfrastructureResourceGroup":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.InfrastructureResourceGroup != nil {
			infrastructureResourceGroup := *typedInput.Properties.InfrastructureResourceGroup
			environment.InfrastructureResourceGroup = &infrastructureResourceGroup
		}
	}

	// Set property "KedaConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.KedaConfiguration != nil {
			var kedaConfiguration1 KedaConfiguration_STATUS
			err := kedaConfiguration1.PopulateFromARM(owner, *typedInput.Properties.KedaConfiguration)
			if err != nil {
				return err
			}
			kedaConfiguration := kedaConfiguration1
			environment.KedaConfiguration = &kedaConfiguration
		}
	}

	// Set property "Kind":
	if typedInput.Kind != nil {
		kind := *typedInput.Kind
		environment.Kind = &kind
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		environment.Location = &location
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		environment.Name = &name
	}

	// Set property "PeerAuthentication":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PeerAuthentication != nil {
			var peerAuthentication1 ManagedEnvironment_Properties_PeerAuthentication_STATUS
			err := peerAuthentication1.PopulateFromARM(owner, *typedInput.Properties.PeerAuthentication)
			if err != nil {
				return err
			}
			peerAuthentication := peerAuthentication1
			environment.PeerAuthentication = &peerAuthentication
		}
	}

	// Set property "PeerTrafficConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PeerTrafficConfiguration != nil {
			var peerTrafficConfiguration1 ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS
			err := peerTrafficConfiguration1.PopulateFromARM(owner, *typedInput.Properties.PeerTrafficConfiguration)
			if err != nil {
				return err
			}
			peerTrafficConfiguration := peerTrafficConfiguration1
			environment.PeerTrafficConfiguration = &peerTrafficConfiguration
		}
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			var temp string
			temp = string(*typedInput.Properties.ProvisioningState)
			provisioningState := ManagedEnvironment_Properties_ProvisioningState_STATUS(temp)
			environment.ProvisioningState = &provisioningState
		}
	}

	// Set property "StaticIp":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.StaticIp != nil {
			staticIp := *typedInput.Properties.StaticIp
			environment.StaticIp = &staticIp
		}
	}

	// Set property "SystemData":
	if typedInput.SystemData != nil {
		var systemData1 SystemData_STATUS
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		environment.SystemData = &systemData
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		environment.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			environment.Tags[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		environment.Type = &typeVar
	}

	// Set property "VnetConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VnetConfiguration != nil {
			var vnetConfiguration1 VnetConfiguration_STATUS
			err := vnetConfiguration1.PopulateFromARM(owner, *typedInput.Properties.VnetConfiguration)
			if err != nil {
				return err
			}
			vnetConfiguration := vnetConfiguration1
			environment.VnetConfiguration = &vnetConfiguration
		}
	}

	// Set property "WorkloadProfiles":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.WorkloadProfiles {
			var item1 WorkloadProfile_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			environment.WorkloadProfiles = append(environment.WorkloadProfiles, item1)
		}
	}

	// Set property "ZoneRedundant":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ZoneRedundant != nil {
			zoneRedundant := *typedInput.Properties.ZoneRedundant
			environment.ZoneRedundant = &zoneRedundant
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedEnvironment_STATUS populates our ManagedEnvironment_STATUS from the provided source ManagedEnvironment_STATUS
func (environment *ManagedEnvironment_STATUS) AssignProperties_From_ManagedEnvironment_STATUS(source *storage.ManagedEnvironment_STATUS) error {

	// AppLogsConfiguration
	if source.AppLogsConfiguration != nil {
		var appLogsConfiguration AppLogsConfiguration_STATUS
		err := appLogsConfiguration.AssignProperties_From_AppLogsConfiguration_STATUS(source.AppLogsConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AppLogsConfiguration_STATUS() to populate field AppLogsConfiguration")
		}
		environment.AppLogsConfiguration = &appLogsConfiguration
	} else {
		environment.AppLogsConfiguration = nil
	}

	// Conditions
	environment.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// CustomDomainConfiguration
	if source.CustomDomainConfiguration != nil {
		var customDomainConfiguration CustomDomainConfiguration_STATUS
		err := customDomainConfiguration.AssignProperties_From_CustomDomainConfiguration_STATUS(source.CustomDomainConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CustomDomainConfiguration_STATUS() to populate field CustomDomainConfiguration")
		}
		environment.CustomDomainConfiguration = &customDomainConfiguration
	} else {
		environment.CustomDomainConfiguration = nil
	}

	// DaprConfiguration
	if source.DaprConfiguration != nil {
		var daprConfiguration DaprConfiguration_STATUS
		err := daprConfiguration.AssignProperties_From_DaprConfiguration_STATUS(source.DaprConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DaprConfiguration_STATUS() to populate field DaprConfiguration")
		}
		environment.DaprConfiguration = &daprConfiguration
	} else {
		environment.DaprConfiguration = nil
	}

	// DefaultDomain
	environment.DefaultDomain = genruntime.ClonePointerToString(source.DefaultDomain)

	// DeploymentErrors
	environment.DeploymentErrors = genruntime.ClonePointerToString(source.DeploymentErrors)

	// EventStreamEndpoint
	environment.EventStreamEndpoint = genruntime.ClonePointerToString(source.EventStreamEndpoint)

	// Id
	environment.Id = genruntime.ClonePointerToString(source.Id)

	// InfrastructureResourceGroup
	environment.InfrastructureResourceGroup = genruntime.ClonePointerToString(source.InfrastructureResourceGroup)

	// KedaConfiguration
	if source.KedaConfiguration != nil {
		var kedaConfiguration KedaConfiguration_STATUS
		err := kedaConfiguration.AssignProperties_From_KedaConfiguration_STATUS(source.KedaConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_KedaConfiguration_STATUS() to populate field KedaConfiguration")
		}
		environment.KedaConfiguration = &kedaConfiguration
	} else {
		environment.KedaConfiguration = nil
	}

	// Kind
	environment.Kind = genruntime.ClonePointerToString(source.Kind)

	// Location
	environment.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	environment.Name = genruntime.ClonePointerToString(source.Name)

	// PeerAuthentication
	if source.PeerAuthentication != nil {
		var peerAuthentication ManagedEnvironment_Properties_PeerAuthentication_STATUS
		err := peerAuthentication.AssignProperties_From_ManagedEnvironment_Properties_PeerAuthentication_STATUS(source.PeerAuthentication)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedEnvironment_Properties_PeerAuthentication_STATUS() to populate field PeerAuthentication")
		}
		environment.PeerAuthentication = &peerAuthentication
	} else {
		environment.PeerAuthentication = nil
	}

	// PeerTrafficConfiguration
	if source.PeerTrafficConfiguration != nil {
		var peerTrafficConfiguration ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS
		err := peerTrafficConfiguration.AssignProperties_From_ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS(source.PeerTrafficConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS() to populate field PeerTrafficConfiguration")
		}
		environment.PeerTrafficConfiguration = &peerTrafficConfiguration
	} else {
		environment.PeerTrafficConfiguration = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, managedEnvironment_Properties_ProvisioningState_STATUS_Values)
		environment.ProvisioningState = &provisioningStateTemp
	} else {
		environment.ProvisioningState = nil
	}

	// StaticIp
	environment.StaticIp = genruntime.ClonePointerToString(source.StaticIp)

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		environment.SystemData = &systemDatum
	} else {
		environment.SystemData = nil
	}

	// Tags
	environment.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	environment.Type = genruntime.ClonePointerToString(source.Type)

	// VnetConfiguration
	if source.VnetConfiguration != nil {
		var vnetConfiguration VnetConfiguration_STATUS
		err := vnetConfiguration.AssignProperties_From_VnetConfiguration_STATUS(source.VnetConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VnetConfiguration_STATUS() to populate field VnetConfiguration")
		}
		environment.VnetConfiguration = &vnetConfiguration
	} else {
		environment.VnetConfiguration = nil
	}

	// WorkloadProfiles
	if source.WorkloadProfiles != nil {
		workloadProfileList := make([]WorkloadProfile_STATUS, len(source.WorkloadProfiles))
		for workloadProfileIndex, workloadProfileItem := range source.WorkloadProfiles {
			// Shadow the loop variable to avoid aliasing
			workloadProfileItem := workloadProfileItem
			var workloadProfile WorkloadProfile_STATUS
			err := workloadProfile.AssignProperties_From_WorkloadProfile_STATUS(&workloadProfileItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_WorkloadProfile_STATUS() to populate field WorkloadProfiles")
			}
			workloadProfileList[workloadProfileIndex] = workloadProfile
		}
		environment.WorkloadProfiles = workloadProfileList
	} else {
		environment.WorkloadProfiles = nil
	}

	// ZoneRedundant
	if source.ZoneRedundant != nil {
		zoneRedundant := *source.ZoneRedundant
		environment.ZoneRedundant = &zoneRedundant
	} else {
		environment.ZoneRedundant = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedEnvironment_STATUS populates the provided destination ManagedEnvironment_STATUS from our ManagedEnvironment_STATUS
func (environment *ManagedEnvironment_STATUS) AssignProperties_To_ManagedEnvironment_STATUS(destination *storage.ManagedEnvironment_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AppLogsConfiguration
	if environment.AppLogsConfiguration != nil {
		var appLogsConfiguration storage.AppLogsConfiguration_STATUS
		err := environment.AppLogsConfiguration.AssignProperties_To_AppLogsConfiguration_STATUS(&appLogsConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AppLogsConfiguration_STATUS() to populate field AppLogsConfiguration")
		}
		destination.AppLogsConfiguration = &appLogsConfiguration
	} else {
		destination.AppLogsConfiguration = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(environment.Conditions)

	// CustomDomainConfiguration
	if environment.CustomDomainConfiguration != nil {
		var customDomainConfiguration storage.CustomDomainConfiguration_STATUS
		err := environment.CustomDomainConfiguration.AssignProperties_To_CustomDomainConfiguration_STATUS(&customDomainConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CustomDomainConfiguration_STATUS() to populate field CustomDomainConfiguration")
		}
		destination.CustomDomainConfiguration = &customDomainConfiguration
	} else {
		destination.CustomDomainConfiguration = nil
	}

	// DaprConfiguration
	if environment.DaprConfiguration != nil {
		var daprConfiguration storage.DaprConfiguration_STATUS
		err := environment.DaprConfiguration.AssignProperties_To_DaprConfiguration_STATUS(&daprConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DaprConfiguration_STATUS() to populate field DaprConfiguration")
		}
		destination.DaprConfiguration = &daprConfiguration
	} else {
		destination.DaprConfiguration = nil
	}

	// DefaultDomain
	destination.DefaultDomain = genruntime.ClonePointerToString(environment.DefaultDomain)

	// DeploymentErrors
	destination.DeploymentErrors = genruntime.ClonePointerToString(environment.DeploymentErrors)

	// EventStreamEndpoint
	destination.EventStreamEndpoint = genruntime.ClonePointerToString(environment.EventStreamEndpoint)

	// Id
	destination.Id = genruntime.ClonePointerToString(environment.Id)

	// InfrastructureResourceGroup
	destination.InfrastructureResourceGroup = genruntime.ClonePointerToString(environment.InfrastructureResourceGroup)

	// KedaConfiguration
	if environment.KedaConfiguration != nil {
		var kedaConfiguration storage.KedaConfiguration_STATUS
		err := environment.KedaConfiguration.AssignProperties_To_KedaConfiguration_STATUS(&kedaConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_KedaConfiguration_STATUS() to populate field KedaConfiguration")
		}
		destination.KedaConfiguration = &kedaConfiguration
	} else {
		destination.KedaConfiguration = nil
	}

	// Kind
	destination.Kind = genruntime.ClonePointerToString(environment.Kind)

	// Location
	destination.Location = genruntime.ClonePointerToString(environment.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(environment.Name)

	// PeerAuthentication
	if environment.PeerAuthentication != nil {
		var peerAuthentication storage.ManagedEnvironment_Properties_PeerAuthentication_STATUS
		err := environment.PeerAuthentication.AssignProperties_To_ManagedEnvironment_Properties_PeerAuthentication_STATUS(&peerAuthentication)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedEnvironment_Properties_PeerAuthentication_STATUS() to populate field PeerAuthentication")
		}
		destination.PeerAuthentication = &peerAuthentication
	} else {
		destination.PeerAuthentication = nil
	}

	// PeerTrafficConfiguration
	if environment.PeerTrafficConfiguration != nil {
		var peerTrafficConfiguration storage.ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS
		err := environment.PeerTrafficConfiguration.AssignProperties_To_ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS(&peerTrafficConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS() to populate field PeerTrafficConfiguration")
		}
		destination.PeerTrafficConfiguration = &peerTrafficConfiguration
	} else {
		destination.PeerTrafficConfiguration = nil
	}

	// ProvisioningState
	if environment.ProvisioningState != nil {
		provisioningState := string(*environment.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// StaticIp
	destination.StaticIp = genruntime.ClonePointerToString(environment.StaticIp)

	// SystemData
	if environment.SystemData != nil {
		var systemDatum storage.SystemData_STATUS
		err := environment.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(environment.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(environment.Type)

	// VnetConfiguration
	if environment.VnetConfiguration != nil {
		var vnetConfiguration storage.VnetConfiguration_STATUS
		err := environment.VnetConfiguration.AssignProperties_To_VnetConfiguration_STATUS(&vnetConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VnetConfiguration_STATUS() to populate field VnetConfiguration")
		}
		destination.VnetConfiguration = &vnetConfiguration
	} else {
		destination.VnetConfiguration = nil
	}

	// WorkloadProfiles
	if environment.WorkloadProfiles != nil {
		workloadProfileList := make([]storage.WorkloadProfile_STATUS, len(environment.WorkloadProfiles))
		for workloadProfileIndex, workloadProfileItem := range environment.WorkloadProfiles {
			// Shadow the loop variable to avoid aliasing
			workloadProfileItem := workloadProfileItem
			var workloadProfile storage.WorkloadProfile_STATUS
			err := workloadProfileItem.AssignProperties_To_WorkloadProfile_STATUS(&workloadProfile)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_WorkloadProfile_STATUS() to populate field WorkloadProfiles")
			}
			workloadProfileList[workloadProfileIndex] = workloadProfile
		}
		destination.WorkloadProfiles = workloadProfileList
	} else {
		destination.WorkloadProfiles = nil
	}

	// ZoneRedundant
	if environment.ZoneRedundant != nil {
		zoneRedundant := *environment.ZoneRedundant
		destination.ZoneRedundant = &zoneRedundant
	} else {
		destination.ZoneRedundant = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Configuration of application logs
type AppLogsConfiguration struct {
	// Destination: Logs destination, can be 'log-analytics', 'azure-monitor' or 'none'
	Destination *string `json:"destination,omitempty"`

	// LogAnalyticsConfiguration: Log Analytics configuration, must only be provided when destination is configured as
	// 'log-analytics'
	LogAnalyticsConfiguration *LogAnalyticsConfiguration `json:"logAnalyticsConfiguration,omitempty"`
}

var _ genruntime.ARMTransformer = &AppLogsConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *AppLogsConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.AppLogsConfiguration{}

	// Set property "Destination":
	if configuration.Destination != nil {
		destination := *configuration.Destination
		result.Destination = &destination
	}

	// Set property "LogAnalyticsConfiguration":
	if configuration.LogAnalyticsConfiguration != nil {
		logAnalyticsConfiguration_ARM, err := (*configuration.LogAnalyticsConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		logAnalyticsConfiguration := *logAnalyticsConfiguration_ARM.(*arm.LogAnalyticsConfiguration)
		result.LogAnalyticsConfiguration = &logAnalyticsConfiguration
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *AppLogsConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AppLogsConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *AppLogsConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AppLogsConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AppLogsConfiguration, got %T", armInput)
	}

	// Set property "Destination":
	if typedInput.Destination != nil {
		destination := *typedInput.Destination
		configuration.Destination = &destination
	}

	// Set property "LogAnalyticsConfiguration":
	if typedInput.LogAnalyticsConfiguration != nil {
		var logAnalyticsConfiguration1 LogAnalyticsConfiguration
		err := logAnalyticsConfiguration1.PopulateFromARM(owner, *typedInput.LogAnalyticsConfiguration)
		if err != nil {
			return err
		}
		logAnalyticsConfiguration := logAnalyticsConfiguration1
		configuration.LogAnalyticsConfiguration = &logAnalyticsConfiguration
	}

	// No error
	return nil
}

// AssignProperties_From_AppLogsConfiguration populates our AppLogsConfiguration from the provided source AppLogsConfiguration
func (configuration *AppLogsConfiguration) AssignProperties_From_AppLogsConfiguration(source *storage.AppLogsConfiguration) error {

	// Destination
	configuration.Destination = genruntime.ClonePointerToString(source.Destination)

	// LogAnalyticsConfiguration
	if source.LogAnalyticsConfiguration != nil {
		var logAnalyticsConfiguration LogAnalyticsConfiguration
		err := logAnalyticsConfiguration.AssignProperties_From_LogAnalyticsConfiguration(source.LogAnalyticsConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LogAnalyticsConfiguration() to populate field LogAnalyticsConfiguration")
		}
		configuration.LogAnalyticsConfiguration = &logAnalyticsConfiguration
	} else {
		configuration.LogAnalyticsConfiguration = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AppLogsConfiguration populates the provided destination AppLogsConfiguration from our AppLogsConfiguration
func (configuration *AppLogsConfiguration) AssignProperties_To_AppLogsConfiguration(destination *storage.AppLogsConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Destination
	destination.Destination = genruntime.ClonePointerToString(configuration.Destination)

	// LogAnalyticsConfiguration
	if configuration.LogAnalyticsConfiguration != nil {
		var logAnalyticsConfiguration storage.LogAnalyticsConfiguration
		err := configuration.LogAnalyticsConfiguration.AssignProperties_To_LogAnalyticsConfiguration(&logAnalyticsConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LogAnalyticsConfiguration() to populate field LogAnalyticsConfiguration")
		}
		destination.LogAnalyticsConfiguration = &logAnalyticsConfiguration
	} else {
		destination.LogAnalyticsConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AppLogsConfiguration_STATUS populates our AppLogsConfiguration from the provided source AppLogsConfiguration_STATUS
func (configuration *AppLogsConfiguration) Initialize_From_AppLogsConfiguration_STATUS(source *AppLogsConfiguration_STATUS) error {

	// Destination
	configuration.Destination = genruntime.ClonePointerToString(source.Destination)

	// LogAnalyticsConfiguration
	if source.LogAnalyticsConfiguration != nil {
		var logAnalyticsConfiguration LogAnalyticsConfiguration
		err := logAnalyticsConfiguration.Initialize_From_LogAnalyticsConfiguration_STATUS(source.LogAnalyticsConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_LogAnalyticsConfiguration_STATUS() to populate field LogAnalyticsConfiguration")
		}
		configuration.LogAnalyticsConfiguration = &logAnalyticsConfiguration
	} else {
		configuration.LogAnalyticsConfiguration = nil
	}

	// No error
	return nil
}

// Configuration of application logs
type AppLogsConfiguration_STATUS struct {
	// Destination: Logs destination, can be 'log-analytics', 'azure-monitor' or 'none'
	Destination *string `json:"destination,omitempty"`

	// LogAnalyticsConfiguration: Log Analytics configuration, must only be provided when destination is configured as
	// 'log-analytics'
	LogAnalyticsConfiguration *LogAnalyticsConfiguration_STATUS `json:"logAnalyticsConfiguration,omitempty"`
}

var _ genruntime.FromARMConverter = &AppLogsConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *AppLogsConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AppLogsConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *AppLogsConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AppLogsConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AppLogsConfiguration_STATUS, got %T", armInput)
	}

	// Set property "Destination":
	if typedInput.Destination != nil {
		destination := *typedInput.Destination
		configuration.Destination = &destination
	}

	// Set property "LogAnalyticsConfiguration":
	if typedInput.LogAnalyticsConfiguration != nil {
		var logAnalyticsConfiguration1 LogAnalyticsConfiguration_STATUS
		err := logAnalyticsConfiguration1.PopulateFromARM(owner, *typedInput.LogAnalyticsConfiguration)
		if err != nil {
			return err
		}
		logAnalyticsConfiguration := logAnalyticsConfiguration1
		configuration.LogAnalyticsConfiguration = &logAnalyticsConfiguration
	}

	// No error
	return nil
}

// AssignProperties_From_AppLogsConfiguration_STATUS populates our AppLogsConfiguration_STATUS from the provided source AppLogsConfiguration_STATUS
func (configuration *AppLogsConfiguration_STATUS) AssignProperties_From_AppLogsConfiguration_STATUS(source *storage.AppLogsConfiguration_STATUS) error {

	// Destination
	configuration.Destination = genruntime.ClonePointerToString(source.Destination)

	// LogAnalyticsConfiguration
	if source.LogAnalyticsConfiguration != nil {
		var logAnalyticsConfiguration LogAnalyticsConfiguration_STATUS
		err := logAnalyticsConfiguration.AssignProperties_From_LogAnalyticsConfiguration_STATUS(source.LogAnalyticsConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LogAnalyticsConfiguration_STATUS() to populate field LogAnalyticsConfiguration")
		}
		configuration.LogAnalyticsConfiguration = &logAnalyticsConfiguration
	} else {
		configuration.LogAnalyticsConfiguration = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AppLogsConfiguration_STATUS populates the provided destination AppLogsConfiguration_STATUS from our AppLogsConfiguration_STATUS
func (configuration *AppLogsConfiguration_STATUS) AssignProperties_To_AppLogsConfiguration_STATUS(destination *storage.AppLogsConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Destination
	destination.Destination = genruntime.ClonePointerToString(configuration.Destination)

	// LogAnalyticsConfiguration
	if configuration.LogAnalyticsConfiguration != nil {
		var logAnalyticsConfiguration storage.LogAnalyticsConfiguration_STATUS
		err := configuration.LogAnalyticsConfiguration.AssignProperties_To_LogAnalyticsConfiguration_STATUS(&logAnalyticsConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LogAnalyticsConfiguration_STATUS() to populate field LogAnalyticsConfiguration")
		}
		destination.LogAnalyticsConfiguration = &logAnalyticsConfiguration
	} else {
		destination.LogAnalyticsConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Configuration properties for apps environment custom domain
type CustomDomainConfiguration struct {
	// CertificatePassword: Certificate password
	CertificatePassword *genruntime.SecretReference `json:"certificatePassword,omitempty"`

	// CertificateValue: PFX or PEM blob
	CertificateValue *genruntime.SecretReference `json:"certificateValue,omitempty"`

	// DnsSuffix: Dns suffix for the environment domain
	DnsSuffix *string `json:"dnsSuffix,omitempty"`
}

var _ genruntime.ARMTransformer = &CustomDomainConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *CustomDomainConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.CustomDomainConfiguration{}

	// Set property "CertificatePassword":
	if configuration.CertificatePassword != nil {
		certificatePasswordSecret, err := resolved.ResolvedSecrets.Lookup(*configuration.CertificatePassword)
		if err != nil {
			return nil, eris.Wrap(err, "looking up secret for property CertificatePassword")
		}
		certificatePassword := certificatePasswordSecret
		result.CertificatePassword = &certificatePassword
	}

	// Set property "CertificateValue":
	if configuration.CertificateValue != nil {
		certificateValueSecret, err := resolved.ResolvedSecrets.Lookup(*configuration.CertificateValue)
		if err != nil {
			return nil, eris.Wrap(err, "looking up secret for property CertificateValue")
		}
		certificateValue := certificateValueSecret
		result.CertificateValue = &certificateValue
	}

	// Set property "DnsSuffix":
	if configuration.DnsSuffix != nil {
		dnsSuffix := *configuration.DnsSuffix
		result.DnsSuffix = &dnsSuffix
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *CustomDomainConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CustomDomainConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *CustomDomainConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CustomDomainConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CustomDomainConfiguration, got %T", armInput)
	}

	// no assignment for property "CertificatePassword"

	// no assignment for property "CertificateValue"

	// Set property "DnsSuffix":
	if typedInput.DnsSuffix != nil {
		dnsSuffix := *typedInput.DnsSuffix
		configuration.DnsSuffix = &dnsSuffix
	}

	// No error
	return nil
}

// AssignProperties_From_CustomDomainConfiguration populates our CustomDomainConfiguration from the provided source CustomDomainConfiguration
func (configuration *CustomDomainConfiguration) AssignProperties_From_CustomDomainConfiguration(source *storage.CustomDomainConfiguration) error {

	// CertificatePassword
	if source.CertificatePassword != nil {
		certificatePassword := source.CertificatePassword.Copy()
		configuration.CertificatePassword = &certificatePassword
	} else {
		configuration.CertificatePassword = nil
	}

	// CertificateValue
	if source.CertificateValue != nil {
		certificateValue := source.CertificateValue.Copy()
		configuration.CertificateValue = &certificateValue
	} else {
		configuration.CertificateValue = nil
	}

	// DnsSuffix
	configuration.DnsSuffix = genruntime.ClonePointerToString(source.DnsSuffix)

	// No error
	return nil
}

// AssignProperties_To_CustomDomainConfiguration populates the provided destination CustomDomainConfiguration from our CustomDomainConfiguration
func (configuration *CustomDomainConfiguration) AssignProperties_To_CustomDomainConfiguration(destination *storage.CustomDomainConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CertificatePassword
	if configuration.CertificatePassword != nil {
		certificatePassword := configuration.CertificatePassword.Copy()
		destination.CertificatePassword = &certificatePassword
	} else {
		destination.CertificatePassword = nil
	}

	// CertificateValue
	if configuration.CertificateValue != nil {
		certificateValue := configuration.CertificateValue.Copy()
		destination.CertificateValue = &certificateValue
	} else {
		destination.CertificateValue = nil
	}

	// DnsSuffix
	destination.DnsSuffix = genruntime.ClonePointerToString(configuration.DnsSuffix)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_CustomDomainConfiguration_STATUS populates our CustomDomainConfiguration from the provided source CustomDomainConfiguration_STATUS
func (configuration *CustomDomainConfiguration) Initialize_From_CustomDomainConfiguration_STATUS(source *CustomDomainConfiguration_STATUS) error {

	// DnsSuffix
	configuration.DnsSuffix = genruntime.ClonePointerToString(source.DnsSuffix)

	// No error
	return nil
}

// Configuration properties for apps environment custom domain
type CustomDomainConfiguration_STATUS struct {
	// CustomDomainVerificationId: Id used to verify domain name ownership
	CustomDomainVerificationId *string `json:"customDomainVerificationId,omitempty"`

	// DnsSuffix: Dns suffix for the environment domain
	DnsSuffix *string `json:"dnsSuffix,omitempty"`

	// ExpirationDate: Certificate expiration date.
	ExpirationDate *string `json:"expirationDate,omitempty"`

	// SubjectName: Subject name of the certificate.
	SubjectName *string `json:"subjectName,omitempty"`

	// Thumbprint: Certificate thumbprint.
	Thumbprint *string `json:"thumbprint,omitempty"`
}

var _ genruntime.FromARMConverter = &CustomDomainConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *CustomDomainConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CustomDomainConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *CustomDomainConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CustomDomainConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CustomDomainConfiguration_STATUS, got %T", armInput)
	}

	// Set property "CustomDomainVerificationId":
	if typedInput.CustomDomainVerificationId != nil {
		customDomainVerificationId := *typedInput.CustomDomainVerificationId
		configuration.CustomDomainVerificationId = &customDomainVerificationId
	}

	// Set property "DnsSuffix":
	if typedInput.DnsSuffix != nil {
		dnsSuffix := *typedInput.DnsSuffix
		configuration.DnsSuffix = &dnsSuffix
	}

	// Set property "ExpirationDate":
	if typedInput.ExpirationDate != nil {
		expirationDate := *typedInput.ExpirationDate
		configuration.ExpirationDate = &expirationDate
	}

	// Set property "SubjectName":
	if typedInput.SubjectName != nil {
		subjectName := *typedInput.SubjectName
		configuration.SubjectName = &subjectName
	}

	// Set property "Thumbprint":
	if typedInput.Thumbprint != nil {
		thumbprint := *typedInput.Thumbprint
		configuration.Thumbprint = &thumbprint
	}

	// No error
	return nil
}

// AssignProperties_From_CustomDomainConfiguration_STATUS populates our CustomDomainConfiguration_STATUS from the provided source CustomDomainConfiguration_STATUS
func (configuration *CustomDomainConfiguration_STATUS) AssignProperties_From_CustomDomainConfiguration_STATUS(source *storage.CustomDomainConfiguration_STATUS) error {

	// CustomDomainVerificationId
	configuration.CustomDomainVerificationId = genruntime.ClonePointerToString(source.CustomDomainVerificationId)

	// DnsSuffix
	configuration.DnsSuffix = genruntime.ClonePointerToString(source.DnsSuffix)

	// ExpirationDate
	configuration.ExpirationDate = genruntime.ClonePointerToString(source.ExpirationDate)

	// SubjectName
	configuration.SubjectName = genruntime.ClonePointerToString(source.SubjectName)

	// Thumbprint
	configuration.Thumbprint = genruntime.ClonePointerToString(source.Thumbprint)

	// No error
	return nil
}

// AssignProperties_To_CustomDomainConfiguration_STATUS populates the provided destination CustomDomainConfiguration_STATUS from our CustomDomainConfiguration_STATUS
func (configuration *CustomDomainConfiguration_STATUS) AssignProperties_To_CustomDomainConfiguration_STATUS(destination *storage.CustomDomainConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CustomDomainVerificationId
	destination.CustomDomainVerificationId = genruntime.ClonePointerToString(configuration.CustomDomainVerificationId)

	// DnsSuffix
	destination.DnsSuffix = genruntime.ClonePointerToString(configuration.DnsSuffix)

	// ExpirationDate
	destination.ExpirationDate = genruntime.ClonePointerToString(configuration.ExpirationDate)

	// SubjectName
	destination.SubjectName = genruntime.ClonePointerToString(configuration.SubjectName)

	// Thumbprint
	destination.Thumbprint = genruntime.ClonePointerToString(configuration.Thumbprint)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Configuration properties Dapr component
type DaprConfiguration_STATUS struct {
	// Version: The version of Dapr
	Version *string `json:"version,omitempty"`
}

var _ genruntime.FromARMConverter = &DaprConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *DaprConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DaprConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *DaprConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DaprConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DaprConfiguration_STATUS, got %T", armInput)
	}

	// Set property "Version":
	if typedInput.Version != nil {
		version := *typedInput.Version
		configuration.Version = &version
	}

	// No error
	return nil
}

// AssignProperties_From_DaprConfiguration_STATUS populates our DaprConfiguration_STATUS from the provided source DaprConfiguration_STATUS
func (configuration *DaprConfiguration_STATUS) AssignProperties_From_DaprConfiguration_STATUS(source *storage.DaprConfiguration_STATUS) error {

	// Version
	configuration.Version = genruntime.ClonePointerToString(source.Version)

	// No error
	return nil
}

// AssignProperties_To_DaprConfiguration_STATUS populates the provided destination DaprConfiguration_STATUS from our DaprConfiguration_STATUS
func (configuration *DaprConfiguration_STATUS) AssignProperties_To_DaprConfiguration_STATUS(destination *storage.DaprConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Version
	destination.Version = genruntime.ClonePointerToString(configuration.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Configuration properties Keda component
type KedaConfiguration_STATUS struct {
	// Version: The version of Keda
	Version *string `json:"version,omitempty"`
}

var _ genruntime.FromARMConverter = &KedaConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *KedaConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KedaConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *KedaConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KedaConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KedaConfiguration_STATUS, got %T", armInput)
	}

	// Set property "Version":
	if typedInput.Version != nil {
		version := *typedInput.Version
		configuration.Version = &version
	}

	// No error
	return nil
}

// AssignProperties_From_KedaConfiguration_STATUS populates our KedaConfiguration_STATUS from the provided source KedaConfiguration_STATUS
func (configuration *KedaConfiguration_STATUS) AssignProperties_From_KedaConfiguration_STATUS(source *storage.KedaConfiguration_STATUS) error {

	// Version
	configuration.Version = genruntime.ClonePointerToString(source.Version)

	// No error
	return nil
}

// AssignProperties_To_KedaConfiguration_STATUS populates the provided destination KedaConfiguration_STATUS from our KedaConfiguration_STATUS
func (configuration *KedaConfiguration_STATUS) AssignProperties_To_KedaConfiguration_STATUS(destination *storage.KedaConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Version
	destination.Version = genruntime.ClonePointerToString(configuration.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedEnvironment_Properties_PeerAuthentication_Spec struct {
	// Mtls: Mutual TLS authentication settings for the Managed Environment
	Mtls *Mtls `json:"mtls,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedEnvironment_Properties_PeerAuthentication_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (authentication *ManagedEnvironment_Properties_PeerAuthentication_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if authentication == nil {
		return nil, nil
	}
	result := &arm.ManagedEnvironment_Properties_PeerAuthentication_Spec{}

	// Set property "Mtls":
	if authentication.Mtls != nil {
		mtls_ARM, err := (*authentication.Mtls).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		mtls := *mtls_ARM.(*arm.Mtls)
		result.Mtls = &mtls
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (authentication *ManagedEnvironment_Properties_PeerAuthentication_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedEnvironment_Properties_PeerAuthentication_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (authentication *ManagedEnvironment_Properties_PeerAuthentication_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedEnvironment_Properties_PeerAuthentication_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedEnvironment_Properties_PeerAuthentication_Spec, got %T", armInput)
	}

	// Set property "Mtls":
	if typedInput.Mtls != nil {
		var mtls1 Mtls
		err := mtls1.PopulateFromARM(owner, *typedInput.Mtls)
		if err != nil {
			return err
		}
		mtls := mtls1
		authentication.Mtls = &mtls
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedEnvironment_Properties_PeerAuthentication_Spec populates our ManagedEnvironment_Properties_PeerAuthentication_Spec from the provided source ManagedEnvironment_Properties_PeerAuthentication_Spec
func (authentication *ManagedEnvironment_Properties_PeerAuthentication_Spec) AssignProperties_From_ManagedEnvironment_Properties_PeerAuthentication_Spec(source *storage.ManagedEnvironment_Properties_PeerAuthentication_Spec) error {

	// Mtls
	if source.Mtls != nil {
		var mtl Mtls
		err := mtl.AssignProperties_From_Mtls(source.Mtls)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Mtls() to populate field Mtls")
		}
		authentication.Mtls = &mtl
	} else {
		authentication.Mtls = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedEnvironment_Properties_PeerAuthentication_Spec populates the provided destination ManagedEnvironment_Properties_PeerAuthentication_Spec from our ManagedEnvironment_Properties_PeerAuthentication_Spec
func (authentication *ManagedEnvironment_Properties_PeerAuthentication_Spec) AssignProperties_To_ManagedEnvironment_Properties_PeerAuthentication_Spec(destination *storage.ManagedEnvironment_Properties_PeerAuthentication_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Mtls
	if authentication.Mtls != nil {
		var mtl storage.Mtls
		err := authentication.Mtls.AssignProperties_To_Mtls(&mtl)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Mtls() to populate field Mtls")
		}
		destination.Mtls = &mtl
	} else {
		destination.Mtls = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ManagedEnvironment_Properties_PeerAuthentication_STATUS populates our ManagedEnvironment_Properties_PeerAuthentication_Spec from the provided source ManagedEnvironment_Properties_PeerAuthentication_STATUS
func (authentication *ManagedEnvironment_Properties_PeerAuthentication_Spec) Initialize_From_ManagedEnvironment_Properties_PeerAuthentication_STATUS(source *ManagedEnvironment_Properties_PeerAuthentication_STATUS) error {

	// Mtls
	if source.Mtls != nil {
		var mtl Mtls
		err := mtl.Initialize_From_Mtls_STATUS(source.Mtls)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_Mtls_STATUS() to populate field Mtls")
		}
		authentication.Mtls = &mtl
	} else {
		authentication.Mtls = nil
	}

	// No error
	return nil
}

type ManagedEnvironment_Properties_PeerAuthentication_STATUS struct {
	// Mtls: Mutual TLS authentication settings for the Managed Environment
	Mtls *Mtls_STATUS `json:"mtls,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedEnvironment_Properties_PeerAuthentication_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (authentication *ManagedEnvironment_Properties_PeerAuthentication_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedEnvironment_Properties_PeerAuthentication_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (authentication *ManagedEnvironment_Properties_PeerAuthentication_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedEnvironment_Properties_PeerAuthentication_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedEnvironment_Properties_PeerAuthentication_STATUS, got %T", armInput)
	}

	// Set property "Mtls":
	if typedInput.Mtls != nil {
		var mtls1 Mtls_STATUS
		err := mtls1.PopulateFromARM(owner, *typedInput.Mtls)
		if err != nil {
			return err
		}
		mtls := mtls1
		authentication.Mtls = &mtls
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedEnvironment_Properties_PeerAuthentication_STATUS populates our ManagedEnvironment_Properties_PeerAuthentication_STATUS from the provided source ManagedEnvironment_Properties_PeerAuthentication_STATUS
func (authentication *ManagedEnvironment_Properties_PeerAuthentication_STATUS) AssignProperties_From_ManagedEnvironment_Properties_PeerAuthentication_STATUS(source *storage.ManagedEnvironment_Properties_PeerAuthentication_STATUS) error {

	// Mtls
	if source.Mtls != nil {
		var mtl Mtls_STATUS
		err := mtl.AssignProperties_From_Mtls_STATUS(source.Mtls)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Mtls_STATUS() to populate field Mtls")
		}
		authentication.Mtls = &mtl
	} else {
		authentication.Mtls = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedEnvironment_Properties_PeerAuthentication_STATUS populates the provided destination ManagedEnvironment_Properties_PeerAuthentication_STATUS from our ManagedEnvironment_Properties_PeerAuthentication_STATUS
func (authentication *ManagedEnvironment_Properties_PeerAuthentication_STATUS) AssignProperties_To_ManagedEnvironment_Properties_PeerAuthentication_STATUS(destination *storage.ManagedEnvironment_Properties_PeerAuthentication_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Mtls
	if authentication.Mtls != nil {
		var mtl storage.Mtls_STATUS
		err := authentication.Mtls.AssignProperties_To_Mtls_STATUS(&mtl)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Mtls_STATUS() to populate field Mtls")
		}
		destination.Mtls = &mtl
	} else {
		destination.Mtls = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec struct {
	// Encryption: Peer traffic encryption settings for the Managed Environment
	Encryption *ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec `json:"encryption,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec{}

	// Set property "Encryption":
	if configuration.Encryption != nil {
		encryption_ARM, err := (*configuration.Encryption).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		encryption := *encryption_ARM.(*arm.ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec)
		result.Encryption = &encryption
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec, got %T", armInput)
	}

	// Set property "Encryption":
	if typedInput.Encryption != nil {
		var encryption1 ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec
		err := encryption1.PopulateFromARM(owner, *typedInput.Encryption)
		if err != nil {
			return err
		}
		encryption := encryption1
		configuration.Encryption = &encryption
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec populates our ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec from the provided source ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec
func (configuration *ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec) AssignProperties_From_ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec(source *storage.ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec) error {

	// Encryption
	if source.Encryption != nil {
		var encryption ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec
		err := encryption.AssignProperties_From_ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec(source.Encryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec() to populate field Encryption")
		}
		configuration.Encryption = &encryption
	} else {
		configuration.Encryption = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec populates the provided destination ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec from our ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec
func (configuration *ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec) AssignProperties_To_ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec(destination *storage.ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Encryption
	if configuration.Encryption != nil {
		var encryption storage.ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec
		err := configuration.Encryption.AssignProperties_To_ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec(&encryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec() to populate field Encryption")
		}
		destination.Encryption = &encryption
	} else {
		destination.Encryption = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS populates our ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec from the provided source ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS
func (configuration *ManagedEnvironment_Properties_PeerTrafficConfiguration_Spec) Initialize_From_ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS(source *ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS) error {

	// Encryption
	if source.Encryption != nil {
		var encryption ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec
		err := encryption.Initialize_From_ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS(source.Encryption)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS() to populate field Encryption")
		}
		configuration.Encryption = &encryption
	} else {
		configuration.Encryption = nil
	}

	// No error
	return nil
}

type ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS struct {
	// Encryption: Peer traffic encryption settings for the Managed Environment
	Encryption *ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS `json:"encryption,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS, got %T", armInput)
	}

	// Set property "Encryption":
	if typedInput.Encryption != nil {
		var encryption1 ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS
		err := encryption1.PopulateFromARM(owner, *typedInput.Encryption)
		if err != nil {
			return err
		}
		encryption := encryption1
		configuration.Encryption = &encryption
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS populates our ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS from the provided source ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS
func (configuration *ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS) AssignProperties_From_ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS(source *storage.ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS) error {

	// Encryption
	if source.Encryption != nil {
		var encryption ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS
		err := encryption.AssignProperties_From_ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS(source.Encryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS() to populate field Encryption")
		}
		configuration.Encryption = &encryption
	} else {
		configuration.Encryption = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS populates the provided destination ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS from our ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS
func (configuration *ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS) AssignProperties_To_ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS(destination *storage.ManagedEnvironment_Properties_PeerTrafficConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Encryption
	if configuration.Encryption != nil {
		var encryption storage.ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS
		err := configuration.Encryption.AssignProperties_To_ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS(&encryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS() to populate field Encryption")
		}
		destination.Encryption = &encryption
	} else {
		destination.Encryption = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedEnvironment_Properties_ProvisioningState_STATUS string

const (
	ManagedEnvironment_Properties_ProvisioningState_STATUS_Canceled                      = ManagedEnvironment_Properties_ProvisioningState_STATUS("Canceled")
	ManagedEnvironment_Properties_ProvisioningState_STATUS_Failed                        = ManagedEnvironment_Properties_ProvisioningState_STATUS("Failed")
	ManagedEnvironment_Properties_ProvisioningState_STATUS_InfrastructureSetupComplete   = ManagedEnvironment_Properties_ProvisioningState_STATUS("InfrastructureSetupComplete")
	ManagedEnvironment_Properties_ProvisioningState_STATUS_InfrastructureSetupInProgress = ManagedEnvironment_Properties_ProvisioningState_STATUS("InfrastructureSetupInProgress")
	ManagedEnvironment_Properties_ProvisioningState_STATUS_InitializationInProgress      = ManagedEnvironment_Properties_ProvisioningState_STATUS("InitializationInProgress")
	ManagedEnvironment_Properties_ProvisioningState_STATUS_ScheduledForDelete            = ManagedEnvironment_Properties_ProvisioningState_STATUS("ScheduledForDelete")
	ManagedEnvironment_Properties_ProvisioningState_STATUS_Succeeded                     = ManagedEnvironment_Properties_ProvisioningState_STATUS("Succeeded")
	ManagedEnvironment_Properties_ProvisioningState_STATUS_UpgradeFailed                 = ManagedEnvironment_Properties_ProvisioningState_STATUS("UpgradeFailed")
	ManagedEnvironment_Properties_ProvisioningState_STATUS_UpgradeRequested              = ManagedEnvironment_Properties_ProvisioningState_STATUS("UpgradeRequested")
	ManagedEnvironment_Properties_ProvisioningState_STATUS_Waiting                       = ManagedEnvironment_Properties_ProvisioningState_STATUS("Waiting")
)

// Mapping from string to ManagedEnvironment_Properties_ProvisioningState_STATUS
var managedEnvironment_Properties_ProvisioningState_STATUS_Values = map[string]ManagedEnvironment_Properties_ProvisioningState_STATUS{
	"canceled":                      ManagedEnvironment_Properties_ProvisioningState_STATUS_Canceled,
	"failed":                        ManagedEnvironment_Properties_ProvisioningState_STATUS_Failed,
	"infrastructuresetupcomplete":   ManagedEnvironment_Properties_ProvisioningState_STATUS_InfrastructureSetupComplete,
	"infrastructuresetupinprogress": ManagedEnvironment_Properties_ProvisioningState_STATUS_InfrastructureSetupInProgress,
	"initializationinprogress":      ManagedEnvironment_Properties_ProvisioningState_STATUS_InitializationInProgress,
	"scheduledfordelete":            ManagedEnvironment_Properties_ProvisioningState_STATUS_ScheduledForDelete,
	"succeeded":                     ManagedEnvironment_Properties_ProvisioningState_STATUS_Succeeded,
	"upgradefailed":                 ManagedEnvironment_Properties_ProvisioningState_STATUS_UpgradeFailed,
	"upgraderequested":              ManagedEnvironment_Properties_ProvisioningState_STATUS_UpgradeRequested,
	"waiting":                       ManagedEnvironment_Properties_ProvisioningState_STATUS_Waiting,
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type ManagedEnvironmentOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_ManagedEnvironmentOperatorSpec populates our ManagedEnvironmentOperatorSpec from the provided source ManagedEnvironmentOperatorSpec
func (operator *ManagedEnvironmentOperatorSpec) AssignProperties_From_ManagedEnvironmentOperatorSpec(source *storage.ManagedEnvironmentOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedEnvironmentOperatorSpec populates the provided destination ManagedEnvironmentOperatorSpec from our ManagedEnvironmentOperatorSpec
func (operator *ManagedEnvironmentOperatorSpec) AssignProperties_To_ManagedEnvironmentOperatorSpec(destination *storage.ManagedEnvironmentOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Configuration properties for apps environment to join a Virtual Network
type VnetConfiguration struct {
	// DockerBridgeCidr: CIDR notation IP range assigned to the Docker bridge, network. Must not overlap with any other
	// provided IP ranges.
	DockerBridgeCidr *string `json:"dockerBridgeCidr,omitempty"`

	// InfrastructureSubnetReference: Resource ID of a subnet for infrastructure components. Must not overlap with any other
	// provided IP ranges.
	InfrastructureSubnetReference *genruntime.ResourceReference `armReference:"InfrastructureSubnetId" json:"infrastructureSubnetReference,omitempty"`

	// Internal: Boolean indicating the environment only has an internal load balancer. These environments do not have a public
	// static IP resource. They must provide infrastructureSubnetId if enabling this property
	Internal *bool `json:"internal,omitempty"`

	// PlatformReservedCidr: IP range in CIDR notation that can be reserved for environment infrastructure IP addresses. Must
	// not overlap with any other provided IP ranges.
	PlatformReservedCidr *string `json:"platformReservedCidr,omitempty"`

	// PlatformReservedDnsIP:  An IP address from the IP range defined by platformReservedCidr that will be reserved for the
	// internal DNS server.
	PlatformReservedDnsIP *string `json:"platformReservedDnsIP,omitempty"`
}

var _ genruntime.ARMTransformer = &VnetConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *VnetConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.VnetConfiguration{}

	// Set property "DockerBridgeCidr":
	if configuration.DockerBridgeCidr != nil {
		dockerBridgeCidr := *configuration.DockerBridgeCidr
		result.DockerBridgeCidr = &dockerBridgeCidr
	}

	// Set property "InfrastructureSubnetId":
	if configuration.InfrastructureSubnetReference != nil {
		infrastructureSubnetReferenceARMID, err := resolved.ResolvedReferences.Lookup(*configuration.InfrastructureSubnetReference)
		if err != nil {
			return nil, err
		}
		infrastructureSubnetReference := infrastructureSubnetReferenceARMID
		result.InfrastructureSubnetId = &infrastructureSubnetReference
	}

	// Set property "Internal":
	if configuration.Internal != nil {
		internal := *configuration.Internal
		result.Internal = &internal
	}

	// Set property "PlatformReservedCidr":
	if configuration.PlatformReservedCidr != nil {
		platformReservedCidr := *configuration.PlatformReservedCidr
		result.PlatformReservedCidr = &platformReservedCidr
	}

	// Set property "PlatformReservedDnsIP":
	if configuration.PlatformReservedDnsIP != nil {
		platformReservedDnsIP := *configuration.PlatformReservedDnsIP
		result.PlatformReservedDnsIP = &platformReservedDnsIP
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *VnetConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VnetConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *VnetConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VnetConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VnetConfiguration, got %T", armInput)
	}

	// Set property "DockerBridgeCidr":
	if typedInput.DockerBridgeCidr != nil {
		dockerBridgeCidr := *typedInput.DockerBridgeCidr
		configuration.DockerBridgeCidr = &dockerBridgeCidr
	}

	// no assignment for property "InfrastructureSubnetReference"

	// Set property "Internal":
	if typedInput.Internal != nil {
		internal := *typedInput.Internal
		configuration.Internal = &internal
	}

	// Set property "PlatformReservedCidr":
	if typedInput.PlatformReservedCidr != nil {
		platformReservedCidr := *typedInput.PlatformReservedCidr
		configuration.PlatformReservedCidr = &platformReservedCidr
	}

	// Set property "PlatformReservedDnsIP":
	if typedInput.PlatformReservedDnsIP != nil {
		platformReservedDnsIP := *typedInput.PlatformReservedDnsIP
		configuration.PlatformReservedDnsIP = &platformReservedDnsIP
	}

	// No error
	return nil
}

// AssignProperties_From_VnetConfiguration populates our VnetConfiguration from the provided source VnetConfiguration
func (configuration *VnetConfiguration) AssignProperties_From_VnetConfiguration(source *storage.VnetConfiguration) error {

	// DockerBridgeCidr
	configuration.DockerBridgeCidr = genruntime.ClonePointerToString(source.DockerBridgeCidr)

	// InfrastructureSubnetReference
	if source.InfrastructureSubnetReference != nil {
		infrastructureSubnetReference := source.InfrastructureSubnetReference.Copy()
		configuration.InfrastructureSubnetReference = &infrastructureSubnetReference
	} else {
		configuration.InfrastructureSubnetReference = nil
	}

	// Internal
	if source.Internal != nil {
		internal := *source.Internal
		configuration.Internal = &internal
	} else {
		configuration.Internal = nil
	}

	// PlatformReservedCidr
	configuration.PlatformReservedCidr = genruntime.ClonePointerToString(source.PlatformReservedCidr)

	// PlatformReservedDnsIP
	configuration.PlatformReservedDnsIP = genruntime.ClonePointerToString(source.PlatformReservedDnsIP)

	// No error
	return nil
}

// AssignProperties_To_VnetConfiguration populates the provided destination VnetConfiguration from our VnetConfiguration
func (configuration *VnetConfiguration) AssignProperties_To_VnetConfiguration(destination *storage.VnetConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DockerBridgeCidr
	destination.DockerBridgeCidr = genruntime.ClonePointerToString(configuration.DockerBridgeCidr)

	// InfrastructureSubnetReference
	if configuration.InfrastructureSubnetReference != nil {
		infrastructureSubnetReference := configuration.InfrastructureSubnetReference.Copy()
		destination.InfrastructureSubnetReference = &infrastructureSubnetReference
	} else {
		destination.InfrastructureSubnetReference = nil
	}

	// Internal
	if configuration.Internal != nil {
		internal := *configuration.Internal
		destination.Internal = &internal
	} else {
		destination.Internal = nil
	}

	// PlatformReservedCidr
	destination.PlatformReservedCidr = genruntime.ClonePointerToString(configuration.PlatformReservedCidr)

	// PlatformReservedDnsIP
	destination.PlatformReservedDnsIP = genruntime.ClonePointerToString(configuration.PlatformReservedDnsIP)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VnetConfiguration_STATUS populates our VnetConfiguration from the provided source VnetConfiguration_STATUS
func (configuration *VnetConfiguration) Initialize_From_VnetConfiguration_STATUS(source *VnetConfiguration_STATUS) error {

	// DockerBridgeCidr
	configuration.DockerBridgeCidr = genruntime.ClonePointerToString(source.DockerBridgeCidr)

	// InfrastructureSubnetReference
	if source.InfrastructureSubnetId != nil {
		infrastructureSubnetReference := genruntime.CreateResourceReferenceFromARMID(*source.InfrastructureSubnetId)
		configuration.InfrastructureSubnetReference = &infrastructureSubnetReference
	} else {
		configuration.InfrastructureSubnetReference = nil
	}

	// Internal
	if source.Internal != nil {
		internal := *source.Internal
		configuration.Internal = &internal
	} else {
		configuration.Internal = nil
	}

	// PlatformReservedCidr
	configuration.PlatformReservedCidr = genruntime.ClonePointerToString(source.PlatformReservedCidr)

	// PlatformReservedDnsIP
	configuration.PlatformReservedDnsIP = genruntime.ClonePointerToString(source.PlatformReservedDnsIP)

	// No error
	return nil
}

// Configuration properties for apps environment to join a Virtual Network
type VnetConfiguration_STATUS struct {
	// DockerBridgeCidr: CIDR notation IP range assigned to the Docker bridge, network. Must not overlap with any other
	// provided IP ranges.
	DockerBridgeCidr *string `json:"dockerBridgeCidr,omitempty"`

	// InfrastructureSubnetId: Resource ID of a subnet for infrastructure components. Must not overlap with any other provided
	// IP ranges.
	InfrastructureSubnetId *string `json:"infrastructureSubnetId,omitempty"`

	// Internal: Boolean indicating the environment only has an internal load balancer. These environments do not have a public
	// static IP resource. They must provide infrastructureSubnetId if enabling this property
	Internal *bool `json:"internal,omitempty"`

	// PlatformReservedCidr: IP range in CIDR notation that can be reserved for environment infrastructure IP addresses. Must
	// not overlap with any other provided IP ranges.
	PlatformReservedCidr *string `json:"platformReservedCidr,omitempty"`

	// PlatformReservedDnsIP:  An IP address from the IP range defined by platformReservedCidr that will be reserved for the
	// internal DNS server.
	PlatformReservedDnsIP *string `json:"platformReservedDnsIP,omitempty"`
}

var _ genruntime.FromARMConverter = &VnetConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *VnetConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VnetConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *VnetConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VnetConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VnetConfiguration_STATUS, got %T", armInput)
	}

	// Set property "DockerBridgeCidr":
	if typedInput.DockerBridgeCidr != nil {
		dockerBridgeCidr := *typedInput.DockerBridgeCidr
		configuration.DockerBridgeCidr = &dockerBridgeCidr
	}

	// Set property "InfrastructureSubnetId":
	if typedInput.InfrastructureSubnetId != nil {
		infrastructureSubnetId := *typedInput.InfrastructureSubnetId
		configuration.InfrastructureSubnetId = &infrastructureSubnetId
	}

	// Set property "Internal":
	if typedInput.Internal != nil {
		internal := *typedInput.Internal
		configuration.Internal = &internal
	}

	// Set property "PlatformReservedCidr":
	if typedInput.PlatformReservedCidr != nil {
		platformReservedCidr := *typedInput.PlatformReservedCidr
		configuration.PlatformReservedCidr = &platformReservedCidr
	}

	// Set property "PlatformReservedDnsIP":
	if typedInput.PlatformReservedDnsIP != nil {
		platformReservedDnsIP := *typedInput.PlatformReservedDnsIP
		configuration.PlatformReservedDnsIP = &platformReservedDnsIP
	}

	// No error
	return nil
}

// AssignProperties_From_VnetConfiguration_STATUS populates our VnetConfiguration_STATUS from the provided source VnetConfiguration_STATUS
func (configuration *VnetConfiguration_STATUS) AssignProperties_From_VnetConfiguration_STATUS(source *storage.VnetConfiguration_STATUS) error {

	// DockerBridgeCidr
	configuration.DockerBridgeCidr = genruntime.ClonePointerToString(source.DockerBridgeCidr)

	// InfrastructureSubnetId
	configuration.InfrastructureSubnetId = genruntime.ClonePointerToString(source.InfrastructureSubnetId)

	// Internal
	if source.Internal != nil {
		internal := *source.Internal
		configuration.Internal = &internal
	} else {
		configuration.Internal = nil
	}

	// PlatformReservedCidr
	configuration.PlatformReservedCidr = genruntime.ClonePointerToString(source.PlatformReservedCidr)

	// PlatformReservedDnsIP
	configuration.PlatformReservedDnsIP = genruntime.ClonePointerToString(source.PlatformReservedDnsIP)

	// No error
	return nil
}

// AssignProperties_To_VnetConfiguration_STATUS populates the provided destination VnetConfiguration_STATUS from our VnetConfiguration_STATUS
func (configuration *VnetConfiguration_STATUS) AssignProperties_To_VnetConfiguration_STATUS(destination *storage.VnetConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DockerBridgeCidr
	destination.DockerBridgeCidr = genruntime.ClonePointerToString(configuration.DockerBridgeCidr)

	// InfrastructureSubnetId
	destination.InfrastructureSubnetId = genruntime.ClonePointerToString(configuration.InfrastructureSubnetId)

	// Internal
	if configuration.Internal != nil {
		internal := *configuration.Internal
		destination.Internal = &internal
	} else {
		destination.Internal = nil
	}

	// PlatformReservedCidr
	destination.PlatformReservedCidr = genruntime.ClonePointerToString(configuration.PlatformReservedCidr)

	// PlatformReservedDnsIP
	destination.PlatformReservedDnsIP = genruntime.ClonePointerToString(configuration.PlatformReservedDnsIP)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Workload profile to scope container app execution.
type WorkloadProfile struct {
	// MaximumCount: The maximum capacity.
	MaximumCount *int `json:"maximumCount,omitempty"`

	// MinimumCount: The minimum capacity.
	MinimumCount *int `json:"minimumCount,omitempty"`

	// +kubebuilder:validation:Required
	// Name: Workload profile type for the workloads to run on.
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// WorkloadProfileType: Workload profile type for the workloads to run on.
	WorkloadProfileType *string `json:"workloadProfileType,omitempty"`
}

var _ genruntime.ARMTransformer = &WorkloadProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *WorkloadProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.WorkloadProfile{}

	// Set property "MaximumCount":
	if profile.MaximumCount != nil {
		maximumCount := *profile.MaximumCount
		result.MaximumCount = &maximumCount
	}

	// Set property "MinimumCount":
	if profile.MinimumCount != nil {
		minimumCount := *profile.MinimumCount
		result.MinimumCount = &minimumCount
	}

	// Set property "Name":
	if profile.Name != nil {
		name := *profile.Name
		result.Name = &name
	}

	// Set property "WorkloadProfileType":
	if profile.WorkloadProfileType != nil {
		workloadProfileType := *profile.WorkloadProfileType
		result.WorkloadProfileType = &workloadProfileType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *WorkloadProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkloadProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *WorkloadProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkloadProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkloadProfile, got %T", armInput)
	}

	// Set property "MaximumCount":
	if typedInput.MaximumCount != nil {
		maximumCount := *typedInput.MaximumCount
		profile.MaximumCount = &maximumCount
	}

	// Set property "MinimumCount":
	if typedInput.MinimumCount != nil {
		minimumCount := *typedInput.MinimumCount
		profile.MinimumCount = &minimumCount
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		profile.Name = &name
	}

	// Set property "WorkloadProfileType":
	if typedInput.WorkloadProfileType != nil {
		workloadProfileType := *typedInput.WorkloadProfileType
		profile.WorkloadProfileType = &workloadProfileType
	}

	// No error
	return nil
}

// AssignProperties_From_WorkloadProfile populates our WorkloadProfile from the provided source WorkloadProfile
func (profile *WorkloadProfile) AssignProperties_From_WorkloadProfile(source *storage.WorkloadProfile) error {

	// MaximumCount
	profile.MaximumCount = genruntime.ClonePointerToInt(source.MaximumCount)

	// MinimumCount
	profile.MinimumCount = genruntime.ClonePointerToInt(source.MinimumCount)

	// Name
	profile.Name = genruntime.ClonePointerToString(source.Name)

	// WorkloadProfileType
	profile.WorkloadProfileType = genruntime.ClonePointerToString(source.WorkloadProfileType)

	// No error
	return nil
}

// AssignProperties_To_WorkloadProfile populates the provided destination WorkloadProfile from our WorkloadProfile
func (profile *WorkloadProfile) AssignProperties_To_WorkloadProfile(destination *storage.WorkloadProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MaximumCount
	destination.MaximumCount = genruntime.ClonePointerToInt(profile.MaximumCount)

	// MinimumCount
	destination.MinimumCount = genruntime.ClonePointerToInt(profile.MinimumCount)

	// Name
	destination.Name = genruntime.ClonePointerToString(profile.Name)

	// WorkloadProfileType
	destination.WorkloadProfileType = genruntime.ClonePointerToString(profile.WorkloadProfileType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_WorkloadProfile_STATUS populates our WorkloadProfile from the provided source WorkloadProfile_STATUS
func (profile *WorkloadProfile) Initialize_From_WorkloadProfile_STATUS(source *WorkloadProfile_STATUS) error {

	// MaximumCount
	profile.MaximumCount = genruntime.ClonePointerToInt(source.MaximumCount)

	// MinimumCount
	profile.MinimumCount = genruntime.ClonePointerToInt(source.MinimumCount)

	// Name
	profile.Name = genruntime.ClonePointerToString(source.Name)

	// WorkloadProfileType
	profile.WorkloadProfileType = genruntime.ClonePointerToString(source.WorkloadProfileType)

	// No error
	return nil
}

// Workload profile to scope container app execution.
type WorkloadProfile_STATUS struct {
	// MaximumCount: The maximum capacity.
	MaximumCount *int `json:"maximumCount,omitempty"`

	// MinimumCount: The minimum capacity.
	MinimumCount *int `json:"minimumCount,omitempty"`

	// Name: Workload profile type for the workloads to run on.
	Name *string `json:"name,omitempty"`

	// WorkloadProfileType: Workload profile type for the workloads to run on.
	WorkloadProfileType *string `json:"workloadProfileType,omitempty"`
}

var _ genruntime.FromARMConverter = &WorkloadProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *WorkloadProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkloadProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *WorkloadProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkloadProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkloadProfile_STATUS, got %T", armInput)
	}

	// Set property "MaximumCount":
	if typedInput.MaximumCount != nil {
		maximumCount := *typedInput.MaximumCount
		profile.MaximumCount = &maximumCount
	}

	// Set property "MinimumCount":
	if typedInput.MinimumCount != nil {
		minimumCount := *typedInput.MinimumCount
		profile.MinimumCount = &minimumCount
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		profile.Name = &name
	}

	// Set property "WorkloadProfileType":
	if typedInput.WorkloadProfileType != nil {
		workloadProfileType := *typedInput.WorkloadProfileType
		profile.WorkloadProfileType = &workloadProfileType
	}

	// No error
	return nil
}

// AssignProperties_From_WorkloadProfile_STATUS populates our WorkloadProfile_STATUS from the provided source WorkloadProfile_STATUS
func (profile *WorkloadProfile_STATUS) AssignProperties_From_WorkloadProfile_STATUS(source *storage.WorkloadProfile_STATUS) error {

	// MaximumCount
	profile.MaximumCount = genruntime.ClonePointerToInt(source.MaximumCount)

	// MinimumCount
	profile.MinimumCount = genruntime.ClonePointerToInt(source.MinimumCount)

	// Name
	profile.Name = genruntime.ClonePointerToString(source.Name)

	// WorkloadProfileType
	profile.WorkloadProfileType = genruntime.ClonePointerToString(source.WorkloadProfileType)

	// No error
	return nil
}

// AssignProperties_To_WorkloadProfile_STATUS populates the provided destination WorkloadProfile_STATUS from our WorkloadProfile_STATUS
func (profile *WorkloadProfile_STATUS) AssignProperties_To_WorkloadProfile_STATUS(destination *storage.WorkloadProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MaximumCount
	destination.MaximumCount = genruntime.ClonePointerToInt(profile.MaximumCount)

	// MinimumCount
	destination.MinimumCount = genruntime.ClonePointerToInt(profile.MinimumCount)

	// Name
	destination.Name = genruntime.ClonePointerToString(profile.Name)

	// WorkloadProfileType
	destination.WorkloadProfileType = genruntime.ClonePointerToString(profile.WorkloadProfileType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Log Analytics configuration, must only be provided when destination is configured as 'log-analytics'
type LogAnalyticsConfiguration struct {
	// CustomerId: Log analytics customer id
	CustomerId *string `json:"customerId,omitempty"`

	// SharedKey: Log analytics customer key
	SharedKey *genruntime.SecretReference `json:"sharedKey,omitempty"`
}

var _ genruntime.ARMTransformer = &LogAnalyticsConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *LogAnalyticsConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.LogAnalyticsConfiguration{}

	// Set property "CustomerId":
	if configuration.CustomerId != nil {
		customerId := *configuration.CustomerId
		result.CustomerId = &customerId
	}

	// Set property "SharedKey":
	if configuration.SharedKey != nil {
		sharedKeySecret, err := resolved.ResolvedSecrets.Lookup(*configuration.SharedKey)
		if err != nil {
			return nil, eris.Wrap(err, "looking up secret for property SharedKey")
		}
		sharedKey := sharedKeySecret
		result.SharedKey = &sharedKey
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *LogAnalyticsConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.LogAnalyticsConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *LogAnalyticsConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.LogAnalyticsConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.LogAnalyticsConfiguration, got %T", armInput)
	}

	// Set property "CustomerId":
	if typedInput.CustomerId != nil {
		customerId := *typedInput.CustomerId
		configuration.CustomerId = &customerId
	}

	// no assignment for property "SharedKey"

	// No error
	return nil
}

// AssignProperties_From_LogAnalyticsConfiguration populates our LogAnalyticsConfiguration from the provided source LogAnalyticsConfiguration
func (configuration *LogAnalyticsConfiguration) AssignProperties_From_LogAnalyticsConfiguration(source *storage.LogAnalyticsConfiguration) error {

	// CustomerId
	configuration.CustomerId = genruntime.ClonePointerToString(source.CustomerId)

	// SharedKey
	if source.SharedKey != nil {
		sharedKey := source.SharedKey.Copy()
		configuration.SharedKey = &sharedKey
	} else {
		configuration.SharedKey = nil
	}

	// No error
	return nil
}

// AssignProperties_To_LogAnalyticsConfiguration populates the provided destination LogAnalyticsConfiguration from our LogAnalyticsConfiguration
func (configuration *LogAnalyticsConfiguration) AssignProperties_To_LogAnalyticsConfiguration(destination *storage.LogAnalyticsConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CustomerId
	destination.CustomerId = genruntime.ClonePointerToString(configuration.CustomerId)

	// SharedKey
	if configuration.SharedKey != nil {
		sharedKey := configuration.SharedKey.Copy()
		destination.SharedKey = &sharedKey
	} else {
		destination.SharedKey = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_LogAnalyticsConfiguration_STATUS populates our LogAnalyticsConfiguration from the provided source LogAnalyticsConfiguration_STATUS
func (configuration *LogAnalyticsConfiguration) Initialize_From_LogAnalyticsConfiguration_STATUS(source *LogAnalyticsConfiguration_STATUS) error {

	// CustomerId
	configuration.CustomerId = genruntime.ClonePointerToString(source.CustomerId)

	// No error
	return nil
}

// Log Analytics configuration, must only be provided when destination is configured as 'log-analytics'
type LogAnalyticsConfiguration_STATUS struct {
	// CustomerId: Log analytics customer id
	CustomerId *string `json:"customerId,omitempty"`
}

var _ genruntime.FromARMConverter = &LogAnalyticsConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *LogAnalyticsConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.LogAnalyticsConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *LogAnalyticsConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.LogAnalyticsConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.LogAnalyticsConfiguration_STATUS, got %T", armInput)
	}

	// Set property "CustomerId":
	if typedInput.CustomerId != nil {
		customerId := *typedInput.CustomerId
		configuration.CustomerId = &customerId
	}

	// No error
	return nil
}

// AssignProperties_From_LogAnalyticsConfiguration_STATUS populates our LogAnalyticsConfiguration_STATUS from the provided source LogAnalyticsConfiguration_STATUS
func (configuration *LogAnalyticsConfiguration_STATUS) AssignProperties_From_LogAnalyticsConfiguration_STATUS(source *storage.LogAnalyticsConfiguration_STATUS) error {

	// CustomerId
	configuration.CustomerId = genruntime.ClonePointerToString(source.CustomerId)

	// No error
	return nil
}

// AssignProperties_To_LogAnalyticsConfiguration_STATUS populates the provided destination LogAnalyticsConfiguration_STATUS from our LogAnalyticsConfiguration_STATUS
func (configuration *LogAnalyticsConfiguration_STATUS) AssignProperties_To_LogAnalyticsConfiguration_STATUS(destination *storage.LogAnalyticsConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CustomerId
	destination.CustomerId = genruntime.ClonePointerToString(configuration.CustomerId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec struct {
	// Enabled: Boolean indicating whether the peer traffic encryption is enabled
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (encryption *ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if encryption == nil {
		return nil, nil
	}
	result := &arm.ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec{}

	// Set property "Enabled":
	if encryption.Enabled != nil {
		enabled := *encryption.Enabled
		result.Enabled = &enabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (encryption *ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (encryption *ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		encryption.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec populates our ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec from the provided source ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec
func (encryption *ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec) AssignProperties_From_ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec(source *storage.ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		encryption.Enabled = &enabled
	} else {
		encryption.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec populates the provided destination ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec from our ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec
func (encryption *ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec) AssignProperties_To_ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec(destination *storage.ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if encryption.Enabled != nil {
		enabled := *encryption.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS populates our ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec from the provided source ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS
func (encryption *ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_Spec) Initialize_From_ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS(source *ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		encryption.Enabled = &enabled
	} else {
		encryption.Enabled = nil
	}

	// No error
	return nil
}

type ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS struct {
	// Enabled: Boolean indicating whether the peer traffic encryption is enabled
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (encryption *ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (encryption *ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		encryption.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS populates our ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS from the provided source ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS
func (encryption *ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS) AssignProperties_From_ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS(source *storage.ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		encryption.Enabled = &enabled
	} else {
		encryption.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS populates the provided destination ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS from our ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS
func (encryption *ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS) AssignProperties_To_ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS(destination *storage.ManagedEnvironment_Properties_PeerTrafficConfiguration_Encryption_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if encryption.Enabled != nil {
		enabled := *encryption.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Configuration properties for mutual TLS authentication
type Mtls struct {
	// Enabled: Boolean indicating whether the mutual TLS authentication is enabled
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.ARMTransformer = &Mtls{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (mtls *Mtls) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if mtls == nil {
		return nil, nil
	}
	result := &arm.Mtls{}

	// Set property "Enabled":
	if mtls.Enabled != nil {
		enabled := *mtls.Enabled
		result.Enabled = &enabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (mtls *Mtls) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Mtls{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (mtls *Mtls) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Mtls)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Mtls, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		mtls.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_Mtls populates our Mtls from the provided source Mtls
func (mtls *Mtls) AssignProperties_From_Mtls(source *storage.Mtls) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		mtls.Enabled = &enabled
	} else {
		mtls.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Mtls populates the provided destination Mtls from our Mtls
func (mtls *Mtls) AssignProperties_To_Mtls(destination *storage.Mtls) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if mtls.Enabled != nil {
		enabled := *mtls.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Mtls_STATUS populates our Mtls from the provided source Mtls_STATUS
func (mtls *Mtls) Initialize_From_Mtls_STATUS(source *Mtls_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		mtls.Enabled = &enabled
	} else {
		mtls.Enabled = nil
	}

	// No error
	return nil
}

// Configuration properties for mutual TLS authentication
type Mtls_STATUS struct {
	// Enabled: Boolean indicating whether the mutual TLS authentication is enabled
	Enabled *bool `json:"enabled,omitempty"`
}

var _ genruntime.FromARMConverter = &Mtls_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (mtls *Mtls_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Mtls_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (mtls *Mtls_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Mtls_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Mtls_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		mtls.Enabled = &enabled
	}

	// No error
	return nil
}

// AssignProperties_From_Mtls_STATUS populates our Mtls_STATUS from the provided source Mtls_STATUS
func (mtls *Mtls_STATUS) AssignProperties_From_Mtls_STATUS(source *storage.Mtls_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		mtls.Enabled = &enabled
	} else {
		mtls.Enabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Mtls_STATUS populates the provided destination Mtls_STATUS from our Mtls_STATUS
func (mtls *Mtls_STATUS) AssignProperties_To_Mtls_STATUS(destination *storage.Mtls_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if mtls.Enabled != nil {
		enabled := *mtls.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&ManagedEnvironment{}, &ManagedEnvironmentList{})
}
