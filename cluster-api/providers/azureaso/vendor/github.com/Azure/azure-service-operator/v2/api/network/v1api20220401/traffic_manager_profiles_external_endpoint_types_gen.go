// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20220401

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/network/v1api20220401/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/network/v1api20220401/storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /trafficmanager/resource-manager/Microsoft.Network/stable/2022-04-01/trafficmanager.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficmanagerprofiles/{profileName}/ExternalEndpoints/{endpointName}
type TrafficManagerProfilesExternalEndpoint struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              TrafficManagerProfilesExternalEndpoint_Spec   `json:"spec,omitempty"`
	Status            TrafficManagerProfilesExternalEndpoint_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &TrafficManagerProfilesExternalEndpoint{}

// GetConditions returns the conditions of the resource
func (endpoint *TrafficManagerProfilesExternalEndpoint) GetConditions() conditions.Conditions {
	return endpoint.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (endpoint *TrafficManagerProfilesExternalEndpoint) SetConditions(conditions conditions.Conditions) {
	endpoint.Status.Conditions = conditions
}

var _ conversion.Convertible = &TrafficManagerProfilesExternalEndpoint{}

// ConvertFrom populates our TrafficManagerProfilesExternalEndpoint from the provided hub TrafficManagerProfilesExternalEndpoint
func (endpoint *TrafficManagerProfilesExternalEndpoint) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.TrafficManagerProfilesExternalEndpoint)
	if !ok {
		return fmt.Errorf("expected network/v1api20220401/storage/TrafficManagerProfilesExternalEndpoint but received %T instead", hub)
	}

	return endpoint.AssignProperties_From_TrafficManagerProfilesExternalEndpoint(source)
}

// ConvertTo populates the provided hub TrafficManagerProfilesExternalEndpoint from our TrafficManagerProfilesExternalEndpoint
func (endpoint *TrafficManagerProfilesExternalEndpoint) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.TrafficManagerProfilesExternalEndpoint)
	if !ok {
		return fmt.Errorf("expected network/v1api20220401/storage/TrafficManagerProfilesExternalEndpoint but received %T instead", hub)
	}

	return endpoint.AssignProperties_To_TrafficManagerProfilesExternalEndpoint(destination)
}

// +kubebuilder:webhook:path=/mutate-network-azure-com-v1api20220401-trafficmanagerprofilesexternalendpoint,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=network.azure.com,resources=trafficmanagerprofilesexternalendpoints,verbs=create;update,versions=v1api20220401,name=default.v1api20220401.trafficmanagerprofilesexternalendpoints.network.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &TrafficManagerProfilesExternalEndpoint{}

// Default applies defaults to the TrafficManagerProfilesExternalEndpoint resource
func (endpoint *TrafficManagerProfilesExternalEndpoint) Default() {
	endpoint.defaultImpl()
	var temp any = endpoint
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (endpoint *TrafficManagerProfilesExternalEndpoint) defaultAzureName() {
	if endpoint.Spec.AzureName == "" {
		endpoint.Spec.AzureName = endpoint.Name
	}
}

// defaultImpl applies the code generated defaults to the TrafficManagerProfilesExternalEndpoint resource
func (endpoint *TrafficManagerProfilesExternalEndpoint) defaultImpl() { endpoint.defaultAzureName() }

var _ configmaps.Exporter = &TrafficManagerProfilesExternalEndpoint{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (endpoint *TrafficManagerProfilesExternalEndpoint) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if endpoint.Spec.OperatorSpec == nil {
		return nil
	}
	return endpoint.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &TrafficManagerProfilesExternalEndpoint{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (endpoint *TrafficManagerProfilesExternalEndpoint) SecretDestinationExpressions() []*core.DestinationExpression {
	if endpoint.Spec.OperatorSpec == nil {
		return nil
	}
	return endpoint.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &TrafficManagerProfilesExternalEndpoint{}

// InitializeSpec initializes the spec for this resource from the given status
func (endpoint *TrafficManagerProfilesExternalEndpoint) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*TrafficManagerProfilesExternalEndpoint_STATUS); ok {
		return endpoint.Spec.Initialize_From_TrafficManagerProfilesExternalEndpoint_STATUS(s)
	}

	return fmt.Errorf("expected Status of type TrafficManagerProfilesExternalEndpoint_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &TrafficManagerProfilesExternalEndpoint{}

// AzureName returns the Azure name of the resource
func (endpoint *TrafficManagerProfilesExternalEndpoint) AzureName() string {
	return endpoint.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2022-04-01"
func (endpoint TrafficManagerProfilesExternalEndpoint) GetAPIVersion() string {
	return "2022-04-01"
}

// GetResourceScope returns the scope of the resource
func (endpoint *TrafficManagerProfilesExternalEndpoint) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (endpoint *TrafficManagerProfilesExternalEndpoint) GetSpec() genruntime.ConvertibleSpec {
	return &endpoint.Spec
}

// GetStatus returns the status of this resource
func (endpoint *TrafficManagerProfilesExternalEndpoint) GetStatus() genruntime.ConvertibleStatus {
	return &endpoint.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (endpoint *TrafficManagerProfilesExternalEndpoint) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Network/trafficmanagerprofiles/ExternalEndpoints"
func (endpoint *TrafficManagerProfilesExternalEndpoint) GetType() string {
	return "Microsoft.Network/trafficmanagerprofiles/ExternalEndpoints"
}

// NewEmptyStatus returns a new empty (blank) status
func (endpoint *TrafficManagerProfilesExternalEndpoint) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &TrafficManagerProfilesExternalEndpoint_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (endpoint *TrafficManagerProfilesExternalEndpoint) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(endpoint.Spec)
	return endpoint.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (endpoint *TrafficManagerProfilesExternalEndpoint) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*TrafficManagerProfilesExternalEndpoint_STATUS); ok {
		endpoint.Status = *st
		return nil
	}

	// Convert status to required version
	var st TrafficManagerProfilesExternalEndpoint_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	endpoint.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-network-azure-com-v1api20220401-trafficmanagerprofilesexternalendpoint,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=network.azure.com,resources=trafficmanagerprofilesexternalendpoints,verbs=create;update,versions=v1api20220401,name=validate.v1api20220401.trafficmanagerprofilesexternalendpoints.network.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &TrafficManagerProfilesExternalEndpoint{}

// ValidateCreate validates the creation of the resource
func (endpoint *TrafficManagerProfilesExternalEndpoint) ValidateCreate() (admission.Warnings, error) {
	validations := endpoint.createValidations()
	var temp any = endpoint
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	return genruntime.ValidateCreate(validations)
}

// ValidateDelete validates the deletion of the resource
func (endpoint *TrafficManagerProfilesExternalEndpoint) ValidateDelete() (admission.Warnings, error) {
	validations := endpoint.deleteValidations()
	var temp any = endpoint
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	return genruntime.ValidateDelete(validations)
}

// ValidateUpdate validates an update of the resource
func (endpoint *TrafficManagerProfilesExternalEndpoint) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	validations := endpoint.updateValidations()
	var temp any = endpoint
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	return genruntime.ValidateUpdate(old, validations)
}

// createValidations validates the creation of the resource
func (endpoint *TrafficManagerProfilesExternalEndpoint) createValidations() []func() (admission.Warnings, error) {
	return []func() (admission.Warnings, error){endpoint.validateResourceReferences, endpoint.validateOwnerReference, endpoint.validateSecretDestinations, endpoint.validateConfigMapDestinations}
}

// deleteValidations validates the deletion of the resource
func (endpoint *TrafficManagerProfilesExternalEndpoint) deleteValidations() []func() (admission.Warnings, error) {
	return nil
}

// updateValidations validates the update of the resource
func (endpoint *TrafficManagerProfilesExternalEndpoint) updateValidations() []func(old runtime.Object) (admission.Warnings, error) {
	return []func(old runtime.Object) (admission.Warnings, error){
		func(old runtime.Object) (admission.Warnings, error) {
			return endpoint.validateResourceReferences()
		},
		endpoint.validateWriteOnceProperties,
		func(old runtime.Object) (admission.Warnings, error) {
			return endpoint.validateOwnerReference()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return endpoint.validateSecretDestinations()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return endpoint.validateConfigMapDestinations()
		},
	}
}

// validateConfigMapDestinations validates there are no colliding genruntime.ConfigMapDestinations
func (endpoint *TrafficManagerProfilesExternalEndpoint) validateConfigMapDestinations() (admission.Warnings, error) {
	if endpoint.Spec.OperatorSpec == nil {
		return nil, nil
	}
	return configmaps.ValidateDestinations(endpoint, nil, endpoint.Spec.OperatorSpec.ConfigMapExpressions)
}

// validateOwnerReference validates the owner field
func (endpoint *TrafficManagerProfilesExternalEndpoint) validateOwnerReference() (admission.Warnings, error) {
	return genruntime.ValidateOwner(endpoint)
}

// validateResourceReferences validates all resource references
func (endpoint *TrafficManagerProfilesExternalEndpoint) validateResourceReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindResourceReferences(&endpoint.Spec)
	if err != nil {
		return nil, err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateSecretDestinations validates there are no colliding genruntime.SecretDestination's
func (endpoint *TrafficManagerProfilesExternalEndpoint) validateSecretDestinations() (admission.Warnings, error) {
	if endpoint.Spec.OperatorSpec == nil {
		return nil, nil
	}
	return secrets.ValidateDestinations(endpoint, nil, endpoint.Spec.OperatorSpec.SecretExpressions)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (endpoint *TrafficManagerProfilesExternalEndpoint) validateWriteOnceProperties(old runtime.Object) (admission.Warnings, error) {
	oldObj, ok := old.(*TrafficManagerProfilesExternalEndpoint)
	if !ok {
		return nil, nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, endpoint)
}

// AssignProperties_From_TrafficManagerProfilesExternalEndpoint populates our TrafficManagerProfilesExternalEndpoint from the provided source TrafficManagerProfilesExternalEndpoint
func (endpoint *TrafficManagerProfilesExternalEndpoint) AssignProperties_From_TrafficManagerProfilesExternalEndpoint(source *storage.TrafficManagerProfilesExternalEndpoint) error {

	// ObjectMeta
	endpoint.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec TrafficManagerProfilesExternalEndpoint_Spec
	err := spec.AssignProperties_From_TrafficManagerProfilesExternalEndpoint_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_TrafficManagerProfilesExternalEndpoint_Spec() to populate field Spec")
	}
	endpoint.Spec = spec

	// Status
	var status TrafficManagerProfilesExternalEndpoint_STATUS
	err = status.AssignProperties_From_TrafficManagerProfilesExternalEndpoint_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_TrafficManagerProfilesExternalEndpoint_STATUS() to populate field Status")
	}
	endpoint.Status = status

	// No error
	return nil
}

// AssignProperties_To_TrafficManagerProfilesExternalEndpoint populates the provided destination TrafficManagerProfilesExternalEndpoint from our TrafficManagerProfilesExternalEndpoint
func (endpoint *TrafficManagerProfilesExternalEndpoint) AssignProperties_To_TrafficManagerProfilesExternalEndpoint(destination *storage.TrafficManagerProfilesExternalEndpoint) error {

	// ObjectMeta
	destination.ObjectMeta = *endpoint.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.TrafficManagerProfilesExternalEndpoint_Spec
	err := endpoint.Spec.AssignProperties_To_TrafficManagerProfilesExternalEndpoint_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_TrafficManagerProfilesExternalEndpoint_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.TrafficManagerProfilesExternalEndpoint_STATUS
	err = endpoint.Status.AssignProperties_To_TrafficManagerProfilesExternalEndpoint_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_TrafficManagerProfilesExternalEndpoint_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (endpoint *TrafficManagerProfilesExternalEndpoint) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: endpoint.Spec.OriginalVersion(),
		Kind:    "TrafficManagerProfilesExternalEndpoint",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /trafficmanager/resource-manager/Microsoft.Network/stable/2022-04-01/trafficmanager.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficmanagerprofiles/{profileName}/ExternalEndpoints/{endpointName}
type TrafficManagerProfilesExternalEndpointList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []TrafficManagerProfilesExternalEndpoint `json:"items"`
}

type TrafficManagerProfilesExternalEndpoint_Spec struct {
	// AlwaysServe: If Always Serve is enabled, probing for endpoint health will be disabled and endpoints will be included in
	// the traffic routing method.
	AlwaysServe *EndpointProperties_AlwaysServe `json:"alwaysServe,omitempty"`

	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// CustomHeaders: List of custom headers.
	CustomHeaders []EndpointProperties_CustomHeaders `json:"customHeaders,omitempty"`

	// EndpointLocation: Specifies the location of the external or nested endpoints when using the 'Performance' traffic
	// routing method.
	EndpointLocation *string `json:"endpointLocation,omitempty"`

	// EndpointMonitorStatus: The monitoring status of the endpoint.
	EndpointMonitorStatus *EndpointProperties_EndpointMonitorStatus `json:"endpointMonitorStatus,omitempty"`

	// EndpointStatus: The status of the endpoint. If the endpoint is Enabled, it is probed for endpoint health and is included
	// in the traffic routing method.
	EndpointStatus *EndpointProperties_EndpointStatus `json:"endpointStatus,omitempty"`

	// GeoMapping: The list of countries/regions mapped to this endpoint when using the 'Geographic' traffic routing method.
	// Please consult Traffic Manager Geographic documentation for a full list of accepted values.
	GeoMapping []string `json:"geoMapping,omitempty"`

	// MinChildEndpoints: The minimum number of endpoints that must be available in the child profile in order for the parent
	// profile to be considered available. Only applicable to endpoint of type 'NestedEndpoints'.
	MinChildEndpoints *int `json:"minChildEndpoints,omitempty"`

	// MinChildEndpointsIPv4: The minimum number of IPv4 (DNS record type A) endpoints that must be available in the child
	// profile in order for the parent profile to be considered available. Only applicable to endpoint of type
	// 'NestedEndpoints'.
	MinChildEndpointsIPv4 *int `json:"minChildEndpointsIPv4,omitempty"`

	// MinChildEndpointsIPv6: The minimum number of IPv6 (DNS record type AAAA) endpoints that must be available in the child
	// profile in order for the parent profile to be considered available. Only applicable to endpoint of type
	// 'NestedEndpoints'.
	MinChildEndpointsIPv6 *int `json:"minChildEndpointsIPv6,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *TrafficManagerProfilesExternalEndpointOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a network.azure.com/TrafficManagerProfile resource
	Owner *genruntime.KnownResourceReference `group:"network.azure.com" json:"owner,omitempty" kind:"TrafficManagerProfile"`

	// Priority: The priority of this endpoint when using the 'Priority' traffic routing method. Possible values are from 1 to
	// 1000, lower values represent higher priority. This is an optional parameter.  If specified, it must be specified on all
	// endpoints, and no two endpoints can share the same priority value.
	Priority *int `json:"priority,omitempty"`

	// Subnets: The list of subnets, IP addresses, and/or address ranges mapped to this endpoint when using the 'Subnet'
	// traffic routing method. An empty list will match all ranges not covered by other endpoints.
	Subnets []EndpointProperties_Subnets `json:"subnets,omitempty"`

	// Target: The fully-qualified DNS name or IP address of the endpoint. Traffic Manager returns this value in DNS responses
	// to direct traffic to this endpoint.
	Target *string `json:"target,omitempty"`

	// TargetResourceReference: The Azure Resource URI of the of the endpoint. Not applicable to endpoints of type
	// 'ExternalEndpoints'.
	TargetResourceReference *genruntime.ResourceReference `armReference:"TargetResourceId" json:"targetResourceReference,omitempty"`

	// Type: The type of the resource. Ex- Microsoft.Network/trafficManagerProfiles.
	Type *string `json:"type,omitempty"`

	// Weight: The weight of this endpoint when using the 'Weighted' traffic routing method. Possible values are from 1 to 1000.
	Weight *int `json:"weight,omitempty"`
}

var _ genruntime.ARMTransformer = &TrafficManagerProfilesExternalEndpoint_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (endpoint *TrafficManagerProfilesExternalEndpoint_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if endpoint == nil {
		return nil, nil
	}
	result := &arm.TrafficManagerProfilesExternalEndpoint_Spec{}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if endpoint.AlwaysServe != nil ||
		endpoint.CustomHeaders != nil ||
		endpoint.EndpointLocation != nil ||
		endpoint.EndpointMonitorStatus != nil ||
		endpoint.EndpointStatus != nil ||
		endpoint.GeoMapping != nil ||
		endpoint.MinChildEndpoints != nil ||
		endpoint.MinChildEndpointsIPv4 != nil ||
		endpoint.MinChildEndpointsIPv6 != nil ||
		endpoint.Priority != nil ||
		endpoint.Subnets != nil ||
		endpoint.Target != nil ||
		endpoint.TargetResourceReference != nil ||
		endpoint.Weight != nil {
		result.Properties = &arm.EndpointProperties{}
	}
	if endpoint.AlwaysServe != nil {
		var temp string
		temp = string(*endpoint.AlwaysServe)
		alwaysServe := arm.EndpointProperties_AlwaysServe(temp)
		result.Properties.AlwaysServe = &alwaysServe
	}
	for _, item := range endpoint.CustomHeaders {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.CustomHeaders = append(result.Properties.CustomHeaders, *item_ARM.(*arm.EndpointProperties_CustomHeaders))
	}
	if endpoint.EndpointLocation != nil {
		endpointLocation := *endpoint.EndpointLocation
		result.Properties.EndpointLocation = &endpointLocation
	}
	if endpoint.EndpointMonitorStatus != nil {
		var temp string
		temp = string(*endpoint.EndpointMonitorStatus)
		endpointMonitorStatus := arm.EndpointProperties_EndpointMonitorStatus(temp)
		result.Properties.EndpointMonitorStatus = &endpointMonitorStatus
	}
	if endpoint.EndpointStatus != nil {
		var temp string
		temp = string(*endpoint.EndpointStatus)
		endpointStatus := arm.EndpointProperties_EndpointStatus(temp)
		result.Properties.EndpointStatus = &endpointStatus
	}
	for _, item := range endpoint.GeoMapping {
		result.Properties.GeoMapping = append(result.Properties.GeoMapping, item)
	}
	if endpoint.MinChildEndpoints != nil {
		minChildEndpoints := *endpoint.MinChildEndpoints
		result.Properties.MinChildEndpoints = &minChildEndpoints
	}
	if endpoint.MinChildEndpointsIPv4 != nil {
		minChildEndpointsIPv4 := *endpoint.MinChildEndpointsIPv4
		result.Properties.MinChildEndpointsIPv4 = &minChildEndpointsIPv4
	}
	if endpoint.MinChildEndpointsIPv6 != nil {
		minChildEndpointsIPv6 := *endpoint.MinChildEndpointsIPv6
		result.Properties.MinChildEndpointsIPv6 = &minChildEndpointsIPv6
	}
	if endpoint.Priority != nil {
		priority := *endpoint.Priority
		result.Properties.Priority = &priority
	}
	for _, item := range endpoint.Subnets {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.Subnets = append(result.Properties.Subnets, *item_ARM.(*arm.EndpointProperties_Subnets))
	}
	if endpoint.Target != nil {
		target := *endpoint.Target
		result.Properties.Target = &target
	}
	if endpoint.TargetResourceReference != nil {
		targetResourceIdARMID, err := resolved.ResolvedReferences.Lookup(*endpoint.TargetResourceReference)
		if err != nil {
			return nil, err
		}
		targetResourceId := targetResourceIdARMID
		result.Properties.TargetResourceId = &targetResourceId
	}
	if endpoint.Weight != nil {
		weight := *endpoint.Weight
		result.Properties.Weight = &weight
	}

	// Set property "Type":
	if endpoint.Type != nil {
		typeVar := *endpoint.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (endpoint *TrafficManagerProfilesExternalEndpoint_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TrafficManagerProfilesExternalEndpoint_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (endpoint *TrafficManagerProfilesExternalEndpoint_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TrafficManagerProfilesExternalEndpoint_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TrafficManagerProfilesExternalEndpoint_Spec, got %T", armInput)
	}

	// Set property "AlwaysServe":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AlwaysServe != nil {
			var temp string
			temp = string(*typedInput.Properties.AlwaysServe)
			alwaysServe := EndpointProperties_AlwaysServe(temp)
			endpoint.AlwaysServe = &alwaysServe
		}
	}

	// Set property "AzureName":
	endpoint.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "CustomHeaders":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.CustomHeaders {
			var item1 EndpointProperties_CustomHeaders
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.CustomHeaders = append(endpoint.CustomHeaders, item1)
		}
	}

	// Set property "EndpointLocation":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EndpointLocation != nil {
			endpointLocation := *typedInput.Properties.EndpointLocation
			endpoint.EndpointLocation = &endpointLocation
		}
	}

	// Set property "EndpointMonitorStatus":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EndpointMonitorStatus != nil {
			var temp string
			temp = string(*typedInput.Properties.EndpointMonitorStatus)
			endpointMonitorStatus := EndpointProperties_EndpointMonitorStatus(temp)
			endpoint.EndpointMonitorStatus = &endpointMonitorStatus
		}
	}

	// Set property "EndpointStatus":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EndpointStatus != nil {
			var temp string
			temp = string(*typedInput.Properties.EndpointStatus)
			endpointStatus := EndpointProperties_EndpointStatus(temp)
			endpoint.EndpointStatus = &endpointStatus
		}
	}

	// Set property "GeoMapping":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.GeoMapping {
			endpoint.GeoMapping = append(endpoint.GeoMapping, item)
		}
	}

	// Set property "MinChildEndpoints":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinChildEndpoints != nil {
			minChildEndpoints := *typedInput.Properties.MinChildEndpoints
			endpoint.MinChildEndpoints = &minChildEndpoints
		}
	}

	// Set property "MinChildEndpointsIPv4":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinChildEndpointsIPv4 != nil {
			minChildEndpointsIPv4 := *typedInput.Properties.MinChildEndpointsIPv4
			endpoint.MinChildEndpointsIPv4 = &minChildEndpointsIPv4
		}
	}

	// Set property "MinChildEndpointsIPv6":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinChildEndpointsIPv6 != nil {
			minChildEndpointsIPv6 := *typedInput.Properties.MinChildEndpointsIPv6
			endpoint.MinChildEndpointsIPv6 = &minChildEndpointsIPv6
		}
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	endpoint.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "Priority":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Priority != nil {
			priority := *typedInput.Properties.Priority
			endpoint.Priority = &priority
		}
	}

	// Set property "Subnets":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Subnets {
			var item1 EndpointProperties_Subnets
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.Subnets = append(endpoint.Subnets, item1)
		}
	}

	// Set property "Target":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Target != nil {
			target := *typedInput.Properties.Target
			endpoint.Target = &target
		}
	}

	// no assignment for property "TargetResourceReference"

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		endpoint.Type = &typeVar
	}

	// Set property "Weight":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Weight != nil {
			weight := *typedInput.Properties.Weight
			endpoint.Weight = &weight
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &TrafficManagerProfilesExternalEndpoint_Spec{}

// ConvertSpecFrom populates our TrafficManagerProfilesExternalEndpoint_Spec from the provided source
func (endpoint *TrafficManagerProfilesExternalEndpoint_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.TrafficManagerProfilesExternalEndpoint_Spec)
	if ok {
		// Populate our instance from source
		return endpoint.AssignProperties_From_TrafficManagerProfilesExternalEndpoint_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.TrafficManagerProfilesExternalEndpoint_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = endpoint.AssignProperties_From_TrafficManagerProfilesExternalEndpoint_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our TrafficManagerProfilesExternalEndpoint_Spec
func (endpoint *TrafficManagerProfilesExternalEndpoint_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.TrafficManagerProfilesExternalEndpoint_Spec)
	if ok {
		// Populate destination from our instance
		return endpoint.AssignProperties_To_TrafficManagerProfilesExternalEndpoint_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.TrafficManagerProfilesExternalEndpoint_Spec{}
	err := endpoint.AssignProperties_To_TrafficManagerProfilesExternalEndpoint_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_TrafficManagerProfilesExternalEndpoint_Spec populates our TrafficManagerProfilesExternalEndpoint_Spec from the provided source TrafficManagerProfilesExternalEndpoint_Spec
func (endpoint *TrafficManagerProfilesExternalEndpoint_Spec) AssignProperties_From_TrafficManagerProfilesExternalEndpoint_Spec(source *storage.TrafficManagerProfilesExternalEndpoint_Spec) error {

	// AlwaysServe
	if source.AlwaysServe != nil {
		alwaysServe := *source.AlwaysServe
		alwaysServeTemp := genruntime.ToEnum(alwaysServe, endpointProperties_AlwaysServe_Values)
		endpoint.AlwaysServe = &alwaysServeTemp
	} else {
		endpoint.AlwaysServe = nil
	}

	// AzureName
	endpoint.AzureName = source.AzureName

	// CustomHeaders
	if source.CustomHeaders != nil {
		customHeaderList := make([]EndpointProperties_CustomHeaders, len(source.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range source.CustomHeaders {
			// Shadow the loop variable to avoid aliasing
			customHeaderItem := customHeaderItem
			var customHeader EndpointProperties_CustomHeaders
			err := customHeader.AssignProperties_From_EndpointProperties_CustomHeaders(&customHeaderItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_EndpointProperties_CustomHeaders() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		endpoint.CustomHeaders = customHeaderList
	} else {
		endpoint.CustomHeaders = nil
	}

	// EndpointLocation
	endpoint.EndpointLocation = genruntime.ClonePointerToString(source.EndpointLocation)

	// EndpointMonitorStatus
	if source.EndpointMonitorStatus != nil {
		endpointMonitorStatus := *source.EndpointMonitorStatus
		endpointMonitorStatusTemp := genruntime.ToEnum(endpointMonitorStatus, endpointProperties_EndpointMonitorStatus_Values)
		endpoint.EndpointMonitorStatus = &endpointMonitorStatusTemp
	} else {
		endpoint.EndpointMonitorStatus = nil
	}

	// EndpointStatus
	if source.EndpointStatus != nil {
		endpointStatus := *source.EndpointStatus
		endpointStatusTemp := genruntime.ToEnum(endpointStatus, endpointProperties_EndpointStatus_Values)
		endpoint.EndpointStatus = &endpointStatusTemp
	} else {
		endpoint.EndpointStatus = nil
	}

	// GeoMapping
	endpoint.GeoMapping = genruntime.CloneSliceOfString(source.GeoMapping)

	// MinChildEndpoints
	endpoint.MinChildEndpoints = genruntime.ClonePointerToInt(source.MinChildEndpoints)

	// MinChildEndpointsIPv4
	endpoint.MinChildEndpointsIPv4 = genruntime.ClonePointerToInt(source.MinChildEndpointsIPv4)

	// MinChildEndpointsIPv6
	endpoint.MinChildEndpointsIPv6 = genruntime.ClonePointerToInt(source.MinChildEndpointsIPv6)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec TrafficManagerProfilesExternalEndpointOperatorSpec
		err := operatorSpec.AssignProperties_From_TrafficManagerProfilesExternalEndpointOperatorSpec(source.OperatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_TrafficManagerProfilesExternalEndpointOperatorSpec() to populate field OperatorSpec")
		}
		endpoint.OperatorSpec = &operatorSpec
	} else {
		endpoint.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		endpoint.Owner = &owner
	} else {
		endpoint.Owner = nil
	}

	// Priority
	endpoint.Priority = genruntime.ClonePointerToInt(source.Priority)

	// Subnets
	if source.Subnets != nil {
		subnetList := make([]EndpointProperties_Subnets, len(source.Subnets))
		for subnetIndex, subnetItem := range source.Subnets {
			// Shadow the loop variable to avoid aliasing
			subnetItem := subnetItem
			var subnet EndpointProperties_Subnets
			err := subnet.AssignProperties_From_EndpointProperties_Subnets(&subnetItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_EndpointProperties_Subnets() to populate field Subnets")
			}
			subnetList[subnetIndex] = subnet
		}
		endpoint.Subnets = subnetList
	} else {
		endpoint.Subnets = nil
	}

	// Target
	endpoint.Target = genruntime.ClonePointerToString(source.Target)

	// TargetResourceReference
	if source.TargetResourceReference != nil {
		targetResourceReference := source.TargetResourceReference.Copy()
		endpoint.TargetResourceReference = &targetResourceReference
	} else {
		endpoint.TargetResourceReference = nil
	}

	// Type
	endpoint.Type = genruntime.ClonePointerToString(source.Type)

	// Weight
	endpoint.Weight = genruntime.ClonePointerToInt(source.Weight)

	// No error
	return nil
}

// AssignProperties_To_TrafficManagerProfilesExternalEndpoint_Spec populates the provided destination TrafficManagerProfilesExternalEndpoint_Spec from our TrafficManagerProfilesExternalEndpoint_Spec
func (endpoint *TrafficManagerProfilesExternalEndpoint_Spec) AssignProperties_To_TrafficManagerProfilesExternalEndpoint_Spec(destination *storage.TrafficManagerProfilesExternalEndpoint_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AlwaysServe
	if endpoint.AlwaysServe != nil {
		alwaysServe := string(*endpoint.AlwaysServe)
		destination.AlwaysServe = &alwaysServe
	} else {
		destination.AlwaysServe = nil
	}

	// AzureName
	destination.AzureName = endpoint.AzureName

	// CustomHeaders
	if endpoint.CustomHeaders != nil {
		customHeaderList := make([]storage.EndpointProperties_CustomHeaders, len(endpoint.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range endpoint.CustomHeaders {
			// Shadow the loop variable to avoid aliasing
			customHeaderItem := customHeaderItem
			var customHeader storage.EndpointProperties_CustomHeaders
			err := customHeaderItem.AssignProperties_To_EndpointProperties_CustomHeaders(&customHeader)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_EndpointProperties_CustomHeaders() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		destination.CustomHeaders = customHeaderList
	} else {
		destination.CustomHeaders = nil
	}

	// EndpointLocation
	destination.EndpointLocation = genruntime.ClonePointerToString(endpoint.EndpointLocation)

	// EndpointMonitorStatus
	if endpoint.EndpointMonitorStatus != nil {
		endpointMonitorStatus := string(*endpoint.EndpointMonitorStatus)
		destination.EndpointMonitorStatus = &endpointMonitorStatus
	} else {
		destination.EndpointMonitorStatus = nil
	}

	// EndpointStatus
	if endpoint.EndpointStatus != nil {
		endpointStatus := string(*endpoint.EndpointStatus)
		destination.EndpointStatus = &endpointStatus
	} else {
		destination.EndpointStatus = nil
	}

	// GeoMapping
	destination.GeoMapping = genruntime.CloneSliceOfString(endpoint.GeoMapping)

	// MinChildEndpoints
	destination.MinChildEndpoints = genruntime.ClonePointerToInt(endpoint.MinChildEndpoints)

	// MinChildEndpointsIPv4
	destination.MinChildEndpointsIPv4 = genruntime.ClonePointerToInt(endpoint.MinChildEndpointsIPv4)

	// MinChildEndpointsIPv6
	destination.MinChildEndpointsIPv6 = genruntime.ClonePointerToInt(endpoint.MinChildEndpointsIPv6)

	// OperatorSpec
	if endpoint.OperatorSpec != nil {
		var operatorSpec storage.TrafficManagerProfilesExternalEndpointOperatorSpec
		err := endpoint.OperatorSpec.AssignProperties_To_TrafficManagerProfilesExternalEndpointOperatorSpec(&operatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_TrafficManagerProfilesExternalEndpointOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = endpoint.OriginalVersion()

	// Owner
	if endpoint.Owner != nil {
		owner := endpoint.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Priority
	destination.Priority = genruntime.ClonePointerToInt(endpoint.Priority)

	// Subnets
	if endpoint.Subnets != nil {
		subnetList := make([]storage.EndpointProperties_Subnets, len(endpoint.Subnets))
		for subnetIndex, subnetItem := range endpoint.Subnets {
			// Shadow the loop variable to avoid aliasing
			subnetItem := subnetItem
			var subnet storage.EndpointProperties_Subnets
			err := subnetItem.AssignProperties_To_EndpointProperties_Subnets(&subnet)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_EndpointProperties_Subnets() to populate field Subnets")
			}
			subnetList[subnetIndex] = subnet
		}
		destination.Subnets = subnetList
	} else {
		destination.Subnets = nil
	}

	// Target
	destination.Target = genruntime.ClonePointerToString(endpoint.Target)

	// TargetResourceReference
	if endpoint.TargetResourceReference != nil {
		targetResourceReference := endpoint.TargetResourceReference.Copy()
		destination.TargetResourceReference = &targetResourceReference
	} else {
		destination.TargetResourceReference = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(endpoint.Type)

	// Weight
	destination.Weight = genruntime.ClonePointerToInt(endpoint.Weight)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_TrafficManagerProfilesExternalEndpoint_STATUS populates our TrafficManagerProfilesExternalEndpoint_Spec from the provided source TrafficManagerProfilesExternalEndpoint_STATUS
func (endpoint *TrafficManagerProfilesExternalEndpoint_Spec) Initialize_From_TrafficManagerProfilesExternalEndpoint_STATUS(source *TrafficManagerProfilesExternalEndpoint_STATUS) error {

	// AlwaysServe
	if source.AlwaysServe != nil {
		alwaysServe := genruntime.ToEnum(string(*source.AlwaysServe), endpointProperties_AlwaysServe_Values)
		endpoint.AlwaysServe = &alwaysServe
	} else {
		endpoint.AlwaysServe = nil
	}

	// CustomHeaders
	if source.CustomHeaders != nil {
		customHeaderList := make([]EndpointProperties_CustomHeaders, len(source.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range source.CustomHeaders {
			// Shadow the loop variable to avoid aliasing
			customHeaderItem := customHeaderItem
			var customHeader EndpointProperties_CustomHeaders
			err := customHeader.Initialize_From_EndpointProperties_CustomHeaders_STATUS(&customHeaderItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_EndpointProperties_CustomHeaders_STATUS() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		endpoint.CustomHeaders = customHeaderList
	} else {
		endpoint.CustomHeaders = nil
	}

	// EndpointLocation
	endpoint.EndpointLocation = genruntime.ClonePointerToString(source.EndpointLocation)

	// EndpointMonitorStatus
	if source.EndpointMonitorStatus != nil {
		endpointMonitorStatus := genruntime.ToEnum(string(*source.EndpointMonitorStatus), endpointProperties_EndpointMonitorStatus_Values)
		endpoint.EndpointMonitorStatus = &endpointMonitorStatus
	} else {
		endpoint.EndpointMonitorStatus = nil
	}

	// EndpointStatus
	if source.EndpointStatus != nil {
		endpointStatus := genruntime.ToEnum(string(*source.EndpointStatus), endpointProperties_EndpointStatus_Values)
		endpoint.EndpointStatus = &endpointStatus
	} else {
		endpoint.EndpointStatus = nil
	}

	// GeoMapping
	endpoint.GeoMapping = genruntime.CloneSliceOfString(source.GeoMapping)

	// MinChildEndpoints
	endpoint.MinChildEndpoints = genruntime.ClonePointerToInt(source.MinChildEndpoints)

	// MinChildEndpointsIPv4
	endpoint.MinChildEndpointsIPv4 = genruntime.ClonePointerToInt(source.MinChildEndpointsIPv4)

	// MinChildEndpointsIPv6
	endpoint.MinChildEndpointsIPv6 = genruntime.ClonePointerToInt(source.MinChildEndpointsIPv6)

	// Priority
	endpoint.Priority = genruntime.ClonePointerToInt(source.Priority)

	// Subnets
	if source.Subnets != nil {
		subnetList := make([]EndpointProperties_Subnets, len(source.Subnets))
		for subnetIndex, subnetItem := range source.Subnets {
			// Shadow the loop variable to avoid aliasing
			subnetItem := subnetItem
			var subnet EndpointProperties_Subnets
			err := subnet.Initialize_From_EndpointProperties_Subnets_STATUS(&subnetItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_EndpointProperties_Subnets_STATUS() to populate field Subnets")
			}
			subnetList[subnetIndex] = subnet
		}
		endpoint.Subnets = subnetList
	} else {
		endpoint.Subnets = nil
	}

	// Target
	endpoint.Target = genruntime.ClonePointerToString(source.Target)

	// TargetResourceReference
	if source.TargetResourceId != nil {
		targetResourceReference := genruntime.CreateResourceReferenceFromARMID(*source.TargetResourceId)
		endpoint.TargetResourceReference = &targetResourceReference
	} else {
		endpoint.TargetResourceReference = nil
	}

	// Type
	endpoint.Type = genruntime.ClonePointerToString(source.Type)

	// Weight
	endpoint.Weight = genruntime.ClonePointerToInt(source.Weight)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (endpoint *TrafficManagerProfilesExternalEndpoint_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (endpoint *TrafficManagerProfilesExternalEndpoint_Spec) SetAzureName(azureName string) {
	endpoint.AzureName = azureName
}

type TrafficManagerProfilesExternalEndpoint_STATUS struct {
	// AlwaysServe: If Always Serve is enabled, probing for endpoint health will be disabled and endpoints will be included in
	// the traffic routing method.
	AlwaysServe *EndpointProperties_AlwaysServe_STATUS `json:"alwaysServe,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// CustomHeaders: List of custom headers.
	CustomHeaders []EndpointProperties_CustomHeaders_STATUS `json:"customHeaders,omitempty"`

	// EndpointLocation: Specifies the location of the external or nested endpoints when using the 'Performance' traffic
	// routing method.
	EndpointLocation *string `json:"endpointLocation,omitempty"`

	// EndpointMonitorStatus: The monitoring status of the endpoint.
	EndpointMonitorStatus *EndpointProperties_EndpointMonitorStatus_STATUS `json:"endpointMonitorStatus,omitempty"`

	// EndpointStatus: The status of the endpoint. If the endpoint is Enabled, it is probed for endpoint health and is included
	// in the traffic routing method.
	EndpointStatus *EndpointProperties_EndpointStatus_STATUS `json:"endpointStatus,omitempty"`

	// GeoMapping: The list of countries/regions mapped to this endpoint when using the 'Geographic' traffic routing method.
	// Please consult Traffic Manager Geographic documentation for a full list of accepted values.
	GeoMapping []string `json:"geoMapping,omitempty"`

	// Id: Fully qualified resource Id for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{resourceName}
	Id *string `json:"id,omitempty"`

	// MinChildEndpoints: The minimum number of endpoints that must be available in the child profile in order for the parent
	// profile to be considered available. Only applicable to endpoint of type 'NestedEndpoints'.
	MinChildEndpoints *int `json:"minChildEndpoints,omitempty"`

	// MinChildEndpointsIPv4: The minimum number of IPv4 (DNS record type A) endpoints that must be available in the child
	// profile in order for the parent profile to be considered available. Only applicable to endpoint of type
	// 'NestedEndpoints'.
	MinChildEndpointsIPv4 *int `json:"minChildEndpointsIPv4,omitempty"`

	// MinChildEndpointsIPv6: The minimum number of IPv6 (DNS record type AAAA) endpoints that must be available in the child
	// profile in order for the parent profile to be considered available. Only applicable to endpoint of type
	// 'NestedEndpoints'.
	MinChildEndpointsIPv6 *int `json:"minChildEndpointsIPv6,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// Priority: The priority of this endpoint when using the 'Priority' traffic routing method. Possible values are from 1 to
	// 1000, lower values represent higher priority. This is an optional parameter.  If specified, it must be specified on all
	// endpoints, and no two endpoints can share the same priority value.
	Priority *int `json:"priority,omitempty"`

	// Subnets: The list of subnets, IP addresses, and/or address ranges mapped to this endpoint when using the 'Subnet'
	// traffic routing method. An empty list will match all ranges not covered by other endpoints.
	Subnets []EndpointProperties_Subnets_STATUS `json:"subnets,omitempty"`

	// Target: The fully-qualified DNS name or IP address of the endpoint. Traffic Manager returns this value in DNS responses
	// to direct traffic to this endpoint.
	Target *string `json:"target,omitempty"`

	// TargetResourceId: The Azure Resource URI of the of the endpoint. Not applicable to endpoints of type 'ExternalEndpoints'.
	TargetResourceId *string `json:"targetResourceId,omitempty"`

	// Type: The type of the resource. Ex- Microsoft.Network/trafficManagerProfiles.
	Type *string `json:"type,omitempty"`

	// Weight: The weight of this endpoint when using the 'Weighted' traffic routing method. Possible values are from 1 to 1000.
	Weight *int `json:"weight,omitempty"`
}

var _ genruntime.ConvertibleStatus = &TrafficManagerProfilesExternalEndpoint_STATUS{}

// ConvertStatusFrom populates our TrafficManagerProfilesExternalEndpoint_STATUS from the provided source
func (endpoint *TrafficManagerProfilesExternalEndpoint_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.TrafficManagerProfilesExternalEndpoint_STATUS)
	if ok {
		// Populate our instance from source
		return endpoint.AssignProperties_From_TrafficManagerProfilesExternalEndpoint_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.TrafficManagerProfilesExternalEndpoint_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = endpoint.AssignProperties_From_TrafficManagerProfilesExternalEndpoint_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our TrafficManagerProfilesExternalEndpoint_STATUS
func (endpoint *TrafficManagerProfilesExternalEndpoint_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.TrafficManagerProfilesExternalEndpoint_STATUS)
	if ok {
		// Populate destination from our instance
		return endpoint.AssignProperties_To_TrafficManagerProfilesExternalEndpoint_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.TrafficManagerProfilesExternalEndpoint_STATUS{}
	err := endpoint.AssignProperties_To_TrafficManagerProfilesExternalEndpoint_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &TrafficManagerProfilesExternalEndpoint_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (endpoint *TrafficManagerProfilesExternalEndpoint_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TrafficManagerProfilesExternalEndpoint_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (endpoint *TrafficManagerProfilesExternalEndpoint_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TrafficManagerProfilesExternalEndpoint_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TrafficManagerProfilesExternalEndpoint_STATUS, got %T", armInput)
	}

	// Set property "AlwaysServe":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AlwaysServe != nil {
			var temp string
			temp = string(*typedInput.Properties.AlwaysServe)
			alwaysServe := EndpointProperties_AlwaysServe_STATUS(temp)
			endpoint.AlwaysServe = &alwaysServe
		}
	}

	// no assignment for property "Conditions"

	// Set property "CustomHeaders":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.CustomHeaders {
			var item1 EndpointProperties_CustomHeaders_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.CustomHeaders = append(endpoint.CustomHeaders, item1)
		}
	}

	// Set property "EndpointLocation":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EndpointLocation != nil {
			endpointLocation := *typedInput.Properties.EndpointLocation
			endpoint.EndpointLocation = &endpointLocation
		}
	}

	// Set property "EndpointMonitorStatus":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EndpointMonitorStatus != nil {
			var temp string
			temp = string(*typedInput.Properties.EndpointMonitorStatus)
			endpointMonitorStatus := EndpointProperties_EndpointMonitorStatus_STATUS(temp)
			endpoint.EndpointMonitorStatus = &endpointMonitorStatus
		}
	}

	// Set property "EndpointStatus":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EndpointStatus != nil {
			var temp string
			temp = string(*typedInput.Properties.EndpointStatus)
			endpointStatus := EndpointProperties_EndpointStatus_STATUS(temp)
			endpoint.EndpointStatus = &endpointStatus
		}
	}

	// Set property "GeoMapping":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.GeoMapping {
			endpoint.GeoMapping = append(endpoint.GeoMapping, item)
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		endpoint.Id = &id
	}

	// Set property "MinChildEndpoints":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinChildEndpoints != nil {
			minChildEndpoints := *typedInput.Properties.MinChildEndpoints
			endpoint.MinChildEndpoints = &minChildEndpoints
		}
	}

	// Set property "MinChildEndpointsIPv4":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinChildEndpointsIPv4 != nil {
			minChildEndpointsIPv4 := *typedInput.Properties.MinChildEndpointsIPv4
			endpoint.MinChildEndpointsIPv4 = &minChildEndpointsIPv4
		}
	}

	// Set property "MinChildEndpointsIPv6":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinChildEndpointsIPv6 != nil {
			minChildEndpointsIPv6 := *typedInput.Properties.MinChildEndpointsIPv6
			endpoint.MinChildEndpointsIPv6 = &minChildEndpointsIPv6
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		endpoint.Name = &name
	}

	// Set property "Priority":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Priority != nil {
			priority := *typedInput.Properties.Priority
			endpoint.Priority = &priority
		}
	}

	// Set property "Subnets":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Subnets {
			var item1 EndpointProperties_Subnets_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.Subnets = append(endpoint.Subnets, item1)
		}
	}

	// Set property "Target":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Target != nil {
			target := *typedInput.Properties.Target
			endpoint.Target = &target
		}
	}

	// Set property "TargetResourceId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TargetResourceId != nil {
			targetResourceId := *typedInput.Properties.TargetResourceId
			endpoint.TargetResourceId = &targetResourceId
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		endpoint.Type = &typeVar
	}

	// Set property "Weight":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Weight != nil {
			weight := *typedInput.Properties.Weight
			endpoint.Weight = &weight
		}
	}

	// No error
	return nil
}

// AssignProperties_From_TrafficManagerProfilesExternalEndpoint_STATUS populates our TrafficManagerProfilesExternalEndpoint_STATUS from the provided source TrafficManagerProfilesExternalEndpoint_STATUS
func (endpoint *TrafficManagerProfilesExternalEndpoint_STATUS) AssignProperties_From_TrafficManagerProfilesExternalEndpoint_STATUS(source *storage.TrafficManagerProfilesExternalEndpoint_STATUS) error {

	// AlwaysServe
	if source.AlwaysServe != nil {
		alwaysServe := *source.AlwaysServe
		alwaysServeTemp := genruntime.ToEnum(alwaysServe, endpointProperties_AlwaysServe_STATUS_Values)
		endpoint.AlwaysServe = &alwaysServeTemp
	} else {
		endpoint.AlwaysServe = nil
	}

	// Conditions
	endpoint.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// CustomHeaders
	if source.CustomHeaders != nil {
		customHeaderList := make([]EndpointProperties_CustomHeaders_STATUS, len(source.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range source.CustomHeaders {
			// Shadow the loop variable to avoid aliasing
			customHeaderItem := customHeaderItem
			var customHeader EndpointProperties_CustomHeaders_STATUS
			err := customHeader.AssignProperties_From_EndpointProperties_CustomHeaders_STATUS(&customHeaderItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_EndpointProperties_CustomHeaders_STATUS() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		endpoint.CustomHeaders = customHeaderList
	} else {
		endpoint.CustomHeaders = nil
	}

	// EndpointLocation
	endpoint.EndpointLocation = genruntime.ClonePointerToString(source.EndpointLocation)

	// EndpointMonitorStatus
	if source.EndpointMonitorStatus != nil {
		endpointMonitorStatus := *source.EndpointMonitorStatus
		endpointMonitorStatusTemp := genruntime.ToEnum(endpointMonitorStatus, endpointProperties_EndpointMonitorStatus_STATUS_Values)
		endpoint.EndpointMonitorStatus = &endpointMonitorStatusTemp
	} else {
		endpoint.EndpointMonitorStatus = nil
	}

	// EndpointStatus
	if source.EndpointStatus != nil {
		endpointStatus := *source.EndpointStatus
		endpointStatusTemp := genruntime.ToEnum(endpointStatus, endpointProperties_EndpointStatus_STATUS_Values)
		endpoint.EndpointStatus = &endpointStatusTemp
	} else {
		endpoint.EndpointStatus = nil
	}

	// GeoMapping
	endpoint.GeoMapping = genruntime.CloneSliceOfString(source.GeoMapping)

	// Id
	endpoint.Id = genruntime.ClonePointerToString(source.Id)

	// MinChildEndpoints
	endpoint.MinChildEndpoints = genruntime.ClonePointerToInt(source.MinChildEndpoints)

	// MinChildEndpointsIPv4
	endpoint.MinChildEndpointsIPv4 = genruntime.ClonePointerToInt(source.MinChildEndpointsIPv4)

	// MinChildEndpointsIPv6
	endpoint.MinChildEndpointsIPv6 = genruntime.ClonePointerToInt(source.MinChildEndpointsIPv6)

	// Name
	endpoint.Name = genruntime.ClonePointerToString(source.Name)

	// Priority
	endpoint.Priority = genruntime.ClonePointerToInt(source.Priority)

	// Subnets
	if source.Subnets != nil {
		subnetList := make([]EndpointProperties_Subnets_STATUS, len(source.Subnets))
		for subnetIndex, subnetItem := range source.Subnets {
			// Shadow the loop variable to avoid aliasing
			subnetItem := subnetItem
			var subnet EndpointProperties_Subnets_STATUS
			err := subnet.AssignProperties_From_EndpointProperties_Subnets_STATUS(&subnetItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_EndpointProperties_Subnets_STATUS() to populate field Subnets")
			}
			subnetList[subnetIndex] = subnet
		}
		endpoint.Subnets = subnetList
	} else {
		endpoint.Subnets = nil
	}

	// Target
	endpoint.Target = genruntime.ClonePointerToString(source.Target)

	// TargetResourceId
	endpoint.TargetResourceId = genruntime.ClonePointerToString(source.TargetResourceId)

	// Type
	endpoint.Type = genruntime.ClonePointerToString(source.Type)

	// Weight
	endpoint.Weight = genruntime.ClonePointerToInt(source.Weight)

	// No error
	return nil
}

// AssignProperties_To_TrafficManagerProfilesExternalEndpoint_STATUS populates the provided destination TrafficManagerProfilesExternalEndpoint_STATUS from our TrafficManagerProfilesExternalEndpoint_STATUS
func (endpoint *TrafficManagerProfilesExternalEndpoint_STATUS) AssignProperties_To_TrafficManagerProfilesExternalEndpoint_STATUS(destination *storage.TrafficManagerProfilesExternalEndpoint_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AlwaysServe
	if endpoint.AlwaysServe != nil {
		alwaysServe := string(*endpoint.AlwaysServe)
		destination.AlwaysServe = &alwaysServe
	} else {
		destination.AlwaysServe = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(endpoint.Conditions)

	// CustomHeaders
	if endpoint.CustomHeaders != nil {
		customHeaderList := make([]storage.EndpointProperties_CustomHeaders_STATUS, len(endpoint.CustomHeaders))
		for customHeaderIndex, customHeaderItem := range endpoint.CustomHeaders {
			// Shadow the loop variable to avoid aliasing
			customHeaderItem := customHeaderItem
			var customHeader storage.EndpointProperties_CustomHeaders_STATUS
			err := customHeaderItem.AssignProperties_To_EndpointProperties_CustomHeaders_STATUS(&customHeader)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_EndpointProperties_CustomHeaders_STATUS() to populate field CustomHeaders")
			}
			customHeaderList[customHeaderIndex] = customHeader
		}
		destination.CustomHeaders = customHeaderList
	} else {
		destination.CustomHeaders = nil
	}

	// EndpointLocation
	destination.EndpointLocation = genruntime.ClonePointerToString(endpoint.EndpointLocation)

	// EndpointMonitorStatus
	if endpoint.EndpointMonitorStatus != nil {
		endpointMonitorStatus := string(*endpoint.EndpointMonitorStatus)
		destination.EndpointMonitorStatus = &endpointMonitorStatus
	} else {
		destination.EndpointMonitorStatus = nil
	}

	// EndpointStatus
	if endpoint.EndpointStatus != nil {
		endpointStatus := string(*endpoint.EndpointStatus)
		destination.EndpointStatus = &endpointStatus
	} else {
		destination.EndpointStatus = nil
	}

	// GeoMapping
	destination.GeoMapping = genruntime.CloneSliceOfString(endpoint.GeoMapping)

	// Id
	destination.Id = genruntime.ClonePointerToString(endpoint.Id)

	// MinChildEndpoints
	destination.MinChildEndpoints = genruntime.ClonePointerToInt(endpoint.MinChildEndpoints)

	// MinChildEndpointsIPv4
	destination.MinChildEndpointsIPv4 = genruntime.ClonePointerToInt(endpoint.MinChildEndpointsIPv4)

	// MinChildEndpointsIPv6
	destination.MinChildEndpointsIPv6 = genruntime.ClonePointerToInt(endpoint.MinChildEndpointsIPv6)

	// Name
	destination.Name = genruntime.ClonePointerToString(endpoint.Name)

	// Priority
	destination.Priority = genruntime.ClonePointerToInt(endpoint.Priority)

	// Subnets
	if endpoint.Subnets != nil {
		subnetList := make([]storage.EndpointProperties_Subnets_STATUS, len(endpoint.Subnets))
		for subnetIndex, subnetItem := range endpoint.Subnets {
			// Shadow the loop variable to avoid aliasing
			subnetItem := subnetItem
			var subnet storage.EndpointProperties_Subnets_STATUS
			err := subnetItem.AssignProperties_To_EndpointProperties_Subnets_STATUS(&subnet)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_EndpointProperties_Subnets_STATUS() to populate field Subnets")
			}
			subnetList[subnetIndex] = subnet
		}
		destination.Subnets = subnetList
	} else {
		destination.Subnets = nil
	}

	// Target
	destination.Target = genruntime.ClonePointerToString(endpoint.Target)

	// TargetResourceId
	destination.TargetResourceId = genruntime.ClonePointerToString(endpoint.TargetResourceId)

	// Type
	destination.Type = genruntime.ClonePointerToString(endpoint.Type)

	// Weight
	destination.Weight = genruntime.ClonePointerToInt(endpoint.Weight)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type TrafficManagerProfilesExternalEndpointOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_TrafficManagerProfilesExternalEndpointOperatorSpec populates our TrafficManagerProfilesExternalEndpointOperatorSpec from the provided source TrafficManagerProfilesExternalEndpointOperatorSpec
func (operator *TrafficManagerProfilesExternalEndpointOperatorSpec) AssignProperties_From_TrafficManagerProfilesExternalEndpointOperatorSpec(source *storage.TrafficManagerProfilesExternalEndpointOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_TrafficManagerProfilesExternalEndpointOperatorSpec populates the provided destination TrafficManagerProfilesExternalEndpointOperatorSpec from our TrafficManagerProfilesExternalEndpointOperatorSpec
func (operator *TrafficManagerProfilesExternalEndpointOperatorSpec) AssignProperties_To_TrafficManagerProfilesExternalEndpointOperatorSpec(destination *storage.TrafficManagerProfilesExternalEndpointOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&TrafficManagerProfilesExternalEndpoint{}, &TrafficManagerProfilesExternalEndpointList{})
}
