// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20220301

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/compute/v1api20220301/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/compute/v1api20220301/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/rotisserie/eris"
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /compute/resource-manager/Microsoft.Compute/ComputeRP/stable/2022-03-01/virtualMachineScaleSet.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}
type VirtualMachineScaleSet struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              VirtualMachineScaleSet_Spec   `json:"spec,omitempty"`
	Status            VirtualMachineScaleSet_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &VirtualMachineScaleSet{}

// GetConditions returns the conditions of the resource
func (scaleSet *VirtualMachineScaleSet) GetConditions() conditions.Conditions {
	return scaleSet.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (scaleSet *VirtualMachineScaleSet) SetConditions(conditions conditions.Conditions) {
	scaleSet.Status.Conditions = conditions
}

var _ conversion.Convertible = &VirtualMachineScaleSet{}

// ConvertFrom populates our VirtualMachineScaleSet from the provided hub VirtualMachineScaleSet
func (scaleSet *VirtualMachineScaleSet) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.VirtualMachineScaleSet)
	if !ok {
		return fmt.Errorf("expected compute/v1api20220301/storage/VirtualMachineScaleSet but received %T instead", hub)
	}

	return scaleSet.AssignProperties_From_VirtualMachineScaleSet(source)
}

// ConvertTo populates the provided hub VirtualMachineScaleSet from our VirtualMachineScaleSet
func (scaleSet *VirtualMachineScaleSet) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.VirtualMachineScaleSet)
	if !ok {
		return fmt.Errorf("expected compute/v1api20220301/storage/VirtualMachineScaleSet but received %T instead", hub)
	}

	return scaleSet.AssignProperties_To_VirtualMachineScaleSet(destination)
}

var _ configmaps.Exporter = &VirtualMachineScaleSet{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (scaleSet *VirtualMachineScaleSet) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if scaleSet.Spec.OperatorSpec == nil {
		return nil
	}
	return scaleSet.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &VirtualMachineScaleSet{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (scaleSet *VirtualMachineScaleSet) SecretDestinationExpressions() []*core.DestinationExpression {
	if scaleSet.Spec.OperatorSpec == nil {
		return nil
	}
	return scaleSet.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &VirtualMachineScaleSet{}

// InitializeSpec initializes the spec for this resource from the given status
func (scaleSet *VirtualMachineScaleSet) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*VirtualMachineScaleSet_STATUS); ok {
		return scaleSet.Spec.Initialize_From_VirtualMachineScaleSet_STATUS(s)
	}

	return fmt.Errorf("expected Status of type VirtualMachineScaleSet_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &VirtualMachineScaleSet{}

// AzureName returns the Azure name of the resource
func (scaleSet *VirtualMachineScaleSet) AzureName() string {
	return scaleSet.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2022-03-01"
func (scaleSet VirtualMachineScaleSet) GetAPIVersion() string {
	return "2022-03-01"
}

// GetResourceScope returns the scope of the resource
func (scaleSet *VirtualMachineScaleSet) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (scaleSet *VirtualMachineScaleSet) GetSpec() genruntime.ConvertibleSpec {
	return &scaleSet.Spec
}

// GetStatus returns the status of this resource
func (scaleSet *VirtualMachineScaleSet) GetStatus() genruntime.ConvertibleStatus {
	return &scaleSet.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (scaleSet *VirtualMachineScaleSet) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Compute/virtualMachineScaleSets"
func (scaleSet *VirtualMachineScaleSet) GetType() string {
	return "Microsoft.Compute/virtualMachineScaleSets"
}

// NewEmptyStatus returns a new empty (blank) status
func (scaleSet *VirtualMachineScaleSet) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &VirtualMachineScaleSet_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (scaleSet *VirtualMachineScaleSet) Owner() *genruntime.ResourceReference {
	if scaleSet.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(scaleSet.Spec)
	return scaleSet.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (scaleSet *VirtualMachineScaleSet) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*VirtualMachineScaleSet_STATUS); ok {
		scaleSet.Status = *st
		return nil
	}

	// Convert status to required version
	var st VirtualMachineScaleSet_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	scaleSet.Status = st
	return nil
}

// AssignProperties_From_VirtualMachineScaleSet populates our VirtualMachineScaleSet from the provided source VirtualMachineScaleSet
func (scaleSet *VirtualMachineScaleSet) AssignProperties_From_VirtualMachineScaleSet(source *storage.VirtualMachineScaleSet) error {

	// ObjectMeta
	scaleSet.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec VirtualMachineScaleSet_Spec
	err := spec.AssignProperties_From_VirtualMachineScaleSet_Spec(&source.Spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSet_Spec() to populate field Spec")
	}
	scaleSet.Spec = spec

	// Status
	var status VirtualMachineScaleSet_STATUS
	err = status.AssignProperties_From_VirtualMachineScaleSet_STATUS(&source.Status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSet_STATUS() to populate field Status")
	}
	scaleSet.Status = status

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSet populates the provided destination VirtualMachineScaleSet from our VirtualMachineScaleSet
func (scaleSet *VirtualMachineScaleSet) AssignProperties_To_VirtualMachineScaleSet(destination *storage.VirtualMachineScaleSet) error {

	// ObjectMeta
	destination.ObjectMeta = *scaleSet.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.VirtualMachineScaleSet_Spec
	err := scaleSet.Spec.AssignProperties_To_VirtualMachineScaleSet_Spec(&spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSet_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.VirtualMachineScaleSet_STATUS
	err = scaleSet.Status.AssignProperties_To_VirtualMachineScaleSet_STATUS(&status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSet_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (scaleSet *VirtualMachineScaleSet) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: scaleSet.Spec.OriginalVersion(),
		Kind:    "VirtualMachineScaleSet",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /compute/resource-manager/Microsoft.Compute/ComputeRP/stable/2022-03-01/virtualMachineScaleSet.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}
type VirtualMachineScaleSetList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []VirtualMachineScaleSet `json:"items"`
}

type VirtualMachineScaleSet_Spec struct {
	// AdditionalCapabilities: Specifies additional capabilities enabled or disabled on the Virtual Machines in the Virtual
	// Machine Scale Set. For instance: whether the Virtual Machines have the capability to support attaching managed data
	// disks with UltraSSD_LRS storage account type.
	AdditionalCapabilities *AdditionalCapabilities `json:"additionalCapabilities,omitempty"`

	// AutomaticRepairsPolicy: Policy for automatic repairs.
	AutomaticRepairsPolicy *AutomaticRepairsPolicy `json:"automaticRepairsPolicy,omitempty"`

	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// DoNotRunExtensionsOnOverprovisionedVMs: When Overprovision is enabled, extensions are launched only on the requested
	// number of VMs which are finally kept. This property will hence ensure that the extensions do not run on the extra
	// overprovisioned VMs.
	DoNotRunExtensionsOnOverprovisionedVMs *bool `json:"doNotRunExtensionsOnOverprovisionedVMs,omitempty"`

	// ExtendedLocation: The extended location of the Virtual Machine Scale Set.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`

	// HostGroup: Specifies information about the dedicated host group that the virtual machine scale set resides in.
	// Minimum api-version: 2020-06-01.
	HostGroup *SubResource `json:"hostGroup,omitempty"`

	// Identity: The identity of the virtual machine scale set, if configured.
	Identity *VirtualMachineScaleSetIdentity `json:"identity,omitempty"`

	// +kubebuilder:validation:Required
	// Location: Resource location
	Location *string `json:"location,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *VirtualMachineScaleSetOperatorSpec `json:"operatorSpec,omitempty"`

	// OrchestrationMode: Specifies the orchestration mode for the virtual machine scale set.
	OrchestrationMode *OrchestrationMode `json:"orchestrationMode,omitempty"`

	// Overprovision: Specifies whether the Virtual Machine Scale Set should be overprovisioned.
	Overprovision *bool `json:"overprovision,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// Plan: Specifies information about the marketplace image used to create the virtual machine. This element is only used
	// for marketplace images. Before you can use a marketplace image from an API, you must enable the image for programmatic
	// use.  In the Azure portal, find the marketplace image that you want to use and then click Want to deploy
	// programmatically, Get Started ->. Enter any required information and then click Save.
	Plan *Plan `json:"plan,omitempty"`

	// PlatformFaultDomainCount: Fault Domain count for each placement group.
	PlatformFaultDomainCount *int `json:"platformFaultDomainCount,omitempty"`

	// ProximityPlacementGroup: Specifies information about the proximity placement group that the virtual machine scale set
	// should be assigned to.
	// Minimum api-version: 2018-04-01.
	ProximityPlacementGroup *SubResource `json:"proximityPlacementGroup,omitempty"`

	// ScaleInPolicy: Specifies the policies applied when scaling in Virtual Machines in the Virtual Machine Scale Set.
	ScaleInPolicy *ScaleInPolicy `json:"scaleInPolicy,omitempty"`

	// SinglePlacementGroup: When true this limits the scale set to a single placement group, of max size 100 virtual machines.
	// NOTE: If singlePlacementGroup is true, it may be modified to false. However, if singlePlacementGroup is false, it may
	// not be modified to true.
	SinglePlacementGroup *bool `json:"singlePlacementGroup,omitempty"`

	// Sku: The virtual machine scale set sku.
	Sku *Sku `json:"sku,omitempty"`

	// SpotRestorePolicy: Specifies the Spot Restore properties for the virtual machine scale set.
	SpotRestorePolicy *SpotRestorePolicy `json:"spotRestorePolicy,omitempty"`

	// Tags: Resource tags
	Tags map[string]string `json:"tags,omitempty"`

	// UpgradePolicy: The upgrade policy.
	UpgradePolicy *UpgradePolicy `json:"upgradePolicy,omitempty"`

	// VirtualMachineProfile: The virtual machine profile.
	VirtualMachineProfile *VirtualMachineScaleSetVMProfile `json:"virtualMachineProfile,omitempty"`

	// ZoneBalance: Whether to force strictly even Virtual Machine distribution cross x-zones in case there is zone outage.
	// zoneBalance property can only be set if the zones property of the scale set contains more than one zone. If there are no
	// zones or only one zone specified, then zoneBalance property should not be set.
	ZoneBalance *bool `json:"zoneBalance,omitempty"`

	// Zones: The virtual machine scale set zones. NOTE: Availability zones can only be set when you create the scale set
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSet_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (scaleSet *VirtualMachineScaleSet_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if scaleSet == nil {
		return nil, nil
	}
	result := &arm.VirtualMachineScaleSet_Spec{}

	// Set property "ExtendedLocation":
	if scaleSet.ExtendedLocation != nil {
		extendedLocation_ARM, err := (*scaleSet.ExtendedLocation).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		extendedLocation := *extendedLocation_ARM.(*arm.ExtendedLocation)
		result.ExtendedLocation = &extendedLocation
	}

	// Set property "Identity":
	if scaleSet.Identity != nil {
		identity_ARM, err := (*scaleSet.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*arm.VirtualMachineScaleSetIdentity)
		result.Identity = &identity
	}

	// Set property "Location":
	if scaleSet.Location != nil {
		location := *scaleSet.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Plan":
	if scaleSet.Plan != nil {
		plan_ARM, err := (*scaleSet.Plan).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		plan := *plan_ARM.(*arm.Plan)
		result.Plan = &plan
	}

	// Set property "Properties":
	if scaleSet.AdditionalCapabilities != nil ||
		scaleSet.AutomaticRepairsPolicy != nil ||
		scaleSet.DoNotRunExtensionsOnOverprovisionedVMs != nil ||
		scaleSet.HostGroup != nil ||
		scaleSet.OrchestrationMode != nil ||
		scaleSet.Overprovision != nil ||
		scaleSet.PlatformFaultDomainCount != nil ||
		scaleSet.ProximityPlacementGroup != nil ||
		scaleSet.ScaleInPolicy != nil ||
		scaleSet.SinglePlacementGroup != nil ||
		scaleSet.SpotRestorePolicy != nil ||
		scaleSet.UpgradePolicy != nil ||
		scaleSet.VirtualMachineProfile != nil ||
		scaleSet.ZoneBalance != nil {
		result.Properties = &arm.VirtualMachineScaleSetProperties{}
	}
	if scaleSet.AdditionalCapabilities != nil {
		additionalCapabilities_ARM, err := (*scaleSet.AdditionalCapabilities).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		additionalCapabilities := *additionalCapabilities_ARM.(*arm.AdditionalCapabilities)
		result.Properties.AdditionalCapabilities = &additionalCapabilities
	}
	if scaleSet.AutomaticRepairsPolicy != nil {
		automaticRepairsPolicy_ARM, err := (*scaleSet.AutomaticRepairsPolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		automaticRepairsPolicy := *automaticRepairsPolicy_ARM.(*arm.AutomaticRepairsPolicy)
		result.Properties.AutomaticRepairsPolicy = &automaticRepairsPolicy
	}
	if scaleSet.DoNotRunExtensionsOnOverprovisionedVMs != nil {
		doNotRunExtensionsOnOverprovisionedVMs := *scaleSet.DoNotRunExtensionsOnOverprovisionedVMs
		result.Properties.DoNotRunExtensionsOnOverprovisionedVMs = &doNotRunExtensionsOnOverprovisionedVMs
	}
	if scaleSet.HostGroup != nil {
		hostGroup_ARM, err := (*scaleSet.HostGroup).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		hostGroup := *hostGroup_ARM.(*arm.SubResource)
		result.Properties.HostGroup = &hostGroup
	}
	if scaleSet.OrchestrationMode != nil {
		var temp string
		temp = string(*scaleSet.OrchestrationMode)
		orchestrationMode := arm.OrchestrationMode(temp)
		result.Properties.OrchestrationMode = &orchestrationMode
	}
	if scaleSet.Overprovision != nil {
		overprovision := *scaleSet.Overprovision
		result.Properties.Overprovision = &overprovision
	}
	if scaleSet.PlatformFaultDomainCount != nil {
		platformFaultDomainCount := *scaleSet.PlatformFaultDomainCount
		result.Properties.PlatformFaultDomainCount = &platformFaultDomainCount
	}
	if scaleSet.ProximityPlacementGroup != nil {
		proximityPlacementGroup_ARM, err := (*scaleSet.ProximityPlacementGroup).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		proximityPlacementGroup := *proximityPlacementGroup_ARM.(*arm.SubResource)
		result.Properties.ProximityPlacementGroup = &proximityPlacementGroup
	}
	if scaleSet.ScaleInPolicy != nil {
		scaleInPolicy_ARM, err := (*scaleSet.ScaleInPolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		scaleInPolicy := *scaleInPolicy_ARM.(*arm.ScaleInPolicy)
		result.Properties.ScaleInPolicy = &scaleInPolicy
	}
	if scaleSet.SinglePlacementGroup != nil {
		singlePlacementGroup := *scaleSet.SinglePlacementGroup
		result.Properties.SinglePlacementGroup = &singlePlacementGroup
	}
	if scaleSet.SpotRestorePolicy != nil {
		spotRestorePolicy_ARM, err := (*scaleSet.SpotRestorePolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		spotRestorePolicy := *spotRestorePolicy_ARM.(*arm.SpotRestorePolicy)
		result.Properties.SpotRestorePolicy = &spotRestorePolicy
	}
	if scaleSet.UpgradePolicy != nil {
		upgradePolicy_ARM, err := (*scaleSet.UpgradePolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		upgradePolicy := *upgradePolicy_ARM.(*arm.UpgradePolicy)
		result.Properties.UpgradePolicy = &upgradePolicy
	}
	if scaleSet.VirtualMachineProfile != nil {
		virtualMachineProfile_ARM, err := (*scaleSet.VirtualMachineProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		virtualMachineProfile := *virtualMachineProfile_ARM.(*arm.VirtualMachineScaleSetVMProfile)
		result.Properties.VirtualMachineProfile = &virtualMachineProfile
	}
	if scaleSet.ZoneBalance != nil {
		zoneBalance := *scaleSet.ZoneBalance
		result.Properties.ZoneBalance = &zoneBalance
	}

	// Set property "Sku":
	if scaleSet.Sku != nil {
		sku_ARM, err := (*scaleSet.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := *sku_ARM.(*arm.Sku)
		result.Sku = &sku
	}

	// Set property "Tags":
	if scaleSet.Tags != nil {
		result.Tags = make(map[string]string, len(scaleSet.Tags))
		for key, value := range scaleSet.Tags {
			result.Tags[key] = value
		}
	}

	// Set property "Zones":
	for _, item := range scaleSet.Zones {
		result.Zones = append(result.Zones, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (scaleSet *VirtualMachineScaleSet_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSet_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (scaleSet *VirtualMachineScaleSet_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSet_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSet_Spec, got %T", armInput)
	}

	// Set property "AdditionalCapabilities":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AdditionalCapabilities != nil {
			var additionalCapabilities1 AdditionalCapabilities
			err := additionalCapabilities1.PopulateFromARM(owner, *typedInput.Properties.AdditionalCapabilities)
			if err != nil {
				return err
			}
			additionalCapabilities := additionalCapabilities1
			scaleSet.AdditionalCapabilities = &additionalCapabilities
		}
	}

	// Set property "AutomaticRepairsPolicy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutomaticRepairsPolicy != nil {
			var automaticRepairsPolicy1 AutomaticRepairsPolicy
			err := automaticRepairsPolicy1.PopulateFromARM(owner, *typedInput.Properties.AutomaticRepairsPolicy)
			if err != nil {
				return err
			}
			automaticRepairsPolicy := automaticRepairsPolicy1
			scaleSet.AutomaticRepairsPolicy = &automaticRepairsPolicy
		}
	}

	// Set property "AzureName":
	scaleSet.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "DoNotRunExtensionsOnOverprovisionedVMs":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DoNotRunExtensionsOnOverprovisionedVMs != nil {
			doNotRunExtensionsOnOverprovisionedVMs := *typedInput.Properties.DoNotRunExtensionsOnOverprovisionedVMs
			scaleSet.DoNotRunExtensionsOnOverprovisionedVMs = &doNotRunExtensionsOnOverprovisionedVMs
		}
	}

	// Set property "ExtendedLocation":
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		scaleSet.ExtendedLocation = &extendedLocation
	}

	// Set property "HostGroup":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostGroup != nil {
			var hostGroup1 SubResource
			err := hostGroup1.PopulateFromARM(owner, *typedInput.Properties.HostGroup)
			if err != nil {
				return err
			}
			hostGroup := hostGroup1
			scaleSet.HostGroup = &hostGroup
		}
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 VirtualMachineScaleSetIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		scaleSet.Identity = &identity
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		scaleSet.Location = &location
	}

	// no assignment for property "OperatorSpec"

	// Set property "OrchestrationMode":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OrchestrationMode != nil {
			var temp string
			temp = string(*typedInput.Properties.OrchestrationMode)
			orchestrationMode := OrchestrationMode(temp)
			scaleSet.OrchestrationMode = &orchestrationMode
		}
	}

	// Set property "Overprovision":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Overprovision != nil {
			overprovision := *typedInput.Properties.Overprovision
			scaleSet.Overprovision = &overprovision
		}
	}

	// Set property "Owner":
	scaleSet.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "Plan":
	if typedInput.Plan != nil {
		var plan1 Plan
		err := plan1.PopulateFromARM(owner, *typedInput.Plan)
		if err != nil {
			return err
		}
		plan := plan1
		scaleSet.Plan = &plan
	}

	// Set property "PlatformFaultDomainCount":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PlatformFaultDomainCount != nil {
			platformFaultDomainCount := *typedInput.Properties.PlatformFaultDomainCount
			scaleSet.PlatformFaultDomainCount = &platformFaultDomainCount
		}
	}

	// Set property "ProximityPlacementGroup":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProximityPlacementGroup != nil {
			var proximityPlacementGroup1 SubResource
			err := proximityPlacementGroup1.PopulateFromARM(owner, *typedInput.Properties.ProximityPlacementGroup)
			if err != nil {
				return err
			}
			proximityPlacementGroup := proximityPlacementGroup1
			scaleSet.ProximityPlacementGroup = &proximityPlacementGroup
		}
	}

	// Set property "ScaleInPolicy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ScaleInPolicy != nil {
			var scaleInPolicy1 ScaleInPolicy
			err := scaleInPolicy1.PopulateFromARM(owner, *typedInput.Properties.ScaleInPolicy)
			if err != nil {
				return err
			}
			scaleInPolicy := scaleInPolicy1
			scaleSet.ScaleInPolicy = &scaleInPolicy
		}
	}

	// Set property "SinglePlacementGroup":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SinglePlacementGroup != nil {
			singlePlacementGroup := *typedInput.Properties.SinglePlacementGroup
			scaleSet.SinglePlacementGroup = &singlePlacementGroup
		}
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 Sku
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		scaleSet.Sku = &sku
	}

	// Set property "SpotRestorePolicy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SpotRestorePolicy != nil {
			var spotRestorePolicy1 SpotRestorePolicy
			err := spotRestorePolicy1.PopulateFromARM(owner, *typedInput.Properties.SpotRestorePolicy)
			if err != nil {
				return err
			}
			spotRestorePolicy := spotRestorePolicy1
			scaleSet.SpotRestorePolicy = &spotRestorePolicy
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		scaleSet.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			scaleSet.Tags[key] = value
		}
	}

	// Set property "UpgradePolicy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.UpgradePolicy != nil {
			var upgradePolicy1 UpgradePolicy
			err := upgradePolicy1.PopulateFromARM(owner, *typedInput.Properties.UpgradePolicy)
			if err != nil {
				return err
			}
			upgradePolicy := upgradePolicy1
			scaleSet.UpgradePolicy = &upgradePolicy
		}
	}

	// Set property "VirtualMachineProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VirtualMachineProfile != nil {
			var virtualMachineProfile1 VirtualMachineScaleSetVMProfile
			err := virtualMachineProfile1.PopulateFromARM(owner, *typedInput.Properties.VirtualMachineProfile)
			if err != nil {
				return err
			}
			virtualMachineProfile := virtualMachineProfile1
			scaleSet.VirtualMachineProfile = &virtualMachineProfile
		}
	}

	// Set property "ZoneBalance":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ZoneBalance != nil {
			zoneBalance := *typedInput.Properties.ZoneBalance
			scaleSet.ZoneBalance = &zoneBalance
		}
	}

	// Set property "Zones":
	for _, item := range typedInput.Zones {
		scaleSet.Zones = append(scaleSet.Zones, item)
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &VirtualMachineScaleSet_Spec{}

// ConvertSpecFrom populates our VirtualMachineScaleSet_Spec from the provided source
func (scaleSet *VirtualMachineScaleSet_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.VirtualMachineScaleSet_Spec)
	if ok {
		// Populate our instance from source
		return scaleSet.AssignProperties_From_VirtualMachineScaleSet_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.VirtualMachineScaleSet_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = scaleSet.AssignProperties_From_VirtualMachineScaleSet_Spec(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our VirtualMachineScaleSet_Spec
func (scaleSet *VirtualMachineScaleSet_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.VirtualMachineScaleSet_Spec)
	if ok {
		// Populate destination from our instance
		return scaleSet.AssignProperties_To_VirtualMachineScaleSet_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.VirtualMachineScaleSet_Spec{}
	err := scaleSet.AssignProperties_To_VirtualMachineScaleSet_Spec(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_VirtualMachineScaleSet_Spec populates our VirtualMachineScaleSet_Spec from the provided source VirtualMachineScaleSet_Spec
func (scaleSet *VirtualMachineScaleSet_Spec) AssignProperties_From_VirtualMachineScaleSet_Spec(source *storage.VirtualMachineScaleSet_Spec) error {

	// AdditionalCapabilities
	if source.AdditionalCapabilities != nil {
		var additionalCapability AdditionalCapabilities
		err := additionalCapability.AssignProperties_From_AdditionalCapabilities(source.AdditionalCapabilities)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AdditionalCapabilities() to populate field AdditionalCapabilities")
		}
		scaleSet.AdditionalCapabilities = &additionalCapability
	} else {
		scaleSet.AdditionalCapabilities = nil
	}

	// AutomaticRepairsPolicy
	if source.AutomaticRepairsPolicy != nil {
		var automaticRepairsPolicy AutomaticRepairsPolicy
		err := automaticRepairsPolicy.AssignProperties_From_AutomaticRepairsPolicy(source.AutomaticRepairsPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AutomaticRepairsPolicy() to populate field AutomaticRepairsPolicy")
		}
		scaleSet.AutomaticRepairsPolicy = &automaticRepairsPolicy
	} else {
		scaleSet.AutomaticRepairsPolicy = nil
	}

	// AzureName
	scaleSet.AzureName = source.AzureName

	// DoNotRunExtensionsOnOverprovisionedVMs
	if source.DoNotRunExtensionsOnOverprovisionedVMs != nil {
		doNotRunExtensionsOnOverprovisionedVM := *source.DoNotRunExtensionsOnOverprovisionedVMs
		scaleSet.DoNotRunExtensionsOnOverprovisionedVMs = &doNotRunExtensionsOnOverprovisionedVM
	} else {
		scaleSet.DoNotRunExtensionsOnOverprovisionedVMs = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation
		err := extendedLocation.AssignProperties_From_ExtendedLocation(source.ExtendedLocation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ExtendedLocation() to populate field ExtendedLocation")
		}
		scaleSet.ExtendedLocation = &extendedLocation
	} else {
		scaleSet.ExtendedLocation = nil
	}

	// HostGroup
	if source.HostGroup != nil {
		var hostGroup SubResource
		err := hostGroup.AssignProperties_From_SubResource(source.HostGroup)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SubResource() to populate field HostGroup")
		}
		scaleSet.HostGroup = &hostGroup
	} else {
		scaleSet.HostGroup = nil
	}

	// Identity
	if source.Identity != nil {
		var identity VirtualMachineScaleSetIdentity
		err := identity.AssignProperties_From_VirtualMachineScaleSetIdentity(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetIdentity() to populate field Identity")
		}
		scaleSet.Identity = &identity
	} else {
		scaleSet.Identity = nil
	}

	// Location
	scaleSet.Location = genruntime.ClonePointerToString(source.Location)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec VirtualMachineScaleSetOperatorSpec
		err := operatorSpec.AssignProperties_From_VirtualMachineScaleSetOperatorSpec(source.OperatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetOperatorSpec() to populate field OperatorSpec")
		}
		scaleSet.OperatorSpec = &operatorSpec
	} else {
		scaleSet.OperatorSpec = nil
	}

	// OrchestrationMode
	if source.OrchestrationMode != nil {
		orchestrationMode := *source.OrchestrationMode
		orchestrationModeTemp := genruntime.ToEnum(orchestrationMode, orchestrationMode_Values)
		scaleSet.OrchestrationMode = &orchestrationModeTemp
	} else {
		scaleSet.OrchestrationMode = nil
	}

	// Overprovision
	if source.Overprovision != nil {
		overprovision := *source.Overprovision
		scaleSet.Overprovision = &overprovision
	} else {
		scaleSet.Overprovision = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		scaleSet.Owner = &owner
	} else {
		scaleSet.Owner = nil
	}

	// Plan
	if source.Plan != nil {
		var plan Plan
		err := plan.AssignProperties_From_Plan(source.Plan)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Plan() to populate field Plan")
		}
		scaleSet.Plan = &plan
	} else {
		scaleSet.Plan = nil
	}

	// PlatformFaultDomainCount
	scaleSet.PlatformFaultDomainCount = genruntime.ClonePointerToInt(source.PlatformFaultDomainCount)

	// ProximityPlacementGroup
	if source.ProximityPlacementGroup != nil {
		var proximityPlacementGroup SubResource
		err := proximityPlacementGroup.AssignProperties_From_SubResource(source.ProximityPlacementGroup)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SubResource() to populate field ProximityPlacementGroup")
		}
		scaleSet.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		scaleSet.ProximityPlacementGroup = nil
	}

	// ScaleInPolicy
	if source.ScaleInPolicy != nil {
		var scaleInPolicy ScaleInPolicy
		err := scaleInPolicy.AssignProperties_From_ScaleInPolicy(source.ScaleInPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ScaleInPolicy() to populate field ScaleInPolicy")
		}
		scaleSet.ScaleInPolicy = &scaleInPolicy
	} else {
		scaleSet.ScaleInPolicy = nil
	}

	// SinglePlacementGroup
	if source.SinglePlacementGroup != nil {
		singlePlacementGroup := *source.SinglePlacementGroup
		scaleSet.SinglePlacementGroup = &singlePlacementGroup
	} else {
		scaleSet.SinglePlacementGroup = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.AssignProperties_From_Sku(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Sku() to populate field Sku")
		}
		scaleSet.Sku = &sku
	} else {
		scaleSet.Sku = nil
	}

	// SpotRestorePolicy
	if source.SpotRestorePolicy != nil {
		var spotRestorePolicy SpotRestorePolicy
		err := spotRestorePolicy.AssignProperties_From_SpotRestorePolicy(source.SpotRestorePolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SpotRestorePolicy() to populate field SpotRestorePolicy")
		}
		scaleSet.SpotRestorePolicy = &spotRestorePolicy
	} else {
		scaleSet.SpotRestorePolicy = nil
	}

	// Tags
	scaleSet.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// UpgradePolicy
	if source.UpgradePolicy != nil {
		var upgradePolicy UpgradePolicy
		err := upgradePolicy.AssignProperties_From_UpgradePolicy(source.UpgradePolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_UpgradePolicy() to populate field UpgradePolicy")
		}
		scaleSet.UpgradePolicy = &upgradePolicy
	} else {
		scaleSet.UpgradePolicy = nil
	}

	// VirtualMachineProfile
	if source.VirtualMachineProfile != nil {
		var virtualMachineProfile VirtualMachineScaleSetVMProfile
		err := virtualMachineProfile.AssignProperties_From_VirtualMachineScaleSetVMProfile(source.VirtualMachineProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetVMProfile() to populate field VirtualMachineProfile")
		}
		scaleSet.VirtualMachineProfile = &virtualMachineProfile
	} else {
		scaleSet.VirtualMachineProfile = nil
	}

	// ZoneBalance
	if source.ZoneBalance != nil {
		zoneBalance := *source.ZoneBalance
		scaleSet.ZoneBalance = &zoneBalance
	} else {
		scaleSet.ZoneBalance = nil
	}

	// Zones
	scaleSet.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSet_Spec populates the provided destination VirtualMachineScaleSet_Spec from our VirtualMachineScaleSet_Spec
func (scaleSet *VirtualMachineScaleSet_Spec) AssignProperties_To_VirtualMachineScaleSet_Spec(destination *storage.VirtualMachineScaleSet_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalCapabilities
	if scaleSet.AdditionalCapabilities != nil {
		var additionalCapability storage.AdditionalCapabilities
		err := scaleSet.AdditionalCapabilities.AssignProperties_To_AdditionalCapabilities(&additionalCapability)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AdditionalCapabilities() to populate field AdditionalCapabilities")
		}
		destination.AdditionalCapabilities = &additionalCapability
	} else {
		destination.AdditionalCapabilities = nil
	}

	// AutomaticRepairsPolicy
	if scaleSet.AutomaticRepairsPolicy != nil {
		var automaticRepairsPolicy storage.AutomaticRepairsPolicy
		err := scaleSet.AutomaticRepairsPolicy.AssignProperties_To_AutomaticRepairsPolicy(&automaticRepairsPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AutomaticRepairsPolicy() to populate field AutomaticRepairsPolicy")
		}
		destination.AutomaticRepairsPolicy = &automaticRepairsPolicy
	} else {
		destination.AutomaticRepairsPolicy = nil
	}

	// AzureName
	destination.AzureName = scaleSet.AzureName

	// DoNotRunExtensionsOnOverprovisionedVMs
	if scaleSet.DoNotRunExtensionsOnOverprovisionedVMs != nil {
		doNotRunExtensionsOnOverprovisionedVM := *scaleSet.DoNotRunExtensionsOnOverprovisionedVMs
		destination.DoNotRunExtensionsOnOverprovisionedVMs = &doNotRunExtensionsOnOverprovisionedVM
	} else {
		destination.DoNotRunExtensionsOnOverprovisionedVMs = nil
	}

	// ExtendedLocation
	if scaleSet.ExtendedLocation != nil {
		var extendedLocation storage.ExtendedLocation
		err := scaleSet.ExtendedLocation.AssignProperties_To_ExtendedLocation(&extendedLocation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ExtendedLocation() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// HostGroup
	if scaleSet.HostGroup != nil {
		var hostGroup storage.SubResource
		err := scaleSet.HostGroup.AssignProperties_To_SubResource(&hostGroup)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SubResource() to populate field HostGroup")
		}
		destination.HostGroup = &hostGroup
	} else {
		destination.HostGroup = nil
	}

	// Identity
	if scaleSet.Identity != nil {
		var identity storage.VirtualMachineScaleSetIdentity
		err := scaleSet.Identity.AssignProperties_To_VirtualMachineScaleSetIdentity(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(scaleSet.Location)

	// OperatorSpec
	if scaleSet.OperatorSpec != nil {
		var operatorSpec storage.VirtualMachineScaleSetOperatorSpec
		err := scaleSet.OperatorSpec.AssignProperties_To_VirtualMachineScaleSetOperatorSpec(&operatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OrchestrationMode
	if scaleSet.OrchestrationMode != nil {
		orchestrationMode := string(*scaleSet.OrchestrationMode)
		destination.OrchestrationMode = &orchestrationMode
	} else {
		destination.OrchestrationMode = nil
	}

	// OriginalVersion
	destination.OriginalVersion = scaleSet.OriginalVersion()

	// Overprovision
	if scaleSet.Overprovision != nil {
		overprovision := *scaleSet.Overprovision
		destination.Overprovision = &overprovision
	} else {
		destination.Overprovision = nil
	}

	// Owner
	if scaleSet.Owner != nil {
		owner := scaleSet.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Plan
	if scaleSet.Plan != nil {
		var plan storage.Plan
		err := scaleSet.Plan.AssignProperties_To_Plan(&plan)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Plan() to populate field Plan")
		}
		destination.Plan = &plan
	} else {
		destination.Plan = nil
	}

	// PlatformFaultDomainCount
	destination.PlatformFaultDomainCount = genruntime.ClonePointerToInt(scaleSet.PlatformFaultDomainCount)

	// ProximityPlacementGroup
	if scaleSet.ProximityPlacementGroup != nil {
		var proximityPlacementGroup storage.SubResource
		err := scaleSet.ProximityPlacementGroup.AssignProperties_To_SubResource(&proximityPlacementGroup)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SubResource() to populate field ProximityPlacementGroup")
		}
		destination.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		destination.ProximityPlacementGroup = nil
	}

	// ScaleInPolicy
	if scaleSet.ScaleInPolicy != nil {
		var scaleInPolicy storage.ScaleInPolicy
		err := scaleSet.ScaleInPolicy.AssignProperties_To_ScaleInPolicy(&scaleInPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ScaleInPolicy() to populate field ScaleInPolicy")
		}
		destination.ScaleInPolicy = &scaleInPolicy
	} else {
		destination.ScaleInPolicy = nil
	}

	// SinglePlacementGroup
	if scaleSet.SinglePlacementGroup != nil {
		singlePlacementGroup := *scaleSet.SinglePlacementGroup
		destination.SinglePlacementGroup = &singlePlacementGroup
	} else {
		destination.SinglePlacementGroup = nil
	}

	// Sku
	if scaleSet.Sku != nil {
		var sku storage.Sku
		err := scaleSet.Sku.AssignProperties_To_Sku(&sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Sku() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// SpotRestorePolicy
	if scaleSet.SpotRestorePolicy != nil {
		var spotRestorePolicy storage.SpotRestorePolicy
		err := scaleSet.SpotRestorePolicy.AssignProperties_To_SpotRestorePolicy(&spotRestorePolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SpotRestorePolicy() to populate field SpotRestorePolicy")
		}
		destination.SpotRestorePolicy = &spotRestorePolicy
	} else {
		destination.SpotRestorePolicy = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(scaleSet.Tags)

	// UpgradePolicy
	if scaleSet.UpgradePolicy != nil {
		var upgradePolicy storage.UpgradePolicy
		err := scaleSet.UpgradePolicy.AssignProperties_To_UpgradePolicy(&upgradePolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_UpgradePolicy() to populate field UpgradePolicy")
		}
		destination.UpgradePolicy = &upgradePolicy
	} else {
		destination.UpgradePolicy = nil
	}

	// VirtualMachineProfile
	if scaleSet.VirtualMachineProfile != nil {
		var virtualMachineProfile storage.VirtualMachineScaleSetVMProfile
		err := scaleSet.VirtualMachineProfile.AssignProperties_To_VirtualMachineScaleSetVMProfile(&virtualMachineProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetVMProfile() to populate field VirtualMachineProfile")
		}
		destination.VirtualMachineProfile = &virtualMachineProfile
	} else {
		destination.VirtualMachineProfile = nil
	}

	// ZoneBalance
	if scaleSet.ZoneBalance != nil {
		zoneBalance := *scaleSet.ZoneBalance
		destination.ZoneBalance = &zoneBalance
	} else {
		destination.ZoneBalance = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(scaleSet.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualMachineScaleSet_STATUS populates our VirtualMachineScaleSet_Spec from the provided source VirtualMachineScaleSet_STATUS
func (scaleSet *VirtualMachineScaleSet_Spec) Initialize_From_VirtualMachineScaleSet_STATUS(source *VirtualMachineScaleSet_STATUS) error {

	// AdditionalCapabilities
	if source.AdditionalCapabilities != nil {
		var additionalCapability AdditionalCapabilities
		err := additionalCapability.Initialize_From_AdditionalCapabilities_STATUS(source.AdditionalCapabilities)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_AdditionalCapabilities_STATUS() to populate field AdditionalCapabilities")
		}
		scaleSet.AdditionalCapabilities = &additionalCapability
	} else {
		scaleSet.AdditionalCapabilities = nil
	}

	// AutomaticRepairsPolicy
	if source.AutomaticRepairsPolicy != nil {
		var automaticRepairsPolicy AutomaticRepairsPolicy
		err := automaticRepairsPolicy.Initialize_From_AutomaticRepairsPolicy_STATUS(source.AutomaticRepairsPolicy)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_AutomaticRepairsPolicy_STATUS() to populate field AutomaticRepairsPolicy")
		}
		scaleSet.AutomaticRepairsPolicy = &automaticRepairsPolicy
	} else {
		scaleSet.AutomaticRepairsPolicy = nil
	}

	// DoNotRunExtensionsOnOverprovisionedVMs
	if source.DoNotRunExtensionsOnOverprovisionedVMs != nil {
		doNotRunExtensionsOnOverprovisionedVM := *source.DoNotRunExtensionsOnOverprovisionedVMs
		scaleSet.DoNotRunExtensionsOnOverprovisionedVMs = &doNotRunExtensionsOnOverprovisionedVM
	} else {
		scaleSet.DoNotRunExtensionsOnOverprovisionedVMs = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation
		err := extendedLocation.Initialize_From_ExtendedLocation_STATUS(source.ExtendedLocation)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ExtendedLocation_STATUS() to populate field ExtendedLocation")
		}
		scaleSet.ExtendedLocation = &extendedLocation
	} else {
		scaleSet.ExtendedLocation = nil
	}

	// HostGroup
	if source.HostGroup != nil {
		var hostGroup SubResource
		err := hostGroup.Initialize_From_SubResource_STATUS(source.HostGroup)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_SubResource_STATUS() to populate field HostGroup")
		}
		scaleSet.HostGroup = &hostGroup
	} else {
		scaleSet.HostGroup = nil
	}

	// Identity
	if source.Identity != nil {
		var identity VirtualMachineScaleSetIdentity
		err := identity.Initialize_From_VirtualMachineScaleSetIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_VirtualMachineScaleSetIdentity_STATUS() to populate field Identity")
		}
		scaleSet.Identity = &identity
	} else {
		scaleSet.Identity = nil
	}

	// Location
	scaleSet.Location = genruntime.ClonePointerToString(source.Location)

	// OrchestrationMode
	if source.OrchestrationMode != nil {
		orchestrationMode := genruntime.ToEnum(string(*source.OrchestrationMode), orchestrationMode_Values)
		scaleSet.OrchestrationMode = &orchestrationMode
	} else {
		scaleSet.OrchestrationMode = nil
	}

	// Overprovision
	if source.Overprovision != nil {
		overprovision := *source.Overprovision
		scaleSet.Overprovision = &overprovision
	} else {
		scaleSet.Overprovision = nil
	}

	// Plan
	if source.Plan != nil {
		var plan Plan
		err := plan.Initialize_From_Plan_STATUS(source.Plan)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_Plan_STATUS() to populate field Plan")
		}
		scaleSet.Plan = &plan
	} else {
		scaleSet.Plan = nil
	}

	// PlatformFaultDomainCount
	scaleSet.PlatformFaultDomainCount = genruntime.ClonePointerToInt(source.PlatformFaultDomainCount)

	// ProximityPlacementGroup
	if source.ProximityPlacementGroup != nil {
		var proximityPlacementGroup SubResource
		err := proximityPlacementGroup.Initialize_From_SubResource_STATUS(source.ProximityPlacementGroup)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_SubResource_STATUS() to populate field ProximityPlacementGroup")
		}
		scaleSet.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		scaleSet.ProximityPlacementGroup = nil
	}

	// ScaleInPolicy
	if source.ScaleInPolicy != nil {
		var scaleInPolicy ScaleInPolicy
		err := scaleInPolicy.Initialize_From_ScaleInPolicy_STATUS(source.ScaleInPolicy)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ScaleInPolicy_STATUS() to populate field ScaleInPolicy")
		}
		scaleSet.ScaleInPolicy = &scaleInPolicy
	} else {
		scaleSet.ScaleInPolicy = nil
	}

	// SinglePlacementGroup
	if source.SinglePlacementGroup != nil {
		singlePlacementGroup := *source.SinglePlacementGroup
		scaleSet.SinglePlacementGroup = &singlePlacementGroup
	} else {
		scaleSet.SinglePlacementGroup = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.Initialize_From_Sku_STATUS(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_Sku_STATUS() to populate field Sku")
		}
		scaleSet.Sku = &sku
	} else {
		scaleSet.Sku = nil
	}

	// SpotRestorePolicy
	if source.SpotRestorePolicy != nil {
		var spotRestorePolicy SpotRestorePolicy
		err := spotRestorePolicy.Initialize_From_SpotRestorePolicy_STATUS(source.SpotRestorePolicy)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_SpotRestorePolicy_STATUS() to populate field SpotRestorePolicy")
		}
		scaleSet.SpotRestorePolicy = &spotRestorePolicy
	} else {
		scaleSet.SpotRestorePolicy = nil
	}

	// Tags
	scaleSet.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// UpgradePolicy
	if source.UpgradePolicy != nil {
		var upgradePolicy UpgradePolicy
		err := upgradePolicy.Initialize_From_UpgradePolicy_STATUS(source.UpgradePolicy)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_UpgradePolicy_STATUS() to populate field UpgradePolicy")
		}
		scaleSet.UpgradePolicy = &upgradePolicy
	} else {
		scaleSet.UpgradePolicy = nil
	}

	// VirtualMachineProfile
	if source.VirtualMachineProfile != nil {
		var virtualMachineProfile VirtualMachineScaleSetVMProfile
		err := virtualMachineProfile.Initialize_From_VirtualMachineScaleSetVMProfile_STATUS(source.VirtualMachineProfile)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_VirtualMachineScaleSetVMProfile_STATUS() to populate field VirtualMachineProfile")
		}
		scaleSet.VirtualMachineProfile = &virtualMachineProfile
	} else {
		scaleSet.VirtualMachineProfile = nil
	}

	// ZoneBalance
	if source.ZoneBalance != nil {
		zoneBalance := *source.ZoneBalance
		scaleSet.ZoneBalance = &zoneBalance
	} else {
		scaleSet.ZoneBalance = nil
	}

	// Zones
	scaleSet.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (scaleSet *VirtualMachineScaleSet_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (scaleSet *VirtualMachineScaleSet_Spec) SetAzureName(azureName string) {
	scaleSet.AzureName = azureName
}

// Describes a Virtual Machine Scale Set.
type VirtualMachineScaleSet_STATUS struct {
	// AdditionalCapabilities: Specifies additional capabilities enabled or disabled on the Virtual Machines in the Virtual
	// Machine Scale Set. For instance: whether the Virtual Machines have the capability to support attaching managed data
	// disks with UltraSSD_LRS storage account type.
	AdditionalCapabilities *AdditionalCapabilities_STATUS `json:"additionalCapabilities,omitempty"`

	// AutomaticRepairsPolicy: Policy for automatic repairs.
	AutomaticRepairsPolicy *AutomaticRepairsPolicy_STATUS `json:"automaticRepairsPolicy,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// DoNotRunExtensionsOnOverprovisionedVMs: When Overprovision is enabled, extensions are launched only on the requested
	// number of VMs which are finally kept. This property will hence ensure that the extensions do not run on the extra
	// overprovisioned VMs.
	DoNotRunExtensionsOnOverprovisionedVMs *bool `json:"doNotRunExtensionsOnOverprovisionedVMs,omitempty"`

	// ExtendedLocation: The extended location of the Virtual Machine Scale Set.
	ExtendedLocation *ExtendedLocation_STATUS `json:"extendedLocation,omitempty"`

	// HostGroup: Specifies information about the dedicated host group that the virtual machine scale set resides in.
	// Minimum api-version: 2020-06-01.
	HostGroup *SubResource_STATUS `json:"hostGroup,omitempty"`

	// Id: Resource Id
	Id *string `json:"id,omitempty"`

	// Identity: The identity of the virtual machine scale set, if configured.
	Identity *VirtualMachineScaleSetIdentity_STATUS `json:"identity,omitempty"`

	// Location: Resource location
	Location *string `json:"location,omitempty"`

	// Name: Resource name
	Name *string `json:"name,omitempty"`

	// OrchestrationMode: Specifies the orchestration mode for the virtual machine scale set.
	OrchestrationMode *OrchestrationMode_STATUS `json:"orchestrationMode,omitempty"`

	// Overprovision: Specifies whether the Virtual Machine Scale Set should be overprovisioned.
	Overprovision *bool `json:"overprovision,omitempty"`

	// Plan: Specifies information about the marketplace image used to create the virtual machine. This element is only used
	// for marketplace images. Before you can use a marketplace image from an API, you must enable the image for programmatic
	// use.  In the Azure portal, find the marketplace image that you want to use and then click Want to deploy
	// programmatically, Get Started ->. Enter any required information and then click Save.
	Plan *Plan_STATUS `json:"plan,omitempty"`

	// PlatformFaultDomainCount: Fault Domain count for each placement group.
	PlatformFaultDomainCount *int `json:"platformFaultDomainCount,omitempty"`

	// ProvisioningState: The provisioning state, which only appears in the response.
	ProvisioningState *string `json:"provisioningState,omitempty"`

	// ProximityPlacementGroup: Specifies information about the proximity placement group that the virtual machine scale set
	// should be assigned to.
	// Minimum api-version: 2018-04-01.
	ProximityPlacementGroup *SubResource_STATUS `json:"proximityPlacementGroup,omitempty"`

	// ScaleInPolicy: Specifies the policies applied when scaling in Virtual Machines in the Virtual Machine Scale Set.
	ScaleInPolicy *ScaleInPolicy_STATUS `json:"scaleInPolicy,omitempty"`

	// SinglePlacementGroup: When true this limits the scale set to a single placement group, of max size 100 virtual machines.
	// NOTE: If singlePlacementGroup is true, it may be modified to false. However, if singlePlacementGroup is false, it may
	// not be modified to true.
	SinglePlacementGroup *bool `json:"singlePlacementGroup,omitempty"`

	// Sku: The virtual machine scale set sku.
	Sku *Sku_STATUS `json:"sku,omitempty"`

	// SpotRestorePolicy: Specifies the Spot Restore properties for the virtual machine scale set.
	SpotRestorePolicy *SpotRestorePolicy_STATUS `json:"spotRestorePolicy,omitempty"`

	// Tags: Resource tags
	Tags map[string]string `json:"tags,omitempty"`

	// TimeCreated: Specifies the time at which the Virtual Machine Scale Set resource was created.
	// Minimum api-version: 2022-03-01.
	TimeCreated *string `json:"timeCreated,omitempty"`

	// Type: Resource type
	Type *string `json:"type,omitempty"`

	// UniqueId: Specifies the ID which uniquely identifies a Virtual Machine Scale Set.
	UniqueId *string `json:"uniqueId,omitempty"`

	// UpgradePolicy: The upgrade policy.
	UpgradePolicy *UpgradePolicy_STATUS `json:"upgradePolicy,omitempty"`

	// VirtualMachineProfile: The virtual machine profile.
	VirtualMachineProfile *VirtualMachineScaleSetVMProfile_STATUS `json:"virtualMachineProfile,omitempty"`

	// ZoneBalance: Whether to force strictly even Virtual Machine distribution cross x-zones in case there is zone outage.
	// zoneBalance property can only be set if the zones property of the scale set contains more than one zone. If there are no
	// zones or only one zone specified, then zoneBalance property should not be set.
	ZoneBalance *bool `json:"zoneBalance,omitempty"`

	// Zones: The virtual machine scale set zones. NOTE: Availability zones can only be set when you create the scale set
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.ConvertibleStatus = &VirtualMachineScaleSet_STATUS{}

// ConvertStatusFrom populates our VirtualMachineScaleSet_STATUS from the provided source
func (scaleSet *VirtualMachineScaleSet_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.VirtualMachineScaleSet_STATUS)
	if ok {
		// Populate our instance from source
		return scaleSet.AssignProperties_From_VirtualMachineScaleSet_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.VirtualMachineScaleSet_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = scaleSet.AssignProperties_From_VirtualMachineScaleSet_STATUS(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our VirtualMachineScaleSet_STATUS
func (scaleSet *VirtualMachineScaleSet_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.VirtualMachineScaleSet_STATUS)
	if ok {
		// Populate destination from our instance
		return scaleSet.AssignProperties_To_VirtualMachineScaleSet_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.VirtualMachineScaleSet_STATUS{}
	err := scaleSet.AssignProperties_To_VirtualMachineScaleSet_STATUS(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSet_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (scaleSet *VirtualMachineScaleSet_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSet_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (scaleSet *VirtualMachineScaleSet_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSet_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSet_STATUS, got %T", armInput)
	}

	// Set property "AdditionalCapabilities":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AdditionalCapabilities != nil {
			var additionalCapabilities1 AdditionalCapabilities_STATUS
			err := additionalCapabilities1.PopulateFromARM(owner, *typedInput.Properties.AdditionalCapabilities)
			if err != nil {
				return err
			}
			additionalCapabilities := additionalCapabilities1
			scaleSet.AdditionalCapabilities = &additionalCapabilities
		}
	}

	// Set property "AutomaticRepairsPolicy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutomaticRepairsPolicy != nil {
			var automaticRepairsPolicy1 AutomaticRepairsPolicy_STATUS
			err := automaticRepairsPolicy1.PopulateFromARM(owner, *typedInput.Properties.AutomaticRepairsPolicy)
			if err != nil {
				return err
			}
			automaticRepairsPolicy := automaticRepairsPolicy1
			scaleSet.AutomaticRepairsPolicy = &automaticRepairsPolicy
		}
	}

	// no assignment for property "Conditions"

	// Set property "DoNotRunExtensionsOnOverprovisionedVMs":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DoNotRunExtensionsOnOverprovisionedVMs != nil {
			doNotRunExtensionsOnOverprovisionedVMs := *typedInput.Properties.DoNotRunExtensionsOnOverprovisionedVMs
			scaleSet.DoNotRunExtensionsOnOverprovisionedVMs = &doNotRunExtensionsOnOverprovisionedVMs
		}
	}

	// Set property "ExtendedLocation":
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_STATUS
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		scaleSet.ExtendedLocation = &extendedLocation
	}

	// Set property "HostGroup":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostGroup != nil {
			var hostGroup1 SubResource_STATUS
			err := hostGroup1.PopulateFromARM(owner, *typedInput.Properties.HostGroup)
			if err != nil {
				return err
			}
			hostGroup := hostGroup1
			scaleSet.HostGroup = &hostGroup
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		scaleSet.Id = &id
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 VirtualMachineScaleSetIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		scaleSet.Identity = &identity
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		scaleSet.Location = &location
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		scaleSet.Name = &name
	}

	// Set property "OrchestrationMode":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OrchestrationMode != nil {
			var temp string
			temp = string(*typedInput.Properties.OrchestrationMode)
			orchestrationMode := OrchestrationMode_STATUS(temp)
			scaleSet.OrchestrationMode = &orchestrationMode
		}
	}

	// Set property "Overprovision":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Overprovision != nil {
			overprovision := *typedInput.Properties.Overprovision
			scaleSet.Overprovision = &overprovision
		}
	}

	// Set property "Plan":
	if typedInput.Plan != nil {
		var plan1 Plan_STATUS
		err := plan1.PopulateFromARM(owner, *typedInput.Plan)
		if err != nil {
			return err
		}
		plan := plan1
		scaleSet.Plan = &plan
	}

	// Set property "PlatformFaultDomainCount":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PlatformFaultDomainCount != nil {
			platformFaultDomainCount := *typedInput.Properties.PlatformFaultDomainCount
			scaleSet.PlatformFaultDomainCount = &platformFaultDomainCount
		}
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			scaleSet.ProvisioningState = &provisioningState
		}
	}

	// Set property "ProximityPlacementGroup":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProximityPlacementGroup != nil {
			var proximityPlacementGroup1 SubResource_STATUS
			err := proximityPlacementGroup1.PopulateFromARM(owner, *typedInput.Properties.ProximityPlacementGroup)
			if err != nil {
				return err
			}
			proximityPlacementGroup := proximityPlacementGroup1
			scaleSet.ProximityPlacementGroup = &proximityPlacementGroup
		}
	}

	// Set property "ScaleInPolicy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ScaleInPolicy != nil {
			var scaleInPolicy1 ScaleInPolicy_STATUS
			err := scaleInPolicy1.PopulateFromARM(owner, *typedInput.Properties.ScaleInPolicy)
			if err != nil {
				return err
			}
			scaleInPolicy := scaleInPolicy1
			scaleSet.ScaleInPolicy = &scaleInPolicy
		}
	}

	// Set property "SinglePlacementGroup":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SinglePlacementGroup != nil {
			singlePlacementGroup := *typedInput.Properties.SinglePlacementGroup
			scaleSet.SinglePlacementGroup = &singlePlacementGroup
		}
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 Sku_STATUS
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		scaleSet.Sku = &sku
	}

	// Set property "SpotRestorePolicy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SpotRestorePolicy != nil {
			var spotRestorePolicy1 SpotRestorePolicy_STATUS
			err := spotRestorePolicy1.PopulateFromARM(owner, *typedInput.Properties.SpotRestorePolicy)
			if err != nil {
				return err
			}
			spotRestorePolicy := spotRestorePolicy1
			scaleSet.SpotRestorePolicy = &spotRestorePolicy
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		scaleSet.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			scaleSet.Tags[key] = value
		}
	}

	// Set property "TimeCreated":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TimeCreated != nil {
			timeCreated := *typedInput.Properties.TimeCreated
			scaleSet.TimeCreated = &timeCreated
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		scaleSet.Type = &typeVar
	}

	// Set property "UniqueId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.UniqueId != nil {
			uniqueId := *typedInput.Properties.UniqueId
			scaleSet.UniqueId = &uniqueId
		}
	}

	// Set property "UpgradePolicy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.UpgradePolicy != nil {
			var upgradePolicy1 UpgradePolicy_STATUS
			err := upgradePolicy1.PopulateFromARM(owner, *typedInput.Properties.UpgradePolicy)
			if err != nil {
				return err
			}
			upgradePolicy := upgradePolicy1
			scaleSet.UpgradePolicy = &upgradePolicy
		}
	}

	// Set property "VirtualMachineProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VirtualMachineProfile != nil {
			var virtualMachineProfile1 VirtualMachineScaleSetVMProfile_STATUS
			err := virtualMachineProfile1.PopulateFromARM(owner, *typedInput.Properties.VirtualMachineProfile)
			if err != nil {
				return err
			}
			virtualMachineProfile := virtualMachineProfile1
			scaleSet.VirtualMachineProfile = &virtualMachineProfile
		}
	}

	// Set property "ZoneBalance":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ZoneBalance != nil {
			zoneBalance := *typedInput.Properties.ZoneBalance
			scaleSet.ZoneBalance = &zoneBalance
		}
	}

	// Set property "Zones":
	for _, item := range typedInput.Zones {
		scaleSet.Zones = append(scaleSet.Zones, item)
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSet_STATUS populates our VirtualMachineScaleSet_STATUS from the provided source VirtualMachineScaleSet_STATUS
func (scaleSet *VirtualMachineScaleSet_STATUS) AssignProperties_From_VirtualMachineScaleSet_STATUS(source *storage.VirtualMachineScaleSet_STATUS) error {

	// AdditionalCapabilities
	if source.AdditionalCapabilities != nil {
		var additionalCapability AdditionalCapabilities_STATUS
		err := additionalCapability.AssignProperties_From_AdditionalCapabilities_STATUS(source.AdditionalCapabilities)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AdditionalCapabilities_STATUS() to populate field AdditionalCapabilities")
		}
		scaleSet.AdditionalCapabilities = &additionalCapability
	} else {
		scaleSet.AdditionalCapabilities = nil
	}

	// AutomaticRepairsPolicy
	if source.AutomaticRepairsPolicy != nil {
		var automaticRepairsPolicy AutomaticRepairsPolicy_STATUS
		err := automaticRepairsPolicy.AssignProperties_From_AutomaticRepairsPolicy_STATUS(source.AutomaticRepairsPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AutomaticRepairsPolicy_STATUS() to populate field AutomaticRepairsPolicy")
		}
		scaleSet.AutomaticRepairsPolicy = &automaticRepairsPolicy
	} else {
		scaleSet.AutomaticRepairsPolicy = nil
	}

	// Conditions
	scaleSet.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// DoNotRunExtensionsOnOverprovisionedVMs
	if source.DoNotRunExtensionsOnOverprovisionedVMs != nil {
		doNotRunExtensionsOnOverprovisionedVM := *source.DoNotRunExtensionsOnOverprovisionedVMs
		scaleSet.DoNotRunExtensionsOnOverprovisionedVMs = &doNotRunExtensionsOnOverprovisionedVM
	} else {
		scaleSet.DoNotRunExtensionsOnOverprovisionedVMs = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_STATUS
		err := extendedLocation.AssignProperties_From_ExtendedLocation_STATUS(source.ExtendedLocation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ExtendedLocation_STATUS() to populate field ExtendedLocation")
		}
		scaleSet.ExtendedLocation = &extendedLocation
	} else {
		scaleSet.ExtendedLocation = nil
	}

	// HostGroup
	if source.HostGroup != nil {
		var hostGroup SubResource_STATUS
		err := hostGroup.AssignProperties_From_SubResource_STATUS(source.HostGroup)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field HostGroup")
		}
		scaleSet.HostGroup = &hostGroup
	} else {
		scaleSet.HostGroup = nil
	}

	// Id
	scaleSet.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity VirtualMachineScaleSetIdentity_STATUS
		err := identity.AssignProperties_From_VirtualMachineScaleSetIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetIdentity_STATUS() to populate field Identity")
		}
		scaleSet.Identity = &identity
	} else {
		scaleSet.Identity = nil
	}

	// Location
	scaleSet.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	scaleSet.Name = genruntime.ClonePointerToString(source.Name)

	// OrchestrationMode
	if source.OrchestrationMode != nil {
		orchestrationMode := *source.OrchestrationMode
		orchestrationModeTemp := genruntime.ToEnum(orchestrationMode, orchestrationMode_STATUS_Values)
		scaleSet.OrchestrationMode = &orchestrationModeTemp
	} else {
		scaleSet.OrchestrationMode = nil
	}

	// Overprovision
	if source.Overprovision != nil {
		overprovision := *source.Overprovision
		scaleSet.Overprovision = &overprovision
	} else {
		scaleSet.Overprovision = nil
	}

	// Plan
	if source.Plan != nil {
		var plan Plan_STATUS
		err := plan.AssignProperties_From_Plan_STATUS(source.Plan)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Plan_STATUS() to populate field Plan")
		}
		scaleSet.Plan = &plan
	} else {
		scaleSet.Plan = nil
	}

	// PlatformFaultDomainCount
	scaleSet.PlatformFaultDomainCount = genruntime.ClonePointerToInt(source.PlatformFaultDomainCount)

	// ProvisioningState
	scaleSet.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// ProximityPlacementGroup
	if source.ProximityPlacementGroup != nil {
		var proximityPlacementGroup SubResource_STATUS
		err := proximityPlacementGroup.AssignProperties_From_SubResource_STATUS(source.ProximityPlacementGroup)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field ProximityPlacementGroup")
		}
		scaleSet.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		scaleSet.ProximityPlacementGroup = nil
	}

	// ScaleInPolicy
	if source.ScaleInPolicy != nil {
		var scaleInPolicy ScaleInPolicy_STATUS
		err := scaleInPolicy.AssignProperties_From_ScaleInPolicy_STATUS(source.ScaleInPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ScaleInPolicy_STATUS() to populate field ScaleInPolicy")
		}
		scaleSet.ScaleInPolicy = &scaleInPolicy
	} else {
		scaleSet.ScaleInPolicy = nil
	}

	// SinglePlacementGroup
	if source.SinglePlacementGroup != nil {
		singlePlacementGroup := *source.SinglePlacementGroup
		scaleSet.SinglePlacementGroup = &singlePlacementGroup
	} else {
		scaleSet.SinglePlacementGroup = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku_STATUS
		err := sku.AssignProperties_From_Sku_STATUS(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Sku_STATUS() to populate field Sku")
		}
		scaleSet.Sku = &sku
	} else {
		scaleSet.Sku = nil
	}

	// SpotRestorePolicy
	if source.SpotRestorePolicy != nil {
		var spotRestorePolicy SpotRestorePolicy_STATUS
		err := spotRestorePolicy.AssignProperties_From_SpotRestorePolicy_STATUS(source.SpotRestorePolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SpotRestorePolicy_STATUS() to populate field SpotRestorePolicy")
		}
		scaleSet.SpotRestorePolicy = &spotRestorePolicy
	} else {
		scaleSet.SpotRestorePolicy = nil
	}

	// Tags
	scaleSet.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TimeCreated
	scaleSet.TimeCreated = genruntime.ClonePointerToString(source.TimeCreated)

	// Type
	scaleSet.Type = genruntime.ClonePointerToString(source.Type)

	// UniqueId
	scaleSet.UniqueId = genruntime.ClonePointerToString(source.UniqueId)

	// UpgradePolicy
	if source.UpgradePolicy != nil {
		var upgradePolicy UpgradePolicy_STATUS
		err := upgradePolicy.AssignProperties_From_UpgradePolicy_STATUS(source.UpgradePolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_UpgradePolicy_STATUS() to populate field UpgradePolicy")
		}
		scaleSet.UpgradePolicy = &upgradePolicy
	} else {
		scaleSet.UpgradePolicy = nil
	}

	// VirtualMachineProfile
	if source.VirtualMachineProfile != nil {
		var virtualMachineProfile VirtualMachineScaleSetVMProfile_STATUS
		err := virtualMachineProfile.AssignProperties_From_VirtualMachineScaleSetVMProfile_STATUS(source.VirtualMachineProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetVMProfile_STATUS() to populate field VirtualMachineProfile")
		}
		scaleSet.VirtualMachineProfile = &virtualMachineProfile
	} else {
		scaleSet.VirtualMachineProfile = nil
	}

	// ZoneBalance
	if source.ZoneBalance != nil {
		zoneBalance := *source.ZoneBalance
		scaleSet.ZoneBalance = &zoneBalance
	} else {
		scaleSet.ZoneBalance = nil
	}

	// Zones
	scaleSet.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSet_STATUS populates the provided destination VirtualMachineScaleSet_STATUS from our VirtualMachineScaleSet_STATUS
func (scaleSet *VirtualMachineScaleSet_STATUS) AssignProperties_To_VirtualMachineScaleSet_STATUS(destination *storage.VirtualMachineScaleSet_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalCapabilities
	if scaleSet.AdditionalCapabilities != nil {
		var additionalCapability storage.AdditionalCapabilities_STATUS
		err := scaleSet.AdditionalCapabilities.AssignProperties_To_AdditionalCapabilities_STATUS(&additionalCapability)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AdditionalCapabilities_STATUS() to populate field AdditionalCapabilities")
		}
		destination.AdditionalCapabilities = &additionalCapability
	} else {
		destination.AdditionalCapabilities = nil
	}

	// AutomaticRepairsPolicy
	if scaleSet.AutomaticRepairsPolicy != nil {
		var automaticRepairsPolicy storage.AutomaticRepairsPolicy_STATUS
		err := scaleSet.AutomaticRepairsPolicy.AssignProperties_To_AutomaticRepairsPolicy_STATUS(&automaticRepairsPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AutomaticRepairsPolicy_STATUS() to populate field AutomaticRepairsPolicy")
		}
		destination.AutomaticRepairsPolicy = &automaticRepairsPolicy
	} else {
		destination.AutomaticRepairsPolicy = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(scaleSet.Conditions)

	// DoNotRunExtensionsOnOverprovisionedVMs
	if scaleSet.DoNotRunExtensionsOnOverprovisionedVMs != nil {
		doNotRunExtensionsOnOverprovisionedVM := *scaleSet.DoNotRunExtensionsOnOverprovisionedVMs
		destination.DoNotRunExtensionsOnOverprovisionedVMs = &doNotRunExtensionsOnOverprovisionedVM
	} else {
		destination.DoNotRunExtensionsOnOverprovisionedVMs = nil
	}

	// ExtendedLocation
	if scaleSet.ExtendedLocation != nil {
		var extendedLocation storage.ExtendedLocation_STATUS
		err := scaleSet.ExtendedLocation.AssignProperties_To_ExtendedLocation_STATUS(&extendedLocation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ExtendedLocation_STATUS() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// HostGroup
	if scaleSet.HostGroup != nil {
		var hostGroup storage.SubResource_STATUS
		err := scaleSet.HostGroup.AssignProperties_To_SubResource_STATUS(&hostGroup)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field HostGroup")
		}
		destination.HostGroup = &hostGroup
	} else {
		destination.HostGroup = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(scaleSet.Id)

	// Identity
	if scaleSet.Identity != nil {
		var identity storage.VirtualMachineScaleSetIdentity_STATUS
		err := scaleSet.Identity.AssignProperties_To_VirtualMachineScaleSetIdentity_STATUS(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(scaleSet.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(scaleSet.Name)

	// OrchestrationMode
	if scaleSet.OrchestrationMode != nil {
		orchestrationMode := string(*scaleSet.OrchestrationMode)
		destination.OrchestrationMode = &orchestrationMode
	} else {
		destination.OrchestrationMode = nil
	}

	// Overprovision
	if scaleSet.Overprovision != nil {
		overprovision := *scaleSet.Overprovision
		destination.Overprovision = &overprovision
	} else {
		destination.Overprovision = nil
	}

	// Plan
	if scaleSet.Plan != nil {
		var plan storage.Plan_STATUS
		err := scaleSet.Plan.AssignProperties_To_Plan_STATUS(&plan)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Plan_STATUS() to populate field Plan")
		}
		destination.Plan = &plan
	} else {
		destination.Plan = nil
	}

	// PlatformFaultDomainCount
	destination.PlatformFaultDomainCount = genruntime.ClonePointerToInt(scaleSet.PlatformFaultDomainCount)

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(scaleSet.ProvisioningState)

	// ProximityPlacementGroup
	if scaleSet.ProximityPlacementGroup != nil {
		var proximityPlacementGroup storage.SubResource_STATUS
		err := scaleSet.ProximityPlacementGroup.AssignProperties_To_SubResource_STATUS(&proximityPlacementGroup)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field ProximityPlacementGroup")
		}
		destination.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		destination.ProximityPlacementGroup = nil
	}

	// ScaleInPolicy
	if scaleSet.ScaleInPolicy != nil {
		var scaleInPolicy storage.ScaleInPolicy_STATUS
		err := scaleSet.ScaleInPolicy.AssignProperties_To_ScaleInPolicy_STATUS(&scaleInPolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ScaleInPolicy_STATUS() to populate field ScaleInPolicy")
		}
		destination.ScaleInPolicy = &scaleInPolicy
	} else {
		destination.ScaleInPolicy = nil
	}

	// SinglePlacementGroup
	if scaleSet.SinglePlacementGroup != nil {
		singlePlacementGroup := *scaleSet.SinglePlacementGroup
		destination.SinglePlacementGroup = &singlePlacementGroup
	} else {
		destination.SinglePlacementGroup = nil
	}

	// Sku
	if scaleSet.Sku != nil {
		var sku storage.Sku_STATUS
		err := scaleSet.Sku.AssignProperties_To_Sku_STATUS(&sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Sku_STATUS() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// SpotRestorePolicy
	if scaleSet.SpotRestorePolicy != nil {
		var spotRestorePolicy storage.SpotRestorePolicy_STATUS
		err := scaleSet.SpotRestorePolicy.AssignProperties_To_SpotRestorePolicy_STATUS(&spotRestorePolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SpotRestorePolicy_STATUS() to populate field SpotRestorePolicy")
		}
		destination.SpotRestorePolicy = &spotRestorePolicy
	} else {
		destination.SpotRestorePolicy = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(scaleSet.Tags)

	// TimeCreated
	destination.TimeCreated = genruntime.ClonePointerToString(scaleSet.TimeCreated)

	// Type
	destination.Type = genruntime.ClonePointerToString(scaleSet.Type)

	// UniqueId
	destination.UniqueId = genruntime.ClonePointerToString(scaleSet.UniqueId)

	// UpgradePolicy
	if scaleSet.UpgradePolicy != nil {
		var upgradePolicy storage.UpgradePolicy_STATUS
		err := scaleSet.UpgradePolicy.AssignProperties_To_UpgradePolicy_STATUS(&upgradePolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_UpgradePolicy_STATUS() to populate field UpgradePolicy")
		}
		destination.UpgradePolicy = &upgradePolicy
	} else {
		destination.UpgradePolicy = nil
	}

	// VirtualMachineProfile
	if scaleSet.VirtualMachineProfile != nil {
		var virtualMachineProfile storage.VirtualMachineScaleSetVMProfile_STATUS
		err := scaleSet.VirtualMachineProfile.AssignProperties_To_VirtualMachineScaleSetVMProfile_STATUS(&virtualMachineProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetVMProfile_STATUS() to populate field VirtualMachineProfile")
		}
		destination.VirtualMachineProfile = &virtualMachineProfile
	} else {
		destination.VirtualMachineProfile = nil
	}

	// ZoneBalance
	if scaleSet.ZoneBalance != nil {
		zoneBalance := *scaleSet.ZoneBalance
		destination.ZoneBalance = &zoneBalance
	} else {
		destination.ZoneBalance = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(scaleSet.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Specifies the configuration parameters for automatic repairs on the virtual machine scale set.
type AutomaticRepairsPolicy struct {
	// Enabled: Specifies whether automatic repairs should be enabled on the virtual machine scale set. The default value is
	// false.
	Enabled *bool `json:"enabled,omitempty"`

	// GracePeriod: The amount of time for which automatic repairs are suspended due to a state change on VM. The grace time
	// starts after the state change has completed. This helps avoid premature or accidental repairs. The time duration should
	// be specified in ISO 8601 format. The minimum allowed grace period is 10 minutes (PT10M), which is also the default
	// value. The maximum allowed grace period is 90 minutes (PT90M).
	GracePeriod *string `json:"gracePeriod,omitempty"`

	// RepairAction: Type of repair action (replace, restart, reimage) that will be used for repairing unhealthy virtual
	// machines in the scale set. Default value is replace.
	RepairAction *AutomaticRepairsPolicy_RepairAction `json:"repairAction,omitempty"`
}

var _ genruntime.ARMTransformer = &AutomaticRepairsPolicy{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *AutomaticRepairsPolicy) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	result := &arm.AutomaticRepairsPolicy{}

	// Set property "Enabled":
	if policy.Enabled != nil {
		enabled := *policy.Enabled
		result.Enabled = &enabled
	}

	// Set property "GracePeriod":
	if policy.GracePeriod != nil {
		gracePeriod := *policy.GracePeriod
		result.GracePeriod = &gracePeriod
	}

	// Set property "RepairAction":
	if policy.RepairAction != nil {
		var temp string
		temp = string(*policy.RepairAction)
		repairAction := arm.AutomaticRepairsPolicy_RepairAction(temp)
		result.RepairAction = &repairAction
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *AutomaticRepairsPolicy) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AutomaticRepairsPolicy{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *AutomaticRepairsPolicy) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AutomaticRepairsPolicy)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AutomaticRepairsPolicy, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		policy.Enabled = &enabled
	}

	// Set property "GracePeriod":
	if typedInput.GracePeriod != nil {
		gracePeriod := *typedInput.GracePeriod
		policy.GracePeriod = &gracePeriod
	}

	// Set property "RepairAction":
	if typedInput.RepairAction != nil {
		var temp string
		temp = string(*typedInput.RepairAction)
		repairAction := AutomaticRepairsPolicy_RepairAction(temp)
		policy.RepairAction = &repairAction
	}

	// No error
	return nil
}

// AssignProperties_From_AutomaticRepairsPolicy populates our AutomaticRepairsPolicy from the provided source AutomaticRepairsPolicy
func (policy *AutomaticRepairsPolicy) AssignProperties_From_AutomaticRepairsPolicy(source *storage.AutomaticRepairsPolicy) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		policy.Enabled = &enabled
	} else {
		policy.Enabled = nil
	}

	// GracePeriod
	policy.GracePeriod = genruntime.ClonePointerToString(source.GracePeriod)

	// RepairAction
	if source.RepairAction != nil {
		repairAction := *source.RepairAction
		repairActionTemp := genruntime.ToEnum(repairAction, automaticRepairsPolicy_RepairAction_Values)
		policy.RepairAction = &repairActionTemp
	} else {
		policy.RepairAction = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AutomaticRepairsPolicy populates the provided destination AutomaticRepairsPolicy from our AutomaticRepairsPolicy
func (policy *AutomaticRepairsPolicy) AssignProperties_To_AutomaticRepairsPolicy(destination *storage.AutomaticRepairsPolicy) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if policy.Enabled != nil {
		enabled := *policy.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// GracePeriod
	destination.GracePeriod = genruntime.ClonePointerToString(policy.GracePeriod)

	// RepairAction
	if policy.RepairAction != nil {
		repairAction := string(*policy.RepairAction)
		destination.RepairAction = &repairAction
	} else {
		destination.RepairAction = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AutomaticRepairsPolicy_STATUS populates our AutomaticRepairsPolicy from the provided source AutomaticRepairsPolicy_STATUS
func (policy *AutomaticRepairsPolicy) Initialize_From_AutomaticRepairsPolicy_STATUS(source *AutomaticRepairsPolicy_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		policy.Enabled = &enabled
	} else {
		policy.Enabled = nil
	}

	// GracePeriod
	policy.GracePeriod = genruntime.ClonePointerToString(source.GracePeriod)

	// RepairAction
	if source.RepairAction != nil {
		repairAction := genruntime.ToEnum(string(*source.RepairAction), automaticRepairsPolicy_RepairAction_Values)
		policy.RepairAction = &repairAction
	} else {
		policy.RepairAction = nil
	}

	// No error
	return nil
}

// Specifies the configuration parameters for automatic repairs on the virtual machine scale set.
type AutomaticRepairsPolicy_STATUS struct {
	// Enabled: Specifies whether automatic repairs should be enabled on the virtual machine scale set. The default value is
	// false.
	Enabled *bool `json:"enabled,omitempty"`

	// GracePeriod: The amount of time for which automatic repairs are suspended due to a state change on VM. The grace time
	// starts after the state change has completed. This helps avoid premature or accidental repairs. The time duration should
	// be specified in ISO 8601 format. The minimum allowed grace period is 10 minutes (PT10M), which is also the default
	// value. The maximum allowed grace period is 90 minutes (PT90M).
	GracePeriod *string `json:"gracePeriod,omitempty"`

	// RepairAction: Type of repair action (replace, restart, reimage) that will be used for repairing unhealthy virtual
	// machines in the scale set. Default value is replace.
	RepairAction *AutomaticRepairsPolicy_RepairAction_STATUS `json:"repairAction,omitempty"`
}

var _ genruntime.FromARMConverter = &AutomaticRepairsPolicy_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *AutomaticRepairsPolicy_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AutomaticRepairsPolicy_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *AutomaticRepairsPolicy_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AutomaticRepairsPolicy_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AutomaticRepairsPolicy_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		policy.Enabled = &enabled
	}

	// Set property "GracePeriod":
	if typedInput.GracePeriod != nil {
		gracePeriod := *typedInput.GracePeriod
		policy.GracePeriod = &gracePeriod
	}

	// Set property "RepairAction":
	if typedInput.RepairAction != nil {
		var temp string
		temp = string(*typedInput.RepairAction)
		repairAction := AutomaticRepairsPolicy_RepairAction_STATUS(temp)
		policy.RepairAction = &repairAction
	}

	// No error
	return nil
}

// AssignProperties_From_AutomaticRepairsPolicy_STATUS populates our AutomaticRepairsPolicy_STATUS from the provided source AutomaticRepairsPolicy_STATUS
func (policy *AutomaticRepairsPolicy_STATUS) AssignProperties_From_AutomaticRepairsPolicy_STATUS(source *storage.AutomaticRepairsPolicy_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		policy.Enabled = &enabled
	} else {
		policy.Enabled = nil
	}

	// GracePeriod
	policy.GracePeriod = genruntime.ClonePointerToString(source.GracePeriod)

	// RepairAction
	if source.RepairAction != nil {
		repairAction := *source.RepairAction
		repairActionTemp := genruntime.ToEnum(repairAction, automaticRepairsPolicy_RepairAction_STATUS_Values)
		policy.RepairAction = &repairActionTemp
	} else {
		policy.RepairAction = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AutomaticRepairsPolicy_STATUS populates the provided destination AutomaticRepairsPolicy_STATUS from our AutomaticRepairsPolicy_STATUS
func (policy *AutomaticRepairsPolicy_STATUS) AssignProperties_To_AutomaticRepairsPolicy_STATUS(destination *storage.AutomaticRepairsPolicy_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if policy.Enabled != nil {
		enabled := *policy.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// GracePeriod
	destination.GracePeriod = genruntime.ClonePointerToString(policy.GracePeriod)

	// RepairAction
	if policy.RepairAction != nil {
		repairAction := string(*policy.RepairAction)
		destination.RepairAction = &repairAction
	} else {
		destination.RepairAction = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Specifies the orchestration mode for the virtual machine scale set.
// +kubebuilder:validation:Enum={"Flexible","Uniform"}
type OrchestrationMode string

const (
	OrchestrationMode_Flexible = OrchestrationMode("Flexible")
	OrchestrationMode_Uniform  = OrchestrationMode("Uniform")
)

// Mapping from string to OrchestrationMode
var orchestrationMode_Values = map[string]OrchestrationMode{
	"flexible": OrchestrationMode_Flexible,
	"uniform":  OrchestrationMode_Uniform,
}

// Specifies the orchestration mode for the virtual machine scale set.
type OrchestrationMode_STATUS string

const (
	OrchestrationMode_STATUS_Flexible = OrchestrationMode_STATUS("Flexible")
	OrchestrationMode_STATUS_Uniform  = OrchestrationMode_STATUS("Uniform")
)

// Mapping from string to OrchestrationMode_STATUS
var orchestrationMode_STATUS_Values = map[string]OrchestrationMode_STATUS{
	"flexible": OrchestrationMode_STATUS_Flexible,
	"uniform":  OrchestrationMode_STATUS_Uniform,
}

// Describes a scale-in policy for a virtual machine scale set.
type ScaleInPolicy struct {
	// ForceDeletion: This property allows you to specify if virtual machines chosen for removal have to be force deleted when
	// a virtual machine scale set is being scaled-in.(Feature in Preview)
	ForceDeletion *bool `json:"forceDeletion,omitempty"`

	// Rules: The rules to be followed when scaling-in a virtual machine scale set.
	// Possible values are:
	// Default When a virtual machine scale set is scaled in, the scale set will first be balanced across zones if it is a
	// zonal scale set. Then, it will be balanced across Fault Domains as far as possible. Within each Fault Domain, the
	// virtual machines chosen for removal will be the newest ones that are not protected from scale-in.
	// OldestVM When a virtual machine scale set is being scaled-in, the oldest virtual machines that are not protected from
	// scale-in will be chosen for removal. For zonal virtual machine scale sets, the scale set will first be balanced across
	// zones. Within each zone, the oldest virtual machines that are not protected will be chosen for removal.
	// NewestVM When a virtual machine scale set is being scaled-in, the newest virtual machines that are not protected from
	// scale-in will be chosen for removal. For zonal virtual machine scale sets, the scale set will first be balanced across
	// zones. Within each zone, the newest virtual machines that are not protected will be chosen for removal.
	Rules []ScaleInPolicy_Rules `json:"rules,omitempty"`
}

var _ genruntime.ARMTransformer = &ScaleInPolicy{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *ScaleInPolicy) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	result := &arm.ScaleInPolicy{}

	// Set property "ForceDeletion":
	if policy.ForceDeletion != nil {
		forceDeletion := *policy.ForceDeletion
		result.ForceDeletion = &forceDeletion
	}

	// Set property "Rules":
	for _, item := range policy.Rules {
		var temp string
		temp = string(item)
		result.Rules = append(result.Rules, arm.ScaleInPolicy_Rules(temp))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *ScaleInPolicy) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ScaleInPolicy{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *ScaleInPolicy) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ScaleInPolicy)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ScaleInPolicy, got %T", armInput)
	}

	// Set property "ForceDeletion":
	if typedInput.ForceDeletion != nil {
		forceDeletion := *typedInput.ForceDeletion
		policy.ForceDeletion = &forceDeletion
	}

	// Set property "Rules":
	for _, item := range typedInput.Rules {
		var temp string
		temp = string(item)
		policy.Rules = append(policy.Rules, ScaleInPolicy_Rules(temp))
	}

	// No error
	return nil
}

// AssignProperties_From_ScaleInPolicy populates our ScaleInPolicy from the provided source ScaleInPolicy
func (policy *ScaleInPolicy) AssignProperties_From_ScaleInPolicy(source *storage.ScaleInPolicy) error {

	// ForceDeletion
	if source.ForceDeletion != nil {
		forceDeletion := *source.ForceDeletion
		policy.ForceDeletion = &forceDeletion
	} else {
		policy.ForceDeletion = nil
	}

	// Rules
	if source.Rules != nil {
		ruleList := make([]ScaleInPolicy_Rules, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			ruleList[ruleIndex] = genruntime.ToEnum(ruleItem, scaleInPolicy_Rules_Values)
		}
		policy.Rules = ruleList
	} else {
		policy.Rules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ScaleInPolicy populates the provided destination ScaleInPolicy from our ScaleInPolicy
func (policy *ScaleInPolicy) AssignProperties_To_ScaleInPolicy(destination *storage.ScaleInPolicy) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ForceDeletion
	if policy.ForceDeletion != nil {
		forceDeletion := *policy.ForceDeletion
		destination.ForceDeletion = &forceDeletion
	} else {
		destination.ForceDeletion = nil
	}

	// Rules
	if policy.Rules != nil {
		ruleList := make([]string, len(policy.Rules))
		for ruleIndex, ruleItem := range policy.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			ruleList[ruleIndex] = string(ruleItem)
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ScaleInPolicy_STATUS populates our ScaleInPolicy from the provided source ScaleInPolicy_STATUS
func (policy *ScaleInPolicy) Initialize_From_ScaleInPolicy_STATUS(source *ScaleInPolicy_STATUS) error {

	// ForceDeletion
	if source.ForceDeletion != nil {
		forceDeletion := *source.ForceDeletion
		policy.ForceDeletion = &forceDeletion
	} else {
		policy.ForceDeletion = nil
	}

	// Rules
	if source.Rules != nil {
		ruleList := make([]ScaleInPolicy_Rules, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			rule := genruntime.ToEnum(string(ruleItem), scaleInPolicy_Rules_Values)
			ruleList[ruleIndex] = rule
		}
		policy.Rules = ruleList
	} else {
		policy.Rules = nil
	}

	// No error
	return nil
}

// Describes a scale-in policy for a virtual machine scale set.
type ScaleInPolicy_STATUS struct {
	// ForceDeletion: This property allows you to specify if virtual machines chosen for removal have to be force deleted when
	// a virtual machine scale set is being scaled-in.(Feature in Preview)
	ForceDeletion *bool `json:"forceDeletion,omitempty"`

	// Rules: The rules to be followed when scaling-in a virtual machine scale set.
	// Possible values are:
	// Default When a virtual machine scale set is scaled in, the scale set will first be balanced across zones if it is a
	// zonal scale set. Then, it will be balanced across Fault Domains as far as possible. Within each Fault Domain, the
	// virtual machines chosen for removal will be the newest ones that are not protected from scale-in.
	// OldestVM When a virtual machine scale set is being scaled-in, the oldest virtual machines that are not protected from
	// scale-in will be chosen for removal. For zonal virtual machine scale sets, the scale set will first be balanced across
	// zones. Within each zone, the oldest virtual machines that are not protected will be chosen for removal.
	// NewestVM When a virtual machine scale set is being scaled-in, the newest virtual machines that are not protected from
	// scale-in will be chosen for removal. For zonal virtual machine scale sets, the scale set will first be balanced across
	// zones. Within each zone, the newest virtual machines that are not protected will be chosen for removal.
	Rules []ScaleInPolicy_Rules_STATUS `json:"rules,omitempty"`
}

var _ genruntime.FromARMConverter = &ScaleInPolicy_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *ScaleInPolicy_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ScaleInPolicy_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *ScaleInPolicy_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ScaleInPolicy_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ScaleInPolicy_STATUS, got %T", armInput)
	}

	// Set property "ForceDeletion":
	if typedInput.ForceDeletion != nil {
		forceDeletion := *typedInput.ForceDeletion
		policy.ForceDeletion = &forceDeletion
	}

	// Set property "Rules":
	for _, item := range typedInput.Rules {
		var temp string
		temp = string(item)
		policy.Rules = append(policy.Rules, ScaleInPolicy_Rules_STATUS(temp))
	}

	// No error
	return nil
}

// AssignProperties_From_ScaleInPolicy_STATUS populates our ScaleInPolicy_STATUS from the provided source ScaleInPolicy_STATUS
func (policy *ScaleInPolicy_STATUS) AssignProperties_From_ScaleInPolicy_STATUS(source *storage.ScaleInPolicy_STATUS) error {

	// ForceDeletion
	if source.ForceDeletion != nil {
		forceDeletion := *source.ForceDeletion
		policy.ForceDeletion = &forceDeletion
	} else {
		policy.ForceDeletion = nil
	}

	// Rules
	if source.Rules != nil {
		ruleList := make([]ScaleInPolicy_Rules_STATUS, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			ruleList[ruleIndex] = genruntime.ToEnum(ruleItem, scaleInPolicy_Rules_STATUS_Values)
		}
		policy.Rules = ruleList
	} else {
		policy.Rules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ScaleInPolicy_STATUS populates the provided destination ScaleInPolicy_STATUS from our ScaleInPolicy_STATUS
func (policy *ScaleInPolicy_STATUS) AssignProperties_To_ScaleInPolicy_STATUS(destination *storage.ScaleInPolicy_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ForceDeletion
	if policy.ForceDeletion != nil {
		forceDeletion := *policy.ForceDeletion
		destination.ForceDeletion = &forceDeletion
	} else {
		destination.ForceDeletion = nil
	}

	// Rules
	if policy.Rules != nil {
		ruleList := make([]string, len(policy.Rules))
		for ruleIndex, ruleItem := range policy.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			ruleList[ruleIndex] = string(ruleItem)
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes a virtual machine scale set sku. NOTE: If the new VM SKU is not supported on the hardware the scale set is
// currently on, you need to deallocate the VMs in the scale set before you modify the SKU name.
type Sku struct {
	// Capacity: Specifies the number of virtual machines in the scale set.
	Capacity *int `json:"capacity,omitempty"`

	// Name: The sku name.
	Name *string `json:"name,omitempty"`

	// Tier: Specifies the tier of virtual machines in a scale set.
	// Possible Values:
	// Standard
	// Basic
	Tier *string `json:"tier,omitempty"`
}

var _ genruntime.ARMTransformer = &Sku{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (sku *Sku) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if sku == nil {
		return nil, nil
	}
	result := &arm.Sku{}

	// Set property "Capacity":
	if sku.Capacity != nil {
		capacity := *sku.Capacity
		result.Capacity = &capacity
	}

	// Set property "Name":
	if sku.Name != nil {
		name := *sku.Name
		result.Name = &name
	}

	// Set property "Tier":
	if sku.Tier != nil {
		tier := *sku.Tier
		result.Tier = &tier
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sku *Sku) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Sku{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sku *Sku) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Sku)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Sku, got %T", armInput)
	}

	// Set property "Capacity":
	if typedInput.Capacity != nil {
		capacity := *typedInput.Capacity
		sku.Capacity = &capacity
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		sku.Name = &name
	}

	// Set property "Tier":
	if typedInput.Tier != nil {
		tier := *typedInput.Tier
		sku.Tier = &tier
	}

	// No error
	return nil
}

// AssignProperties_From_Sku populates our Sku from the provided source Sku
func (sku *Sku) AssignProperties_From_Sku(source *storage.Sku) error {

	// Capacity
	sku.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Name
	sku.Name = genruntime.ClonePointerToString(source.Name)

	// Tier
	sku.Tier = genruntime.ClonePointerToString(source.Tier)

	// No error
	return nil
}

// AssignProperties_To_Sku populates the provided destination Sku from our Sku
func (sku *Sku) AssignProperties_To_Sku(destination *storage.Sku) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Capacity
	destination.Capacity = genruntime.ClonePointerToInt(sku.Capacity)

	// Name
	destination.Name = genruntime.ClonePointerToString(sku.Name)

	// Tier
	destination.Tier = genruntime.ClonePointerToString(sku.Tier)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Sku_STATUS populates our Sku from the provided source Sku_STATUS
func (sku *Sku) Initialize_From_Sku_STATUS(source *Sku_STATUS) error {

	// Capacity
	sku.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Name
	sku.Name = genruntime.ClonePointerToString(source.Name)

	// Tier
	sku.Tier = genruntime.ClonePointerToString(source.Tier)

	// No error
	return nil
}

// Describes a virtual machine scale set sku. NOTE: If the new VM SKU is not supported on the hardware the scale set is
// currently on, you need to deallocate the VMs in the scale set before you modify the SKU name.
type Sku_STATUS struct {
	// Capacity: Specifies the number of virtual machines in the scale set.
	Capacity *int `json:"capacity,omitempty"`

	// Name: The sku name.
	Name *string `json:"name,omitempty"`

	// Tier: Specifies the tier of virtual machines in a scale set.
	// Possible Values:
	// Standard
	// Basic
	Tier *string `json:"tier,omitempty"`
}

var _ genruntime.FromARMConverter = &Sku_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sku *Sku_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Sku_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sku *Sku_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Sku_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Sku_STATUS, got %T", armInput)
	}

	// Set property "Capacity":
	if typedInput.Capacity != nil {
		capacity := *typedInput.Capacity
		sku.Capacity = &capacity
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		sku.Name = &name
	}

	// Set property "Tier":
	if typedInput.Tier != nil {
		tier := *typedInput.Tier
		sku.Tier = &tier
	}

	// No error
	return nil
}

// AssignProperties_From_Sku_STATUS populates our Sku_STATUS from the provided source Sku_STATUS
func (sku *Sku_STATUS) AssignProperties_From_Sku_STATUS(source *storage.Sku_STATUS) error {

	// Capacity
	sku.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Name
	sku.Name = genruntime.ClonePointerToString(source.Name)

	// Tier
	sku.Tier = genruntime.ClonePointerToString(source.Tier)

	// No error
	return nil
}

// AssignProperties_To_Sku_STATUS populates the provided destination Sku_STATUS from our Sku_STATUS
func (sku *Sku_STATUS) AssignProperties_To_Sku_STATUS(destination *storage.Sku_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Capacity
	destination.Capacity = genruntime.ClonePointerToInt(sku.Capacity)

	// Name
	destination.Name = genruntime.ClonePointerToString(sku.Name)

	// Tier
	destination.Tier = genruntime.ClonePointerToString(sku.Tier)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Specifies the Spot-Try-Restore properties for the virtual machine scale set.
// With this property customer can
// enable or disable automatic restore of the evicted Spot VMSS VM instances opportunistically based on capacity
// availability and pricing constraint.
type SpotRestorePolicy struct {
	// Enabled: Enables the Spot-Try-Restore feature where evicted VMSS SPOT instances will be tried to be restored
	// opportunistically based on capacity availability and pricing constraints
	Enabled *bool `json:"enabled,omitempty"`

	// RestoreTimeout: Timeout value expressed as an ISO 8601 time duration after which the platform will not try to restore
	// the VMSS SPOT instances
	RestoreTimeout *string `json:"restoreTimeout,omitempty"`
}

var _ genruntime.ARMTransformer = &SpotRestorePolicy{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *SpotRestorePolicy) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	result := &arm.SpotRestorePolicy{}

	// Set property "Enabled":
	if policy.Enabled != nil {
		enabled := *policy.Enabled
		result.Enabled = &enabled
	}

	// Set property "RestoreTimeout":
	if policy.RestoreTimeout != nil {
		restoreTimeout := *policy.RestoreTimeout
		result.RestoreTimeout = &restoreTimeout
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *SpotRestorePolicy) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SpotRestorePolicy{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *SpotRestorePolicy) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SpotRestorePolicy)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SpotRestorePolicy, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		policy.Enabled = &enabled
	}

	// Set property "RestoreTimeout":
	if typedInput.RestoreTimeout != nil {
		restoreTimeout := *typedInput.RestoreTimeout
		policy.RestoreTimeout = &restoreTimeout
	}

	// No error
	return nil
}

// AssignProperties_From_SpotRestorePolicy populates our SpotRestorePolicy from the provided source SpotRestorePolicy
func (policy *SpotRestorePolicy) AssignProperties_From_SpotRestorePolicy(source *storage.SpotRestorePolicy) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		policy.Enabled = &enabled
	} else {
		policy.Enabled = nil
	}

	// RestoreTimeout
	policy.RestoreTimeout = genruntime.ClonePointerToString(source.RestoreTimeout)

	// No error
	return nil
}

// AssignProperties_To_SpotRestorePolicy populates the provided destination SpotRestorePolicy from our SpotRestorePolicy
func (policy *SpotRestorePolicy) AssignProperties_To_SpotRestorePolicy(destination *storage.SpotRestorePolicy) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if policy.Enabled != nil {
		enabled := *policy.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// RestoreTimeout
	destination.RestoreTimeout = genruntime.ClonePointerToString(policy.RestoreTimeout)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_SpotRestorePolicy_STATUS populates our SpotRestorePolicy from the provided source SpotRestorePolicy_STATUS
func (policy *SpotRestorePolicy) Initialize_From_SpotRestorePolicy_STATUS(source *SpotRestorePolicy_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		policy.Enabled = &enabled
	} else {
		policy.Enabled = nil
	}

	// RestoreTimeout
	policy.RestoreTimeout = genruntime.ClonePointerToString(source.RestoreTimeout)

	// No error
	return nil
}

// Specifies the Spot-Try-Restore properties for the virtual machine scale set.
// With this property customer can
// enable or disable automatic restore of the evicted Spot VMSS VM instances opportunistically based on capacity
// availability and pricing constraint.
type SpotRestorePolicy_STATUS struct {
	// Enabled: Enables the Spot-Try-Restore feature where evicted VMSS SPOT instances will be tried to be restored
	// opportunistically based on capacity availability and pricing constraints
	Enabled *bool `json:"enabled,omitempty"`

	// RestoreTimeout: Timeout value expressed as an ISO 8601 time duration after which the platform will not try to restore
	// the VMSS SPOT instances
	RestoreTimeout *string `json:"restoreTimeout,omitempty"`
}

var _ genruntime.FromARMConverter = &SpotRestorePolicy_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *SpotRestorePolicy_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SpotRestorePolicy_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *SpotRestorePolicy_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SpotRestorePolicy_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SpotRestorePolicy_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		policy.Enabled = &enabled
	}

	// Set property "RestoreTimeout":
	if typedInput.RestoreTimeout != nil {
		restoreTimeout := *typedInput.RestoreTimeout
		policy.RestoreTimeout = &restoreTimeout
	}

	// No error
	return nil
}

// AssignProperties_From_SpotRestorePolicy_STATUS populates our SpotRestorePolicy_STATUS from the provided source SpotRestorePolicy_STATUS
func (policy *SpotRestorePolicy_STATUS) AssignProperties_From_SpotRestorePolicy_STATUS(source *storage.SpotRestorePolicy_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		policy.Enabled = &enabled
	} else {
		policy.Enabled = nil
	}

	// RestoreTimeout
	policy.RestoreTimeout = genruntime.ClonePointerToString(source.RestoreTimeout)

	// No error
	return nil
}

// AssignProperties_To_SpotRestorePolicy_STATUS populates the provided destination SpotRestorePolicy_STATUS from our SpotRestorePolicy_STATUS
func (policy *SpotRestorePolicy_STATUS) AssignProperties_To_SpotRestorePolicy_STATUS(destination *storage.SpotRestorePolicy_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if policy.Enabled != nil {
		enabled := *policy.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// RestoreTimeout
	destination.RestoreTimeout = genruntime.ClonePointerToString(policy.RestoreTimeout)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes an upgrade policy - automatic, manual, or rolling.
type UpgradePolicy struct {
	// AutomaticOSUpgradePolicy: Configuration parameters used for performing automatic OS Upgrade.
	AutomaticOSUpgradePolicy *AutomaticOSUpgradePolicy `json:"automaticOSUpgradePolicy,omitempty"`

	// Mode: Specifies the mode of an upgrade to virtual machines in the scale set.
	// Possible values are:
	// Manual - You  control the application of updates to virtual machines in the scale set. You do this by using the
	// manualUpgrade action.
	// Automatic - All virtual machines in the scale set are  automatically updated at the same time.
	Mode *UpgradePolicy_Mode `json:"mode,omitempty"`

	// RollingUpgradePolicy: The configuration parameters used while performing a rolling upgrade.
	RollingUpgradePolicy *RollingUpgradePolicy `json:"rollingUpgradePolicy,omitempty"`
}

var _ genruntime.ARMTransformer = &UpgradePolicy{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *UpgradePolicy) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	result := &arm.UpgradePolicy{}

	// Set property "AutomaticOSUpgradePolicy":
	if policy.AutomaticOSUpgradePolicy != nil {
		automaticOSUpgradePolicy_ARM, err := (*policy.AutomaticOSUpgradePolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		automaticOSUpgradePolicy := *automaticOSUpgradePolicy_ARM.(*arm.AutomaticOSUpgradePolicy)
		result.AutomaticOSUpgradePolicy = &automaticOSUpgradePolicy
	}

	// Set property "Mode":
	if policy.Mode != nil {
		var temp string
		temp = string(*policy.Mode)
		mode := arm.UpgradePolicy_Mode(temp)
		result.Mode = &mode
	}

	// Set property "RollingUpgradePolicy":
	if policy.RollingUpgradePolicy != nil {
		rollingUpgradePolicy_ARM, err := (*policy.RollingUpgradePolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		rollingUpgradePolicy := *rollingUpgradePolicy_ARM.(*arm.RollingUpgradePolicy)
		result.RollingUpgradePolicy = &rollingUpgradePolicy
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *UpgradePolicy) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UpgradePolicy{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *UpgradePolicy) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UpgradePolicy)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UpgradePolicy, got %T", armInput)
	}

	// Set property "AutomaticOSUpgradePolicy":
	if typedInput.AutomaticOSUpgradePolicy != nil {
		var automaticOSUpgradePolicy1 AutomaticOSUpgradePolicy
		err := automaticOSUpgradePolicy1.PopulateFromARM(owner, *typedInput.AutomaticOSUpgradePolicy)
		if err != nil {
			return err
		}
		automaticOSUpgradePolicy := automaticOSUpgradePolicy1
		policy.AutomaticOSUpgradePolicy = &automaticOSUpgradePolicy
	}

	// Set property "Mode":
	if typedInput.Mode != nil {
		var temp string
		temp = string(*typedInput.Mode)
		mode := UpgradePolicy_Mode(temp)
		policy.Mode = &mode
	}

	// Set property "RollingUpgradePolicy":
	if typedInput.RollingUpgradePolicy != nil {
		var rollingUpgradePolicy1 RollingUpgradePolicy
		err := rollingUpgradePolicy1.PopulateFromARM(owner, *typedInput.RollingUpgradePolicy)
		if err != nil {
			return err
		}
		rollingUpgradePolicy := rollingUpgradePolicy1
		policy.RollingUpgradePolicy = &rollingUpgradePolicy
	}

	// No error
	return nil
}

// AssignProperties_From_UpgradePolicy populates our UpgradePolicy from the provided source UpgradePolicy
func (policy *UpgradePolicy) AssignProperties_From_UpgradePolicy(source *storage.UpgradePolicy) error {

	// AutomaticOSUpgradePolicy
	if source.AutomaticOSUpgradePolicy != nil {
		var automaticOSUpgradePolicy AutomaticOSUpgradePolicy
		err := automaticOSUpgradePolicy.AssignProperties_From_AutomaticOSUpgradePolicy(source.AutomaticOSUpgradePolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AutomaticOSUpgradePolicy() to populate field AutomaticOSUpgradePolicy")
		}
		policy.AutomaticOSUpgradePolicy = &automaticOSUpgradePolicy
	} else {
		policy.AutomaticOSUpgradePolicy = nil
	}

	// Mode
	if source.Mode != nil {
		mode := *source.Mode
		modeTemp := genruntime.ToEnum(mode, upgradePolicy_Mode_Values)
		policy.Mode = &modeTemp
	} else {
		policy.Mode = nil
	}

	// RollingUpgradePolicy
	if source.RollingUpgradePolicy != nil {
		var rollingUpgradePolicy RollingUpgradePolicy
		err := rollingUpgradePolicy.AssignProperties_From_RollingUpgradePolicy(source.RollingUpgradePolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_RollingUpgradePolicy() to populate field RollingUpgradePolicy")
		}
		policy.RollingUpgradePolicy = &rollingUpgradePolicy
	} else {
		policy.RollingUpgradePolicy = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UpgradePolicy populates the provided destination UpgradePolicy from our UpgradePolicy
func (policy *UpgradePolicy) AssignProperties_To_UpgradePolicy(destination *storage.UpgradePolicy) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AutomaticOSUpgradePolicy
	if policy.AutomaticOSUpgradePolicy != nil {
		var automaticOSUpgradePolicy storage.AutomaticOSUpgradePolicy
		err := policy.AutomaticOSUpgradePolicy.AssignProperties_To_AutomaticOSUpgradePolicy(&automaticOSUpgradePolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AutomaticOSUpgradePolicy() to populate field AutomaticOSUpgradePolicy")
		}
		destination.AutomaticOSUpgradePolicy = &automaticOSUpgradePolicy
	} else {
		destination.AutomaticOSUpgradePolicy = nil
	}

	// Mode
	if policy.Mode != nil {
		mode := string(*policy.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// RollingUpgradePolicy
	if policy.RollingUpgradePolicy != nil {
		var rollingUpgradePolicy storage.RollingUpgradePolicy
		err := policy.RollingUpgradePolicy.AssignProperties_To_RollingUpgradePolicy(&rollingUpgradePolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_RollingUpgradePolicy() to populate field RollingUpgradePolicy")
		}
		destination.RollingUpgradePolicy = &rollingUpgradePolicy
	} else {
		destination.RollingUpgradePolicy = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_UpgradePolicy_STATUS populates our UpgradePolicy from the provided source UpgradePolicy_STATUS
func (policy *UpgradePolicy) Initialize_From_UpgradePolicy_STATUS(source *UpgradePolicy_STATUS) error {

	// AutomaticOSUpgradePolicy
	if source.AutomaticOSUpgradePolicy != nil {
		var automaticOSUpgradePolicy AutomaticOSUpgradePolicy
		err := automaticOSUpgradePolicy.Initialize_From_AutomaticOSUpgradePolicy_STATUS(source.AutomaticOSUpgradePolicy)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_AutomaticOSUpgradePolicy_STATUS() to populate field AutomaticOSUpgradePolicy")
		}
		policy.AutomaticOSUpgradePolicy = &automaticOSUpgradePolicy
	} else {
		policy.AutomaticOSUpgradePolicy = nil
	}

	// Mode
	if source.Mode != nil {
		mode := genruntime.ToEnum(string(*source.Mode), upgradePolicy_Mode_Values)
		policy.Mode = &mode
	} else {
		policy.Mode = nil
	}

	// RollingUpgradePolicy
	if source.RollingUpgradePolicy != nil {
		var rollingUpgradePolicy RollingUpgradePolicy
		err := rollingUpgradePolicy.Initialize_From_RollingUpgradePolicy_STATUS(source.RollingUpgradePolicy)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_RollingUpgradePolicy_STATUS() to populate field RollingUpgradePolicy")
		}
		policy.RollingUpgradePolicy = &rollingUpgradePolicy
	} else {
		policy.RollingUpgradePolicy = nil
	}

	// No error
	return nil
}

// Describes an upgrade policy - automatic, manual, or rolling.
type UpgradePolicy_STATUS struct {
	// AutomaticOSUpgradePolicy: Configuration parameters used for performing automatic OS Upgrade.
	AutomaticOSUpgradePolicy *AutomaticOSUpgradePolicy_STATUS `json:"automaticOSUpgradePolicy,omitempty"`

	// Mode: Specifies the mode of an upgrade to virtual machines in the scale set.
	// Possible values are:
	// Manual - You  control the application of updates to virtual machines in the scale set. You do this by using the
	// manualUpgrade action.
	// Automatic - All virtual machines in the scale set are  automatically updated at the same time.
	Mode *UpgradePolicy_Mode_STATUS `json:"mode,omitempty"`

	// RollingUpgradePolicy: The configuration parameters used while performing a rolling upgrade.
	RollingUpgradePolicy *RollingUpgradePolicy_STATUS `json:"rollingUpgradePolicy,omitempty"`
}

var _ genruntime.FromARMConverter = &UpgradePolicy_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *UpgradePolicy_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UpgradePolicy_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *UpgradePolicy_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UpgradePolicy_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UpgradePolicy_STATUS, got %T", armInput)
	}

	// Set property "AutomaticOSUpgradePolicy":
	if typedInput.AutomaticOSUpgradePolicy != nil {
		var automaticOSUpgradePolicy1 AutomaticOSUpgradePolicy_STATUS
		err := automaticOSUpgradePolicy1.PopulateFromARM(owner, *typedInput.AutomaticOSUpgradePolicy)
		if err != nil {
			return err
		}
		automaticOSUpgradePolicy := automaticOSUpgradePolicy1
		policy.AutomaticOSUpgradePolicy = &automaticOSUpgradePolicy
	}

	// Set property "Mode":
	if typedInput.Mode != nil {
		var temp string
		temp = string(*typedInput.Mode)
		mode := UpgradePolicy_Mode_STATUS(temp)
		policy.Mode = &mode
	}

	// Set property "RollingUpgradePolicy":
	if typedInput.RollingUpgradePolicy != nil {
		var rollingUpgradePolicy1 RollingUpgradePolicy_STATUS
		err := rollingUpgradePolicy1.PopulateFromARM(owner, *typedInput.RollingUpgradePolicy)
		if err != nil {
			return err
		}
		rollingUpgradePolicy := rollingUpgradePolicy1
		policy.RollingUpgradePolicy = &rollingUpgradePolicy
	}

	// No error
	return nil
}

// AssignProperties_From_UpgradePolicy_STATUS populates our UpgradePolicy_STATUS from the provided source UpgradePolicy_STATUS
func (policy *UpgradePolicy_STATUS) AssignProperties_From_UpgradePolicy_STATUS(source *storage.UpgradePolicy_STATUS) error {

	// AutomaticOSUpgradePolicy
	if source.AutomaticOSUpgradePolicy != nil {
		var automaticOSUpgradePolicy AutomaticOSUpgradePolicy_STATUS
		err := automaticOSUpgradePolicy.AssignProperties_From_AutomaticOSUpgradePolicy_STATUS(source.AutomaticOSUpgradePolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AutomaticOSUpgradePolicy_STATUS() to populate field AutomaticOSUpgradePolicy")
		}
		policy.AutomaticOSUpgradePolicy = &automaticOSUpgradePolicy
	} else {
		policy.AutomaticOSUpgradePolicy = nil
	}

	// Mode
	if source.Mode != nil {
		mode := *source.Mode
		modeTemp := genruntime.ToEnum(mode, upgradePolicy_Mode_STATUS_Values)
		policy.Mode = &modeTemp
	} else {
		policy.Mode = nil
	}

	// RollingUpgradePolicy
	if source.RollingUpgradePolicy != nil {
		var rollingUpgradePolicy RollingUpgradePolicy_STATUS
		err := rollingUpgradePolicy.AssignProperties_From_RollingUpgradePolicy_STATUS(source.RollingUpgradePolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_RollingUpgradePolicy_STATUS() to populate field RollingUpgradePolicy")
		}
		policy.RollingUpgradePolicy = &rollingUpgradePolicy
	} else {
		policy.RollingUpgradePolicy = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UpgradePolicy_STATUS populates the provided destination UpgradePolicy_STATUS from our UpgradePolicy_STATUS
func (policy *UpgradePolicy_STATUS) AssignProperties_To_UpgradePolicy_STATUS(destination *storage.UpgradePolicy_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AutomaticOSUpgradePolicy
	if policy.AutomaticOSUpgradePolicy != nil {
		var automaticOSUpgradePolicy storage.AutomaticOSUpgradePolicy_STATUS
		err := policy.AutomaticOSUpgradePolicy.AssignProperties_To_AutomaticOSUpgradePolicy_STATUS(&automaticOSUpgradePolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AutomaticOSUpgradePolicy_STATUS() to populate field AutomaticOSUpgradePolicy")
		}
		destination.AutomaticOSUpgradePolicy = &automaticOSUpgradePolicy
	} else {
		destination.AutomaticOSUpgradePolicy = nil
	}

	// Mode
	if policy.Mode != nil {
		mode := string(*policy.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// RollingUpgradePolicy
	if policy.RollingUpgradePolicy != nil {
		var rollingUpgradePolicy storage.RollingUpgradePolicy_STATUS
		err := policy.RollingUpgradePolicy.AssignProperties_To_RollingUpgradePolicy_STATUS(&rollingUpgradePolicy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_RollingUpgradePolicy_STATUS() to populate field RollingUpgradePolicy")
		}
		destination.RollingUpgradePolicy = &rollingUpgradePolicy
	} else {
		destination.RollingUpgradePolicy = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Identity for the virtual machine scale set.
type VirtualMachineScaleSetIdentity struct {
	// Type: The type of identity used for the virtual machine scale set. The type 'SystemAssigned, UserAssigned' includes both
	// an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from
	// the virtual machine scale set.
	Type *VirtualMachineScaleSetIdentity_Type `json:"type,omitempty"`

	// UserAssignedIdentities: The list of user identities associated with the virtual machine scale set. The user identity
	// dictionary key references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities []UserAssignedIdentityDetails `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *VirtualMachineScaleSetIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &arm.VirtualMachineScaleSetIdentity{}

	// Set property "Type":
	if identity.Type != nil {
		var temp string
		temp = string(*identity.Type)
		typeVar := arm.VirtualMachineScaleSetIdentity_Type(temp)
		result.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	result.UserAssignedIdentities = make(map[string]arm.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
	for _, ident := range identity.UserAssignedIdentities {
		identARMID, err := resolved.ResolvedReferences.Lookup(ident.Reference)
		if err != nil {
			return nil, err
		}
		key := identARMID
		result.UserAssignedIdentities[key] = arm.UserAssignedIdentityDetails{}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *VirtualMachineScaleSetIdentity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSetIdentity{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *VirtualMachineScaleSetIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSetIdentity)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSetIdentity, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := VirtualMachineScaleSetIdentity_Type(temp)
		identity.Type = &typeVar
	}

	// no assignment for property "UserAssignedIdentities"

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSetIdentity populates our VirtualMachineScaleSetIdentity from the provided source VirtualMachineScaleSetIdentity
func (identity *VirtualMachineScaleSetIdentity) AssignProperties_From_VirtualMachineScaleSetIdentity(source *storage.VirtualMachineScaleSetIdentity) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, virtualMachineScaleSetIdentity_Type_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, len(source.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity UserAssignedIdentityDetails
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentityDetails(&userAssignedIdentityItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetIdentity populates the provided destination VirtualMachineScaleSetIdentity from our VirtualMachineScaleSetIdentity
func (identity *VirtualMachineScaleSetIdentity) AssignProperties_To_VirtualMachineScaleSetIdentity(destination *storage.VirtualMachineScaleSetIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]storage.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity storage.UserAssignedIdentityDetails
			err := userAssignedIdentityItem.AssignProperties_To_UserAssignedIdentityDetails(&userAssignedIdentity)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityList
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualMachineScaleSetIdentity_STATUS populates our VirtualMachineScaleSetIdentity from the provided source VirtualMachineScaleSetIdentity_STATUS
func (identity *VirtualMachineScaleSetIdentity) Initialize_From_VirtualMachineScaleSetIdentity_STATUS(source *VirtualMachineScaleSetIdentity_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := genruntime.ToEnum(string(*source.Type), virtualMachineScaleSetIdentity_Type_Values)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, 0, len(source.UserAssignedIdentities))
		for userAssignedIdentitiesKey := range source.UserAssignedIdentities {
			userAssignedIdentitiesRef := genruntime.CreateResourceReferenceFromARMID(userAssignedIdentitiesKey)
			userAssignedIdentityList = append(userAssignedIdentityList, UserAssignedIdentityDetails{Reference: userAssignedIdentitiesRef})
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// Identity for the virtual machine scale set.
type VirtualMachineScaleSetIdentity_STATUS struct {
	// PrincipalId: The principal id of virtual machine scale set identity. This property will only be provided for a system
	// assigned identity.
	PrincipalId *string `json:"principalId,omitempty"`

	// TenantId: The tenant id associated with the virtual machine scale set. This property will only be provided for a system
	// assigned identity.
	TenantId *string `json:"tenantId,omitempty"`

	// Type: The type of identity used for the virtual machine scale set. The type 'SystemAssigned, UserAssigned' includes both
	// an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from
	// the virtual machine scale set.
	Type *VirtualMachineScaleSetIdentity_Type_STATUS `json:"type,omitempty"`

	// UserAssignedIdentities: The list of user identities associated with the virtual machine scale set. The user identity
	// dictionary key references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities map[string]VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *VirtualMachineScaleSetIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSetIdentity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *VirtualMachineScaleSetIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSetIdentity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSetIdentity_STATUS, got %T", armInput)
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		identity.TenantId = &tenantId
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := VirtualMachineScaleSetIdentity_Type_STATUS(temp)
		identity.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	if typedInput.UserAssignedIdentities != nil {
		identity.UserAssignedIdentities = make(map[string]VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS, len(typedInput.UserAssignedIdentities))
		for key, value := range typedInput.UserAssignedIdentities {
			var value1 VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			identity.UserAssignedIdentities[key] = value1
		}
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSetIdentity_STATUS populates our VirtualMachineScaleSetIdentity_STATUS from the provided source VirtualMachineScaleSetIdentity_STATUS
func (identity *VirtualMachineScaleSetIdentity_STATUS) AssignProperties_From_VirtualMachineScaleSetIdentity_STATUS(source *storage.VirtualMachineScaleSetIdentity_STATUS) error {

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, virtualMachineScaleSetIdentity_Type_STATUS_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS
			err := userAssignedIdentity.AssignProperties_From_VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS(&userAssignedIdentityValue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetIdentity_STATUS populates the provided destination VirtualMachineScaleSetIdentity_STATUS from our VirtualMachineScaleSetIdentity_STATUS
func (identity *VirtualMachineScaleSetIdentity_STATUS) AssignProperties_To_VirtualMachineScaleSetIdentity_STATUS(destination *storage.VirtualMachineScaleSetIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]storage.VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS, len(identity.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity storage.VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS
			err := userAssignedIdentityValue.AssignProperties_To_VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS(&userAssignedIdentity)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type VirtualMachineScaleSetOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_VirtualMachineScaleSetOperatorSpec populates our VirtualMachineScaleSetOperatorSpec from the provided source VirtualMachineScaleSetOperatorSpec
func (operator *VirtualMachineScaleSetOperatorSpec) AssignProperties_From_VirtualMachineScaleSetOperatorSpec(source *storage.VirtualMachineScaleSetOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetOperatorSpec populates the provided destination VirtualMachineScaleSetOperatorSpec from our VirtualMachineScaleSetOperatorSpec
func (operator *VirtualMachineScaleSetOperatorSpec) AssignProperties_To_VirtualMachineScaleSetOperatorSpec(destination *storage.VirtualMachineScaleSetOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes a virtual machine scale set virtual machine profile.
type VirtualMachineScaleSetVMProfile struct {
	// ApplicationProfile: Specifies the gallery applications that should be made available to the VM/VMSS
	ApplicationProfile *ApplicationProfile `json:"applicationProfile,omitempty"`

	// BillingProfile: Specifies the billing related details of a Azure Spot VMSS.
	// Minimum api-version: 2019-03-01.
	BillingProfile *BillingProfile `json:"billingProfile,omitempty"`

	// CapacityReservation: Specifies the capacity reservation related details of a scale set.
	// Minimum api-version: 2021-04-01.
	CapacityReservation *CapacityReservationProfile `json:"capacityReservation,omitempty"`

	// DiagnosticsProfile: Specifies the boot diagnostic settings state.
	// Minimum api-version: 2015-06-15.
	DiagnosticsProfile *DiagnosticsProfile `json:"diagnosticsProfile,omitempty"`

	// EvictionPolicy: Specifies the eviction policy for the Azure Spot virtual machine and Azure Spot scale set.
	// For Azure Spot virtual machines, both 'Deallocate' and 'Delete' are supported and the minimum api-version is 2019-03-01.
	// For Azure Spot scale sets, both 'Deallocate' and 'Delete' are supported and the minimum api-version is
	// 2017-10-30-preview.
	EvictionPolicy *EvictionPolicy `json:"evictionPolicy,omitempty"`

	// ExtensionProfile: Specifies a collection of settings for extensions installed on virtual machines in the scale set.
	ExtensionProfile *VirtualMachineScaleSetExtensionProfile `json:"extensionProfile,omitempty"`

	// HardwareProfile: Specifies the hardware profile related details of a scale set.
	// Minimum api-version: 2022-03-01.
	HardwareProfile *VirtualMachineScaleSetHardwareProfile `json:"hardwareProfile,omitempty"`

	// LicenseType: Specifies that the image or disk that is being used was licensed on-premises.
	// Possible values for Windows Server operating system are:
	// Windows_Client
	// Windows_Server
	// Possible values for Linux Server operating system are:
	// RHEL_BYOS (for RHEL)
	// SLES_BYOS (for SUSE)
	// For more information, see [Azure Hybrid Use Benefit for Windows
	// Server](https://docs.microsoft.com/azure/virtual-machines/windows/hybrid-use-benefit-licensing)
	// [Azure Hybrid Use Benefit for Linux
	// Server](https://docs.microsoft.com/azure/virtual-machines/linux/azure-hybrid-benefit-linux)
	// Minimum api-version: 2015-06-15
	LicenseType *string `json:"licenseType,omitempty"`

	// NetworkProfile: Specifies properties of the network interfaces of the virtual machines in the scale set.
	NetworkProfile *VirtualMachineScaleSetNetworkProfile `json:"networkProfile,omitempty"`

	// OsProfile: Specifies the operating system settings for the virtual machines in the scale set.
	OsProfile *VirtualMachineScaleSetOSProfile `json:"osProfile,omitempty"`

	// Priority: Specifies the priority for the virtual machines in the scale set.
	// Minimum api-version: 2017-10-30-preview
	Priority *Priority `json:"priority,omitempty"`

	// ScheduledEventsProfile: Specifies Scheduled Event related configurations.
	ScheduledEventsProfile *ScheduledEventsProfile `json:"scheduledEventsProfile,omitempty"`

	// SecurityProfile: Specifies the Security related profile settings for the virtual machines in the scale set.
	SecurityProfile *SecurityProfile `json:"securityProfile,omitempty"`

	// StorageProfile: Specifies the storage settings for the virtual machine disks.
	StorageProfile *VirtualMachineScaleSetStorageProfile `json:"storageProfile,omitempty"`

	// UserData: UserData for the virtual machines in the scale set, which must be base-64 encoded. Customer should not pass
	// any secrets in here.
	// Minimum api-version: 2021-03-01
	UserData *string `json:"userData,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetVMProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *VirtualMachineScaleSetVMProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.VirtualMachineScaleSetVMProfile{}

	// Set property "ApplicationProfile":
	if profile.ApplicationProfile != nil {
		applicationProfile_ARM, err := (*profile.ApplicationProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		applicationProfile := *applicationProfile_ARM.(*arm.ApplicationProfile)
		result.ApplicationProfile = &applicationProfile
	}

	// Set property "BillingProfile":
	if profile.BillingProfile != nil {
		billingProfile_ARM, err := (*profile.BillingProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		billingProfile := *billingProfile_ARM.(*arm.BillingProfile)
		result.BillingProfile = &billingProfile
	}

	// Set property "CapacityReservation":
	if profile.CapacityReservation != nil {
		capacityReservation_ARM, err := (*profile.CapacityReservation).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		capacityReservation := *capacityReservation_ARM.(*arm.CapacityReservationProfile)
		result.CapacityReservation = &capacityReservation
	}

	// Set property "DiagnosticsProfile":
	if profile.DiagnosticsProfile != nil {
		diagnosticsProfile_ARM, err := (*profile.DiagnosticsProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		diagnosticsProfile := *diagnosticsProfile_ARM.(*arm.DiagnosticsProfile)
		result.DiagnosticsProfile = &diagnosticsProfile
	}

	// Set property "EvictionPolicy":
	if profile.EvictionPolicy != nil {
		var temp string
		temp = string(*profile.EvictionPolicy)
		evictionPolicy := arm.EvictionPolicy(temp)
		result.EvictionPolicy = &evictionPolicy
	}

	// Set property "ExtensionProfile":
	if profile.ExtensionProfile != nil {
		extensionProfile_ARM, err := (*profile.ExtensionProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		extensionProfile := *extensionProfile_ARM.(*arm.VirtualMachineScaleSetExtensionProfile)
		result.ExtensionProfile = &extensionProfile
	}

	// Set property "HardwareProfile":
	if profile.HardwareProfile != nil {
		hardwareProfile_ARM, err := (*profile.HardwareProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		hardwareProfile := *hardwareProfile_ARM.(*arm.VirtualMachineScaleSetHardwareProfile)
		result.HardwareProfile = &hardwareProfile
	}

	// Set property "LicenseType":
	if profile.LicenseType != nil {
		licenseType := *profile.LicenseType
		result.LicenseType = &licenseType
	}

	// Set property "NetworkProfile":
	if profile.NetworkProfile != nil {
		networkProfile_ARM, err := (*profile.NetworkProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		networkProfile := *networkProfile_ARM.(*arm.VirtualMachineScaleSetNetworkProfile)
		result.NetworkProfile = &networkProfile
	}

	// Set property "OsProfile":
	if profile.OsProfile != nil {
		osProfile_ARM, err := (*profile.OsProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		osProfile := *osProfile_ARM.(*arm.VirtualMachineScaleSetOSProfile)
		result.OsProfile = &osProfile
	}

	// Set property "Priority":
	if profile.Priority != nil {
		var temp string
		temp = string(*profile.Priority)
		priority := arm.Priority(temp)
		result.Priority = &priority
	}

	// Set property "ScheduledEventsProfile":
	if profile.ScheduledEventsProfile != nil {
		scheduledEventsProfile_ARM, err := (*profile.ScheduledEventsProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		scheduledEventsProfile := *scheduledEventsProfile_ARM.(*arm.ScheduledEventsProfile)
		result.ScheduledEventsProfile = &scheduledEventsProfile
	}

	// Set property "SecurityProfile":
	if profile.SecurityProfile != nil {
		securityProfile_ARM, err := (*profile.SecurityProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		securityProfile := *securityProfile_ARM.(*arm.SecurityProfile)
		result.SecurityProfile = &securityProfile
	}

	// Set property "StorageProfile":
	if profile.StorageProfile != nil {
		storageProfile_ARM, err := (*profile.StorageProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		storageProfile := *storageProfile_ARM.(*arm.VirtualMachineScaleSetStorageProfile)
		result.StorageProfile = &storageProfile
	}

	// Set property "UserData":
	if profile.UserData != nil {
		userData := *profile.UserData
		result.UserData = &userData
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSetVMProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSetVMProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSetVMProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSetVMProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSetVMProfile, got %T", armInput)
	}

	// Set property "ApplicationProfile":
	if typedInput.ApplicationProfile != nil {
		var applicationProfile1 ApplicationProfile
		err := applicationProfile1.PopulateFromARM(owner, *typedInput.ApplicationProfile)
		if err != nil {
			return err
		}
		applicationProfile := applicationProfile1
		profile.ApplicationProfile = &applicationProfile
	}

	// Set property "BillingProfile":
	if typedInput.BillingProfile != nil {
		var billingProfile1 BillingProfile
		err := billingProfile1.PopulateFromARM(owner, *typedInput.BillingProfile)
		if err != nil {
			return err
		}
		billingProfile := billingProfile1
		profile.BillingProfile = &billingProfile
	}

	// Set property "CapacityReservation":
	if typedInput.CapacityReservation != nil {
		var capacityReservation1 CapacityReservationProfile
		err := capacityReservation1.PopulateFromARM(owner, *typedInput.CapacityReservation)
		if err != nil {
			return err
		}
		capacityReservation := capacityReservation1
		profile.CapacityReservation = &capacityReservation
	}

	// Set property "DiagnosticsProfile":
	if typedInput.DiagnosticsProfile != nil {
		var diagnosticsProfile1 DiagnosticsProfile
		err := diagnosticsProfile1.PopulateFromARM(owner, *typedInput.DiagnosticsProfile)
		if err != nil {
			return err
		}
		diagnosticsProfile := diagnosticsProfile1
		profile.DiagnosticsProfile = &diagnosticsProfile
	}

	// Set property "EvictionPolicy":
	if typedInput.EvictionPolicy != nil {
		var temp string
		temp = string(*typedInput.EvictionPolicy)
		evictionPolicy := EvictionPolicy(temp)
		profile.EvictionPolicy = &evictionPolicy
	}

	// Set property "ExtensionProfile":
	if typedInput.ExtensionProfile != nil {
		var extensionProfile1 VirtualMachineScaleSetExtensionProfile
		err := extensionProfile1.PopulateFromARM(owner, *typedInput.ExtensionProfile)
		if err != nil {
			return err
		}
		extensionProfile := extensionProfile1
		profile.ExtensionProfile = &extensionProfile
	}

	// Set property "HardwareProfile":
	if typedInput.HardwareProfile != nil {
		var hardwareProfile1 VirtualMachineScaleSetHardwareProfile
		err := hardwareProfile1.PopulateFromARM(owner, *typedInput.HardwareProfile)
		if err != nil {
			return err
		}
		hardwareProfile := hardwareProfile1
		profile.HardwareProfile = &hardwareProfile
	}

	// Set property "LicenseType":
	if typedInput.LicenseType != nil {
		licenseType := *typedInput.LicenseType
		profile.LicenseType = &licenseType
	}

	// Set property "NetworkProfile":
	if typedInput.NetworkProfile != nil {
		var networkProfile1 VirtualMachineScaleSetNetworkProfile
		err := networkProfile1.PopulateFromARM(owner, *typedInput.NetworkProfile)
		if err != nil {
			return err
		}
		networkProfile := networkProfile1
		profile.NetworkProfile = &networkProfile
	}

	// Set property "OsProfile":
	if typedInput.OsProfile != nil {
		var osProfile1 VirtualMachineScaleSetOSProfile
		err := osProfile1.PopulateFromARM(owner, *typedInput.OsProfile)
		if err != nil {
			return err
		}
		osProfile := osProfile1
		profile.OsProfile = &osProfile
	}

	// Set property "Priority":
	if typedInput.Priority != nil {
		var temp string
		temp = string(*typedInput.Priority)
		priority := Priority(temp)
		profile.Priority = &priority
	}

	// Set property "ScheduledEventsProfile":
	if typedInput.ScheduledEventsProfile != nil {
		var scheduledEventsProfile1 ScheduledEventsProfile
		err := scheduledEventsProfile1.PopulateFromARM(owner, *typedInput.ScheduledEventsProfile)
		if err != nil {
			return err
		}
		scheduledEventsProfile := scheduledEventsProfile1
		profile.ScheduledEventsProfile = &scheduledEventsProfile
	}

	// Set property "SecurityProfile":
	if typedInput.SecurityProfile != nil {
		var securityProfile1 SecurityProfile
		err := securityProfile1.PopulateFromARM(owner, *typedInput.SecurityProfile)
		if err != nil {
			return err
		}
		securityProfile := securityProfile1
		profile.SecurityProfile = &securityProfile
	}

	// Set property "StorageProfile":
	if typedInput.StorageProfile != nil {
		var storageProfile1 VirtualMachineScaleSetStorageProfile
		err := storageProfile1.PopulateFromARM(owner, *typedInput.StorageProfile)
		if err != nil {
			return err
		}
		storageProfile := storageProfile1
		profile.StorageProfile = &storageProfile
	}

	// Set property "UserData":
	if typedInput.UserData != nil {
		userData := *typedInput.UserData
		profile.UserData = &userData
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSetVMProfile populates our VirtualMachineScaleSetVMProfile from the provided source VirtualMachineScaleSetVMProfile
func (profile *VirtualMachineScaleSetVMProfile) AssignProperties_From_VirtualMachineScaleSetVMProfile(source *storage.VirtualMachineScaleSetVMProfile) error {

	// ApplicationProfile
	if source.ApplicationProfile != nil {
		var applicationProfile ApplicationProfile
		err := applicationProfile.AssignProperties_From_ApplicationProfile(source.ApplicationProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ApplicationProfile() to populate field ApplicationProfile")
		}
		profile.ApplicationProfile = &applicationProfile
	} else {
		profile.ApplicationProfile = nil
	}

	// BillingProfile
	if source.BillingProfile != nil {
		var billingProfile BillingProfile
		err := billingProfile.AssignProperties_From_BillingProfile(source.BillingProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BillingProfile() to populate field BillingProfile")
		}
		profile.BillingProfile = &billingProfile
	} else {
		profile.BillingProfile = nil
	}

	// CapacityReservation
	if source.CapacityReservation != nil {
		var capacityReservation CapacityReservationProfile
		err := capacityReservation.AssignProperties_From_CapacityReservationProfile(source.CapacityReservation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CapacityReservationProfile() to populate field CapacityReservation")
		}
		profile.CapacityReservation = &capacityReservation
	} else {
		profile.CapacityReservation = nil
	}

	// DiagnosticsProfile
	if source.DiagnosticsProfile != nil {
		var diagnosticsProfile DiagnosticsProfile
		err := diagnosticsProfile.AssignProperties_From_DiagnosticsProfile(source.DiagnosticsProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DiagnosticsProfile() to populate field DiagnosticsProfile")
		}
		profile.DiagnosticsProfile = &diagnosticsProfile
	} else {
		profile.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	if source.EvictionPolicy != nil {
		evictionPolicy := *source.EvictionPolicy
		evictionPolicyTemp := genruntime.ToEnum(evictionPolicy, evictionPolicy_Values)
		profile.EvictionPolicy = &evictionPolicyTemp
	} else {
		profile.EvictionPolicy = nil
	}

	// ExtensionProfile
	if source.ExtensionProfile != nil {
		var extensionProfile VirtualMachineScaleSetExtensionProfile
		err := extensionProfile.AssignProperties_From_VirtualMachineScaleSetExtensionProfile(source.ExtensionProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetExtensionProfile() to populate field ExtensionProfile")
		}
		profile.ExtensionProfile = &extensionProfile
	} else {
		profile.ExtensionProfile = nil
	}

	// HardwareProfile
	if source.HardwareProfile != nil {
		var hardwareProfile VirtualMachineScaleSetHardwareProfile
		err := hardwareProfile.AssignProperties_From_VirtualMachineScaleSetHardwareProfile(source.HardwareProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetHardwareProfile() to populate field HardwareProfile")
		}
		profile.HardwareProfile = &hardwareProfile
	} else {
		profile.HardwareProfile = nil
	}

	// LicenseType
	profile.LicenseType = genruntime.ClonePointerToString(source.LicenseType)

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile VirtualMachineScaleSetNetworkProfile
		err := networkProfile.AssignProperties_From_VirtualMachineScaleSetNetworkProfile(source.NetworkProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetNetworkProfile() to populate field NetworkProfile")
		}
		profile.NetworkProfile = &networkProfile
	} else {
		profile.NetworkProfile = nil
	}

	// OsProfile
	if source.OsProfile != nil {
		var osProfile VirtualMachineScaleSetOSProfile
		err := osProfile.AssignProperties_From_VirtualMachineScaleSetOSProfile(source.OsProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetOSProfile() to populate field OsProfile")
		}
		profile.OsProfile = &osProfile
	} else {
		profile.OsProfile = nil
	}

	// Priority
	if source.Priority != nil {
		priority := *source.Priority
		priorityTemp := genruntime.ToEnum(priority, priority_Values)
		profile.Priority = &priorityTemp
	} else {
		profile.Priority = nil
	}

	// ScheduledEventsProfile
	if source.ScheduledEventsProfile != nil {
		var scheduledEventsProfile ScheduledEventsProfile
		err := scheduledEventsProfile.AssignProperties_From_ScheduledEventsProfile(source.ScheduledEventsProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ScheduledEventsProfile() to populate field ScheduledEventsProfile")
		}
		profile.ScheduledEventsProfile = &scheduledEventsProfile
	} else {
		profile.ScheduledEventsProfile = nil
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		var securityProfile SecurityProfile
		err := securityProfile.AssignProperties_From_SecurityProfile(source.SecurityProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SecurityProfile() to populate field SecurityProfile")
		}
		profile.SecurityProfile = &securityProfile
	} else {
		profile.SecurityProfile = nil
	}

	// StorageProfile
	if source.StorageProfile != nil {
		var storageProfile VirtualMachineScaleSetStorageProfile
		err := storageProfile.AssignProperties_From_VirtualMachineScaleSetStorageProfile(source.StorageProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetStorageProfile() to populate field StorageProfile")
		}
		profile.StorageProfile = &storageProfile
	} else {
		profile.StorageProfile = nil
	}

	// UserData
	profile.UserData = genruntime.ClonePointerToString(source.UserData)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetVMProfile populates the provided destination VirtualMachineScaleSetVMProfile from our VirtualMachineScaleSetVMProfile
func (profile *VirtualMachineScaleSetVMProfile) AssignProperties_To_VirtualMachineScaleSetVMProfile(destination *storage.VirtualMachineScaleSetVMProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ApplicationProfile
	if profile.ApplicationProfile != nil {
		var applicationProfile storage.ApplicationProfile
		err := profile.ApplicationProfile.AssignProperties_To_ApplicationProfile(&applicationProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ApplicationProfile() to populate field ApplicationProfile")
		}
		destination.ApplicationProfile = &applicationProfile
	} else {
		destination.ApplicationProfile = nil
	}

	// BillingProfile
	if profile.BillingProfile != nil {
		var billingProfile storage.BillingProfile
		err := profile.BillingProfile.AssignProperties_To_BillingProfile(&billingProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BillingProfile() to populate field BillingProfile")
		}
		destination.BillingProfile = &billingProfile
	} else {
		destination.BillingProfile = nil
	}

	// CapacityReservation
	if profile.CapacityReservation != nil {
		var capacityReservation storage.CapacityReservationProfile
		err := profile.CapacityReservation.AssignProperties_To_CapacityReservationProfile(&capacityReservation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CapacityReservationProfile() to populate field CapacityReservation")
		}
		destination.CapacityReservation = &capacityReservation
	} else {
		destination.CapacityReservation = nil
	}

	// DiagnosticsProfile
	if profile.DiagnosticsProfile != nil {
		var diagnosticsProfile storage.DiagnosticsProfile
		err := profile.DiagnosticsProfile.AssignProperties_To_DiagnosticsProfile(&diagnosticsProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DiagnosticsProfile() to populate field DiagnosticsProfile")
		}
		destination.DiagnosticsProfile = &diagnosticsProfile
	} else {
		destination.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	if profile.EvictionPolicy != nil {
		evictionPolicy := string(*profile.EvictionPolicy)
		destination.EvictionPolicy = &evictionPolicy
	} else {
		destination.EvictionPolicy = nil
	}

	// ExtensionProfile
	if profile.ExtensionProfile != nil {
		var extensionProfile storage.VirtualMachineScaleSetExtensionProfile
		err := profile.ExtensionProfile.AssignProperties_To_VirtualMachineScaleSetExtensionProfile(&extensionProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetExtensionProfile() to populate field ExtensionProfile")
		}
		destination.ExtensionProfile = &extensionProfile
	} else {
		destination.ExtensionProfile = nil
	}

	// HardwareProfile
	if profile.HardwareProfile != nil {
		var hardwareProfile storage.VirtualMachineScaleSetHardwareProfile
		err := profile.HardwareProfile.AssignProperties_To_VirtualMachineScaleSetHardwareProfile(&hardwareProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetHardwareProfile() to populate field HardwareProfile")
		}
		destination.HardwareProfile = &hardwareProfile
	} else {
		destination.HardwareProfile = nil
	}

	// LicenseType
	destination.LicenseType = genruntime.ClonePointerToString(profile.LicenseType)

	// NetworkProfile
	if profile.NetworkProfile != nil {
		var networkProfile storage.VirtualMachineScaleSetNetworkProfile
		err := profile.NetworkProfile.AssignProperties_To_VirtualMachineScaleSetNetworkProfile(&networkProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetNetworkProfile() to populate field NetworkProfile")
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// OsProfile
	if profile.OsProfile != nil {
		var osProfile storage.VirtualMachineScaleSetOSProfile
		err := profile.OsProfile.AssignProperties_To_VirtualMachineScaleSetOSProfile(&osProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetOSProfile() to populate field OsProfile")
		}
		destination.OsProfile = &osProfile
	} else {
		destination.OsProfile = nil
	}

	// Priority
	if profile.Priority != nil {
		priority := string(*profile.Priority)
		destination.Priority = &priority
	} else {
		destination.Priority = nil
	}

	// ScheduledEventsProfile
	if profile.ScheduledEventsProfile != nil {
		var scheduledEventsProfile storage.ScheduledEventsProfile
		err := profile.ScheduledEventsProfile.AssignProperties_To_ScheduledEventsProfile(&scheduledEventsProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ScheduledEventsProfile() to populate field ScheduledEventsProfile")
		}
		destination.ScheduledEventsProfile = &scheduledEventsProfile
	} else {
		destination.ScheduledEventsProfile = nil
	}

	// SecurityProfile
	if profile.SecurityProfile != nil {
		var securityProfile storage.SecurityProfile
		err := profile.SecurityProfile.AssignProperties_To_SecurityProfile(&securityProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SecurityProfile() to populate field SecurityProfile")
		}
		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// StorageProfile
	if profile.StorageProfile != nil {
		var storageProfile storage.VirtualMachineScaleSetStorageProfile
		err := profile.StorageProfile.AssignProperties_To_VirtualMachineScaleSetStorageProfile(&storageProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetStorageProfile() to populate field StorageProfile")
		}
		destination.StorageProfile = &storageProfile
	} else {
		destination.StorageProfile = nil
	}

	// UserData
	destination.UserData = genruntime.ClonePointerToString(profile.UserData)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualMachineScaleSetVMProfile_STATUS populates our VirtualMachineScaleSetVMProfile from the provided source VirtualMachineScaleSetVMProfile_STATUS
func (profile *VirtualMachineScaleSetVMProfile) Initialize_From_VirtualMachineScaleSetVMProfile_STATUS(source *VirtualMachineScaleSetVMProfile_STATUS) error {

	// ApplicationProfile
	if source.ApplicationProfile != nil {
		var applicationProfile ApplicationProfile
		err := applicationProfile.Initialize_From_ApplicationProfile_STATUS(source.ApplicationProfile)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ApplicationProfile_STATUS() to populate field ApplicationProfile")
		}
		profile.ApplicationProfile = &applicationProfile
	} else {
		profile.ApplicationProfile = nil
	}

	// BillingProfile
	if source.BillingProfile != nil {
		var billingProfile BillingProfile
		err := billingProfile.Initialize_From_BillingProfile_STATUS(source.BillingProfile)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_BillingProfile_STATUS() to populate field BillingProfile")
		}
		profile.BillingProfile = &billingProfile
	} else {
		profile.BillingProfile = nil
	}

	// CapacityReservation
	if source.CapacityReservation != nil {
		var capacityReservation CapacityReservationProfile
		err := capacityReservation.Initialize_From_CapacityReservationProfile_STATUS(source.CapacityReservation)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_CapacityReservationProfile_STATUS() to populate field CapacityReservation")
		}
		profile.CapacityReservation = &capacityReservation
	} else {
		profile.CapacityReservation = nil
	}

	// DiagnosticsProfile
	if source.DiagnosticsProfile != nil {
		var diagnosticsProfile DiagnosticsProfile
		err := diagnosticsProfile.Initialize_From_DiagnosticsProfile_STATUS(source.DiagnosticsProfile)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_DiagnosticsProfile_STATUS() to populate field DiagnosticsProfile")
		}
		profile.DiagnosticsProfile = &diagnosticsProfile
	} else {
		profile.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	if source.EvictionPolicy != nil {
		evictionPolicy := genruntime.ToEnum(string(*source.EvictionPolicy), evictionPolicy_Values)
		profile.EvictionPolicy = &evictionPolicy
	} else {
		profile.EvictionPolicy = nil
	}

	// ExtensionProfile
	if source.ExtensionProfile != nil {
		var extensionProfile VirtualMachineScaleSetExtensionProfile
		err := extensionProfile.Initialize_From_VirtualMachineScaleSetExtensionProfile_STATUS(source.ExtensionProfile)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_VirtualMachineScaleSetExtensionProfile_STATUS() to populate field ExtensionProfile")
		}
		profile.ExtensionProfile = &extensionProfile
	} else {
		profile.ExtensionProfile = nil
	}

	// HardwareProfile
	if source.HardwareProfile != nil {
		var hardwareProfile VirtualMachineScaleSetHardwareProfile
		err := hardwareProfile.Initialize_From_VirtualMachineScaleSetHardwareProfile_STATUS(source.HardwareProfile)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_VirtualMachineScaleSetHardwareProfile_STATUS() to populate field HardwareProfile")
		}
		profile.HardwareProfile = &hardwareProfile
	} else {
		profile.HardwareProfile = nil
	}

	// LicenseType
	profile.LicenseType = genruntime.ClonePointerToString(source.LicenseType)

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile VirtualMachineScaleSetNetworkProfile
		err := networkProfile.Initialize_From_VirtualMachineScaleSetNetworkProfile_STATUS(source.NetworkProfile)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_VirtualMachineScaleSetNetworkProfile_STATUS() to populate field NetworkProfile")
		}
		profile.NetworkProfile = &networkProfile
	} else {
		profile.NetworkProfile = nil
	}

	// OsProfile
	if source.OsProfile != nil {
		var osProfile VirtualMachineScaleSetOSProfile
		err := osProfile.Initialize_From_VirtualMachineScaleSetOSProfile_STATUS(source.OsProfile)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_VirtualMachineScaleSetOSProfile_STATUS() to populate field OsProfile")
		}
		profile.OsProfile = &osProfile
	} else {
		profile.OsProfile = nil
	}

	// Priority
	if source.Priority != nil {
		priority := genruntime.ToEnum(string(*source.Priority), priority_Values)
		profile.Priority = &priority
	} else {
		profile.Priority = nil
	}

	// ScheduledEventsProfile
	if source.ScheduledEventsProfile != nil {
		var scheduledEventsProfile ScheduledEventsProfile
		err := scheduledEventsProfile.Initialize_From_ScheduledEventsProfile_STATUS(source.ScheduledEventsProfile)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ScheduledEventsProfile_STATUS() to populate field ScheduledEventsProfile")
		}
		profile.ScheduledEventsProfile = &scheduledEventsProfile
	} else {
		profile.ScheduledEventsProfile = nil
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		var securityProfile SecurityProfile
		err := securityProfile.Initialize_From_SecurityProfile_STATUS(source.SecurityProfile)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_SecurityProfile_STATUS() to populate field SecurityProfile")
		}
		profile.SecurityProfile = &securityProfile
	} else {
		profile.SecurityProfile = nil
	}

	// StorageProfile
	if source.StorageProfile != nil {
		var storageProfile VirtualMachineScaleSetStorageProfile
		err := storageProfile.Initialize_From_VirtualMachineScaleSetStorageProfile_STATUS(source.StorageProfile)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_VirtualMachineScaleSetStorageProfile_STATUS() to populate field StorageProfile")
		}
		profile.StorageProfile = &storageProfile
	} else {
		profile.StorageProfile = nil
	}

	// UserData
	profile.UserData = genruntime.ClonePointerToString(source.UserData)

	// No error
	return nil
}

// Describes a virtual machine scale set virtual machine profile.
type VirtualMachineScaleSetVMProfile_STATUS struct {
	// ApplicationProfile: Specifies the gallery applications that should be made available to the VM/VMSS
	ApplicationProfile *ApplicationProfile_STATUS `json:"applicationProfile,omitempty"`

	// BillingProfile: Specifies the billing related details of a Azure Spot VMSS.
	// Minimum api-version: 2019-03-01.
	BillingProfile *BillingProfile_STATUS `json:"billingProfile,omitempty"`

	// CapacityReservation: Specifies the capacity reservation related details of a scale set.
	// Minimum api-version: 2021-04-01.
	CapacityReservation *CapacityReservationProfile_STATUS `json:"capacityReservation,omitempty"`

	// DiagnosticsProfile: Specifies the boot diagnostic settings state.
	// Minimum api-version: 2015-06-15.
	DiagnosticsProfile *DiagnosticsProfile_STATUS `json:"diagnosticsProfile,omitempty"`

	// EvictionPolicy: Specifies the eviction policy for the Azure Spot virtual machine and Azure Spot scale set.
	// For Azure Spot virtual machines, both 'Deallocate' and 'Delete' are supported and the minimum api-version is 2019-03-01.
	// For Azure Spot scale sets, both 'Deallocate' and 'Delete' are supported and the minimum api-version is
	// 2017-10-30-preview.
	EvictionPolicy *EvictionPolicy_STATUS `json:"evictionPolicy,omitempty"`

	// ExtensionProfile: Specifies a collection of settings for extensions installed on virtual machines in the scale set.
	ExtensionProfile *VirtualMachineScaleSetExtensionProfile_STATUS `json:"extensionProfile,omitempty"`

	// HardwareProfile: Specifies the hardware profile related details of a scale set.
	// Minimum api-version: 2022-03-01.
	HardwareProfile *VirtualMachineScaleSetHardwareProfile_STATUS `json:"hardwareProfile,omitempty"`

	// LicenseType: Specifies that the image or disk that is being used was licensed on-premises.
	// Possible values for Windows Server operating system are:
	// Windows_Client
	// Windows_Server
	// Possible values for Linux Server operating system are:
	// RHEL_BYOS (for RHEL)
	// SLES_BYOS (for SUSE)
	// For more information, see [Azure Hybrid Use Benefit for Windows
	// Server](https://docs.microsoft.com/azure/virtual-machines/windows/hybrid-use-benefit-licensing)
	// [Azure Hybrid Use Benefit for Linux
	// Server](https://docs.microsoft.com/azure/virtual-machines/linux/azure-hybrid-benefit-linux)
	// Minimum api-version: 2015-06-15
	LicenseType *string `json:"licenseType,omitempty"`

	// NetworkProfile: Specifies properties of the network interfaces of the virtual machines in the scale set.
	NetworkProfile *VirtualMachineScaleSetNetworkProfile_STATUS `json:"networkProfile,omitempty"`

	// OsProfile: Specifies the operating system settings for the virtual machines in the scale set.
	OsProfile *VirtualMachineScaleSetOSProfile_STATUS `json:"osProfile,omitempty"`

	// Priority: Specifies the priority for the virtual machines in the scale set.
	// Minimum api-version: 2017-10-30-preview
	Priority *Priority_STATUS `json:"priority,omitempty"`

	// ScheduledEventsProfile: Specifies Scheduled Event related configurations.
	ScheduledEventsProfile *ScheduledEventsProfile_STATUS `json:"scheduledEventsProfile,omitempty"`

	// SecurityProfile: Specifies the Security related profile settings for the virtual machines in the scale set.
	SecurityProfile *SecurityProfile_STATUS `json:"securityProfile,omitempty"`

	// StorageProfile: Specifies the storage settings for the virtual machine disks.
	StorageProfile *VirtualMachineScaleSetStorageProfile_STATUS `json:"storageProfile,omitempty"`

	// UserData: UserData for the virtual machines in the scale set, which must be base-64 encoded. Customer should not pass
	// any secrets in here.
	// Minimum api-version: 2021-03-01
	UserData *string `json:"userData,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetVMProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSetVMProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSetVMProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSetVMProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSetVMProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSetVMProfile_STATUS, got %T", armInput)
	}

	// Set property "ApplicationProfile":
	if typedInput.ApplicationProfile != nil {
		var applicationProfile1 ApplicationProfile_STATUS
		err := applicationProfile1.PopulateFromARM(owner, *typedInput.ApplicationProfile)
		if err != nil {
			return err
		}
		applicationProfile := applicationProfile1
		profile.ApplicationProfile = &applicationProfile
	}

	// Set property "BillingProfile":
	if typedInput.BillingProfile != nil {
		var billingProfile1 BillingProfile_STATUS
		err := billingProfile1.PopulateFromARM(owner, *typedInput.BillingProfile)
		if err != nil {
			return err
		}
		billingProfile := billingProfile1
		profile.BillingProfile = &billingProfile
	}

	// Set property "CapacityReservation":
	if typedInput.CapacityReservation != nil {
		var capacityReservation1 CapacityReservationProfile_STATUS
		err := capacityReservation1.PopulateFromARM(owner, *typedInput.CapacityReservation)
		if err != nil {
			return err
		}
		capacityReservation := capacityReservation1
		profile.CapacityReservation = &capacityReservation
	}

	// Set property "DiagnosticsProfile":
	if typedInput.DiagnosticsProfile != nil {
		var diagnosticsProfile1 DiagnosticsProfile_STATUS
		err := diagnosticsProfile1.PopulateFromARM(owner, *typedInput.DiagnosticsProfile)
		if err != nil {
			return err
		}
		diagnosticsProfile := diagnosticsProfile1
		profile.DiagnosticsProfile = &diagnosticsProfile
	}

	// Set property "EvictionPolicy":
	if typedInput.EvictionPolicy != nil {
		var temp string
		temp = string(*typedInput.EvictionPolicy)
		evictionPolicy := EvictionPolicy_STATUS(temp)
		profile.EvictionPolicy = &evictionPolicy
	}

	// Set property "ExtensionProfile":
	if typedInput.ExtensionProfile != nil {
		var extensionProfile1 VirtualMachineScaleSetExtensionProfile_STATUS
		err := extensionProfile1.PopulateFromARM(owner, *typedInput.ExtensionProfile)
		if err != nil {
			return err
		}
		extensionProfile := extensionProfile1
		profile.ExtensionProfile = &extensionProfile
	}

	// Set property "HardwareProfile":
	if typedInput.HardwareProfile != nil {
		var hardwareProfile1 VirtualMachineScaleSetHardwareProfile_STATUS
		err := hardwareProfile1.PopulateFromARM(owner, *typedInput.HardwareProfile)
		if err != nil {
			return err
		}
		hardwareProfile := hardwareProfile1
		profile.HardwareProfile = &hardwareProfile
	}

	// Set property "LicenseType":
	if typedInput.LicenseType != nil {
		licenseType := *typedInput.LicenseType
		profile.LicenseType = &licenseType
	}

	// Set property "NetworkProfile":
	if typedInput.NetworkProfile != nil {
		var networkProfile1 VirtualMachineScaleSetNetworkProfile_STATUS
		err := networkProfile1.PopulateFromARM(owner, *typedInput.NetworkProfile)
		if err != nil {
			return err
		}
		networkProfile := networkProfile1
		profile.NetworkProfile = &networkProfile
	}

	// Set property "OsProfile":
	if typedInput.OsProfile != nil {
		var osProfile1 VirtualMachineScaleSetOSProfile_STATUS
		err := osProfile1.PopulateFromARM(owner, *typedInput.OsProfile)
		if err != nil {
			return err
		}
		osProfile := osProfile1
		profile.OsProfile = &osProfile
	}

	// Set property "Priority":
	if typedInput.Priority != nil {
		var temp string
		temp = string(*typedInput.Priority)
		priority := Priority_STATUS(temp)
		profile.Priority = &priority
	}

	// Set property "ScheduledEventsProfile":
	if typedInput.ScheduledEventsProfile != nil {
		var scheduledEventsProfile1 ScheduledEventsProfile_STATUS
		err := scheduledEventsProfile1.PopulateFromARM(owner, *typedInput.ScheduledEventsProfile)
		if err != nil {
			return err
		}
		scheduledEventsProfile := scheduledEventsProfile1
		profile.ScheduledEventsProfile = &scheduledEventsProfile
	}

	// Set property "SecurityProfile":
	if typedInput.SecurityProfile != nil {
		var securityProfile1 SecurityProfile_STATUS
		err := securityProfile1.PopulateFromARM(owner, *typedInput.SecurityProfile)
		if err != nil {
			return err
		}
		securityProfile := securityProfile1
		profile.SecurityProfile = &securityProfile
	}

	// Set property "StorageProfile":
	if typedInput.StorageProfile != nil {
		var storageProfile1 VirtualMachineScaleSetStorageProfile_STATUS
		err := storageProfile1.PopulateFromARM(owner, *typedInput.StorageProfile)
		if err != nil {
			return err
		}
		storageProfile := storageProfile1
		profile.StorageProfile = &storageProfile
	}

	// Set property "UserData":
	if typedInput.UserData != nil {
		userData := *typedInput.UserData
		profile.UserData = &userData
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSetVMProfile_STATUS populates our VirtualMachineScaleSetVMProfile_STATUS from the provided source VirtualMachineScaleSetVMProfile_STATUS
func (profile *VirtualMachineScaleSetVMProfile_STATUS) AssignProperties_From_VirtualMachineScaleSetVMProfile_STATUS(source *storage.VirtualMachineScaleSetVMProfile_STATUS) error {

	// ApplicationProfile
	if source.ApplicationProfile != nil {
		var applicationProfile ApplicationProfile_STATUS
		err := applicationProfile.AssignProperties_From_ApplicationProfile_STATUS(source.ApplicationProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ApplicationProfile_STATUS() to populate field ApplicationProfile")
		}
		profile.ApplicationProfile = &applicationProfile
	} else {
		profile.ApplicationProfile = nil
	}

	// BillingProfile
	if source.BillingProfile != nil {
		var billingProfile BillingProfile_STATUS
		err := billingProfile.AssignProperties_From_BillingProfile_STATUS(source.BillingProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BillingProfile_STATUS() to populate field BillingProfile")
		}
		profile.BillingProfile = &billingProfile
	} else {
		profile.BillingProfile = nil
	}

	// CapacityReservation
	if source.CapacityReservation != nil {
		var capacityReservation CapacityReservationProfile_STATUS
		err := capacityReservation.AssignProperties_From_CapacityReservationProfile_STATUS(source.CapacityReservation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CapacityReservationProfile_STATUS() to populate field CapacityReservation")
		}
		profile.CapacityReservation = &capacityReservation
	} else {
		profile.CapacityReservation = nil
	}

	// DiagnosticsProfile
	if source.DiagnosticsProfile != nil {
		var diagnosticsProfile DiagnosticsProfile_STATUS
		err := diagnosticsProfile.AssignProperties_From_DiagnosticsProfile_STATUS(source.DiagnosticsProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DiagnosticsProfile_STATUS() to populate field DiagnosticsProfile")
		}
		profile.DiagnosticsProfile = &diagnosticsProfile
	} else {
		profile.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	if source.EvictionPolicy != nil {
		evictionPolicy := *source.EvictionPolicy
		evictionPolicyTemp := genruntime.ToEnum(evictionPolicy, evictionPolicy_STATUS_Values)
		profile.EvictionPolicy = &evictionPolicyTemp
	} else {
		profile.EvictionPolicy = nil
	}

	// ExtensionProfile
	if source.ExtensionProfile != nil {
		var extensionProfile VirtualMachineScaleSetExtensionProfile_STATUS
		err := extensionProfile.AssignProperties_From_VirtualMachineScaleSetExtensionProfile_STATUS(source.ExtensionProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetExtensionProfile_STATUS() to populate field ExtensionProfile")
		}
		profile.ExtensionProfile = &extensionProfile
	} else {
		profile.ExtensionProfile = nil
	}

	// HardwareProfile
	if source.HardwareProfile != nil {
		var hardwareProfile VirtualMachineScaleSetHardwareProfile_STATUS
		err := hardwareProfile.AssignProperties_From_VirtualMachineScaleSetHardwareProfile_STATUS(source.HardwareProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetHardwareProfile_STATUS() to populate field HardwareProfile")
		}
		profile.HardwareProfile = &hardwareProfile
	} else {
		profile.HardwareProfile = nil
	}

	// LicenseType
	profile.LicenseType = genruntime.ClonePointerToString(source.LicenseType)

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile VirtualMachineScaleSetNetworkProfile_STATUS
		err := networkProfile.AssignProperties_From_VirtualMachineScaleSetNetworkProfile_STATUS(source.NetworkProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetNetworkProfile_STATUS() to populate field NetworkProfile")
		}
		profile.NetworkProfile = &networkProfile
	} else {
		profile.NetworkProfile = nil
	}

	// OsProfile
	if source.OsProfile != nil {
		var osProfile VirtualMachineScaleSetOSProfile_STATUS
		err := osProfile.AssignProperties_From_VirtualMachineScaleSetOSProfile_STATUS(source.OsProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetOSProfile_STATUS() to populate field OsProfile")
		}
		profile.OsProfile = &osProfile
	} else {
		profile.OsProfile = nil
	}

	// Priority
	if source.Priority != nil {
		priority := *source.Priority
		priorityTemp := genruntime.ToEnum(priority, priority_STATUS_Values)
		profile.Priority = &priorityTemp
	} else {
		profile.Priority = nil
	}

	// ScheduledEventsProfile
	if source.ScheduledEventsProfile != nil {
		var scheduledEventsProfile ScheduledEventsProfile_STATUS
		err := scheduledEventsProfile.AssignProperties_From_ScheduledEventsProfile_STATUS(source.ScheduledEventsProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ScheduledEventsProfile_STATUS() to populate field ScheduledEventsProfile")
		}
		profile.ScheduledEventsProfile = &scheduledEventsProfile
	} else {
		profile.ScheduledEventsProfile = nil
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		var securityProfile SecurityProfile_STATUS
		err := securityProfile.AssignProperties_From_SecurityProfile_STATUS(source.SecurityProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SecurityProfile_STATUS() to populate field SecurityProfile")
		}
		profile.SecurityProfile = &securityProfile
	} else {
		profile.SecurityProfile = nil
	}

	// StorageProfile
	if source.StorageProfile != nil {
		var storageProfile VirtualMachineScaleSetStorageProfile_STATUS
		err := storageProfile.AssignProperties_From_VirtualMachineScaleSetStorageProfile_STATUS(source.StorageProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetStorageProfile_STATUS() to populate field StorageProfile")
		}
		profile.StorageProfile = &storageProfile
	} else {
		profile.StorageProfile = nil
	}

	// UserData
	profile.UserData = genruntime.ClonePointerToString(source.UserData)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetVMProfile_STATUS populates the provided destination VirtualMachineScaleSetVMProfile_STATUS from our VirtualMachineScaleSetVMProfile_STATUS
func (profile *VirtualMachineScaleSetVMProfile_STATUS) AssignProperties_To_VirtualMachineScaleSetVMProfile_STATUS(destination *storage.VirtualMachineScaleSetVMProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ApplicationProfile
	if profile.ApplicationProfile != nil {
		var applicationProfile storage.ApplicationProfile_STATUS
		err := profile.ApplicationProfile.AssignProperties_To_ApplicationProfile_STATUS(&applicationProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ApplicationProfile_STATUS() to populate field ApplicationProfile")
		}
		destination.ApplicationProfile = &applicationProfile
	} else {
		destination.ApplicationProfile = nil
	}

	// BillingProfile
	if profile.BillingProfile != nil {
		var billingProfile storage.BillingProfile_STATUS
		err := profile.BillingProfile.AssignProperties_To_BillingProfile_STATUS(&billingProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BillingProfile_STATUS() to populate field BillingProfile")
		}
		destination.BillingProfile = &billingProfile
	} else {
		destination.BillingProfile = nil
	}

	// CapacityReservation
	if profile.CapacityReservation != nil {
		var capacityReservation storage.CapacityReservationProfile_STATUS
		err := profile.CapacityReservation.AssignProperties_To_CapacityReservationProfile_STATUS(&capacityReservation)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CapacityReservationProfile_STATUS() to populate field CapacityReservation")
		}
		destination.CapacityReservation = &capacityReservation
	} else {
		destination.CapacityReservation = nil
	}

	// DiagnosticsProfile
	if profile.DiagnosticsProfile != nil {
		var diagnosticsProfile storage.DiagnosticsProfile_STATUS
		err := profile.DiagnosticsProfile.AssignProperties_To_DiagnosticsProfile_STATUS(&diagnosticsProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DiagnosticsProfile_STATUS() to populate field DiagnosticsProfile")
		}
		destination.DiagnosticsProfile = &diagnosticsProfile
	} else {
		destination.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	if profile.EvictionPolicy != nil {
		evictionPolicy := string(*profile.EvictionPolicy)
		destination.EvictionPolicy = &evictionPolicy
	} else {
		destination.EvictionPolicy = nil
	}

	// ExtensionProfile
	if profile.ExtensionProfile != nil {
		var extensionProfile storage.VirtualMachineScaleSetExtensionProfile_STATUS
		err := profile.ExtensionProfile.AssignProperties_To_VirtualMachineScaleSetExtensionProfile_STATUS(&extensionProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetExtensionProfile_STATUS() to populate field ExtensionProfile")
		}
		destination.ExtensionProfile = &extensionProfile
	} else {
		destination.ExtensionProfile = nil
	}

	// HardwareProfile
	if profile.HardwareProfile != nil {
		var hardwareProfile storage.VirtualMachineScaleSetHardwareProfile_STATUS
		err := profile.HardwareProfile.AssignProperties_To_VirtualMachineScaleSetHardwareProfile_STATUS(&hardwareProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetHardwareProfile_STATUS() to populate field HardwareProfile")
		}
		destination.HardwareProfile = &hardwareProfile
	} else {
		destination.HardwareProfile = nil
	}

	// LicenseType
	destination.LicenseType = genruntime.ClonePointerToString(profile.LicenseType)

	// NetworkProfile
	if profile.NetworkProfile != nil {
		var networkProfile storage.VirtualMachineScaleSetNetworkProfile_STATUS
		err := profile.NetworkProfile.AssignProperties_To_VirtualMachineScaleSetNetworkProfile_STATUS(&networkProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetNetworkProfile_STATUS() to populate field NetworkProfile")
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// OsProfile
	if profile.OsProfile != nil {
		var osProfile storage.VirtualMachineScaleSetOSProfile_STATUS
		err := profile.OsProfile.AssignProperties_To_VirtualMachineScaleSetOSProfile_STATUS(&osProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetOSProfile_STATUS() to populate field OsProfile")
		}
		destination.OsProfile = &osProfile
	} else {
		destination.OsProfile = nil
	}

	// Priority
	if profile.Priority != nil {
		priority := string(*profile.Priority)
		destination.Priority = &priority
	} else {
		destination.Priority = nil
	}

	// ScheduledEventsProfile
	if profile.ScheduledEventsProfile != nil {
		var scheduledEventsProfile storage.ScheduledEventsProfile_STATUS
		err := profile.ScheduledEventsProfile.AssignProperties_To_ScheduledEventsProfile_STATUS(&scheduledEventsProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ScheduledEventsProfile_STATUS() to populate field ScheduledEventsProfile")
		}
		destination.ScheduledEventsProfile = &scheduledEventsProfile
	} else {
		destination.ScheduledEventsProfile = nil
	}

	// SecurityProfile
	if profile.SecurityProfile != nil {
		var securityProfile storage.SecurityProfile_STATUS
		err := profile.SecurityProfile.AssignProperties_To_SecurityProfile_STATUS(&securityProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SecurityProfile_STATUS() to populate field SecurityProfile")
		}
		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// StorageProfile
	if profile.StorageProfile != nil {
		var storageProfile storage.VirtualMachineScaleSetStorageProfile_STATUS
		err := profile.StorageProfile.AssignProperties_To_VirtualMachineScaleSetStorageProfile_STATUS(&storageProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetStorageProfile_STATUS() to populate field StorageProfile")
		}
		destination.StorageProfile = &storageProfile
	} else {
		destination.StorageProfile = nil
	}

	// UserData
	destination.UserData = genruntime.ClonePointerToString(profile.UserData)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration parameters used for performing automatic OS upgrade.
type AutomaticOSUpgradePolicy struct {
	// DisableAutomaticRollback: Whether OS image rollback feature should be disabled. Default value is false.
	DisableAutomaticRollback *bool `json:"disableAutomaticRollback,omitempty"`

	// EnableAutomaticOSUpgrade: Indicates whether OS upgrades should automatically be applied to scale set instances in a
	// rolling fashion when a newer version of the OS image becomes available. Default value is false.
	// If this is set to true for Windows based scale sets,
	// [enableAutomaticUpdates](https://docs.microsoft.com/dotnet/api/microsoft.azure.management.compute.models.windowsconfiguration.enableautomaticupdates?view=azure-dotnet)
	// is automatically set to false and cannot be set to true.
	EnableAutomaticOSUpgrade *bool `json:"enableAutomaticOSUpgrade,omitempty"`

	// UseRollingUpgradePolicy: Indicates whether rolling upgrade policy should be used during Auto OS Upgrade. Default value
	// is false. Auto OS Upgrade will fallback to the default policy if no policy is defined on the VMSS.
	UseRollingUpgradePolicy *bool `json:"useRollingUpgradePolicy,omitempty"`
}

var _ genruntime.ARMTransformer = &AutomaticOSUpgradePolicy{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *AutomaticOSUpgradePolicy) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	result := &arm.AutomaticOSUpgradePolicy{}

	// Set property "DisableAutomaticRollback":
	if policy.DisableAutomaticRollback != nil {
		disableAutomaticRollback := *policy.DisableAutomaticRollback
		result.DisableAutomaticRollback = &disableAutomaticRollback
	}

	// Set property "EnableAutomaticOSUpgrade":
	if policy.EnableAutomaticOSUpgrade != nil {
		enableAutomaticOSUpgrade := *policy.EnableAutomaticOSUpgrade
		result.EnableAutomaticOSUpgrade = &enableAutomaticOSUpgrade
	}

	// Set property "UseRollingUpgradePolicy":
	if policy.UseRollingUpgradePolicy != nil {
		useRollingUpgradePolicy := *policy.UseRollingUpgradePolicy
		result.UseRollingUpgradePolicy = &useRollingUpgradePolicy
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *AutomaticOSUpgradePolicy) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AutomaticOSUpgradePolicy{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *AutomaticOSUpgradePolicy) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AutomaticOSUpgradePolicy)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AutomaticOSUpgradePolicy, got %T", armInput)
	}

	// Set property "DisableAutomaticRollback":
	if typedInput.DisableAutomaticRollback != nil {
		disableAutomaticRollback := *typedInput.DisableAutomaticRollback
		policy.DisableAutomaticRollback = &disableAutomaticRollback
	}

	// Set property "EnableAutomaticOSUpgrade":
	if typedInput.EnableAutomaticOSUpgrade != nil {
		enableAutomaticOSUpgrade := *typedInput.EnableAutomaticOSUpgrade
		policy.EnableAutomaticOSUpgrade = &enableAutomaticOSUpgrade
	}

	// Set property "UseRollingUpgradePolicy":
	if typedInput.UseRollingUpgradePolicy != nil {
		useRollingUpgradePolicy := *typedInput.UseRollingUpgradePolicy
		policy.UseRollingUpgradePolicy = &useRollingUpgradePolicy
	}

	// No error
	return nil
}

// AssignProperties_From_AutomaticOSUpgradePolicy populates our AutomaticOSUpgradePolicy from the provided source AutomaticOSUpgradePolicy
func (policy *AutomaticOSUpgradePolicy) AssignProperties_From_AutomaticOSUpgradePolicy(source *storage.AutomaticOSUpgradePolicy) error {

	// DisableAutomaticRollback
	if source.DisableAutomaticRollback != nil {
		disableAutomaticRollback := *source.DisableAutomaticRollback
		policy.DisableAutomaticRollback = &disableAutomaticRollback
	} else {
		policy.DisableAutomaticRollback = nil
	}

	// EnableAutomaticOSUpgrade
	if source.EnableAutomaticOSUpgrade != nil {
		enableAutomaticOSUpgrade := *source.EnableAutomaticOSUpgrade
		policy.EnableAutomaticOSUpgrade = &enableAutomaticOSUpgrade
	} else {
		policy.EnableAutomaticOSUpgrade = nil
	}

	// UseRollingUpgradePolicy
	if source.UseRollingUpgradePolicy != nil {
		useRollingUpgradePolicy := *source.UseRollingUpgradePolicy
		policy.UseRollingUpgradePolicy = &useRollingUpgradePolicy
	} else {
		policy.UseRollingUpgradePolicy = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AutomaticOSUpgradePolicy populates the provided destination AutomaticOSUpgradePolicy from our AutomaticOSUpgradePolicy
func (policy *AutomaticOSUpgradePolicy) AssignProperties_To_AutomaticOSUpgradePolicy(destination *storage.AutomaticOSUpgradePolicy) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DisableAutomaticRollback
	if policy.DisableAutomaticRollback != nil {
		disableAutomaticRollback := *policy.DisableAutomaticRollback
		destination.DisableAutomaticRollback = &disableAutomaticRollback
	} else {
		destination.DisableAutomaticRollback = nil
	}

	// EnableAutomaticOSUpgrade
	if policy.EnableAutomaticOSUpgrade != nil {
		enableAutomaticOSUpgrade := *policy.EnableAutomaticOSUpgrade
		destination.EnableAutomaticOSUpgrade = &enableAutomaticOSUpgrade
	} else {
		destination.EnableAutomaticOSUpgrade = nil
	}

	// UseRollingUpgradePolicy
	if policy.UseRollingUpgradePolicy != nil {
		useRollingUpgradePolicy := *policy.UseRollingUpgradePolicy
		destination.UseRollingUpgradePolicy = &useRollingUpgradePolicy
	} else {
		destination.UseRollingUpgradePolicy = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AutomaticOSUpgradePolicy_STATUS populates our AutomaticOSUpgradePolicy from the provided source AutomaticOSUpgradePolicy_STATUS
func (policy *AutomaticOSUpgradePolicy) Initialize_From_AutomaticOSUpgradePolicy_STATUS(source *AutomaticOSUpgradePolicy_STATUS) error {

	// DisableAutomaticRollback
	if source.DisableAutomaticRollback != nil {
		disableAutomaticRollback := *source.DisableAutomaticRollback
		policy.DisableAutomaticRollback = &disableAutomaticRollback
	} else {
		policy.DisableAutomaticRollback = nil
	}

	// EnableAutomaticOSUpgrade
	if source.EnableAutomaticOSUpgrade != nil {
		enableAutomaticOSUpgrade := *source.EnableAutomaticOSUpgrade
		policy.EnableAutomaticOSUpgrade = &enableAutomaticOSUpgrade
	} else {
		policy.EnableAutomaticOSUpgrade = nil
	}

	// UseRollingUpgradePolicy
	if source.UseRollingUpgradePolicy != nil {
		useRollingUpgradePolicy := *source.UseRollingUpgradePolicy
		policy.UseRollingUpgradePolicy = &useRollingUpgradePolicy
	} else {
		policy.UseRollingUpgradePolicy = nil
	}

	// No error
	return nil
}

// The configuration parameters used for performing automatic OS upgrade.
type AutomaticOSUpgradePolicy_STATUS struct {
	// DisableAutomaticRollback: Whether OS image rollback feature should be disabled. Default value is false.
	DisableAutomaticRollback *bool `json:"disableAutomaticRollback,omitempty"`

	// EnableAutomaticOSUpgrade: Indicates whether OS upgrades should automatically be applied to scale set instances in a
	// rolling fashion when a newer version of the OS image becomes available. Default value is false.
	// If this is set to true for Windows based scale sets,
	// [enableAutomaticUpdates](https://docs.microsoft.com/dotnet/api/microsoft.azure.management.compute.models.windowsconfiguration.enableautomaticupdates?view=azure-dotnet)
	// is automatically set to false and cannot be set to true.
	EnableAutomaticOSUpgrade *bool `json:"enableAutomaticOSUpgrade,omitempty"`

	// UseRollingUpgradePolicy: Indicates whether rolling upgrade policy should be used during Auto OS Upgrade. Default value
	// is false. Auto OS Upgrade will fallback to the default policy if no policy is defined on the VMSS.
	UseRollingUpgradePolicy *bool `json:"useRollingUpgradePolicy,omitempty"`
}

var _ genruntime.FromARMConverter = &AutomaticOSUpgradePolicy_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *AutomaticOSUpgradePolicy_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AutomaticOSUpgradePolicy_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *AutomaticOSUpgradePolicy_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AutomaticOSUpgradePolicy_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AutomaticOSUpgradePolicy_STATUS, got %T", armInput)
	}

	// Set property "DisableAutomaticRollback":
	if typedInput.DisableAutomaticRollback != nil {
		disableAutomaticRollback := *typedInput.DisableAutomaticRollback
		policy.DisableAutomaticRollback = &disableAutomaticRollback
	}

	// Set property "EnableAutomaticOSUpgrade":
	if typedInput.EnableAutomaticOSUpgrade != nil {
		enableAutomaticOSUpgrade := *typedInput.EnableAutomaticOSUpgrade
		policy.EnableAutomaticOSUpgrade = &enableAutomaticOSUpgrade
	}

	// Set property "UseRollingUpgradePolicy":
	if typedInput.UseRollingUpgradePolicy != nil {
		useRollingUpgradePolicy := *typedInput.UseRollingUpgradePolicy
		policy.UseRollingUpgradePolicy = &useRollingUpgradePolicy
	}

	// No error
	return nil
}

// AssignProperties_From_AutomaticOSUpgradePolicy_STATUS populates our AutomaticOSUpgradePolicy_STATUS from the provided source AutomaticOSUpgradePolicy_STATUS
func (policy *AutomaticOSUpgradePolicy_STATUS) AssignProperties_From_AutomaticOSUpgradePolicy_STATUS(source *storage.AutomaticOSUpgradePolicy_STATUS) error {

	// DisableAutomaticRollback
	if source.DisableAutomaticRollback != nil {
		disableAutomaticRollback := *source.DisableAutomaticRollback
		policy.DisableAutomaticRollback = &disableAutomaticRollback
	} else {
		policy.DisableAutomaticRollback = nil
	}

	// EnableAutomaticOSUpgrade
	if source.EnableAutomaticOSUpgrade != nil {
		enableAutomaticOSUpgrade := *source.EnableAutomaticOSUpgrade
		policy.EnableAutomaticOSUpgrade = &enableAutomaticOSUpgrade
	} else {
		policy.EnableAutomaticOSUpgrade = nil
	}

	// UseRollingUpgradePolicy
	if source.UseRollingUpgradePolicy != nil {
		useRollingUpgradePolicy := *source.UseRollingUpgradePolicy
		policy.UseRollingUpgradePolicy = &useRollingUpgradePolicy
	} else {
		policy.UseRollingUpgradePolicy = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AutomaticOSUpgradePolicy_STATUS populates the provided destination AutomaticOSUpgradePolicy_STATUS from our AutomaticOSUpgradePolicy_STATUS
func (policy *AutomaticOSUpgradePolicy_STATUS) AssignProperties_To_AutomaticOSUpgradePolicy_STATUS(destination *storage.AutomaticOSUpgradePolicy_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DisableAutomaticRollback
	if policy.DisableAutomaticRollback != nil {
		disableAutomaticRollback := *policy.DisableAutomaticRollback
		destination.DisableAutomaticRollback = &disableAutomaticRollback
	} else {
		destination.DisableAutomaticRollback = nil
	}

	// EnableAutomaticOSUpgrade
	if policy.EnableAutomaticOSUpgrade != nil {
		enableAutomaticOSUpgrade := *policy.EnableAutomaticOSUpgrade
		destination.EnableAutomaticOSUpgrade = &enableAutomaticOSUpgrade
	} else {
		destination.EnableAutomaticOSUpgrade = nil
	}

	// UseRollingUpgradePolicy
	if policy.UseRollingUpgradePolicy != nil {
		useRollingUpgradePolicy := *policy.UseRollingUpgradePolicy
		destination.UseRollingUpgradePolicy = &useRollingUpgradePolicy
	} else {
		destination.UseRollingUpgradePolicy = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Reimage","Replace","Restart"}
type AutomaticRepairsPolicy_RepairAction string

const (
	AutomaticRepairsPolicy_RepairAction_Reimage = AutomaticRepairsPolicy_RepairAction("Reimage")
	AutomaticRepairsPolicy_RepairAction_Replace = AutomaticRepairsPolicy_RepairAction("Replace")
	AutomaticRepairsPolicy_RepairAction_Restart = AutomaticRepairsPolicy_RepairAction("Restart")
)

// Mapping from string to AutomaticRepairsPolicy_RepairAction
var automaticRepairsPolicy_RepairAction_Values = map[string]AutomaticRepairsPolicy_RepairAction{
	"reimage": AutomaticRepairsPolicy_RepairAction_Reimage,
	"replace": AutomaticRepairsPolicy_RepairAction_Replace,
	"restart": AutomaticRepairsPolicy_RepairAction_Restart,
}

type AutomaticRepairsPolicy_RepairAction_STATUS string

const (
	AutomaticRepairsPolicy_RepairAction_STATUS_Reimage = AutomaticRepairsPolicy_RepairAction_STATUS("Reimage")
	AutomaticRepairsPolicy_RepairAction_STATUS_Replace = AutomaticRepairsPolicy_RepairAction_STATUS("Replace")
	AutomaticRepairsPolicy_RepairAction_STATUS_Restart = AutomaticRepairsPolicy_RepairAction_STATUS("Restart")
)

// Mapping from string to AutomaticRepairsPolicy_RepairAction_STATUS
var automaticRepairsPolicy_RepairAction_STATUS_Values = map[string]AutomaticRepairsPolicy_RepairAction_STATUS{
	"reimage": AutomaticRepairsPolicy_RepairAction_STATUS_Reimage,
	"replace": AutomaticRepairsPolicy_RepairAction_STATUS_Replace,
	"restart": AutomaticRepairsPolicy_RepairAction_STATUS_Restart,
}

// The configuration parameters used while performing a rolling upgrade.
type RollingUpgradePolicy struct {
	// EnableCrossZoneUpgrade: Allow VMSS to ignore AZ boundaries when constructing upgrade batches. Take into consideration
	// the Update Domain and maxBatchInstancePercent to determine the batch size.
	EnableCrossZoneUpgrade *bool `json:"enableCrossZoneUpgrade,omitempty"`

	// +kubebuilder:validation:Maximum=100
	// +kubebuilder:validation:Minimum=5
	// MaxBatchInstancePercent: The maximum percent of total virtual machine instances that will be upgraded simultaneously by
	// the rolling upgrade in one batch. As this is a maximum, unhealthy instances in previous or future batches can cause the
	// percentage of instances in a batch to decrease to ensure higher reliability. The default value for this parameter is 20%.
	MaxBatchInstancePercent *int `json:"maxBatchInstancePercent,omitempty"`

	// +kubebuilder:validation:Maximum=100
	// +kubebuilder:validation:Minimum=5
	// MaxUnhealthyInstancePercent: The maximum percentage of the total virtual machine instances in the scale set that can be
	// simultaneously unhealthy, either as a result of being upgraded, or by being found in an unhealthy state by the virtual
	// machine health checks before the rolling upgrade aborts. This constraint will be checked prior to starting any batch.
	// The default value for this parameter is 20%.
	MaxUnhealthyInstancePercent *int `json:"maxUnhealthyInstancePercent,omitempty"`

	// +kubebuilder:validation:Maximum=100
	// +kubebuilder:validation:Minimum=0
	// MaxUnhealthyUpgradedInstancePercent: The maximum percentage of upgraded virtual machine instances that can be found to
	// be in an unhealthy state. This check will happen after each batch is upgraded. If this percentage is ever exceeded, the
	// rolling update aborts. The default value for this parameter is 20%.
	MaxUnhealthyUpgradedInstancePercent *int `json:"maxUnhealthyUpgradedInstancePercent,omitempty"`

	// PauseTimeBetweenBatches: The wait time between completing the update for all virtual machines in one batch and starting
	// the next batch. The time duration should be specified in ISO 8601 format. The default value is 0 seconds (PT0S).
	PauseTimeBetweenBatches *string `json:"pauseTimeBetweenBatches,omitempty"`

	// PrioritizeUnhealthyInstances: Upgrade all unhealthy instances in a scale set before any healthy instances.
	PrioritizeUnhealthyInstances *bool `json:"prioritizeUnhealthyInstances,omitempty"`
}

var _ genruntime.ARMTransformer = &RollingUpgradePolicy{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *RollingUpgradePolicy) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	result := &arm.RollingUpgradePolicy{}

	// Set property "EnableCrossZoneUpgrade":
	if policy.EnableCrossZoneUpgrade != nil {
		enableCrossZoneUpgrade := *policy.EnableCrossZoneUpgrade
		result.EnableCrossZoneUpgrade = &enableCrossZoneUpgrade
	}

	// Set property "MaxBatchInstancePercent":
	if policy.MaxBatchInstancePercent != nil {
		maxBatchInstancePercent := *policy.MaxBatchInstancePercent
		result.MaxBatchInstancePercent = &maxBatchInstancePercent
	}

	// Set property "MaxUnhealthyInstancePercent":
	if policy.MaxUnhealthyInstancePercent != nil {
		maxUnhealthyInstancePercent := *policy.MaxUnhealthyInstancePercent
		result.MaxUnhealthyInstancePercent = &maxUnhealthyInstancePercent
	}

	// Set property "MaxUnhealthyUpgradedInstancePercent":
	if policy.MaxUnhealthyUpgradedInstancePercent != nil {
		maxUnhealthyUpgradedInstancePercent := *policy.MaxUnhealthyUpgradedInstancePercent
		result.MaxUnhealthyUpgradedInstancePercent = &maxUnhealthyUpgradedInstancePercent
	}

	// Set property "PauseTimeBetweenBatches":
	if policy.PauseTimeBetweenBatches != nil {
		pauseTimeBetweenBatches := *policy.PauseTimeBetweenBatches
		result.PauseTimeBetweenBatches = &pauseTimeBetweenBatches
	}

	// Set property "PrioritizeUnhealthyInstances":
	if policy.PrioritizeUnhealthyInstances != nil {
		prioritizeUnhealthyInstances := *policy.PrioritizeUnhealthyInstances
		result.PrioritizeUnhealthyInstances = &prioritizeUnhealthyInstances
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *RollingUpgradePolicy) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RollingUpgradePolicy{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *RollingUpgradePolicy) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RollingUpgradePolicy)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RollingUpgradePolicy, got %T", armInput)
	}

	// Set property "EnableCrossZoneUpgrade":
	if typedInput.EnableCrossZoneUpgrade != nil {
		enableCrossZoneUpgrade := *typedInput.EnableCrossZoneUpgrade
		policy.EnableCrossZoneUpgrade = &enableCrossZoneUpgrade
	}

	// Set property "MaxBatchInstancePercent":
	if typedInput.MaxBatchInstancePercent != nil {
		maxBatchInstancePercent := *typedInput.MaxBatchInstancePercent
		policy.MaxBatchInstancePercent = &maxBatchInstancePercent
	}

	// Set property "MaxUnhealthyInstancePercent":
	if typedInput.MaxUnhealthyInstancePercent != nil {
		maxUnhealthyInstancePercent := *typedInput.MaxUnhealthyInstancePercent
		policy.MaxUnhealthyInstancePercent = &maxUnhealthyInstancePercent
	}

	// Set property "MaxUnhealthyUpgradedInstancePercent":
	if typedInput.MaxUnhealthyUpgradedInstancePercent != nil {
		maxUnhealthyUpgradedInstancePercent := *typedInput.MaxUnhealthyUpgradedInstancePercent
		policy.MaxUnhealthyUpgradedInstancePercent = &maxUnhealthyUpgradedInstancePercent
	}

	// Set property "PauseTimeBetweenBatches":
	if typedInput.PauseTimeBetweenBatches != nil {
		pauseTimeBetweenBatches := *typedInput.PauseTimeBetweenBatches
		policy.PauseTimeBetweenBatches = &pauseTimeBetweenBatches
	}

	// Set property "PrioritizeUnhealthyInstances":
	if typedInput.PrioritizeUnhealthyInstances != nil {
		prioritizeUnhealthyInstances := *typedInput.PrioritizeUnhealthyInstances
		policy.PrioritizeUnhealthyInstances = &prioritizeUnhealthyInstances
	}

	// No error
	return nil
}

// AssignProperties_From_RollingUpgradePolicy populates our RollingUpgradePolicy from the provided source RollingUpgradePolicy
func (policy *RollingUpgradePolicy) AssignProperties_From_RollingUpgradePolicy(source *storage.RollingUpgradePolicy) error {

	// EnableCrossZoneUpgrade
	if source.EnableCrossZoneUpgrade != nil {
		enableCrossZoneUpgrade := *source.EnableCrossZoneUpgrade
		policy.EnableCrossZoneUpgrade = &enableCrossZoneUpgrade
	} else {
		policy.EnableCrossZoneUpgrade = nil
	}

	// MaxBatchInstancePercent
	policy.MaxBatchInstancePercent = genruntime.ClonePointerToInt(source.MaxBatchInstancePercent)

	// MaxUnhealthyInstancePercent
	policy.MaxUnhealthyInstancePercent = genruntime.ClonePointerToInt(source.MaxUnhealthyInstancePercent)

	// MaxUnhealthyUpgradedInstancePercent
	policy.MaxUnhealthyUpgradedInstancePercent = genruntime.ClonePointerToInt(source.MaxUnhealthyUpgradedInstancePercent)

	// PauseTimeBetweenBatches
	policy.PauseTimeBetweenBatches = genruntime.ClonePointerToString(source.PauseTimeBetweenBatches)

	// PrioritizeUnhealthyInstances
	if source.PrioritizeUnhealthyInstances != nil {
		prioritizeUnhealthyInstance := *source.PrioritizeUnhealthyInstances
		policy.PrioritizeUnhealthyInstances = &prioritizeUnhealthyInstance
	} else {
		policy.PrioritizeUnhealthyInstances = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RollingUpgradePolicy populates the provided destination RollingUpgradePolicy from our RollingUpgradePolicy
func (policy *RollingUpgradePolicy) AssignProperties_To_RollingUpgradePolicy(destination *storage.RollingUpgradePolicy) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EnableCrossZoneUpgrade
	if policy.EnableCrossZoneUpgrade != nil {
		enableCrossZoneUpgrade := *policy.EnableCrossZoneUpgrade
		destination.EnableCrossZoneUpgrade = &enableCrossZoneUpgrade
	} else {
		destination.EnableCrossZoneUpgrade = nil
	}

	// MaxBatchInstancePercent
	destination.MaxBatchInstancePercent = genruntime.ClonePointerToInt(policy.MaxBatchInstancePercent)

	// MaxUnhealthyInstancePercent
	destination.MaxUnhealthyInstancePercent = genruntime.ClonePointerToInt(policy.MaxUnhealthyInstancePercent)

	// MaxUnhealthyUpgradedInstancePercent
	destination.MaxUnhealthyUpgradedInstancePercent = genruntime.ClonePointerToInt(policy.MaxUnhealthyUpgradedInstancePercent)

	// PauseTimeBetweenBatches
	destination.PauseTimeBetweenBatches = genruntime.ClonePointerToString(policy.PauseTimeBetweenBatches)

	// PrioritizeUnhealthyInstances
	if policy.PrioritizeUnhealthyInstances != nil {
		prioritizeUnhealthyInstance := *policy.PrioritizeUnhealthyInstances
		destination.PrioritizeUnhealthyInstances = &prioritizeUnhealthyInstance
	} else {
		destination.PrioritizeUnhealthyInstances = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RollingUpgradePolicy_STATUS populates our RollingUpgradePolicy from the provided source RollingUpgradePolicy_STATUS
func (policy *RollingUpgradePolicy) Initialize_From_RollingUpgradePolicy_STATUS(source *RollingUpgradePolicy_STATUS) error {

	// EnableCrossZoneUpgrade
	if source.EnableCrossZoneUpgrade != nil {
		enableCrossZoneUpgrade := *source.EnableCrossZoneUpgrade
		policy.EnableCrossZoneUpgrade = &enableCrossZoneUpgrade
	} else {
		policy.EnableCrossZoneUpgrade = nil
	}

	// MaxBatchInstancePercent
	policy.MaxBatchInstancePercent = genruntime.ClonePointerToInt(source.MaxBatchInstancePercent)

	// MaxUnhealthyInstancePercent
	policy.MaxUnhealthyInstancePercent = genruntime.ClonePointerToInt(source.MaxUnhealthyInstancePercent)

	// MaxUnhealthyUpgradedInstancePercent
	policy.MaxUnhealthyUpgradedInstancePercent = genruntime.ClonePointerToInt(source.MaxUnhealthyUpgradedInstancePercent)

	// PauseTimeBetweenBatches
	policy.PauseTimeBetweenBatches = genruntime.ClonePointerToString(source.PauseTimeBetweenBatches)

	// PrioritizeUnhealthyInstances
	if source.PrioritizeUnhealthyInstances != nil {
		prioritizeUnhealthyInstance := *source.PrioritizeUnhealthyInstances
		policy.PrioritizeUnhealthyInstances = &prioritizeUnhealthyInstance
	} else {
		policy.PrioritizeUnhealthyInstances = nil
	}

	// No error
	return nil
}

// The configuration parameters used while performing a rolling upgrade.
type RollingUpgradePolicy_STATUS struct {
	// EnableCrossZoneUpgrade: Allow VMSS to ignore AZ boundaries when constructing upgrade batches. Take into consideration
	// the Update Domain and maxBatchInstancePercent to determine the batch size.
	EnableCrossZoneUpgrade *bool `json:"enableCrossZoneUpgrade,omitempty"`

	// MaxBatchInstancePercent: The maximum percent of total virtual machine instances that will be upgraded simultaneously by
	// the rolling upgrade in one batch. As this is a maximum, unhealthy instances in previous or future batches can cause the
	// percentage of instances in a batch to decrease to ensure higher reliability. The default value for this parameter is 20%.
	MaxBatchInstancePercent *int `json:"maxBatchInstancePercent,omitempty"`

	// MaxUnhealthyInstancePercent: The maximum percentage of the total virtual machine instances in the scale set that can be
	// simultaneously unhealthy, either as a result of being upgraded, or by being found in an unhealthy state by the virtual
	// machine health checks before the rolling upgrade aborts. This constraint will be checked prior to starting any batch.
	// The default value for this parameter is 20%.
	MaxUnhealthyInstancePercent *int `json:"maxUnhealthyInstancePercent,omitempty"`

	// MaxUnhealthyUpgradedInstancePercent: The maximum percentage of upgraded virtual machine instances that can be found to
	// be in an unhealthy state. This check will happen after each batch is upgraded. If this percentage is ever exceeded, the
	// rolling update aborts. The default value for this parameter is 20%.
	MaxUnhealthyUpgradedInstancePercent *int `json:"maxUnhealthyUpgradedInstancePercent,omitempty"`

	// PauseTimeBetweenBatches: The wait time between completing the update for all virtual machines in one batch and starting
	// the next batch. The time duration should be specified in ISO 8601 format. The default value is 0 seconds (PT0S).
	PauseTimeBetweenBatches *string `json:"pauseTimeBetweenBatches,omitempty"`

	// PrioritizeUnhealthyInstances: Upgrade all unhealthy instances in a scale set before any healthy instances.
	PrioritizeUnhealthyInstances *bool `json:"prioritizeUnhealthyInstances,omitempty"`
}

var _ genruntime.FromARMConverter = &RollingUpgradePolicy_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *RollingUpgradePolicy_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RollingUpgradePolicy_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *RollingUpgradePolicy_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RollingUpgradePolicy_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RollingUpgradePolicy_STATUS, got %T", armInput)
	}

	// Set property "EnableCrossZoneUpgrade":
	if typedInput.EnableCrossZoneUpgrade != nil {
		enableCrossZoneUpgrade := *typedInput.EnableCrossZoneUpgrade
		policy.EnableCrossZoneUpgrade = &enableCrossZoneUpgrade
	}

	// Set property "MaxBatchInstancePercent":
	if typedInput.MaxBatchInstancePercent != nil {
		maxBatchInstancePercent := *typedInput.MaxBatchInstancePercent
		policy.MaxBatchInstancePercent = &maxBatchInstancePercent
	}

	// Set property "MaxUnhealthyInstancePercent":
	if typedInput.MaxUnhealthyInstancePercent != nil {
		maxUnhealthyInstancePercent := *typedInput.MaxUnhealthyInstancePercent
		policy.MaxUnhealthyInstancePercent = &maxUnhealthyInstancePercent
	}

	// Set property "MaxUnhealthyUpgradedInstancePercent":
	if typedInput.MaxUnhealthyUpgradedInstancePercent != nil {
		maxUnhealthyUpgradedInstancePercent := *typedInput.MaxUnhealthyUpgradedInstancePercent
		policy.MaxUnhealthyUpgradedInstancePercent = &maxUnhealthyUpgradedInstancePercent
	}

	// Set property "PauseTimeBetweenBatches":
	if typedInput.PauseTimeBetweenBatches != nil {
		pauseTimeBetweenBatches := *typedInput.PauseTimeBetweenBatches
		policy.PauseTimeBetweenBatches = &pauseTimeBetweenBatches
	}

	// Set property "PrioritizeUnhealthyInstances":
	if typedInput.PrioritizeUnhealthyInstances != nil {
		prioritizeUnhealthyInstances := *typedInput.PrioritizeUnhealthyInstances
		policy.PrioritizeUnhealthyInstances = &prioritizeUnhealthyInstances
	}

	// No error
	return nil
}

// AssignProperties_From_RollingUpgradePolicy_STATUS populates our RollingUpgradePolicy_STATUS from the provided source RollingUpgradePolicy_STATUS
func (policy *RollingUpgradePolicy_STATUS) AssignProperties_From_RollingUpgradePolicy_STATUS(source *storage.RollingUpgradePolicy_STATUS) error {

	// EnableCrossZoneUpgrade
	if source.EnableCrossZoneUpgrade != nil {
		enableCrossZoneUpgrade := *source.EnableCrossZoneUpgrade
		policy.EnableCrossZoneUpgrade = &enableCrossZoneUpgrade
	} else {
		policy.EnableCrossZoneUpgrade = nil
	}

	// MaxBatchInstancePercent
	policy.MaxBatchInstancePercent = genruntime.ClonePointerToInt(source.MaxBatchInstancePercent)

	// MaxUnhealthyInstancePercent
	policy.MaxUnhealthyInstancePercent = genruntime.ClonePointerToInt(source.MaxUnhealthyInstancePercent)

	// MaxUnhealthyUpgradedInstancePercent
	policy.MaxUnhealthyUpgradedInstancePercent = genruntime.ClonePointerToInt(source.MaxUnhealthyUpgradedInstancePercent)

	// PauseTimeBetweenBatches
	policy.PauseTimeBetweenBatches = genruntime.ClonePointerToString(source.PauseTimeBetweenBatches)

	// PrioritizeUnhealthyInstances
	if source.PrioritizeUnhealthyInstances != nil {
		prioritizeUnhealthyInstance := *source.PrioritizeUnhealthyInstances
		policy.PrioritizeUnhealthyInstances = &prioritizeUnhealthyInstance
	} else {
		policy.PrioritizeUnhealthyInstances = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RollingUpgradePolicy_STATUS populates the provided destination RollingUpgradePolicy_STATUS from our RollingUpgradePolicy_STATUS
func (policy *RollingUpgradePolicy_STATUS) AssignProperties_To_RollingUpgradePolicy_STATUS(destination *storage.RollingUpgradePolicy_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EnableCrossZoneUpgrade
	if policy.EnableCrossZoneUpgrade != nil {
		enableCrossZoneUpgrade := *policy.EnableCrossZoneUpgrade
		destination.EnableCrossZoneUpgrade = &enableCrossZoneUpgrade
	} else {
		destination.EnableCrossZoneUpgrade = nil
	}

	// MaxBatchInstancePercent
	destination.MaxBatchInstancePercent = genruntime.ClonePointerToInt(policy.MaxBatchInstancePercent)

	// MaxUnhealthyInstancePercent
	destination.MaxUnhealthyInstancePercent = genruntime.ClonePointerToInt(policy.MaxUnhealthyInstancePercent)

	// MaxUnhealthyUpgradedInstancePercent
	destination.MaxUnhealthyUpgradedInstancePercent = genruntime.ClonePointerToInt(policy.MaxUnhealthyUpgradedInstancePercent)

	// PauseTimeBetweenBatches
	destination.PauseTimeBetweenBatches = genruntime.ClonePointerToString(policy.PauseTimeBetweenBatches)

	// PrioritizeUnhealthyInstances
	if policy.PrioritizeUnhealthyInstances != nil {
		prioritizeUnhealthyInstance := *policy.PrioritizeUnhealthyInstances
		destination.PrioritizeUnhealthyInstances = &prioritizeUnhealthyInstance
	} else {
		destination.PrioritizeUnhealthyInstances = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Default","NewestVM","OldestVM"}
type ScaleInPolicy_Rules string

const (
	ScaleInPolicy_Rules_Default  = ScaleInPolicy_Rules("Default")
	ScaleInPolicy_Rules_NewestVM = ScaleInPolicy_Rules("NewestVM")
	ScaleInPolicy_Rules_OldestVM = ScaleInPolicy_Rules("OldestVM")
)

// Mapping from string to ScaleInPolicy_Rules
var scaleInPolicy_Rules_Values = map[string]ScaleInPolicy_Rules{
	"default":  ScaleInPolicy_Rules_Default,
	"newestvm": ScaleInPolicy_Rules_NewestVM,
	"oldestvm": ScaleInPolicy_Rules_OldestVM,
}

type ScaleInPolicy_Rules_STATUS string

const (
	ScaleInPolicy_Rules_STATUS_Default  = ScaleInPolicy_Rules_STATUS("Default")
	ScaleInPolicy_Rules_STATUS_NewestVM = ScaleInPolicy_Rules_STATUS("NewestVM")
	ScaleInPolicy_Rules_STATUS_OldestVM = ScaleInPolicy_Rules_STATUS("OldestVM")
)

// Mapping from string to ScaleInPolicy_Rules_STATUS
var scaleInPolicy_Rules_STATUS_Values = map[string]ScaleInPolicy_Rules_STATUS{
	"default":  ScaleInPolicy_Rules_STATUS_Default,
	"newestvm": ScaleInPolicy_Rules_STATUS_NewestVM,
	"oldestvm": ScaleInPolicy_Rules_STATUS_OldestVM,
}

// +kubebuilder:validation:Enum={"Automatic","Manual","Rolling"}
type UpgradePolicy_Mode string

const (
	UpgradePolicy_Mode_Automatic = UpgradePolicy_Mode("Automatic")
	UpgradePolicy_Mode_Manual    = UpgradePolicy_Mode("Manual")
	UpgradePolicy_Mode_Rolling   = UpgradePolicy_Mode("Rolling")
)

// Mapping from string to UpgradePolicy_Mode
var upgradePolicy_Mode_Values = map[string]UpgradePolicy_Mode{
	"automatic": UpgradePolicy_Mode_Automatic,
	"manual":    UpgradePolicy_Mode_Manual,
	"rolling":   UpgradePolicy_Mode_Rolling,
}

type UpgradePolicy_Mode_STATUS string

const (
	UpgradePolicy_Mode_STATUS_Automatic = UpgradePolicy_Mode_STATUS("Automatic")
	UpgradePolicy_Mode_STATUS_Manual    = UpgradePolicy_Mode_STATUS("Manual")
	UpgradePolicy_Mode_STATUS_Rolling   = UpgradePolicy_Mode_STATUS("Rolling")
)

// Mapping from string to UpgradePolicy_Mode_STATUS
var upgradePolicy_Mode_STATUS_Values = map[string]UpgradePolicy_Mode_STATUS{
	"automatic": UpgradePolicy_Mode_STATUS_Automatic,
	"manual":    UpgradePolicy_Mode_STATUS_Manual,
	"rolling":   UpgradePolicy_Mode_STATUS_Rolling,
}

// Describes a virtual machine scale set extension profile.
type VirtualMachineScaleSetExtensionProfile struct {
	// Extensions: The virtual machine scale set child extension resources.
	Extensions []VirtualMachineScaleSetExtension `json:"extensions,omitempty"`

	// ExtensionsTimeBudget: Specifies the time alloted for all extensions to start. The time duration should be between 15
	// minutes and 120 minutes (inclusive) and should be specified in ISO 8601 format. The default value is 90 minutes
	// (PT1H30M).
	// Minimum api-version: 2020-06-01
	ExtensionsTimeBudget *string `json:"extensionsTimeBudget,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetExtensionProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *VirtualMachineScaleSetExtensionProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.VirtualMachineScaleSetExtensionProfile{}

	// Set property "Extensions":
	for _, item := range profile.Extensions {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Extensions = append(result.Extensions, *item_ARM.(*arm.VirtualMachineScaleSetExtension))
	}

	// Set property "ExtensionsTimeBudget":
	if profile.ExtensionsTimeBudget != nil {
		extensionsTimeBudget := *profile.ExtensionsTimeBudget
		result.ExtensionsTimeBudget = &extensionsTimeBudget
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSetExtensionProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSetExtensionProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSetExtensionProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSetExtensionProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSetExtensionProfile, got %T", armInput)
	}

	// Set property "Extensions":
	for _, item := range typedInput.Extensions {
		var item1 VirtualMachineScaleSetExtension
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.Extensions = append(profile.Extensions, item1)
	}

	// Set property "ExtensionsTimeBudget":
	if typedInput.ExtensionsTimeBudget != nil {
		extensionsTimeBudget := *typedInput.ExtensionsTimeBudget
		profile.ExtensionsTimeBudget = &extensionsTimeBudget
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSetExtensionProfile populates our VirtualMachineScaleSetExtensionProfile from the provided source VirtualMachineScaleSetExtensionProfile
func (profile *VirtualMachineScaleSetExtensionProfile) AssignProperties_From_VirtualMachineScaleSetExtensionProfile(source *storage.VirtualMachineScaleSetExtensionProfile) error {

	// Extensions
	if source.Extensions != nil {
		extensionList := make([]VirtualMachineScaleSetExtension, len(source.Extensions))
		for extensionIndex, extensionItem := range source.Extensions {
			// Shadow the loop variable to avoid aliasing
			extensionItem := extensionItem
			var extension VirtualMachineScaleSetExtension
			err := extension.AssignProperties_From_VirtualMachineScaleSetExtension(&extensionItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetExtension() to populate field Extensions")
			}
			extensionList[extensionIndex] = extension
		}
		profile.Extensions = extensionList
	} else {
		profile.Extensions = nil
	}

	// ExtensionsTimeBudget
	profile.ExtensionsTimeBudget = genruntime.ClonePointerToString(source.ExtensionsTimeBudget)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetExtensionProfile populates the provided destination VirtualMachineScaleSetExtensionProfile from our VirtualMachineScaleSetExtensionProfile
func (profile *VirtualMachineScaleSetExtensionProfile) AssignProperties_To_VirtualMachineScaleSetExtensionProfile(destination *storage.VirtualMachineScaleSetExtensionProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Extensions
	if profile.Extensions != nil {
		extensionList := make([]storage.VirtualMachineScaleSetExtension, len(profile.Extensions))
		for extensionIndex, extensionItem := range profile.Extensions {
			// Shadow the loop variable to avoid aliasing
			extensionItem := extensionItem
			var extension storage.VirtualMachineScaleSetExtension
			err := extensionItem.AssignProperties_To_VirtualMachineScaleSetExtension(&extension)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetExtension() to populate field Extensions")
			}
			extensionList[extensionIndex] = extension
		}
		destination.Extensions = extensionList
	} else {
		destination.Extensions = nil
	}

	// ExtensionsTimeBudget
	destination.ExtensionsTimeBudget = genruntime.ClonePointerToString(profile.ExtensionsTimeBudget)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualMachineScaleSetExtensionProfile_STATUS populates our VirtualMachineScaleSetExtensionProfile from the provided source VirtualMachineScaleSetExtensionProfile_STATUS
func (profile *VirtualMachineScaleSetExtensionProfile) Initialize_From_VirtualMachineScaleSetExtensionProfile_STATUS(source *VirtualMachineScaleSetExtensionProfile_STATUS) error {

	// Extensions
	if source.Extensions != nil {
		extensionList := make([]VirtualMachineScaleSetExtension, len(source.Extensions))
		for extensionIndex, extensionItem := range source.Extensions {
			// Shadow the loop variable to avoid aliasing
			extensionItem := extensionItem
			var extension VirtualMachineScaleSetExtension
			err := extension.Initialize_From_VirtualMachineScaleSetExtension_STATUS(&extensionItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_VirtualMachineScaleSetExtension_STATUS() to populate field Extensions")
			}
			extensionList[extensionIndex] = extension
		}
		profile.Extensions = extensionList
	} else {
		profile.Extensions = nil
	}

	// ExtensionsTimeBudget
	profile.ExtensionsTimeBudget = genruntime.ClonePointerToString(source.ExtensionsTimeBudget)

	// No error
	return nil
}

// Describes a virtual machine scale set extension profile.
type VirtualMachineScaleSetExtensionProfile_STATUS struct {
	// Extensions: The virtual machine scale set child extension resources.
	Extensions []VirtualMachineScaleSetExtension_STATUS `json:"extensions,omitempty"`

	// ExtensionsTimeBudget: Specifies the time alloted for all extensions to start. The time duration should be between 15
	// minutes and 120 minutes (inclusive) and should be specified in ISO 8601 format. The default value is 90 minutes
	// (PT1H30M).
	// Minimum api-version: 2020-06-01
	ExtensionsTimeBudget *string `json:"extensionsTimeBudget,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetExtensionProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSetExtensionProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSetExtensionProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSetExtensionProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSetExtensionProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSetExtensionProfile_STATUS, got %T", armInput)
	}

	// Set property "Extensions":
	for _, item := range typedInput.Extensions {
		var item1 VirtualMachineScaleSetExtension_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.Extensions = append(profile.Extensions, item1)
	}

	// Set property "ExtensionsTimeBudget":
	if typedInput.ExtensionsTimeBudget != nil {
		extensionsTimeBudget := *typedInput.ExtensionsTimeBudget
		profile.ExtensionsTimeBudget = &extensionsTimeBudget
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSetExtensionProfile_STATUS populates our VirtualMachineScaleSetExtensionProfile_STATUS from the provided source VirtualMachineScaleSetExtensionProfile_STATUS
func (profile *VirtualMachineScaleSetExtensionProfile_STATUS) AssignProperties_From_VirtualMachineScaleSetExtensionProfile_STATUS(source *storage.VirtualMachineScaleSetExtensionProfile_STATUS) error {

	// Extensions
	if source.Extensions != nil {
		extensionList := make([]VirtualMachineScaleSetExtension_STATUS, len(source.Extensions))
		for extensionIndex, extensionItem := range source.Extensions {
			// Shadow the loop variable to avoid aliasing
			extensionItem := extensionItem
			var extension VirtualMachineScaleSetExtension_STATUS
			err := extension.AssignProperties_From_VirtualMachineScaleSetExtension_STATUS(&extensionItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetExtension_STATUS() to populate field Extensions")
			}
			extensionList[extensionIndex] = extension
		}
		profile.Extensions = extensionList
	} else {
		profile.Extensions = nil
	}

	// ExtensionsTimeBudget
	profile.ExtensionsTimeBudget = genruntime.ClonePointerToString(source.ExtensionsTimeBudget)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetExtensionProfile_STATUS populates the provided destination VirtualMachineScaleSetExtensionProfile_STATUS from our VirtualMachineScaleSetExtensionProfile_STATUS
func (profile *VirtualMachineScaleSetExtensionProfile_STATUS) AssignProperties_To_VirtualMachineScaleSetExtensionProfile_STATUS(destination *storage.VirtualMachineScaleSetExtensionProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Extensions
	if profile.Extensions != nil {
		extensionList := make([]storage.VirtualMachineScaleSetExtension_STATUS, len(profile.Extensions))
		for extensionIndex, extensionItem := range profile.Extensions {
			// Shadow the loop variable to avoid aliasing
			extensionItem := extensionItem
			var extension storage.VirtualMachineScaleSetExtension_STATUS
			err := extensionItem.AssignProperties_To_VirtualMachineScaleSetExtension_STATUS(&extension)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetExtension_STATUS() to populate field Extensions")
			}
			extensionList[extensionIndex] = extension
		}
		destination.Extensions = extensionList
	} else {
		destination.Extensions = nil
	}

	// ExtensionsTimeBudget
	destination.ExtensionsTimeBudget = genruntime.ClonePointerToString(profile.ExtensionsTimeBudget)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Specifies the hardware settings for the virtual machine scale set.
type VirtualMachineScaleSetHardwareProfile struct {
	// VmSizeProperties: Specifies the properties for customizing the size of the virtual machine. Minimum api-version:
	// 2022-03-01.
	// Please follow the instructions in [VM Customization](https://aka.ms/vmcustomization) for more details.
	VmSizeProperties *VMSizeProperties `json:"vmSizeProperties,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetHardwareProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *VirtualMachineScaleSetHardwareProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.VirtualMachineScaleSetHardwareProfile{}

	// Set property "VmSizeProperties":
	if profile.VmSizeProperties != nil {
		vmSizeProperties_ARM, err := (*profile.VmSizeProperties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		vmSizeProperties := *vmSizeProperties_ARM.(*arm.VMSizeProperties)
		result.VmSizeProperties = &vmSizeProperties
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSetHardwareProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSetHardwareProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSetHardwareProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSetHardwareProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSetHardwareProfile, got %T", armInput)
	}

	// Set property "VmSizeProperties":
	if typedInput.VmSizeProperties != nil {
		var vmSizeProperties1 VMSizeProperties
		err := vmSizeProperties1.PopulateFromARM(owner, *typedInput.VmSizeProperties)
		if err != nil {
			return err
		}
		vmSizeProperties := vmSizeProperties1
		profile.VmSizeProperties = &vmSizeProperties
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSetHardwareProfile populates our VirtualMachineScaleSetHardwareProfile from the provided source VirtualMachineScaleSetHardwareProfile
func (profile *VirtualMachineScaleSetHardwareProfile) AssignProperties_From_VirtualMachineScaleSetHardwareProfile(source *storage.VirtualMachineScaleSetHardwareProfile) error {

	// VmSizeProperties
	if source.VmSizeProperties != nil {
		var vmSizeProperty VMSizeProperties
		err := vmSizeProperty.AssignProperties_From_VMSizeProperties(source.VmSizeProperties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VMSizeProperties() to populate field VmSizeProperties")
		}
		profile.VmSizeProperties = &vmSizeProperty
	} else {
		profile.VmSizeProperties = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetHardwareProfile populates the provided destination VirtualMachineScaleSetHardwareProfile from our VirtualMachineScaleSetHardwareProfile
func (profile *VirtualMachineScaleSetHardwareProfile) AssignProperties_To_VirtualMachineScaleSetHardwareProfile(destination *storage.VirtualMachineScaleSetHardwareProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// VmSizeProperties
	if profile.VmSizeProperties != nil {
		var vmSizeProperty storage.VMSizeProperties
		err := profile.VmSizeProperties.AssignProperties_To_VMSizeProperties(&vmSizeProperty)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VMSizeProperties() to populate field VmSizeProperties")
		}
		destination.VmSizeProperties = &vmSizeProperty
	} else {
		destination.VmSizeProperties = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualMachineScaleSetHardwareProfile_STATUS populates our VirtualMachineScaleSetHardwareProfile from the provided source VirtualMachineScaleSetHardwareProfile_STATUS
func (profile *VirtualMachineScaleSetHardwareProfile) Initialize_From_VirtualMachineScaleSetHardwareProfile_STATUS(source *VirtualMachineScaleSetHardwareProfile_STATUS) error {

	// VmSizeProperties
	if source.VmSizeProperties != nil {
		var vmSizeProperty VMSizeProperties
		err := vmSizeProperty.Initialize_From_VMSizeProperties_STATUS(source.VmSizeProperties)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_VMSizeProperties_STATUS() to populate field VmSizeProperties")
		}
		profile.VmSizeProperties = &vmSizeProperty
	} else {
		profile.VmSizeProperties = nil
	}

	// No error
	return nil
}

// Specifies the hardware settings for the virtual machine scale set.
type VirtualMachineScaleSetHardwareProfile_STATUS struct {
	// VmSizeProperties: Specifies the properties for customizing the size of the virtual machine. Minimum api-version:
	// 2022-03-01.
	// Please follow the instructions in [VM Customization](https://aka.ms/vmcustomization) for more details.
	VmSizeProperties *VMSizeProperties_STATUS `json:"vmSizeProperties,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetHardwareProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSetHardwareProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSetHardwareProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSetHardwareProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSetHardwareProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSetHardwareProfile_STATUS, got %T", armInput)
	}

	// Set property "VmSizeProperties":
	if typedInput.VmSizeProperties != nil {
		var vmSizeProperties1 VMSizeProperties_STATUS
		err := vmSizeProperties1.PopulateFromARM(owner, *typedInput.VmSizeProperties)
		if err != nil {
			return err
		}
		vmSizeProperties := vmSizeProperties1
		profile.VmSizeProperties = &vmSizeProperties
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSetHardwareProfile_STATUS populates our VirtualMachineScaleSetHardwareProfile_STATUS from the provided source VirtualMachineScaleSetHardwareProfile_STATUS
func (profile *VirtualMachineScaleSetHardwareProfile_STATUS) AssignProperties_From_VirtualMachineScaleSetHardwareProfile_STATUS(source *storage.VirtualMachineScaleSetHardwareProfile_STATUS) error {

	// VmSizeProperties
	if source.VmSizeProperties != nil {
		var vmSizeProperty VMSizeProperties_STATUS
		err := vmSizeProperty.AssignProperties_From_VMSizeProperties_STATUS(source.VmSizeProperties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VMSizeProperties_STATUS() to populate field VmSizeProperties")
		}
		profile.VmSizeProperties = &vmSizeProperty
	} else {
		profile.VmSizeProperties = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetHardwareProfile_STATUS populates the provided destination VirtualMachineScaleSetHardwareProfile_STATUS from our VirtualMachineScaleSetHardwareProfile_STATUS
func (profile *VirtualMachineScaleSetHardwareProfile_STATUS) AssignProperties_To_VirtualMachineScaleSetHardwareProfile_STATUS(destination *storage.VirtualMachineScaleSetHardwareProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// VmSizeProperties
	if profile.VmSizeProperties != nil {
		var vmSizeProperty storage.VMSizeProperties_STATUS
		err := profile.VmSizeProperties.AssignProperties_To_VMSizeProperties_STATUS(&vmSizeProperty)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VMSizeProperties_STATUS() to populate field VmSizeProperties")
		}
		destination.VmSizeProperties = &vmSizeProperty
	} else {
		destination.VmSizeProperties = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"None","SystemAssigned","SystemAssigned, UserAssigned","UserAssigned"}
type VirtualMachineScaleSetIdentity_Type string

const (
	VirtualMachineScaleSetIdentity_Type_None                       = VirtualMachineScaleSetIdentity_Type("None")
	VirtualMachineScaleSetIdentity_Type_SystemAssigned             = VirtualMachineScaleSetIdentity_Type("SystemAssigned")
	VirtualMachineScaleSetIdentity_Type_SystemAssignedUserAssigned = VirtualMachineScaleSetIdentity_Type("SystemAssigned, UserAssigned")
	VirtualMachineScaleSetIdentity_Type_UserAssigned               = VirtualMachineScaleSetIdentity_Type("UserAssigned")
)

// Mapping from string to VirtualMachineScaleSetIdentity_Type
var virtualMachineScaleSetIdentity_Type_Values = map[string]VirtualMachineScaleSetIdentity_Type{
	"none":                         VirtualMachineScaleSetIdentity_Type_None,
	"systemassigned":               VirtualMachineScaleSetIdentity_Type_SystemAssigned,
	"systemassigned, userassigned": VirtualMachineScaleSetIdentity_Type_SystemAssignedUserAssigned,
	"userassigned":                 VirtualMachineScaleSetIdentity_Type_UserAssigned,
}

type VirtualMachineScaleSetIdentity_Type_STATUS string

const (
	VirtualMachineScaleSetIdentity_Type_STATUS_None                       = VirtualMachineScaleSetIdentity_Type_STATUS("None")
	VirtualMachineScaleSetIdentity_Type_STATUS_SystemAssigned             = VirtualMachineScaleSetIdentity_Type_STATUS("SystemAssigned")
	VirtualMachineScaleSetIdentity_Type_STATUS_SystemAssignedUserAssigned = VirtualMachineScaleSetIdentity_Type_STATUS("SystemAssigned, UserAssigned")
	VirtualMachineScaleSetIdentity_Type_STATUS_UserAssigned               = VirtualMachineScaleSetIdentity_Type_STATUS("UserAssigned")
)

// Mapping from string to VirtualMachineScaleSetIdentity_Type_STATUS
var virtualMachineScaleSetIdentity_Type_STATUS_Values = map[string]VirtualMachineScaleSetIdentity_Type_STATUS{
	"none":                         VirtualMachineScaleSetIdentity_Type_STATUS_None,
	"systemassigned":               VirtualMachineScaleSetIdentity_Type_STATUS_SystemAssigned,
	"systemassigned, userassigned": VirtualMachineScaleSetIdentity_Type_STATUS_SystemAssignedUserAssigned,
	"userassigned":                 VirtualMachineScaleSetIdentity_Type_STATUS_UserAssigned,
}

type VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS struct {
	// ClientId: The client id of user assigned identity.
	ClientId *string `json:"clientId,omitempty"`

	// PrincipalId: The principal id of user assigned identity.
	PrincipalId *string `json:"principalId,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identities *VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identities *VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		identities.ClientId = &clientId
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identities.PrincipalId = &principalId
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS populates our VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS from the provided source VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS
func (identities *VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS) AssignProperties_From_VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS(source *storage.VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS) error {

	// ClientId
	identities.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// PrincipalId
	identities.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS populates the provided destination VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS from our VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS
func (identities *VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS) AssignProperties_To_VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS(destination *storage.VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identities.ClientId)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identities.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes a virtual machine scale set network profile.
type VirtualMachineScaleSetNetworkProfile struct {
	// HealthProbe: A reference to a load balancer probe used to determine the health of an instance in the virtual machine
	// scale set. The reference will be in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/probes/{probeName}'.
	HealthProbe *ApiEntityReference `json:"healthProbe,omitempty"`

	// NetworkApiVersion: specifies the Microsoft.Network API version used when creating networking resources in the Network
	// Interface Configurations for Virtual Machine Scale Set with orchestration mode 'Flexible'
	NetworkApiVersion *VirtualMachineScaleSetNetworkProfile_NetworkApiVersion `json:"networkApiVersion,omitempty"`

	// NetworkInterfaceConfigurations: The list of network configurations.
	NetworkInterfaceConfigurations []VirtualMachineScaleSetNetworkConfiguration `json:"networkInterfaceConfigurations,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetNetworkProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *VirtualMachineScaleSetNetworkProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.VirtualMachineScaleSetNetworkProfile{}

	// Set property "HealthProbe":
	if profile.HealthProbe != nil {
		healthProbe_ARM, err := (*profile.HealthProbe).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		healthProbe := *healthProbe_ARM.(*arm.ApiEntityReference)
		result.HealthProbe = &healthProbe
	}

	// Set property "NetworkApiVersion":
	if profile.NetworkApiVersion != nil {
		var temp string
		temp = string(*profile.NetworkApiVersion)
		networkApiVersion := arm.VirtualMachineScaleSetNetworkProfile_NetworkApiVersion(temp)
		result.NetworkApiVersion = &networkApiVersion
	}

	// Set property "NetworkInterfaceConfigurations":
	for _, item := range profile.NetworkInterfaceConfigurations {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.NetworkInterfaceConfigurations = append(result.NetworkInterfaceConfigurations, *item_ARM.(*arm.VirtualMachineScaleSetNetworkConfiguration))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSetNetworkProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSetNetworkProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSetNetworkProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSetNetworkProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSetNetworkProfile, got %T", armInput)
	}

	// Set property "HealthProbe":
	if typedInput.HealthProbe != nil {
		var healthProbe1 ApiEntityReference
		err := healthProbe1.PopulateFromARM(owner, *typedInput.HealthProbe)
		if err != nil {
			return err
		}
		healthProbe := healthProbe1
		profile.HealthProbe = &healthProbe
	}

	// Set property "NetworkApiVersion":
	if typedInput.NetworkApiVersion != nil {
		var temp string
		temp = string(*typedInput.NetworkApiVersion)
		networkApiVersion := VirtualMachineScaleSetNetworkProfile_NetworkApiVersion(temp)
		profile.NetworkApiVersion = &networkApiVersion
	}

	// Set property "NetworkInterfaceConfigurations":
	for _, item := range typedInput.NetworkInterfaceConfigurations {
		var item1 VirtualMachineScaleSetNetworkConfiguration
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.NetworkInterfaceConfigurations = append(profile.NetworkInterfaceConfigurations, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSetNetworkProfile populates our VirtualMachineScaleSetNetworkProfile from the provided source VirtualMachineScaleSetNetworkProfile
func (profile *VirtualMachineScaleSetNetworkProfile) AssignProperties_From_VirtualMachineScaleSetNetworkProfile(source *storage.VirtualMachineScaleSetNetworkProfile) error {

	// HealthProbe
	if source.HealthProbe != nil {
		var healthProbe ApiEntityReference
		err := healthProbe.AssignProperties_From_ApiEntityReference(source.HealthProbe)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ApiEntityReference() to populate field HealthProbe")
		}
		profile.HealthProbe = &healthProbe
	} else {
		profile.HealthProbe = nil
	}

	// NetworkApiVersion
	if source.NetworkApiVersion != nil {
		networkApiVersion := *source.NetworkApiVersion
		networkApiVersionTemp := genruntime.ToEnum(networkApiVersion, virtualMachineScaleSetNetworkProfile_NetworkApiVersion_Values)
		profile.NetworkApiVersion = &networkApiVersionTemp
	} else {
		profile.NetworkApiVersion = nil
	}

	// NetworkInterfaceConfigurations
	if source.NetworkInterfaceConfigurations != nil {
		networkInterfaceConfigurationList := make([]VirtualMachineScaleSetNetworkConfiguration, len(source.NetworkInterfaceConfigurations))
		for networkInterfaceConfigurationIndex, networkInterfaceConfigurationItem := range source.NetworkInterfaceConfigurations {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceConfigurationItem := networkInterfaceConfigurationItem
			var networkInterfaceConfiguration VirtualMachineScaleSetNetworkConfiguration
			err := networkInterfaceConfiguration.AssignProperties_From_VirtualMachineScaleSetNetworkConfiguration(&networkInterfaceConfigurationItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetNetworkConfiguration() to populate field NetworkInterfaceConfigurations")
			}
			networkInterfaceConfigurationList[networkInterfaceConfigurationIndex] = networkInterfaceConfiguration
		}
		profile.NetworkInterfaceConfigurations = networkInterfaceConfigurationList
	} else {
		profile.NetworkInterfaceConfigurations = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetNetworkProfile populates the provided destination VirtualMachineScaleSetNetworkProfile from our VirtualMachineScaleSetNetworkProfile
func (profile *VirtualMachineScaleSetNetworkProfile) AssignProperties_To_VirtualMachineScaleSetNetworkProfile(destination *storage.VirtualMachineScaleSetNetworkProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HealthProbe
	if profile.HealthProbe != nil {
		var healthProbe storage.ApiEntityReference
		err := profile.HealthProbe.AssignProperties_To_ApiEntityReference(&healthProbe)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ApiEntityReference() to populate field HealthProbe")
		}
		destination.HealthProbe = &healthProbe
	} else {
		destination.HealthProbe = nil
	}

	// NetworkApiVersion
	if profile.NetworkApiVersion != nil {
		networkApiVersion := string(*profile.NetworkApiVersion)
		destination.NetworkApiVersion = &networkApiVersion
	} else {
		destination.NetworkApiVersion = nil
	}

	// NetworkInterfaceConfigurations
	if profile.NetworkInterfaceConfigurations != nil {
		networkInterfaceConfigurationList := make([]storage.VirtualMachineScaleSetNetworkConfiguration, len(profile.NetworkInterfaceConfigurations))
		for networkInterfaceConfigurationIndex, networkInterfaceConfigurationItem := range profile.NetworkInterfaceConfigurations {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceConfigurationItem := networkInterfaceConfigurationItem
			var networkInterfaceConfiguration storage.VirtualMachineScaleSetNetworkConfiguration
			err := networkInterfaceConfigurationItem.AssignProperties_To_VirtualMachineScaleSetNetworkConfiguration(&networkInterfaceConfiguration)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetNetworkConfiguration() to populate field NetworkInterfaceConfigurations")
			}
			networkInterfaceConfigurationList[networkInterfaceConfigurationIndex] = networkInterfaceConfiguration
		}
		destination.NetworkInterfaceConfigurations = networkInterfaceConfigurationList
	} else {
		destination.NetworkInterfaceConfigurations = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualMachineScaleSetNetworkProfile_STATUS populates our VirtualMachineScaleSetNetworkProfile from the provided source VirtualMachineScaleSetNetworkProfile_STATUS
func (profile *VirtualMachineScaleSetNetworkProfile) Initialize_From_VirtualMachineScaleSetNetworkProfile_STATUS(source *VirtualMachineScaleSetNetworkProfile_STATUS) error {

	// HealthProbe
	if source.HealthProbe != nil {
		var healthProbe ApiEntityReference
		err := healthProbe.Initialize_From_ApiEntityReference_STATUS(source.HealthProbe)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ApiEntityReference_STATUS() to populate field HealthProbe")
		}
		profile.HealthProbe = &healthProbe
	} else {
		profile.HealthProbe = nil
	}

	// NetworkApiVersion
	if source.NetworkApiVersion != nil {
		networkApiVersion := genruntime.ToEnum(string(*source.NetworkApiVersion), virtualMachineScaleSetNetworkProfile_NetworkApiVersion_Values)
		profile.NetworkApiVersion = &networkApiVersion
	} else {
		profile.NetworkApiVersion = nil
	}

	// NetworkInterfaceConfigurations
	if source.NetworkInterfaceConfigurations != nil {
		networkInterfaceConfigurationList := make([]VirtualMachineScaleSetNetworkConfiguration, len(source.NetworkInterfaceConfigurations))
		for networkInterfaceConfigurationIndex, networkInterfaceConfigurationItem := range source.NetworkInterfaceConfigurations {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceConfigurationItem := networkInterfaceConfigurationItem
			var networkInterfaceConfiguration VirtualMachineScaleSetNetworkConfiguration
			err := networkInterfaceConfiguration.Initialize_From_VirtualMachineScaleSetNetworkConfiguration_STATUS(&networkInterfaceConfigurationItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_VirtualMachineScaleSetNetworkConfiguration_STATUS() to populate field NetworkInterfaceConfigurations")
			}
			networkInterfaceConfigurationList[networkInterfaceConfigurationIndex] = networkInterfaceConfiguration
		}
		profile.NetworkInterfaceConfigurations = networkInterfaceConfigurationList
	} else {
		profile.NetworkInterfaceConfigurations = nil
	}

	// No error
	return nil
}

// Describes a virtual machine scale set network profile.
type VirtualMachineScaleSetNetworkProfile_STATUS struct {
	// HealthProbe: A reference to a load balancer probe used to determine the health of an instance in the virtual machine
	// scale set. The reference will be in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/probes/{probeName}'.
	HealthProbe *ApiEntityReference_STATUS `json:"healthProbe,omitempty"`

	// NetworkApiVersion: specifies the Microsoft.Network API version used when creating networking resources in the Network
	// Interface Configurations for Virtual Machine Scale Set with orchestration mode 'Flexible'
	NetworkApiVersion *VirtualMachineScaleSetNetworkProfile_NetworkApiVersion_STATUS `json:"networkApiVersion,omitempty"`

	// NetworkInterfaceConfigurations: The list of network configurations.
	NetworkInterfaceConfigurations []VirtualMachineScaleSetNetworkConfiguration_STATUS `json:"networkInterfaceConfigurations,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetNetworkProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSetNetworkProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSetNetworkProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSetNetworkProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSetNetworkProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSetNetworkProfile_STATUS, got %T", armInput)
	}

	// Set property "HealthProbe":
	if typedInput.HealthProbe != nil {
		var healthProbe1 ApiEntityReference_STATUS
		err := healthProbe1.PopulateFromARM(owner, *typedInput.HealthProbe)
		if err != nil {
			return err
		}
		healthProbe := healthProbe1
		profile.HealthProbe = &healthProbe
	}

	// Set property "NetworkApiVersion":
	if typedInput.NetworkApiVersion != nil {
		var temp string
		temp = string(*typedInput.NetworkApiVersion)
		networkApiVersion := VirtualMachineScaleSetNetworkProfile_NetworkApiVersion_STATUS(temp)
		profile.NetworkApiVersion = &networkApiVersion
	}

	// Set property "NetworkInterfaceConfigurations":
	for _, item := range typedInput.NetworkInterfaceConfigurations {
		var item1 VirtualMachineScaleSetNetworkConfiguration_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.NetworkInterfaceConfigurations = append(profile.NetworkInterfaceConfigurations, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSetNetworkProfile_STATUS populates our VirtualMachineScaleSetNetworkProfile_STATUS from the provided source VirtualMachineScaleSetNetworkProfile_STATUS
func (profile *VirtualMachineScaleSetNetworkProfile_STATUS) AssignProperties_From_VirtualMachineScaleSetNetworkProfile_STATUS(source *storage.VirtualMachineScaleSetNetworkProfile_STATUS) error {

	// HealthProbe
	if source.HealthProbe != nil {
		var healthProbe ApiEntityReference_STATUS
		err := healthProbe.AssignProperties_From_ApiEntityReference_STATUS(source.HealthProbe)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ApiEntityReference_STATUS() to populate field HealthProbe")
		}
		profile.HealthProbe = &healthProbe
	} else {
		profile.HealthProbe = nil
	}

	// NetworkApiVersion
	if source.NetworkApiVersion != nil {
		networkApiVersion := *source.NetworkApiVersion
		networkApiVersionTemp := genruntime.ToEnum(networkApiVersion, virtualMachineScaleSetNetworkProfile_NetworkApiVersion_STATUS_Values)
		profile.NetworkApiVersion = &networkApiVersionTemp
	} else {
		profile.NetworkApiVersion = nil
	}

	// NetworkInterfaceConfigurations
	if source.NetworkInterfaceConfigurations != nil {
		networkInterfaceConfigurationList := make([]VirtualMachineScaleSetNetworkConfiguration_STATUS, len(source.NetworkInterfaceConfigurations))
		for networkInterfaceConfigurationIndex, networkInterfaceConfigurationItem := range source.NetworkInterfaceConfigurations {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceConfigurationItem := networkInterfaceConfigurationItem
			var networkInterfaceConfiguration VirtualMachineScaleSetNetworkConfiguration_STATUS
			err := networkInterfaceConfiguration.AssignProperties_From_VirtualMachineScaleSetNetworkConfiguration_STATUS(&networkInterfaceConfigurationItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetNetworkConfiguration_STATUS() to populate field NetworkInterfaceConfigurations")
			}
			networkInterfaceConfigurationList[networkInterfaceConfigurationIndex] = networkInterfaceConfiguration
		}
		profile.NetworkInterfaceConfigurations = networkInterfaceConfigurationList
	} else {
		profile.NetworkInterfaceConfigurations = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetNetworkProfile_STATUS populates the provided destination VirtualMachineScaleSetNetworkProfile_STATUS from our VirtualMachineScaleSetNetworkProfile_STATUS
func (profile *VirtualMachineScaleSetNetworkProfile_STATUS) AssignProperties_To_VirtualMachineScaleSetNetworkProfile_STATUS(destination *storage.VirtualMachineScaleSetNetworkProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HealthProbe
	if profile.HealthProbe != nil {
		var healthProbe storage.ApiEntityReference_STATUS
		err := profile.HealthProbe.AssignProperties_To_ApiEntityReference_STATUS(&healthProbe)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ApiEntityReference_STATUS() to populate field HealthProbe")
		}
		destination.HealthProbe = &healthProbe
	} else {
		destination.HealthProbe = nil
	}

	// NetworkApiVersion
	if profile.NetworkApiVersion != nil {
		networkApiVersion := string(*profile.NetworkApiVersion)
		destination.NetworkApiVersion = &networkApiVersion
	} else {
		destination.NetworkApiVersion = nil
	}

	// NetworkInterfaceConfigurations
	if profile.NetworkInterfaceConfigurations != nil {
		networkInterfaceConfigurationList := make([]storage.VirtualMachineScaleSetNetworkConfiguration_STATUS, len(profile.NetworkInterfaceConfigurations))
		for networkInterfaceConfigurationIndex, networkInterfaceConfigurationItem := range profile.NetworkInterfaceConfigurations {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceConfigurationItem := networkInterfaceConfigurationItem
			var networkInterfaceConfiguration storage.VirtualMachineScaleSetNetworkConfiguration_STATUS
			err := networkInterfaceConfigurationItem.AssignProperties_To_VirtualMachineScaleSetNetworkConfiguration_STATUS(&networkInterfaceConfiguration)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetNetworkConfiguration_STATUS() to populate field NetworkInterfaceConfigurations")
			}
			networkInterfaceConfigurationList[networkInterfaceConfigurationIndex] = networkInterfaceConfiguration
		}
		destination.NetworkInterfaceConfigurations = networkInterfaceConfigurationList
	} else {
		destination.NetworkInterfaceConfigurations = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes a virtual machine scale set OS profile.
type VirtualMachineScaleSetOSProfile struct {
	// AdminPassword: Specifies the password of the administrator account.
	// Minimum-length (Windows): 8 characters
	// Minimum-length (Linux): 6 characters
	// Max-length (Windows): 123 characters
	// Max-length (Linux): 72 characters
	// Complexity requirements: 3 out of 4 conditions below need to be fulfilled
	// Has lower characters
	// Has upper characters
	// Has a digit
	// Has a special character (Regex match [\W_])
	// Disallowed values: "abc@123", "P@$$w0rd", "P@ssw0rd", "P@ssword123", "Pa$$word", "pass@word1", "Password!", "Password1",
	// "Password22", "iloveyou!"
	// For resetting the password, see [How to reset the Remote Desktop service or its login password in a Windows
	// VM](https://docs.microsoft.com/troubleshoot/azure/virtual-machines/reset-rdp)
	// For resetting root password, see [Manage users, SSH, and check or repair disks on Azure Linux VMs using the VMAccess
	// Extension](https://docs.microsoft.com/troubleshoot/azure/virtual-machines/troubleshoot-ssh-connection)
	AdminPassword *genruntime.SecretReference `json:"adminPassword,omitempty"`

	// AdminUsername: Specifies the name of the administrator account.
	// Windows-only restriction: Cannot end in "."
	// Disallowed values: "administrator", "admin", "user", "user1", "test", "user2", "test1", "user3", "admin1", "1", "123",
	// "a", "actuser", "adm", "admin2", "aspnet", "backup", "console", "david", "guest", "john", "owner", "root", "server",
	// "sql", "support", "support_388945a0", "sys", "test2", "test3", "user4", "user5".
	// Minimum-length (Linux): 1  character
	// Max-length (Linux): 64 characters
	// Max-length (Windows): 20 characters
	AdminUsername *string `json:"adminUsername,omitempty"`

	// AllowExtensionOperations: Specifies whether extension operations should be allowed on the virtual machine scale set.
	// This may only be set to False when no extensions are present on the virtual machine scale set.
	AllowExtensionOperations *bool `json:"allowExtensionOperations,omitempty"`

	// ComputerNamePrefix: Specifies the computer name prefix for all of the virtual machines in the scale set. Computer name
	// prefixes must be 1 to 15 characters long.
	ComputerNamePrefix *string `json:"computerNamePrefix,omitempty"`

	// CustomData: Specifies a base-64 encoded string of custom data. The base-64 encoded string is decoded to a binary array
	// that is saved as a file on the Virtual Machine. The maximum length of the binary array is 65535 bytes.
	// For using cloud-init for your VM, see [Using cloud-init to customize a Linux VM during
	// creation](https://docs.microsoft.com/azure/virtual-machines/linux/using-cloud-init)
	CustomData *string `json:"customData,omitempty"`

	// LinuxConfiguration: Specifies the Linux operating system settings on the virtual machine.
	// For a list of supported Linux distributions, see [Linux on Azure-Endorsed
	// Distributions](https://docs.microsoft.com/azure/virtual-machines/linux/endorsed-distros).
	LinuxConfiguration *LinuxConfiguration `json:"linuxConfiguration,omitempty"`

	// Secrets: Specifies set of certificates that should be installed onto the virtual machines in the scale set. To install
	// certificates on a virtual machine it is recommended to use the [Azure Key Vault virtual machine extension for
	// Linux](https://docs.microsoft.com/azure/virtual-machines/extensions/key-vault-linux) or the [Azure Key Vault virtual
	// machine extension for Windows](https://docs.microsoft.com/azure/virtual-machines/extensions/key-vault-windows).
	Secrets []VaultSecretGroup `json:"secrets,omitempty"`

	// WindowsConfiguration: Specifies Windows operating system settings on the virtual machine.
	WindowsConfiguration *WindowsConfiguration `json:"windowsConfiguration,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetOSProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *VirtualMachineScaleSetOSProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.VirtualMachineScaleSetOSProfile{}

	// Set property "AdminPassword":
	if profile.AdminPassword != nil {
		adminPasswordSecret, err := resolved.ResolvedSecrets.Lookup(*profile.AdminPassword)
		if err != nil {
			return nil, eris.Wrap(err, "looking up secret for property AdminPassword")
		}
		adminPassword := adminPasswordSecret
		result.AdminPassword = &adminPassword
	}

	// Set property "AdminUsername":
	if profile.AdminUsername != nil {
		adminUsername := *profile.AdminUsername
		result.AdminUsername = &adminUsername
	}

	// Set property "AllowExtensionOperations":
	if profile.AllowExtensionOperations != nil {
		allowExtensionOperations := *profile.AllowExtensionOperations
		result.AllowExtensionOperations = &allowExtensionOperations
	}

	// Set property "ComputerNamePrefix":
	if profile.ComputerNamePrefix != nil {
		computerNamePrefix := *profile.ComputerNamePrefix
		result.ComputerNamePrefix = &computerNamePrefix
	}

	// Set property "CustomData":
	if profile.CustomData != nil {
		customData := *profile.CustomData
		result.CustomData = &customData
	}

	// Set property "LinuxConfiguration":
	if profile.LinuxConfiguration != nil {
		linuxConfiguration_ARM, err := (*profile.LinuxConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		linuxConfiguration := *linuxConfiguration_ARM.(*arm.LinuxConfiguration)
		result.LinuxConfiguration = &linuxConfiguration
	}

	// Set property "Secrets":
	for _, item := range profile.Secrets {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Secrets = append(result.Secrets, *item_ARM.(*arm.VaultSecretGroup))
	}

	// Set property "WindowsConfiguration":
	if profile.WindowsConfiguration != nil {
		windowsConfiguration_ARM, err := (*profile.WindowsConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		windowsConfiguration := *windowsConfiguration_ARM.(*arm.WindowsConfiguration)
		result.WindowsConfiguration = &windowsConfiguration
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSetOSProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSetOSProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSetOSProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSetOSProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSetOSProfile, got %T", armInput)
	}

	// no assignment for property "AdminPassword"

	// Set property "AdminUsername":
	if typedInput.AdminUsername != nil {
		adminUsername := *typedInput.AdminUsername
		profile.AdminUsername = &adminUsername
	}

	// Set property "AllowExtensionOperations":
	if typedInput.AllowExtensionOperations != nil {
		allowExtensionOperations := *typedInput.AllowExtensionOperations
		profile.AllowExtensionOperations = &allowExtensionOperations
	}

	// Set property "ComputerNamePrefix":
	if typedInput.ComputerNamePrefix != nil {
		computerNamePrefix := *typedInput.ComputerNamePrefix
		profile.ComputerNamePrefix = &computerNamePrefix
	}

	// Set property "CustomData":
	if typedInput.CustomData != nil {
		customData := *typedInput.CustomData
		profile.CustomData = &customData
	}

	// Set property "LinuxConfiguration":
	if typedInput.LinuxConfiguration != nil {
		var linuxConfiguration1 LinuxConfiguration
		err := linuxConfiguration1.PopulateFromARM(owner, *typedInput.LinuxConfiguration)
		if err != nil {
			return err
		}
		linuxConfiguration := linuxConfiguration1
		profile.LinuxConfiguration = &linuxConfiguration
	}

	// Set property "Secrets":
	for _, item := range typedInput.Secrets {
		var item1 VaultSecretGroup
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.Secrets = append(profile.Secrets, item1)
	}

	// Set property "WindowsConfiguration":
	if typedInput.WindowsConfiguration != nil {
		var windowsConfiguration1 WindowsConfiguration
		err := windowsConfiguration1.PopulateFromARM(owner, *typedInput.WindowsConfiguration)
		if err != nil {
			return err
		}
		windowsConfiguration := windowsConfiguration1
		profile.WindowsConfiguration = &windowsConfiguration
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSetOSProfile populates our VirtualMachineScaleSetOSProfile from the provided source VirtualMachineScaleSetOSProfile
func (profile *VirtualMachineScaleSetOSProfile) AssignProperties_From_VirtualMachineScaleSetOSProfile(source *storage.VirtualMachineScaleSetOSProfile) error {

	// AdminPassword
	if source.AdminPassword != nil {
		adminPassword := source.AdminPassword.Copy()
		profile.AdminPassword = &adminPassword
	} else {
		profile.AdminPassword = nil
	}

	// AdminUsername
	profile.AdminUsername = genruntime.ClonePointerToString(source.AdminUsername)

	// AllowExtensionOperations
	if source.AllowExtensionOperations != nil {
		allowExtensionOperation := *source.AllowExtensionOperations
		profile.AllowExtensionOperations = &allowExtensionOperation
	} else {
		profile.AllowExtensionOperations = nil
	}

	// ComputerNamePrefix
	profile.ComputerNamePrefix = genruntime.ClonePointerToString(source.ComputerNamePrefix)

	// CustomData
	profile.CustomData = genruntime.ClonePointerToString(source.CustomData)

	// LinuxConfiguration
	if source.LinuxConfiguration != nil {
		var linuxConfiguration LinuxConfiguration
		err := linuxConfiguration.AssignProperties_From_LinuxConfiguration(source.LinuxConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LinuxConfiguration() to populate field LinuxConfiguration")
		}
		profile.LinuxConfiguration = &linuxConfiguration
	} else {
		profile.LinuxConfiguration = nil
	}

	// Secrets
	if source.Secrets != nil {
		secretList := make([]VaultSecretGroup, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret VaultSecretGroup
			err := secret.AssignProperties_From_VaultSecretGroup(&secretItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_VaultSecretGroup() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		profile.Secrets = secretList
	} else {
		profile.Secrets = nil
	}

	// WindowsConfiguration
	if source.WindowsConfiguration != nil {
		var windowsConfiguration WindowsConfiguration
		err := windowsConfiguration.AssignProperties_From_WindowsConfiguration(source.WindowsConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WindowsConfiguration() to populate field WindowsConfiguration")
		}
		profile.WindowsConfiguration = &windowsConfiguration
	} else {
		profile.WindowsConfiguration = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetOSProfile populates the provided destination VirtualMachineScaleSetOSProfile from our VirtualMachineScaleSetOSProfile
func (profile *VirtualMachineScaleSetOSProfile) AssignProperties_To_VirtualMachineScaleSetOSProfile(destination *storage.VirtualMachineScaleSetOSProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminPassword
	if profile.AdminPassword != nil {
		adminPassword := profile.AdminPassword.Copy()
		destination.AdminPassword = &adminPassword
	} else {
		destination.AdminPassword = nil
	}

	// AdminUsername
	destination.AdminUsername = genruntime.ClonePointerToString(profile.AdminUsername)

	// AllowExtensionOperations
	if profile.AllowExtensionOperations != nil {
		allowExtensionOperation := *profile.AllowExtensionOperations
		destination.AllowExtensionOperations = &allowExtensionOperation
	} else {
		destination.AllowExtensionOperations = nil
	}

	// ComputerNamePrefix
	destination.ComputerNamePrefix = genruntime.ClonePointerToString(profile.ComputerNamePrefix)

	// CustomData
	destination.CustomData = genruntime.ClonePointerToString(profile.CustomData)

	// LinuxConfiguration
	if profile.LinuxConfiguration != nil {
		var linuxConfiguration storage.LinuxConfiguration
		err := profile.LinuxConfiguration.AssignProperties_To_LinuxConfiguration(&linuxConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LinuxConfiguration() to populate field LinuxConfiguration")
		}
		destination.LinuxConfiguration = &linuxConfiguration
	} else {
		destination.LinuxConfiguration = nil
	}

	// Secrets
	if profile.Secrets != nil {
		secretList := make([]storage.VaultSecretGroup, len(profile.Secrets))
		for secretIndex, secretItem := range profile.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret storage.VaultSecretGroup
			err := secretItem.AssignProperties_To_VaultSecretGroup(&secret)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_VaultSecretGroup() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		destination.Secrets = secretList
	} else {
		destination.Secrets = nil
	}

	// WindowsConfiguration
	if profile.WindowsConfiguration != nil {
		var windowsConfiguration storage.WindowsConfiguration
		err := profile.WindowsConfiguration.AssignProperties_To_WindowsConfiguration(&windowsConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WindowsConfiguration() to populate field WindowsConfiguration")
		}
		destination.WindowsConfiguration = &windowsConfiguration
	} else {
		destination.WindowsConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualMachineScaleSetOSProfile_STATUS populates our VirtualMachineScaleSetOSProfile from the provided source VirtualMachineScaleSetOSProfile_STATUS
func (profile *VirtualMachineScaleSetOSProfile) Initialize_From_VirtualMachineScaleSetOSProfile_STATUS(source *VirtualMachineScaleSetOSProfile_STATUS) error {

	// AdminUsername
	profile.AdminUsername = genruntime.ClonePointerToString(source.AdminUsername)

	// AllowExtensionOperations
	if source.AllowExtensionOperations != nil {
		allowExtensionOperation := *source.AllowExtensionOperations
		profile.AllowExtensionOperations = &allowExtensionOperation
	} else {
		profile.AllowExtensionOperations = nil
	}

	// ComputerNamePrefix
	profile.ComputerNamePrefix = genruntime.ClonePointerToString(source.ComputerNamePrefix)

	// CustomData
	profile.CustomData = genruntime.ClonePointerToString(source.CustomData)

	// LinuxConfiguration
	if source.LinuxConfiguration != nil {
		var linuxConfiguration LinuxConfiguration
		err := linuxConfiguration.Initialize_From_LinuxConfiguration_STATUS(source.LinuxConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_LinuxConfiguration_STATUS() to populate field LinuxConfiguration")
		}
		profile.LinuxConfiguration = &linuxConfiguration
	} else {
		profile.LinuxConfiguration = nil
	}

	// Secrets
	if source.Secrets != nil {
		secretList := make([]VaultSecretGroup, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret VaultSecretGroup
			err := secret.Initialize_From_VaultSecretGroup_STATUS(&secretItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_VaultSecretGroup_STATUS() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		profile.Secrets = secretList
	} else {
		profile.Secrets = nil
	}

	// WindowsConfiguration
	if source.WindowsConfiguration != nil {
		var windowsConfiguration WindowsConfiguration
		err := windowsConfiguration.Initialize_From_WindowsConfiguration_STATUS(source.WindowsConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_WindowsConfiguration_STATUS() to populate field WindowsConfiguration")
		}
		profile.WindowsConfiguration = &windowsConfiguration
	} else {
		profile.WindowsConfiguration = nil
	}

	// No error
	return nil
}

// Describes a virtual machine scale set OS profile.
type VirtualMachineScaleSetOSProfile_STATUS struct {
	// AdminUsername: Specifies the name of the administrator account.
	// Windows-only restriction: Cannot end in "."
	// Disallowed values: "administrator", "admin", "user", "user1", "test", "user2", "test1", "user3", "admin1", "1", "123",
	// "a", "actuser", "adm", "admin2", "aspnet", "backup", "console", "david", "guest", "john", "owner", "root", "server",
	// "sql", "support", "support_388945a0", "sys", "test2", "test3", "user4", "user5".
	// Minimum-length (Linux): 1  character
	// Max-length (Linux): 64 characters
	// Max-length (Windows): 20 characters
	AdminUsername *string `json:"adminUsername,omitempty"`

	// AllowExtensionOperations: Specifies whether extension operations should be allowed on the virtual machine scale set.
	// This may only be set to False when no extensions are present on the virtual machine scale set.
	AllowExtensionOperations *bool `json:"allowExtensionOperations,omitempty"`

	// ComputerNamePrefix: Specifies the computer name prefix for all of the virtual machines in the scale set. Computer name
	// prefixes must be 1 to 15 characters long.
	ComputerNamePrefix *string `json:"computerNamePrefix,omitempty"`

	// CustomData: Specifies a base-64 encoded string of custom data. The base-64 encoded string is decoded to a binary array
	// that is saved as a file on the Virtual Machine. The maximum length of the binary array is 65535 bytes.
	// For using cloud-init for your VM, see [Using cloud-init to customize a Linux VM during
	// creation](https://docs.microsoft.com/azure/virtual-machines/linux/using-cloud-init)
	CustomData *string `json:"customData,omitempty"`

	// LinuxConfiguration: Specifies the Linux operating system settings on the virtual machine.
	// For a list of supported Linux distributions, see [Linux on Azure-Endorsed
	// Distributions](https://docs.microsoft.com/azure/virtual-machines/linux/endorsed-distros).
	LinuxConfiguration *LinuxConfiguration_STATUS `json:"linuxConfiguration,omitempty"`

	// Secrets: Specifies set of certificates that should be installed onto the virtual machines in the scale set. To install
	// certificates on a virtual machine it is recommended to use the [Azure Key Vault virtual machine extension for
	// Linux](https://docs.microsoft.com/azure/virtual-machines/extensions/key-vault-linux) or the [Azure Key Vault virtual
	// machine extension for Windows](https://docs.microsoft.com/azure/virtual-machines/extensions/key-vault-windows).
	Secrets []VaultSecretGroup_STATUS `json:"secrets,omitempty"`

	// WindowsConfiguration: Specifies Windows operating system settings on the virtual machine.
	WindowsConfiguration *WindowsConfiguration_STATUS `json:"windowsConfiguration,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetOSProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSetOSProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSetOSProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSetOSProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSetOSProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSetOSProfile_STATUS, got %T", armInput)
	}

	// Set property "AdminUsername":
	if typedInput.AdminUsername != nil {
		adminUsername := *typedInput.AdminUsername
		profile.AdminUsername = &adminUsername
	}

	// Set property "AllowExtensionOperations":
	if typedInput.AllowExtensionOperations != nil {
		allowExtensionOperations := *typedInput.AllowExtensionOperations
		profile.AllowExtensionOperations = &allowExtensionOperations
	}

	// Set property "ComputerNamePrefix":
	if typedInput.ComputerNamePrefix != nil {
		computerNamePrefix := *typedInput.ComputerNamePrefix
		profile.ComputerNamePrefix = &computerNamePrefix
	}

	// Set property "CustomData":
	if typedInput.CustomData != nil {
		customData := *typedInput.CustomData
		profile.CustomData = &customData
	}

	// Set property "LinuxConfiguration":
	if typedInput.LinuxConfiguration != nil {
		var linuxConfiguration1 LinuxConfiguration_STATUS
		err := linuxConfiguration1.PopulateFromARM(owner, *typedInput.LinuxConfiguration)
		if err != nil {
			return err
		}
		linuxConfiguration := linuxConfiguration1
		profile.LinuxConfiguration = &linuxConfiguration
	}

	// Set property "Secrets":
	for _, item := range typedInput.Secrets {
		var item1 VaultSecretGroup_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.Secrets = append(profile.Secrets, item1)
	}

	// Set property "WindowsConfiguration":
	if typedInput.WindowsConfiguration != nil {
		var windowsConfiguration1 WindowsConfiguration_STATUS
		err := windowsConfiguration1.PopulateFromARM(owner, *typedInput.WindowsConfiguration)
		if err != nil {
			return err
		}
		windowsConfiguration := windowsConfiguration1
		profile.WindowsConfiguration = &windowsConfiguration
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSetOSProfile_STATUS populates our VirtualMachineScaleSetOSProfile_STATUS from the provided source VirtualMachineScaleSetOSProfile_STATUS
func (profile *VirtualMachineScaleSetOSProfile_STATUS) AssignProperties_From_VirtualMachineScaleSetOSProfile_STATUS(source *storage.VirtualMachineScaleSetOSProfile_STATUS) error {

	// AdminUsername
	profile.AdminUsername = genruntime.ClonePointerToString(source.AdminUsername)

	// AllowExtensionOperations
	if source.AllowExtensionOperations != nil {
		allowExtensionOperation := *source.AllowExtensionOperations
		profile.AllowExtensionOperations = &allowExtensionOperation
	} else {
		profile.AllowExtensionOperations = nil
	}

	// ComputerNamePrefix
	profile.ComputerNamePrefix = genruntime.ClonePointerToString(source.ComputerNamePrefix)

	// CustomData
	profile.CustomData = genruntime.ClonePointerToString(source.CustomData)

	// LinuxConfiguration
	if source.LinuxConfiguration != nil {
		var linuxConfiguration LinuxConfiguration_STATUS
		err := linuxConfiguration.AssignProperties_From_LinuxConfiguration_STATUS(source.LinuxConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_LinuxConfiguration_STATUS() to populate field LinuxConfiguration")
		}
		profile.LinuxConfiguration = &linuxConfiguration
	} else {
		profile.LinuxConfiguration = nil
	}

	// Secrets
	if source.Secrets != nil {
		secretList := make([]VaultSecretGroup_STATUS, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret VaultSecretGroup_STATUS
			err := secret.AssignProperties_From_VaultSecretGroup_STATUS(&secretItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_VaultSecretGroup_STATUS() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		profile.Secrets = secretList
	} else {
		profile.Secrets = nil
	}

	// WindowsConfiguration
	if source.WindowsConfiguration != nil {
		var windowsConfiguration WindowsConfiguration_STATUS
		err := windowsConfiguration.AssignProperties_From_WindowsConfiguration_STATUS(source.WindowsConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WindowsConfiguration_STATUS() to populate field WindowsConfiguration")
		}
		profile.WindowsConfiguration = &windowsConfiguration
	} else {
		profile.WindowsConfiguration = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetOSProfile_STATUS populates the provided destination VirtualMachineScaleSetOSProfile_STATUS from our VirtualMachineScaleSetOSProfile_STATUS
func (profile *VirtualMachineScaleSetOSProfile_STATUS) AssignProperties_To_VirtualMachineScaleSetOSProfile_STATUS(destination *storage.VirtualMachineScaleSetOSProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminUsername
	destination.AdminUsername = genruntime.ClonePointerToString(profile.AdminUsername)

	// AllowExtensionOperations
	if profile.AllowExtensionOperations != nil {
		allowExtensionOperation := *profile.AllowExtensionOperations
		destination.AllowExtensionOperations = &allowExtensionOperation
	} else {
		destination.AllowExtensionOperations = nil
	}

	// ComputerNamePrefix
	destination.ComputerNamePrefix = genruntime.ClonePointerToString(profile.ComputerNamePrefix)

	// CustomData
	destination.CustomData = genruntime.ClonePointerToString(profile.CustomData)

	// LinuxConfiguration
	if profile.LinuxConfiguration != nil {
		var linuxConfiguration storage.LinuxConfiguration_STATUS
		err := profile.LinuxConfiguration.AssignProperties_To_LinuxConfiguration_STATUS(&linuxConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_LinuxConfiguration_STATUS() to populate field LinuxConfiguration")
		}
		destination.LinuxConfiguration = &linuxConfiguration
	} else {
		destination.LinuxConfiguration = nil
	}

	// Secrets
	if profile.Secrets != nil {
		secretList := make([]storage.VaultSecretGroup_STATUS, len(profile.Secrets))
		for secretIndex, secretItem := range profile.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret storage.VaultSecretGroup_STATUS
			err := secretItem.AssignProperties_To_VaultSecretGroup_STATUS(&secret)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_VaultSecretGroup_STATUS() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		destination.Secrets = secretList
	} else {
		destination.Secrets = nil
	}

	// WindowsConfiguration
	if profile.WindowsConfiguration != nil {
		var windowsConfiguration storage.WindowsConfiguration_STATUS
		err := profile.WindowsConfiguration.AssignProperties_To_WindowsConfiguration_STATUS(&windowsConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WindowsConfiguration_STATUS() to populate field WindowsConfiguration")
		}
		destination.WindowsConfiguration = &windowsConfiguration
	} else {
		destination.WindowsConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes a virtual machine scale set storage profile.
type VirtualMachineScaleSetStorageProfile struct {
	// DataDisks: Specifies the parameters that are used to add data disks to the virtual machines in the scale set.
	// For more information about disks, see [About disks and VHDs for Azure virtual
	// machines](https://docs.microsoft.com/azure/virtual-machines/managed-disks-overview).
	DataDisks []VirtualMachineScaleSetDataDisk `json:"dataDisks,omitempty"`

	// ImageReference: Specifies information about the image to use. You can specify information about platform images,
	// marketplace images, or virtual machine images. This element is required when you want to use a platform image,
	// marketplace image, or virtual machine image, but is not used in other creation operations.
	ImageReference *ImageReference `json:"imageReference,omitempty"`

	// OsDisk: Specifies information about the operating system disk used by the virtual machines in the scale set.
	// For more information about disks, see [About disks and VHDs for Azure virtual
	// machines](https://docs.microsoft.com/azure/virtual-machines/managed-disks-overview).
	OsDisk *VirtualMachineScaleSetOSDisk `json:"osDisk,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetStorageProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *VirtualMachineScaleSetStorageProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.VirtualMachineScaleSetStorageProfile{}

	// Set property "DataDisks":
	for _, item := range profile.DataDisks {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.DataDisks = append(result.DataDisks, *item_ARM.(*arm.VirtualMachineScaleSetDataDisk))
	}

	// Set property "ImageReference":
	if profile.ImageReference != nil {
		imageReference_ARM, err := (*profile.ImageReference).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		imageReference := *imageReference_ARM.(*arm.ImageReference)
		result.ImageReference = &imageReference
	}

	// Set property "OsDisk":
	if profile.OsDisk != nil {
		osDisk_ARM, err := (*profile.OsDisk).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		osDisk := *osDisk_ARM.(*arm.VirtualMachineScaleSetOSDisk)
		result.OsDisk = &osDisk
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSetStorageProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSetStorageProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSetStorageProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSetStorageProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSetStorageProfile, got %T", armInput)
	}

	// Set property "DataDisks":
	for _, item := range typedInput.DataDisks {
		var item1 VirtualMachineScaleSetDataDisk
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.DataDisks = append(profile.DataDisks, item1)
	}

	// Set property "ImageReference":
	if typedInput.ImageReference != nil {
		var imageReference1 ImageReference
		err := imageReference1.PopulateFromARM(owner, *typedInput.ImageReference)
		if err != nil {
			return err
		}
		imageReference := imageReference1
		profile.ImageReference = &imageReference
	}

	// Set property "OsDisk":
	if typedInput.OsDisk != nil {
		var osDisk1 VirtualMachineScaleSetOSDisk
		err := osDisk1.PopulateFromARM(owner, *typedInput.OsDisk)
		if err != nil {
			return err
		}
		osDisk := osDisk1
		profile.OsDisk = &osDisk
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSetStorageProfile populates our VirtualMachineScaleSetStorageProfile from the provided source VirtualMachineScaleSetStorageProfile
func (profile *VirtualMachineScaleSetStorageProfile) AssignProperties_From_VirtualMachineScaleSetStorageProfile(source *storage.VirtualMachineScaleSetStorageProfile) error {

	// DataDisks
	if source.DataDisks != nil {
		dataDiskList := make([]VirtualMachineScaleSetDataDisk, len(source.DataDisks))
		for dataDiskIndex, dataDiskItem := range source.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk VirtualMachineScaleSetDataDisk
			err := dataDisk.AssignProperties_From_VirtualMachineScaleSetDataDisk(&dataDiskItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetDataDisk() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		profile.DataDisks = dataDiskList
	} else {
		profile.DataDisks = nil
	}

	// ImageReference
	if source.ImageReference != nil {
		var imageReference ImageReference
		err := imageReference.AssignProperties_From_ImageReference(source.ImageReference)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ImageReference() to populate field ImageReference")
		}
		profile.ImageReference = &imageReference
	} else {
		profile.ImageReference = nil
	}

	// OsDisk
	if source.OsDisk != nil {
		var osDisk VirtualMachineScaleSetOSDisk
		err := osDisk.AssignProperties_From_VirtualMachineScaleSetOSDisk(source.OsDisk)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetOSDisk() to populate field OsDisk")
		}
		profile.OsDisk = &osDisk
	} else {
		profile.OsDisk = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetStorageProfile populates the provided destination VirtualMachineScaleSetStorageProfile from our VirtualMachineScaleSetStorageProfile
func (profile *VirtualMachineScaleSetStorageProfile) AssignProperties_To_VirtualMachineScaleSetStorageProfile(destination *storage.VirtualMachineScaleSetStorageProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataDisks
	if profile.DataDisks != nil {
		dataDiskList := make([]storage.VirtualMachineScaleSetDataDisk, len(profile.DataDisks))
		for dataDiskIndex, dataDiskItem := range profile.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk storage.VirtualMachineScaleSetDataDisk
			err := dataDiskItem.AssignProperties_To_VirtualMachineScaleSetDataDisk(&dataDisk)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetDataDisk() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		destination.DataDisks = dataDiskList
	} else {
		destination.DataDisks = nil
	}

	// ImageReference
	if profile.ImageReference != nil {
		var imageReference storage.ImageReference
		err := profile.ImageReference.AssignProperties_To_ImageReference(&imageReference)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ImageReference() to populate field ImageReference")
		}
		destination.ImageReference = &imageReference
	} else {
		destination.ImageReference = nil
	}

	// OsDisk
	if profile.OsDisk != nil {
		var osDisk storage.VirtualMachineScaleSetOSDisk
		err := profile.OsDisk.AssignProperties_To_VirtualMachineScaleSetOSDisk(&osDisk)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetOSDisk() to populate field OsDisk")
		}
		destination.OsDisk = &osDisk
	} else {
		destination.OsDisk = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualMachineScaleSetStorageProfile_STATUS populates our VirtualMachineScaleSetStorageProfile from the provided source VirtualMachineScaleSetStorageProfile_STATUS
func (profile *VirtualMachineScaleSetStorageProfile) Initialize_From_VirtualMachineScaleSetStorageProfile_STATUS(source *VirtualMachineScaleSetStorageProfile_STATUS) error {

	// DataDisks
	if source.DataDisks != nil {
		dataDiskList := make([]VirtualMachineScaleSetDataDisk, len(source.DataDisks))
		for dataDiskIndex, dataDiskItem := range source.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk VirtualMachineScaleSetDataDisk
			err := dataDisk.Initialize_From_VirtualMachineScaleSetDataDisk_STATUS(&dataDiskItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_VirtualMachineScaleSetDataDisk_STATUS() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		profile.DataDisks = dataDiskList
	} else {
		profile.DataDisks = nil
	}

	// ImageReference
	if source.ImageReference != nil {
		var imageReference ImageReference
		err := imageReference.Initialize_From_ImageReference_STATUS(source.ImageReference)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ImageReference_STATUS() to populate field ImageReference")
		}
		profile.ImageReference = &imageReference
	} else {
		profile.ImageReference = nil
	}

	// OsDisk
	if source.OsDisk != nil {
		var osDisk VirtualMachineScaleSetOSDisk
		err := osDisk.Initialize_From_VirtualMachineScaleSetOSDisk_STATUS(source.OsDisk)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_VirtualMachineScaleSetOSDisk_STATUS() to populate field OsDisk")
		}
		profile.OsDisk = &osDisk
	} else {
		profile.OsDisk = nil
	}

	// No error
	return nil
}

// Describes a virtual machine scale set storage profile.
type VirtualMachineScaleSetStorageProfile_STATUS struct {
	// DataDisks: Specifies the parameters that are used to add data disks to the virtual machines in the scale set.
	// For more information about disks, see [About disks and VHDs for Azure virtual
	// machines](https://docs.microsoft.com/azure/virtual-machines/managed-disks-overview).
	DataDisks []VirtualMachineScaleSetDataDisk_STATUS `json:"dataDisks,omitempty"`

	// ImageReference: Specifies information about the image to use. You can specify information about platform images,
	// marketplace images, or virtual machine images. This element is required when you want to use a platform image,
	// marketplace image, or virtual machine image, but is not used in other creation operations.
	ImageReference *ImageReference_STATUS `json:"imageReference,omitempty"`

	// OsDisk: Specifies information about the operating system disk used by the virtual machines in the scale set.
	// For more information about disks, see [About disks and VHDs for Azure virtual
	// machines](https://docs.microsoft.com/azure/virtual-machines/managed-disks-overview).
	OsDisk *VirtualMachineScaleSetOSDisk_STATUS `json:"osDisk,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetStorageProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VirtualMachineScaleSetStorageProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSetStorageProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VirtualMachineScaleSetStorageProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSetStorageProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSetStorageProfile_STATUS, got %T", armInput)
	}

	// Set property "DataDisks":
	for _, item := range typedInput.DataDisks {
		var item1 VirtualMachineScaleSetDataDisk_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.DataDisks = append(profile.DataDisks, item1)
	}

	// Set property "ImageReference":
	if typedInput.ImageReference != nil {
		var imageReference1 ImageReference_STATUS
		err := imageReference1.PopulateFromARM(owner, *typedInput.ImageReference)
		if err != nil {
			return err
		}
		imageReference := imageReference1
		profile.ImageReference = &imageReference
	}

	// Set property "OsDisk":
	if typedInput.OsDisk != nil {
		var osDisk1 VirtualMachineScaleSetOSDisk_STATUS
		err := osDisk1.PopulateFromARM(owner, *typedInput.OsDisk)
		if err != nil {
			return err
		}
		osDisk := osDisk1
		profile.OsDisk = &osDisk
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSetStorageProfile_STATUS populates our VirtualMachineScaleSetStorageProfile_STATUS from the provided source VirtualMachineScaleSetStorageProfile_STATUS
func (profile *VirtualMachineScaleSetStorageProfile_STATUS) AssignProperties_From_VirtualMachineScaleSetStorageProfile_STATUS(source *storage.VirtualMachineScaleSetStorageProfile_STATUS) error {

	// DataDisks
	if source.DataDisks != nil {
		dataDiskList := make([]VirtualMachineScaleSetDataDisk_STATUS, len(source.DataDisks))
		for dataDiskIndex, dataDiskItem := range source.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk VirtualMachineScaleSetDataDisk_STATUS
			err := dataDisk.AssignProperties_From_VirtualMachineScaleSetDataDisk_STATUS(&dataDiskItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetDataDisk_STATUS() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		profile.DataDisks = dataDiskList
	} else {
		profile.DataDisks = nil
	}

	// ImageReference
	if source.ImageReference != nil {
		var imageReference ImageReference_STATUS
		err := imageReference.AssignProperties_From_ImageReference_STATUS(source.ImageReference)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ImageReference_STATUS() to populate field ImageReference")
		}
		profile.ImageReference = &imageReference
	} else {
		profile.ImageReference = nil
	}

	// OsDisk
	if source.OsDisk != nil {
		var osDisk VirtualMachineScaleSetOSDisk_STATUS
		err := osDisk.AssignProperties_From_VirtualMachineScaleSetOSDisk_STATUS(source.OsDisk)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetOSDisk_STATUS() to populate field OsDisk")
		}
		profile.OsDisk = &osDisk
	} else {
		profile.OsDisk = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetStorageProfile_STATUS populates the provided destination VirtualMachineScaleSetStorageProfile_STATUS from our VirtualMachineScaleSetStorageProfile_STATUS
func (profile *VirtualMachineScaleSetStorageProfile_STATUS) AssignProperties_To_VirtualMachineScaleSetStorageProfile_STATUS(destination *storage.VirtualMachineScaleSetStorageProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataDisks
	if profile.DataDisks != nil {
		dataDiskList := make([]storage.VirtualMachineScaleSetDataDisk_STATUS, len(profile.DataDisks))
		for dataDiskIndex, dataDiskItem := range profile.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk storage.VirtualMachineScaleSetDataDisk_STATUS
			err := dataDiskItem.AssignProperties_To_VirtualMachineScaleSetDataDisk_STATUS(&dataDisk)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetDataDisk_STATUS() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		destination.DataDisks = dataDiskList
	} else {
		destination.DataDisks = nil
	}

	// ImageReference
	if profile.ImageReference != nil {
		var imageReference storage.ImageReference_STATUS
		err := profile.ImageReference.AssignProperties_To_ImageReference_STATUS(&imageReference)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ImageReference_STATUS() to populate field ImageReference")
		}
		destination.ImageReference = &imageReference
	} else {
		destination.ImageReference = nil
	}

	// OsDisk
	if profile.OsDisk != nil {
		var osDisk storage.VirtualMachineScaleSetOSDisk_STATUS
		err := profile.OsDisk.AssignProperties_To_VirtualMachineScaleSetOSDisk_STATUS(&osDisk)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetOSDisk_STATUS() to populate field OsDisk")
		}
		destination.OsDisk = &osDisk
	} else {
		destination.OsDisk = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The API entity reference.
type ApiEntityReference struct {
	// Reference: The ARM resource id in the form of /subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/...
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &ApiEntityReference{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (reference *ApiEntityReference) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if reference == nil {
		return nil, nil
	}
	result := &arm.ApiEntityReference{}

	// Set property "Id":
	if reference.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*reference.Reference)
		if err != nil {
			return nil, err
		}
		reference1 := referenceARMID
		result.Id = &reference1
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *ApiEntityReference) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApiEntityReference{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *ApiEntityReference) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(arm.ApiEntityReference)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApiEntityReference, got %T", armInput)
	}

	// no assignment for property "Reference"

	// No error
	return nil
}

// AssignProperties_From_ApiEntityReference populates our ApiEntityReference from the provided source ApiEntityReference
func (reference *ApiEntityReference) AssignProperties_From_ApiEntityReference(source *storage.ApiEntityReference) error {

	// Reference
	if source.Reference != nil {
		referenceTemp := source.Reference.Copy()
		reference.Reference = &referenceTemp
	} else {
		reference.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApiEntityReference populates the provided destination ApiEntityReference from our ApiEntityReference
func (reference *ApiEntityReference) AssignProperties_To_ApiEntityReference(destination *storage.ApiEntityReference) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if reference.Reference != nil {
		referenceTemp := reference.Reference.Copy()
		destination.Reference = &referenceTemp
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApiEntityReference_STATUS populates our ApiEntityReference from the provided source ApiEntityReference_STATUS
func (reference *ApiEntityReference) Initialize_From_ApiEntityReference_STATUS(source *ApiEntityReference_STATUS) error {

	// Reference
	if source.Id != nil {
		referenceTemp := genruntime.CreateResourceReferenceFromARMID(*source.Id)
		reference.Reference = &referenceTemp
	} else {
		reference.Reference = nil
	}

	// No error
	return nil
}

// The API entity reference.
type ApiEntityReference_STATUS struct {
	// Id: The ARM resource id in the form of /subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/...
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ApiEntityReference_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *ApiEntityReference_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApiEntityReference_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *ApiEntityReference_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApiEntityReference_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApiEntityReference_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		reference.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_ApiEntityReference_STATUS populates our ApiEntityReference_STATUS from the provided source ApiEntityReference_STATUS
func (reference *ApiEntityReference_STATUS) AssignProperties_From_ApiEntityReference_STATUS(source *storage.ApiEntityReference_STATUS) error {

	// Id
	reference.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_ApiEntityReference_STATUS populates the provided destination ApiEntityReference_STATUS from our ApiEntityReference_STATUS
func (reference *ApiEntityReference_STATUS) AssignProperties_To_ApiEntityReference_STATUS(destination *storage.ApiEntityReference_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(reference.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes a virtual machine scale set data disk.
type VirtualMachineScaleSetDataDisk struct {
	// Caching: Specifies the caching requirements.
	// Possible values are:
	// None
	// ReadOnly
	// ReadWrite
	// Default: None for Standard storage. ReadOnly for Premium storage
	Caching *Caching `json:"caching,omitempty"`

	// +kubebuilder:validation:Required
	// CreateOption: The create option.
	CreateOption *CreateOption `json:"createOption,omitempty"`

	// DeleteOption: Specifies whether data disk should be deleted or detached upon VMSS Flex deletion (This feature is
	// available for VMSS with Flexible OrchestrationMode only).
	// Possible values:
	// Delete If this value is used, the data disk is deleted when the VMSS Flex VM is deleted.
	// Detach If this value is used, the data disk is retained after VMSS Flex VM is deleted.
	// The default value is set to Delete.
	DeleteOption *DeleteOption `json:"deleteOption,omitempty"`

	// DiskIOPSReadWrite: Specifies the Read-Write IOPS for the managed disk. Should be used only when StorageAccountType is
	// UltraSSD_LRS. If not specified, a default value would be assigned based on diskSizeGB.
	DiskIOPSReadWrite *int `json:"diskIOPSReadWrite,omitempty"`

	// DiskMBpsReadWrite: Specifies the bandwidth in MB per second for the managed disk. Should be used only when
	// StorageAccountType is UltraSSD_LRS. If not specified, a default value would be assigned based on diskSizeGB.
	DiskMBpsReadWrite *int `json:"diskMBpsReadWrite,omitempty"`

	// DiskSizeGB: Specifies the size of an empty data disk in gigabytes. This element can be used to overwrite the size of the
	// disk in a virtual machine image.
	// This value cannot be larger than 1023 GB
	DiskSizeGB *int `json:"diskSizeGB,omitempty"`

	// +kubebuilder:validation:Required
	// Lun: Specifies the logical unit number of the data disk. This value is used to identify data disks within the VM and
	// therefore must be unique for each data disk attached to a VM.
	Lun *int `json:"lun,omitempty"`

	// ManagedDisk: The managed disk parameters.
	ManagedDisk *VirtualMachineScaleSetManagedDiskParameters `json:"managedDisk,omitempty"`

	// Name: The disk name.
	Name *string `json:"name,omitempty"`

	// WriteAcceleratorEnabled: Specifies whether writeAccelerator should be enabled or disabled on the disk.
	WriteAcceleratorEnabled *bool `json:"writeAcceleratorEnabled,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetDataDisk{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (disk *VirtualMachineScaleSetDataDisk) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if disk == nil {
		return nil, nil
	}
	result := &arm.VirtualMachineScaleSetDataDisk{}

	// Set property "Caching":
	if disk.Caching != nil {
		var temp string
		temp = string(*disk.Caching)
		caching := arm.Caching(temp)
		result.Caching = &caching
	}

	// Set property "CreateOption":
	if disk.CreateOption != nil {
		var temp string
		temp = string(*disk.CreateOption)
		createOption := arm.CreateOption(temp)
		result.CreateOption = &createOption
	}

	// Set property "DeleteOption":
	if disk.DeleteOption != nil {
		var temp string
		temp = string(*disk.DeleteOption)
		deleteOption := arm.DeleteOption(temp)
		result.DeleteOption = &deleteOption
	}

	// Set property "DiskIOPSReadWrite":
	if disk.DiskIOPSReadWrite != nil {
		diskIOPSReadWrite := *disk.DiskIOPSReadWrite
		result.DiskIOPSReadWrite = &diskIOPSReadWrite
	}

	// Set property "DiskMBpsReadWrite":
	if disk.DiskMBpsReadWrite != nil {
		diskMBpsReadWrite := *disk.DiskMBpsReadWrite
		result.DiskMBpsReadWrite = &diskMBpsReadWrite
	}

	// Set property "DiskSizeGB":
	if disk.DiskSizeGB != nil {
		diskSizeGB := *disk.DiskSizeGB
		result.DiskSizeGB = &diskSizeGB
	}

	// Set property "Lun":
	if disk.Lun != nil {
		lun := *disk.Lun
		result.Lun = &lun
	}

	// Set property "ManagedDisk":
	if disk.ManagedDisk != nil {
		managedDisk_ARM, err := (*disk.ManagedDisk).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		managedDisk := *managedDisk_ARM.(*arm.VirtualMachineScaleSetManagedDiskParameters)
		result.ManagedDisk = &managedDisk
	}

	// Set property "Name":
	if disk.Name != nil {
		name := *disk.Name
		result.Name = &name
	}

	// Set property "WriteAcceleratorEnabled":
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		result.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (disk *VirtualMachineScaleSetDataDisk) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSetDataDisk{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (disk *VirtualMachineScaleSetDataDisk) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSetDataDisk)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSetDataDisk, got %T", armInput)
	}

	// Set property "Caching":
	if typedInput.Caching != nil {
		var temp string
		temp = string(*typedInput.Caching)
		caching := Caching(temp)
		disk.Caching = &caching
	}

	// Set property "CreateOption":
	if typedInput.CreateOption != nil {
		var temp string
		temp = string(*typedInput.CreateOption)
		createOption := CreateOption(temp)
		disk.CreateOption = &createOption
	}

	// Set property "DeleteOption":
	if typedInput.DeleteOption != nil {
		var temp string
		temp = string(*typedInput.DeleteOption)
		deleteOption := DeleteOption(temp)
		disk.DeleteOption = &deleteOption
	}

	// Set property "DiskIOPSReadWrite":
	if typedInput.DiskIOPSReadWrite != nil {
		diskIOPSReadWrite := *typedInput.DiskIOPSReadWrite
		disk.DiskIOPSReadWrite = &diskIOPSReadWrite
	}

	// Set property "DiskMBpsReadWrite":
	if typedInput.DiskMBpsReadWrite != nil {
		diskMBpsReadWrite := *typedInput.DiskMBpsReadWrite
		disk.DiskMBpsReadWrite = &diskMBpsReadWrite
	}

	// Set property "DiskSizeGB":
	if typedInput.DiskSizeGB != nil {
		diskSizeGB := *typedInput.DiskSizeGB
		disk.DiskSizeGB = &diskSizeGB
	}

	// Set property "Lun":
	if typedInput.Lun != nil {
		lun := *typedInput.Lun
		disk.Lun = &lun
	}

	// Set property "ManagedDisk":
	if typedInput.ManagedDisk != nil {
		var managedDisk1 VirtualMachineScaleSetManagedDiskParameters
		err := managedDisk1.PopulateFromARM(owner, *typedInput.ManagedDisk)
		if err != nil {
			return err
		}
		managedDisk := managedDisk1
		disk.ManagedDisk = &managedDisk
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		disk.Name = &name
	}

	// Set property "WriteAcceleratorEnabled":
	if typedInput.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *typedInput.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSetDataDisk populates our VirtualMachineScaleSetDataDisk from the provided source VirtualMachineScaleSetDataDisk
func (disk *VirtualMachineScaleSetDataDisk) AssignProperties_From_VirtualMachineScaleSetDataDisk(source *storage.VirtualMachineScaleSetDataDisk) error {

	// Caching
	if source.Caching != nil {
		caching := *source.Caching
		cachingTemp := genruntime.ToEnum(caching, caching_Values)
		disk.Caching = &cachingTemp
	} else {
		disk.Caching = nil
	}

	// CreateOption
	if source.CreateOption != nil {
		createOption := *source.CreateOption
		createOptionTemp := genruntime.ToEnum(createOption, createOption_Values)
		disk.CreateOption = &createOptionTemp
	} else {
		disk.CreateOption = nil
	}

	// DeleteOption
	if source.DeleteOption != nil {
		deleteOption := *source.DeleteOption
		deleteOptionTemp := genruntime.ToEnum(deleteOption, deleteOption_Values)
		disk.DeleteOption = &deleteOptionTemp
	} else {
		disk.DeleteOption = nil
	}

	// DiskIOPSReadWrite
	disk.DiskIOPSReadWrite = genruntime.ClonePointerToInt(source.DiskIOPSReadWrite)

	// DiskMBpsReadWrite
	disk.DiskMBpsReadWrite = genruntime.ClonePointerToInt(source.DiskMBpsReadWrite)

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// Lun
	disk.Lun = genruntime.ClonePointerToInt(source.Lun)

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk VirtualMachineScaleSetManagedDiskParameters
		err := managedDisk.AssignProperties_From_VirtualMachineScaleSetManagedDiskParameters(source.ManagedDisk)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetManagedDiskParameters() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetDataDisk populates the provided destination VirtualMachineScaleSetDataDisk from our VirtualMachineScaleSetDataDisk
func (disk *VirtualMachineScaleSetDataDisk) AssignProperties_To_VirtualMachineScaleSetDataDisk(destination *storage.VirtualMachineScaleSetDataDisk) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Caching
	if disk.Caching != nil {
		caching := string(*disk.Caching)
		destination.Caching = &caching
	} else {
		destination.Caching = nil
	}

	// CreateOption
	if disk.CreateOption != nil {
		createOption := string(*disk.CreateOption)
		destination.CreateOption = &createOption
	} else {
		destination.CreateOption = nil
	}

	// DeleteOption
	if disk.DeleteOption != nil {
		deleteOption := string(*disk.DeleteOption)
		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// DiskIOPSReadWrite
	destination.DiskIOPSReadWrite = genruntime.ClonePointerToInt(disk.DiskIOPSReadWrite)

	// DiskMBpsReadWrite
	destination.DiskMBpsReadWrite = genruntime.ClonePointerToInt(disk.DiskMBpsReadWrite)

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// Lun
	destination.Lun = genruntime.ClonePointerToInt(disk.Lun)

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk storage.VirtualMachineScaleSetManagedDiskParameters
		err := disk.ManagedDisk.AssignProperties_To_VirtualMachineScaleSetManagedDiskParameters(&managedDisk)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetManagedDiskParameters() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualMachineScaleSetDataDisk_STATUS populates our VirtualMachineScaleSetDataDisk from the provided source VirtualMachineScaleSetDataDisk_STATUS
func (disk *VirtualMachineScaleSetDataDisk) Initialize_From_VirtualMachineScaleSetDataDisk_STATUS(source *VirtualMachineScaleSetDataDisk_STATUS) error {

	// Caching
	if source.Caching != nil {
		caching := genruntime.ToEnum(string(*source.Caching), caching_Values)
		disk.Caching = &caching
	} else {
		disk.Caching = nil
	}

	// CreateOption
	if source.CreateOption != nil {
		createOption := genruntime.ToEnum(string(*source.CreateOption), createOption_Values)
		disk.CreateOption = &createOption
	} else {
		disk.CreateOption = nil
	}

	// DeleteOption
	if source.DeleteOption != nil {
		deleteOption := genruntime.ToEnum(string(*source.DeleteOption), deleteOption_Values)
		disk.DeleteOption = &deleteOption
	} else {
		disk.DeleteOption = nil
	}

	// DiskIOPSReadWrite
	disk.DiskIOPSReadWrite = genruntime.ClonePointerToInt(source.DiskIOPSReadWrite)

	// DiskMBpsReadWrite
	disk.DiskMBpsReadWrite = genruntime.ClonePointerToInt(source.DiskMBpsReadWrite)

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// Lun
	disk.Lun = genruntime.ClonePointerToInt(source.Lun)

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk VirtualMachineScaleSetManagedDiskParameters
		err := managedDisk.Initialize_From_VirtualMachineScaleSetManagedDiskParameters_STATUS(source.ManagedDisk)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_VirtualMachineScaleSetManagedDiskParameters_STATUS() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// No error
	return nil
}

// Describes a virtual machine scale set data disk.
type VirtualMachineScaleSetDataDisk_STATUS struct {
	// Caching: Specifies the caching requirements.
	// Possible values are:
	// None
	// ReadOnly
	// ReadWrite
	// Default: None for Standard storage. ReadOnly for Premium storage
	Caching *Caching_STATUS `json:"caching,omitempty"`

	// CreateOption: The create option.
	CreateOption *CreateOption_STATUS `json:"createOption,omitempty"`

	// DeleteOption: Specifies whether data disk should be deleted or detached upon VMSS Flex deletion (This feature is
	// available for VMSS with Flexible OrchestrationMode only).
	// Possible values:
	// Delete If this value is used, the data disk is deleted when the VMSS Flex VM is deleted.
	// Detach If this value is used, the data disk is retained after VMSS Flex VM is deleted.
	// The default value is set to Delete.
	DeleteOption *DeleteOption_STATUS `json:"deleteOption,omitempty"`

	// DiskIOPSReadWrite: Specifies the Read-Write IOPS for the managed disk. Should be used only when StorageAccountType is
	// UltraSSD_LRS. If not specified, a default value would be assigned based on diskSizeGB.
	DiskIOPSReadWrite *int `json:"diskIOPSReadWrite,omitempty"`

	// DiskMBpsReadWrite: Specifies the bandwidth in MB per second for the managed disk. Should be used only when
	// StorageAccountType is UltraSSD_LRS. If not specified, a default value would be assigned based on diskSizeGB.
	DiskMBpsReadWrite *int `json:"diskMBpsReadWrite,omitempty"`

	// DiskSizeGB: Specifies the size of an empty data disk in gigabytes. This element can be used to overwrite the size of the
	// disk in a virtual machine image.
	// This value cannot be larger than 1023 GB
	DiskSizeGB *int `json:"diskSizeGB,omitempty"`

	// Lun: Specifies the logical unit number of the data disk. This value is used to identify data disks within the VM and
	// therefore must be unique for each data disk attached to a VM.
	Lun *int `json:"lun,omitempty"`

	// ManagedDisk: The managed disk parameters.
	ManagedDisk *VirtualMachineScaleSetManagedDiskParameters_STATUS `json:"managedDisk,omitempty"`

	// Name: The disk name.
	Name *string `json:"name,omitempty"`

	// WriteAcceleratorEnabled: Specifies whether writeAccelerator should be enabled or disabled on the disk.
	WriteAcceleratorEnabled *bool `json:"writeAcceleratorEnabled,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetDataDisk_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (disk *VirtualMachineScaleSetDataDisk_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSetDataDisk_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (disk *VirtualMachineScaleSetDataDisk_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSetDataDisk_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSetDataDisk_STATUS, got %T", armInput)
	}

	// Set property "Caching":
	if typedInput.Caching != nil {
		var temp string
		temp = string(*typedInput.Caching)
		caching := Caching_STATUS(temp)
		disk.Caching = &caching
	}

	// Set property "CreateOption":
	if typedInput.CreateOption != nil {
		var temp string
		temp = string(*typedInput.CreateOption)
		createOption := CreateOption_STATUS(temp)
		disk.CreateOption = &createOption
	}

	// Set property "DeleteOption":
	if typedInput.DeleteOption != nil {
		var temp string
		temp = string(*typedInput.DeleteOption)
		deleteOption := DeleteOption_STATUS(temp)
		disk.DeleteOption = &deleteOption
	}

	// Set property "DiskIOPSReadWrite":
	if typedInput.DiskIOPSReadWrite != nil {
		diskIOPSReadWrite := *typedInput.DiskIOPSReadWrite
		disk.DiskIOPSReadWrite = &diskIOPSReadWrite
	}

	// Set property "DiskMBpsReadWrite":
	if typedInput.DiskMBpsReadWrite != nil {
		diskMBpsReadWrite := *typedInput.DiskMBpsReadWrite
		disk.DiskMBpsReadWrite = &diskMBpsReadWrite
	}

	// Set property "DiskSizeGB":
	if typedInput.DiskSizeGB != nil {
		diskSizeGB := *typedInput.DiskSizeGB
		disk.DiskSizeGB = &diskSizeGB
	}

	// Set property "Lun":
	if typedInput.Lun != nil {
		lun := *typedInput.Lun
		disk.Lun = &lun
	}

	// Set property "ManagedDisk":
	if typedInput.ManagedDisk != nil {
		var managedDisk1 VirtualMachineScaleSetManagedDiskParameters_STATUS
		err := managedDisk1.PopulateFromARM(owner, *typedInput.ManagedDisk)
		if err != nil {
			return err
		}
		managedDisk := managedDisk1
		disk.ManagedDisk = &managedDisk
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		disk.Name = &name
	}

	// Set property "WriteAcceleratorEnabled":
	if typedInput.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *typedInput.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSetDataDisk_STATUS populates our VirtualMachineScaleSetDataDisk_STATUS from the provided source VirtualMachineScaleSetDataDisk_STATUS
func (disk *VirtualMachineScaleSetDataDisk_STATUS) AssignProperties_From_VirtualMachineScaleSetDataDisk_STATUS(source *storage.VirtualMachineScaleSetDataDisk_STATUS) error {

	// Caching
	if source.Caching != nil {
		caching := *source.Caching
		cachingTemp := genruntime.ToEnum(caching, caching_STATUS_Values)
		disk.Caching = &cachingTemp
	} else {
		disk.Caching = nil
	}

	// CreateOption
	if source.CreateOption != nil {
		createOption := *source.CreateOption
		createOptionTemp := genruntime.ToEnum(createOption, createOption_STATUS_Values)
		disk.CreateOption = &createOptionTemp
	} else {
		disk.CreateOption = nil
	}

	// DeleteOption
	if source.DeleteOption != nil {
		deleteOption := *source.DeleteOption
		deleteOptionTemp := genruntime.ToEnum(deleteOption, deleteOption_STATUS_Values)
		disk.DeleteOption = &deleteOptionTemp
	} else {
		disk.DeleteOption = nil
	}

	// DiskIOPSReadWrite
	disk.DiskIOPSReadWrite = genruntime.ClonePointerToInt(source.DiskIOPSReadWrite)

	// DiskMBpsReadWrite
	disk.DiskMBpsReadWrite = genruntime.ClonePointerToInt(source.DiskMBpsReadWrite)

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// Lun
	disk.Lun = genruntime.ClonePointerToInt(source.Lun)

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk VirtualMachineScaleSetManagedDiskParameters_STATUS
		err := managedDisk.AssignProperties_From_VirtualMachineScaleSetManagedDiskParameters_STATUS(source.ManagedDisk)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetManagedDiskParameters_STATUS() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetDataDisk_STATUS populates the provided destination VirtualMachineScaleSetDataDisk_STATUS from our VirtualMachineScaleSetDataDisk_STATUS
func (disk *VirtualMachineScaleSetDataDisk_STATUS) AssignProperties_To_VirtualMachineScaleSetDataDisk_STATUS(destination *storage.VirtualMachineScaleSetDataDisk_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Caching
	if disk.Caching != nil {
		caching := string(*disk.Caching)
		destination.Caching = &caching
	} else {
		destination.Caching = nil
	}

	// CreateOption
	if disk.CreateOption != nil {
		createOption := string(*disk.CreateOption)
		destination.CreateOption = &createOption
	} else {
		destination.CreateOption = nil
	}

	// DeleteOption
	if disk.DeleteOption != nil {
		deleteOption := string(*disk.DeleteOption)
		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// DiskIOPSReadWrite
	destination.DiskIOPSReadWrite = genruntime.ClonePointerToInt(disk.DiskIOPSReadWrite)

	// DiskMBpsReadWrite
	destination.DiskMBpsReadWrite = genruntime.ClonePointerToInt(disk.DiskMBpsReadWrite)

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// Lun
	destination.Lun = genruntime.ClonePointerToInt(disk.Lun)

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk storage.VirtualMachineScaleSetManagedDiskParameters_STATUS
		err := disk.ManagedDisk.AssignProperties_To_VirtualMachineScaleSetManagedDiskParameters_STATUS(&managedDisk)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetManagedDiskParameters_STATUS() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes a Virtual Machine Scale Set Extension.
type VirtualMachineScaleSetExtension struct {
	// AutoUpgradeMinorVersion: Indicates whether the extension should use a newer minor version if one is available at
	// deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this
	// property set to true.
	AutoUpgradeMinorVersion *bool `json:"autoUpgradeMinorVersion,omitempty"`

	// EnableAutomaticUpgrade: Indicates whether the extension should be automatically upgraded by the platform if there is a
	// newer version of the extension available.
	EnableAutomaticUpgrade *bool `json:"enableAutomaticUpgrade,omitempty"`

	// ForceUpdateTag: If a value is provided and is different from the previous value, the extension handler will be forced to
	// update even if the extension configuration has not changed.
	ForceUpdateTag *string `json:"forceUpdateTag,omitempty"`

	// Name: The name of the extension.
	Name *string `json:"name,omitempty"`

	// ProtectedSettings: The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected
	// settings at all.
	ProtectedSettings *genruntime.SecretMapReference `json:"protectedSettings,omitempty"`

	// ProtectedSettingsFromKeyVault: The extensions protected settings that are passed by reference, and consumed from key
	// vault
	ProtectedSettingsFromKeyVault *KeyVaultSecretReference `json:"protectedSettingsFromKeyVault,omitempty"`

	// ProvisionAfterExtensions: Collection of extension names after which this extension needs to be provisioned.
	ProvisionAfterExtensions []string `json:"provisionAfterExtensions,omitempty"`

	// Publisher: The name of the extension handler publisher.
	Publisher *string `json:"publisher,omitempty"`

	// Settings: Json formatted public settings for the extension.
	Settings map[string]v1.JSON `json:"settings,omitempty"`

	// SuppressFailures: Indicates whether failures stemming from the extension will be suppressed (Operational failures such
	// as not connecting to the VM will not be suppressed regardless of this value). The default is false.
	SuppressFailures *bool `json:"suppressFailures,omitempty"`

	// Type: Specifies the type of the extension; an example is "CustomScriptExtension".
	Type *string `json:"type,omitempty"`

	// TypeHandlerVersion: Specifies the version of the script handler.
	TypeHandlerVersion *string `json:"typeHandlerVersion,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetExtension{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (extension *VirtualMachineScaleSetExtension) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if extension == nil {
		return nil, nil
	}
	result := &arm.VirtualMachineScaleSetExtension{}

	// Set property "Name":
	if extension.Name != nil {
		name := *extension.Name
		result.Name = &name
	}

	// Set property "Properties":
	if extension.AutoUpgradeMinorVersion != nil ||
		extension.EnableAutomaticUpgrade != nil ||
		extension.ForceUpdateTag != nil ||
		extension.ProtectedSettings != nil ||
		extension.ProtectedSettingsFromKeyVault != nil ||
		extension.ProvisionAfterExtensions != nil ||
		extension.Publisher != nil ||
		extension.Settings != nil ||
		extension.SuppressFailures != nil ||
		extension.Type != nil ||
		extension.TypeHandlerVersion != nil {
		result.Properties = &arm.VirtualMachineScaleSetExtensionProperties{}
	}
	if extension.AutoUpgradeMinorVersion != nil {
		autoUpgradeMinorVersion := *extension.AutoUpgradeMinorVersion
		result.Properties.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
	}
	if extension.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *extension.EnableAutomaticUpgrade
		result.Properties.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	}
	if extension.ForceUpdateTag != nil {
		forceUpdateTag := *extension.ForceUpdateTag
		result.Properties.ForceUpdateTag = &forceUpdateTag
	}
	if extension.ProtectedSettings != nil {
		var temp map[string]string
		tempSecret, err := resolved.ResolvedSecretMaps.Lookup(*extension.ProtectedSettings)
		if err != nil {
			return nil, eris.Wrap(err, "looking up secret for property temp")
		}
		temp = tempSecret
		result.Properties.ProtectedSettings = temp
	}
	if extension.ProtectedSettingsFromKeyVault != nil {
		protectedSettingsFromKeyVault_ARM, err := (*extension.ProtectedSettingsFromKeyVault).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		protectedSettingsFromKeyVault := *protectedSettingsFromKeyVault_ARM.(*arm.KeyVaultSecretReference)
		result.Properties.ProtectedSettingsFromKeyVault = &protectedSettingsFromKeyVault
	}
	for _, item := range extension.ProvisionAfterExtensions {
		result.Properties.ProvisionAfterExtensions = append(result.Properties.ProvisionAfterExtensions, item)
	}
	if extension.Publisher != nil {
		publisher := *extension.Publisher
		result.Properties.Publisher = &publisher
	}
	if extension.Settings != nil {
		result.Properties.Settings = make(map[string]v1.JSON, len(extension.Settings))
		for key, value := range extension.Settings {
			result.Properties.Settings[key] = *value.DeepCopy()
		}
	}
	if extension.SuppressFailures != nil {
		suppressFailures := *extension.SuppressFailures
		result.Properties.SuppressFailures = &suppressFailures
	}
	if extension.Type != nil {
		typeVar := *extension.Type
		result.Properties.Type = &typeVar
	}
	if extension.TypeHandlerVersion != nil {
		typeHandlerVersion := *extension.TypeHandlerVersion
		result.Properties.TypeHandlerVersion = &typeHandlerVersion
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (extension *VirtualMachineScaleSetExtension) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSetExtension{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (extension *VirtualMachineScaleSetExtension) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSetExtension)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSetExtension, got %T", armInput)
	}

	// Set property "AutoUpgradeMinorVersion":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutoUpgradeMinorVersion != nil {
			autoUpgradeMinorVersion := *typedInput.Properties.AutoUpgradeMinorVersion
			extension.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
		}
	}

	// Set property "EnableAutomaticUpgrade":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableAutomaticUpgrade != nil {
			enableAutomaticUpgrade := *typedInput.Properties.EnableAutomaticUpgrade
			extension.EnableAutomaticUpgrade = &enableAutomaticUpgrade
		}
	}

	// Set property "ForceUpdateTag":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ForceUpdateTag != nil {
			forceUpdateTag := *typedInput.Properties.ForceUpdateTag
			extension.ForceUpdateTag = &forceUpdateTag
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		extension.Name = &name
	}

	// no assignment for property "ProtectedSettings"

	// Set property "ProtectedSettingsFromKeyVault":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProtectedSettingsFromKeyVault != nil {
			var protectedSettingsFromKeyVault1 KeyVaultSecretReference
			err := protectedSettingsFromKeyVault1.PopulateFromARM(owner, *typedInput.Properties.ProtectedSettingsFromKeyVault)
			if err != nil {
				return err
			}
			protectedSettingsFromKeyVault := protectedSettingsFromKeyVault1
			extension.ProtectedSettingsFromKeyVault = &protectedSettingsFromKeyVault
		}
	}

	// Set property "ProvisionAfterExtensions":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ProvisionAfterExtensions {
			extension.ProvisionAfterExtensions = append(extension.ProvisionAfterExtensions, item)
		}
	}

	// Set property "Publisher":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Publisher != nil {
			publisher := *typedInput.Properties.Publisher
			extension.Publisher = &publisher
		}
	}

	// Set property "Settings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Settings != nil {
			extension.Settings = make(map[string]v1.JSON, len(typedInput.Properties.Settings))
			for key, value := range typedInput.Properties.Settings {
				extension.Settings[key] = *value.DeepCopy()
			}
		}
	}

	// Set property "SuppressFailures":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SuppressFailures != nil {
			suppressFailures := *typedInput.Properties.SuppressFailures
			extension.SuppressFailures = &suppressFailures
		}
	}

	// Set property "Type":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Type != nil {
			typeVar := *typedInput.Properties.Type
			extension.Type = &typeVar
		}
	}

	// Set property "TypeHandlerVersion":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TypeHandlerVersion != nil {
			typeHandlerVersion := *typedInput.Properties.TypeHandlerVersion
			extension.TypeHandlerVersion = &typeHandlerVersion
		}
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSetExtension populates our VirtualMachineScaleSetExtension from the provided source VirtualMachineScaleSetExtension
func (extension *VirtualMachineScaleSetExtension) AssignProperties_From_VirtualMachineScaleSetExtension(source *storage.VirtualMachineScaleSetExtension) error {

	// AutoUpgradeMinorVersion
	if source.AutoUpgradeMinorVersion != nil {
		autoUpgradeMinorVersion := *source.AutoUpgradeMinorVersion
		extension.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
	} else {
		extension.AutoUpgradeMinorVersion = nil
	}

	// EnableAutomaticUpgrade
	if source.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *source.EnableAutomaticUpgrade
		extension.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	} else {
		extension.EnableAutomaticUpgrade = nil
	}

	// ForceUpdateTag
	extension.ForceUpdateTag = genruntime.ClonePointerToString(source.ForceUpdateTag)

	// Name
	extension.Name = genruntime.ClonePointerToString(source.Name)

	// ProtectedSettings
	if source.ProtectedSettings != nil {
		protectedSetting := source.ProtectedSettings.Copy()
		extension.ProtectedSettings = &protectedSetting
	} else {
		extension.ProtectedSettings = nil
	}

	// ProtectedSettingsFromKeyVault
	if source.ProtectedSettingsFromKeyVault != nil {
		var protectedSettingsFromKeyVault KeyVaultSecretReference
		err := protectedSettingsFromKeyVault.AssignProperties_From_KeyVaultSecretReference(source.ProtectedSettingsFromKeyVault)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_KeyVaultSecretReference() to populate field ProtectedSettingsFromKeyVault")
		}
		extension.ProtectedSettingsFromKeyVault = &protectedSettingsFromKeyVault
	} else {
		extension.ProtectedSettingsFromKeyVault = nil
	}

	// ProvisionAfterExtensions
	extension.ProvisionAfterExtensions = genruntime.CloneSliceOfString(source.ProvisionAfterExtensions)

	// Publisher
	extension.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// Settings
	if source.Settings != nil {
		settingMap := make(map[string]v1.JSON, len(source.Settings))
		for settingKey, settingValue := range source.Settings {
			// Shadow the loop variable to avoid aliasing
			settingValue := settingValue
			settingMap[settingKey] = *settingValue.DeepCopy()
		}
		extension.Settings = settingMap
	} else {
		extension.Settings = nil
	}

	// SuppressFailures
	if source.SuppressFailures != nil {
		suppressFailure := *source.SuppressFailures
		extension.SuppressFailures = &suppressFailure
	} else {
		extension.SuppressFailures = nil
	}

	// Type
	extension.Type = genruntime.ClonePointerToString(source.Type)

	// TypeHandlerVersion
	extension.TypeHandlerVersion = genruntime.ClonePointerToString(source.TypeHandlerVersion)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetExtension populates the provided destination VirtualMachineScaleSetExtension from our VirtualMachineScaleSetExtension
func (extension *VirtualMachineScaleSetExtension) AssignProperties_To_VirtualMachineScaleSetExtension(destination *storage.VirtualMachineScaleSetExtension) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AutoUpgradeMinorVersion
	if extension.AutoUpgradeMinorVersion != nil {
		autoUpgradeMinorVersion := *extension.AutoUpgradeMinorVersion
		destination.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
	} else {
		destination.AutoUpgradeMinorVersion = nil
	}

	// EnableAutomaticUpgrade
	if extension.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *extension.EnableAutomaticUpgrade
		destination.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	} else {
		destination.EnableAutomaticUpgrade = nil
	}

	// ForceUpdateTag
	destination.ForceUpdateTag = genruntime.ClonePointerToString(extension.ForceUpdateTag)

	// Name
	destination.Name = genruntime.ClonePointerToString(extension.Name)

	// ProtectedSettings
	if extension.ProtectedSettings != nil {
		protectedSetting := extension.ProtectedSettings.Copy()
		destination.ProtectedSettings = &protectedSetting
	} else {
		destination.ProtectedSettings = nil
	}

	// ProtectedSettingsFromKeyVault
	if extension.ProtectedSettingsFromKeyVault != nil {
		var protectedSettingsFromKeyVault storage.KeyVaultSecretReference
		err := extension.ProtectedSettingsFromKeyVault.AssignProperties_To_KeyVaultSecretReference(&protectedSettingsFromKeyVault)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_KeyVaultSecretReference() to populate field ProtectedSettingsFromKeyVault")
		}
		destination.ProtectedSettingsFromKeyVault = &protectedSettingsFromKeyVault
	} else {
		destination.ProtectedSettingsFromKeyVault = nil
	}

	// ProvisionAfterExtensions
	destination.ProvisionAfterExtensions = genruntime.CloneSliceOfString(extension.ProvisionAfterExtensions)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(extension.Publisher)

	// Settings
	if extension.Settings != nil {
		settingMap := make(map[string]v1.JSON, len(extension.Settings))
		for settingKey, settingValue := range extension.Settings {
			// Shadow the loop variable to avoid aliasing
			settingValue := settingValue
			settingMap[settingKey] = *settingValue.DeepCopy()
		}
		destination.Settings = settingMap
	} else {
		destination.Settings = nil
	}

	// SuppressFailures
	if extension.SuppressFailures != nil {
		suppressFailure := *extension.SuppressFailures
		destination.SuppressFailures = &suppressFailure
	} else {
		destination.SuppressFailures = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(extension.Type)

	// TypeHandlerVersion
	destination.TypeHandlerVersion = genruntime.ClonePointerToString(extension.TypeHandlerVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualMachineScaleSetExtension_STATUS populates our VirtualMachineScaleSetExtension from the provided source VirtualMachineScaleSetExtension_STATUS
func (extension *VirtualMachineScaleSetExtension) Initialize_From_VirtualMachineScaleSetExtension_STATUS(source *VirtualMachineScaleSetExtension_STATUS) error {

	// AutoUpgradeMinorVersion
	if source.AutoUpgradeMinorVersion != nil {
		autoUpgradeMinorVersion := *source.AutoUpgradeMinorVersion
		extension.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
	} else {
		extension.AutoUpgradeMinorVersion = nil
	}

	// EnableAutomaticUpgrade
	if source.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *source.EnableAutomaticUpgrade
		extension.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	} else {
		extension.EnableAutomaticUpgrade = nil
	}

	// ForceUpdateTag
	extension.ForceUpdateTag = genruntime.ClonePointerToString(source.ForceUpdateTag)

	// Name
	extension.Name = genruntime.ClonePointerToString(source.Name)

	// ProtectedSettingsFromKeyVault
	if source.ProtectedSettingsFromKeyVault != nil {
		var protectedSettingsFromKeyVault KeyVaultSecretReference
		err := protectedSettingsFromKeyVault.Initialize_From_KeyVaultSecretReference_STATUS(source.ProtectedSettingsFromKeyVault)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_KeyVaultSecretReference_STATUS() to populate field ProtectedSettingsFromKeyVault")
		}
		extension.ProtectedSettingsFromKeyVault = &protectedSettingsFromKeyVault
	} else {
		extension.ProtectedSettingsFromKeyVault = nil
	}

	// ProvisionAfterExtensions
	extension.ProvisionAfterExtensions = genruntime.CloneSliceOfString(source.ProvisionAfterExtensions)

	// Publisher
	extension.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// Settings
	if source.Settings != nil {
		settingMap := make(map[string]v1.JSON, len(source.Settings))
		for settingKey, settingValue := range source.Settings {
			// Shadow the loop variable to avoid aliasing
			settingValue := settingValue
			settingMap[settingKey] = *settingValue.DeepCopy()
		}
		extension.Settings = settingMap
	} else {
		extension.Settings = nil
	}

	// SuppressFailures
	if source.SuppressFailures != nil {
		suppressFailure := *source.SuppressFailures
		extension.SuppressFailures = &suppressFailure
	} else {
		extension.SuppressFailures = nil
	}

	// Type
	extension.Type = genruntime.ClonePointerToString(source.PropertiesType)

	// TypeHandlerVersion
	extension.TypeHandlerVersion = genruntime.ClonePointerToString(source.TypeHandlerVersion)

	// No error
	return nil
}

// Describes a Virtual Machine Scale Set Extension.
type VirtualMachineScaleSetExtension_STATUS struct {
	// AutoUpgradeMinorVersion: Indicates whether the extension should use a newer minor version if one is available at
	// deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this
	// property set to true.
	AutoUpgradeMinorVersion *bool `json:"autoUpgradeMinorVersion,omitempty"`

	// EnableAutomaticUpgrade: Indicates whether the extension should be automatically upgraded by the platform if there is a
	// newer version of the extension available.
	EnableAutomaticUpgrade *bool `json:"enableAutomaticUpgrade,omitempty"`

	// ForceUpdateTag: If a value is provided and is different from the previous value, the extension handler will be forced to
	// update even if the extension configuration has not changed.
	ForceUpdateTag *string `json:"forceUpdateTag,omitempty"`

	// Id: Resource Id
	Id *string `json:"id,omitempty"`

	// Name: The name of the extension.
	Name *string `json:"name,omitempty"`

	// PropertiesType: Specifies the type of the extension; an example is "CustomScriptExtension".
	PropertiesType *string `json:"properties_type,omitempty"`

	// ProtectedSettingsFromKeyVault: The extensions protected settings that are passed by reference, and consumed from key
	// vault
	ProtectedSettingsFromKeyVault *KeyVaultSecretReference_STATUS `json:"protectedSettingsFromKeyVault,omitempty"`

	// ProvisionAfterExtensions: Collection of extension names after which this extension needs to be provisioned.
	ProvisionAfterExtensions []string `json:"provisionAfterExtensions,omitempty"`

	// ProvisioningState: The provisioning state, which only appears in the response.
	ProvisioningState *string `json:"provisioningState,omitempty"`

	// Publisher: The name of the extension handler publisher.
	Publisher *string `json:"publisher,omitempty"`

	// Settings: Json formatted public settings for the extension.
	Settings map[string]v1.JSON `json:"settings,omitempty"`

	// SuppressFailures: Indicates whether failures stemming from the extension will be suppressed (Operational failures such
	// as not connecting to the VM will not be suppressed regardless of this value). The default is false.
	SuppressFailures *bool `json:"suppressFailures,omitempty"`

	// Type: Resource type
	Type *string `json:"type,omitempty"`

	// TypeHandlerVersion: Specifies the version of the script handler.
	TypeHandlerVersion *string `json:"typeHandlerVersion,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetExtension_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (extension *VirtualMachineScaleSetExtension_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSetExtension_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (extension *VirtualMachineScaleSetExtension_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSetExtension_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSetExtension_STATUS, got %T", armInput)
	}

	// Set property "AutoUpgradeMinorVersion":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutoUpgradeMinorVersion != nil {
			autoUpgradeMinorVersion := *typedInput.Properties.AutoUpgradeMinorVersion
			extension.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
		}
	}

	// Set property "EnableAutomaticUpgrade":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableAutomaticUpgrade != nil {
			enableAutomaticUpgrade := *typedInput.Properties.EnableAutomaticUpgrade
			extension.EnableAutomaticUpgrade = &enableAutomaticUpgrade
		}
	}

	// Set property "ForceUpdateTag":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ForceUpdateTag != nil {
			forceUpdateTag := *typedInput.Properties.ForceUpdateTag
			extension.ForceUpdateTag = &forceUpdateTag
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		extension.Id = &id
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		extension.Name = &name
	}

	// Set property "PropertiesType":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Type != nil {
			propertiesType := *typedInput.Properties.Type
			extension.PropertiesType = &propertiesType
		}
	}

	// Set property "ProtectedSettingsFromKeyVault":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProtectedSettingsFromKeyVault != nil {
			var protectedSettingsFromKeyVault1 KeyVaultSecretReference_STATUS
			err := protectedSettingsFromKeyVault1.PopulateFromARM(owner, *typedInput.Properties.ProtectedSettingsFromKeyVault)
			if err != nil {
				return err
			}
			protectedSettingsFromKeyVault := protectedSettingsFromKeyVault1
			extension.ProtectedSettingsFromKeyVault = &protectedSettingsFromKeyVault
		}
	}

	// Set property "ProvisionAfterExtensions":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ProvisionAfterExtensions {
			extension.ProvisionAfterExtensions = append(extension.ProvisionAfterExtensions, item)
		}
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			extension.ProvisioningState = &provisioningState
		}
	}

	// Set property "Publisher":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Publisher != nil {
			publisher := *typedInput.Properties.Publisher
			extension.Publisher = &publisher
		}
	}

	// Set property "Settings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Settings != nil {
			extension.Settings = make(map[string]v1.JSON, len(typedInput.Properties.Settings))
			for key, value := range typedInput.Properties.Settings {
				extension.Settings[key] = *value.DeepCopy()
			}
		}
	}

	// Set property "SuppressFailures":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SuppressFailures != nil {
			suppressFailures := *typedInput.Properties.SuppressFailures
			extension.SuppressFailures = &suppressFailures
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		extension.Type = &typeVar
	}

	// Set property "TypeHandlerVersion":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TypeHandlerVersion != nil {
			typeHandlerVersion := *typedInput.Properties.TypeHandlerVersion
			extension.TypeHandlerVersion = &typeHandlerVersion
		}
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSetExtension_STATUS populates our VirtualMachineScaleSetExtension_STATUS from the provided source VirtualMachineScaleSetExtension_STATUS
func (extension *VirtualMachineScaleSetExtension_STATUS) AssignProperties_From_VirtualMachineScaleSetExtension_STATUS(source *storage.VirtualMachineScaleSetExtension_STATUS) error {

	// AutoUpgradeMinorVersion
	if source.AutoUpgradeMinorVersion != nil {
		autoUpgradeMinorVersion := *source.AutoUpgradeMinorVersion
		extension.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
	} else {
		extension.AutoUpgradeMinorVersion = nil
	}

	// EnableAutomaticUpgrade
	if source.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *source.EnableAutomaticUpgrade
		extension.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	} else {
		extension.EnableAutomaticUpgrade = nil
	}

	// ForceUpdateTag
	extension.ForceUpdateTag = genruntime.ClonePointerToString(source.ForceUpdateTag)

	// Id
	extension.Id = genruntime.ClonePointerToString(source.Id)

	// Name
	extension.Name = genruntime.ClonePointerToString(source.Name)

	// PropertiesType
	extension.PropertiesType = genruntime.ClonePointerToString(source.PropertiesType)

	// ProtectedSettingsFromKeyVault
	if source.ProtectedSettingsFromKeyVault != nil {
		var protectedSettingsFromKeyVault KeyVaultSecretReference_STATUS
		err := protectedSettingsFromKeyVault.AssignProperties_From_KeyVaultSecretReference_STATUS(source.ProtectedSettingsFromKeyVault)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_KeyVaultSecretReference_STATUS() to populate field ProtectedSettingsFromKeyVault")
		}
		extension.ProtectedSettingsFromKeyVault = &protectedSettingsFromKeyVault
	} else {
		extension.ProtectedSettingsFromKeyVault = nil
	}

	// ProvisionAfterExtensions
	extension.ProvisionAfterExtensions = genruntime.CloneSliceOfString(source.ProvisionAfterExtensions)

	// ProvisioningState
	extension.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// Publisher
	extension.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// Settings
	if source.Settings != nil {
		settingMap := make(map[string]v1.JSON, len(source.Settings))
		for settingKey, settingValue := range source.Settings {
			// Shadow the loop variable to avoid aliasing
			settingValue := settingValue
			settingMap[settingKey] = *settingValue.DeepCopy()
		}
		extension.Settings = settingMap
	} else {
		extension.Settings = nil
	}

	// SuppressFailures
	if source.SuppressFailures != nil {
		suppressFailure := *source.SuppressFailures
		extension.SuppressFailures = &suppressFailure
	} else {
		extension.SuppressFailures = nil
	}

	// Type
	extension.Type = genruntime.ClonePointerToString(source.Type)

	// TypeHandlerVersion
	extension.TypeHandlerVersion = genruntime.ClonePointerToString(source.TypeHandlerVersion)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetExtension_STATUS populates the provided destination VirtualMachineScaleSetExtension_STATUS from our VirtualMachineScaleSetExtension_STATUS
func (extension *VirtualMachineScaleSetExtension_STATUS) AssignProperties_To_VirtualMachineScaleSetExtension_STATUS(destination *storage.VirtualMachineScaleSetExtension_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AutoUpgradeMinorVersion
	if extension.AutoUpgradeMinorVersion != nil {
		autoUpgradeMinorVersion := *extension.AutoUpgradeMinorVersion
		destination.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
	} else {
		destination.AutoUpgradeMinorVersion = nil
	}

	// EnableAutomaticUpgrade
	if extension.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *extension.EnableAutomaticUpgrade
		destination.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	} else {
		destination.EnableAutomaticUpgrade = nil
	}

	// ForceUpdateTag
	destination.ForceUpdateTag = genruntime.ClonePointerToString(extension.ForceUpdateTag)

	// Id
	destination.Id = genruntime.ClonePointerToString(extension.Id)

	// Name
	destination.Name = genruntime.ClonePointerToString(extension.Name)

	// PropertiesType
	destination.PropertiesType = genruntime.ClonePointerToString(extension.PropertiesType)

	// ProtectedSettingsFromKeyVault
	if extension.ProtectedSettingsFromKeyVault != nil {
		var protectedSettingsFromKeyVault storage.KeyVaultSecretReference_STATUS
		err := extension.ProtectedSettingsFromKeyVault.AssignProperties_To_KeyVaultSecretReference_STATUS(&protectedSettingsFromKeyVault)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_KeyVaultSecretReference_STATUS() to populate field ProtectedSettingsFromKeyVault")
		}
		destination.ProtectedSettingsFromKeyVault = &protectedSettingsFromKeyVault
	} else {
		destination.ProtectedSettingsFromKeyVault = nil
	}

	// ProvisionAfterExtensions
	destination.ProvisionAfterExtensions = genruntime.CloneSliceOfString(extension.ProvisionAfterExtensions)

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(extension.ProvisioningState)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(extension.Publisher)

	// Settings
	if extension.Settings != nil {
		settingMap := make(map[string]v1.JSON, len(extension.Settings))
		for settingKey, settingValue := range extension.Settings {
			// Shadow the loop variable to avoid aliasing
			settingValue := settingValue
			settingMap[settingKey] = *settingValue.DeepCopy()
		}
		destination.Settings = settingMap
	} else {
		destination.Settings = nil
	}

	// SuppressFailures
	if extension.SuppressFailures != nil {
		suppressFailure := *extension.SuppressFailures
		destination.SuppressFailures = &suppressFailure
	} else {
		destination.SuppressFailures = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(extension.Type)

	// TypeHandlerVersion
	destination.TypeHandlerVersion = genruntime.ClonePointerToString(extension.TypeHandlerVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes a virtual machine scale set network profile's network configurations.
type VirtualMachineScaleSetNetworkConfiguration struct {
	// DeleteOption: Specify what happens to the network interface when the VM is deleted
	DeleteOption *VirtualMachineScaleSetNetworkConfigurationProperties_DeleteOption `json:"deleteOption,omitempty"`

	// DnsSettings: The dns settings to be applied on the network interfaces.
	DnsSettings *VirtualMachineScaleSetNetworkConfigurationDnsSettings `json:"dnsSettings,omitempty"`

	// EnableAcceleratedNetworking: Specifies whether the network interface is accelerated networking-enabled.
	EnableAcceleratedNetworking *bool `json:"enableAcceleratedNetworking,omitempty"`

	// EnableFpga: Specifies whether the network interface is FPGA networking-enabled.
	EnableFpga *bool `json:"enableFpga,omitempty"`

	// EnableIPForwarding: Whether IP forwarding enabled on this NIC.
	EnableIPForwarding *bool `json:"enableIPForwarding,omitempty"`

	// +kubebuilder:validation:Required
	// IpConfigurations: Specifies the IP configurations of the network interface.
	IpConfigurations []VirtualMachineScaleSetIPConfiguration `json:"ipConfigurations,omitempty"`

	// +kubebuilder:validation:Required
	// Name: The network configuration name.
	Name *string `json:"name,omitempty"`

	// NetworkSecurityGroup: The network security group.
	NetworkSecurityGroup *SubResource `json:"networkSecurityGroup,omitempty"`

	// Primary: Specifies the primary network interface in case the virtual machine has more than 1 network interface.
	Primary *bool `json:"primary,omitempty"`

	// Reference: Resource Id
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetNetworkConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *VirtualMachineScaleSetNetworkConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.VirtualMachineScaleSetNetworkConfiguration{}

	// Set property "Id":
	if configuration.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*configuration.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property "Name":
	if configuration.Name != nil {
		name := *configuration.Name
		result.Name = &name
	}

	// Set property "Properties":
	if configuration.DeleteOption != nil ||
		configuration.DnsSettings != nil ||
		configuration.EnableAcceleratedNetworking != nil ||
		configuration.EnableFpga != nil ||
		configuration.EnableIPForwarding != nil ||
		configuration.IpConfigurations != nil ||
		configuration.NetworkSecurityGroup != nil ||
		configuration.Primary != nil {
		result.Properties = &arm.VirtualMachineScaleSetNetworkConfigurationProperties{}
	}
	if configuration.DeleteOption != nil {
		var temp string
		temp = string(*configuration.DeleteOption)
		deleteOption := arm.VirtualMachineScaleSetNetworkConfigurationProperties_DeleteOption(temp)
		result.Properties.DeleteOption = &deleteOption
	}
	if configuration.DnsSettings != nil {
		dnsSettings_ARM, err := (*configuration.DnsSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dnsSettings := *dnsSettings_ARM.(*arm.VirtualMachineScaleSetNetworkConfigurationDnsSettings)
		result.Properties.DnsSettings = &dnsSettings
	}
	if configuration.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *configuration.EnableAcceleratedNetworking
		result.Properties.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	}
	if configuration.EnableFpga != nil {
		enableFpga := *configuration.EnableFpga
		result.Properties.EnableFpga = &enableFpga
	}
	if configuration.EnableIPForwarding != nil {
		enableIPForwarding := *configuration.EnableIPForwarding
		result.Properties.EnableIPForwarding = &enableIPForwarding
	}
	for _, item := range configuration.IpConfigurations {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.IpConfigurations = append(result.Properties.IpConfigurations, *item_ARM.(*arm.VirtualMachineScaleSetIPConfiguration))
	}
	if configuration.NetworkSecurityGroup != nil {
		networkSecurityGroup_ARM, err := (*configuration.NetworkSecurityGroup).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		networkSecurityGroup := *networkSecurityGroup_ARM.(*arm.SubResource)
		result.Properties.NetworkSecurityGroup = &networkSecurityGroup
	}
	if configuration.Primary != nil {
		primary := *configuration.Primary
		result.Properties.Primary = &primary
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *VirtualMachineScaleSetNetworkConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSetNetworkConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *VirtualMachineScaleSetNetworkConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSetNetworkConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSetNetworkConfiguration, got %T", armInput)
	}

	// Set property "DeleteOption":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DeleteOption != nil {
			var temp string
			temp = string(*typedInput.Properties.DeleteOption)
			deleteOption := VirtualMachineScaleSetNetworkConfigurationProperties_DeleteOption(temp)
			configuration.DeleteOption = &deleteOption
		}
	}

	// Set property "DnsSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsSettings != nil {
			var dnsSettings1 VirtualMachineScaleSetNetworkConfigurationDnsSettings
			err := dnsSettings1.PopulateFromARM(owner, *typedInput.Properties.DnsSettings)
			if err != nil {
				return err
			}
			dnsSettings := dnsSettings1
			configuration.DnsSettings = &dnsSettings
		}
	}

	// Set property "EnableAcceleratedNetworking":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableAcceleratedNetworking != nil {
			enableAcceleratedNetworking := *typedInput.Properties.EnableAcceleratedNetworking
			configuration.EnableAcceleratedNetworking = &enableAcceleratedNetworking
		}
	}

	// Set property "EnableFpga":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableFpga != nil {
			enableFpga := *typedInput.Properties.EnableFpga
			configuration.EnableFpga = &enableFpga
		}
	}

	// Set property "EnableIPForwarding":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableIPForwarding != nil {
			enableIPForwarding := *typedInput.Properties.EnableIPForwarding
			configuration.EnableIPForwarding = &enableIPForwarding
		}
	}

	// Set property "IpConfigurations":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpConfigurations {
			var item1 VirtualMachineScaleSetIPConfiguration
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.IpConfigurations = append(configuration.IpConfigurations, item1)
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		configuration.Name = &name
	}

	// Set property "NetworkSecurityGroup":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkSecurityGroup != nil {
			var networkSecurityGroup1 SubResource
			err := networkSecurityGroup1.PopulateFromARM(owner, *typedInput.Properties.NetworkSecurityGroup)
			if err != nil {
				return err
			}
			networkSecurityGroup := networkSecurityGroup1
			configuration.NetworkSecurityGroup = &networkSecurityGroup
		}
	}

	// Set property "Primary":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			configuration.Primary = &primary
		}
	}

	// no assignment for property "Reference"

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSetNetworkConfiguration populates our VirtualMachineScaleSetNetworkConfiguration from the provided source VirtualMachineScaleSetNetworkConfiguration
func (configuration *VirtualMachineScaleSetNetworkConfiguration) AssignProperties_From_VirtualMachineScaleSetNetworkConfiguration(source *storage.VirtualMachineScaleSetNetworkConfiguration) error {

	// DeleteOption
	if source.DeleteOption != nil {
		deleteOption := *source.DeleteOption
		deleteOptionTemp := genruntime.ToEnum(deleteOption, virtualMachineScaleSetNetworkConfigurationProperties_DeleteOption_Values)
		configuration.DeleteOption = &deleteOptionTemp
	} else {
		configuration.DeleteOption = nil
	}

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting VirtualMachineScaleSetNetworkConfigurationDnsSettings
		err := dnsSetting.AssignProperties_From_VirtualMachineScaleSetNetworkConfigurationDnsSettings(source.DnsSettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetNetworkConfigurationDnsSettings() to populate field DnsSettings")
		}
		configuration.DnsSettings = &dnsSetting
	} else {
		configuration.DnsSettings = nil
	}

	// EnableAcceleratedNetworking
	if source.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *source.EnableAcceleratedNetworking
		configuration.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		configuration.EnableAcceleratedNetworking = nil
	}

	// EnableFpga
	if source.EnableFpga != nil {
		enableFpga := *source.EnableFpga
		configuration.EnableFpga = &enableFpga
	} else {
		configuration.EnableFpga = nil
	}

	// EnableIPForwarding
	if source.EnableIPForwarding != nil {
		enableIPForwarding := *source.EnableIPForwarding
		configuration.EnableIPForwarding = &enableIPForwarding
	} else {
		configuration.EnableIPForwarding = nil
	}

	// IpConfigurations
	if source.IpConfigurations != nil {
		ipConfigurationList := make([]VirtualMachineScaleSetIPConfiguration, len(source.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range source.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration VirtualMachineScaleSetIPConfiguration
			err := ipConfiguration.AssignProperties_From_VirtualMachineScaleSetIPConfiguration(&ipConfigurationItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetIPConfiguration() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		configuration.IpConfigurations = ipConfigurationList
	} else {
		configuration.IpConfigurations = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// NetworkSecurityGroup
	if source.NetworkSecurityGroup != nil {
		var networkSecurityGroup SubResource
		err := networkSecurityGroup.AssignProperties_From_SubResource(source.NetworkSecurityGroup)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SubResource() to populate field NetworkSecurityGroup")
		}
		configuration.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		configuration.NetworkSecurityGroup = nil
	}

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		configuration.Primary = &primary
	} else {
		configuration.Primary = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		configuration.Reference = &reference
	} else {
		configuration.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetNetworkConfiguration populates the provided destination VirtualMachineScaleSetNetworkConfiguration from our VirtualMachineScaleSetNetworkConfiguration
func (configuration *VirtualMachineScaleSetNetworkConfiguration) AssignProperties_To_VirtualMachineScaleSetNetworkConfiguration(destination *storage.VirtualMachineScaleSetNetworkConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DeleteOption
	if configuration.DeleteOption != nil {
		deleteOption := string(*configuration.DeleteOption)
		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// DnsSettings
	if configuration.DnsSettings != nil {
		var dnsSetting storage.VirtualMachineScaleSetNetworkConfigurationDnsSettings
		err := configuration.DnsSettings.AssignProperties_To_VirtualMachineScaleSetNetworkConfigurationDnsSettings(&dnsSetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetNetworkConfigurationDnsSettings() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// EnableAcceleratedNetworking
	if configuration.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *configuration.EnableAcceleratedNetworking
		destination.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		destination.EnableAcceleratedNetworking = nil
	}

	// EnableFpga
	if configuration.EnableFpga != nil {
		enableFpga := *configuration.EnableFpga
		destination.EnableFpga = &enableFpga
	} else {
		destination.EnableFpga = nil
	}

	// EnableIPForwarding
	if configuration.EnableIPForwarding != nil {
		enableIPForwarding := *configuration.EnableIPForwarding
		destination.EnableIPForwarding = &enableIPForwarding
	} else {
		destination.EnableIPForwarding = nil
	}

	// IpConfigurations
	if configuration.IpConfigurations != nil {
		ipConfigurationList := make([]storage.VirtualMachineScaleSetIPConfiguration, len(configuration.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range configuration.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration storage.VirtualMachineScaleSetIPConfiguration
			err := ipConfigurationItem.AssignProperties_To_VirtualMachineScaleSetIPConfiguration(&ipConfiguration)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetIPConfiguration() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		destination.IpConfigurations = ipConfigurationList
	} else {
		destination.IpConfigurations = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// NetworkSecurityGroup
	if configuration.NetworkSecurityGroup != nil {
		var networkSecurityGroup storage.SubResource
		err := configuration.NetworkSecurityGroup.AssignProperties_To_SubResource(&networkSecurityGroup)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SubResource() to populate field NetworkSecurityGroup")
		}
		destination.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		destination.NetworkSecurityGroup = nil
	}

	// Primary
	if configuration.Primary != nil {
		primary := *configuration.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// Reference
	if configuration.Reference != nil {
		reference := configuration.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualMachineScaleSetNetworkConfiguration_STATUS populates our VirtualMachineScaleSetNetworkConfiguration from the provided source VirtualMachineScaleSetNetworkConfiguration_STATUS
func (configuration *VirtualMachineScaleSetNetworkConfiguration) Initialize_From_VirtualMachineScaleSetNetworkConfiguration_STATUS(source *VirtualMachineScaleSetNetworkConfiguration_STATUS) error {

	// DeleteOption
	if source.DeleteOption != nil {
		deleteOption := genruntime.ToEnum(string(*source.DeleteOption), virtualMachineScaleSetNetworkConfigurationProperties_DeleteOption_Values)
		configuration.DeleteOption = &deleteOption
	} else {
		configuration.DeleteOption = nil
	}

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting VirtualMachineScaleSetNetworkConfigurationDnsSettings
		err := dnsSetting.Initialize_From_VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS(source.DnsSettings)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS() to populate field DnsSettings")
		}
		configuration.DnsSettings = &dnsSetting
	} else {
		configuration.DnsSettings = nil
	}

	// EnableAcceleratedNetworking
	if source.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *source.EnableAcceleratedNetworking
		configuration.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		configuration.EnableAcceleratedNetworking = nil
	}

	// EnableFpga
	if source.EnableFpga != nil {
		enableFpga := *source.EnableFpga
		configuration.EnableFpga = &enableFpga
	} else {
		configuration.EnableFpga = nil
	}

	// EnableIPForwarding
	if source.EnableIPForwarding != nil {
		enableIPForwarding := *source.EnableIPForwarding
		configuration.EnableIPForwarding = &enableIPForwarding
	} else {
		configuration.EnableIPForwarding = nil
	}

	// IpConfigurations
	if source.IpConfigurations != nil {
		ipConfigurationList := make([]VirtualMachineScaleSetIPConfiguration, len(source.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range source.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration VirtualMachineScaleSetIPConfiguration
			err := ipConfiguration.Initialize_From_VirtualMachineScaleSetIPConfiguration_STATUS(&ipConfigurationItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_VirtualMachineScaleSetIPConfiguration_STATUS() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		configuration.IpConfigurations = ipConfigurationList
	} else {
		configuration.IpConfigurations = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// NetworkSecurityGroup
	if source.NetworkSecurityGroup != nil {
		var networkSecurityGroup SubResource
		err := networkSecurityGroup.Initialize_From_SubResource_STATUS(source.NetworkSecurityGroup)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_SubResource_STATUS() to populate field NetworkSecurityGroup")
		}
		configuration.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		configuration.NetworkSecurityGroup = nil
	}

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		configuration.Primary = &primary
	} else {
		configuration.Primary = nil
	}

	// Reference
	if source.Id != nil {
		reference := genruntime.CreateResourceReferenceFromARMID(*source.Id)
		configuration.Reference = &reference
	} else {
		configuration.Reference = nil
	}

	// No error
	return nil
}

// Describes a virtual machine scale set network profile's network configurations.
type VirtualMachineScaleSetNetworkConfiguration_STATUS struct {
	// DeleteOption: Specify what happens to the network interface when the VM is deleted
	DeleteOption *VirtualMachineScaleSetNetworkConfigurationProperties_DeleteOption_STATUS `json:"deleteOption,omitempty"`

	// DnsSettings: The dns settings to be applied on the network interfaces.
	DnsSettings *VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS `json:"dnsSettings,omitempty"`

	// EnableAcceleratedNetworking: Specifies whether the network interface is accelerated networking-enabled.
	EnableAcceleratedNetworking *bool `json:"enableAcceleratedNetworking,omitempty"`

	// EnableFpga: Specifies whether the network interface is FPGA networking-enabled.
	EnableFpga *bool `json:"enableFpga,omitempty"`

	// EnableIPForwarding: Whether IP forwarding enabled on this NIC.
	EnableIPForwarding *bool `json:"enableIPForwarding,omitempty"`

	// Id: Resource Id
	Id *string `json:"id,omitempty"`

	// IpConfigurations: Specifies the IP configurations of the network interface.
	IpConfigurations []VirtualMachineScaleSetIPConfiguration_STATUS `json:"ipConfigurations,omitempty"`

	// Name: The network configuration name.
	Name *string `json:"name,omitempty"`

	// NetworkSecurityGroup: The network security group.
	NetworkSecurityGroup *SubResource_STATUS `json:"networkSecurityGroup,omitempty"`

	// Primary: Specifies the primary network interface in case the virtual machine has more than 1 network interface.
	Primary *bool `json:"primary,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetNetworkConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *VirtualMachineScaleSetNetworkConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSetNetworkConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *VirtualMachineScaleSetNetworkConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSetNetworkConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSetNetworkConfiguration_STATUS, got %T", armInput)
	}

	// Set property "DeleteOption":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DeleteOption != nil {
			var temp string
			temp = string(*typedInput.Properties.DeleteOption)
			deleteOption := VirtualMachineScaleSetNetworkConfigurationProperties_DeleteOption_STATUS(temp)
			configuration.DeleteOption = &deleteOption
		}
	}

	// Set property "DnsSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsSettings != nil {
			var dnsSettings1 VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS
			err := dnsSettings1.PopulateFromARM(owner, *typedInput.Properties.DnsSettings)
			if err != nil {
				return err
			}
			dnsSettings := dnsSettings1
			configuration.DnsSettings = &dnsSettings
		}
	}

	// Set property "EnableAcceleratedNetworking":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableAcceleratedNetworking != nil {
			enableAcceleratedNetworking := *typedInput.Properties.EnableAcceleratedNetworking
			configuration.EnableAcceleratedNetworking = &enableAcceleratedNetworking
		}
	}

	// Set property "EnableFpga":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableFpga != nil {
			enableFpga := *typedInput.Properties.EnableFpga
			configuration.EnableFpga = &enableFpga
		}
	}

	// Set property "EnableIPForwarding":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableIPForwarding != nil {
			enableIPForwarding := *typedInput.Properties.EnableIPForwarding
			configuration.EnableIPForwarding = &enableIPForwarding
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		configuration.Id = &id
	}

	// Set property "IpConfigurations":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpConfigurations {
			var item1 VirtualMachineScaleSetIPConfiguration_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.IpConfigurations = append(configuration.IpConfigurations, item1)
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		configuration.Name = &name
	}

	// Set property "NetworkSecurityGroup":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkSecurityGroup != nil {
			var networkSecurityGroup1 SubResource_STATUS
			err := networkSecurityGroup1.PopulateFromARM(owner, *typedInput.Properties.NetworkSecurityGroup)
			if err != nil {
				return err
			}
			networkSecurityGroup := networkSecurityGroup1
			configuration.NetworkSecurityGroup = &networkSecurityGroup
		}
	}

	// Set property "Primary":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			configuration.Primary = &primary
		}
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSetNetworkConfiguration_STATUS populates our VirtualMachineScaleSetNetworkConfiguration_STATUS from the provided source VirtualMachineScaleSetNetworkConfiguration_STATUS
func (configuration *VirtualMachineScaleSetNetworkConfiguration_STATUS) AssignProperties_From_VirtualMachineScaleSetNetworkConfiguration_STATUS(source *storage.VirtualMachineScaleSetNetworkConfiguration_STATUS) error {

	// DeleteOption
	if source.DeleteOption != nil {
		deleteOption := *source.DeleteOption
		deleteOptionTemp := genruntime.ToEnum(deleteOption, virtualMachineScaleSetNetworkConfigurationProperties_DeleteOption_STATUS_Values)
		configuration.DeleteOption = &deleteOptionTemp
	} else {
		configuration.DeleteOption = nil
	}

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS
		err := dnsSetting.AssignProperties_From_VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS(source.DnsSettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS() to populate field DnsSettings")
		}
		configuration.DnsSettings = &dnsSetting
	} else {
		configuration.DnsSettings = nil
	}

	// EnableAcceleratedNetworking
	if source.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *source.EnableAcceleratedNetworking
		configuration.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		configuration.EnableAcceleratedNetworking = nil
	}

	// EnableFpga
	if source.EnableFpga != nil {
		enableFpga := *source.EnableFpga
		configuration.EnableFpga = &enableFpga
	} else {
		configuration.EnableFpga = nil
	}

	// EnableIPForwarding
	if source.EnableIPForwarding != nil {
		enableIPForwarding := *source.EnableIPForwarding
		configuration.EnableIPForwarding = &enableIPForwarding
	} else {
		configuration.EnableIPForwarding = nil
	}

	// Id
	configuration.Id = genruntime.ClonePointerToString(source.Id)

	// IpConfigurations
	if source.IpConfigurations != nil {
		ipConfigurationList := make([]VirtualMachineScaleSetIPConfiguration_STATUS, len(source.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range source.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration VirtualMachineScaleSetIPConfiguration_STATUS
			err := ipConfiguration.AssignProperties_From_VirtualMachineScaleSetIPConfiguration_STATUS(&ipConfigurationItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetIPConfiguration_STATUS() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		configuration.IpConfigurations = ipConfigurationList
	} else {
		configuration.IpConfigurations = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// NetworkSecurityGroup
	if source.NetworkSecurityGroup != nil {
		var networkSecurityGroup SubResource_STATUS
		err := networkSecurityGroup.AssignProperties_From_SubResource_STATUS(source.NetworkSecurityGroup)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field NetworkSecurityGroup")
		}
		configuration.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		configuration.NetworkSecurityGroup = nil
	}

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		configuration.Primary = &primary
	} else {
		configuration.Primary = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetNetworkConfiguration_STATUS populates the provided destination VirtualMachineScaleSetNetworkConfiguration_STATUS from our VirtualMachineScaleSetNetworkConfiguration_STATUS
func (configuration *VirtualMachineScaleSetNetworkConfiguration_STATUS) AssignProperties_To_VirtualMachineScaleSetNetworkConfiguration_STATUS(destination *storage.VirtualMachineScaleSetNetworkConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DeleteOption
	if configuration.DeleteOption != nil {
		deleteOption := string(*configuration.DeleteOption)
		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// DnsSettings
	if configuration.DnsSettings != nil {
		var dnsSetting storage.VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS
		err := configuration.DnsSettings.AssignProperties_To_VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS(&dnsSetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// EnableAcceleratedNetworking
	if configuration.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *configuration.EnableAcceleratedNetworking
		destination.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		destination.EnableAcceleratedNetworking = nil
	}

	// EnableFpga
	if configuration.EnableFpga != nil {
		enableFpga := *configuration.EnableFpga
		destination.EnableFpga = &enableFpga
	} else {
		destination.EnableFpga = nil
	}

	// EnableIPForwarding
	if configuration.EnableIPForwarding != nil {
		enableIPForwarding := *configuration.EnableIPForwarding
		destination.EnableIPForwarding = &enableIPForwarding
	} else {
		destination.EnableIPForwarding = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(configuration.Id)

	// IpConfigurations
	if configuration.IpConfigurations != nil {
		ipConfigurationList := make([]storage.VirtualMachineScaleSetIPConfiguration_STATUS, len(configuration.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range configuration.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration storage.VirtualMachineScaleSetIPConfiguration_STATUS
			err := ipConfigurationItem.AssignProperties_To_VirtualMachineScaleSetIPConfiguration_STATUS(&ipConfiguration)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetIPConfiguration_STATUS() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		destination.IpConfigurations = ipConfigurationList
	} else {
		destination.IpConfigurations = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// NetworkSecurityGroup
	if configuration.NetworkSecurityGroup != nil {
		var networkSecurityGroup storage.SubResource_STATUS
		err := configuration.NetworkSecurityGroup.AssignProperties_To_SubResource_STATUS(&networkSecurityGroup)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field NetworkSecurityGroup")
		}
		destination.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		destination.NetworkSecurityGroup = nil
	}

	// Primary
	if configuration.Primary != nil {
		primary := *configuration.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"2020-11-01"}
type VirtualMachineScaleSetNetworkProfile_NetworkApiVersion string

const VirtualMachineScaleSetNetworkProfile_NetworkApiVersion_20201101 = VirtualMachineScaleSetNetworkProfile_NetworkApiVersion("2020-11-01")

// Mapping from string to VirtualMachineScaleSetNetworkProfile_NetworkApiVersion
var virtualMachineScaleSetNetworkProfile_NetworkApiVersion_Values = map[string]VirtualMachineScaleSetNetworkProfile_NetworkApiVersion{
	"2020-11-01": VirtualMachineScaleSetNetworkProfile_NetworkApiVersion_20201101,
}

type VirtualMachineScaleSetNetworkProfile_NetworkApiVersion_STATUS string

const VirtualMachineScaleSetNetworkProfile_NetworkApiVersion_STATUS_20201101 = VirtualMachineScaleSetNetworkProfile_NetworkApiVersion_STATUS("2020-11-01")

// Mapping from string to VirtualMachineScaleSetNetworkProfile_NetworkApiVersion_STATUS
var virtualMachineScaleSetNetworkProfile_NetworkApiVersion_STATUS_Values = map[string]VirtualMachineScaleSetNetworkProfile_NetworkApiVersion_STATUS{
	"2020-11-01": VirtualMachineScaleSetNetworkProfile_NetworkApiVersion_STATUS_20201101,
}

// Describes a virtual machine scale set operating system disk.
type VirtualMachineScaleSetOSDisk struct {
	// Caching: Specifies the caching requirements.
	// Possible values are:
	// None
	// ReadOnly
	// ReadWrite
	// Default: None for Standard storage. ReadOnly for Premium storage
	Caching *Caching `json:"caching,omitempty"`

	// +kubebuilder:validation:Required
	// CreateOption: Specifies how the virtual machines in the scale set should be created.
	// The only allowed value is: FromImage \u2013 This value is used when you are using an image to create the virtual
	// machine. If you are using a platform image, you also use the imageReference element described above. If you are using a
	// marketplace image, you  also use the plan element previously described.
	CreateOption *CreateOption `json:"createOption,omitempty"`

	// DeleteOption: Specifies whether OS Disk should be deleted or detached upon VMSS Flex deletion (This feature is available
	// for VMSS with Flexible OrchestrationMode only).
	// Possible values:
	// Delete If this value is used, the OS disk is deleted when VMSS Flex VM is deleted.
	// Detach If this value is used, the OS disk is retained after VMSS Flex VM is deleted.
	// The default value is set to Delete. For an Ephemeral OS Disk, the default value is set to Delete. User cannot change the
	// delete option for Ephemeral OS Disk.
	DeleteOption *DeleteOption `json:"deleteOption,omitempty"`

	// DiffDiskSettings: Specifies the ephemeral disk Settings for the operating system disk used by the virtual machine scale
	// set.
	DiffDiskSettings *DiffDiskSettings `json:"diffDiskSettings,omitempty"`

	// DiskSizeGB: Specifies the size of the operating system disk in gigabytes. This element can be used to overwrite the size
	// of the disk in a virtual machine image.
	// This value cannot be larger than 1023 GB
	DiskSizeGB *int `json:"diskSizeGB,omitempty"`

	// Image: Specifies information about the unmanaged user image to base the scale set on.
	Image *VirtualHardDisk `json:"image,omitempty"`

	// ManagedDisk: The managed disk parameters.
	ManagedDisk *VirtualMachineScaleSetManagedDiskParameters `json:"managedDisk,omitempty"`

	// Name: The disk name.
	Name *string `json:"name,omitempty"`

	// OsType: This property allows you to specify the type of the OS that is included in the disk if creating a VM from
	// user-image or a specialized VHD.
	// Possible values are:
	// Windows
	// Linux
	OsType *VirtualMachineScaleSetOSDisk_OsType `json:"osType,omitempty"`

	// VhdContainers: Specifies the container urls that are used to store operating system disks for the scale set.
	VhdContainers []string `json:"vhdContainers,omitempty"`

	// WriteAcceleratorEnabled: Specifies whether writeAccelerator should be enabled or disabled on the disk.
	WriteAcceleratorEnabled *bool `json:"writeAcceleratorEnabled,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetOSDisk{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (disk *VirtualMachineScaleSetOSDisk) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if disk == nil {
		return nil, nil
	}
	result := &arm.VirtualMachineScaleSetOSDisk{}

	// Set property "Caching":
	if disk.Caching != nil {
		var temp string
		temp = string(*disk.Caching)
		caching := arm.Caching(temp)
		result.Caching = &caching
	}

	// Set property "CreateOption":
	if disk.CreateOption != nil {
		var temp string
		temp = string(*disk.CreateOption)
		createOption := arm.CreateOption(temp)
		result.CreateOption = &createOption
	}

	// Set property "DeleteOption":
	if disk.DeleteOption != nil {
		var temp string
		temp = string(*disk.DeleteOption)
		deleteOption := arm.DeleteOption(temp)
		result.DeleteOption = &deleteOption
	}

	// Set property "DiffDiskSettings":
	if disk.DiffDiskSettings != nil {
		diffDiskSettings_ARM, err := (*disk.DiffDiskSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		diffDiskSettings := *diffDiskSettings_ARM.(*arm.DiffDiskSettings)
		result.DiffDiskSettings = &diffDiskSettings
	}

	// Set property "DiskSizeGB":
	if disk.DiskSizeGB != nil {
		diskSizeGB := *disk.DiskSizeGB
		result.DiskSizeGB = &diskSizeGB
	}

	// Set property "Image":
	if disk.Image != nil {
		image_ARM, err := (*disk.Image).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		image := *image_ARM.(*arm.VirtualHardDisk)
		result.Image = &image
	}

	// Set property "ManagedDisk":
	if disk.ManagedDisk != nil {
		managedDisk_ARM, err := (*disk.ManagedDisk).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		managedDisk := *managedDisk_ARM.(*arm.VirtualMachineScaleSetManagedDiskParameters)
		result.ManagedDisk = &managedDisk
	}

	// Set property "Name":
	if disk.Name != nil {
		name := *disk.Name
		result.Name = &name
	}

	// Set property "OsType":
	if disk.OsType != nil {
		var temp string
		temp = string(*disk.OsType)
		osType := arm.VirtualMachineScaleSetOSDisk_OsType(temp)
		result.OsType = &osType
	}

	// Set property "VhdContainers":
	for _, item := range disk.VhdContainers {
		result.VhdContainers = append(result.VhdContainers, item)
	}

	// Set property "WriteAcceleratorEnabled":
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		result.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (disk *VirtualMachineScaleSetOSDisk) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSetOSDisk{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (disk *VirtualMachineScaleSetOSDisk) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSetOSDisk)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSetOSDisk, got %T", armInput)
	}

	// Set property "Caching":
	if typedInput.Caching != nil {
		var temp string
		temp = string(*typedInput.Caching)
		caching := Caching(temp)
		disk.Caching = &caching
	}

	// Set property "CreateOption":
	if typedInput.CreateOption != nil {
		var temp string
		temp = string(*typedInput.CreateOption)
		createOption := CreateOption(temp)
		disk.CreateOption = &createOption
	}

	// Set property "DeleteOption":
	if typedInput.DeleteOption != nil {
		var temp string
		temp = string(*typedInput.DeleteOption)
		deleteOption := DeleteOption(temp)
		disk.DeleteOption = &deleteOption
	}

	// Set property "DiffDiskSettings":
	if typedInput.DiffDiskSettings != nil {
		var diffDiskSettings1 DiffDiskSettings
		err := diffDiskSettings1.PopulateFromARM(owner, *typedInput.DiffDiskSettings)
		if err != nil {
			return err
		}
		diffDiskSettings := diffDiskSettings1
		disk.DiffDiskSettings = &diffDiskSettings
	}

	// Set property "DiskSizeGB":
	if typedInput.DiskSizeGB != nil {
		diskSizeGB := *typedInput.DiskSizeGB
		disk.DiskSizeGB = &diskSizeGB
	}

	// Set property "Image":
	if typedInput.Image != nil {
		var image1 VirtualHardDisk
		err := image1.PopulateFromARM(owner, *typedInput.Image)
		if err != nil {
			return err
		}
		image := image1
		disk.Image = &image
	}

	// Set property "ManagedDisk":
	if typedInput.ManagedDisk != nil {
		var managedDisk1 VirtualMachineScaleSetManagedDiskParameters
		err := managedDisk1.PopulateFromARM(owner, *typedInput.ManagedDisk)
		if err != nil {
			return err
		}
		managedDisk := managedDisk1
		disk.ManagedDisk = &managedDisk
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		disk.Name = &name
	}

	// Set property "OsType":
	if typedInput.OsType != nil {
		var temp string
		temp = string(*typedInput.OsType)
		osType := VirtualMachineScaleSetOSDisk_OsType(temp)
		disk.OsType = &osType
	}

	// Set property "VhdContainers":
	for _, item := range typedInput.VhdContainers {
		disk.VhdContainers = append(disk.VhdContainers, item)
	}

	// Set property "WriteAcceleratorEnabled":
	if typedInput.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *typedInput.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSetOSDisk populates our VirtualMachineScaleSetOSDisk from the provided source VirtualMachineScaleSetOSDisk
func (disk *VirtualMachineScaleSetOSDisk) AssignProperties_From_VirtualMachineScaleSetOSDisk(source *storage.VirtualMachineScaleSetOSDisk) error {

	// Caching
	if source.Caching != nil {
		caching := *source.Caching
		cachingTemp := genruntime.ToEnum(caching, caching_Values)
		disk.Caching = &cachingTemp
	} else {
		disk.Caching = nil
	}

	// CreateOption
	if source.CreateOption != nil {
		createOption := *source.CreateOption
		createOptionTemp := genruntime.ToEnum(createOption, createOption_Values)
		disk.CreateOption = &createOptionTemp
	} else {
		disk.CreateOption = nil
	}

	// DeleteOption
	if source.DeleteOption != nil {
		deleteOption := *source.DeleteOption
		deleteOptionTemp := genruntime.ToEnum(deleteOption, deleteOption_Values)
		disk.DeleteOption = &deleteOptionTemp
	} else {
		disk.DeleteOption = nil
	}

	// DiffDiskSettings
	if source.DiffDiskSettings != nil {
		var diffDiskSetting DiffDiskSettings
		err := diffDiskSetting.AssignProperties_From_DiffDiskSettings(source.DiffDiskSettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DiffDiskSettings() to populate field DiffDiskSettings")
		}
		disk.DiffDiskSettings = &diffDiskSetting
	} else {
		disk.DiffDiskSettings = nil
	}

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// Image
	if source.Image != nil {
		var image VirtualHardDisk
		err := image.AssignProperties_From_VirtualHardDisk(source.Image)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualHardDisk() to populate field Image")
		}
		disk.Image = &image
	} else {
		disk.Image = nil
	}

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk VirtualMachineScaleSetManagedDiskParameters
		err := managedDisk.AssignProperties_From_VirtualMachineScaleSetManagedDiskParameters(source.ManagedDisk)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetManagedDiskParameters() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// OsType
	if source.OsType != nil {
		osType := *source.OsType
		osTypeTemp := genruntime.ToEnum(osType, virtualMachineScaleSetOSDisk_OsType_Values)
		disk.OsType = &osTypeTemp
	} else {
		disk.OsType = nil
	}

	// VhdContainers
	disk.VhdContainers = genruntime.CloneSliceOfString(source.VhdContainers)

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetOSDisk populates the provided destination VirtualMachineScaleSetOSDisk from our VirtualMachineScaleSetOSDisk
func (disk *VirtualMachineScaleSetOSDisk) AssignProperties_To_VirtualMachineScaleSetOSDisk(destination *storage.VirtualMachineScaleSetOSDisk) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Caching
	if disk.Caching != nil {
		caching := string(*disk.Caching)
		destination.Caching = &caching
	} else {
		destination.Caching = nil
	}

	// CreateOption
	if disk.CreateOption != nil {
		createOption := string(*disk.CreateOption)
		destination.CreateOption = &createOption
	} else {
		destination.CreateOption = nil
	}

	// DeleteOption
	if disk.DeleteOption != nil {
		deleteOption := string(*disk.DeleteOption)
		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// DiffDiskSettings
	if disk.DiffDiskSettings != nil {
		var diffDiskSetting storage.DiffDiskSettings
		err := disk.DiffDiskSettings.AssignProperties_To_DiffDiskSettings(&diffDiskSetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DiffDiskSettings() to populate field DiffDiskSettings")
		}
		destination.DiffDiskSettings = &diffDiskSetting
	} else {
		destination.DiffDiskSettings = nil
	}

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// Image
	if disk.Image != nil {
		var image storage.VirtualHardDisk
		err := disk.Image.AssignProperties_To_VirtualHardDisk(&image)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualHardDisk() to populate field Image")
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk storage.VirtualMachineScaleSetManagedDiskParameters
		err := disk.ManagedDisk.AssignProperties_To_VirtualMachineScaleSetManagedDiskParameters(&managedDisk)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetManagedDiskParameters() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// OsType
	if disk.OsType != nil {
		osType := string(*disk.OsType)
		destination.OsType = &osType
	} else {
		destination.OsType = nil
	}

	// VhdContainers
	destination.VhdContainers = genruntime.CloneSliceOfString(disk.VhdContainers)

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualMachineScaleSetOSDisk_STATUS populates our VirtualMachineScaleSetOSDisk from the provided source VirtualMachineScaleSetOSDisk_STATUS
func (disk *VirtualMachineScaleSetOSDisk) Initialize_From_VirtualMachineScaleSetOSDisk_STATUS(source *VirtualMachineScaleSetOSDisk_STATUS) error {

	// Caching
	if source.Caching != nil {
		caching := genruntime.ToEnum(string(*source.Caching), caching_Values)
		disk.Caching = &caching
	} else {
		disk.Caching = nil
	}

	// CreateOption
	if source.CreateOption != nil {
		createOption := genruntime.ToEnum(string(*source.CreateOption), createOption_Values)
		disk.CreateOption = &createOption
	} else {
		disk.CreateOption = nil
	}

	// DeleteOption
	if source.DeleteOption != nil {
		deleteOption := genruntime.ToEnum(string(*source.DeleteOption), deleteOption_Values)
		disk.DeleteOption = &deleteOption
	} else {
		disk.DeleteOption = nil
	}

	// DiffDiskSettings
	if source.DiffDiskSettings != nil {
		var diffDiskSetting DiffDiskSettings
		err := diffDiskSetting.Initialize_From_DiffDiskSettings_STATUS(source.DiffDiskSettings)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_DiffDiskSettings_STATUS() to populate field DiffDiskSettings")
		}
		disk.DiffDiskSettings = &diffDiskSetting
	} else {
		disk.DiffDiskSettings = nil
	}

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// Image
	if source.Image != nil {
		var image VirtualHardDisk
		err := image.Initialize_From_VirtualHardDisk_STATUS(source.Image)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_VirtualHardDisk_STATUS() to populate field Image")
		}
		disk.Image = &image
	} else {
		disk.Image = nil
	}

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk VirtualMachineScaleSetManagedDiskParameters
		err := managedDisk.Initialize_From_VirtualMachineScaleSetManagedDiskParameters_STATUS(source.ManagedDisk)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_VirtualMachineScaleSetManagedDiskParameters_STATUS() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// OsType
	if source.OsType != nil {
		osType := genruntime.ToEnum(string(*source.OsType), virtualMachineScaleSetOSDisk_OsType_Values)
		disk.OsType = &osType
	} else {
		disk.OsType = nil
	}

	// VhdContainers
	disk.VhdContainers = genruntime.CloneSliceOfString(source.VhdContainers)

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// No error
	return nil
}

// Describes a virtual machine scale set operating system disk.
type VirtualMachineScaleSetOSDisk_STATUS struct {
	// Caching: Specifies the caching requirements.
	// Possible values are:
	// None
	// ReadOnly
	// ReadWrite
	// Default: None for Standard storage. ReadOnly for Premium storage
	Caching *Caching_STATUS `json:"caching,omitempty"`

	// CreateOption: Specifies how the virtual machines in the scale set should be created.
	// The only allowed value is: FromImage \u2013 This value is used when you are using an image to create the virtual
	// machine. If you are using a platform image, you also use the imageReference element described above. If you are using a
	// marketplace image, you  also use the plan element previously described.
	CreateOption *CreateOption_STATUS `json:"createOption,omitempty"`

	// DeleteOption: Specifies whether OS Disk should be deleted or detached upon VMSS Flex deletion (This feature is available
	// for VMSS with Flexible OrchestrationMode only).
	// Possible values:
	// Delete If this value is used, the OS disk is deleted when VMSS Flex VM is deleted.
	// Detach If this value is used, the OS disk is retained after VMSS Flex VM is deleted.
	// The default value is set to Delete. For an Ephemeral OS Disk, the default value is set to Delete. User cannot change the
	// delete option for Ephemeral OS Disk.
	DeleteOption *DeleteOption_STATUS `json:"deleteOption,omitempty"`

	// DiffDiskSettings: Specifies the ephemeral disk Settings for the operating system disk used by the virtual machine scale
	// set.
	DiffDiskSettings *DiffDiskSettings_STATUS `json:"diffDiskSettings,omitempty"`

	// DiskSizeGB: Specifies the size of the operating system disk in gigabytes. This element can be used to overwrite the size
	// of the disk in a virtual machine image.
	// This value cannot be larger than 1023 GB
	DiskSizeGB *int `json:"diskSizeGB,omitempty"`

	// Image: Specifies information about the unmanaged user image to base the scale set on.
	Image *VirtualHardDisk_STATUS `json:"image,omitempty"`

	// ManagedDisk: The managed disk parameters.
	ManagedDisk *VirtualMachineScaleSetManagedDiskParameters_STATUS `json:"managedDisk,omitempty"`

	// Name: The disk name.
	Name *string `json:"name,omitempty"`

	// OsType: This property allows you to specify the type of the OS that is included in the disk if creating a VM from
	// user-image or a specialized VHD.
	// Possible values are:
	// Windows
	// Linux
	OsType *VirtualMachineScaleSetOSDisk_OsType_STATUS `json:"osType,omitempty"`

	// VhdContainers: Specifies the container urls that are used to store operating system disks for the scale set.
	VhdContainers []string `json:"vhdContainers,omitempty"`

	// WriteAcceleratorEnabled: Specifies whether writeAccelerator should be enabled or disabled on the disk.
	WriteAcceleratorEnabled *bool `json:"writeAcceleratorEnabled,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetOSDisk_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (disk *VirtualMachineScaleSetOSDisk_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSetOSDisk_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (disk *VirtualMachineScaleSetOSDisk_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSetOSDisk_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSetOSDisk_STATUS, got %T", armInput)
	}

	// Set property "Caching":
	if typedInput.Caching != nil {
		var temp string
		temp = string(*typedInput.Caching)
		caching := Caching_STATUS(temp)
		disk.Caching = &caching
	}

	// Set property "CreateOption":
	if typedInput.CreateOption != nil {
		var temp string
		temp = string(*typedInput.CreateOption)
		createOption := CreateOption_STATUS(temp)
		disk.CreateOption = &createOption
	}

	// Set property "DeleteOption":
	if typedInput.DeleteOption != nil {
		var temp string
		temp = string(*typedInput.DeleteOption)
		deleteOption := DeleteOption_STATUS(temp)
		disk.DeleteOption = &deleteOption
	}

	// Set property "DiffDiskSettings":
	if typedInput.DiffDiskSettings != nil {
		var diffDiskSettings1 DiffDiskSettings_STATUS
		err := diffDiskSettings1.PopulateFromARM(owner, *typedInput.DiffDiskSettings)
		if err != nil {
			return err
		}
		diffDiskSettings := diffDiskSettings1
		disk.DiffDiskSettings = &diffDiskSettings
	}

	// Set property "DiskSizeGB":
	if typedInput.DiskSizeGB != nil {
		diskSizeGB := *typedInput.DiskSizeGB
		disk.DiskSizeGB = &diskSizeGB
	}

	// Set property "Image":
	if typedInput.Image != nil {
		var image1 VirtualHardDisk_STATUS
		err := image1.PopulateFromARM(owner, *typedInput.Image)
		if err != nil {
			return err
		}
		image := image1
		disk.Image = &image
	}

	// Set property "ManagedDisk":
	if typedInput.ManagedDisk != nil {
		var managedDisk1 VirtualMachineScaleSetManagedDiskParameters_STATUS
		err := managedDisk1.PopulateFromARM(owner, *typedInput.ManagedDisk)
		if err != nil {
			return err
		}
		managedDisk := managedDisk1
		disk.ManagedDisk = &managedDisk
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		disk.Name = &name
	}

	// Set property "OsType":
	if typedInput.OsType != nil {
		var temp string
		temp = string(*typedInput.OsType)
		osType := VirtualMachineScaleSetOSDisk_OsType_STATUS(temp)
		disk.OsType = &osType
	}

	// Set property "VhdContainers":
	for _, item := range typedInput.VhdContainers {
		disk.VhdContainers = append(disk.VhdContainers, item)
	}

	// Set property "WriteAcceleratorEnabled":
	if typedInput.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *typedInput.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSetOSDisk_STATUS populates our VirtualMachineScaleSetOSDisk_STATUS from the provided source VirtualMachineScaleSetOSDisk_STATUS
func (disk *VirtualMachineScaleSetOSDisk_STATUS) AssignProperties_From_VirtualMachineScaleSetOSDisk_STATUS(source *storage.VirtualMachineScaleSetOSDisk_STATUS) error {

	// Caching
	if source.Caching != nil {
		caching := *source.Caching
		cachingTemp := genruntime.ToEnum(caching, caching_STATUS_Values)
		disk.Caching = &cachingTemp
	} else {
		disk.Caching = nil
	}

	// CreateOption
	if source.CreateOption != nil {
		createOption := *source.CreateOption
		createOptionTemp := genruntime.ToEnum(createOption, createOption_STATUS_Values)
		disk.CreateOption = &createOptionTemp
	} else {
		disk.CreateOption = nil
	}

	// DeleteOption
	if source.DeleteOption != nil {
		deleteOption := *source.DeleteOption
		deleteOptionTemp := genruntime.ToEnum(deleteOption, deleteOption_STATUS_Values)
		disk.DeleteOption = &deleteOptionTemp
	} else {
		disk.DeleteOption = nil
	}

	// DiffDiskSettings
	if source.DiffDiskSettings != nil {
		var diffDiskSetting DiffDiskSettings_STATUS
		err := diffDiskSetting.AssignProperties_From_DiffDiskSettings_STATUS(source.DiffDiskSettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DiffDiskSettings_STATUS() to populate field DiffDiskSettings")
		}
		disk.DiffDiskSettings = &diffDiskSetting
	} else {
		disk.DiffDiskSettings = nil
	}

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// Image
	if source.Image != nil {
		var image VirtualHardDisk_STATUS
		err := image.AssignProperties_From_VirtualHardDisk_STATUS(source.Image)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualHardDisk_STATUS() to populate field Image")
		}
		disk.Image = &image
	} else {
		disk.Image = nil
	}

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk VirtualMachineScaleSetManagedDiskParameters_STATUS
		err := managedDisk.AssignProperties_From_VirtualMachineScaleSetManagedDiskParameters_STATUS(source.ManagedDisk)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetManagedDiskParameters_STATUS() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// OsType
	if source.OsType != nil {
		osType := *source.OsType
		osTypeTemp := genruntime.ToEnum(osType, virtualMachineScaleSetOSDisk_OsType_STATUS_Values)
		disk.OsType = &osTypeTemp
	} else {
		disk.OsType = nil
	}

	// VhdContainers
	disk.VhdContainers = genruntime.CloneSliceOfString(source.VhdContainers)

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetOSDisk_STATUS populates the provided destination VirtualMachineScaleSetOSDisk_STATUS from our VirtualMachineScaleSetOSDisk_STATUS
func (disk *VirtualMachineScaleSetOSDisk_STATUS) AssignProperties_To_VirtualMachineScaleSetOSDisk_STATUS(destination *storage.VirtualMachineScaleSetOSDisk_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Caching
	if disk.Caching != nil {
		caching := string(*disk.Caching)
		destination.Caching = &caching
	} else {
		destination.Caching = nil
	}

	// CreateOption
	if disk.CreateOption != nil {
		createOption := string(*disk.CreateOption)
		destination.CreateOption = &createOption
	} else {
		destination.CreateOption = nil
	}

	// DeleteOption
	if disk.DeleteOption != nil {
		deleteOption := string(*disk.DeleteOption)
		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// DiffDiskSettings
	if disk.DiffDiskSettings != nil {
		var diffDiskSetting storage.DiffDiskSettings_STATUS
		err := disk.DiffDiskSettings.AssignProperties_To_DiffDiskSettings_STATUS(&diffDiskSetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DiffDiskSettings_STATUS() to populate field DiffDiskSettings")
		}
		destination.DiffDiskSettings = &diffDiskSetting
	} else {
		destination.DiffDiskSettings = nil
	}

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// Image
	if disk.Image != nil {
		var image storage.VirtualHardDisk_STATUS
		err := disk.Image.AssignProperties_To_VirtualHardDisk_STATUS(&image)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualHardDisk_STATUS() to populate field Image")
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk storage.VirtualMachineScaleSetManagedDiskParameters_STATUS
		err := disk.ManagedDisk.AssignProperties_To_VirtualMachineScaleSetManagedDiskParameters_STATUS(&managedDisk)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetManagedDiskParameters_STATUS() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// OsType
	if disk.OsType != nil {
		osType := string(*disk.OsType)
		destination.OsType = &osType
	} else {
		destination.OsType = nil
	}

	// VhdContainers
	destination.VhdContainers = genruntime.CloneSliceOfString(disk.VhdContainers)

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes a virtual machine scale set network profile's IP configuration.
type VirtualMachineScaleSetIPConfiguration struct {
	// ApplicationGatewayBackendAddressPools: Specifies an array of references to backend address pools of application
	// gateways. A scale set can reference backend address pools of multiple application gateways. Multiple scale sets cannot
	// use the same application gateway.
	ApplicationGatewayBackendAddressPools []SubResource `json:"applicationGatewayBackendAddressPools,omitempty"`

	// ApplicationSecurityGroups: Specifies an array of references to application security group.
	ApplicationSecurityGroups []SubResource `json:"applicationSecurityGroups,omitempty"`

	// LoadBalancerBackendAddressPools: Specifies an array of references to backend address pools of load balancers. A scale
	// set can reference backend address pools of one public and one internal load balancer. Multiple scale sets cannot use the
	// same basic sku load balancer.
	LoadBalancerBackendAddressPools []SubResource `json:"loadBalancerBackendAddressPools,omitempty"`

	// LoadBalancerInboundNatPools: Specifies an array of references to inbound Nat pools of the load balancers. A scale set
	// can reference inbound nat pools of one public and one internal load balancer. Multiple scale sets cannot use the same
	// basic sku load balancer.
	LoadBalancerInboundNatPools []SubResource `json:"loadBalancerInboundNatPools,omitempty"`

	// +kubebuilder:validation:Required
	// Name: The IP configuration name.
	Name *string `json:"name,omitempty"`

	// Primary: Specifies the primary network interface in case the virtual machine has more than 1 network interface.
	Primary *bool `json:"primary,omitempty"`

	// PrivateIPAddressVersion: Available from Api-Version 2017-03-30 onwards, it represents whether the specific
	// ipconfiguration is IPv4 or IPv6. Default is taken as IPv4.  Possible values are: 'IPv4' and 'IPv6'.
	PrivateIPAddressVersion *VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion `json:"privateIPAddressVersion,omitempty"`

	// PublicIPAddressConfiguration: The publicIPAddressConfiguration.
	PublicIPAddressConfiguration *VirtualMachineScaleSetPublicIPAddressConfiguration `json:"publicIPAddressConfiguration,omitempty"`

	// Reference: Resource Id
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`

	// Subnet: Specifies the identifier of the subnet.
	Subnet *ApiEntityReference `json:"subnet,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetIPConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *VirtualMachineScaleSetIPConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.VirtualMachineScaleSetIPConfiguration{}

	// Set property "Id":
	if configuration.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*configuration.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property "Name":
	if configuration.Name != nil {
		name := *configuration.Name
		result.Name = &name
	}

	// Set property "Properties":
	if configuration.ApplicationGatewayBackendAddressPools != nil ||
		configuration.ApplicationSecurityGroups != nil ||
		configuration.LoadBalancerBackendAddressPools != nil ||
		configuration.LoadBalancerInboundNatPools != nil ||
		configuration.Primary != nil ||
		configuration.PrivateIPAddressVersion != nil ||
		configuration.PublicIPAddressConfiguration != nil ||
		configuration.Subnet != nil {
		result.Properties = &arm.VirtualMachineScaleSetIPConfigurationProperties{}
	}
	for _, item := range configuration.ApplicationGatewayBackendAddressPools {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.ApplicationGatewayBackendAddressPools = append(result.Properties.ApplicationGatewayBackendAddressPools, *item_ARM.(*arm.SubResource))
	}
	for _, item := range configuration.ApplicationSecurityGroups {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.ApplicationSecurityGroups = append(result.Properties.ApplicationSecurityGroups, *item_ARM.(*arm.SubResource))
	}
	for _, item := range configuration.LoadBalancerBackendAddressPools {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.LoadBalancerBackendAddressPools = append(result.Properties.LoadBalancerBackendAddressPools, *item_ARM.(*arm.SubResource))
	}
	for _, item := range configuration.LoadBalancerInboundNatPools {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.LoadBalancerInboundNatPools = append(result.Properties.LoadBalancerInboundNatPools, *item_ARM.(*arm.SubResource))
	}
	if configuration.Primary != nil {
		primary := *configuration.Primary
		result.Properties.Primary = &primary
	}
	if configuration.PrivateIPAddressVersion != nil {
		var temp string
		temp = string(*configuration.PrivateIPAddressVersion)
		privateIPAddressVersion := arm.VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion(temp)
		result.Properties.PrivateIPAddressVersion = &privateIPAddressVersion
	}
	if configuration.PublicIPAddressConfiguration != nil {
		publicIPAddressConfiguration_ARM, err := (*configuration.PublicIPAddressConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		publicIPAddressConfiguration := *publicIPAddressConfiguration_ARM.(*arm.VirtualMachineScaleSetPublicIPAddressConfiguration)
		result.Properties.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	}
	if configuration.Subnet != nil {
		subnet_ARM, err := (*configuration.Subnet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		subnet := *subnet_ARM.(*arm.ApiEntityReference)
		result.Properties.Subnet = &subnet
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *VirtualMachineScaleSetIPConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSetIPConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *VirtualMachineScaleSetIPConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSetIPConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSetIPConfiguration, got %T", armInput)
	}

	// Set property "ApplicationGatewayBackendAddressPools":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationGatewayBackendAddressPools {
			var item1 SubResource
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.ApplicationGatewayBackendAddressPools = append(configuration.ApplicationGatewayBackendAddressPools, item1)
		}
	}

	// Set property "ApplicationSecurityGroups":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationSecurityGroups {
			var item1 SubResource
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.ApplicationSecurityGroups = append(configuration.ApplicationSecurityGroups, item1)
		}
	}

	// Set property "LoadBalancerBackendAddressPools":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancerBackendAddressPools {
			var item1 SubResource
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.LoadBalancerBackendAddressPools = append(configuration.LoadBalancerBackendAddressPools, item1)
		}
	}

	// Set property "LoadBalancerInboundNatPools":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancerInboundNatPools {
			var item1 SubResource
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.LoadBalancerInboundNatPools = append(configuration.LoadBalancerInboundNatPools, item1)
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		configuration.Name = &name
	}

	// Set property "Primary":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			configuration.Primary = &primary
		}
	}

	// Set property "PrivateIPAddressVersion":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddressVersion != nil {
			var temp string
			temp = string(*typedInput.Properties.PrivateIPAddressVersion)
			privateIPAddressVersion := VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion(temp)
			configuration.PrivateIPAddressVersion = &privateIPAddressVersion
		}
	}

	// Set property "PublicIPAddressConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddressConfiguration != nil {
			var publicIPAddressConfiguration1 VirtualMachineScaleSetPublicIPAddressConfiguration
			err := publicIPAddressConfiguration1.PopulateFromARM(owner, *typedInput.Properties.PublicIPAddressConfiguration)
			if err != nil {
				return err
			}
			publicIPAddressConfiguration := publicIPAddressConfiguration1
			configuration.PublicIPAddressConfiguration = &publicIPAddressConfiguration
		}
	}

	// no assignment for property "Reference"

	// Set property "Subnet":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Subnet != nil {
			var subnet1 ApiEntityReference
			err := subnet1.PopulateFromARM(owner, *typedInput.Properties.Subnet)
			if err != nil {
				return err
			}
			subnet := subnet1
			configuration.Subnet = &subnet
		}
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSetIPConfiguration populates our VirtualMachineScaleSetIPConfiguration from the provided source VirtualMachineScaleSetIPConfiguration
func (configuration *VirtualMachineScaleSetIPConfiguration) AssignProperties_From_VirtualMachineScaleSetIPConfiguration(source *storage.VirtualMachineScaleSetIPConfiguration) error {

	// ApplicationGatewayBackendAddressPools
	if source.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]SubResource, len(source.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range source.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var applicationGatewayBackendAddressPool SubResource
			err := applicationGatewayBackendAddressPool.AssignProperties_From_SubResource(&applicationGatewayBackendAddressPoolItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_SubResource() to populate field ApplicationGatewayBackendAddressPools")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		configuration.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		configuration.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if source.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]SubResource, len(source.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range source.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var applicationSecurityGroup SubResource
			err := applicationSecurityGroup.AssignProperties_From_SubResource(&applicationSecurityGroupItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_SubResource() to populate field ApplicationSecurityGroups")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		configuration.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		configuration.ApplicationSecurityGroups = nil
	}

	// LoadBalancerBackendAddressPools
	if source.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]SubResource, len(source.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range source.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var loadBalancerBackendAddressPool SubResource
			err := loadBalancerBackendAddressPool.AssignProperties_From_SubResource(&loadBalancerBackendAddressPoolItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_SubResource() to populate field LoadBalancerBackendAddressPools")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		configuration.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		configuration.LoadBalancerBackendAddressPools = nil
	}

	// LoadBalancerInboundNatPools
	if source.LoadBalancerInboundNatPools != nil {
		loadBalancerInboundNatPoolList := make([]SubResource, len(source.LoadBalancerInboundNatPools))
		for loadBalancerInboundNatPoolIndex, loadBalancerInboundNatPoolItem := range source.LoadBalancerInboundNatPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerInboundNatPoolItem := loadBalancerInboundNatPoolItem
			var loadBalancerInboundNatPool SubResource
			err := loadBalancerInboundNatPool.AssignProperties_From_SubResource(&loadBalancerInboundNatPoolItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_SubResource() to populate field LoadBalancerInboundNatPools")
			}
			loadBalancerInboundNatPoolList[loadBalancerInboundNatPoolIndex] = loadBalancerInboundNatPool
		}
		configuration.LoadBalancerInboundNatPools = loadBalancerInboundNatPoolList
	} else {
		configuration.LoadBalancerInboundNatPools = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		configuration.Primary = &primary
	} else {
		configuration.Primary = nil
	}

	// PrivateIPAddressVersion
	if source.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := *source.PrivateIPAddressVersion
		privateIPAddressVersionTemp := genruntime.ToEnum(privateIPAddressVersion, virtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion_Values)
		configuration.PrivateIPAddressVersion = &privateIPAddressVersionTemp
	} else {
		configuration.PrivateIPAddressVersion = nil
	}

	// PublicIPAddressConfiguration
	if source.PublicIPAddressConfiguration != nil {
		var publicIPAddressConfiguration VirtualMachineScaleSetPublicIPAddressConfiguration
		err := publicIPAddressConfiguration.AssignProperties_From_VirtualMachineScaleSetPublicIPAddressConfiguration(source.PublicIPAddressConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetPublicIPAddressConfiguration() to populate field PublicIPAddressConfiguration")
		}
		configuration.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	} else {
		configuration.PublicIPAddressConfiguration = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		configuration.Reference = &reference
	} else {
		configuration.Reference = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet ApiEntityReference
		err := subnet.AssignProperties_From_ApiEntityReference(source.Subnet)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ApiEntityReference() to populate field Subnet")
		}
		configuration.Subnet = &subnet
	} else {
		configuration.Subnet = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetIPConfiguration populates the provided destination VirtualMachineScaleSetIPConfiguration from our VirtualMachineScaleSetIPConfiguration
func (configuration *VirtualMachineScaleSetIPConfiguration) AssignProperties_To_VirtualMachineScaleSetIPConfiguration(destination *storage.VirtualMachineScaleSetIPConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ApplicationGatewayBackendAddressPools
	if configuration.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]storage.SubResource, len(configuration.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range configuration.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var applicationGatewayBackendAddressPool storage.SubResource
			err := applicationGatewayBackendAddressPoolItem.AssignProperties_To_SubResource(&applicationGatewayBackendAddressPool)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_SubResource() to populate field ApplicationGatewayBackendAddressPools")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		destination.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		destination.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if configuration.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]storage.SubResource, len(configuration.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range configuration.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var applicationSecurityGroup storage.SubResource
			err := applicationSecurityGroupItem.AssignProperties_To_SubResource(&applicationSecurityGroup)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_SubResource() to populate field ApplicationSecurityGroups")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		destination.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		destination.ApplicationSecurityGroups = nil
	}

	// LoadBalancerBackendAddressPools
	if configuration.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]storage.SubResource, len(configuration.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range configuration.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var loadBalancerBackendAddressPool storage.SubResource
			err := loadBalancerBackendAddressPoolItem.AssignProperties_To_SubResource(&loadBalancerBackendAddressPool)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_SubResource() to populate field LoadBalancerBackendAddressPools")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		destination.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		destination.LoadBalancerBackendAddressPools = nil
	}

	// LoadBalancerInboundNatPools
	if configuration.LoadBalancerInboundNatPools != nil {
		loadBalancerInboundNatPoolList := make([]storage.SubResource, len(configuration.LoadBalancerInboundNatPools))
		for loadBalancerInboundNatPoolIndex, loadBalancerInboundNatPoolItem := range configuration.LoadBalancerInboundNatPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerInboundNatPoolItem := loadBalancerInboundNatPoolItem
			var loadBalancerInboundNatPool storage.SubResource
			err := loadBalancerInboundNatPoolItem.AssignProperties_To_SubResource(&loadBalancerInboundNatPool)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_SubResource() to populate field LoadBalancerInboundNatPools")
			}
			loadBalancerInboundNatPoolList[loadBalancerInboundNatPoolIndex] = loadBalancerInboundNatPool
		}
		destination.LoadBalancerInboundNatPools = loadBalancerInboundNatPoolList
	} else {
		destination.LoadBalancerInboundNatPools = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// Primary
	if configuration.Primary != nil {
		primary := *configuration.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// PrivateIPAddressVersion
	if configuration.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := string(*configuration.PrivateIPAddressVersion)
		destination.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		destination.PrivateIPAddressVersion = nil
	}

	// PublicIPAddressConfiguration
	if configuration.PublicIPAddressConfiguration != nil {
		var publicIPAddressConfiguration storage.VirtualMachineScaleSetPublicIPAddressConfiguration
		err := configuration.PublicIPAddressConfiguration.AssignProperties_To_VirtualMachineScaleSetPublicIPAddressConfiguration(&publicIPAddressConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetPublicIPAddressConfiguration() to populate field PublicIPAddressConfiguration")
		}
		destination.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	} else {
		destination.PublicIPAddressConfiguration = nil
	}

	// Reference
	if configuration.Reference != nil {
		reference := configuration.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Subnet
	if configuration.Subnet != nil {
		var subnet storage.ApiEntityReference
		err := configuration.Subnet.AssignProperties_To_ApiEntityReference(&subnet)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ApiEntityReference() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualMachineScaleSetIPConfiguration_STATUS populates our VirtualMachineScaleSetIPConfiguration from the provided source VirtualMachineScaleSetIPConfiguration_STATUS
func (configuration *VirtualMachineScaleSetIPConfiguration) Initialize_From_VirtualMachineScaleSetIPConfiguration_STATUS(source *VirtualMachineScaleSetIPConfiguration_STATUS) error {

	// ApplicationGatewayBackendAddressPools
	if source.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]SubResource, len(source.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range source.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var applicationGatewayBackendAddressPool SubResource
			err := applicationGatewayBackendAddressPool.Initialize_From_SubResource_STATUS(&applicationGatewayBackendAddressPoolItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_SubResource_STATUS() to populate field ApplicationGatewayBackendAddressPools")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		configuration.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		configuration.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if source.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]SubResource, len(source.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range source.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var applicationSecurityGroup SubResource
			err := applicationSecurityGroup.Initialize_From_SubResource_STATUS(&applicationSecurityGroupItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_SubResource_STATUS() to populate field ApplicationSecurityGroups")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		configuration.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		configuration.ApplicationSecurityGroups = nil
	}

	// LoadBalancerBackendAddressPools
	if source.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]SubResource, len(source.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range source.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var loadBalancerBackendAddressPool SubResource
			err := loadBalancerBackendAddressPool.Initialize_From_SubResource_STATUS(&loadBalancerBackendAddressPoolItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_SubResource_STATUS() to populate field LoadBalancerBackendAddressPools")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		configuration.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		configuration.LoadBalancerBackendAddressPools = nil
	}

	// LoadBalancerInboundNatPools
	if source.LoadBalancerInboundNatPools != nil {
		loadBalancerInboundNatPoolList := make([]SubResource, len(source.LoadBalancerInboundNatPools))
		for loadBalancerInboundNatPoolIndex, loadBalancerInboundNatPoolItem := range source.LoadBalancerInboundNatPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerInboundNatPoolItem := loadBalancerInboundNatPoolItem
			var loadBalancerInboundNatPool SubResource
			err := loadBalancerInboundNatPool.Initialize_From_SubResource_STATUS(&loadBalancerInboundNatPoolItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_SubResource_STATUS() to populate field LoadBalancerInboundNatPools")
			}
			loadBalancerInboundNatPoolList[loadBalancerInboundNatPoolIndex] = loadBalancerInboundNatPool
		}
		configuration.LoadBalancerInboundNatPools = loadBalancerInboundNatPoolList
	} else {
		configuration.LoadBalancerInboundNatPools = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		configuration.Primary = &primary
	} else {
		configuration.Primary = nil
	}

	// PrivateIPAddressVersion
	if source.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := genruntime.ToEnum(string(*source.PrivateIPAddressVersion), virtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion_Values)
		configuration.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		configuration.PrivateIPAddressVersion = nil
	}

	// PublicIPAddressConfiguration
	if source.PublicIPAddressConfiguration != nil {
		var publicIPAddressConfiguration VirtualMachineScaleSetPublicIPAddressConfiguration
		err := publicIPAddressConfiguration.Initialize_From_VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS(source.PublicIPAddressConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS() to populate field PublicIPAddressConfiguration")
		}
		configuration.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	} else {
		configuration.PublicIPAddressConfiguration = nil
	}

	// Reference
	if source.Id != nil {
		reference := genruntime.CreateResourceReferenceFromARMID(*source.Id)
		configuration.Reference = &reference
	} else {
		configuration.Reference = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet ApiEntityReference
		err := subnet.Initialize_From_ApiEntityReference_STATUS(source.Subnet)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ApiEntityReference_STATUS() to populate field Subnet")
		}
		configuration.Subnet = &subnet
	} else {
		configuration.Subnet = nil
	}

	// No error
	return nil
}

// Describes a virtual machine scale set network profile's IP configuration.
type VirtualMachineScaleSetIPConfiguration_STATUS struct {
	// ApplicationGatewayBackendAddressPools: Specifies an array of references to backend address pools of application
	// gateways. A scale set can reference backend address pools of multiple application gateways. Multiple scale sets cannot
	// use the same application gateway.
	ApplicationGatewayBackendAddressPools []SubResource_STATUS `json:"applicationGatewayBackendAddressPools,omitempty"`

	// ApplicationSecurityGroups: Specifies an array of references to application security group.
	ApplicationSecurityGroups []SubResource_STATUS `json:"applicationSecurityGroups,omitempty"`

	// Id: Resource Id
	Id *string `json:"id,omitempty"`

	// LoadBalancerBackendAddressPools: Specifies an array of references to backend address pools of load balancers. A scale
	// set can reference backend address pools of one public and one internal load balancer. Multiple scale sets cannot use the
	// same basic sku load balancer.
	LoadBalancerBackendAddressPools []SubResource_STATUS `json:"loadBalancerBackendAddressPools,omitempty"`

	// LoadBalancerInboundNatPools: Specifies an array of references to inbound Nat pools of the load balancers. A scale set
	// can reference inbound nat pools of one public and one internal load balancer. Multiple scale sets cannot use the same
	// basic sku load balancer.
	LoadBalancerInboundNatPools []SubResource_STATUS `json:"loadBalancerInboundNatPools,omitempty"`

	// Name: The IP configuration name.
	Name *string `json:"name,omitempty"`

	// Primary: Specifies the primary network interface in case the virtual machine has more than 1 network interface.
	Primary *bool `json:"primary,omitempty"`

	// PrivateIPAddressVersion: Available from Api-Version 2017-03-30 onwards, it represents whether the specific
	// ipconfiguration is IPv4 or IPv6. Default is taken as IPv4.  Possible values are: 'IPv4' and 'IPv6'.
	PrivateIPAddressVersion *VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion_STATUS `json:"privateIPAddressVersion,omitempty"`

	// PublicIPAddressConfiguration: The publicIPAddressConfiguration.
	PublicIPAddressConfiguration *VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS `json:"publicIPAddressConfiguration,omitempty"`

	// Subnet: Specifies the identifier of the subnet.
	Subnet *ApiEntityReference_STATUS `json:"subnet,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetIPConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *VirtualMachineScaleSetIPConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSetIPConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *VirtualMachineScaleSetIPConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSetIPConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSetIPConfiguration_STATUS, got %T", armInput)
	}

	// Set property "ApplicationGatewayBackendAddressPools":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationGatewayBackendAddressPools {
			var item1 SubResource_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.ApplicationGatewayBackendAddressPools = append(configuration.ApplicationGatewayBackendAddressPools, item1)
		}
	}

	// Set property "ApplicationSecurityGroups":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationSecurityGroups {
			var item1 SubResource_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.ApplicationSecurityGroups = append(configuration.ApplicationSecurityGroups, item1)
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		configuration.Id = &id
	}

	// Set property "LoadBalancerBackendAddressPools":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancerBackendAddressPools {
			var item1 SubResource_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.LoadBalancerBackendAddressPools = append(configuration.LoadBalancerBackendAddressPools, item1)
		}
	}

	// Set property "LoadBalancerInboundNatPools":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancerInboundNatPools {
			var item1 SubResource_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.LoadBalancerInboundNatPools = append(configuration.LoadBalancerInboundNatPools, item1)
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		configuration.Name = &name
	}

	// Set property "Primary":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			configuration.Primary = &primary
		}
	}

	// Set property "PrivateIPAddressVersion":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddressVersion != nil {
			var temp string
			temp = string(*typedInput.Properties.PrivateIPAddressVersion)
			privateIPAddressVersion := VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion_STATUS(temp)
			configuration.PrivateIPAddressVersion = &privateIPAddressVersion
		}
	}

	// Set property "PublicIPAddressConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddressConfiguration != nil {
			var publicIPAddressConfiguration1 VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS
			err := publicIPAddressConfiguration1.PopulateFromARM(owner, *typedInput.Properties.PublicIPAddressConfiguration)
			if err != nil {
				return err
			}
			publicIPAddressConfiguration := publicIPAddressConfiguration1
			configuration.PublicIPAddressConfiguration = &publicIPAddressConfiguration
		}
	}

	// Set property "Subnet":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Subnet != nil {
			var subnet1 ApiEntityReference_STATUS
			err := subnet1.PopulateFromARM(owner, *typedInput.Properties.Subnet)
			if err != nil {
				return err
			}
			subnet := subnet1
			configuration.Subnet = &subnet
		}
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSetIPConfiguration_STATUS populates our VirtualMachineScaleSetIPConfiguration_STATUS from the provided source VirtualMachineScaleSetIPConfiguration_STATUS
func (configuration *VirtualMachineScaleSetIPConfiguration_STATUS) AssignProperties_From_VirtualMachineScaleSetIPConfiguration_STATUS(source *storage.VirtualMachineScaleSetIPConfiguration_STATUS) error {

	// ApplicationGatewayBackendAddressPools
	if source.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]SubResource_STATUS, len(source.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range source.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var applicationGatewayBackendAddressPool SubResource_STATUS
			err := applicationGatewayBackendAddressPool.AssignProperties_From_SubResource_STATUS(&applicationGatewayBackendAddressPoolItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field ApplicationGatewayBackendAddressPools")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		configuration.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		configuration.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if source.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]SubResource_STATUS, len(source.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range source.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var applicationSecurityGroup SubResource_STATUS
			err := applicationSecurityGroup.AssignProperties_From_SubResource_STATUS(&applicationSecurityGroupItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field ApplicationSecurityGroups")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		configuration.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		configuration.ApplicationSecurityGroups = nil
	}

	// Id
	configuration.Id = genruntime.ClonePointerToString(source.Id)

	// LoadBalancerBackendAddressPools
	if source.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]SubResource_STATUS, len(source.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range source.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var loadBalancerBackendAddressPool SubResource_STATUS
			err := loadBalancerBackendAddressPool.AssignProperties_From_SubResource_STATUS(&loadBalancerBackendAddressPoolItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field LoadBalancerBackendAddressPools")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		configuration.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		configuration.LoadBalancerBackendAddressPools = nil
	}

	// LoadBalancerInboundNatPools
	if source.LoadBalancerInboundNatPools != nil {
		loadBalancerInboundNatPoolList := make([]SubResource_STATUS, len(source.LoadBalancerInboundNatPools))
		for loadBalancerInboundNatPoolIndex, loadBalancerInboundNatPoolItem := range source.LoadBalancerInboundNatPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerInboundNatPoolItem := loadBalancerInboundNatPoolItem
			var loadBalancerInboundNatPool SubResource_STATUS
			err := loadBalancerInboundNatPool.AssignProperties_From_SubResource_STATUS(&loadBalancerInboundNatPoolItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field LoadBalancerInboundNatPools")
			}
			loadBalancerInboundNatPoolList[loadBalancerInboundNatPoolIndex] = loadBalancerInboundNatPool
		}
		configuration.LoadBalancerInboundNatPools = loadBalancerInboundNatPoolList
	} else {
		configuration.LoadBalancerInboundNatPools = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		configuration.Primary = &primary
	} else {
		configuration.Primary = nil
	}

	// PrivateIPAddressVersion
	if source.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := *source.PrivateIPAddressVersion
		privateIPAddressVersionTemp := genruntime.ToEnum(privateIPAddressVersion, virtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion_STATUS_Values)
		configuration.PrivateIPAddressVersion = &privateIPAddressVersionTemp
	} else {
		configuration.PrivateIPAddressVersion = nil
	}

	// PublicIPAddressConfiguration
	if source.PublicIPAddressConfiguration != nil {
		var publicIPAddressConfiguration VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS
		err := publicIPAddressConfiguration.AssignProperties_From_VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS(source.PublicIPAddressConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS() to populate field PublicIPAddressConfiguration")
		}
		configuration.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	} else {
		configuration.PublicIPAddressConfiguration = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet ApiEntityReference_STATUS
		err := subnet.AssignProperties_From_ApiEntityReference_STATUS(source.Subnet)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ApiEntityReference_STATUS() to populate field Subnet")
		}
		configuration.Subnet = &subnet
	} else {
		configuration.Subnet = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetIPConfiguration_STATUS populates the provided destination VirtualMachineScaleSetIPConfiguration_STATUS from our VirtualMachineScaleSetIPConfiguration_STATUS
func (configuration *VirtualMachineScaleSetIPConfiguration_STATUS) AssignProperties_To_VirtualMachineScaleSetIPConfiguration_STATUS(destination *storage.VirtualMachineScaleSetIPConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ApplicationGatewayBackendAddressPools
	if configuration.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]storage.SubResource_STATUS, len(configuration.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range configuration.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var applicationGatewayBackendAddressPool storage.SubResource_STATUS
			err := applicationGatewayBackendAddressPoolItem.AssignProperties_To_SubResource_STATUS(&applicationGatewayBackendAddressPool)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field ApplicationGatewayBackendAddressPools")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		destination.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		destination.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if configuration.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]storage.SubResource_STATUS, len(configuration.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range configuration.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var applicationSecurityGroup storage.SubResource_STATUS
			err := applicationSecurityGroupItem.AssignProperties_To_SubResource_STATUS(&applicationSecurityGroup)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field ApplicationSecurityGroups")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		destination.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		destination.ApplicationSecurityGroups = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(configuration.Id)

	// LoadBalancerBackendAddressPools
	if configuration.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]storage.SubResource_STATUS, len(configuration.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range configuration.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var loadBalancerBackendAddressPool storage.SubResource_STATUS
			err := loadBalancerBackendAddressPoolItem.AssignProperties_To_SubResource_STATUS(&loadBalancerBackendAddressPool)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field LoadBalancerBackendAddressPools")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		destination.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		destination.LoadBalancerBackendAddressPools = nil
	}

	// LoadBalancerInboundNatPools
	if configuration.LoadBalancerInboundNatPools != nil {
		loadBalancerInboundNatPoolList := make([]storage.SubResource_STATUS, len(configuration.LoadBalancerInboundNatPools))
		for loadBalancerInboundNatPoolIndex, loadBalancerInboundNatPoolItem := range configuration.LoadBalancerInboundNatPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerInboundNatPoolItem := loadBalancerInboundNatPoolItem
			var loadBalancerInboundNatPool storage.SubResource_STATUS
			err := loadBalancerInboundNatPoolItem.AssignProperties_To_SubResource_STATUS(&loadBalancerInboundNatPool)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field LoadBalancerInboundNatPools")
			}
			loadBalancerInboundNatPoolList[loadBalancerInboundNatPoolIndex] = loadBalancerInboundNatPool
		}
		destination.LoadBalancerInboundNatPools = loadBalancerInboundNatPoolList
	} else {
		destination.LoadBalancerInboundNatPools = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// Primary
	if configuration.Primary != nil {
		primary := *configuration.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// PrivateIPAddressVersion
	if configuration.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := string(*configuration.PrivateIPAddressVersion)
		destination.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		destination.PrivateIPAddressVersion = nil
	}

	// PublicIPAddressConfiguration
	if configuration.PublicIPAddressConfiguration != nil {
		var publicIPAddressConfiguration storage.VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS
		err := configuration.PublicIPAddressConfiguration.AssignProperties_To_VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS(&publicIPAddressConfiguration)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS() to populate field PublicIPAddressConfiguration")
		}
		destination.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	} else {
		destination.PublicIPAddressConfiguration = nil
	}

	// Subnet
	if configuration.Subnet != nil {
		var subnet storage.ApiEntityReference_STATUS
		err := configuration.Subnet.AssignProperties_To_ApiEntityReference_STATUS(&subnet)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ApiEntityReference_STATUS() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes the parameters of a ScaleSet managed disk.
type VirtualMachineScaleSetManagedDiskParameters struct {
	// DiskEncryptionSet: Specifies the customer managed disk encryption set resource id for the managed disk.
	DiskEncryptionSet *SubResource `json:"diskEncryptionSet,omitempty"`

	// SecurityProfile: Specifies the security profile for the managed disk.
	SecurityProfile *VMDiskSecurityProfile `json:"securityProfile,omitempty"`

	// StorageAccountType: Specifies the storage account type for the managed disk. NOTE: UltraSSD_LRS can only be used with
	// data disks, it cannot be used with OS Disk.
	StorageAccountType *StorageAccountType `json:"storageAccountType,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetManagedDiskParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *VirtualMachineScaleSetManagedDiskParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.VirtualMachineScaleSetManagedDiskParameters{}

	// Set property "DiskEncryptionSet":
	if parameters.DiskEncryptionSet != nil {
		diskEncryptionSet_ARM, err := (*parameters.DiskEncryptionSet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		diskEncryptionSet := *diskEncryptionSet_ARM.(*arm.SubResource)
		result.DiskEncryptionSet = &diskEncryptionSet
	}

	// Set property "SecurityProfile":
	if parameters.SecurityProfile != nil {
		securityProfile_ARM, err := (*parameters.SecurityProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		securityProfile := *securityProfile_ARM.(*arm.VMDiskSecurityProfile)
		result.SecurityProfile = &securityProfile
	}

	// Set property "StorageAccountType":
	if parameters.StorageAccountType != nil {
		var temp string
		temp = string(*parameters.StorageAccountType)
		storageAccountType := arm.StorageAccountType(temp)
		result.StorageAccountType = &storageAccountType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *VirtualMachineScaleSetManagedDiskParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSetManagedDiskParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *VirtualMachineScaleSetManagedDiskParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSetManagedDiskParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSetManagedDiskParameters, got %T", armInput)
	}

	// Set property "DiskEncryptionSet":
	if typedInput.DiskEncryptionSet != nil {
		var diskEncryptionSet1 SubResource
		err := diskEncryptionSet1.PopulateFromARM(owner, *typedInput.DiskEncryptionSet)
		if err != nil {
			return err
		}
		diskEncryptionSet := diskEncryptionSet1
		parameters.DiskEncryptionSet = &diskEncryptionSet
	}

	// Set property "SecurityProfile":
	if typedInput.SecurityProfile != nil {
		var securityProfile1 VMDiskSecurityProfile
		err := securityProfile1.PopulateFromARM(owner, *typedInput.SecurityProfile)
		if err != nil {
			return err
		}
		securityProfile := securityProfile1
		parameters.SecurityProfile = &securityProfile
	}

	// Set property "StorageAccountType":
	if typedInput.StorageAccountType != nil {
		var temp string
		temp = string(*typedInput.StorageAccountType)
		storageAccountType := StorageAccountType(temp)
		parameters.StorageAccountType = &storageAccountType
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSetManagedDiskParameters populates our VirtualMachineScaleSetManagedDiskParameters from the provided source VirtualMachineScaleSetManagedDiskParameters
func (parameters *VirtualMachineScaleSetManagedDiskParameters) AssignProperties_From_VirtualMachineScaleSetManagedDiskParameters(source *storage.VirtualMachineScaleSetManagedDiskParameters) error {

	// DiskEncryptionSet
	if source.DiskEncryptionSet != nil {
		var diskEncryptionSet SubResource
		err := diskEncryptionSet.AssignProperties_From_SubResource(source.DiskEncryptionSet)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SubResource() to populate field DiskEncryptionSet")
		}
		parameters.DiskEncryptionSet = &diskEncryptionSet
	} else {
		parameters.DiskEncryptionSet = nil
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		var securityProfile VMDiskSecurityProfile
		err := securityProfile.AssignProperties_From_VMDiskSecurityProfile(source.SecurityProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VMDiskSecurityProfile() to populate field SecurityProfile")
		}
		parameters.SecurityProfile = &securityProfile
	} else {
		parameters.SecurityProfile = nil
	}

	// StorageAccountType
	if source.StorageAccountType != nil {
		storageAccountType := *source.StorageAccountType
		storageAccountTypeTemp := genruntime.ToEnum(storageAccountType, storageAccountType_Values)
		parameters.StorageAccountType = &storageAccountTypeTemp
	} else {
		parameters.StorageAccountType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetManagedDiskParameters populates the provided destination VirtualMachineScaleSetManagedDiskParameters from our VirtualMachineScaleSetManagedDiskParameters
func (parameters *VirtualMachineScaleSetManagedDiskParameters) AssignProperties_To_VirtualMachineScaleSetManagedDiskParameters(destination *storage.VirtualMachineScaleSetManagedDiskParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DiskEncryptionSet
	if parameters.DiskEncryptionSet != nil {
		var diskEncryptionSet storage.SubResource
		err := parameters.DiskEncryptionSet.AssignProperties_To_SubResource(&diskEncryptionSet)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SubResource() to populate field DiskEncryptionSet")
		}
		destination.DiskEncryptionSet = &diskEncryptionSet
	} else {
		destination.DiskEncryptionSet = nil
	}

	// SecurityProfile
	if parameters.SecurityProfile != nil {
		var securityProfile storage.VMDiskSecurityProfile
		err := parameters.SecurityProfile.AssignProperties_To_VMDiskSecurityProfile(&securityProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VMDiskSecurityProfile() to populate field SecurityProfile")
		}
		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// StorageAccountType
	if parameters.StorageAccountType != nil {
		storageAccountType := string(*parameters.StorageAccountType)
		destination.StorageAccountType = &storageAccountType
	} else {
		destination.StorageAccountType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualMachineScaleSetManagedDiskParameters_STATUS populates our VirtualMachineScaleSetManagedDiskParameters from the provided source VirtualMachineScaleSetManagedDiskParameters_STATUS
func (parameters *VirtualMachineScaleSetManagedDiskParameters) Initialize_From_VirtualMachineScaleSetManagedDiskParameters_STATUS(source *VirtualMachineScaleSetManagedDiskParameters_STATUS) error {

	// DiskEncryptionSet
	if source.DiskEncryptionSet != nil {
		var diskEncryptionSet SubResource
		err := diskEncryptionSet.Initialize_From_SubResource_STATUS(source.DiskEncryptionSet)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_SubResource_STATUS() to populate field DiskEncryptionSet")
		}
		parameters.DiskEncryptionSet = &diskEncryptionSet
	} else {
		parameters.DiskEncryptionSet = nil
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		var securityProfile VMDiskSecurityProfile
		err := securityProfile.Initialize_From_VMDiskSecurityProfile_STATUS(source.SecurityProfile)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_VMDiskSecurityProfile_STATUS() to populate field SecurityProfile")
		}
		parameters.SecurityProfile = &securityProfile
	} else {
		parameters.SecurityProfile = nil
	}

	// StorageAccountType
	if source.StorageAccountType != nil {
		storageAccountType := genruntime.ToEnum(string(*source.StorageAccountType), storageAccountType_Values)
		parameters.StorageAccountType = &storageAccountType
	} else {
		parameters.StorageAccountType = nil
	}

	// No error
	return nil
}

// Describes the parameters of a ScaleSet managed disk.
type VirtualMachineScaleSetManagedDiskParameters_STATUS struct {
	// DiskEncryptionSet: Specifies the customer managed disk encryption set resource id for the managed disk.
	DiskEncryptionSet *SubResource_STATUS `json:"diskEncryptionSet,omitempty"`

	// SecurityProfile: Specifies the security profile for the managed disk.
	SecurityProfile *VMDiskSecurityProfile_STATUS `json:"securityProfile,omitempty"`

	// StorageAccountType: Specifies the storage account type for the managed disk. NOTE: UltraSSD_LRS can only be used with
	// data disks, it cannot be used with OS Disk.
	StorageAccountType *StorageAccountType_STATUS `json:"storageAccountType,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetManagedDiskParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *VirtualMachineScaleSetManagedDiskParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSetManagedDiskParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *VirtualMachineScaleSetManagedDiskParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSetManagedDiskParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSetManagedDiskParameters_STATUS, got %T", armInput)
	}

	// Set property "DiskEncryptionSet":
	if typedInput.DiskEncryptionSet != nil {
		var diskEncryptionSet1 SubResource_STATUS
		err := diskEncryptionSet1.PopulateFromARM(owner, *typedInput.DiskEncryptionSet)
		if err != nil {
			return err
		}
		diskEncryptionSet := diskEncryptionSet1
		parameters.DiskEncryptionSet = &diskEncryptionSet
	}

	// Set property "SecurityProfile":
	if typedInput.SecurityProfile != nil {
		var securityProfile1 VMDiskSecurityProfile_STATUS
		err := securityProfile1.PopulateFromARM(owner, *typedInput.SecurityProfile)
		if err != nil {
			return err
		}
		securityProfile := securityProfile1
		parameters.SecurityProfile = &securityProfile
	}

	// Set property "StorageAccountType":
	if typedInput.StorageAccountType != nil {
		var temp string
		temp = string(*typedInput.StorageAccountType)
		storageAccountType := StorageAccountType_STATUS(temp)
		parameters.StorageAccountType = &storageAccountType
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSetManagedDiskParameters_STATUS populates our VirtualMachineScaleSetManagedDiskParameters_STATUS from the provided source VirtualMachineScaleSetManagedDiskParameters_STATUS
func (parameters *VirtualMachineScaleSetManagedDiskParameters_STATUS) AssignProperties_From_VirtualMachineScaleSetManagedDiskParameters_STATUS(source *storage.VirtualMachineScaleSetManagedDiskParameters_STATUS) error {

	// DiskEncryptionSet
	if source.DiskEncryptionSet != nil {
		var diskEncryptionSet SubResource_STATUS
		err := diskEncryptionSet.AssignProperties_From_SubResource_STATUS(source.DiskEncryptionSet)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field DiskEncryptionSet")
		}
		parameters.DiskEncryptionSet = &diskEncryptionSet
	} else {
		parameters.DiskEncryptionSet = nil
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		var securityProfile VMDiskSecurityProfile_STATUS
		err := securityProfile.AssignProperties_From_VMDiskSecurityProfile_STATUS(source.SecurityProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VMDiskSecurityProfile_STATUS() to populate field SecurityProfile")
		}
		parameters.SecurityProfile = &securityProfile
	} else {
		parameters.SecurityProfile = nil
	}

	// StorageAccountType
	if source.StorageAccountType != nil {
		storageAccountType := *source.StorageAccountType
		storageAccountTypeTemp := genruntime.ToEnum(storageAccountType, storageAccountType_STATUS_Values)
		parameters.StorageAccountType = &storageAccountTypeTemp
	} else {
		parameters.StorageAccountType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetManagedDiskParameters_STATUS populates the provided destination VirtualMachineScaleSetManagedDiskParameters_STATUS from our VirtualMachineScaleSetManagedDiskParameters_STATUS
func (parameters *VirtualMachineScaleSetManagedDiskParameters_STATUS) AssignProperties_To_VirtualMachineScaleSetManagedDiskParameters_STATUS(destination *storage.VirtualMachineScaleSetManagedDiskParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DiskEncryptionSet
	if parameters.DiskEncryptionSet != nil {
		var diskEncryptionSet storage.SubResource_STATUS
		err := parameters.DiskEncryptionSet.AssignProperties_To_SubResource_STATUS(&diskEncryptionSet)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field DiskEncryptionSet")
		}
		destination.DiskEncryptionSet = &diskEncryptionSet
	} else {
		destination.DiskEncryptionSet = nil
	}

	// SecurityProfile
	if parameters.SecurityProfile != nil {
		var securityProfile storage.VMDiskSecurityProfile_STATUS
		err := parameters.SecurityProfile.AssignProperties_To_VMDiskSecurityProfile_STATUS(&securityProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VMDiskSecurityProfile_STATUS() to populate field SecurityProfile")
		}
		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// StorageAccountType
	if parameters.StorageAccountType != nil {
		storageAccountType := string(*parameters.StorageAccountType)
		destination.StorageAccountType = &storageAccountType
	} else {
		destination.StorageAccountType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes a virtual machines scale sets network configuration's DNS settings.
type VirtualMachineScaleSetNetworkConfigurationDnsSettings struct {
	// DnsServers: List of DNS servers IP addresses
	DnsServers []string `json:"dnsServers,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetNetworkConfigurationDnsSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *VirtualMachineScaleSetNetworkConfigurationDnsSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.VirtualMachineScaleSetNetworkConfigurationDnsSettings{}

	// Set property "DnsServers":
	for _, item := range settings.DnsServers {
		result.DnsServers = append(result.DnsServers, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *VirtualMachineScaleSetNetworkConfigurationDnsSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSetNetworkConfigurationDnsSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *VirtualMachineScaleSetNetworkConfigurationDnsSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSetNetworkConfigurationDnsSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSetNetworkConfigurationDnsSettings, got %T", armInput)
	}

	// Set property "DnsServers":
	for _, item := range typedInput.DnsServers {
		settings.DnsServers = append(settings.DnsServers, item)
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSetNetworkConfigurationDnsSettings populates our VirtualMachineScaleSetNetworkConfigurationDnsSettings from the provided source VirtualMachineScaleSetNetworkConfigurationDnsSettings
func (settings *VirtualMachineScaleSetNetworkConfigurationDnsSettings) AssignProperties_From_VirtualMachineScaleSetNetworkConfigurationDnsSettings(source *storage.VirtualMachineScaleSetNetworkConfigurationDnsSettings) error {

	// DnsServers
	settings.DnsServers = genruntime.CloneSliceOfString(source.DnsServers)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetNetworkConfigurationDnsSettings populates the provided destination VirtualMachineScaleSetNetworkConfigurationDnsSettings from our VirtualMachineScaleSetNetworkConfigurationDnsSettings
func (settings *VirtualMachineScaleSetNetworkConfigurationDnsSettings) AssignProperties_To_VirtualMachineScaleSetNetworkConfigurationDnsSettings(destination *storage.VirtualMachineScaleSetNetworkConfigurationDnsSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsServers
	destination.DnsServers = genruntime.CloneSliceOfString(settings.DnsServers)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS populates our VirtualMachineScaleSetNetworkConfigurationDnsSettings from the provided source VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS
func (settings *VirtualMachineScaleSetNetworkConfigurationDnsSettings) Initialize_From_VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS(source *VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS) error {

	// DnsServers
	settings.DnsServers = genruntime.CloneSliceOfString(source.DnsServers)

	// No error
	return nil
}

// Describes a virtual machines scale sets network configuration's DNS settings.
type VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS struct {
	// DnsServers: List of DNS servers IP addresses
	DnsServers []string `json:"dnsServers,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS, got %T", armInput)
	}

	// Set property "DnsServers":
	for _, item := range typedInput.DnsServers {
		settings.DnsServers = append(settings.DnsServers, item)
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS populates our VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS from the provided source VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS
func (settings *VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS) AssignProperties_From_VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS(source *storage.VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS) error {

	// DnsServers
	settings.DnsServers = genruntime.CloneSliceOfString(source.DnsServers)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS populates the provided destination VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS from our VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS
func (settings *VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS) AssignProperties_To_VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS(destination *storage.VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsServers
	destination.DnsServers = genruntime.CloneSliceOfString(settings.DnsServers)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Delete","Detach"}
type VirtualMachineScaleSetNetworkConfigurationProperties_DeleteOption string

const (
	VirtualMachineScaleSetNetworkConfigurationProperties_DeleteOption_Delete = VirtualMachineScaleSetNetworkConfigurationProperties_DeleteOption("Delete")
	VirtualMachineScaleSetNetworkConfigurationProperties_DeleteOption_Detach = VirtualMachineScaleSetNetworkConfigurationProperties_DeleteOption("Detach")
)

// Mapping from string to VirtualMachineScaleSetNetworkConfigurationProperties_DeleteOption
var virtualMachineScaleSetNetworkConfigurationProperties_DeleteOption_Values = map[string]VirtualMachineScaleSetNetworkConfigurationProperties_DeleteOption{
	"delete": VirtualMachineScaleSetNetworkConfigurationProperties_DeleteOption_Delete,
	"detach": VirtualMachineScaleSetNetworkConfigurationProperties_DeleteOption_Detach,
}

type VirtualMachineScaleSetNetworkConfigurationProperties_DeleteOption_STATUS string

const (
	VirtualMachineScaleSetNetworkConfigurationProperties_DeleteOption_STATUS_Delete = VirtualMachineScaleSetNetworkConfigurationProperties_DeleteOption_STATUS("Delete")
	VirtualMachineScaleSetNetworkConfigurationProperties_DeleteOption_STATUS_Detach = VirtualMachineScaleSetNetworkConfigurationProperties_DeleteOption_STATUS("Detach")
)

// Mapping from string to VirtualMachineScaleSetNetworkConfigurationProperties_DeleteOption_STATUS
var virtualMachineScaleSetNetworkConfigurationProperties_DeleteOption_STATUS_Values = map[string]VirtualMachineScaleSetNetworkConfigurationProperties_DeleteOption_STATUS{
	"delete": VirtualMachineScaleSetNetworkConfigurationProperties_DeleteOption_STATUS_Delete,
	"detach": VirtualMachineScaleSetNetworkConfigurationProperties_DeleteOption_STATUS_Detach,
}

// +kubebuilder:validation:Enum={"Linux","Windows"}
type VirtualMachineScaleSetOSDisk_OsType string

const (
	VirtualMachineScaleSetOSDisk_OsType_Linux   = VirtualMachineScaleSetOSDisk_OsType("Linux")
	VirtualMachineScaleSetOSDisk_OsType_Windows = VirtualMachineScaleSetOSDisk_OsType("Windows")
)

// Mapping from string to VirtualMachineScaleSetOSDisk_OsType
var virtualMachineScaleSetOSDisk_OsType_Values = map[string]VirtualMachineScaleSetOSDisk_OsType{
	"linux":   VirtualMachineScaleSetOSDisk_OsType_Linux,
	"windows": VirtualMachineScaleSetOSDisk_OsType_Windows,
}

type VirtualMachineScaleSetOSDisk_OsType_STATUS string

const (
	VirtualMachineScaleSetOSDisk_OsType_STATUS_Linux   = VirtualMachineScaleSetOSDisk_OsType_STATUS("Linux")
	VirtualMachineScaleSetOSDisk_OsType_STATUS_Windows = VirtualMachineScaleSetOSDisk_OsType_STATUS("Windows")
)

// Mapping from string to VirtualMachineScaleSetOSDisk_OsType_STATUS
var virtualMachineScaleSetOSDisk_OsType_STATUS_Values = map[string]VirtualMachineScaleSetOSDisk_OsType_STATUS{
	"linux":   VirtualMachineScaleSetOSDisk_OsType_STATUS_Linux,
	"windows": VirtualMachineScaleSetOSDisk_OsType_STATUS_Windows,
}

// +kubebuilder:validation:Enum={"IPv4","IPv6"}
type VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion string

const (
	VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion_IPv4 = VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion("IPv4")
	VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion_IPv6 = VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion("IPv6")
)

// Mapping from string to VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion
var virtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion_Values = map[string]VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion{
	"ipv4": VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion_IPv4,
	"ipv6": VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion_IPv6,
}

type VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion_STATUS string

const (
	VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion_STATUS_IPv4 = VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion_STATUS("IPv4")
	VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion_STATUS_IPv6 = VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion_STATUS("IPv6")
)

// Mapping from string to VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion_STATUS
var virtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion_STATUS_Values = map[string]VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion_STATUS{
	"ipv4": VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion_STATUS_IPv4,
	"ipv6": VirtualMachineScaleSetIPConfigurationProperties_PrivateIPAddressVersion_STATUS_IPv6,
}

// Describes a virtual machines scale set IP Configuration's PublicIPAddress configuration
type VirtualMachineScaleSetPublicIPAddressConfiguration struct {
	// DeleteOption: Specify what happens to the public IP when the VM is deleted
	DeleteOption *VirtualMachineScaleSetPublicIPAddressConfigurationProperties_DeleteOption `json:"deleteOption,omitempty"`

	// DnsSettings: The dns settings to be applied on the publicIP addresses .
	DnsSettings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings `json:"dnsSettings,omitempty"`

	// IdleTimeoutInMinutes: The idle timeout of the public IP address.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	// IpTags: The list of IP tags associated with the public IP address.
	IpTags []VirtualMachineScaleSetIpTag `json:"ipTags,omitempty"`

	// +kubebuilder:validation:Required
	// Name: The publicIP address configuration name.
	Name *string `json:"name,omitempty"`

	// PublicIPAddressVersion: Available from Api-Version 2019-07-01 onwards, it represents whether the specific
	// ipconfiguration is IPv4 or IPv6. Default is taken as IPv4. Possible values are: 'IPv4' and 'IPv6'.
	PublicIPAddressVersion *VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion `json:"publicIPAddressVersion,omitempty"`

	// PublicIPPrefix: The PublicIPPrefix from which to allocate publicIP addresses.
	PublicIPPrefix *SubResource `json:"publicIPPrefix,omitempty"`

	// Sku: Describes the public IP Sku. It can only be set with OrchestrationMode as Flexible.
	Sku *PublicIPAddressSku `json:"sku,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetPublicIPAddressConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.VirtualMachineScaleSetPublicIPAddressConfiguration{}

	// Set property "Name":
	if configuration.Name != nil {
		name := *configuration.Name
		result.Name = &name
	}

	// Set property "Properties":
	if configuration.DeleteOption != nil ||
		configuration.DnsSettings != nil ||
		configuration.IdleTimeoutInMinutes != nil ||
		configuration.IpTags != nil ||
		configuration.PublicIPAddressVersion != nil ||
		configuration.PublicIPPrefix != nil {
		result.Properties = &arm.VirtualMachineScaleSetPublicIPAddressConfigurationProperties{}
	}
	if configuration.DeleteOption != nil {
		var temp string
		temp = string(*configuration.DeleteOption)
		deleteOption := arm.VirtualMachineScaleSetPublicIPAddressConfigurationProperties_DeleteOption(temp)
		result.Properties.DeleteOption = &deleteOption
	}
	if configuration.DnsSettings != nil {
		dnsSettings_ARM, err := (*configuration.DnsSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dnsSettings := *dnsSettings_ARM.(*arm.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings)
		result.Properties.DnsSettings = &dnsSettings
	}
	if configuration.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinutes := *configuration.IdleTimeoutInMinutes
		result.Properties.IdleTimeoutInMinutes = &idleTimeoutInMinutes
	}
	for _, item := range configuration.IpTags {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.IpTags = append(result.Properties.IpTags, *item_ARM.(*arm.VirtualMachineScaleSetIpTag))
	}
	if configuration.PublicIPAddressVersion != nil {
		var temp string
		temp = string(*configuration.PublicIPAddressVersion)
		publicIPAddressVersion := arm.VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion(temp)
		result.Properties.PublicIPAddressVersion = &publicIPAddressVersion
	}
	if configuration.PublicIPPrefix != nil {
		publicIPPrefix_ARM, err := (*configuration.PublicIPPrefix).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		publicIPPrefix := *publicIPPrefix_ARM.(*arm.SubResource)
		result.Properties.PublicIPPrefix = &publicIPPrefix
	}

	// Set property "Sku":
	if configuration.Sku != nil {
		sku_ARM, err := (*configuration.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := *sku_ARM.(*arm.PublicIPAddressSku)
		result.Sku = &sku
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSetPublicIPAddressConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSetPublicIPAddressConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSetPublicIPAddressConfiguration, got %T", armInput)
	}

	// Set property "DeleteOption":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DeleteOption != nil {
			var temp string
			temp = string(*typedInput.Properties.DeleteOption)
			deleteOption := VirtualMachineScaleSetPublicIPAddressConfigurationProperties_DeleteOption(temp)
			configuration.DeleteOption = &deleteOption
		}
	}

	// Set property "DnsSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsSettings != nil {
			var dnsSettings1 VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings
			err := dnsSettings1.PopulateFromARM(owner, *typedInput.Properties.DnsSettings)
			if err != nil {
				return err
			}
			dnsSettings := dnsSettings1
			configuration.DnsSettings = &dnsSettings
		}
	}

	// Set property "IdleTimeoutInMinutes":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			configuration.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property "IpTags":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpTags {
			var item1 VirtualMachineScaleSetIpTag
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.IpTags = append(configuration.IpTags, item1)
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		configuration.Name = &name
	}

	// Set property "PublicIPAddressVersion":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddressVersion != nil {
			var temp string
			temp = string(*typedInput.Properties.PublicIPAddressVersion)
			publicIPAddressVersion := VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion(temp)
			configuration.PublicIPAddressVersion = &publicIPAddressVersion
		}
	}

	// Set property "PublicIPPrefix":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPPrefix != nil {
			var publicIPPrefix1 SubResource
			err := publicIPPrefix1.PopulateFromARM(owner, *typedInput.Properties.PublicIPPrefix)
			if err != nil {
				return err
			}
			publicIPPrefix := publicIPPrefix1
			configuration.PublicIPPrefix = &publicIPPrefix
		}
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 PublicIPAddressSku
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		configuration.Sku = &sku
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSetPublicIPAddressConfiguration populates our VirtualMachineScaleSetPublicIPAddressConfiguration from the provided source VirtualMachineScaleSetPublicIPAddressConfiguration
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration) AssignProperties_From_VirtualMachineScaleSetPublicIPAddressConfiguration(source *storage.VirtualMachineScaleSetPublicIPAddressConfiguration) error {

	// DeleteOption
	if source.DeleteOption != nil {
		deleteOption := *source.DeleteOption
		deleteOptionTemp := genruntime.ToEnum(deleteOption, virtualMachineScaleSetPublicIPAddressConfigurationProperties_DeleteOption_Values)
		configuration.DeleteOption = &deleteOptionTemp
	} else {
		configuration.DeleteOption = nil
	}

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings
		err := dnsSetting.AssignProperties_From_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings(source.DnsSettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings() to populate field DnsSettings")
		}
		configuration.DnsSettings = &dnsSetting
	} else {
		configuration.DnsSettings = nil
	}

	// IdleTimeoutInMinutes
	configuration.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// IpTags
	if source.IpTags != nil {
		ipTagList := make([]VirtualMachineScaleSetIpTag, len(source.IpTags))
		for ipTagIndex, ipTagItem := range source.IpTags {
			// Shadow the loop variable to avoid aliasing
			ipTagItem := ipTagItem
			var ipTag VirtualMachineScaleSetIpTag
			err := ipTag.AssignProperties_From_VirtualMachineScaleSetIpTag(&ipTagItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetIpTag() to populate field IpTags")
			}
			ipTagList[ipTagIndex] = ipTag
		}
		configuration.IpTags = ipTagList
	} else {
		configuration.IpTags = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// PublicIPAddressVersion
	if source.PublicIPAddressVersion != nil {
		publicIPAddressVersion := *source.PublicIPAddressVersion
		publicIPAddressVersionTemp := genruntime.ToEnum(publicIPAddressVersion, virtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion_Values)
		configuration.PublicIPAddressVersion = &publicIPAddressVersionTemp
	} else {
		configuration.PublicIPAddressVersion = nil
	}

	// PublicIPPrefix
	if source.PublicIPPrefix != nil {
		var publicIPPrefix SubResource
		err := publicIPPrefix.AssignProperties_From_SubResource(source.PublicIPPrefix)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SubResource() to populate field PublicIPPrefix")
		}
		configuration.PublicIPPrefix = &publicIPPrefix
	} else {
		configuration.PublicIPPrefix = nil
	}

	// Sku
	if source.Sku != nil {
		var sku PublicIPAddressSku
		err := sku.AssignProperties_From_PublicIPAddressSku(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_PublicIPAddressSku() to populate field Sku")
		}
		configuration.Sku = &sku
	} else {
		configuration.Sku = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetPublicIPAddressConfiguration populates the provided destination VirtualMachineScaleSetPublicIPAddressConfiguration from our VirtualMachineScaleSetPublicIPAddressConfiguration
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration) AssignProperties_To_VirtualMachineScaleSetPublicIPAddressConfiguration(destination *storage.VirtualMachineScaleSetPublicIPAddressConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DeleteOption
	if configuration.DeleteOption != nil {
		deleteOption := string(*configuration.DeleteOption)
		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// DnsSettings
	if configuration.DnsSettings != nil {
		var dnsSetting storage.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings
		err := configuration.DnsSettings.AssignProperties_To_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings(&dnsSetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(configuration.IdleTimeoutInMinutes)

	// IpTags
	if configuration.IpTags != nil {
		ipTagList := make([]storage.VirtualMachineScaleSetIpTag, len(configuration.IpTags))
		for ipTagIndex, ipTagItem := range configuration.IpTags {
			// Shadow the loop variable to avoid aliasing
			ipTagItem := ipTagItem
			var ipTag storage.VirtualMachineScaleSetIpTag
			err := ipTagItem.AssignProperties_To_VirtualMachineScaleSetIpTag(&ipTag)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetIpTag() to populate field IpTags")
			}
			ipTagList[ipTagIndex] = ipTag
		}
		destination.IpTags = ipTagList
	} else {
		destination.IpTags = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// PublicIPAddressVersion
	if configuration.PublicIPAddressVersion != nil {
		publicIPAddressVersion := string(*configuration.PublicIPAddressVersion)
		destination.PublicIPAddressVersion = &publicIPAddressVersion
	} else {
		destination.PublicIPAddressVersion = nil
	}

	// PublicIPPrefix
	if configuration.PublicIPPrefix != nil {
		var publicIPPrefix storage.SubResource
		err := configuration.PublicIPPrefix.AssignProperties_To_SubResource(&publicIPPrefix)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SubResource() to populate field PublicIPPrefix")
		}
		destination.PublicIPPrefix = &publicIPPrefix
	} else {
		destination.PublicIPPrefix = nil
	}

	// Sku
	if configuration.Sku != nil {
		var sku storage.PublicIPAddressSku
		err := configuration.Sku.AssignProperties_To_PublicIPAddressSku(&sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_PublicIPAddressSku() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS populates our VirtualMachineScaleSetPublicIPAddressConfiguration from the provided source VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration) Initialize_From_VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS(source *VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS) error {

	// DeleteOption
	if source.DeleteOption != nil {
		deleteOption := genruntime.ToEnum(string(*source.DeleteOption), virtualMachineScaleSetPublicIPAddressConfigurationProperties_DeleteOption_Values)
		configuration.DeleteOption = &deleteOption
	} else {
		configuration.DeleteOption = nil
	}

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings
		err := dnsSetting.Initialize_From_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS(source.DnsSettings)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS() to populate field DnsSettings")
		}
		configuration.DnsSettings = &dnsSetting
	} else {
		configuration.DnsSettings = nil
	}

	// IdleTimeoutInMinutes
	configuration.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// IpTags
	if source.IpTags != nil {
		ipTagList := make([]VirtualMachineScaleSetIpTag, len(source.IpTags))
		for ipTagIndex, ipTagItem := range source.IpTags {
			// Shadow the loop variable to avoid aliasing
			ipTagItem := ipTagItem
			var ipTag VirtualMachineScaleSetIpTag
			err := ipTag.Initialize_From_VirtualMachineScaleSetIpTag_STATUS(&ipTagItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_VirtualMachineScaleSetIpTag_STATUS() to populate field IpTags")
			}
			ipTagList[ipTagIndex] = ipTag
		}
		configuration.IpTags = ipTagList
	} else {
		configuration.IpTags = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// PublicIPAddressVersion
	if source.PublicIPAddressVersion != nil {
		publicIPAddressVersion := genruntime.ToEnum(string(*source.PublicIPAddressVersion), virtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion_Values)
		configuration.PublicIPAddressVersion = &publicIPAddressVersion
	} else {
		configuration.PublicIPAddressVersion = nil
	}

	// PublicIPPrefix
	if source.PublicIPPrefix != nil {
		var publicIPPrefix SubResource
		err := publicIPPrefix.Initialize_From_SubResource_STATUS(source.PublicIPPrefix)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_SubResource_STATUS() to populate field PublicIPPrefix")
		}
		configuration.PublicIPPrefix = &publicIPPrefix
	} else {
		configuration.PublicIPPrefix = nil
	}

	// Sku
	if source.Sku != nil {
		var sku PublicIPAddressSku
		err := sku.Initialize_From_PublicIPAddressSku_STATUS(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_PublicIPAddressSku_STATUS() to populate field Sku")
		}
		configuration.Sku = &sku
	} else {
		configuration.Sku = nil
	}

	// No error
	return nil
}

// Describes a virtual machines scale set IP Configuration's PublicIPAddress configuration
type VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS struct {
	// DeleteOption: Specify what happens to the public IP when the VM is deleted
	DeleteOption *VirtualMachineScaleSetPublicIPAddressConfigurationProperties_DeleteOption_STATUS `json:"deleteOption,omitempty"`

	// DnsSettings: The dns settings to be applied on the publicIP addresses .
	DnsSettings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS `json:"dnsSettings,omitempty"`

	// IdleTimeoutInMinutes: The idle timeout of the public IP address.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	// IpTags: The list of IP tags associated with the public IP address.
	IpTags []VirtualMachineScaleSetIpTag_STATUS `json:"ipTags,omitempty"`

	// Name: The publicIP address configuration name.
	Name *string `json:"name,omitempty"`

	// PublicIPAddressVersion: Available from Api-Version 2019-07-01 onwards, it represents whether the specific
	// ipconfiguration is IPv4 or IPv6. Default is taken as IPv4. Possible values are: 'IPv4' and 'IPv6'.
	PublicIPAddressVersion *VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion_STATUS `json:"publicIPAddressVersion,omitempty"`

	// PublicIPPrefix: The PublicIPPrefix from which to allocate publicIP addresses.
	PublicIPPrefix *SubResource_STATUS `json:"publicIPPrefix,omitempty"`

	// Sku: Describes the public IP Sku. It can only be set with OrchestrationMode as Flexible.
	Sku *PublicIPAddressSku_STATUS `json:"sku,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS, got %T", armInput)
	}

	// Set property "DeleteOption":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DeleteOption != nil {
			var temp string
			temp = string(*typedInput.Properties.DeleteOption)
			deleteOption := VirtualMachineScaleSetPublicIPAddressConfigurationProperties_DeleteOption_STATUS(temp)
			configuration.DeleteOption = &deleteOption
		}
	}

	// Set property "DnsSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsSettings != nil {
			var dnsSettings1 VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS
			err := dnsSettings1.PopulateFromARM(owner, *typedInput.Properties.DnsSettings)
			if err != nil {
				return err
			}
			dnsSettings := dnsSettings1
			configuration.DnsSettings = &dnsSettings
		}
	}

	// Set property "IdleTimeoutInMinutes":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			configuration.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property "IpTags":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpTags {
			var item1 VirtualMachineScaleSetIpTag_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.IpTags = append(configuration.IpTags, item1)
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		configuration.Name = &name
	}

	// Set property "PublicIPAddressVersion":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddressVersion != nil {
			var temp string
			temp = string(*typedInput.Properties.PublicIPAddressVersion)
			publicIPAddressVersion := VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion_STATUS(temp)
			configuration.PublicIPAddressVersion = &publicIPAddressVersion
		}
	}

	// Set property "PublicIPPrefix":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPPrefix != nil {
			var publicIPPrefix1 SubResource_STATUS
			err := publicIPPrefix1.PopulateFromARM(owner, *typedInput.Properties.PublicIPPrefix)
			if err != nil {
				return err
			}
			publicIPPrefix := publicIPPrefix1
			configuration.PublicIPPrefix = &publicIPPrefix
		}
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 PublicIPAddressSku_STATUS
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		configuration.Sku = &sku
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS populates our VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS from the provided source VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS) AssignProperties_From_VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS(source *storage.VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS) error {

	// DeleteOption
	if source.DeleteOption != nil {
		deleteOption := *source.DeleteOption
		deleteOptionTemp := genruntime.ToEnum(deleteOption, virtualMachineScaleSetPublicIPAddressConfigurationProperties_DeleteOption_STATUS_Values)
		configuration.DeleteOption = &deleteOptionTemp
	} else {
		configuration.DeleteOption = nil
	}

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS
		err := dnsSetting.AssignProperties_From_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS(source.DnsSettings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS() to populate field DnsSettings")
		}
		configuration.DnsSettings = &dnsSetting
	} else {
		configuration.DnsSettings = nil
	}

	// IdleTimeoutInMinutes
	configuration.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// IpTags
	if source.IpTags != nil {
		ipTagList := make([]VirtualMachineScaleSetIpTag_STATUS, len(source.IpTags))
		for ipTagIndex, ipTagItem := range source.IpTags {
			// Shadow the loop variable to avoid aliasing
			ipTagItem := ipTagItem
			var ipTag VirtualMachineScaleSetIpTag_STATUS
			err := ipTag.AssignProperties_From_VirtualMachineScaleSetIpTag_STATUS(&ipTagItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetIpTag_STATUS() to populate field IpTags")
			}
			ipTagList[ipTagIndex] = ipTag
		}
		configuration.IpTags = ipTagList
	} else {
		configuration.IpTags = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// PublicIPAddressVersion
	if source.PublicIPAddressVersion != nil {
		publicIPAddressVersion := *source.PublicIPAddressVersion
		publicIPAddressVersionTemp := genruntime.ToEnum(publicIPAddressVersion, virtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion_STATUS_Values)
		configuration.PublicIPAddressVersion = &publicIPAddressVersionTemp
	} else {
		configuration.PublicIPAddressVersion = nil
	}

	// PublicIPPrefix
	if source.PublicIPPrefix != nil {
		var publicIPPrefix SubResource_STATUS
		err := publicIPPrefix.AssignProperties_From_SubResource_STATUS(source.PublicIPPrefix)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field PublicIPPrefix")
		}
		configuration.PublicIPPrefix = &publicIPPrefix
	} else {
		configuration.PublicIPPrefix = nil
	}

	// Sku
	if source.Sku != nil {
		var sku PublicIPAddressSku_STATUS
		err := sku.AssignProperties_From_PublicIPAddressSku_STATUS(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_PublicIPAddressSku_STATUS() to populate field Sku")
		}
		configuration.Sku = &sku
	} else {
		configuration.Sku = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS populates the provided destination VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS from our VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS) AssignProperties_To_VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS(destination *storage.VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DeleteOption
	if configuration.DeleteOption != nil {
		deleteOption := string(*configuration.DeleteOption)
		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// DnsSettings
	if configuration.DnsSettings != nil {
		var dnsSetting storage.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS
		err := configuration.DnsSettings.AssignProperties_To_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS(&dnsSetting)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(configuration.IdleTimeoutInMinutes)

	// IpTags
	if configuration.IpTags != nil {
		ipTagList := make([]storage.VirtualMachineScaleSetIpTag_STATUS, len(configuration.IpTags))
		for ipTagIndex, ipTagItem := range configuration.IpTags {
			// Shadow the loop variable to avoid aliasing
			ipTagItem := ipTagItem
			var ipTag storage.VirtualMachineScaleSetIpTag_STATUS
			err := ipTagItem.AssignProperties_To_VirtualMachineScaleSetIpTag_STATUS(&ipTag)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetIpTag_STATUS() to populate field IpTags")
			}
			ipTagList[ipTagIndex] = ipTag
		}
		destination.IpTags = ipTagList
	} else {
		destination.IpTags = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// PublicIPAddressVersion
	if configuration.PublicIPAddressVersion != nil {
		publicIPAddressVersion := string(*configuration.PublicIPAddressVersion)
		destination.PublicIPAddressVersion = &publicIPAddressVersion
	} else {
		destination.PublicIPAddressVersion = nil
	}

	// PublicIPPrefix
	if configuration.PublicIPPrefix != nil {
		var publicIPPrefix storage.SubResource_STATUS
		err := configuration.PublicIPPrefix.AssignProperties_To_SubResource_STATUS(&publicIPPrefix)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field PublicIPPrefix")
		}
		destination.PublicIPPrefix = &publicIPPrefix
	} else {
		destination.PublicIPPrefix = nil
	}

	// Sku
	if configuration.Sku != nil {
		var sku storage.PublicIPAddressSku_STATUS
		err := configuration.Sku.AssignProperties_To_PublicIPAddressSku_STATUS(&sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_PublicIPAddressSku_STATUS() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Contains the IP tag associated with the public IP address.
type VirtualMachineScaleSetIpTag struct {
	// IpTagType: IP tag type. Example: FirstPartyUsage.
	IpTagType *string `json:"ipTagType,omitempty"`

	// Tag: IP tag associated with the public IP. Example: SQL, Storage etc.
	Tag *string `json:"tag,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetIpTag{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (ipTag *VirtualMachineScaleSetIpTag) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if ipTag == nil {
		return nil, nil
	}
	result := &arm.VirtualMachineScaleSetIpTag{}

	// Set property "IpTagType":
	if ipTag.IpTagType != nil {
		ipTagType := *ipTag.IpTagType
		result.IpTagType = &ipTagType
	}

	// Set property "Tag":
	if ipTag.Tag != nil {
		tag := *ipTag.Tag
		result.Tag = &tag
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (ipTag *VirtualMachineScaleSetIpTag) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSetIpTag{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (ipTag *VirtualMachineScaleSetIpTag) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSetIpTag)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSetIpTag, got %T", armInput)
	}

	// Set property "IpTagType":
	if typedInput.IpTagType != nil {
		ipTagType := *typedInput.IpTagType
		ipTag.IpTagType = &ipTagType
	}

	// Set property "Tag":
	if typedInput.Tag != nil {
		tag := *typedInput.Tag
		ipTag.Tag = &tag
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSetIpTag populates our VirtualMachineScaleSetIpTag from the provided source VirtualMachineScaleSetIpTag
func (ipTag *VirtualMachineScaleSetIpTag) AssignProperties_From_VirtualMachineScaleSetIpTag(source *storage.VirtualMachineScaleSetIpTag) error {

	// IpTagType
	ipTag.IpTagType = genruntime.ClonePointerToString(source.IpTagType)

	// Tag
	ipTag.Tag = genruntime.ClonePointerToString(source.Tag)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetIpTag populates the provided destination VirtualMachineScaleSetIpTag from our VirtualMachineScaleSetIpTag
func (ipTag *VirtualMachineScaleSetIpTag) AssignProperties_To_VirtualMachineScaleSetIpTag(destination *storage.VirtualMachineScaleSetIpTag) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IpTagType
	destination.IpTagType = genruntime.ClonePointerToString(ipTag.IpTagType)

	// Tag
	destination.Tag = genruntime.ClonePointerToString(ipTag.Tag)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualMachineScaleSetIpTag_STATUS populates our VirtualMachineScaleSetIpTag from the provided source VirtualMachineScaleSetIpTag_STATUS
func (ipTag *VirtualMachineScaleSetIpTag) Initialize_From_VirtualMachineScaleSetIpTag_STATUS(source *VirtualMachineScaleSetIpTag_STATUS) error {

	// IpTagType
	ipTag.IpTagType = genruntime.ClonePointerToString(source.IpTagType)

	// Tag
	ipTag.Tag = genruntime.ClonePointerToString(source.Tag)

	// No error
	return nil
}

// Contains the IP tag associated with the public IP address.
type VirtualMachineScaleSetIpTag_STATUS struct {
	// IpTagType: IP tag type. Example: FirstPartyUsage.
	IpTagType *string `json:"ipTagType,omitempty"`

	// Tag: IP tag associated with the public IP. Example: SQL, Storage etc.
	Tag *string `json:"tag,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetIpTag_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (ipTag *VirtualMachineScaleSetIpTag_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSetIpTag_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (ipTag *VirtualMachineScaleSetIpTag_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSetIpTag_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSetIpTag_STATUS, got %T", armInput)
	}

	// Set property "IpTagType":
	if typedInput.IpTagType != nil {
		ipTagType := *typedInput.IpTagType
		ipTag.IpTagType = &ipTagType
	}

	// Set property "Tag":
	if typedInput.Tag != nil {
		tag := *typedInput.Tag
		ipTag.Tag = &tag
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSetIpTag_STATUS populates our VirtualMachineScaleSetIpTag_STATUS from the provided source VirtualMachineScaleSetIpTag_STATUS
func (ipTag *VirtualMachineScaleSetIpTag_STATUS) AssignProperties_From_VirtualMachineScaleSetIpTag_STATUS(source *storage.VirtualMachineScaleSetIpTag_STATUS) error {

	// IpTagType
	ipTag.IpTagType = genruntime.ClonePointerToString(source.IpTagType)

	// Tag
	ipTag.Tag = genruntime.ClonePointerToString(source.Tag)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetIpTag_STATUS populates the provided destination VirtualMachineScaleSetIpTag_STATUS from our VirtualMachineScaleSetIpTag_STATUS
func (ipTag *VirtualMachineScaleSetIpTag_STATUS) AssignProperties_To_VirtualMachineScaleSetIpTag_STATUS(destination *storage.VirtualMachineScaleSetIpTag_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IpTagType
	destination.IpTagType = genruntime.ClonePointerToString(ipTag.IpTagType)

	// Tag
	destination.Tag = genruntime.ClonePointerToString(ipTag.Tag)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes a virtual machines scale sets network configuration's DNS settings.
type VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings struct {
	// +kubebuilder:validation:Required
	// DomainNameLabel: The Domain name label.The concatenation of the domain name label and vm index will be the domain name
	// labels of the PublicIPAddress resources that will be created
	DomainNameLabel *string `json:"domainNameLabel,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings{}

	// Set property "DomainNameLabel":
	if settings.DomainNameLabel != nil {
		domainNameLabel := *settings.DomainNameLabel
		result.DomainNameLabel = &domainNameLabel
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings, got %T", armInput)
	}

	// Set property "DomainNameLabel":
	if typedInput.DomainNameLabel != nil {
		domainNameLabel := *typedInput.DomainNameLabel
		settings.DomainNameLabel = &domainNameLabel
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings populates our VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings from the provided source VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings
func (settings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings) AssignProperties_From_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings(source *storage.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings) error {

	// DomainNameLabel
	settings.DomainNameLabel = genruntime.ClonePointerToString(source.DomainNameLabel)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings populates the provided destination VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings from our VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings
func (settings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings) AssignProperties_To_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings(destination *storage.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DomainNameLabel
	destination.DomainNameLabel = genruntime.ClonePointerToString(settings.DomainNameLabel)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS populates our VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings from the provided source VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS
func (settings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings) Initialize_From_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS(source *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS) error {

	// DomainNameLabel
	settings.DomainNameLabel = genruntime.ClonePointerToString(source.DomainNameLabel)

	// No error
	return nil
}

// Describes a virtual machines scale sets network configuration's DNS settings.
type VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS struct {
	// DomainNameLabel: The Domain name label.The concatenation of the domain name label and vm index will be the domain name
	// labels of the PublicIPAddress resources that will be created
	DomainNameLabel *string `json:"domainNameLabel,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS, got %T", armInput)
	}

	// Set property "DomainNameLabel":
	if typedInput.DomainNameLabel != nil {
		domainNameLabel := *typedInput.DomainNameLabel
		settings.DomainNameLabel = &domainNameLabel
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS populates our VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS from the provided source VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS
func (settings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS) AssignProperties_From_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS(source *storage.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS) error {

	// DomainNameLabel
	settings.DomainNameLabel = genruntime.ClonePointerToString(source.DomainNameLabel)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS populates the provided destination VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS from our VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS
func (settings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS) AssignProperties_To_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS(destination *storage.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DomainNameLabel
	destination.DomainNameLabel = genruntime.ClonePointerToString(settings.DomainNameLabel)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Delete","Detach"}
type VirtualMachineScaleSetPublicIPAddressConfigurationProperties_DeleteOption string

const (
	VirtualMachineScaleSetPublicIPAddressConfigurationProperties_DeleteOption_Delete = VirtualMachineScaleSetPublicIPAddressConfigurationProperties_DeleteOption("Delete")
	VirtualMachineScaleSetPublicIPAddressConfigurationProperties_DeleteOption_Detach = VirtualMachineScaleSetPublicIPAddressConfigurationProperties_DeleteOption("Detach")
)

// Mapping from string to VirtualMachineScaleSetPublicIPAddressConfigurationProperties_DeleteOption
var virtualMachineScaleSetPublicIPAddressConfigurationProperties_DeleteOption_Values = map[string]VirtualMachineScaleSetPublicIPAddressConfigurationProperties_DeleteOption{
	"delete": VirtualMachineScaleSetPublicIPAddressConfigurationProperties_DeleteOption_Delete,
	"detach": VirtualMachineScaleSetPublicIPAddressConfigurationProperties_DeleteOption_Detach,
}

type VirtualMachineScaleSetPublicIPAddressConfigurationProperties_DeleteOption_STATUS string

const (
	VirtualMachineScaleSetPublicIPAddressConfigurationProperties_DeleteOption_STATUS_Delete = VirtualMachineScaleSetPublicIPAddressConfigurationProperties_DeleteOption_STATUS("Delete")
	VirtualMachineScaleSetPublicIPAddressConfigurationProperties_DeleteOption_STATUS_Detach = VirtualMachineScaleSetPublicIPAddressConfigurationProperties_DeleteOption_STATUS("Detach")
)

// Mapping from string to VirtualMachineScaleSetPublicIPAddressConfigurationProperties_DeleteOption_STATUS
var virtualMachineScaleSetPublicIPAddressConfigurationProperties_DeleteOption_STATUS_Values = map[string]VirtualMachineScaleSetPublicIPAddressConfigurationProperties_DeleteOption_STATUS{
	"delete": VirtualMachineScaleSetPublicIPAddressConfigurationProperties_DeleteOption_STATUS_Delete,
	"detach": VirtualMachineScaleSetPublicIPAddressConfigurationProperties_DeleteOption_STATUS_Detach,
}

// +kubebuilder:validation:Enum={"IPv4","IPv6"}
type VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion string

const (
	VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion_IPv4 = VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion("IPv4")
	VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion_IPv6 = VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion("IPv6")
)

// Mapping from string to VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion
var virtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion_Values = map[string]VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion{
	"ipv4": VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion_IPv4,
	"ipv6": VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion_IPv6,
}

type VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion_STATUS string

const (
	VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion_STATUS_IPv4 = VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion_STATUS("IPv4")
	VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion_STATUS_IPv6 = VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion_STATUS("IPv6")
)

// Mapping from string to VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion_STATUS
var virtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion_STATUS_Values = map[string]VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion_STATUS{
	"ipv4": VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion_STATUS_IPv4,
	"ipv6": VirtualMachineScaleSetPublicIPAddressConfigurationProperties_PublicIPAddressVersion_STATUS_IPv6,
}

func init() {
	SchemeBuilder.Register(&VirtualMachineScaleSet{}, &VirtualMachineScaleSetList{})
}
