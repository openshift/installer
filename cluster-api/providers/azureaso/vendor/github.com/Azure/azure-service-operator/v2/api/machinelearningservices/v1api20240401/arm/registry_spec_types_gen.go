// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import "github.com/Azure/azure-service-operator/v2/pkg/genruntime"

type Registry_Spec struct {
	// Identity: Managed service identity (system assigned and/or user assigned identities)
	Identity *ManagedServiceIdentity `json:"identity,omitempty"`

	// Kind: Metadata used by portal/tooling/etc to render different UX experiences for resources of the same type.
	Kind *string `json:"kind,omitempty"`

	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	Name     string  `json:"name,omitempty"`

	// Properties: [Required] Additional attributes of the entity.
	Properties *RegistrySpec `json:"properties,omitempty"`

	// Sku: Sku details required for ARM contract for Autoscaling.
	Sku *Sku `json:"sku,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMResourceSpec = &Registry_Spec{}

// GetAPIVersion returns the ARM API version of the resource. This is always "2024-04-01"
func (registry Registry_Spec) GetAPIVersion() string {
	return "2024-04-01"
}

// GetName returns the Name of the resource
func (registry *Registry_Spec) GetName() string {
	return registry.Name
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.MachineLearningServices/registries"
func (registry *Registry_Spec) GetType() string {
	return "Microsoft.MachineLearningServices/registries"
}

// Managed service identity (system assigned and/or user assigned identities)
type ManagedServiceIdentity struct {
	// Type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
	Type                   *ManagedServiceIdentityType            `json:"type,omitempty"`
	UserAssignedIdentities map[string]UserAssignedIdentityDetails `json:"userAssignedIdentities,omitempty"`
}

// Details of the Registry
type RegistrySpec struct {
	// DiscoveryUrl: Discovery URL for the Registry
	DiscoveryUrl *string `json:"discoveryUrl,omitempty"`

	// IntellectualPropertyPublisher: IntellectualPropertyPublisher for the registry
	IntellectualPropertyPublisher *string `json:"intellectualPropertyPublisher,omitempty"`

	// ManagedResourceGroup: ResourceId of the managed RG if the registry has system created resources
	ManagedResourceGroup *ArmResourceId `json:"managedResourceGroup,omitempty"`

	// MlFlowRegistryUri: MLFlow Registry URI for the Registry
	MlFlowRegistryUri *string `json:"mlFlowRegistryUri,omitempty"`

	// PublicNetworkAccess: Is the Registry accessible from the internet?
	// Possible values: "Enabled" or "Disabled"
	PublicNetworkAccess *string `json:"publicNetworkAccess,omitempty"`

	// RegionDetails: Details of each region the registry is in
	RegionDetails []RegistryRegionArmDetails `json:"regionDetails,omitempty"`

	// RegistryPrivateEndpointConnections: Private endpoint connections info used for pending connections in private link portal
	RegistryPrivateEndpointConnections []RegistryPrivateEndpointConnection `json:"registryPrivateEndpointConnections,omitempty"`
}

// The resource model definition representing SKU
type Sku struct {
	// Capacity: If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible
	// for the resource this may be omitted.
	Capacity *int `json:"capacity,omitempty"`

	// Family: If the service has different generations of hardware, for the same SKU, then that can be captured here.
	Family *string `json:"family,omitempty"`

	// Name: The name of the SKU. Ex - P3. It is typically a letter+number code
	Name *string `json:"name,omitempty"`

	// Size: The SKU size. When the name field is the combination of tier and some other value, this would be the standalone
	// code.
	Size *string `json:"size,omitempty"`

	// Tier: This field is required to be implemented by the Resource Provider if the service has more than one tier, but is
	// not  required on a PUT.
	Tier *SkuTier `json:"tier,omitempty"`
}

// ARM ResourceId of a resource
type ArmResourceId struct {
	ResourceId *string `json:"resourceId,omitempty"`
}

// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
// +kubebuilder:validation:Enum={"None","SystemAssigned","SystemAssigned,UserAssigned","UserAssigned"}
type ManagedServiceIdentityType string

const (
	ManagedServiceIdentityType_None                       = ManagedServiceIdentityType("None")
	ManagedServiceIdentityType_SystemAssigned             = ManagedServiceIdentityType("SystemAssigned")
	ManagedServiceIdentityType_SystemAssignedUserAssigned = ManagedServiceIdentityType("SystemAssigned,UserAssigned")
	ManagedServiceIdentityType_UserAssigned               = ManagedServiceIdentityType("UserAssigned")
)

// Mapping from string to ManagedServiceIdentityType
var managedServiceIdentityType_Values = map[string]ManagedServiceIdentityType{
	"none":                        ManagedServiceIdentityType_None,
	"systemassigned":              ManagedServiceIdentityType_SystemAssigned,
	"systemassigned,userassigned": ManagedServiceIdentityType_SystemAssignedUserAssigned,
	"userassigned":                ManagedServiceIdentityType_UserAssigned,
}

// Private endpoint connection definition.
type RegistryPrivateEndpointConnection struct {
	Id *string `json:"id,omitempty"`

	// Location: Same as workspace location.
	Location *string `json:"location,omitempty"`

	// Properties: Properties of the Private Endpoint Connection
	Properties *RegistryPrivateEndpointConnectionProperties `json:"properties,omitempty"`
}

// Details for each region the registry is in
type RegistryRegionArmDetails struct {
	// AcrDetails: List of ACR accounts
	AcrDetails []AcrDetails `json:"acrDetails,omitempty"`

	// Location: The location where the registry exists
	Location *string `json:"location,omitempty"`

	// StorageAccountDetails: List of storage accounts
	StorageAccountDetails []StorageAccountDetails `json:"storageAccountDetails,omitempty"`
}

// This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not
// required on a PUT.
// +kubebuilder:validation:Enum={"Basic","Free","Premium","Standard"}
type SkuTier string

const (
	SkuTier_Basic    = SkuTier("Basic")
	SkuTier_Free     = SkuTier("Free")
	SkuTier_Premium  = SkuTier("Premium")
	SkuTier_Standard = SkuTier("Standard")
)

// Mapping from string to SkuTier
var skuTier_Values = map[string]SkuTier{
	"basic":    SkuTier_Basic,
	"free":     SkuTier_Free,
	"premium":  SkuTier_Premium,
	"standard": SkuTier_Standard,
}

// Information about the user assigned identity for the resource
type UserAssignedIdentityDetails struct {
}

// Details of ACR account to be used for the Registry
type AcrDetails struct {
	// SystemCreatedAcrAccount: Details of system created ACR account to be used for the Registry
	SystemCreatedAcrAccount *SystemCreatedAcrAccount `json:"systemCreatedAcrAccount,omitempty"`

	// UserCreatedAcrAccount: Details of user created ACR account to be used for the Registry
	UserCreatedAcrAccount *UserCreatedAcrAccount `json:"userCreatedAcrAccount,omitempty"`
}

// Properties of the Private Endpoint Connection
type RegistryPrivateEndpointConnectionProperties struct {
	// GroupIds: The group ids
	GroupIds []string `json:"groupIds,omitempty"`

	// PrivateEndpoint: The PE network resource that is linked to this PE connection.
	PrivateEndpoint *PrivateEndpointResource `json:"privateEndpoint,omitempty"`

	// ProvisioningState: One of null, "Succeeded", "Provisioning", "Failed". While not approved, it's null.
	ProvisioningState *string `json:"provisioningState,omitempty"`

	// RegistryPrivateLinkServiceConnectionState: The connection state.
	RegistryPrivateLinkServiceConnectionState *RegistryPrivateLinkServiceConnectionState `json:"registryPrivateLinkServiceConnectionState,omitempty"`
}

// Details of storage account to be used for the Registry
type StorageAccountDetails struct {
	// SystemCreatedStorageAccount: Details of system created storage account to be used for the registry
	SystemCreatedStorageAccount *SystemCreatedStorageAccount `json:"systemCreatedStorageAccount,omitempty"`

	// UserCreatedStorageAccount: Details of user created storage account to be used for the registry
	UserCreatedStorageAccount *UserCreatedStorageAccount `json:"userCreatedStorageAccount,omitempty"`
}

// The PE network resource that is linked to this PE connection.
type PrivateEndpointResource struct {
	SubnetArmId *string `json:"subnetArmId,omitempty"`
}

// The connection state.
type RegistryPrivateLinkServiceConnectionState struct {
	// ActionsRequired: Some RP chose "None". Other RPs use this for region expansion.
	ActionsRequired *string `json:"actionsRequired,omitempty"`

	// Description: User-defined message that, per NRP doc, may be used for approval-related message.
	Description *string `json:"description,omitempty"`

	// Status: Connection status of the service consumer with the service provider
	Status *EndpointServiceConnectionStatus `json:"status,omitempty"`
}

type SystemCreatedAcrAccount struct {
	// AcrAccountName: Name of the ACR account
	AcrAccountName *string `json:"acrAccountName,omitempty"`

	// AcrAccountSku: SKU of the ACR account
	AcrAccountSku *string `json:"acrAccountSku,omitempty"`
}

type SystemCreatedStorageAccount struct {
	// AllowBlobPublicAccess: Public blob access allowed
	AllowBlobPublicAccess *bool `json:"allowBlobPublicAccess,omitempty"`

	// StorageAccountHnsEnabled: HNS enabled for storage account
	StorageAccountHnsEnabled *bool `json:"storageAccountHnsEnabled,omitempty"`

	// StorageAccountName: Name of the storage account
	StorageAccountName *string `json:"storageAccountName,omitempty"`

	// StorageAccountType: Allowed values:
	// "Standard_LRS",
	// "Standard_GRS",
	// "Standard_RAGRS",
	// "Standard_ZRS",
	// "Standard_GZRS",
	// "Standard_RAGZRS",
	// "Premium_LRS",
	// "Premium_ZRS"
	StorageAccountType *string `json:"storageAccountType,omitempty"`
}

type UserCreatedAcrAccount struct {
	// ArmResourceId: ARM ResourceId of a resource
	ArmResourceId *ArmResourceId `json:"armResourceId,omitempty"`
}

type UserCreatedStorageAccount struct {
	// ArmResourceId: ARM ResourceId of a resource
	ArmResourceId *ArmResourceId `json:"armResourceId,omitempty"`
}

// Connection status of the service consumer with the service provider
// +kubebuilder:validation:Enum={"Approved","Disconnected","Pending","Rejected"}
type EndpointServiceConnectionStatus string

const (
	EndpointServiceConnectionStatus_Approved     = EndpointServiceConnectionStatus("Approved")
	EndpointServiceConnectionStatus_Disconnected = EndpointServiceConnectionStatus("Disconnected")
	EndpointServiceConnectionStatus_Pending      = EndpointServiceConnectionStatus("Pending")
	EndpointServiceConnectionStatus_Rejected     = EndpointServiceConnectionStatus("Rejected")
)

// Mapping from string to EndpointServiceConnectionStatus
var endpointServiceConnectionStatus_Values = map[string]EndpointServiceConnectionStatus{
	"approved":     EndpointServiceConnectionStatus_Approved,
	"disconnected": EndpointServiceConnectionStatus_Disconnected,
	"pending":      EndpointServiceConnectionStatus_Pending,
	"rejected":     EndpointServiceConnectionStatus_Rejected,
}
