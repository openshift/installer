// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package storage

import (
	storage "github.com/Azure/azure-service-operator/v2/api/cdn/v1api20230501/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

// +kubebuilder:rbac:groups=cdn.azure.com,resources=profilesendpoints,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=cdn.azure.com,resources={profilesendpoints/status,profilesendpoints/finalizers},verbs=get;update;patch

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Storage version of v1api20210601.ProfilesEndpoint
// Generator information:
// - Generated from: /cdn/resource-manager/Microsoft.Cdn/stable/2021-06-01/cdn.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}
type ProfilesEndpoint struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ProfilesEndpoint_Spec   `json:"spec,omitempty"`
	Status            ProfilesEndpoint_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &ProfilesEndpoint{}

// GetConditions returns the conditions of the resource
func (endpoint *ProfilesEndpoint) GetConditions() conditions.Conditions {
	return endpoint.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (endpoint *ProfilesEndpoint) SetConditions(conditions conditions.Conditions) {
	endpoint.Status.Conditions = conditions
}

var _ configmaps.Exporter = &ProfilesEndpoint{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (endpoint *ProfilesEndpoint) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if endpoint.Spec.OperatorSpec == nil {
		return nil
	}
	return endpoint.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &ProfilesEndpoint{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (endpoint *ProfilesEndpoint) SecretDestinationExpressions() []*core.DestinationExpression {
	if endpoint.Spec.OperatorSpec == nil {
		return nil
	}
	return endpoint.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.KubernetesResource = &ProfilesEndpoint{}

// AzureName returns the Azure name of the resource
func (endpoint *ProfilesEndpoint) AzureName() string {
	return endpoint.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2021-06-01"
func (endpoint ProfilesEndpoint) GetAPIVersion() string {
	return "2021-06-01"
}

// GetResourceScope returns the scope of the resource
func (endpoint *ProfilesEndpoint) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (endpoint *ProfilesEndpoint) GetSpec() genruntime.ConvertibleSpec {
	return &endpoint.Spec
}

// GetStatus returns the status of this resource
func (endpoint *ProfilesEndpoint) GetStatus() genruntime.ConvertibleStatus {
	return &endpoint.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (endpoint *ProfilesEndpoint) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Cdn/profiles/endpoints"
func (endpoint *ProfilesEndpoint) GetType() string {
	return "Microsoft.Cdn/profiles/endpoints"
}

// NewEmptyStatus returns a new empty (blank) status
func (endpoint *ProfilesEndpoint) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &ProfilesEndpoint_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (endpoint *ProfilesEndpoint) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(endpoint.Spec)
	return endpoint.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (endpoint *ProfilesEndpoint) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*ProfilesEndpoint_STATUS); ok {
		endpoint.Status = *st
		return nil
	}

	// Convert status to required version
	var st ProfilesEndpoint_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	endpoint.Status = st
	return nil
}

// Hub marks that this ProfilesEndpoint is the hub type for conversion
func (endpoint *ProfilesEndpoint) Hub() {}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (endpoint *ProfilesEndpoint) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: endpoint.Spec.OriginalVersion,
		Kind:    "ProfilesEndpoint",
	}
}

// +kubebuilder:object:root=true
// Storage version of v1api20210601.ProfilesEndpoint
// Generator information:
// - Generated from: /cdn/resource-manager/Microsoft.Cdn/stable/2021-06-01/cdn.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/endpoints/{endpointName}
type ProfilesEndpointList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ProfilesEndpoint `json:"items"`
}

// Storage version of v1api20210601.ProfilesEndpoint_Spec
type ProfilesEndpoint_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName              string                             `json:"azureName,omitempty"`
	ContentTypesToCompress []string                           `json:"contentTypesToCompress,omitempty"`
	DefaultOriginGroup     *ResourceReference                 `json:"defaultOriginGroup,omitempty"`
	DeliveryPolicy         *EndpointProperties_DeliveryPolicy `json:"deliveryPolicy,omitempty"`
	GeoFilters             []GeoFilter                        `json:"geoFilters,omitempty"`
	IsCompressionEnabled   *bool                              `json:"isCompressionEnabled,omitempty"`
	IsHttpAllowed          *bool                              `json:"isHttpAllowed,omitempty"`
	IsHttpsAllowed         *bool                              `json:"isHttpsAllowed,omitempty"`
	Location               *string                            `json:"location,omitempty"`
	OperatorSpec           *ProfilesEndpointOperatorSpec      `json:"operatorSpec,omitempty"`
	OptimizationType       *string                            `json:"optimizationType,omitempty"`
	OriginGroups           []DeepCreatedOriginGroup           `json:"originGroups,omitempty"`
	OriginHostHeader       *string                            `json:"originHostHeader,omitempty"`
	OriginPath             *string                            `json:"originPath,omitempty"`
	OriginalVersion        string                             `json:"originalVersion,omitempty"`
	Origins                []DeepCreatedOrigin                `json:"origins,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a cdn.azure.com/Profile resource
	Owner                            *genruntime.KnownResourceReference                   `group:"cdn.azure.com" json:"owner,omitempty" kind:"Profile"`
	ProbePath                        *string                                              `json:"probePath,omitempty"`
	PropertyBag                      genruntime.PropertyBag                               `json:"$propertyBag,omitempty"`
	QueryStringCachingBehavior       *string                                              `json:"queryStringCachingBehavior,omitempty"`
	Tags                             map[string]string                                    `json:"tags,omitempty"`
	UrlSigningKeys                   []UrlSigningKey                                      `json:"urlSigningKeys,omitempty"`
	WebApplicationFirewallPolicyLink *EndpointProperties_WebApplicationFirewallPolicyLink `json:"webApplicationFirewallPolicyLink,omitempty"`
}

var _ genruntime.ConvertibleSpec = &ProfilesEndpoint_Spec{}

// ConvertSpecFrom populates our ProfilesEndpoint_Spec from the provided source
func (endpoint *ProfilesEndpoint_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	if source == endpoint {
		return errors.New("attempted conversion between unrelated implementations of github.com/Azure/azure-service-operator/v2/pkg/genruntime/ConvertibleSpec")
	}

	return source.ConvertSpecTo(endpoint)
}

// ConvertSpecTo populates the provided destination from our ProfilesEndpoint_Spec
func (endpoint *ProfilesEndpoint_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	if destination == endpoint {
		return errors.New("attempted conversion between unrelated implementations of github.com/Azure/azure-service-operator/v2/pkg/genruntime/ConvertibleSpec")
	}

	return destination.ConvertSpecFrom(endpoint)
}

// Storage version of v1api20210601.ProfilesEndpoint_STATUS
type ProfilesEndpoint_STATUS struct {
	Conditions                       []conditions.Condition                                      `json:"conditions,omitempty"`
	ContentTypesToCompress           []string                                                    `json:"contentTypesToCompress,omitempty"`
	CustomDomains                    []DeepCreatedCustomDomain_STATUS                            `json:"customDomains,omitempty"`
	DefaultOriginGroup               *ResourceReference_STATUS                                   `json:"defaultOriginGroup,omitempty"`
	DeliveryPolicy                   *EndpointProperties_DeliveryPolicy_STATUS                   `json:"deliveryPolicy,omitempty"`
	GeoFilters                       []GeoFilter_STATUS                                          `json:"geoFilters,omitempty"`
	HostName                         *string                                                     `json:"hostName,omitempty"`
	Id                               *string                                                     `json:"id,omitempty"`
	IsCompressionEnabled             *bool                                                       `json:"isCompressionEnabled,omitempty"`
	IsHttpAllowed                    *bool                                                       `json:"isHttpAllowed,omitempty"`
	IsHttpsAllowed                   *bool                                                       `json:"isHttpsAllowed,omitempty"`
	Location                         *string                                                     `json:"location,omitempty"`
	Name                             *string                                                     `json:"name,omitempty"`
	OptimizationType                 *string                                                     `json:"optimizationType,omitempty"`
	OriginGroups                     []DeepCreatedOriginGroup_STATUS                             `json:"originGroups,omitempty"`
	OriginHostHeader                 *string                                                     `json:"originHostHeader,omitempty"`
	OriginPath                       *string                                                     `json:"originPath,omitempty"`
	Origins                          []DeepCreatedOrigin_STATUS                                  `json:"origins,omitempty"`
	ProbePath                        *string                                                     `json:"probePath,omitempty"`
	PropertyBag                      genruntime.PropertyBag                                      `json:"$propertyBag,omitempty"`
	ProvisioningState                *string                                                     `json:"provisioningState,omitempty"`
	QueryStringCachingBehavior       *string                                                     `json:"queryStringCachingBehavior,omitempty"`
	ResourceState                    *string                                                     `json:"resourceState,omitempty"`
	SystemData                       *SystemData_STATUS                                          `json:"systemData,omitempty"`
	Tags                             map[string]string                                           `json:"tags,omitempty"`
	Type                             *string                                                     `json:"type,omitempty"`
	UrlSigningKeys                   []UrlSigningKey_STATUS                                      `json:"urlSigningKeys,omitempty"`
	WebApplicationFirewallPolicyLink *EndpointProperties_WebApplicationFirewallPolicyLink_STATUS `json:"webApplicationFirewallPolicyLink,omitempty"`
}

var _ genruntime.ConvertibleStatus = &ProfilesEndpoint_STATUS{}

// ConvertStatusFrom populates our ProfilesEndpoint_STATUS from the provided source
func (endpoint *ProfilesEndpoint_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	if source == endpoint {
		return errors.New("attempted conversion between unrelated implementations of github.com/Azure/azure-service-operator/v2/pkg/genruntime/ConvertibleStatus")
	}

	return source.ConvertStatusTo(endpoint)
}

// ConvertStatusTo populates the provided destination from our ProfilesEndpoint_STATUS
func (endpoint *ProfilesEndpoint_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	if destination == endpoint {
		return errors.New("attempted conversion between unrelated implementations of github.com/Azure/azure-service-operator/v2/pkg/genruntime/ConvertibleStatus")
	}

	return destination.ConvertStatusFrom(endpoint)
}

// Storage version of v1api20210601.DeepCreatedCustomDomain_STATUS
// Custom domains created on the CDN endpoint.
type DeepCreatedCustomDomain_STATUS struct {
	HostName       *string                `json:"hostName,omitempty"`
	Name           *string                `json:"name,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ValidationData *string                `json:"validationData,omitempty"`
}

// Storage version of v1api20210601.DeepCreatedOrigin
// The main origin of CDN content which is added when creating a CDN endpoint.
type DeepCreatedOrigin struct {
	Enabled                    *bool   `json:"enabled,omitempty"`
	HostName                   *string `json:"hostName,omitempty"`
	HttpPort                   *int    `json:"httpPort,omitempty"`
	HttpsPort                  *int    `json:"httpsPort,omitempty"`
	Name                       *string `json:"name,omitempty"`
	OriginHostHeader           *string `json:"originHostHeader,omitempty"`
	Priority                   *int    `json:"priority,omitempty"`
	PrivateLinkAlias           *string `json:"privateLinkAlias,omitempty"`
	PrivateLinkApprovalMessage *string `json:"privateLinkApprovalMessage,omitempty"`

	// PrivateLinkLocationReference: The location of the Private Link resource. Required only if 'privateLinkResourceId' is
	// populated
	PrivateLinkLocationReference *genruntime.ResourceReference `armReference:"PrivateLinkLocation" json:"privateLinkLocationReference,omitempty"`

	// PrivateLinkResourceReference: The Resource Id of the Private Link resource. Populating this optional field indicates
	// that this backend is 'Private'
	PrivateLinkResourceReference *genruntime.ResourceReference `armReference:"PrivateLinkResourceId" json:"privateLinkResourceReference,omitempty"`
	PropertyBag                  genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	Weight                       *int                          `json:"weight,omitempty"`
}

// Storage version of v1api20210601.DeepCreatedOrigin_STATUS
// The main origin of CDN content which is added when creating a CDN endpoint.
type DeepCreatedOrigin_STATUS struct {
	Enabled                    *bool                  `json:"enabled,omitempty"`
	HostName                   *string                `json:"hostName,omitempty"`
	HttpPort                   *int                   `json:"httpPort,omitempty"`
	HttpsPort                  *int                   `json:"httpsPort,omitempty"`
	Name                       *string                `json:"name,omitempty"`
	OriginHostHeader           *string                `json:"originHostHeader,omitempty"`
	Priority                   *int                   `json:"priority,omitempty"`
	PrivateEndpointStatus      *string                `json:"privateEndpointStatus,omitempty"`
	PrivateLinkAlias           *string                `json:"privateLinkAlias,omitempty"`
	PrivateLinkApprovalMessage *string                `json:"privateLinkApprovalMessage,omitempty"`
	PrivateLinkLocation        *string                `json:"privateLinkLocation,omitempty"`
	PrivateLinkResourceId      *string                `json:"privateLinkResourceId,omitempty"`
	PropertyBag                genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Weight                     *int                   `json:"weight,omitempty"`
}

// Storage version of v1api20210601.DeepCreatedOriginGroup
// The origin group for CDN content which is added when creating a CDN endpoint. Traffic is sent to the origins within the
// origin group based on origin health.
type DeepCreatedOriginGroup struct {
	HealthProbeSettings                                   *HealthProbeParameters                       `json:"healthProbeSettings,omitempty"`
	Name                                                  *string                                      `json:"name,omitempty"`
	Origins                                               []ResourceReference                          `json:"origins,omitempty"`
	PropertyBag                                           genruntime.PropertyBag                       `json:"$propertyBag,omitempty"`
	ResponseBasedOriginErrorDetectionSettings             *ResponseBasedOriginErrorDetectionParameters `json:"responseBasedOriginErrorDetectionSettings,omitempty"`
	TrafficRestorationTimeToHealedOrNewEndpointsInMinutes *int                                         `json:"trafficRestorationTimeToHealedOrNewEndpointsInMinutes,omitempty"`
}

// Storage version of v1api20210601.DeepCreatedOriginGroup_STATUS
// The origin group for CDN content which is added when creating a CDN endpoint. Traffic is sent to the origins within the
// origin group based on origin health.
type DeepCreatedOriginGroup_STATUS struct {
	HealthProbeSettings                                   *HealthProbeParameters_STATUS                       `json:"healthProbeSettings,omitempty"`
	Name                                                  *string                                             `json:"name,omitempty"`
	Origins                                               []ResourceReference_STATUS                          `json:"origins,omitempty"`
	PropertyBag                                           genruntime.PropertyBag                              `json:"$propertyBag,omitempty"`
	ResponseBasedOriginErrorDetectionSettings             *ResponseBasedOriginErrorDetectionParameters_STATUS `json:"responseBasedOriginErrorDetectionSettings,omitempty"`
	TrafficRestorationTimeToHealedOrNewEndpointsInMinutes *int                                                `json:"trafficRestorationTimeToHealedOrNewEndpointsInMinutes,omitempty"`
}

// Storage version of v1api20210601.EndpointProperties_DeliveryPolicy
type EndpointProperties_DeliveryPolicy struct {
	Description *string                `json:"description,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Rules       []DeliveryRule         `json:"rules,omitempty"`
}

// Storage version of v1api20210601.EndpointProperties_DeliveryPolicy_STATUS
type EndpointProperties_DeliveryPolicy_STATUS struct {
	Description *string                `json:"description,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Rules       []DeliveryRule_STATUS  `json:"rules,omitempty"`
}

// Storage version of v1api20210601.EndpointProperties_WebApplicationFirewallPolicyLink
type EndpointProperties_WebApplicationFirewallPolicyLink struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`

	// Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

// Storage version of v1api20210601.EndpointProperties_WebApplicationFirewallPolicyLink_STATUS
type EndpointProperties_WebApplicationFirewallPolicyLink_STATUS struct {
	Id          *string                `json:"id,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// Storage version of v1api20210601.GeoFilter
// Rules defining user's geo access within a CDN endpoint.
type GeoFilter struct {
	Action       *string                `json:"action,omitempty"`
	CountryCodes []string               `json:"countryCodes,omitempty"`
	PropertyBag  genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	RelativePath *string                `json:"relativePath,omitempty"`
}

// Storage version of v1api20210601.GeoFilter_STATUS
// Rules defining user's geo access within a CDN endpoint.
type GeoFilter_STATUS struct {
	Action       *string                `json:"action,omitempty"`
	CountryCodes []string               `json:"countryCodes,omitempty"`
	PropertyBag  genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	RelativePath *string                `json:"relativePath,omitempty"`
}

// Storage version of v1api20210601.ProfilesEndpointOperatorSpec
// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type ProfilesEndpointOperatorSpec struct {
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`
	PropertyBag          genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	SecretExpressions    []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// Storage version of v1api20210601.ResourceReference
// Reference to another resource.
type ResourceReference struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`

	// Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

// AssignProperties_From_ResourceReference populates our ResourceReference from the provided source ResourceReference
func (reference *ResourceReference) AssignProperties_From_ResourceReference(source *storage.ResourceReference) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Reference
	if source.Reference != nil {
		referenceTemp := source.Reference.Copy()
		reference.Reference = &referenceTemp
	} else {
		reference.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		reference.PropertyBag = propertyBag
	} else {
		reference.PropertyBag = nil
	}

	// Invoke the augmentConversionForResourceReference interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForResourceReference); ok {
		err := augmentedReference.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ResourceReference populates the provided destination ResourceReference from our ResourceReference
func (reference *ResourceReference) AssignProperties_To_ResourceReference(destination *storage.ResourceReference) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(reference.PropertyBag)

	// Reference
	if reference.Reference != nil {
		referenceTemp := reference.Reference.Copy()
		destination.Reference = &referenceTemp
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForResourceReference interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForResourceReference); ok {
		err := augmentedReference.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.ResourceReference_STATUS
// Reference to another resource.
type ResourceReference_STATUS struct {
	Id          *string                `json:"id,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_ResourceReference_STATUS populates our ResourceReference_STATUS from the provided source ResourceReference_STATUS
func (reference *ResourceReference_STATUS) AssignProperties_From_ResourceReference_STATUS(source *storage.ResourceReference_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Id
	reference.Id = genruntime.ClonePointerToString(source.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		reference.PropertyBag = propertyBag
	} else {
		reference.PropertyBag = nil
	}

	// Invoke the augmentConversionForResourceReference_STATUS interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForResourceReference_STATUS); ok {
		err := augmentedReference.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ResourceReference_STATUS populates the provided destination ResourceReference_STATUS from our ResourceReference_STATUS
func (reference *ResourceReference_STATUS) AssignProperties_To_ResourceReference_STATUS(destination *storage.ResourceReference_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(reference.PropertyBag)

	// Id
	destination.Id = genruntime.ClonePointerToString(reference.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForResourceReference_STATUS interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForResourceReference_STATUS); ok {
		err := augmentedReference.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.UrlSigningKey
// Url signing key
type UrlSigningKey struct {
	KeyId               *string                       `json:"keyId,omitempty"`
	KeySourceParameters *KeyVaultSigningKeyParameters `json:"keySourceParameters,omitempty"`
	PropertyBag         genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
}

// Storage version of v1api20210601.UrlSigningKey_STATUS
// Url signing key
type UrlSigningKey_STATUS struct {
	KeyId               *string                              `json:"keyId,omitempty"`
	KeySourceParameters *KeyVaultSigningKeyParameters_STATUS `json:"keySourceParameters,omitempty"`
	PropertyBag         genruntime.PropertyBag               `json:"$propertyBag,omitempty"`
}

type augmentConversionForResourceReference interface {
	AssignPropertiesFrom(src *storage.ResourceReference) error
	AssignPropertiesTo(dst *storage.ResourceReference) error
}

type augmentConversionForResourceReference_STATUS interface {
	AssignPropertiesFrom(src *storage.ResourceReference_STATUS) error
	AssignPropertiesTo(dst *storage.ResourceReference_STATUS) error
}

// Storage version of v1api20210601.DeliveryRule
// A rule that specifies a set of actions and conditions
type DeliveryRule struct {
	Actions     []DeliveryRuleAction    `json:"actions,omitempty"`
	Conditions  []DeliveryRuleCondition `json:"conditions,omitempty"`
	Name        *string                 `json:"name,omitempty"`
	Order       *int                    `json:"order,omitempty"`
	PropertyBag genruntime.PropertyBag  `json:"$propertyBag,omitempty"`
}

// Storage version of v1api20210601.DeliveryRule_STATUS
// A rule that specifies a set of actions and conditions
type DeliveryRule_STATUS struct {
	Actions     []DeliveryRuleAction_STATUS    `json:"actions,omitempty"`
	Conditions  []DeliveryRuleCondition_STATUS `json:"conditions,omitempty"`
	Name        *string                        `json:"name,omitempty"`
	Order       *int                           `json:"order,omitempty"`
	PropertyBag genruntime.PropertyBag         `json:"$propertyBag,omitempty"`
}

// Storage version of v1api20210601.HealthProbeParameters
// The JSON object that contains the properties to send health probes to origin.
type HealthProbeParameters struct {
	ProbeIntervalInSeconds *int                   `json:"probeIntervalInSeconds,omitempty"`
	ProbePath              *string                `json:"probePath,omitempty"`
	ProbeProtocol          *string                `json:"probeProtocol,omitempty"`
	ProbeRequestType       *string                `json:"probeRequestType,omitempty"`
	PropertyBag            genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_HealthProbeParameters populates our HealthProbeParameters from the provided source HealthProbeParameters
func (parameters *HealthProbeParameters) AssignProperties_From_HealthProbeParameters(source *storage.HealthProbeParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ProbeIntervalInSeconds
	parameters.ProbeIntervalInSeconds = genruntime.ClonePointerToInt(source.ProbeIntervalInSeconds)

	// ProbePath
	parameters.ProbePath = genruntime.ClonePointerToString(source.ProbePath)

	// ProbeProtocol
	parameters.ProbeProtocol = genruntime.ClonePointerToString(source.ProbeProtocol)

	// ProbeRequestType
	parameters.ProbeRequestType = genruntime.ClonePointerToString(source.ProbeRequestType)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForHealthProbeParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHealthProbeParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_HealthProbeParameters populates the provided destination HealthProbeParameters from our HealthProbeParameters
func (parameters *HealthProbeParameters) AssignProperties_To_HealthProbeParameters(destination *storage.HealthProbeParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// ProbeIntervalInSeconds
	destination.ProbeIntervalInSeconds = genruntime.ClonePointerToInt(parameters.ProbeIntervalInSeconds)

	// ProbePath
	destination.ProbePath = genruntime.ClonePointerToString(parameters.ProbePath)

	// ProbeProtocol
	destination.ProbeProtocol = genruntime.ClonePointerToString(parameters.ProbeProtocol)

	// ProbeRequestType
	destination.ProbeRequestType = genruntime.ClonePointerToString(parameters.ProbeRequestType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForHealthProbeParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHealthProbeParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.HealthProbeParameters_STATUS
// The JSON object that contains the properties to send health probes to origin.
type HealthProbeParameters_STATUS struct {
	ProbeIntervalInSeconds *int                   `json:"probeIntervalInSeconds,omitempty"`
	ProbePath              *string                `json:"probePath,omitempty"`
	ProbeProtocol          *string                `json:"probeProtocol,omitempty"`
	ProbeRequestType       *string                `json:"probeRequestType,omitempty"`
	PropertyBag            genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_HealthProbeParameters_STATUS populates our HealthProbeParameters_STATUS from the provided source HealthProbeParameters_STATUS
func (parameters *HealthProbeParameters_STATUS) AssignProperties_From_HealthProbeParameters_STATUS(source *storage.HealthProbeParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ProbeIntervalInSeconds
	parameters.ProbeIntervalInSeconds = genruntime.ClonePointerToInt(source.ProbeIntervalInSeconds)

	// ProbePath
	parameters.ProbePath = genruntime.ClonePointerToString(source.ProbePath)

	// ProbeProtocol
	parameters.ProbeProtocol = genruntime.ClonePointerToString(source.ProbeProtocol)

	// ProbeRequestType
	parameters.ProbeRequestType = genruntime.ClonePointerToString(source.ProbeRequestType)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForHealthProbeParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHealthProbeParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_HealthProbeParameters_STATUS populates the provided destination HealthProbeParameters_STATUS from our HealthProbeParameters_STATUS
func (parameters *HealthProbeParameters_STATUS) AssignProperties_To_HealthProbeParameters_STATUS(destination *storage.HealthProbeParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// ProbeIntervalInSeconds
	destination.ProbeIntervalInSeconds = genruntime.ClonePointerToInt(parameters.ProbeIntervalInSeconds)

	// ProbePath
	destination.ProbePath = genruntime.ClonePointerToString(parameters.ProbePath)

	// ProbeProtocol
	destination.ProbeProtocol = genruntime.ClonePointerToString(parameters.ProbeProtocol)

	// ProbeRequestType
	destination.ProbeRequestType = genruntime.ClonePointerToString(parameters.ProbeRequestType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForHealthProbeParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHealthProbeParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.KeyVaultSigningKeyParameters
// Describes the parameters for using a user's KeyVault for URL Signing Key.
type KeyVaultSigningKeyParameters struct {
	PropertyBag       genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ResourceGroupName *string                `json:"resourceGroupName,omitempty"`
	SecretName        *string                `json:"secretName,omitempty"`
	SecretVersion     *string                `json:"secretVersion,omitempty"`
	SubscriptionId    *string                `json:"subscriptionId,omitempty"`
	TypeName          *string                `json:"typeName,omitempty"`
	VaultName         *string                `json:"vaultName,omitempty"`
}

// Storage version of v1api20210601.KeyVaultSigningKeyParameters_STATUS
// Describes the parameters for using a user's KeyVault for URL Signing Key.
type KeyVaultSigningKeyParameters_STATUS struct {
	PropertyBag       genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ResourceGroupName *string                `json:"resourceGroupName,omitempty"`
	SecretName        *string                `json:"secretName,omitempty"`
	SecretVersion     *string                `json:"secretVersion,omitempty"`
	SubscriptionId    *string                `json:"subscriptionId,omitempty"`
	TypeName          *string                `json:"typeName,omitempty"`
	VaultName         *string                `json:"vaultName,omitempty"`
}

// Storage version of v1api20210601.ResponseBasedOriginErrorDetectionParameters
// The JSON object that contains the properties to determine origin health using real requests/responses.
type ResponseBasedOriginErrorDetectionParameters struct {
	HttpErrorRanges                          []HttpErrorRangeParameters `json:"httpErrorRanges,omitempty"`
	PropertyBag                              genruntime.PropertyBag     `json:"$propertyBag,omitempty"`
	ResponseBasedDetectedErrorTypes          *string                    `json:"responseBasedDetectedErrorTypes,omitempty"`
	ResponseBasedFailoverThresholdPercentage *int                       `json:"responseBasedFailoverThresholdPercentage,omitempty"`
}

// Storage version of v1api20210601.ResponseBasedOriginErrorDetectionParameters_STATUS
// The JSON object that contains the properties to determine origin health using real requests/responses.
type ResponseBasedOriginErrorDetectionParameters_STATUS struct {
	HttpErrorRanges                          []HttpErrorRangeParameters_STATUS `json:"httpErrorRanges,omitempty"`
	PropertyBag                              genruntime.PropertyBag            `json:"$propertyBag,omitempty"`
	ResponseBasedDetectedErrorTypes          *string                           `json:"responseBasedDetectedErrorTypes,omitempty"`
	ResponseBasedFailoverThresholdPercentage *int                              `json:"responseBasedFailoverThresholdPercentage,omitempty"`
}

type augmentConversionForHealthProbeParameters interface {
	AssignPropertiesFrom(src *storage.HealthProbeParameters) error
	AssignPropertiesTo(dst *storage.HealthProbeParameters) error
}

type augmentConversionForHealthProbeParameters_STATUS interface {
	AssignPropertiesFrom(src *storage.HealthProbeParameters_STATUS) error
	AssignPropertiesTo(dst *storage.HealthProbeParameters_STATUS) error
}

// Storage version of v1api20210601.DeliveryRuleAction
// An action for the delivery rule.
type DeliveryRuleAction struct {
	CacheExpiration            *DeliveryRuleCacheExpirationAction            `json:"cacheExpiration,omitempty"`
	CacheKeyQueryString        *DeliveryRuleCacheKeyQueryStringAction        `json:"cacheKeyQueryString,omitempty"`
	ModifyRequestHeader        *DeliveryRuleRequestHeaderAction              `json:"modifyRequestHeader,omitempty"`
	ModifyResponseHeader       *DeliveryRuleResponseHeaderAction             `json:"modifyResponseHeader,omitempty"`
	OriginGroupOverride        *OriginGroupOverrideAction                    `json:"originGroupOverride,omitempty"`
	PropertyBag                genruntime.PropertyBag                        `json:"$propertyBag,omitempty"`
	RouteConfigurationOverride *DeliveryRuleRouteConfigurationOverrideAction `json:"routeConfigurationOverride,omitempty"`
	UrlRedirect                *UrlRedirectAction                            `json:"urlRedirect,omitempty"`
	UrlRewrite                 *UrlRewriteAction                             `json:"urlRewrite,omitempty"`
	UrlSigning                 *UrlSigningAction                             `json:"urlSigning,omitempty"`
}

// AssignProperties_From_DeliveryRuleAction populates our DeliveryRuleAction from the provided source DeliveryRuleAction
func (action *DeliveryRuleAction) AssignProperties_From_DeliveryRuleAction(source *storage.DeliveryRuleAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CacheExpiration
	if source.CacheExpiration != nil {
		var cacheExpiration DeliveryRuleCacheExpirationAction
		err := cacheExpiration.AssignProperties_From_DeliveryRuleCacheExpirationAction(source.CacheExpiration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleCacheExpirationAction() to populate field CacheExpiration")
		}
		action.CacheExpiration = &cacheExpiration
	} else {
		action.CacheExpiration = nil
	}

	// CacheKeyQueryString
	if source.CacheKeyQueryString != nil {
		var cacheKeyQueryString DeliveryRuleCacheKeyQueryStringAction
		err := cacheKeyQueryString.AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction(source.CacheKeyQueryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction() to populate field CacheKeyQueryString")
		}
		action.CacheKeyQueryString = &cacheKeyQueryString
	} else {
		action.CacheKeyQueryString = nil
	}

	// ModifyRequestHeader
	if source.ModifyRequestHeader != nil {
		var modifyRequestHeader DeliveryRuleRequestHeaderAction
		err := modifyRequestHeader.AssignProperties_From_DeliveryRuleRequestHeaderAction(source.ModifyRequestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestHeaderAction() to populate field ModifyRequestHeader")
		}
		action.ModifyRequestHeader = &modifyRequestHeader
	} else {
		action.ModifyRequestHeader = nil
	}

	// ModifyResponseHeader
	if source.ModifyResponseHeader != nil {
		var modifyResponseHeader DeliveryRuleResponseHeaderAction
		err := modifyResponseHeader.AssignProperties_From_DeliveryRuleResponseHeaderAction(source.ModifyResponseHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleResponseHeaderAction() to populate field ModifyResponseHeader")
		}
		action.ModifyResponseHeader = &modifyResponseHeader
	} else {
		action.ModifyResponseHeader = nil
	}

	// OriginGroupOverride
	if source.OriginGroupOverride != nil {
		var originGroupOverride OriginGroupOverrideAction
		err := originGroupOverride.AssignProperties_From_OriginGroupOverrideAction(source.OriginGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OriginGroupOverrideAction() to populate field OriginGroupOverride")
		}
		action.OriginGroupOverride = &originGroupOverride
	} else {
		action.OriginGroupOverride = nil
	}

	// RouteConfigurationOverride
	if source.RouteConfigurationOverride != nil {
		var routeConfigurationOverride DeliveryRuleRouteConfigurationOverrideAction
		err := routeConfigurationOverride.AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction(source.RouteConfigurationOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction() to populate field RouteConfigurationOverride")
		}
		action.RouteConfigurationOverride = &routeConfigurationOverride
	} else {
		action.RouteConfigurationOverride = nil
	}

	// UrlRedirect
	if source.UrlRedirect != nil {
		var urlRedirect UrlRedirectAction
		err := urlRedirect.AssignProperties_From_UrlRedirectAction(source.UrlRedirect)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlRedirectAction() to populate field UrlRedirect")
		}
		action.UrlRedirect = &urlRedirect
	} else {
		action.UrlRedirect = nil
	}

	// UrlRewrite
	if source.UrlRewrite != nil {
		var urlRewrite UrlRewriteAction
		err := urlRewrite.AssignProperties_From_UrlRewriteAction(source.UrlRewrite)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlRewriteAction() to populate field UrlRewrite")
		}
		action.UrlRewrite = &urlRewrite
	} else {
		action.UrlRewrite = nil
	}

	// UrlSigning
	if source.UrlSigning != nil {
		var urlSigning UrlSigningAction
		err := urlSigning.AssignProperties_From_UrlSigningAction(source.UrlSigning)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlSigningAction() to populate field UrlSigning")
		}
		action.UrlSigning = &urlSigning
	} else {
		action.UrlSigning = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleAction); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleAction populates the provided destination DeliveryRuleAction from our DeliveryRuleAction
func (action *DeliveryRuleAction) AssignProperties_To_DeliveryRuleAction(destination *storage.DeliveryRuleAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// CacheExpiration
	if action.CacheExpiration != nil {
		var cacheExpiration storage.DeliveryRuleCacheExpirationAction
		err := action.CacheExpiration.AssignProperties_To_DeliveryRuleCacheExpirationAction(&cacheExpiration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleCacheExpirationAction() to populate field CacheExpiration")
		}
		destination.CacheExpiration = &cacheExpiration
	} else {
		destination.CacheExpiration = nil
	}

	// CacheKeyQueryString
	if action.CacheKeyQueryString != nil {
		var cacheKeyQueryString storage.DeliveryRuleCacheKeyQueryStringAction
		err := action.CacheKeyQueryString.AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction(&cacheKeyQueryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction() to populate field CacheKeyQueryString")
		}
		destination.CacheKeyQueryString = &cacheKeyQueryString
	} else {
		destination.CacheKeyQueryString = nil
	}

	// ModifyRequestHeader
	if action.ModifyRequestHeader != nil {
		var modifyRequestHeader storage.DeliveryRuleRequestHeaderAction
		err := action.ModifyRequestHeader.AssignProperties_To_DeliveryRuleRequestHeaderAction(&modifyRequestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestHeaderAction() to populate field ModifyRequestHeader")
		}
		destination.ModifyRequestHeader = &modifyRequestHeader
	} else {
		destination.ModifyRequestHeader = nil
	}

	// ModifyResponseHeader
	if action.ModifyResponseHeader != nil {
		var modifyResponseHeader storage.DeliveryRuleResponseHeaderAction
		err := action.ModifyResponseHeader.AssignProperties_To_DeliveryRuleResponseHeaderAction(&modifyResponseHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleResponseHeaderAction() to populate field ModifyResponseHeader")
		}
		destination.ModifyResponseHeader = &modifyResponseHeader
	} else {
		destination.ModifyResponseHeader = nil
	}

	// OriginGroupOverride
	if action.OriginGroupOverride != nil {
		var originGroupOverride storage.OriginGroupOverrideAction
		err := action.OriginGroupOverride.AssignProperties_To_OriginGroupOverrideAction(&originGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OriginGroupOverrideAction() to populate field OriginGroupOverride")
		}
		destination.OriginGroupOverride = &originGroupOverride
	} else {
		destination.OriginGroupOverride = nil
	}

	// RouteConfigurationOverride
	if action.RouteConfigurationOverride != nil {
		var routeConfigurationOverride storage.DeliveryRuleRouteConfigurationOverrideAction
		err := action.RouteConfigurationOverride.AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction(&routeConfigurationOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction() to populate field RouteConfigurationOverride")
		}
		destination.RouteConfigurationOverride = &routeConfigurationOverride
	} else {
		destination.RouteConfigurationOverride = nil
	}

	// UrlRedirect
	if action.UrlRedirect != nil {
		var urlRedirect storage.UrlRedirectAction
		err := action.UrlRedirect.AssignProperties_To_UrlRedirectAction(&urlRedirect)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlRedirectAction() to populate field UrlRedirect")
		}
		destination.UrlRedirect = &urlRedirect
	} else {
		destination.UrlRedirect = nil
	}

	// UrlRewrite
	if action.UrlRewrite != nil {
		var urlRewrite storage.UrlRewriteAction
		err := action.UrlRewrite.AssignProperties_To_UrlRewriteAction(&urlRewrite)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlRewriteAction() to populate field UrlRewrite")
		}
		destination.UrlRewrite = &urlRewrite
	} else {
		destination.UrlRewrite = nil
	}

	// UrlSigning
	if action.UrlSigning != nil {
		var urlSigning storage.UrlSigningAction
		err := action.UrlSigning.AssignProperties_To_UrlSigningAction(&urlSigning)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlSigningAction() to populate field UrlSigning")
		}
		destination.UrlSigning = &urlSigning
	} else {
		destination.UrlSigning = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleAction); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleAction_STATUS
// An action for the delivery rule.
type DeliveryRuleAction_STATUS struct {
	CacheExpiration            *DeliveryRuleCacheExpirationAction_STATUS            `json:"cacheExpiration,omitempty"`
	CacheKeyQueryString        *DeliveryRuleCacheKeyQueryStringAction_STATUS        `json:"cacheKeyQueryString,omitempty"`
	ModifyRequestHeader        *DeliveryRuleRequestHeaderAction_STATUS              `json:"modifyRequestHeader,omitempty"`
	ModifyResponseHeader       *DeliveryRuleResponseHeaderAction_STATUS             `json:"modifyResponseHeader,omitempty"`
	OriginGroupOverride        *OriginGroupOverrideAction_STATUS                    `json:"originGroupOverride,omitempty"`
	PropertyBag                genruntime.PropertyBag                               `json:"$propertyBag,omitempty"`
	RouteConfigurationOverride *DeliveryRuleRouteConfigurationOverrideAction_STATUS `json:"routeConfigurationOverride,omitempty"`
	UrlRedirect                *UrlRedirectAction_STATUS                            `json:"urlRedirect,omitempty"`
	UrlRewrite                 *UrlRewriteAction_STATUS                             `json:"urlRewrite,omitempty"`
	UrlSigning                 *UrlSigningAction_STATUS                             `json:"urlSigning,omitempty"`
}

// AssignProperties_From_DeliveryRuleAction_STATUS populates our DeliveryRuleAction_STATUS from the provided source DeliveryRuleAction_STATUS
func (action *DeliveryRuleAction_STATUS) AssignProperties_From_DeliveryRuleAction_STATUS(source *storage.DeliveryRuleAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CacheExpiration
	if source.CacheExpiration != nil {
		var cacheExpiration DeliveryRuleCacheExpirationAction_STATUS
		err := cacheExpiration.AssignProperties_From_DeliveryRuleCacheExpirationAction_STATUS(source.CacheExpiration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleCacheExpirationAction_STATUS() to populate field CacheExpiration")
		}
		action.CacheExpiration = &cacheExpiration
	} else {
		action.CacheExpiration = nil
	}

	// CacheKeyQueryString
	if source.CacheKeyQueryString != nil {
		var cacheKeyQueryString DeliveryRuleCacheKeyQueryStringAction_STATUS
		err := cacheKeyQueryString.AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction_STATUS(source.CacheKeyQueryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction_STATUS() to populate field CacheKeyQueryString")
		}
		action.CacheKeyQueryString = &cacheKeyQueryString
	} else {
		action.CacheKeyQueryString = nil
	}

	// ModifyRequestHeader
	if source.ModifyRequestHeader != nil {
		var modifyRequestHeader DeliveryRuleRequestHeaderAction_STATUS
		err := modifyRequestHeader.AssignProperties_From_DeliveryRuleRequestHeaderAction_STATUS(source.ModifyRequestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestHeaderAction_STATUS() to populate field ModifyRequestHeader")
		}
		action.ModifyRequestHeader = &modifyRequestHeader
	} else {
		action.ModifyRequestHeader = nil
	}

	// ModifyResponseHeader
	if source.ModifyResponseHeader != nil {
		var modifyResponseHeader DeliveryRuleResponseHeaderAction_STATUS
		err := modifyResponseHeader.AssignProperties_From_DeliveryRuleResponseHeaderAction_STATUS(source.ModifyResponseHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleResponseHeaderAction_STATUS() to populate field ModifyResponseHeader")
		}
		action.ModifyResponseHeader = &modifyResponseHeader
	} else {
		action.ModifyResponseHeader = nil
	}

	// OriginGroupOverride
	if source.OriginGroupOverride != nil {
		var originGroupOverride OriginGroupOverrideAction_STATUS
		err := originGroupOverride.AssignProperties_From_OriginGroupOverrideAction_STATUS(source.OriginGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OriginGroupOverrideAction_STATUS() to populate field OriginGroupOverride")
		}
		action.OriginGroupOverride = &originGroupOverride
	} else {
		action.OriginGroupOverride = nil
	}

	// RouteConfigurationOverride
	if source.RouteConfigurationOverride != nil {
		var routeConfigurationOverride DeliveryRuleRouteConfigurationOverrideAction_STATUS
		err := routeConfigurationOverride.AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction_STATUS(source.RouteConfigurationOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction_STATUS() to populate field RouteConfigurationOverride")
		}
		action.RouteConfigurationOverride = &routeConfigurationOverride
	} else {
		action.RouteConfigurationOverride = nil
	}

	// UrlRedirect
	if source.UrlRedirect != nil {
		var urlRedirect UrlRedirectAction_STATUS
		err := urlRedirect.AssignProperties_From_UrlRedirectAction_STATUS(source.UrlRedirect)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlRedirectAction_STATUS() to populate field UrlRedirect")
		}
		action.UrlRedirect = &urlRedirect
	} else {
		action.UrlRedirect = nil
	}

	// UrlRewrite
	if source.UrlRewrite != nil {
		var urlRewrite UrlRewriteAction_STATUS
		err := urlRewrite.AssignProperties_From_UrlRewriteAction_STATUS(source.UrlRewrite)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlRewriteAction_STATUS() to populate field UrlRewrite")
		}
		action.UrlRewrite = &urlRewrite
	} else {
		action.UrlRewrite = nil
	}

	// UrlSigning
	if source.UrlSigning != nil {
		var urlSigning UrlSigningAction_STATUS
		err := urlSigning.AssignProperties_From_UrlSigningAction_STATUS(source.UrlSigning)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlSigningAction_STATUS() to populate field UrlSigning")
		}
		action.UrlSigning = &urlSigning
	} else {
		action.UrlSigning = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleAction_STATUS populates the provided destination DeliveryRuleAction_STATUS from our DeliveryRuleAction_STATUS
func (action *DeliveryRuleAction_STATUS) AssignProperties_To_DeliveryRuleAction_STATUS(destination *storage.DeliveryRuleAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// CacheExpiration
	if action.CacheExpiration != nil {
		var cacheExpiration storage.DeliveryRuleCacheExpirationAction_STATUS
		err := action.CacheExpiration.AssignProperties_To_DeliveryRuleCacheExpirationAction_STATUS(&cacheExpiration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleCacheExpirationAction_STATUS() to populate field CacheExpiration")
		}
		destination.CacheExpiration = &cacheExpiration
	} else {
		destination.CacheExpiration = nil
	}

	// CacheKeyQueryString
	if action.CacheKeyQueryString != nil {
		var cacheKeyQueryString storage.DeliveryRuleCacheKeyQueryStringAction_STATUS
		err := action.CacheKeyQueryString.AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction_STATUS(&cacheKeyQueryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction_STATUS() to populate field CacheKeyQueryString")
		}
		destination.CacheKeyQueryString = &cacheKeyQueryString
	} else {
		destination.CacheKeyQueryString = nil
	}

	// ModifyRequestHeader
	if action.ModifyRequestHeader != nil {
		var modifyRequestHeader storage.DeliveryRuleRequestHeaderAction_STATUS
		err := action.ModifyRequestHeader.AssignProperties_To_DeliveryRuleRequestHeaderAction_STATUS(&modifyRequestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestHeaderAction_STATUS() to populate field ModifyRequestHeader")
		}
		destination.ModifyRequestHeader = &modifyRequestHeader
	} else {
		destination.ModifyRequestHeader = nil
	}

	// ModifyResponseHeader
	if action.ModifyResponseHeader != nil {
		var modifyResponseHeader storage.DeliveryRuleResponseHeaderAction_STATUS
		err := action.ModifyResponseHeader.AssignProperties_To_DeliveryRuleResponseHeaderAction_STATUS(&modifyResponseHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleResponseHeaderAction_STATUS() to populate field ModifyResponseHeader")
		}
		destination.ModifyResponseHeader = &modifyResponseHeader
	} else {
		destination.ModifyResponseHeader = nil
	}

	// OriginGroupOverride
	if action.OriginGroupOverride != nil {
		var originGroupOverride storage.OriginGroupOverrideAction_STATUS
		err := action.OriginGroupOverride.AssignProperties_To_OriginGroupOverrideAction_STATUS(&originGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OriginGroupOverrideAction_STATUS() to populate field OriginGroupOverride")
		}
		destination.OriginGroupOverride = &originGroupOverride
	} else {
		destination.OriginGroupOverride = nil
	}

	// RouteConfigurationOverride
	if action.RouteConfigurationOverride != nil {
		var routeConfigurationOverride storage.DeliveryRuleRouteConfigurationOverrideAction_STATUS
		err := action.RouteConfigurationOverride.AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction_STATUS(&routeConfigurationOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction_STATUS() to populate field RouteConfigurationOverride")
		}
		destination.RouteConfigurationOverride = &routeConfigurationOverride
	} else {
		destination.RouteConfigurationOverride = nil
	}

	// UrlRedirect
	if action.UrlRedirect != nil {
		var urlRedirect storage.UrlRedirectAction_STATUS
		err := action.UrlRedirect.AssignProperties_To_UrlRedirectAction_STATUS(&urlRedirect)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlRedirectAction_STATUS() to populate field UrlRedirect")
		}
		destination.UrlRedirect = &urlRedirect
	} else {
		destination.UrlRedirect = nil
	}

	// UrlRewrite
	if action.UrlRewrite != nil {
		var urlRewrite storage.UrlRewriteAction_STATUS
		err := action.UrlRewrite.AssignProperties_To_UrlRewriteAction_STATUS(&urlRewrite)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlRewriteAction_STATUS() to populate field UrlRewrite")
		}
		destination.UrlRewrite = &urlRewrite
	} else {
		destination.UrlRewrite = nil
	}

	// UrlSigning
	if action.UrlSigning != nil {
		var urlSigning storage.UrlSigningAction_STATUS
		err := action.UrlSigning.AssignProperties_To_UrlSigningAction_STATUS(&urlSigning)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlSigningAction_STATUS() to populate field UrlSigning")
		}
		destination.UrlSigning = &urlSigning
	} else {
		destination.UrlSigning = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleCondition
// A condition for the delivery rule.
type DeliveryRuleCondition struct {
	ClientPort       *DeliveryRuleClientPortCondition       `json:"clientPort,omitempty"`
	Cookies          *DeliveryRuleCookiesCondition          `json:"cookies,omitempty"`
	HostName         *DeliveryRuleHostNameCondition         `json:"hostName,omitempty"`
	HttpVersion      *DeliveryRuleHttpVersionCondition      `json:"httpVersion,omitempty"`
	IsDevice         *DeliveryRuleIsDeviceCondition         `json:"isDevice,omitempty"`
	PostArgs         *DeliveryRulePostArgsCondition         `json:"postArgs,omitempty"`
	PropertyBag      genruntime.PropertyBag                 `json:"$propertyBag,omitempty"`
	QueryString      *DeliveryRuleQueryStringCondition      `json:"queryString,omitempty"`
	RemoteAddress    *DeliveryRuleRemoteAddressCondition    `json:"remoteAddress,omitempty"`
	RequestBody      *DeliveryRuleRequestBodyCondition      `json:"requestBody,omitempty"`
	RequestHeader    *DeliveryRuleRequestHeaderCondition    `json:"requestHeader,omitempty"`
	RequestMethod    *DeliveryRuleRequestMethodCondition    `json:"requestMethod,omitempty"`
	RequestScheme    *DeliveryRuleRequestSchemeCondition    `json:"requestScheme,omitempty"`
	RequestUri       *DeliveryRuleRequestUriCondition       `json:"requestUri,omitempty"`
	ServerPort       *DeliveryRuleServerPortCondition       `json:"serverPort,omitempty"`
	SocketAddr       *DeliveryRuleSocketAddrCondition       `json:"socketAddr,omitempty"`
	SslProtocol      *DeliveryRuleSslProtocolCondition      `json:"sslProtocol,omitempty"`
	UrlFileExtension *DeliveryRuleUrlFileExtensionCondition `json:"urlFileExtension,omitempty"`
	UrlFileName      *DeliveryRuleUrlFileNameCondition      `json:"urlFileName,omitempty"`
	UrlPath          *DeliveryRuleUrlPathCondition          `json:"urlPath,omitempty"`
}

// AssignProperties_From_DeliveryRuleCondition populates our DeliveryRuleCondition from the provided source DeliveryRuleCondition
func (condition *DeliveryRuleCondition) AssignProperties_From_DeliveryRuleCondition(source *storage.DeliveryRuleCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ClientPort
	if source.ClientPort != nil {
		var clientPort DeliveryRuleClientPortCondition
		err := clientPort.AssignProperties_From_DeliveryRuleClientPortCondition(source.ClientPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleClientPortCondition() to populate field ClientPort")
		}
		condition.ClientPort = &clientPort
	} else {
		condition.ClientPort = nil
	}

	// Cookies
	if source.Cookies != nil {
		var cookie DeliveryRuleCookiesCondition
		err := cookie.AssignProperties_From_DeliveryRuleCookiesCondition(source.Cookies)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleCookiesCondition() to populate field Cookies")
		}
		condition.Cookies = &cookie
	} else {
		condition.Cookies = nil
	}

	// HostName
	if source.HostName != nil {
		var hostName DeliveryRuleHostNameCondition
		err := hostName.AssignProperties_From_DeliveryRuleHostNameCondition(source.HostName)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleHostNameCondition() to populate field HostName")
		}
		condition.HostName = &hostName
	} else {
		condition.HostName = nil
	}

	// HttpVersion
	if source.HttpVersion != nil {
		var httpVersion DeliveryRuleHttpVersionCondition
		err := httpVersion.AssignProperties_From_DeliveryRuleHttpVersionCondition(source.HttpVersion)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleHttpVersionCondition() to populate field HttpVersion")
		}
		condition.HttpVersion = &httpVersion
	} else {
		condition.HttpVersion = nil
	}

	// IsDevice
	if source.IsDevice != nil {
		var isDevice DeliveryRuleIsDeviceCondition
		err := isDevice.AssignProperties_From_DeliveryRuleIsDeviceCondition(source.IsDevice)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleIsDeviceCondition() to populate field IsDevice")
		}
		condition.IsDevice = &isDevice
	} else {
		condition.IsDevice = nil
	}

	// PostArgs
	if source.PostArgs != nil {
		var postArg DeliveryRulePostArgsCondition
		err := postArg.AssignProperties_From_DeliveryRulePostArgsCondition(source.PostArgs)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRulePostArgsCondition() to populate field PostArgs")
		}
		condition.PostArgs = &postArg
	} else {
		condition.PostArgs = nil
	}

	// QueryString
	if source.QueryString != nil {
		var queryString DeliveryRuleQueryStringCondition
		err := queryString.AssignProperties_From_DeliveryRuleQueryStringCondition(source.QueryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleQueryStringCondition() to populate field QueryString")
		}
		condition.QueryString = &queryString
	} else {
		condition.QueryString = nil
	}

	// RemoteAddress
	if source.RemoteAddress != nil {
		var remoteAddress DeliveryRuleRemoteAddressCondition
		err := remoteAddress.AssignProperties_From_DeliveryRuleRemoteAddressCondition(source.RemoteAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRemoteAddressCondition() to populate field RemoteAddress")
		}
		condition.RemoteAddress = &remoteAddress
	} else {
		condition.RemoteAddress = nil
	}

	// RequestBody
	if source.RequestBody != nil {
		var requestBody DeliveryRuleRequestBodyCondition
		err := requestBody.AssignProperties_From_DeliveryRuleRequestBodyCondition(source.RequestBody)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestBodyCondition() to populate field RequestBody")
		}
		condition.RequestBody = &requestBody
	} else {
		condition.RequestBody = nil
	}

	// RequestHeader
	if source.RequestHeader != nil {
		var requestHeader DeliveryRuleRequestHeaderCondition
		err := requestHeader.AssignProperties_From_DeliveryRuleRequestHeaderCondition(source.RequestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestHeaderCondition() to populate field RequestHeader")
		}
		condition.RequestHeader = &requestHeader
	} else {
		condition.RequestHeader = nil
	}

	// RequestMethod
	if source.RequestMethod != nil {
		var requestMethod DeliveryRuleRequestMethodCondition
		err := requestMethod.AssignProperties_From_DeliveryRuleRequestMethodCondition(source.RequestMethod)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestMethodCondition() to populate field RequestMethod")
		}
		condition.RequestMethod = &requestMethod
	} else {
		condition.RequestMethod = nil
	}

	// RequestScheme
	if source.RequestScheme != nil {
		var requestScheme DeliveryRuleRequestSchemeCondition
		err := requestScheme.AssignProperties_From_DeliveryRuleRequestSchemeCondition(source.RequestScheme)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestSchemeCondition() to populate field RequestScheme")
		}
		condition.RequestScheme = &requestScheme
	} else {
		condition.RequestScheme = nil
	}

	// RequestUri
	if source.RequestUri != nil {
		var requestUri DeliveryRuleRequestUriCondition
		err := requestUri.AssignProperties_From_DeliveryRuleRequestUriCondition(source.RequestUri)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestUriCondition() to populate field RequestUri")
		}
		condition.RequestUri = &requestUri
	} else {
		condition.RequestUri = nil
	}

	// ServerPort
	if source.ServerPort != nil {
		var serverPort DeliveryRuleServerPortCondition
		err := serverPort.AssignProperties_From_DeliveryRuleServerPortCondition(source.ServerPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleServerPortCondition() to populate field ServerPort")
		}
		condition.ServerPort = &serverPort
	} else {
		condition.ServerPort = nil
	}

	// SocketAddr
	if source.SocketAddr != nil {
		var socketAddr DeliveryRuleSocketAddrCondition
		err := socketAddr.AssignProperties_From_DeliveryRuleSocketAddrCondition(source.SocketAddr)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleSocketAddrCondition() to populate field SocketAddr")
		}
		condition.SocketAddr = &socketAddr
	} else {
		condition.SocketAddr = nil
	}

	// SslProtocol
	if source.SslProtocol != nil {
		var sslProtocol DeliveryRuleSslProtocolCondition
		err := sslProtocol.AssignProperties_From_DeliveryRuleSslProtocolCondition(source.SslProtocol)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleSslProtocolCondition() to populate field SslProtocol")
		}
		condition.SslProtocol = &sslProtocol
	} else {
		condition.SslProtocol = nil
	}

	// UrlFileExtension
	if source.UrlFileExtension != nil {
		var urlFileExtension DeliveryRuleUrlFileExtensionCondition
		err := urlFileExtension.AssignProperties_From_DeliveryRuleUrlFileExtensionCondition(source.UrlFileExtension)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleUrlFileExtensionCondition() to populate field UrlFileExtension")
		}
		condition.UrlFileExtension = &urlFileExtension
	} else {
		condition.UrlFileExtension = nil
	}

	// UrlFileName
	if source.UrlFileName != nil {
		var urlFileName DeliveryRuleUrlFileNameCondition
		err := urlFileName.AssignProperties_From_DeliveryRuleUrlFileNameCondition(source.UrlFileName)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleUrlFileNameCondition() to populate field UrlFileName")
		}
		condition.UrlFileName = &urlFileName
	} else {
		condition.UrlFileName = nil
	}

	// UrlPath
	if source.UrlPath != nil {
		var urlPath DeliveryRuleUrlPathCondition
		err := urlPath.AssignProperties_From_DeliveryRuleUrlPathCondition(source.UrlPath)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleUrlPathCondition() to populate field UrlPath")
		}
		condition.UrlPath = &urlPath
	} else {
		condition.UrlPath = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleCondition populates the provided destination DeliveryRuleCondition from our DeliveryRuleCondition
func (condition *DeliveryRuleCondition) AssignProperties_To_DeliveryRuleCondition(destination *storage.DeliveryRuleCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// ClientPort
	if condition.ClientPort != nil {
		var clientPort storage.DeliveryRuleClientPortCondition
		err := condition.ClientPort.AssignProperties_To_DeliveryRuleClientPortCondition(&clientPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleClientPortCondition() to populate field ClientPort")
		}
		destination.ClientPort = &clientPort
	} else {
		destination.ClientPort = nil
	}

	// Cookies
	if condition.Cookies != nil {
		var cookie storage.DeliveryRuleCookiesCondition
		err := condition.Cookies.AssignProperties_To_DeliveryRuleCookiesCondition(&cookie)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleCookiesCondition() to populate field Cookies")
		}
		destination.Cookies = &cookie
	} else {
		destination.Cookies = nil
	}

	// HostName
	if condition.HostName != nil {
		var hostName storage.DeliveryRuleHostNameCondition
		err := condition.HostName.AssignProperties_To_DeliveryRuleHostNameCondition(&hostName)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleHostNameCondition() to populate field HostName")
		}
		destination.HostName = &hostName
	} else {
		destination.HostName = nil
	}

	// HttpVersion
	if condition.HttpVersion != nil {
		var httpVersion storage.DeliveryRuleHttpVersionCondition
		err := condition.HttpVersion.AssignProperties_To_DeliveryRuleHttpVersionCondition(&httpVersion)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleHttpVersionCondition() to populate field HttpVersion")
		}
		destination.HttpVersion = &httpVersion
	} else {
		destination.HttpVersion = nil
	}

	// IsDevice
	if condition.IsDevice != nil {
		var isDevice storage.DeliveryRuleIsDeviceCondition
		err := condition.IsDevice.AssignProperties_To_DeliveryRuleIsDeviceCondition(&isDevice)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleIsDeviceCondition() to populate field IsDevice")
		}
		destination.IsDevice = &isDevice
	} else {
		destination.IsDevice = nil
	}

	// PostArgs
	if condition.PostArgs != nil {
		var postArg storage.DeliveryRulePostArgsCondition
		err := condition.PostArgs.AssignProperties_To_DeliveryRulePostArgsCondition(&postArg)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRulePostArgsCondition() to populate field PostArgs")
		}
		destination.PostArgs = &postArg
	} else {
		destination.PostArgs = nil
	}

	// QueryString
	if condition.QueryString != nil {
		var queryString storage.DeliveryRuleQueryStringCondition
		err := condition.QueryString.AssignProperties_To_DeliveryRuleQueryStringCondition(&queryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleQueryStringCondition() to populate field QueryString")
		}
		destination.QueryString = &queryString
	} else {
		destination.QueryString = nil
	}

	// RemoteAddress
	if condition.RemoteAddress != nil {
		var remoteAddress storage.DeliveryRuleRemoteAddressCondition
		err := condition.RemoteAddress.AssignProperties_To_DeliveryRuleRemoteAddressCondition(&remoteAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRemoteAddressCondition() to populate field RemoteAddress")
		}
		destination.RemoteAddress = &remoteAddress
	} else {
		destination.RemoteAddress = nil
	}

	// RequestBody
	if condition.RequestBody != nil {
		var requestBody storage.DeliveryRuleRequestBodyCondition
		err := condition.RequestBody.AssignProperties_To_DeliveryRuleRequestBodyCondition(&requestBody)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestBodyCondition() to populate field RequestBody")
		}
		destination.RequestBody = &requestBody
	} else {
		destination.RequestBody = nil
	}

	// RequestHeader
	if condition.RequestHeader != nil {
		var requestHeader storage.DeliveryRuleRequestHeaderCondition
		err := condition.RequestHeader.AssignProperties_To_DeliveryRuleRequestHeaderCondition(&requestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestHeaderCondition() to populate field RequestHeader")
		}
		destination.RequestHeader = &requestHeader
	} else {
		destination.RequestHeader = nil
	}

	// RequestMethod
	if condition.RequestMethod != nil {
		var requestMethod storage.DeliveryRuleRequestMethodCondition
		err := condition.RequestMethod.AssignProperties_To_DeliveryRuleRequestMethodCondition(&requestMethod)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestMethodCondition() to populate field RequestMethod")
		}
		destination.RequestMethod = &requestMethod
	} else {
		destination.RequestMethod = nil
	}

	// RequestScheme
	if condition.RequestScheme != nil {
		var requestScheme storage.DeliveryRuleRequestSchemeCondition
		err := condition.RequestScheme.AssignProperties_To_DeliveryRuleRequestSchemeCondition(&requestScheme)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestSchemeCondition() to populate field RequestScheme")
		}
		destination.RequestScheme = &requestScheme
	} else {
		destination.RequestScheme = nil
	}

	// RequestUri
	if condition.RequestUri != nil {
		var requestUri storage.DeliveryRuleRequestUriCondition
		err := condition.RequestUri.AssignProperties_To_DeliveryRuleRequestUriCondition(&requestUri)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestUriCondition() to populate field RequestUri")
		}
		destination.RequestUri = &requestUri
	} else {
		destination.RequestUri = nil
	}

	// ServerPort
	if condition.ServerPort != nil {
		var serverPort storage.DeliveryRuleServerPortCondition
		err := condition.ServerPort.AssignProperties_To_DeliveryRuleServerPortCondition(&serverPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleServerPortCondition() to populate field ServerPort")
		}
		destination.ServerPort = &serverPort
	} else {
		destination.ServerPort = nil
	}

	// SocketAddr
	if condition.SocketAddr != nil {
		var socketAddr storage.DeliveryRuleSocketAddrCondition
		err := condition.SocketAddr.AssignProperties_To_DeliveryRuleSocketAddrCondition(&socketAddr)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleSocketAddrCondition() to populate field SocketAddr")
		}
		destination.SocketAddr = &socketAddr
	} else {
		destination.SocketAddr = nil
	}

	// SslProtocol
	if condition.SslProtocol != nil {
		var sslProtocol storage.DeliveryRuleSslProtocolCondition
		err := condition.SslProtocol.AssignProperties_To_DeliveryRuleSslProtocolCondition(&sslProtocol)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleSslProtocolCondition() to populate field SslProtocol")
		}
		destination.SslProtocol = &sslProtocol
	} else {
		destination.SslProtocol = nil
	}

	// UrlFileExtension
	if condition.UrlFileExtension != nil {
		var urlFileExtension storage.DeliveryRuleUrlFileExtensionCondition
		err := condition.UrlFileExtension.AssignProperties_To_DeliveryRuleUrlFileExtensionCondition(&urlFileExtension)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleUrlFileExtensionCondition() to populate field UrlFileExtension")
		}
		destination.UrlFileExtension = &urlFileExtension
	} else {
		destination.UrlFileExtension = nil
	}

	// UrlFileName
	if condition.UrlFileName != nil {
		var urlFileName storage.DeliveryRuleUrlFileNameCondition
		err := condition.UrlFileName.AssignProperties_To_DeliveryRuleUrlFileNameCondition(&urlFileName)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleUrlFileNameCondition() to populate field UrlFileName")
		}
		destination.UrlFileName = &urlFileName
	} else {
		destination.UrlFileName = nil
	}

	// UrlPath
	if condition.UrlPath != nil {
		var urlPath storage.DeliveryRuleUrlPathCondition
		err := condition.UrlPath.AssignProperties_To_DeliveryRuleUrlPathCondition(&urlPath)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleUrlPathCondition() to populate field UrlPath")
		}
		destination.UrlPath = &urlPath
	} else {
		destination.UrlPath = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleCondition_STATUS
// A condition for the delivery rule.
type DeliveryRuleCondition_STATUS struct {
	ClientPort       *DeliveryRuleClientPortCondition_STATUS       `json:"clientPort,omitempty"`
	Cookies          *DeliveryRuleCookiesCondition_STATUS          `json:"cookies,omitempty"`
	HostName         *DeliveryRuleHostNameCondition_STATUS         `json:"hostName,omitempty"`
	HttpVersion      *DeliveryRuleHttpVersionCondition_STATUS      `json:"httpVersion,omitempty"`
	IsDevice         *DeliveryRuleIsDeviceCondition_STATUS         `json:"isDevice,omitempty"`
	PostArgs         *DeliveryRulePostArgsCondition_STATUS         `json:"postArgs,omitempty"`
	PropertyBag      genruntime.PropertyBag                        `json:"$propertyBag,omitempty"`
	QueryString      *DeliveryRuleQueryStringCondition_STATUS      `json:"queryString,omitempty"`
	RemoteAddress    *DeliveryRuleRemoteAddressCondition_STATUS    `json:"remoteAddress,omitempty"`
	RequestBody      *DeliveryRuleRequestBodyCondition_STATUS      `json:"requestBody,omitempty"`
	RequestHeader    *DeliveryRuleRequestHeaderCondition_STATUS    `json:"requestHeader,omitempty"`
	RequestMethod    *DeliveryRuleRequestMethodCondition_STATUS    `json:"requestMethod,omitempty"`
	RequestScheme    *DeliveryRuleRequestSchemeCondition_STATUS    `json:"requestScheme,omitempty"`
	RequestUri       *DeliveryRuleRequestUriCondition_STATUS       `json:"requestUri,omitempty"`
	ServerPort       *DeliveryRuleServerPortCondition_STATUS       `json:"serverPort,omitempty"`
	SocketAddr       *DeliveryRuleSocketAddrCondition_STATUS       `json:"socketAddr,omitempty"`
	SslProtocol      *DeliveryRuleSslProtocolCondition_STATUS      `json:"sslProtocol,omitempty"`
	UrlFileExtension *DeliveryRuleUrlFileExtensionCondition_STATUS `json:"urlFileExtension,omitempty"`
	UrlFileName      *DeliveryRuleUrlFileNameCondition_STATUS      `json:"urlFileName,omitempty"`
	UrlPath          *DeliveryRuleUrlPathCondition_STATUS          `json:"urlPath,omitempty"`
}

// AssignProperties_From_DeliveryRuleCondition_STATUS populates our DeliveryRuleCondition_STATUS from the provided source DeliveryRuleCondition_STATUS
func (condition *DeliveryRuleCondition_STATUS) AssignProperties_From_DeliveryRuleCondition_STATUS(source *storage.DeliveryRuleCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ClientPort
	if source.ClientPort != nil {
		var clientPort DeliveryRuleClientPortCondition_STATUS
		err := clientPort.AssignProperties_From_DeliveryRuleClientPortCondition_STATUS(source.ClientPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleClientPortCondition_STATUS() to populate field ClientPort")
		}
		condition.ClientPort = &clientPort
	} else {
		condition.ClientPort = nil
	}

	// Cookies
	if source.Cookies != nil {
		var cookie DeliveryRuleCookiesCondition_STATUS
		err := cookie.AssignProperties_From_DeliveryRuleCookiesCondition_STATUS(source.Cookies)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleCookiesCondition_STATUS() to populate field Cookies")
		}
		condition.Cookies = &cookie
	} else {
		condition.Cookies = nil
	}

	// HostName
	if source.HostName != nil {
		var hostName DeliveryRuleHostNameCondition_STATUS
		err := hostName.AssignProperties_From_DeliveryRuleHostNameCondition_STATUS(source.HostName)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleHostNameCondition_STATUS() to populate field HostName")
		}
		condition.HostName = &hostName
	} else {
		condition.HostName = nil
	}

	// HttpVersion
	if source.HttpVersion != nil {
		var httpVersion DeliveryRuleHttpVersionCondition_STATUS
		err := httpVersion.AssignProperties_From_DeliveryRuleHttpVersionCondition_STATUS(source.HttpVersion)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleHttpVersionCondition_STATUS() to populate field HttpVersion")
		}
		condition.HttpVersion = &httpVersion
	} else {
		condition.HttpVersion = nil
	}

	// IsDevice
	if source.IsDevice != nil {
		var isDevice DeliveryRuleIsDeviceCondition_STATUS
		err := isDevice.AssignProperties_From_DeliveryRuleIsDeviceCondition_STATUS(source.IsDevice)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleIsDeviceCondition_STATUS() to populate field IsDevice")
		}
		condition.IsDevice = &isDevice
	} else {
		condition.IsDevice = nil
	}

	// PostArgs
	if source.PostArgs != nil {
		var postArg DeliveryRulePostArgsCondition_STATUS
		err := postArg.AssignProperties_From_DeliveryRulePostArgsCondition_STATUS(source.PostArgs)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRulePostArgsCondition_STATUS() to populate field PostArgs")
		}
		condition.PostArgs = &postArg
	} else {
		condition.PostArgs = nil
	}

	// QueryString
	if source.QueryString != nil {
		var queryString DeliveryRuleQueryStringCondition_STATUS
		err := queryString.AssignProperties_From_DeliveryRuleQueryStringCondition_STATUS(source.QueryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleQueryStringCondition_STATUS() to populate field QueryString")
		}
		condition.QueryString = &queryString
	} else {
		condition.QueryString = nil
	}

	// RemoteAddress
	if source.RemoteAddress != nil {
		var remoteAddress DeliveryRuleRemoteAddressCondition_STATUS
		err := remoteAddress.AssignProperties_From_DeliveryRuleRemoteAddressCondition_STATUS(source.RemoteAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRemoteAddressCondition_STATUS() to populate field RemoteAddress")
		}
		condition.RemoteAddress = &remoteAddress
	} else {
		condition.RemoteAddress = nil
	}

	// RequestBody
	if source.RequestBody != nil {
		var requestBody DeliveryRuleRequestBodyCondition_STATUS
		err := requestBody.AssignProperties_From_DeliveryRuleRequestBodyCondition_STATUS(source.RequestBody)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestBodyCondition_STATUS() to populate field RequestBody")
		}
		condition.RequestBody = &requestBody
	} else {
		condition.RequestBody = nil
	}

	// RequestHeader
	if source.RequestHeader != nil {
		var requestHeader DeliveryRuleRequestHeaderCondition_STATUS
		err := requestHeader.AssignProperties_From_DeliveryRuleRequestHeaderCondition_STATUS(source.RequestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestHeaderCondition_STATUS() to populate field RequestHeader")
		}
		condition.RequestHeader = &requestHeader
	} else {
		condition.RequestHeader = nil
	}

	// RequestMethod
	if source.RequestMethod != nil {
		var requestMethod DeliveryRuleRequestMethodCondition_STATUS
		err := requestMethod.AssignProperties_From_DeliveryRuleRequestMethodCondition_STATUS(source.RequestMethod)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestMethodCondition_STATUS() to populate field RequestMethod")
		}
		condition.RequestMethod = &requestMethod
	} else {
		condition.RequestMethod = nil
	}

	// RequestScheme
	if source.RequestScheme != nil {
		var requestScheme DeliveryRuleRequestSchemeCondition_STATUS
		err := requestScheme.AssignProperties_From_DeliveryRuleRequestSchemeCondition_STATUS(source.RequestScheme)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestSchemeCondition_STATUS() to populate field RequestScheme")
		}
		condition.RequestScheme = &requestScheme
	} else {
		condition.RequestScheme = nil
	}

	// RequestUri
	if source.RequestUri != nil {
		var requestUri DeliveryRuleRequestUriCondition_STATUS
		err := requestUri.AssignProperties_From_DeliveryRuleRequestUriCondition_STATUS(source.RequestUri)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestUriCondition_STATUS() to populate field RequestUri")
		}
		condition.RequestUri = &requestUri
	} else {
		condition.RequestUri = nil
	}

	// ServerPort
	if source.ServerPort != nil {
		var serverPort DeliveryRuleServerPortCondition_STATUS
		err := serverPort.AssignProperties_From_DeliveryRuleServerPortCondition_STATUS(source.ServerPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleServerPortCondition_STATUS() to populate field ServerPort")
		}
		condition.ServerPort = &serverPort
	} else {
		condition.ServerPort = nil
	}

	// SocketAddr
	if source.SocketAddr != nil {
		var socketAddr DeliveryRuleSocketAddrCondition_STATUS
		err := socketAddr.AssignProperties_From_DeliveryRuleSocketAddrCondition_STATUS(source.SocketAddr)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleSocketAddrCondition_STATUS() to populate field SocketAddr")
		}
		condition.SocketAddr = &socketAddr
	} else {
		condition.SocketAddr = nil
	}

	// SslProtocol
	if source.SslProtocol != nil {
		var sslProtocol DeliveryRuleSslProtocolCondition_STATUS
		err := sslProtocol.AssignProperties_From_DeliveryRuleSslProtocolCondition_STATUS(source.SslProtocol)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleSslProtocolCondition_STATUS() to populate field SslProtocol")
		}
		condition.SslProtocol = &sslProtocol
	} else {
		condition.SslProtocol = nil
	}

	// UrlFileExtension
	if source.UrlFileExtension != nil {
		var urlFileExtension DeliveryRuleUrlFileExtensionCondition_STATUS
		err := urlFileExtension.AssignProperties_From_DeliveryRuleUrlFileExtensionCondition_STATUS(source.UrlFileExtension)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleUrlFileExtensionCondition_STATUS() to populate field UrlFileExtension")
		}
		condition.UrlFileExtension = &urlFileExtension
	} else {
		condition.UrlFileExtension = nil
	}

	// UrlFileName
	if source.UrlFileName != nil {
		var urlFileName DeliveryRuleUrlFileNameCondition_STATUS
		err := urlFileName.AssignProperties_From_DeliveryRuleUrlFileNameCondition_STATUS(source.UrlFileName)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleUrlFileNameCondition_STATUS() to populate field UrlFileName")
		}
		condition.UrlFileName = &urlFileName
	} else {
		condition.UrlFileName = nil
	}

	// UrlPath
	if source.UrlPath != nil {
		var urlPath DeliveryRuleUrlPathCondition_STATUS
		err := urlPath.AssignProperties_From_DeliveryRuleUrlPathCondition_STATUS(source.UrlPath)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleUrlPathCondition_STATUS() to populate field UrlPath")
		}
		condition.UrlPath = &urlPath
	} else {
		condition.UrlPath = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleCondition_STATUS populates the provided destination DeliveryRuleCondition_STATUS from our DeliveryRuleCondition_STATUS
func (condition *DeliveryRuleCondition_STATUS) AssignProperties_To_DeliveryRuleCondition_STATUS(destination *storage.DeliveryRuleCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// ClientPort
	if condition.ClientPort != nil {
		var clientPort storage.DeliveryRuleClientPortCondition_STATUS
		err := condition.ClientPort.AssignProperties_To_DeliveryRuleClientPortCondition_STATUS(&clientPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleClientPortCondition_STATUS() to populate field ClientPort")
		}
		destination.ClientPort = &clientPort
	} else {
		destination.ClientPort = nil
	}

	// Cookies
	if condition.Cookies != nil {
		var cookie storage.DeliveryRuleCookiesCondition_STATUS
		err := condition.Cookies.AssignProperties_To_DeliveryRuleCookiesCondition_STATUS(&cookie)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleCookiesCondition_STATUS() to populate field Cookies")
		}
		destination.Cookies = &cookie
	} else {
		destination.Cookies = nil
	}

	// HostName
	if condition.HostName != nil {
		var hostName storage.DeliveryRuleHostNameCondition_STATUS
		err := condition.HostName.AssignProperties_To_DeliveryRuleHostNameCondition_STATUS(&hostName)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleHostNameCondition_STATUS() to populate field HostName")
		}
		destination.HostName = &hostName
	} else {
		destination.HostName = nil
	}

	// HttpVersion
	if condition.HttpVersion != nil {
		var httpVersion storage.DeliveryRuleHttpVersionCondition_STATUS
		err := condition.HttpVersion.AssignProperties_To_DeliveryRuleHttpVersionCondition_STATUS(&httpVersion)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleHttpVersionCondition_STATUS() to populate field HttpVersion")
		}
		destination.HttpVersion = &httpVersion
	} else {
		destination.HttpVersion = nil
	}

	// IsDevice
	if condition.IsDevice != nil {
		var isDevice storage.DeliveryRuleIsDeviceCondition_STATUS
		err := condition.IsDevice.AssignProperties_To_DeliveryRuleIsDeviceCondition_STATUS(&isDevice)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleIsDeviceCondition_STATUS() to populate field IsDevice")
		}
		destination.IsDevice = &isDevice
	} else {
		destination.IsDevice = nil
	}

	// PostArgs
	if condition.PostArgs != nil {
		var postArg storage.DeliveryRulePostArgsCondition_STATUS
		err := condition.PostArgs.AssignProperties_To_DeliveryRulePostArgsCondition_STATUS(&postArg)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRulePostArgsCondition_STATUS() to populate field PostArgs")
		}
		destination.PostArgs = &postArg
	} else {
		destination.PostArgs = nil
	}

	// QueryString
	if condition.QueryString != nil {
		var queryString storage.DeliveryRuleQueryStringCondition_STATUS
		err := condition.QueryString.AssignProperties_To_DeliveryRuleQueryStringCondition_STATUS(&queryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleQueryStringCondition_STATUS() to populate field QueryString")
		}
		destination.QueryString = &queryString
	} else {
		destination.QueryString = nil
	}

	// RemoteAddress
	if condition.RemoteAddress != nil {
		var remoteAddress storage.DeliveryRuleRemoteAddressCondition_STATUS
		err := condition.RemoteAddress.AssignProperties_To_DeliveryRuleRemoteAddressCondition_STATUS(&remoteAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRemoteAddressCondition_STATUS() to populate field RemoteAddress")
		}
		destination.RemoteAddress = &remoteAddress
	} else {
		destination.RemoteAddress = nil
	}

	// RequestBody
	if condition.RequestBody != nil {
		var requestBody storage.DeliveryRuleRequestBodyCondition_STATUS
		err := condition.RequestBody.AssignProperties_To_DeliveryRuleRequestBodyCondition_STATUS(&requestBody)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestBodyCondition_STATUS() to populate field RequestBody")
		}
		destination.RequestBody = &requestBody
	} else {
		destination.RequestBody = nil
	}

	// RequestHeader
	if condition.RequestHeader != nil {
		var requestHeader storage.DeliveryRuleRequestHeaderCondition_STATUS
		err := condition.RequestHeader.AssignProperties_To_DeliveryRuleRequestHeaderCondition_STATUS(&requestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestHeaderCondition_STATUS() to populate field RequestHeader")
		}
		destination.RequestHeader = &requestHeader
	} else {
		destination.RequestHeader = nil
	}

	// RequestMethod
	if condition.RequestMethod != nil {
		var requestMethod storage.DeliveryRuleRequestMethodCondition_STATUS
		err := condition.RequestMethod.AssignProperties_To_DeliveryRuleRequestMethodCondition_STATUS(&requestMethod)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestMethodCondition_STATUS() to populate field RequestMethod")
		}
		destination.RequestMethod = &requestMethod
	} else {
		destination.RequestMethod = nil
	}

	// RequestScheme
	if condition.RequestScheme != nil {
		var requestScheme storage.DeliveryRuleRequestSchemeCondition_STATUS
		err := condition.RequestScheme.AssignProperties_To_DeliveryRuleRequestSchemeCondition_STATUS(&requestScheme)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestSchemeCondition_STATUS() to populate field RequestScheme")
		}
		destination.RequestScheme = &requestScheme
	} else {
		destination.RequestScheme = nil
	}

	// RequestUri
	if condition.RequestUri != nil {
		var requestUri storage.DeliveryRuleRequestUriCondition_STATUS
		err := condition.RequestUri.AssignProperties_To_DeliveryRuleRequestUriCondition_STATUS(&requestUri)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestUriCondition_STATUS() to populate field RequestUri")
		}
		destination.RequestUri = &requestUri
	} else {
		destination.RequestUri = nil
	}

	// ServerPort
	if condition.ServerPort != nil {
		var serverPort storage.DeliveryRuleServerPortCondition_STATUS
		err := condition.ServerPort.AssignProperties_To_DeliveryRuleServerPortCondition_STATUS(&serverPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleServerPortCondition_STATUS() to populate field ServerPort")
		}
		destination.ServerPort = &serverPort
	} else {
		destination.ServerPort = nil
	}

	// SocketAddr
	if condition.SocketAddr != nil {
		var socketAddr storage.DeliveryRuleSocketAddrCondition_STATUS
		err := condition.SocketAddr.AssignProperties_To_DeliveryRuleSocketAddrCondition_STATUS(&socketAddr)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleSocketAddrCondition_STATUS() to populate field SocketAddr")
		}
		destination.SocketAddr = &socketAddr
	} else {
		destination.SocketAddr = nil
	}

	// SslProtocol
	if condition.SslProtocol != nil {
		var sslProtocol storage.DeliveryRuleSslProtocolCondition_STATUS
		err := condition.SslProtocol.AssignProperties_To_DeliveryRuleSslProtocolCondition_STATUS(&sslProtocol)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleSslProtocolCondition_STATUS() to populate field SslProtocol")
		}
		destination.SslProtocol = &sslProtocol
	} else {
		destination.SslProtocol = nil
	}

	// UrlFileExtension
	if condition.UrlFileExtension != nil {
		var urlFileExtension storage.DeliveryRuleUrlFileExtensionCondition_STATUS
		err := condition.UrlFileExtension.AssignProperties_To_DeliveryRuleUrlFileExtensionCondition_STATUS(&urlFileExtension)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleUrlFileExtensionCondition_STATUS() to populate field UrlFileExtension")
		}
		destination.UrlFileExtension = &urlFileExtension
	} else {
		destination.UrlFileExtension = nil
	}

	// UrlFileName
	if condition.UrlFileName != nil {
		var urlFileName storage.DeliveryRuleUrlFileNameCondition_STATUS
		err := condition.UrlFileName.AssignProperties_To_DeliveryRuleUrlFileNameCondition_STATUS(&urlFileName)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleUrlFileNameCondition_STATUS() to populate field UrlFileName")
		}
		destination.UrlFileName = &urlFileName
	} else {
		destination.UrlFileName = nil
	}

	// UrlPath
	if condition.UrlPath != nil {
		var urlPath storage.DeliveryRuleUrlPathCondition_STATUS
		err := condition.UrlPath.AssignProperties_To_DeliveryRuleUrlPathCondition_STATUS(&urlPath)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleUrlPathCondition_STATUS() to populate field UrlPath")
		}
		destination.UrlPath = &urlPath
	} else {
		destination.UrlPath = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.HttpErrorRangeParameters
// The JSON object that represents the range for http status codes
type HttpErrorRangeParameters struct {
	Begin       *int                   `json:"begin,omitempty"`
	End         *int                   `json:"end,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// Storage version of v1api20210601.HttpErrorRangeParameters_STATUS
// The JSON object that represents the range for http status codes
type HttpErrorRangeParameters_STATUS struct {
	Begin       *int                   `json:"begin,omitempty"`
	End         *int                   `json:"end,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

type augmentConversionForDeliveryRuleAction interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleAction) error
	AssignPropertiesTo(dst *storage.DeliveryRuleAction) error
}

type augmentConversionForDeliveryRuleAction_STATUS interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleAction_STATUS) error
	AssignPropertiesTo(dst *storage.DeliveryRuleAction_STATUS) error
}

type augmentConversionForDeliveryRuleCondition interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleCondition) error
	AssignPropertiesTo(dst *storage.DeliveryRuleCondition) error
}

type augmentConversionForDeliveryRuleCondition_STATUS interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleCondition_STATUS) error
	AssignPropertiesTo(dst *storage.DeliveryRuleCondition_STATUS) error
}

// Storage version of v1api20210601.DeliveryRuleCacheExpirationAction
type DeliveryRuleCacheExpirationAction struct {
	Name        *string                          `json:"name,omitempty"`
	Parameters  *CacheExpirationActionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag           `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleCacheExpirationAction populates our DeliveryRuleCacheExpirationAction from the provided source DeliveryRuleCacheExpirationAction
func (action *DeliveryRuleCacheExpirationAction) AssignProperties_From_DeliveryRuleCacheExpirationAction(source *storage.DeliveryRuleCacheExpirationAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter CacheExpirationActionParameters
		err := parameter.AssignProperties_From_CacheExpirationActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CacheExpirationActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleCacheExpirationAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleCacheExpirationAction); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleCacheExpirationAction populates the provided destination DeliveryRuleCacheExpirationAction from our DeliveryRuleCacheExpirationAction
func (action *DeliveryRuleCacheExpirationAction) AssignProperties_To_DeliveryRuleCacheExpirationAction(destination *storage.DeliveryRuleCacheExpirationAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter storage.CacheExpirationActionParameters
		err := action.Parameters.AssignProperties_To_CacheExpirationActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CacheExpirationActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleCacheExpirationAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleCacheExpirationAction); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleCacheExpirationAction_STATUS
type DeliveryRuleCacheExpirationAction_STATUS struct {
	Name        *string                                 `json:"name,omitempty"`
	Parameters  *CacheExpirationActionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                  `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleCacheExpirationAction_STATUS populates our DeliveryRuleCacheExpirationAction_STATUS from the provided source DeliveryRuleCacheExpirationAction_STATUS
func (action *DeliveryRuleCacheExpirationAction_STATUS) AssignProperties_From_DeliveryRuleCacheExpirationAction_STATUS(source *storage.DeliveryRuleCacheExpirationAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter CacheExpirationActionParameters_STATUS
		err := parameter.AssignProperties_From_CacheExpirationActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CacheExpirationActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleCacheExpirationAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleCacheExpirationAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleCacheExpirationAction_STATUS populates the provided destination DeliveryRuleCacheExpirationAction_STATUS from our DeliveryRuleCacheExpirationAction_STATUS
func (action *DeliveryRuleCacheExpirationAction_STATUS) AssignProperties_To_DeliveryRuleCacheExpirationAction_STATUS(destination *storage.DeliveryRuleCacheExpirationAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter storage.CacheExpirationActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_CacheExpirationActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CacheExpirationActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleCacheExpirationAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleCacheExpirationAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleCacheKeyQueryStringAction
type DeliveryRuleCacheKeyQueryStringAction struct {
	Name        *string                              `json:"name,omitempty"`
	Parameters  *CacheKeyQueryStringActionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag               `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction populates our DeliveryRuleCacheKeyQueryStringAction from the provided source DeliveryRuleCacheKeyQueryStringAction
func (action *DeliveryRuleCacheKeyQueryStringAction) AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction(source *storage.DeliveryRuleCacheKeyQueryStringAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter CacheKeyQueryStringActionParameters
		err := parameter.AssignProperties_From_CacheKeyQueryStringActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CacheKeyQueryStringActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleCacheKeyQueryStringAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleCacheKeyQueryStringAction); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction populates the provided destination DeliveryRuleCacheKeyQueryStringAction from our DeliveryRuleCacheKeyQueryStringAction
func (action *DeliveryRuleCacheKeyQueryStringAction) AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction(destination *storage.DeliveryRuleCacheKeyQueryStringAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter storage.CacheKeyQueryStringActionParameters
		err := action.Parameters.AssignProperties_To_CacheKeyQueryStringActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CacheKeyQueryStringActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleCacheKeyQueryStringAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleCacheKeyQueryStringAction); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleCacheKeyQueryStringAction_STATUS
type DeliveryRuleCacheKeyQueryStringAction_STATUS struct {
	Name        *string                                     `json:"name,omitempty"`
	Parameters  *CacheKeyQueryStringActionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                      `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction_STATUS populates our DeliveryRuleCacheKeyQueryStringAction_STATUS from the provided source DeliveryRuleCacheKeyQueryStringAction_STATUS
func (action *DeliveryRuleCacheKeyQueryStringAction_STATUS) AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction_STATUS(source *storage.DeliveryRuleCacheKeyQueryStringAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter CacheKeyQueryStringActionParameters_STATUS
		err := parameter.AssignProperties_From_CacheKeyQueryStringActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CacheKeyQueryStringActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleCacheKeyQueryStringAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleCacheKeyQueryStringAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction_STATUS populates the provided destination DeliveryRuleCacheKeyQueryStringAction_STATUS from our DeliveryRuleCacheKeyQueryStringAction_STATUS
func (action *DeliveryRuleCacheKeyQueryStringAction_STATUS) AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction_STATUS(destination *storage.DeliveryRuleCacheKeyQueryStringAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter storage.CacheKeyQueryStringActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_CacheKeyQueryStringActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CacheKeyQueryStringActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleCacheKeyQueryStringAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleCacheKeyQueryStringAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleClientPortCondition
type DeliveryRuleClientPortCondition struct {
	Name        *string                             `json:"name,omitempty"`
	Parameters  *ClientPortMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag              `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleClientPortCondition populates our DeliveryRuleClientPortCondition from the provided source DeliveryRuleClientPortCondition
func (condition *DeliveryRuleClientPortCondition) AssignProperties_From_DeliveryRuleClientPortCondition(source *storage.DeliveryRuleClientPortCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter ClientPortMatchConditionParameters
		err := parameter.AssignProperties_From_ClientPortMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ClientPortMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleClientPortCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleClientPortCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleClientPortCondition populates the provided destination DeliveryRuleClientPortCondition from our DeliveryRuleClientPortCondition
func (condition *DeliveryRuleClientPortCondition) AssignProperties_To_DeliveryRuleClientPortCondition(destination *storage.DeliveryRuleClientPortCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.ClientPortMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_ClientPortMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ClientPortMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleClientPortCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleClientPortCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleClientPortCondition_STATUS
type DeliveryRuleClientPortCondition_STATUS struct {
	Name        *string                                    `json:"name,omitempty"`
	Parameters  *ClientPortMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                     `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleClientPortCondition_STATUS populates our DeliveryRuleClientPortCondition_STATUS from the provided source DeliveryRuleClientPortCondition_STATUS
func (condition *DeliveryRuleClientPortCondition_STATUS) AssignProperties_From_DeliveryRuleClientPortCondition_STATUS(source *storage.DeliveryRuleClientPortCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter ClientPortMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_ClientPortMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ClientPortMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleClientPortCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleClientPortCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleClientPortCondition_STATUS populates the provided destination DeliveryRuleClientPortCondition_STATUS from our DeliveryRuleClientPortCondition_STATUS
func (condition *DeliveryRuleClientPortCondition_STATUS) AssignProperties_To_DeliveryRuleClientPortCondition_STATUS(destination *storage.DeliveryRuleClientPortCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.ClientPortMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_ClientPortMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ClientPortMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleClientPortCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleClientPortCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleCookiesCondition
type DeliveryRuleCookiesCondition struct {
	Name        *string                          `json:"name,omitempty"`
	Parameters  *CookiesMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag           `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleCookiesCondition populates our DeliveryRuleCookiesCondition from the provided source DeliveryRuleCookiesCondition
func (condition *DeliveryRuleCookiesCondition) AssignProperties_From_DeliveryRuleCookiesCondition(source *storage.DeliveryRuleCookiesCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter CookiesMatchConditionParameters
		err := parameter.AssignProperties_From_CookiesMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CookiesMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleCookiesCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleCookiesCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleCookiesCondition populates the provided destination DeliveryRuleCookiesCondition from our DeliveryRuleCookiesCondition
func (condition *DeliveryRuleCookiesCondition) AssignProperties_To_DeliveryRuleCookiesCondition(destination *storage.DeliveryRuleCookiesCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.CookiesMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_CookiesMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CookiesMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleCookiesCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleCookiesCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleCookiesCondition_STATUS
type DeliveryRuleCookiesCondition_STATUS struct {
	Name        *string                                 `json:"name,omitempty"`
	Parameters  *CookiesMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                  `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleCookiesCondition_STATUS populates our DeliveryRuleCookiesCondition_STATUS from the provided source DeliveryRuleCookiesCondition_STATUS
func (condition *DeliveryRuleCookiesCondition_STATUS) AssignProperties_From_DeliveryRuleCookiesCondition_STATUS(source *storage.DeliveryRuleCookiesCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter CookiesMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_CookiesMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CookiesMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleCookiesCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleCookiesCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleCookiesCondition_STATUS populates the provided destination DeliveryRuleCookiesCondition_STATUS from our DeliveryRuleCookiesCondition_STATUS
func (condition *DeliveryRuleCookiesCondition_STATUS) AssignProperties_To_DeliveryRuleCookiesCondition_STATUS(destination *storage.DeliveryRuleCookiesCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.CookiesMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_CookiesMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CookiesMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleCookiesCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleCookiesCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleHostNameCondition
type DeliveryRuleHostNameCondition struct {
	Name        *string                           `json:"name,omitempty"`
	Parameters  *HostNameMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag            `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleHostNameCondition populates our DeliveryRuleHostNameCondition from the provided source DeliveryRuleHostNameCondition
func (condition *DeliveryRuleHostNameCondition) AssignProperties_From_DeliveryRuleHostNameCondition(source *storage.DeliveryRuleHostNameCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter HostNameMatchConditionParameters
		err := parameter.AssignProperties_From_HostNameMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HostNameMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleHostNameCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleHostNameCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleHostNameCondition populates the provided destination DeliveryRuleHostNameCondition from our DeliveryRuleHostNameCondition
func (condition *DeliveryRuleHostNameCondition) AssignProperties_To_DeliveryRuleHostNameCondition(destination *storage.DeliveryRuleHostNameCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.HostNameMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_HostNameMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HostNameMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleHostNameCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleHostNameCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleHostNameCondition_STATUS
type DeliveryRuleHostNameCondition_STATUS struct {
	Name        *string                                  `json:"name,omitempty"`
	Parameters  *HostNameMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                   `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleHostNameCondition_STATUS populates our DeliveryRuleHostNameCondition_STATUS from the provided source DeliveryRuleHostNameCondition_STATUS
func (condition *DeliveryRuleHostNameCondition_STATUS) AssignProperties_From_DeliveryRuleHostNameCondition_STATUS(source *storage.DeliveryRuleHostNameCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter HostNameMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_HostNameMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HostNameMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleHostNameCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleHostNameCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleHostNameCondition_STATUS populates the provided destination DeliveryRuleHostNameCondition_STATUS from our DeliveryRuleHostNameCondition_STATUS
func (condition *DeliveryRuleHostNameCondition_STATUS) AssignProperties_To_DeliveryRuleHostNameCondition_STATUS(destination *storage.DeliveryRuleHostNameCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.HostNameMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_HostNameMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HostNameMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleHostNameCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleHostNameCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleHttpVersionCondition
type DeliveryRuleHttpVersionCondition struct {
	Name        *string                              `json:"name,omitempty"`
	Parameters  *HttpVersionMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag               `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleHttpVersionCondition populates our DeliveryRuleHttpVersionCondition from the provided source DeliveryRuleHttpVersionCondition
func (condition *DeliveryRuleHttpVersionCondition) AssignProperties_From_DeliveryRuleHttpVersionCondition(source *storage.DeliveryRuleHttpVersionCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter HttpVersionMatchConditionParameters
		err := parameter.AssignProperties_From_HttpVersionMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HttpVersionMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleHttpVersionCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleHttpVersionCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleHttpVersionCondition populates the provided destination DeliveryRuleHttpVersionCondition from our DeliveryRuleHttpVersionCondition
func (condition *DeliveryRuleHttpVersionCondition) AssignProperties_To_DeliveryRuleHttpVersionCondition(destination *storage.DeliveryRuleHttpVersionCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.HttpVersionMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_HttpVersionMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HttpVersionMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleHttpVersionCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleHttpVersionCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleHttpVersionCondition_STATUS
type DeliveryRuleHttpVersionCondition_STATUS struct {
	Name        *string                                     `json:"name,omitempty"`
	Parameters  *HttpVersionMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                      `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleHttpVersionCondition_STATUS populates our DeliveryRuleHttpVersionCondition_STATUS from the provided source DeliveryRuleHttpVersionCondition_STATUS
func (condition *DeliveryRuleHttpVersionCondition_STATUS) AssignProperties_From_DeliveryRuleHttpVersionCondition_STATUS(source *storage.DeliveryRuleHttpVersionCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter HttpVersionMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_HttpVersionMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HttpVersionMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleHttpVersionCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleHttpVersionCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleHttpVersionCondition_STATUS populates the provided destination DeliveryRuleHttpVersionCondition_STATUS from our DeliveryRuleHttpVersionCondition_STATUS
func (condition *DeliveryRuleHttpVersionCondition_STATUS) AssignProperties_To_DeliveryRuleHttpVersionCondition_STATUS(destination *storage.DeliveryRuleHttpVersionCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.HttpVersionMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_HttpVersionMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HttpVersionMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleHttpVersionCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleHttpVersionCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleIsDeviceCondition
type DeliveryRuleIsDeviceCondition struct {
	Name        *string                           `json:"name,omitempty"`
	Parameters  *IsDeviceMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag            `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleIsDeviceCondition populates our DeliveryRuleIsDeviceCondition from the provided source DeliveryRuleIsDeviceCondition
func (condition *DeliveryRuleIsDeviceCondition) AssignProperties_From_DeliveryRuleIsDeviceCondition(source *storage.DeliveryRuleIsDeviceCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter IsDeviceMatchConditionParameters
		err := parameter.AssignProperties_From_IsDeviceMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_IsDeviceMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleIsDeviceCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleIsDeviceCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleIsDeviceCondition populates the provided destination DeliveryRuleIsDeviceCondition from our DeliveryRuleIsDeviceCondition
func (condition *DeliveryRuleIsDeviceCondition) AssignProperties_To_DeliveryRuleIsDeviceCondition(destination *storage.DeliveryRuleIsDeviceCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.IsDeviceMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_IsDeviceMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_IsDeviceMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleIsDeviceCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleIsDeviceCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleIsDeviceCondition_STATUS
type DeliveryRuleIsDeviceCondition_STATUS struct {
	Name        *string                                  `json:"name,omitempty"`
	Parameters  *IsDeviceMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                   `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleIsDeviceCondition_STATUS populates our DeliveryRuleIsDeviceCondition_STATUS from the provided source DeliveryRuleIsDeviceCondition_STATUS
func (condition *DeliveryRuleIsDeviceCondition_STATUS) AssignProperties_From_DeliveryRuleIsDeviceCondition_STATUS(source *storage.DeliveryRuleIsDeviceCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter IsDeviceMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_IsDeviceMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_IsDeviceMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleIsDeviceCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleIsDeviceCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleIsDeviceCondition_STATUS populates the provided destination DeliveryRuleIsDeviceCondition_STATUS from our DeliveryRuleIsDeviceCondition_STATUS
func (condition *DeliveryRuleIsDeviceCondition_STATUS) AssignProperties_To_DeliveryRuleIsDeviceCondition_STATUS(destination *storage.DeliveryRuleIsDeviceCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.IsDeviceMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_IsDeviceMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_IsDeviceMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleIsDeviceCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleIsDeviceCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRulePostArgsCondition
type DeliveryRulePostArgsCondition struct {
	Name        *string                           `json:"name,omitempty"`
	Parameters  *PostArgsMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag            `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRulePostArgsCondition populates our DeliveryRulePostArgsCondition from the provided source DeliveryRulePostArgsCondition
func (condition *DeliveryRulePostArgsCondition) AssignProperties_From_DeliveryRulePostArgsCondition(source *storage.DeliveryRulePostArgsCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter PostArgsMatchConditionParameters
		err := parameter.AssignProperties_From_PostArgsMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PostArgsMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRulePostArgsCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRulePostArgsCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRulePostArgsCondition populates the provided destination DeliveryRulePostArgsCondition from our DeliveryRulePostArgsCondition
func (condition *DeliveryRulePostArgsCondition) AssignProperties_To_DeliveryRulePostArgsCondition(destination *storage.DeliveryRulePostArgsCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.PostArgsMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_PostArgsMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PostArgsMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRulePostArgsCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRulePostArgsCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRulePostArgsCondition_STATUS
type DeliveryRulePostArgsCondition_STATUS struct {
	Name        *string                                  `json:"name,omitempty"`
	Parameters  *PostArgsMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                   `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRulePostArgsCondition_STATUS populates our DeliveryRulePostArgsCondition_STATUS from the provided source DeliveryRulePostArgsCondition_STATUS
func (condition *DeliveryRulePostArgsCondition_STATUS) AssignProperties_From_DeliveryRulePostArgsCondition_STATUS(source *storage.DeliveryRulePostArgsCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter PostArgsMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_PostArgsMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PostArgsMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRulePostArgsCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRulePostArgsCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRulePostArgsCondition_STATUS populates the provided destination DeliveryRulePostArgsCondition_STATUS from our DeliveryRulePostArgsCondition_STATUS
func (condition *DeliveryRulePostArgsCondition_STATUS) AssignProperties_To_DeliveryRulePostArgsCondition_STATUS(destination *storage.DeliveryRulePostArgsCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.PostArgsMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_PostArgsMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PostArgsMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRulePostArgsCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRulePostArgsCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleQueryStringCondition
type DeliveryRuleQueryStringCondition struct {
	Name        *string                              `json:"name,omitempty"`
	Parameters  *QueryStringMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag               `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleQueryStringCondition populates our DeliveryRuleQueryStringCondition from the provided source DeliveryRuleQueryStringCondition
func (condition *DeliveryRuleQueryStringCondition) AssignProperties_From_DeliveryRuleQueryStringCondition(source *storage.DeliveryRuleQueryStringCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter QueryStringMatchConditionParameters
		err := parameter.AssignProperties_From_QueryStringMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_QueryStringMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleQueryStringCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleQueryStringCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleQueryStringCondition populates the provided destination DeliveryRuleQueryStringCondition from our DeliveryRuleQueryStringCondition
func (condition *DeliveryRuleQueryStringCondition) AssignProperties_To_DeliveryRuleQueryStringCondition(destination *storage.DeliveryRuleQueryStringCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.QueryStringMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_QueryStringMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_QueryStringMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleQueryStringCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleQueryStringCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleQueryStringCondition_STATUS
type DeliveryRuleQueryStringCondition_STATUS struct {
	Name        *string                                     `json:"name,omitempty"`
	Parameters  *QueryStringMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                      `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleQueryStringCondition_STATUS populates our DeliveryRuleQueryStringCondition_STATUS from the provided source DeliveryRuleQueryStringCondition_STATUS
func (condition *DeliveryRuleQueryStringCondition_STATUS) AssignProperties_From_DeliveryRuleQueryStringCondition_STATUS(source *storage.DeliveryRuleQueryStringCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter QueryStringMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_QueryStringMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_QueryStringMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleQueryStringCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleQueryStringCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleQueryStringCondition_STATUS populates the provided destination DeliveryRuleQueryStringCondition_STATUS from our DeliveryRuleQueryStringCondition_STATUS
func (condition *DeliveryRuleQueryStringCondition_STATUS) AssignProperties_To_DeliveryRuleQueryStringCondition_STATUS(destination *storage.DeliveryRuleQueryStringCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.QueryStringMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_QueryStringMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_QueryStringMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleQueryStringCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleQueryStringCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleRemoteAddressCondition
type DeliveryRuleRemoteAddressCondition struct {
	Name        *string                                `json:"name,omitempty"`
	Parameters  *RemoteAddressMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                 `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleRemoteAddressCondition populates our DeliveryRuleRemoteAddressCondition from the provided source DeliveryRuleRemoteAddressCondition
func (condition *DeliveryRuleRemoteAddressCondition) AssignProperties_From_DeliveryRuleRemoteAddressCondition(source *storage.DeliveryRuleRemoteAddressCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter RemoteAddressMatchConditionParameters
		err := parameter.AssignProperties_From_RemoteAddressMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RemoteAddressMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRemoteAddressCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRemoteAddressCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRemoteAddressCondition populates the provided destination DeliveryRuleRemoteAddressCondition from our DeliveryRuleRemoteAddressCondition
func (condition *DeliveryRuleRemoteAddressCondition) AssignProperties_To_DeliveryRuleRemoteAddressCondition(destination *storage.DeliveryRuleRemoteAddressCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.RemoteAddressMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_RemoteAddressMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RemoteAddressMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRemoteAddressCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRemoteAddressCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleRemoteAddressCondition_STATUS
type DeliveryRuleRemoteAddressCondition_STATUS struct {
	Name        *string                                       `json:"name,omitempty"`
	Parameters  *RemoteAddressMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                        `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleRemoteAddressCondition_STATUS populates our DeliveryRuleRemoteAddressCondition_STATUS from the provided source DeliveryRuleRemoteAddressCondition_STATUS
func (condition *DeliveryRuleRemoteAddressCondition_STATUS) AssignProperties_From_DeliveryRuleRemoteAddressCondition_STATUS(source *storage.DeliveryRuleRemoteAddressCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter RemoteAddressMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_RemoteAddressMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RemoteAddressMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRemoteAddressCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRemoteAddressCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRemoteAddressCondition_STATUS populates the provided destination DeliveryRuleRemoteAddressCondition_STATUS from our DeliveryRuleRemoteAddressCondition_STATUS
func (condition *DeliveryRuleRemoteAddressCondition_STATUS) AssignProperties_To_DeliveryRuleRemoteAddressCondition_STATUS(destination *storage.DeliveryRuleRemoteAddressCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.RemoteAddressMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_RemoteAddressMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RemoteAddressMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRemoteAddressCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRemoteAddressCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleRequestBodyCondition
type DeliveryRuleRequestBodyCondition struct {
	Name        *string                              `json:"name,omitempty"`
	Parameters  *RequestBodyMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag               `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleRequestBodyCondition populates our DeliveryRuleRequestBodyCondition from the provided source DeliveryRuleRequestBodyCondition
func (condition *DeliveryRuleRequestBodyCondition) AssignProperties_From_DeliveryRuleRequestBodyCondition(source *storage.DeliveryRuleRequestBodyCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter RequestBodyMatchConditionParameters
		err := parameter.AssignProperties_From_RequestBodyMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestBodyMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestBodyCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestBodyCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestBodyCondition populates the provided destination DeliveryRuleRequestBodyCondition from our DeliveryRuleRequestBodyCondition
func (condition *DeliveryRuleRequestBodyCondition) AssignProperties_To_DeliveryRuleRequestBodyCondition(destination *storage.DeliveryRuleRequestBodyCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.RequestBodyMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_RequestBodyMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestBodyMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestBodyCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestBodyCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleRequestBodyCondition_STATUS
type DeliveryRuleRequestBodyCondition_STATUS struct {
	Name        *string                                     `json:"name,omitempty"`
	Parameters  *RequestBodyMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                      `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleRequestBodyCondition_STATUS populates our DeliveryRuleRequestBodyCondition_STATUS from the provided source DeliveryRuleRequestBodyCondition_STATUS
func (condition *DeliveryRuleRequestBodyCondition_STATUS) AssignProperties_From_DeliveryRuleRequestBodyCondition_STATUS(source *storage.DeliveryRuleRequestBodyCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter RequestBodyMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_RequestBodyMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestBodyMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestBodyCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestBodyCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestBodyCondition_STATUS populates the provided destination DeliveryRuleRequestBodyCondition_STATUS from our DeliveryRuleRequestBodyCondition_STATUS
func (condition *DeliveryRuleRequestBodyCondition_STATUS) AssignProperties_To_DeliveryRuleRequestBodyCondition_STATUS(destination *storage.DeliveryRuleRequestBodyCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.RequestBodyMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_RequestBodyMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestBodyMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestBodyCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestBodyCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleRequestHeaderAction
type DeliveryRuleRequestHeaderAction struct {
	Name        *string                 `json:"name,omitempty"`
	Parameters  *HeaderActionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag  `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleRequestHeaderAction populates our DeliveryRuleRequestHeaderAction from the provided source DeliveryRuleRequestHeaderAction
func (action *DeliveryRuleRequestHeaderAction) AssignProperties_From_DeliveryRuleRequestHeaderAction(source *storage.DeliveryRuleRequestHeaderAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter HeaderActionParameters
		err := parameter.AssignProperties_From_HeaderActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HeaderActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestHeaderAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleRequestHeaderAction); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestHeaderAction populates the provided destination DeliveryRuleRequestHeaderAction from our DeliveryRuleRequestHeaderAction
func (action *DeliveryRuleRequestHeaderAction) AssignProperties_To_DeliveryRuleRequestHeaderAction(destination *storage.DeliveryRuleRequestHeaderAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter storage.HeaderActionParameters
		err := action.Parameters.AssignProperties_To_HeaderActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HeaderActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestHeaderAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleRequestHeaderAction); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleRequestHeaderAction_STATUS
type DeliveryRuleRequestHeaderAction_STATUS struct {
	Name        *string                        `json:"name,omitempty"`
	Parameters  *HeaderActionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag         `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleRequestHeaderAction_STATUS populates our DeliveryRuleRequestHeaderAction_STATUS from the provided source DeliveryRuleRequestHeaderAction_STATUS
func (action *DeliveryRuleRequestHeaderAction_STATUS) AssignProperties_From_DeliveryRuleRequestHeaderAction_STATUS(source *storage.DeliveryRuleRequestHeaderAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter HeaderActionParameters_STATUS
		err := parameter.AssignProperties_From_HeaderActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HeaderActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestHeaderAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleRequestHeaderAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestHeaderAction_STATUS populates the provided destination DeliveryRuleRequestHeaderAction_STATUS from our DeliveryRuleRequestHeaderAction_STATUS
func (action *DeliveryRuleRequestHeaderAction_STATUS) AssignProperties_To_DeliveryRuleRequestHeaderAction_STATUS(destination *storage.DeliveryRuleRequestHeaderAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter storage.HeaderActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_HeaderActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HeaderActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestHeaderAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleRequestHeaderAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleRequestHeaderCondition
type DeliveryRuleRequestHeaderCondition struct {
	Name        *string                                `json:"name,omitempty"`
	Parameters  *RequestHeaderMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                 `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleRequestHeaderCondition populates our DeliveryRuleRequestHeaderCondition from the provided source DeliveryRuleRequestHeaderCondition
func (condition *DeliveryRuleRequestHeaderCondition) AssignProperties_From_DeliveryRuleRequestHeaderCondition(source *storage.DeliveryRuleRequestHeaderCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter RequestHeaderMatchConditionParameters
		err := parameter.AssignProperties_From_RequestHeaderMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestHeaderMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestHeaderCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestHeaderCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestHeaderCondition populates the provided destination DeliveryRuleRequestHeaderCondition from our DeliveryRuleRequestHeaderCondition
func (condition *DeliveryRuleRequestHeaderCondition) AssignProperties_To_DeliveryRuleRequestHeaderCondition(destination *storage.DeliveryRuleRequestHeaderCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.RequestHeaderMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_RequestHeaderMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestHeaderMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestHeaderCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestHeaderCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleRequestHeaderCondition_STATUS
type DeliveryRuleRequestHeaderCondition_STATUS struct {
	Name        *string                                       `json:"name,omitempty"`
	Parameters  *RequestHeaderMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                        `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleRequestHeaderCondition_STATUS populates our DeliveryRuleRequestHeaderCondition_STATUS from the provided source DeliveryRuleRequestHeaderCondition_STATUS
func (condition *DeliveryRuleRequestHeaderCondition_STATUS) AssignProperties_From_DeliveryRuleRequestHeaderCondition_STATUS(source *storage.DeliveryRuleRequestHeaderCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter RequestHeaderMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_RequestHeaderMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestHeaderMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestHeaderCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestHeaderCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestHeaderCondition_STATUS populates the provided destination DeliveryRuleRequestHeaderCondition_STATUS from our DeliveryRuleRequestHeaderCondition_STATUS
func (condition *DeliveryRuleRequestHeaderCondition_STATUS) AssignProperties_To_DeliveryRuleRequestHeaderCondition_STATUS(destination *storage.DeliveryRuleRequestHeaderCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.RequestHeaderMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_RequestHeaderMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestHeaderMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestHeaderCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestHeaderCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleRequestMethodCondition
type DeliveryRuleRequestMethodCondition struct {
	Name        *string                                `json:"name,omitempty"`
	Parameters  *RequestMethodMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                 `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleRequestMethodCondition populates our DeliveryRuleRequestMethodCondition from the provided source DeliveryRuleRequestMethodCondition
func (condition *DeliveryRuleRequestMethodCondition) AssignProperties_From_DeliveryRuleRequestMethodCondition(source *storage.DeliveryRuleRequestMethodCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter RequestMethodMatchConditionParameters
		err := parameter.AssignProperties_From_RequestMethodMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestMethodMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestMethodCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestMethodCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestMethodCondition populates the provided destination DeliveryRuleRequestMethodCondition from our DeliveryRuleRequestMethodCondition
func (condition *DeliveryRuleRequestMethodCondition) AssignProperties_To_DeliveryRuleRequestMethodCondition(destination *storage.DeliveryRuleRequestMethodCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.RequestMethodMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_RequestMethodMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestMethodMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestMethodCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestMethodCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleRequestMethodCondition_STATUS
type DeliveryRuleRequestMethodCondition_STATUS struct {
	Name        *string                                       `json:"name,omitempty"`
	Parameters  *RequestMethodMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                        `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleRequestMethodCondition_STATUS populates our DeliveryRuleRequestMethodCondition_STATUS from the provided source DeliveryRuleRequestMethodCondition_STATUS
func (condition *DeliveryRuleRequestMethodCondition_STATUS) AssignProperties_From_DeliveryRuleRequestMethodCondition_STATUS(source *storage.DeliveryRuleRequestMethodCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter RequestMethodMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_RequestMethodMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestMethodMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestMethodCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestMethodCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestMethodCondition_STATUS populates the provided destination DeliveryRuleRequestMethodCondition_STATUS from our DeliveryRuleRequestMethodCondition_STATUS
func (condition *DeliveryRuleRequestMethodCondition_STATUS) AssignProperties_To_DeliveryRuleRequestMethodCondition_STATUS(destination *storage.DeliveryRuleRequestMethodCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.RequestMethodMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_RequestMethodMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestMethodMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestMethodCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestMethodCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleRequestSchemeCondition
type DeliveryRuleRequestSchemeCondition struct {
	Name        *string                                `json:"name,omitempty"`
	Parameters  *RequestSchemeMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                 `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleRequestSchemeCondition populates our DeliveryRuleRequestSchemeCondition from the provided source DeliveryRuleRequestSchemeCondition
func (condition *DeliveryRuleRequestSchemeCondition) AssignProperties_From_DeliveryRuleRequestSchemeCondition(source *storage.DeliveryRuleRequestSchemeCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter RequestSchemeMatchConditionParameters
		err := parameter.AssignProperties_From_RequestSchemeMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestSchemeMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestSchemeCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestSchemeCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestSchemeCondition populates the provided destination DeliveryRuleRequestSchemeCondition from our DeliveryRuleRequestSchemeCondition
func (condition *DeliveryRuleRequestSchemeCondition) AssignProperties_To_DeliveryRuleRequestSchemeCondition(destination *storage.DeliveryRuleRequestSchemeCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.RequestSchemeMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_RequestSchemeMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestSchemeMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestSchemeCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestSchemeCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleRequestSchemeCondition_STATUS
type DeliveryRuleRequestSchemeCondition_STATUS struct {
	Name        *string                                       `json:"name,omitempty"`
	Parameters  *RequestSchemeMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                        `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleRequestSchemeCondition_STATUS populates our DeliveryRuleRequestSchemeCondition_STATUS from the provided source DeliveryRuleRequestSchemeCondition_STATUS
func (condition *DeliveryRuleRequestSchemeCondition_STATUS) AssignProperties_From_DeliveryRuleRequestSchemeCondition_STATUS(source *storage.DeliveryRuleRequestSchemeCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter RequestSchemeMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_RequestSchemeMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestSchemeMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestSchemeCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestSchemeCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestSchemeCondition_STATUS populates the provided destination DeliveryRuleRequestSchemeCondition_STATUS from our DeliveryRuleRequestSchemeCondition_STATUS
func (condition *DeliveryRuleRequestSchemeCondition_STATUS) AssignProperties_To_DeliveryRuleRequestSchemeCondition_STATUS(destination *storage.DeliveryRuleRequestSchemeCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.RequestSchemeMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_RequestSchemeMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestSchemeMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestSchemeCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestSchemeCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleRequestUriCondition
type DeliveryRuleRequestUriCondition struct {
	Name        *string                             `json:"name,omitempty"`
	Parameters  *RequestUriMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag              `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleRequestUriCondition populates our DeliveryRuleRequestUriCondition from the provided source DeliveryRuleRequestUriCondition
func (condition *DeliveryRuleRequestUriCondition) AssignProperties_From_DeliveryRuleRequestUriCondition(source *storage.DeliveryRuleRequestUriCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter RequestUriMatchConditionParameters
		err := parameter.AssignProperties_From_RequestUriMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestUriMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestUriCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestUriCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestUriCondition populates the provided destination DeliveryRuleRequestUriCondition from our DeliveryRuleRequestUriCondition
func (condition *DeliveryRuleRequestUriCondition) AssignProperties_To_DeliveryRuleRequestUriCondition(destination *storage.DeliveryRuleRequestUriCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.RequestUriMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_RequestUriMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestUriMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestUriCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestUriCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleRequestUriCondition_STATUS
type DeliveryRuleRequestUriCondition_STATUS struct {
	Name        *string                                    `json:"name,omitempty"`
	Parameters  *RequestUriMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                     `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleRequestUriCondition_STATUS populates our DeliveryRuleRequestUriCondition_STATUS from the provided source DeliveryRuleRequestUriCondition_STATUS
func (condition *DeliveryRuleRequestUriCondition_STATUS) AssignProperties_From_DeliveryRuleRequestUriCondition_STATUS(source *storage.DeliveryRuleRequestUriCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter RequestUriMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_RequestUriMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestUriMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestUriCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestUriCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestUriCondition_STATUS populates the provided destination DeliveryRuleRequestUriCondition_STATUS from our DeliveryRuleRequestUriCondition_STATUS
func (condition *DeliveryRuleRequestUriCondition_STATUS) AssignProperties_To_DeliveryRuleRequestUriCondition_STATUS(destination *storage.DeliveryRuleRequestUriCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.RequestUriMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_RequestUriMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestUriMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestUriCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestUriCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleResponseHeaderAction
type DeliveryRuleResponseHeaderAction struct {
	Name        *string                 `json:"name,omitempty"`
	Parameters  *HeaderActionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag  `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleResponseHeaderAction populates our DeliveryRuleResponseHeaderAction from the provided source DeliveryRuleResponseHeaderAction
func (action *DeliveryRuleResponseHeaderAction) AssignProperties_From_DeliveryRuleResponseHeaderAction(source *storage.DeliveryRuleResponseHeaderAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter HeaderActionParameters
		err := parameter.AssignProperties_From_HeaderActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HeaderActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleResponseHeaderAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleResponseHeaderAction); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleResponseHeaderAction populates the provided destination DeliveryRuleResponseHeaderAction from our DeliveryRuleResponseHeaderAction
func (action *DeliveryRuleResponseHeaderAction) AssignProperties_To_DeliveryRuleResponseHeaderAction(destination *storage.DeliveryRuleResponseHeaderAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter storage.HeaderActionParameters
		err := action.Parameters.AssignProperties_To_HeaderActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HeaderActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleResponseHeaderAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleResponseHeaderAction); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleResponseHeaderAction_STATUS
type DeliveryRuleResponseHeaderAction_STATUS struct {
	Name        *string                        `json:"name,omitempty"`
	Parameters  *HeaderActionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag         `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleResponseHeaderAction_STATUS populates our DeliveryRuleResponseHeaderAction_STATUS from the provided source DeliveryRuleResponseHeaderAction_STATUS
func (action *DeliveryRuleResponseHeaderAction_STATUS) AssignProperties_From_DeliveryRuleResponseHeaderAction_STATUS(source *storage.DeliveryRuleResponseHeaderAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter HeaderActionParameters_STATUS
		err := parameter.AssignProperties_From_HeaderActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HeaderActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleResponseHeaderAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleResponseHeaderAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleResponseHeaderAction_STATUS populates the provided destination DeliveryRuleResponseHeaderAction_STATUS from our DeliveryRuleResponseHeaderAction_STATUS
func (action *DeliveryRuleResponseHeaderAction_STATUS) AssignProperties_To_DeliveryRuleResponseHeaderAction_STATUS(destination *storage.DeliveryRuleResponseHeaderAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter storage.HeaderActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_HeaderActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HeaderActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleResponseHeaderAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleResponseHeaderAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleRouteConfigurationOverrideAction
type DeliveryRuleRouteConfigurationOverrideAction struct {
	Name        *string                                     `json:"name,omitempty"`
	Parameters  *RouteConfigurationOverrideActionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                      `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction populates our DeliveryRuleRouteConfigurationOverrideAction from the provided source DeliveryRuleRouteConfigurationOverrideAction
func (action *DeliveryRuleRouteConfigurationOverrideAction) AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction(source *storage.DeliveryRuleRouteConfigurationOverrideAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter RouteConfigurationOverrideActionParameters
		err := parameter.AssignProperties_From_RouteConfigurationOverrideActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RouteConfigurationOverrideActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRouteConfigurationOverrideAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleRouteConfigurationOverrideAction); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction populates the provided destination DeliveryRuleRouteConfigurationOverrideAction from our DeliveryRuleRouteConfigurationOverrideAction
func (action *DeliveryRuleRouteConfigurationOverrideAction) AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction(destination *storage.DeliveryRuleRouteConfigurationOverrideAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter storage.RouteConfigurationOverrideActionParameters
		err := action.Parameters.AssignProperties_To_RouteConfigurationOverrideActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RouteConfigurationOverrideActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRouteConfigurationOverrideAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleRouteConfigurationOverrideAction); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleRouteConfigurationOverrideAction_STATUS
type DeliveryRuleRouteConfigurationOverrideAction_STATUS struct {
	Name        *string                                            `json:"name,omitempty"`
	Parameters  *RouteConfigurationOverrideActionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                             `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction_STATUS populates our DeliveryRuleRouteConfigurationOverrideAction_STATUS from the provided source DeliveryRuleRouteConfigurationOverrideAction_STATUS
func (action *DeliveryRuleRouteConfigurationOverrideAction_STATUS) AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction_STATUS(source *storage.DeliveryRuleRouteConfigurationOverrideAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter RouteConfigurationOverrideActionParameters_STATUS
		err := parameter.AssignProperties_From_RouteConfigurationOverrideActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RouteConfigurationOverrideActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRouteConfigurationOverrideAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleRouteConfigurationOverrideAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction_STATUS populates the provided destination DeliveryRuleRouteConfigurationOverrideAction_STATUS from our DeliveryRuleRouteConfigurationOverrideAction_STATUS
func (action *DeliveryRuleRouteConfigurationOverrideAction_STATUS) AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction_STATUS(destination *storage.DeliveryRuleRouteConfigurationOverrideAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter storage.RouteConfigurationOverrideActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_RouteConfigurationOverrideActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RouteConfigurationOverrideActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRouteConfigurationOverrideAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleRouteConfigurationOverrideAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleServerPortCondition
type DeliveryRuleServerPortCondition struct {
	Name        *string                             `json:"name,omitempty"`
	Parameters  *ServerPortMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag              `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleServerPortCondition populates our DeliveryRuleServerPortCondition from the provided source DeliveryRuleServerPortCondition
func (condition *DeliveryRuleServerPortCondition) AssignProperties_From_DeliveryRuleServerPortCondition(source *storage.DeliveryRuleServerPortCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter ServerPortMatchConditionParameters
		err := parameter.AssignProperties_From_ServerPortMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ServerPortMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleServerPortCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleServerPortCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleServerPortCondition populates the provided destination DeliveryRuleServerPortCondition from our DeliveryRuleServerPortCondition
func (condition *DeliveryRuleServerPortCondition) AssignProperties_To_DeliveryRuleServerPortCondition(destination *storage.DeliveryRuleServerPortCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.ServerPortMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_ServerPortMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ServerPortMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleServerPortCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleServerPortCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleServerPortCondition_STATUS
type DeliveryRuleServerPortCondition_STATUS struct {
	Name        *string                                    `json:"name,omitempty"`
	Parameters  *ServerPortMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                     `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleServerPortCondition_STATUS populates our DeliveryRuleServerPortCondition_STATUS from the provided source DeliveryRuleServerPortCondition_STATUS
func (condition *DeliveryRuleServerPortCondition_STATUS) AssignProperties_From_DeliveryRuleServerPortCondition_STATUS(source *storage.DeliveryRuleServerPortCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter ServerPortMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_ServerPortMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ServerPortMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleServerPortCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleServerPortCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleServerPortCondition_STATUS populates the provided destination DeliveryRuleServerPortCondition_STATUS from our DeliveryRuleServerPortCondition_STATUS
func (condition *DeliveryRuleServerPortCondition_STATUS) AssignProperties_To_DeliveryRuleServerPortCondition_STATUS(destination *storage.DeliveryRuleServerPortCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.ServerPortMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_ServerPortMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ServerPortMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleServerPortCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleServerPortCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleSocketAddrCondition
type DeliveryRuleSocketAddrCondition struct {
	Name        *string                             `json:"name,omitempty"`
	Parameters  *SocketAddrMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag              `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleSocketAddrCondition populates our DeliveryRuleSocketAddrCondition from the provided source DeliveryRuleSocketAddrCondition
func (condition *DeliveryRuleSocketAddrCondition) AssignProperties_From_DeliveryRuleSocketAddrCondition(source *storage.DeliveryRuleSocketAddrCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter SocketAddrMatchConditionParameters
		err := parameter.AssignProperties_From_SocketAddrMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SocketAddrMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleSocketAddrCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleSocketAddrCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleSocketAddrCondition populates the provided destination DeliveryRuleSocketAddrCondition from our DeliveryRuleSocketAddrCondition
func (condition *DeliveryRuleSocketAddrCondition) AssignProperties_To_DeliveryRuleSocketAddrCondition(destination *storage.DeliveryRuleSocketAddrCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.SocketAddrMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_SocketAddrMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SocketAddrMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleSocketAddrCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleSocketAddrCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleSocketAddrCondition_STATUS
type DeliveryRuleSocketAddrCondition_STATUS struct {
	Name        *string                                    `json:"name,omitempty"`
	Parameters  *SocketAddrMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                     `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleSocketAddrCondition_STATUS populates our DeliveryRuleSocketAddrCondition_STATUS from the provided source DeliveryRuleSocketAddrCondition_STATUS
func (condition *DeliveryRuleSocketAddrCondition_STATUS) AssignProperties_From_DeliveryRuleSocketAddrCondition_STATUS(source *storage.DeliveryRuleSocketAddrCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter SocketAddrMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_SocketAddrMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SocketAddrMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleSocketAddrCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleSocketAddrCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleSocketAddrCondition_STATUS populates the provided destination DeliveryRuleSocketAddrCondition_STATUS from our DeliveryRuleSocketAddrCondition_STATUS
func (condition *DeliveryRuleSocketAddrCondition_STATUS) AssignProperties_To_DeliveryRuleSocketAddrCondition_STATUS(destination *storage.DeliveryRuleSocketAddrCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.SocketAddrMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_SocketAddrMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SocketAddrMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleSocketAddrCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleSocketAddrCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleSslProtocolCondition
type DeliveryRuleSslProtocolCondition struct {
	Name        *string                              `json:"name,omitempty"`
	Parameters  *SslProtocolMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag               `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleSslProtocolCondition populates our DeliveryRuleSslProtocolCondition from the provided source DeliveryRuleSslProtocolCondition
func (condition *DeliveryRuleSslProtocolCondition) AssignProperties_From_DeliveryRuleSslProtocolCondition(source *storage.DeliveryRuleSslProtocolCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter SslProtocolMatchConditionParameters
		err := parameter.AssignProperties_From_SslProtocolMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SslProtocolMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleSslProtocolCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleSslProtocolCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleSslProtocolCondition populates the provided destination DeliveryRuleSslProtocolCondition from our DeliveryRuleSslProtocolCondition
func (condition *DeliveryRuleSslProtocolCondition) AssignProperties_To_DeliveryRuleSslProtocolCondition(destination *storage.DeliveryRuleSslProtocolCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.SslProtocolMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_SslProtocolMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SslProtocolMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleSslProtocolCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleSslProtocolCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleSslProtocolCondition_STATUS
type DeliveryRuleSslProtocolCondition_STATUS struct {
	Name        *string                                     `json:"name,omitempty"`
	Parameters  *SslProtocolMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                      `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleSslProtocolCondition_STATUS populates our DeliveryRuleSslProtocolCondition_STATUS from the provided source DeliveryRuleSslProtocolCondition_STATUS
func (condition *DeliveryRuleSslProtocolCondition_STATUS) AssignProperties_From_DeliveryRuleSslProtocolCondition_STATUS(source *storage.DeliveryRuleSslProtocolCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter SslProtocolMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_SslProtocolMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SslProtocolMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleSslProtocolCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleSslProtocolCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleSslProtocolCondition_STATUS populates the provided destination DeliveryRuleSslProtocolCondition_STATUS from our DeliveryRuleSslProtocolCondition_STATUS
func (condition *DeliveryRuleSslProtocolCondition_STATUS) AssignProperties_To_DeliveryRuleSslProtocolCondition_STATUS(destination *storage.DeliveryRuleSslProtocolCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.SslProtocolMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_SslProtocolMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SslProtocolMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleSslProtocolCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleSslProtocolCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleUrlFileExtensionCondition
type DeliveryRuleUrlFileExtensionCondition struct {
	Name        *string                                   `json:"name,omitempty"`
	Parameters  *UrlFileExtensionMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                    `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleUrlFileExtensionCondition populates our DeliveryRuleUrlFileExtensionCondition from the provided source DeliveryRuleUrlFileExtensionCondition
func (condition *DeliveryRuleUrlFileExtensionCondition) AssignProperties_From_DeliveryRuleUrlFileExtensionCondition(source *storage.DeliveryRuleUrlFileExtensionCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter UrlFileExtensionMatchConditionParameters
		err := parameter.AssignProperties_From_UrlFileExtensionMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlFileExtensionMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleUrlFileExtensionCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleUrlFileExtensionCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleUrlFileExtensionCondition populates the provided destination DeliveryRuleUrlFileExtensionCondition from our DeliveryRuleUrlFileExtensionCondition
func (condition *DeliveryRuleUrlFileExtensionCondition) AssignProperties_To_DeliveryRuleUrlFileExtensionCondition(destination *storage.DeliveryRuleUrlFileExtensionCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.UrlFileExtensionMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_UrlFileExtensionMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlFileExtensionMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleUrlFileExtensionCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleUrlFileExtensionCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleUrlFileExtensionCondition_STATUS
type DeliveryRuleUrlFileExtensionCondition_STATUS struct {
	Name        *string                                          `json:"name,omitempty"`
	Parameters  *UrlFileExtensionMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                           `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleUrlFileExtensionCondition_STATUS populates our DeliveryRuleUrlFileExtensionCondition_STATUS from the provided source DeliveryRuleUrlFileExtensionCondition_STATUS
func (condition *DeliveryRuleUrlFileExtensionCondition_STATUS) AssignProperties_From_DeliveryRuleUrlFileExtensionCondition_STATUS(source *storage.DeliveryRuleUrlFileExtensionCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter UrlFileExtensionMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_UrlFileExtensionMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlFileExtensionMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleUrlFileExtensionCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleUrlFileExtensionCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleUrlFileExtensionCondition_STATUS populates the provided destination DeliveryRuleUrlFileExtensionCondition_STATUS from our DeliveryRuleUrlFileExtensionCondition_STATUS
func (condition *DeliveryRuleUrlFileExtensionCondition_STATUS) AssignProperties_To_DeliveryRuleUrlFileExtensionCondition_STATUS(destination *storage.DeliveryRuleUrlFileExtensionCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.UrlFileExtensionMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_UrlFileExtensionMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlFileExtensionMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleUrlFileExtensionCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleUrlFileExtensionCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleUrlFileNameCondition
type DeliveryRuleUrlFileNameCondition struct {
	Name        *string                              `json:"name,omitempty"`
	Parameters  *UrlFileNameMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag               `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleUrlFileNameCondition populates our DeliveryRuleUrlFileNameCondition from the provided source DeliveryRuleUrlFileNameCondition
func (condition *DeliveryRuleUrlFileNameCondition) AssignProperties_From_DeliveryRuleUrlFileNameCondition(source *storage.DeliveryRuleUrlFileNameCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter UrlFileNameMatchConditionParameters
		err := parameter.AssignProperties_From_UrlFileNameMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlFileNameMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleUrlFileNameCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleUrlFileNameCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleUrlFileNameCondition populates the provided destination DeliveryRuleUrlFileNameCondition from our DeliveryRuleUrlFileNameCondition
func (condition *DeliveryRuleUrlFileNameCondition) AssignProperties_To_DeliveryRuleUrlFileNameCondition(destination *storage.DeliveryRuleUrlFileNameCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.UrlFileNameMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_UrlFileNameMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlFileNameMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleUrlFileNameCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleUrlFileNameCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleUrlFileNameCondition_STATUS
type DeliveryRuleUrlFileNameCondition_STATUS struct {
	Name        *string                                     `json:"name,omitempty"`
	Parameters  *UrlFileNameMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                      `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleUrlFileNameCondition_STATUS populates our DeliveryRuleUrlFileNameCondition_STATUS from the provided source DeliveryRuleUrlFileNameCondition_STATUS
func (condition *DeliveryRuleUrlFileNameCondition_STATUS) AssignProperties_From_DeliveryRuleUrlFileNameCondition_STATUS(source *storage.DeliveryRuleUrlFileNameCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter UrlFileNameMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_UrlFileNameMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlFileNameMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleUrlFileNameCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleUrlFileNameCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleUrlFileNameCondition_STATUS populates the provided destination DeliveryRuleUrlFileNameCondition_STATUS from our DeliveryRuleUrlFileNameCondition_STATUS
func (condition *DeliveryRuleUrlFileNameCondition_STATUS) AssignProperties_To_DeliveryRuleUrlFileNameCondition_STATUS(destination *storage.DeliveryRuleUrlFileNameCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.UrlFileNameMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_UrlFileNameMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlFileNameMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleUrlFileNameCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleUrlFileNameCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleUrlPathCondition
type DeliveryRuleUrlPathCondition struct {
	Name        *string                          `json:"name,omitempty"`
	Parameters  *UrlPathMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag           `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleUrlPathCondition populates our DeliveryRuleUrlPathCondition from the provided source DeliveryRuleUrlPathCondition
func (condition *DeliveryRuleUrlPathCondition) AssignProperties_From_DeliveryRuleUrlPathCondition(source *storage.DeliveryRuleUrlPathCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter UrlPathMatchConditionParameters
		err := parameter.AssignProperties_From_UrlPathMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlPathMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleUrlPathCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleUrlPathCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleUrlPathCondition populates the provided destination DeliveryRuleUrlPathCondition from our DeliveryRuleUrlPathCondition
func (condition *DeliveryRuleUrlPathCondition) AssignProperties_To_DeliveryRuleUrlPathCondition(destination *storage.DeliveryRuleUrlPathCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.UrlPathMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_UrlPathMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlPathMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleUrlPathCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleUrlPathCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.DeliveryRuleUrlPathCondition_STATUS
type DeliveryRuleUrlPathCondition_STATUS struct {
	Name        *string                                 `json:"name,omitempty"`
	Parameters  *UrlPathMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                  `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleUrlPathCondition_STATUS populates our DeliveryRuleUrlPathCondition_STATUS from the provided source DeliveryRuleUrlPathCondition_STATUS
func (condition *DeliveryRuleUrlPathCondition_STATUS) AssignProperties_From_DeliveryRuleUrlPathCondition_STATUS(source *storage.DeliveryRuleUrlPathCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter UrlPathMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_UrlPathMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlPathMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleUrlPathCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleUrlPathCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleUrlPathCondition_STATUS populates the provided destination DeliveryRuleUrlPathCondition_STATUS from our DeliveryRuleUrlPathCondition_STATUS
func (condition *DeliveryRuleUrlPathCondition_STATUS) AssignProperties_To_DeliveryRuleUrlPathCondition_STATUS(destination *storage.DeliveryRuleUrlPathCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter storage.UrlPathMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_UrlPathMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlPathMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleUrlPathCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleUrlPathCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.OriginGroupOverrideAction
type OriginGroupOverrideAction struct {
	Name        *string                              `json:"name,omitempty"`
	Parameters  *OriginGroupOverrideActionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag               `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_OriginGroupOverrideAction populates our OriginGroupOverrideAction from the provided source OriginGroupOverrideAction
func (action *OriginGroupOverrideAction) AssignProperties_From_OriginGroupOverrideAction(source *storage.OriginGroupOverrideAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter OriginGroupOverrideActionParameters
		err := parameter.AssignProperties_From_OriginGroupOverrideActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OriginGroupOverrideActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForOriginGroupOverrideAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForOriginGroupOverrideAction); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_OriginGroupOverrideAction populates the provided destination OriginGroupOverrideAction from our OriginGroupOverrideAction
func (action *OriginGroupOverrideAction) AssignProperties_To_OriginGroupOverrideAction(destination *storage.OriginGroupOverrideAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter storage.OriginGroupOverrideActionParameters
		err := action.Parameters.AssignProperties_To_OriginGroupOverrideActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OriginGroupOverrideActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForOriginGroupOverrideAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForOriginGroupOverrideAction); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.OriginGroupOverrideAction_STATUS
type OriginGroupOverrideAction_STATUS struct {
	Name        *string                                     `json:"name,omitempty"`
	Parameters  *OriginGroupOverrideActionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                      `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_OriginGroupOverrideAction_STATUS populates our OriginGroupOverrideAction_STATUS from the provided source OriginGroupOverrideAction_STATUS
func (action *OriginGroupOverrideAction_STATUS) AssignProperties_From_OriginGroupOverrideAction_STATUS(source *storage.OriginGroupOverrideAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter OriginGroupOverrideActionParameters_STATUS
		err := parameter.AssignProperties_From_OriginGroupOverrideActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OriginGroupOverrideActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForOriginGroupOverrideAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForOriginGroupOverrideAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_OriginGroupOverrideAction_STATUS populates the provided destination OriginGroupOverrideAction_STATUS from our OriginGroupOverrideAction_STATUS
func (action *OriginGroupOverrideAction_STATUS) AssignProperties_To_OriginGroupOverrideAction_STATUS(destination *storage.OriginGroupOverrideAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter storage.OriginGroupOverrideActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_OriginGroupOverrideActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OriginGroupOverrideActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForOriginGroupOverrideAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForOriginGroupOverrideAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.UrlRedirectAction
type UrlRedirectAction struct {
	Name        *string                      `json:"name,omitempty"`
	Parameters  *UrlRedirectActionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag       `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_UrlRedirectAction populates our UrlRedirectAction from the provided source UrlRedirectAction
func (action *UrlRedirectAction) AssignProperties_From_UrlRedirectAction(source *storage.UrlRedirectAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter UrlRedirectActionParameters
		err := parameter.AssignProperties_From_UrlRedirectActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlRedirectActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlRedirectAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForUrlRedirectAction); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlRedirectAction populates the provided destination UrlRedirectAction from our UrlRedirectAction
func (action *UrlRedirectAction) AssignProperties_To_UrlRedirectAction(destination *storage.UrlRedirectAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter storage.UrlRedirectActionParameters
		err := action.Parameters.AssignProperties_To_UrlRedirectActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlRedirectActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlRedirectAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForUrlRedirectAction); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.UrlRedirectAction_STATUS
type UrlRedirectAction_STATUS struct {
	Name        *string                             `json:"name,omitempty"`
	Parameters  *UrlRedirectActionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag              `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_UrlRedirectAction_STATUS populates our UrlRedirectAction_STATUS from the provided source UrlRedirectAction_STATUS
func (action *UrlRedirectAction_STATUS) AssignProperties_From_UrlRedirectAction_STATUS(source *storage.UrlRedirectAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter UrlRedirectActionParameters_STATUS
		err := parameter.AssignProperties_From_UrlRedirectActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlRedirectActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlRedirectAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForUrlRedirectAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlRedirectAction_STATUS populates the provided destination UrlRedirectAction_STATUS from our UrlRedirectAction_STATUS
func (action *UrlRedirectAction_STATUS) AssignProperties_To_UrlRedirectAction_STATUS(destination *storage.UrlRedirectAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter storage.UrlRedirectActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_UrlRedirectActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlRedirectActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlRedirectAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForUrlRedirectAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.UrlRewriteAction
type UrlRewriteAction struct {
	Name        *string                     `json:"name,omitempty"`
	Parameters  *UrlRewriteActionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag      `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_UrlRewriteAction populates our UrlRewriteAction from the provided source UrlRewriteAction
func (action *UrlRewriteAction) AssignProperties_From_UrlRewriteAction(source *storage.UrlRewriteAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter UrlRewriteActionParameters
		err := parameter.AssignProperties_From_UrlRewriteActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlRewriteActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlRewriteAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForUrlRewriteAction); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlRewriteAction populates the provided destination UrlRewriteAction from our UrlRewriteAction
func (action *UrlRewriteAction) AssignProperties_To_UrlRewriteAction(destination *storage.UrlRewriteAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter storage.UrlRewriteActionParameters
		err := action.Parameters.AssignProperties_To_UrlRewriteActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlRewriteActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlRewriteAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForUrlRewriteAction); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.UrlRewriteAction_STATUS
type UrlRewriteAction_STATUS struct {
	Name        *string                            `json:"name,omitempty"`
	Parameters  *UrlRewriteActionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag             `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_UrlRewriteAction_STATUS populates our UrlRewriteAction_STATUS from the provided source UrlRewriteAction_STATUS
func (action *UrlRewriteAction_STATUS) AssignProperties_From_UrlRewriteAction_STATUS(source *storage.UrlRewriteAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter UrlRewriteActionParameters_STATUS
		err := parameter.AssignProperties_From_UrlRewriteActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlRewriteActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlRewriteAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForUrlRewriteAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlRewriteAction_STATUS populates the provided destination UrlRewriteAction_STATUS from our UrlRewriteAction_STATUS
func (action *UrlRewriteAction_STATUS) AssignProperties_To_UrlRewriteAction_STATUS(destination *storage.UrlRewriteAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter storage.UrlRewriteActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_UrlRewriteActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlRewriteActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlRewriteAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForUrlRewriteAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.UrlSigningAction
type UrlSigningAction struct {
	Name        *string                     `json:"name,omitempty"`
	Parameters  *UrlSigningActionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag      `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_UrlSigningAction populates our UrlSigningAction from the provided source UrlSigningAction
func (action *UrlSigningAction) AssignProperties_From_UrlSigningAction(source *storage.UrlSigningAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter UrlSigningActionParameters
		err := parameter.AssignProperties_From_UrlSigningActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlSigningActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlSigningAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForUrlSigningAction); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlSigningAction populates the provided destination UrlSigningAction from our UrlSigningAction
func (action *UrlSigningAction) AssignProperties_To_UrlSigningAction(destination *storage.UrlSigningAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter storage.UrlSigningActionParameters
		err := action.Parameters.AssignProperties_To_UrlSigningActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlSigningActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlSigningAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForUrlSigningAction); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.UrlSigningAction_STATUS
type UrlSigningAction_STATUS struct {
	Name        *string                            `json:"name,omitempty"`
	Parameters  *UrlSigningActionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag             `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_UrlSigningAction_STATUS populates our UrlSigningAction_STATUS from the provided source UrlSigningAction_STATUS
func (action *UrlSigningAction_STATUS) AssignProperties_From_UrlSigningAction_STATUS(source *storage.UrlSigningAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter UrlSigningActionParameters_STATUS
		err := parameter.AssignProperties_From_UrlSigningActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlSigningActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlSigningAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForUrlSigningAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlSigningAction_STATUS populates the provided destination UrlSigningAction_STATUS from our UrlSigningAction_STATUS
func (action *UrlSigningAction_STATUS) AssignProperties_To_UrlSigningAction_STATUS(destination *storage.UrlSigningAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter storage.UrlSigningActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_UrlSigningActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlSigningActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlSigningAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForUrlSigningAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForDeliveryRuleCacheExpirationAction interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleCacheExpirationAction) error
	AssignPropertiesTo(dst *storage.DeliveryRuleCacheExpirationAction) error
}

type augmentConversionForDeliveryRuleCacheExpirationAction_STATUS interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleCacheExpirationAction_STATUS) error
	AssignPropertiesTo(dst *storage.DeliveryRuleCacheExpirationAction_STATUS) error
}

type augmentConversionForDeliveryRuleCacheKeyQueryStringAction interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleCacheKeyQueryStringAction) error
	AssignPropertiesTo(dst *storage.DeliveryRuleCacheKeyQueryStringAction) error
}

type augmentConversionForDeliveryRuleCacheKeyQueryStringAction_STATUS interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleCacheKeyQueryStringAction_STATUS) error
	AssignPropertiesTo(dst *storage.DeliveryRuleCacheKeyQueryStringAction_STATUS) error
}

type augmentConversionForDeliveryRuleClientPortCondition interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleClientPortCondition) error
	AssignPropertiesTo(dst *storage.DeliveryRuleClientPortCondition) error
}

type augmentConversionForDeliveryRuleClientPortCondition_STATUS interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleClientPortCondition_STATUS) error
	AssignPropertiesTo(dst *storage.DeliveryRuleClientPortCondition_STATUS) error
}

type augmentConversionForDeliveryRuleCookiesCondition interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleCookiesCondition) error
	AssignPropertiesTo(dst *storage.DeliveryRuleCookiesCondition) error
}

type augmentConversionForDeliveryRuleCookiesCondition_STATUS interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleCookiesCondition_STATUS) error
	AssignPropertiesTo(dst *storage.DeliveryRuleCookiesCondition_STATUS) error
}

type augmentConversionForDeliveryRuleHostNameCondition interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleHostNameCondition) error
	AssignPropertiesTo(dst *storage.DeliveryRuleHostNameCondition) error
}

type augmentConversionForDeliveryRuleHostNameCondition_STATUS interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleHostNameCondition_STATUS) error
	AssignPropertiesTo(dst *storage.DeliveryRuleHostNameCondition_STATUS) error
}

type augmentConversionForDeliveryRuleHttpVersionCondition interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleHttpVersionCondition) error
	AssignPropertiesTo(dst *storage.DeliveryRuleHttpVersionCondition) error
}

type augmentConversionForDeliveryRuleHttpVersionCondition_STATUS interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleHttpVersionCondition_STATUS) error
	AssignPropertiesTo(dst *storage.DeliveryRuleHttpVersionCondition_STATUS) error
}

type augmentConversionForDeliveryRuleIsDeviceCondition interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleIsDeviceCondition) error
	AssignPropertiesTo(dst *storage.DeliveryRuleIsDeviceCondition) error
}

type augmentConversionForDeliveryRuleIsDeviceCondition_STATUS interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleIsDeviceCondition_STATUS) error
	AssignPropertiesTo(dst *storage.DeliveryRuleIsDeviceCondition_STATUS) error
}

type augmentConversionForDeliveryRulePostArgsCondition interface {
	AssignPropertiesFrom(src *storage.DeliveryRulePostArgsCondition) error
	AssignPropertiesTo(dst *storage.DeliveryRulePostArgsCondition) error
}

type augmentConversionForDeliveryRulePostArgsCondition_STATUS interface {
	AssignPropertiesFrom(src *storage.DeliveryRulePostArgsCondition_STATUS) error
	AssignPropertiesTo(dst *storage.DeliveryRulePostArgsCondition_STATUS) error
}

type augmentConversionForDeliveryRuleQueryStringCondition interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleQueryStringCondition) error
	AssignPropertiesTo(dst *storage.DeliveryRuleQueryStringCondition) error
}

type augmentConversionForDeliveryRuleQueryStringCondition_STATUS interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleQueryStringCondition_STATUS) error
	AssignPropertiesTo(dst *storage.DeliveryRuleQueryStringCondition_STATUS) error
}

type augmentConversionForDeliveryRuleRemoteAddressCondition interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleRemoteAddressCondition) error
	AssignPropertiesTo(dst *storage.DeliveryRuleRemoteAddressCondition) error
}

type augmentConversionForDeliveryRuleRemoteAddressCondition_STATUS interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleRemoteAddressCondition_STATUS) error
	AssignPropertiesTo(dst *storage.DeliveryRuleRemoteAddressCondition_STATUS) error
}

type augmentConversionForDeliveryRuleRequestBodyCondition interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleRequestBodyCondition) error
	AssignPropertiesTo(dst *storage.DeliveryRuleRequestBodyCondition) error
}

type augmentConversionForDeliveryRuleRequestBodyCondition_STATUS interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleRequestBodyCondition_STATUS) error
	AssignPropertiesTo(dst *storage.DeliveryRuleRequestBodyCondition_STATUS) error
}

type augmentConversionForDeliveryRuleRequestHeaderAction interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleRequestHeaderAction) error
	AssignPropertiesTo(dst *storage.DeliveryRuleRequestHeaderAction) error
}

type augmentConversionForDeliveryRuleRequestHeaderAction_STATUS interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleRequestHeaderAction_STATUS) error
	AssignPropertiesTo(dst *storage.DeliveryRuleRequestHeaderAction_STATUS) error
}

type augmentConversionForDeliveryRuleRequestHeaderCondition interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleRequestHeaderCondition) error
	AssignPropertiesTo(dst *storage.DeliveryRuleRequestHeaderCondition) error
}

type augmentConversionForDeliveryRuleRequestHeaderCondition_STATUS interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleRequestHeaderCondition_STATUS) error
	AssignPropertiesTo(dst *storage.DeliveryRuleRequestHeaderCondition_STATUS) error
}

type augmentConversionForDeliveryRuleRequestMethodCondition interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleRequestMethodCondition) error
	AssignPropertiesTo(dst *storage.DeliveryRuleRequestMethodCondition) error
}

type augmentConversionForDeliveryRuleRequestMethodCondition_STATUS interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleRequestMethodCondition_STATUS) error
	AssignPropertiesTo(dst *storage.DeliveryRuleRequestMethodCondition_STATUS) error
}

type augmentConversionForDeliveryRuleRequestSchemeCondition interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleRequestSchemeCondition) error
	AssignPropertiesTo(dst *storage.DeliveryRuleRequestSchemeCondition) error
}

type augmentConversionForDeliveryRuleRequestSchemeCondition_STATUS interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleRequestSchemeCondition_STATUS) error
	AssignPropertiesTo(dst *storage.DeliveryRuleRequestSchemeCondition_STATUS) error
}

type augmentConversionForDeliveryRuleRequestUriCondition interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleRequestUriCondition) error
	AssignPropertiesTo(dst *storage.DeliveryRuleRequestUriCondition) error
}

type augmentConversionForDeliveryRuleRequestUriCondition_STATUS interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleRequestUriCondition_STATUS) error
	AssignPropertiesTo(dst *storage.DeliveryRuleRequestUriCondition_STATUS) error
}

type augmentConversionForDeliveryRuleResponseHeaderAction interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleResponseHeaderAction) error
	AssignPropertiesTo(dst *storage.DeliveryRuleResponseHeaderAction) error
}

type augmentConversionForDeliveryRuleResponseHeaderAction_STATUS interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleResponseHeaderAction_STATUS) error
	AssignPropertiesTo(dst *storage.DeliveryRuleResponseHeaderAction_STATUS) error
}

type augmentConversionForDeliveryRuleRouteConfigurationOverrideAction interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleRouteConfigurationOverrideAction) error
	AssignPropertiesTo(dst *storage.DeliveryRuleRouteConfigurationOverrideAction) error
}

type augmentConversionForDeliveryRuleRouteConfigurationOverrideAction_STATUS interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleRouteConfigurationOverrideAction_STATUS) error
	AssignPropertiesTo(dst *storage.DeliveryRuleRouteConfigurationOverrideAction_STATUS) error
}

type augmentConversionForDeliveryRuleServerPortCondition interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleServerPortCondition) error
	AssignPropertiesTo(dst *storage.DeliveryRuleServerPortCondition) error
}

type augmentConversionForDeliveryRuleServerPortCondition_STATUS interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleServerPortCondition_STATUS) error
	AssignPropertiesTo(dst *storage.DeliveryRuleServerPortCondition_STATUS) error
}

type augmentConversionForDeliveryRuleSocketAddrCondition interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleSocketAddrCondition) error
	AssignPropertiesTo(dst *storage.DeliveryRuleSocketAddrCondition) error
}

type augmentConversionForDeliveryRuleSocketAddrCondition_STATUS interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleSocketAddrCondition_STATUS) error
	AssignPropertiesTo(dst *storage.DeliveryRuleSocketAddrCondition_STATUS) error
}

type augmentConversionForDeliveryRuleSslProtocolCondition interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleSslProtocolCondition) error
	AssignPropertiesTo(dst *storage.DeliveryRuleSslProtocolCondition) error
}

type augmentConversionForDeliveryRuleSslProtocolCondition_STATUS interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleSslProtocolCondition_STATUS) error
	AssignPropertiesTo(dst *storage.DeliveryRuleSslProtocolCondition_STATUS) error
}

type augmentConversionForDeliveryRuleUrlFileExtensionCondition interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleUrlFileExtensionCondition) error
	AssignPropertiesTo(dst *storage.DeliveryRuleUrlFileExtensionCondition) error
}

type augmentConversionForDeliveryRuleUrlFileExtensionCondition_STATUS interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleUrlFileExtensionCondition_STATUS) error
	AssignPropertiesTo(dst *storage.DeliveryRuleUrlFileExtensionCondition_STATUS) error
}

type augmentConversionForDeliveryRuleUrlFileNameCondition interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleUrlFileNameCondition) error
	AssignPropertiesTo(dst *storage.DeliveryRuleUrlFileNameCondition) error
}

type augmentConversionForDeliveryRuleUrlFileNameCondition_STATUS interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleUrlFileNameCondition_STATUS) error
	AssignPropertiesTo(dst *storage.DeliveryRuleUrlFileNameCondition_STATUS) error
}

type augmentConversionForDeliveryRuleUrlPathCondition interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleUrlPathCondition) error
	AssignPropertiesTo(dst *storage.DeliveryRuleUrlPathCondition) error
}

type augmentConversionForDeliveryRuleUrlPathCondition_STATUS interface {
	AssignPropertiesFrom(src *storage.DeliveryRuleUrlPathCondition_STATUS) error
	AssignPropertiesTo(dst *storage.DeliveryRuleUrlPathCondition_STATUS) error
}

type augmentConversionForOriginGroupOverrideAction interface {
	AssignPropertiesFrom(src *storage.OriginGroupOverrideAction) error
	AssignPropertiesTo(dst *storage.OriginGroupOverrideAction) error
}

type augmentConversionForOriginGroupOverrideAction_STATUS interface {
	AssignPropertiesFrom(src *storage.OriginGroupOverrideAction_STATUS) error
	AssignPropertiesTo(dst *storage.OriginGroupOverrideAction_STATUS) error
}

type augmentConversionForUrlRedirectAction interface {
	AssignPropertiesFrom(src *storage.UrlRedirectAction) error
	AssignPropertiesTo(dst *storage.UrlRedirectAction) error
}

type augmentConversionForUrlRedirectAction_STATUS interface {
	AssignPropertiesFrom(src *storage.UrlRedirectAction_STATUS) error
	AssignPropertiesTo(dst *storage.UrlRedirectAction_STATUS) error
}

type augmentConversionForUrlRewriteAction interface {
	AssignPropertiesFrom(src *storage.UrlRewriteAction) error
	AssignPropertiesTo(dst *storage.UrlRewriteAction) error
}

type augmentConversionForUrlRewriteAction_STATUS interface {
	AssignPropertiesFrom(src *storage.UrlRewriteAction_STATUS) error
	AssignPropertiesTo(dst *storage.UrlRewriteAction_STATUS) error
}

type augmentConversionForUrlSigningAction interface {
	AssignPropertiesFrom(src *storage.UrlSigningAction) error
	AssignPropertiesTo(dst *storage.UrlSigningAction) error
}

type augmentConversionForUrlSigningAction_STATUS interface {
	AssignPropertiesFrom(src *storage.UrlSigningAction_STATUS) error
	AssignPropertiesTo(dst *storage.UrlSigningAction_STATUS) error
}

// Storage version of v1api20210601.CacheExpirationActionParameters
// Defines the parameters for the cache expiration action.
type CacheExpirationActionParameters struct {
	CacheBehavior *string                `json:"cacheBehavior,omitempty"`
	CacheDuration *string                `json:"cacheDuration,omitempty"`
	CacheType     *string                `json:"cacheType,omitempty"`
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	TypeName      *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_CacheExpirationActionParameters populates our CacheExpirationActionParameters from the provided source CacheExpirationActionParameters
func (parameters *CacheExpirationActionParameters) AssignProperties_From_CacheExpirationActionParameters(source *storage.CacheExpirationActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CacheBehavior
	parameters.CacheBehavior = genruntime.ClonePointerToString(source.CacheBehavior)

	// CacheDuration
	parameters.CacheDuration = genruntime.ClonePointerToString(source.CacheDuration)

	// CacheType
	parameters.CacheType = genruntime.ClonePointerToString(source.CacheType)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForCacheExpirationActionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForCacheExpirationActionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_CacheExpirationActionParameters populates the provided destination CacheExpirationActionParameters from our CacheExpirationActionParameters
func (parameters *CacheExpirationActionParameters) AssignProperties_To_CacheExpirationActionParameters(destination *storage.CacheExpirationActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// CacheBehavior
	destination.CacheBehavior = genruntime.ClonePointerToString(parameters.CacheBehavior)

	// CacheDuration
	destination.CacheDuration = genruntime.ClonePointerToString(parameters.CacheDuration)

	// CacheType
	destination.CacheType = genruntime.ClonePointerToString(parameters.CacheType)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForCacheExpirationActionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForCacheExpirationActionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.CacheExpirationActionParameters_STATUS
// Defines the parameters for the cache expiration action.
type CacheExpirationActionParameters_STATUS struct {
	CacheBehavior *string                `json:"cacheBehavior,omitempty"`
	CacheDuration *string                `json:"cacheDuration,omitempty"`
	CacheType     *string                `json:"cacheType,omitempty"`
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	TypeName      *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_CacheExpirationActionParameters_STATUS populates our CacheExpirationActionParameters_STATUS from the provided source CacheExpirationActionParameters_STATUS
func (parameters *CacheExpirationActionParameters_STATUS) AssignProperties_From_CacheExpirationActionParameters_STATUS(source *storage.CacheExpirationActionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CacheBehavior
	parameters.CacheBehavior = genruntime.ClonePointerToString(source.CacheBehavior)

	// CacheDuration
	parameters.CacheDuration = genruntime.ClonePointerToString(source.CacheDuration)

	// CacheType
	parameters.CacheType = genruntime.ClonePointerToString(source.CacheType)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForCacheExpirationActionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForCacheExpirationActionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_CacheExpirationActionParameters_STATUS populates the provided destination CacheExpirationActionParameters_STATUS from our CacheExpirationActionParameters_STATUS
func (parameters *CacheExpirationActionParameters_STATUS) AssignProperties_To_CacheExpirationActionParameters_STATUS(destination *storage.CacheExpirationActionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// CacheBehavior
	destination.CacheBehavior = genruntime.ClonePointerToString(parameters.CacheBehavior)

	// CacheDuration
	destination.CacheDuration = genruntime.ClonePointerToString(parameters.CacheDuration)

	// CacheType
	destination.CacheType = genruntime.ClonePointerToString(parameters.CacheType)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForCacheExpirationActionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForCacheExpirationActionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.CacheKeyQueryStringActionParameters
// Defines the parameters for the cache-key query string action.
type CacheKeyQueryStringActionParameters struct {
	PropertyBag         genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	QueryParameters     *string                `json:"queryParameters,omitempty"`
	QueryStringBehavior *string                `json:"queryStringBehavior,omitempty"`
	TypeName            *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_CacheKeyQueryStringActionParameters populates our CacheKeyQueryStringActionParameters from the provided source CacheKeyQueryStringActionParameters
func (parameters *CacheKeyQueryStringActionParameters) AssignProperties_From_CacheKeyQueryStringActionParameters(source *storage.CacheKeyQueryStringActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// QueryParameters
	parameters.QueryParameters = genruntime.ClonePointerToString(source.QueryParameters)

	// QueryStringBehavior
	parameters.QueryStringBehavior = genruntime.ClonePointerToString(source.QueryStringBehavior)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForCacheKeyQueryStringActionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForCacheKeyQueryStringActionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_CacheKeyQueryStringActionParameters populates the provided destination CacheKeyQueryStringActionParameters from our CacheKeyQueryStringActionParameters
func (parameters *CacheKeyQueryStringActionParameters) AssignProperties_To_CacheKeyQueryStringActionParameters(destination *storage.CacheKeyQueryStringActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// QueryParameters
	destination.QueryParameters = genruntime.ClonePointerToString(parameters.QueryParameters)

	// QueryStringBehavior
	destination.QueryStringBehavior = genruntime.ClonePointerToString(parameters.QueryStringBehavior)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForCacheKeyQueryStringActionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForCacheKeyQueryStringActionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.CacheKeyQueryStringActionParameters_STATUS
// Defines the parameters for the cache-key query string action.
type CacheKeyQueryStringActionParameters_STATUS struct {
	PropertyBag         genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	QueryParameters     *string                `json:"queryParameters,omitempty"`
	QueryStringBehavior *string                `json:"queryStringBehavior,omitempty"`
	TypeName            *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_CacheKeyQueryStringActionParameters_STATUS populates our CacheKeyQueryStringActionParameters_STATUS from the provided source CacheKeyQueryStringActionParameters_STATUS
func (parameters *CacheKeyQueryStringActionParameters_STATUS) AssignProperties_From_CacheKeyQueryStringActionParameters_STATUS(source *storage.CacheKeyQueryStringActionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// QueryParameters
	parameters.QueryParameters = genruntime.ClonePointerToString(source.QueryParameters)

	// QueryStringBehavior
	parameters.QueryStringBehavior = genruntime.ClonePointerToString(source.QueryStringBehavior)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForCacheKeyQueryStringActionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForCacheKeyQueryStringActionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_CacheKeyQueryStringActionParameters_STATUS populates the provided destination CacheKeyQueryStringActionParameters_STATUS from our CacheKeyQueryStringActionParameters_STATUS
func (parameters *CacheKeyQueryStringActionParameters_STATUS) AssignProperties_To_CacheKeyQueryStringActionParameters_STATUS(destination *storage.CacheKeyQueryStringActionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// QueryParameters
	destination.QueryParameters = genruntime.ClonePointerToString(parameters.QueryParameters)

	// QueryStringBehavior
	destination.QueryStringBehavior = genruntime.ClonePointerToString(parameters.QueryStringBehavior)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForCacheKeyQueryStringActionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForCacheKeyQueryStringActionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.ClientPortMatchConditionParameters
// Defines the parameters for ClientPort match conditions
type ClientPortMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_ClientPortMatchConditionParameters populates our ClientPortMatchConditionParameters from the provided source ClientPortMatchConditionParameters
func (parameters *ClientPortMatchConditionParameters) AssignProperties_From_ClientPortMatchConditionParameters(source *storage.ClientPortMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForClientPortMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForClientPortMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ClientPortMatchConditionParameters populates the provided destination ClientPortMatchConditionParameters from our ClientPortMatchConditionParameters
func (parameters *ClientPortMatchConditionParameters) AssignProperties_To_ClientPortMatchConditionParameters(destination *storage.ClientPortMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForClientPortMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForClientPortMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.ClientPortMatchConditionParameters_STATUS
// Defines the parameters for ClientPort match conditions
type ClientPortMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_ClientPortMatchConditionParameters_STATUS populates our ClientPortMatchConditionParameters_STATUS from the provided source ClientPortMatchConditionParameters_STATUS
func (parameters *ClientPortMatchConditionParameters_STATUS) AssignProperties_From_ClientPortMatchConditionParameters_STATUS(source *storage.ClientPortMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForClientPortMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForClientPortMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ClientPortMatchConditionParameters_STATUS populates the provided destination ClientPortMatchConditionParameters_STATUS from our ClientPortMatchConditionParameters_STATUS
func (parameters *ClientPortMatchConditionParameters_STATUS) AssignProperties_To_ClientPortMatchConditionParameters_STATUS(destination *storage.ClientPortMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForClientPortMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForClientPortMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.CookiesMatchConditionParameters
// Defines the parameters for Cookies match conditions
type CookiesMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Selector        *string                `json:"selector,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_CookiesMatchConditionParameters populates our CookiesMatchConditionParameters from the provided source CookiesMatchConditionParameters
func (parameters *CookiesMatchConditionParameters) AssignProperties_From_CookiesMatchConditionParameters(source *storage.CookiesMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Selector
	parameters.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForCookiesMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForCookiesMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_CookiesMatchConditionParameters populates the provided destination CookiesMatchConditionParameters from our CookiesMatchConditionParameters
func (parameters *CookiesMatchConditionParameters) AssignProperties_To_CookiesMatchConditionParameters(destination *storage.CookiesMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Selector
	destination.Selector = genruntime.ClonePointerToString(parameters.Selector)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForCookiesMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForCookiesMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.CookiesMatchConditionParameters_STATUS
// Defines the parameters for Cookies match conditions
type CookiesMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Selector        *string                `json:"selector,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_CookiesMatchConditionParameters_STATUS populates our CookiesMatchConditionParameters_STATUS from the provided source CookiesMatchConditionParameters_STATUS
func (parameters *CookiesMatchConditionParameters_STATUS) AssignProperties_From_CookiesMatchConditionParameters_STATUS(source *storage.CookiesMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Selector
	parameters.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForCookiesMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForCookiesMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_CookiesMatchConditionParameters_STATUS populates the provided destination CookiesMatchConditionParameters_STATUS from our CookiesMatchConditionParameters_STATUS
func (parameters *CookiesMatchConditionParameters_STATUS) AssignProperties_To_CookiesMatchConditionParameters_STATUS(destination *storage.CookiesMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Selector
	destination.Selector = genruntime.ClonePointerToString(parameters.Selector)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForCookiesMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForCookiesMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.HeaderActionParameters
// Defines the parameters for the request header action.
type HeaderActionParameters struct {
	HeaderAction *string                `json:"headerAction,omitempty"`
	HeaderName   *string                `json:"headerName,omitempty"`
	PropertyBag  genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	TypeName     *string                `json:"typeName,omitempty"`
	Value        *string                `json:"value,omitempty"`
}

// AssignProperties_From_HeaderActionParameters populates our HeaderActionParameters from the provided source HeaderActionParameters
func (parameters *HeaderActionParameters) AssignProperties_From_HeaderActionParameters(source *storage.HeaderActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// HeaderAction
	parameters.HeaderAction = genruntime.ClonePointerToString(source.HeaderAction)

	// HeaderName
	parameters.HeaderName = genruntime.ClonePointerToString(source.HeaderName)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Value
	parameters.Value = genruntime.ClonePointerToString(source.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForHeaderActionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHeaderActionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_HeaderActionParameters populates the provided destination HeaderActionParameters from our HeaderActionParameters
func (parameters *HeaderActionParameters) AssignProperties_To_HeaderActionParameters(destination *storage.HeaderActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// HeaderAction
	destination.HeaderAction = genruntime.ClonePointerToString(parameters.HeaderAction)

	// HeaderName
	destination.HeaderName = genruntime.ClonePointerToString(parameters.HeaderName)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Value
	destination.Value = genruntime.ClonePointerToString(parameters.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForHeaderActionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHeaderActionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.HeaderActionParameters_STATUS
// Defines the parameters for the request header action.
type HeaderActionParameters_STATUS struct {
	HeaderAction *string                `json:"headerAction,omitempty"`
	HeaderName   *string                `json:"headerName,omitempty"`
	PropertyBag  genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	TypeName     *string                `json:"typeName,omitempty"`
	Value        *string                `json:"value,omitempty"`
}

// AssignProperties_From_HeaderActionParameters_STATUS populates our HeaderActionParameters_STATUS from the provided source HeaderActionParameters_STATUS
func (parameters *HeaderActionParameters_STATUS) AssignProperties_From_HeaderActionParameters_STATUS(source *storage.HeaderActionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// HeaderAction
	parameters.HeaderAction = genruntime.ClonePointerToString(source.HeaderAction)

	// HeaderName
	parameters.HeaderName = genruntime.ClonePointerToString(source.HeaderName)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Value
	parameters.Value = genruntime.ClonePointerToString(source.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForHeaderActionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHeaderActionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_HeaderActionParameters_STATUS populates the provided destination HeaderActionParameters_STATUS from our HeaderActionParameters_STATUS
func (parameters *HeaderActionParameters_STATUS) AssignProperties_To_HeaderActionParameters_STATUS(destination *storage.HeaderActionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// HeaderAction
	destination.HeaderAction = genruntime.ClonePointerToString(parameters.HeaderAction)

	// HeaderName
	destination.HeaderName = genruntime.ClonePointerToString(parameters.HeaderName)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Value
	destination.Value = genruntime.ClonePointerToString(parameters.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForHeaderActionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHeaderActionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.HostNameMatchConditionParameters
// Defines the parameters for HostName match conditions
type HostNameMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_HostNameMatchConditionParameters populates our HostNameMatchConditionParameters from the provided source HostNameMatchConditionParameters
func (parameters *HostNameMatchConditionParameters) AssignProperties_From_HostNameMatchConditionParameters(source *storage.HostNameMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForHostNameMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHostNameMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_HostNameMatchConditionParameters populates the provided destination HostNameMatchConditionParameters from our HostNameMatchConditionParameters
func (parameters *HostNameMatchConditionParameters) AssignProperties_To_HostNameMatchConditionParameters(destination *storage.HostNameMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForHostNameMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHostNameMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.HostNameMatchConditionParameters_STATUS
// Defines the parameters for HostName match conditions
type HostNameMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_HostNameMatchConditionParameters_STATUS populates our HostNameMatchConditionParameters_STATUS from the provided source HostNameMatchConditionParameters_STATUS
func (parameters *HostNameMatchConditionParameters_STATUS) AssignProperties_From_HostNameMatchConditionParameters_STATUS(source *storage.HostNameMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForHostNameMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHostNameMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_HostNameMatchConditionParameters_STATUS populates the provided destination HostNameMatchConditionParameters_STATUS from our HostNameMatchConditionParameters_STATUS
func (parameters *HostNameMatchConditionParameters_STATUS) AssignProperties_To_HostNameMatchConditionParameters_STATUS(destination *storage.HostNameMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForHostNameMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHostNameMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.HttpVersionMatchConditionParameters
// Defines the parameters for HttpVersion match conditions
type HttpVersionMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_HttpVersionMatchConditionParameters populates our HttpVersionMatchConditionParameters from the provided source HttpVersionMatchConditionParameters
func (parameters *HttpVersionMatchConditionParameters) AssignProperties_From_HttpVersionMatchConditionParameters(source *storage.HttpVersionMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForHttpVersionMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHttpVersionMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_HttpVersionMatchConditionParameters populates the provided destination HttpVersionMatchConditionParameters from our HttpVersionMatchConditionParameters
func (parameters *HttpVersionMatchConditionParameters) AssignProperties_To_HttpVersionMatchConditionParameters(destination *storage.HttpVersionMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForHttpVersionMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHttpVersionMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.HttpVersionMatchConditionParameters_STATUS
// Defines the parameters for HttpVersion match conditions
type HttpVersionMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_HttpVersionMatchConditionParameters_STATUS populates our HttpVersionMatchConditionParameters_STATUS from the provided source HttpVersionMatchConditionParameters_STATUS
func (parameters *HttpVersionMatchConditionParameters_STATUS) AssignProperties_From_HttpVersionMatchConditionParameters_STATUS(source *storage.HttpVersionMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForHttpVersionMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHttpVersionMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_HttpVersionMatchConditionParameters_STATUS populates the provided destination HttpVersionMatchConditionParameters_STATUS from our HttpVersionMatchConditionParameters_STATUS
func (parameters *HttpVersionMatchConditionParameters_STATUS) AssignProperties_To_HttpVersionMatchConditionParameters_STATUS(destination *storage.HttpVersionMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForHttpVersionMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHttpVersionMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.IsDeviceMatchConditionParameters
// Defines the parameters for IsDevice match conditions
type IsDeviceMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_IsDeviceMatchConditionParameters populates our IsDeviceMatchConditionParameters from the provided source IsDeviceMatchConditionParameters
func (parameters *IsDeviceMatchConditionParameters) AssignProperties_From_IsDeviceMatchConditionParameters(source *storage.IsDeviceMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForIsDeviceMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForIsDeviceMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_IsDeviceMatchConditionParameters populates the provided destination IsDeviceMatchConditionParameters from our IsDeviceMatchConditionParameters
func (parameters *IsDeviceMatchConditionParameters) AssignProperties_To_IsDeviceMatchConditionParameters(destination *storage.IsDeviceMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForIsDeviceMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForIsDeviceMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.IsDeviceMatchConditionParameters_STATUS
// Defines the parameters for IsDevice match conditions
type IsDeviceMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_IsDeviceMatchConditionParameters_STATUS populates our IsDeviceMatchConditionParameters_STATUS from the provided source IsDeviceMatchConditionParameters_STATUS
func (parameters *IsDeviceMatchConditionParameters_STATUS) AssignProperties_From_IsDeviceMatchConditionParameters_STATUS(source *storage.IsDeviceMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForIsDeviceMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForIsDeviceMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_IsDeviceMatchConditionParameters_STATUS populates the provided destination IsDeviceMatchConditionParameters_STATUS from our IsDeviceMatchConditionParameters_STATUS
func (parameters *IsDeviceMatchConditionParameters_STATUS) AssignProperties_To_IsDeviceMatchConditionParameters_STATUS(destination *storage.IsDeviceMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForIsDeviceMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForIsDeviceMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.OriginGroupOverrideActionParameters
// Defines the parameters for the origin group override action.
type OriginGroupOverrideActionParameters struct {
	OriginGroup *ResourceReference     `json:"originGroup,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	TypeName    *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_OriginGroupOverrideActionParameters populates our OriginGroupOverrideActionParameters from the provided source OriginGroupOverrideActionParameters
func (parameters *OriginGroupOverrideActionParameters) AssignProperties_From_OriginGroupOverrideActionParameters(source *storage.OriginGroupOverrideActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// OriginGroup
	if source.OriginGroup != nil {
		var originGroup ResourceReference
		err := originGroup.AssignProperties_From_ResourceReference(source.OriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceReference() to populate field OriginGroup")
		}
		parameters.OriginGroup = &originGroup
	} else {
		parameters.OriginGroup = nil
	}

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForOriginGroupOverrideActionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForOriginGroupOverrideActionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_OriginGroupOverrideActionParameters populates the provided destination OriginGroupOverrideActionParameters from our OriginGroupOverrideActionParameters
func (parameters *OriginGroupOverrideActionParameters) AssignProperties_To_OriginGroupOverrideActionParameters(destination *storage.OriginGroupOverrideActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// OriginGroup
	if parameters.OriginGroup != nil {
		var originGroup storage.ResourceReference
		err := parameters.OriginGroup.AssignProperties_To_ResourceReference(&originGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceReference() to populate field OriginGroup")
		}
		destination.OriginGroup = &originGroup
	} else {
		destination.OriginGroup = nil
	}

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForOriginGroupOverrideActionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForOriginGroupOverrideActionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.OriginGroupOverrideActionParameters_STATUS
// Defines the parameters for the origin group override action.
type OriginGroupOverrideActionParameters_STATUS struct {
	OriginGroup *ResourceReference_STATUS `json:"originGroup,omitempty"`
	PropertyBag genruntime.PropertyBag    `json:"$propertyBag,omitempty"`
	TypeName    *string                   `json:"typeName,omitempty"`
}

// AssignProperties_From_OriginGroupOverrideActionParameters_STATUS populates our OriginGroupOverrideActionParameters_STATUS from the provided source OriginGroupOverrideActionParameters_STATUS
func (parameters *OriginGroupOverrideActionParameters_STATUS) AssignProperties_From_OriginGroupOverrideActionParameters_STATUS(source *storage.OriginGroupOverrideActionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// OriginGroup
	if source.OriginGroup != nil {
		var originGroup ResourceReference_STATUS
		err := originGroup.AssignProperties_From_ResourceReference_STATUS(source.OriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceReference_STATUS() to populate field OriginGroup")
		}
		parameters.OriginGroup = &originGroup
	} else {
		parameters.OriginGroup = nil
	}

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForOriginGroupOverrideActionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForOriginGroupOverrideActionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_OriginGroupOverrideActionParameters_STATUS populates the provided destination OriginGroupOverrideActionParameters_STATUS from our OriginGroupOverrideActionParameters_STATUS
func (parameters *OriginGroupOverrideActionParameters_STATUS) AssignProperties_To_OriginGroupOverrideActionParameters_STATUS(destination *storage.OriginGroupOverrideActionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// OriginGroup
	if parameters.OriginGroup != nil {
		var originGroup storage.ResourceReference_STATUS
		err := parameters.OriginGroup.AssignProperties_To_ResourceReference_STATUS(&originGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceReference_STATUS() to populate field OriginGroup")
		}
		destination.OriginGroup = &originGroup
	} else {
		destination.OriginGroup = nil
	}

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForOriginGroupOverrideActionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForOriginGroupOverrideActionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.PostArgsMatchConditionParameters
// Defines the parameters for PostArgs match conditions
type PostArgsMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Selector        *string                `json:"selector,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_PostArgsMatchConditionParameters populates our PostArgsMatchConditionParameters from the provided source PostArgsMatchConditionParameters
func (parameters *PostArgsMatchConditionParameters) AssignProperties_From_PostArgsMatchConditionParameters(source *storage.PostArgsMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Selector
	parameters.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForPostArgsMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForPostArgsMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_PostArgsMatchConditionParameters populates the provided destination PostArgsMatchConditionParameters from our PostArgsMatchConditionParameters
func (parameters *PostArgsMatchConditionParameters) AssignProperties_To_PostArgsMatchConditionParameters(destination *storage.PostArgsMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Selector
	destination.Selector = genruntime.ClonePointerToString(parameters.Selector)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForPostArgsMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForPostArgsMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.PostArgsMatchConditionParameters_STATUS
// Defines the parameters for PostArgs match conditions
type PostArgsMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Selector        *string                `json:"selector,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_PostArgsMatchConditionParameters_STATUS populates our PostArgsMatchConditionParameters_STATUS from the provided source PostArgsMatchConditionParameters_STATUS
func (parameters *PostArgsMatchConditionParameters_STATUS) AssignProperties_From_PostArgsMatchConditionParameters_STATUS(source *storage.PostArgsMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Selector
	parameters.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForPostArgsMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForPostArgsMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_PostArgsMatchConditionParameters_STATUS populates the provided destination PostArgsMatchConditionParameters_STATUS from our PostArgsMatchConditionParameters_STATUS
func (parameters *PostArgsMatchConditionParameters_STATUS) AssignProperties_To_PostArgsMatchConditionParameters_STATUS(destination *storage.PostArgsMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Selector
	destination.Selector = genruntime.ClonePointerToString(parameters.Selector)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForPostArgsMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForPostArgsMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.QueryStringMatchConditionParameters
// Defines the parameters for QueryString match conditions
type QueryStringMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_QueryStringMatchConditionParameters populates our QueryStringMatchConditionParameters from the provided source QueryStringMatchConditionParameters
func (parameters *QueryStringMatchConditionParameters) AssignProperties_From_QueryStringMatchConditionParameters(source *storage.QueryStringMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForQueryStringMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForQueryStringMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_QueryStringMatchConditionParameters populates the provided destination QueryStringMatchConditionParameters from our QueryStringMatchConditionParameters
func (parameters *QueryStringMatchConditionParameters) AssignProperties_To_QueryStringMatchConditionParameters(destination *storage.QueryStringMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForQueryStringMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForQueryStringMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.QueryStringMatchConditionParameters_STATUS
// Defines the parameters for QueryString match conditions
type QueryStringMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_QueryStringMatchConditionParameters_STATUS populates our QueryStringMatchConditionParameters_STATUS from the provided source QueryStringMatchConditionParameters_STATUS
func (parameters *QueryStringMatchConditionParameters_STATUS) AssignProperties_From_QueryStringMatchConditionParameters_STATUS(source *storage.QueryStringMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForQueryStringMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForQueryStringMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_QueryStringMatchConditionParameters_STATUS populates the provided destination QueryStringMatchConditionParameters_STATUS from our QueryStringMatchConditionParameters_STATUS
func (parameters *QueryStringMatchConditionParameters_STATUS) AssignProperties_To_QueryStringMatchConditionParameters_STATUS(destination *storage.QueryStringMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForQueryStringMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForQueryStringMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.RemoteAddressMatchConditionParameters
// Defines the parameters for RemoteAddress match conditions
type RemoteAddressMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_RemoteAddressMatchConditionParameters populates our RemoteAddressMatchConditionParameters from the provided source RemoteAddressMatchConditionParameters
func (parameters *RemoteAddressMatchConditionParameters) AssignProperties_From_RemoteAddressMatchConditionParameters(source *storage.RemoteAddressMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForRemoteAddressMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRemoteAddressMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_RemoteAddressMatchConditionParameters populates the provided destination RemoteAddressMatchConditionParameters from our RemoteAddressMatchConditionParameters
func (parameters *RemoteAddressMatchConditionParameters) AssignProperties_To_RemoteAddressMatchConditionParameters(destination *storage.RemoteAddressMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForRemoteAddressMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRemoteAddressMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.RemoteAddressMatchConditionParameters_STATUS
// Defines the parameters for RemoteAddress match conditions
type RemoteAddressMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_RemoteAddressMatchConditionParameters_STATUS populates our RemoteAddressMatchConditionParameters_STATUS from the provided source RemoteAddressMatchConditionParameters_STATUS
func (parameters *RemoteAddressMatchConditionParameters_STATUS) AssignProperties_From_RemoteAddressMatchConditionParameters_STATUS(source *storage.RemoteAddressMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForRemoteAddressMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRemoteAddressMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_RemoteAddressMatchConditionParameters_STATUS populates the provided destination RemoteAddressMatchConditionParameters_STATUS from our RemoteAddressMatchConditionParameters_STATUS
func (parameters *RemoteAddressMatchConditionParameters_STATUS) AssignProperties_To_RemoteAddressMatchConditionParameters_STATUS(destination *storage.RemoteAddressMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForRemoteAddressMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRemoteAddressMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.RequestBodyMatchConditionParameters
// Defines the parameters for RequestBody match conditions
type RequestBodyMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_RequestBodyMatchConditionParameters populates our RequestBodyMatchConditionParameters from the provided source RequestBodyMatchConditionParameters
func (parameters *RequestBodyMatchConditionParameters) AssignProperties_From_RequestBodyMatchConditionParameters(source *storage.RequestBodyMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestBodyMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestBodyMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_RequestBodyMatchConditionParameters populates the provided destination RequestBodyMatchConditionParameters from our RequestBodyMatchConditionParameters
func (parameters *RequestBodyMatchConditionParameters) AssignProperties_To_RequestBodyMatchConditionParameters(destination *storage.RequestBodyMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestBodyMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestBodyMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.RequestBodyMatchConditionParameters_STATUS
// Defines the parameters for RequestBody match conditions
type RequestBodyMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_RequestBodyMatchConditionParameters_STATUS populates our RequestBodyMatchConditionParameters_STATUS from the provided source RequestBodyMatchConditionParameters_STATUS
func (parameters *RequestBodyMatchConditionParameters_STATUS) AssignProperties_From_RequestBodyMatchConditionParameters_STATUS(source *storage.RequestBodyMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestBodyMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestBodyMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_RequestBodyMatchConditionParameters_STATUS populates the provided destination RequestBodyMatchConditionParameters_STATUS from our RequestBodyMatchConditionParameters_STATUS
func (parameters *RequestBodyMatchConditionParameters_STATUS) AssignProperties_To_RequestBodyMatchConditionParameters_STATUS(destination *storage.RequestBodyMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestBodyMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestBodyMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.RequestHeaderMatchConditionParameters
// Defines the parameters for RequestHeader match conditions
type RequestHeaderMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Selector        *string                `json:"selector,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_RequestHeaderMatchConditionParameters populates our RequestHeaderMatchConditionParameters from the provided source RequestHeaderMatchConditionParameters
func (parameters *RequestHeaderMatchConditionParameters) AssignProperties_From_RequestHeaderMatchConditionParameters(source *storage.RequestHeaderMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Selector
	parameters.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestHeaderMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestHeaderMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_RequestHeaderMatchConditionParameters populates the provided destination RequestHeaderMatchConditionParameters from our RequestHeaderMatchConditionParameters
func (parameters *RequestHeaderMatchConditionParameters) AssignProperties_To_RequestHeaderMatchConditionParameters(destination *storage.RequestHeaderMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Selector
	destination.Selector = genruntime.ClonePointerToString(parameters.Selector)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestHeaderMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestHeaderMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.RequestHeaderMatchConditionParameters_STATUS
// Defines the parameters for RequestHeader match conditions
type RequestHeaderMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Selector        *string                `json:"selector,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_RequestHeaderMatchConditionParameters_STATUS populates our RequestHeaderMatchConditionParameters_STATUS from the provided source RequestHeaderMatchConditionParameters_STATUS
func (parameters *RequestHeaderMatchConditionParameters_STATUS) AssignProperties_From_RequestHeaderMatchConditionParameters_STATUS(source *storage.RequestHeaderMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Selector
	parameters.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestHeaderMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestHeaderMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_RequestHeaderMatchConditionParameters_STATUS populates the provided destination RequestHeaderMatchConditionParameters_STATUS from our RequestHeaderMatchConditionParameters_STATUS
func (parameters *RequestHeaderMatchConditionParameters_STATUS) AssignProperties_To_RequestHeaderMatchConditionParameters_STATUS(destination *storage.RequestHeaderMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Selector
	destination.Selector = genruntime.ClonePointerToString(parameters.Selector)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestHeaderMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestHeaderMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.RequestMethodMatchConditionParameters
// Defines the parameters for RequestMethod match conditions
type RequestMethodMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_RequestMethodMatchConditionParameters populates our RequestMethodMatchConditionParameters from the provided source RequestMethodMatchConditionParameters
func (parameters *RequestMethodMatchConditionParameters) AssignProperties_From_RequestMethodMatchConditionParameters(source *storage.RequestMethodMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestMethodMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestMethodMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_RequestMethodMatchConditionParameters populates the provided destination RequestMethodMatchConditionParameters from our RequestMethodMatchConditionParameters
func (parameters *RequestMethodMatchConditionParameters) AssignProperties_To_RequestMethodMatchConditionParameters(destination *storage.RequestMethodMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestMethodMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestMethodMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.RequestMethodMatchConditionParameters_STATUS
// Defines the parameters for RequestMethod match conditions
type RequestMethodMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_RequestMethodMatchConditionParameters_STATUS populates our RequestMethodMatchConditionParameters_STATUS from the provided source RequestMethodMatchConditionParameters_STATUS
func (parameters *RequestMethodMatchConditionParameters_STATUS) AssignProperties_From_RequestMethodMatchConditionParameters_STATUS(source *storage.RequestMethodMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestMethodMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestMethodMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_RequestMethodMatchConditionParameters_STATUS populates the provided destination RequestMethodMatchConditionParameters_STATUS from our RequestMethodMatchConditionParameters_STATUS
func (parameters *RequestMethodMatchConditionParameters_STATUS) AssignProperties_To_RequestMethodMatchConditionParameters_STATUS(destination *storage.RequestMethodMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestMethodMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestMethodMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.RequestSchemeMatchConditionParameters
// Defines the parameters for RequestScheme match conditions
type RequestSchemeMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_RequestSchemeMatchConditionParameters populates our RequestSchemeMatchConditionParameters from the provided source RequestSchemeMatchConditionParameters
func (parameters *RequestSchemeMatchConditionParameters) AssignProperties_From_RequestSchemeMatchConditionParameters(source *storage.RequestSchemeMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestSchemeMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestSchemeMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_RequestSchemeMatchConditionParameters populates the provided destination RequestSchemeMatchConditionParameters from our RequestSchemeMatchConditionParameters
func (parameters *RequestSchemeMatchConditionParameters) AssignProperties_To_RequestSchemeMatchConditionParameters(destination *storage.RequestSchemeMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestSchemeMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestSchemeMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.RequestSchemeMatchConditionParameters_STATUS
// Defines the parameters for RequestScheme match conditions
type RequestSchemeMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_RequestSchemeMatchConditionParameters_STATUS populates our RequestSchemeMatchConditionParameters_STATUS from the provided source RequestSchemeMatchConditionParameters_STATUS
func (parameters *RequestSchemeMatchConditionParameters_STATUS) AssignProperties_From_RequestSchemeMatchConditionParameters_STATUS(source *storage.RequestSchemeMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestSchemeMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestSchemeMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_RequestSchemeMatchConditionParameters_STATUS populates the provided destination RequestSchemeMatchConditionParameters_STATUS from our RequestSchemeMatchConditionParameters_STATUS
func (parameters *RequestSchemeMatchConditionParameters_STATUS) AssignProperties_To_RequestSchemeMatchConditionParameters_STATUS(destination *storage.RequestSchemeMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestSchemeMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestSchemeMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.RequestUriMatchConditionParameters
// Defines the parameters for RequestUri match conditions
type RequestUriMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_RequestUriMatchConditionParameters populates our RequestUriMatchConditionParameters from the provided source RequestUriMatchConditionParameters
func (parameters *RequestUriMatchConditionParameters) AssignProperties_From_RequestUriMatchConditionParameters(source *storage.RequestUriMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestUriMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestUriMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_RequestUriMatchConditionParameters populates the provided destination RequestUriMatchConditionParameters from our RequestUriMatchConditionParameters
func (parameters *RequestUriMatchConditionParameters) AssignProperties_To_RequestUriMatchConditionParameters(destination *storage.RequestUriMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestUriMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestUriMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.RequestUriMatchConditionParameters_STATUS
// Defines the parameters for RequestUri match conditions
type RequestUriMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_RequestUriMatchConditionParameters_STATUS populates our RequestUriMatchConditionParameters_STATUS from the provided source RequestUriMatchConditionParameters_STATUS
func (parameters *RequestUriMatchConditionParameters_STATUS) AssignProperties_From_RequestUriMatchConditionParameters_STATUS(source *storage.RequestUriMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestUriMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestUriMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_RequestUriMatchConditionParameters_STATUS populates the provided destination RequestUriMatchConditionParameters_STATUS from our RequestUriMatchConditionParameters_STATUS
func (parameters *RequestUriMatchConditionParameters_STATUS) AssignProperties_To_RequestUriMatchConditionParameters_STATUS(destination *storage.RequestUriMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestUriMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestUriMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.RouteConfigurationOverrideActionParameters
// Defines the parameters for the route configuration override action.
type RouteConfigurationOverrideActionParameters struct {
	CacheConfiguration  *CacheConfiguration    `json:"cacheConfiguration,omitempty"`
	OriginGroupOverride *OriginGroupOverride   `json:"originGroupOverride,omitempty"`
	PropertyBag         genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	TypeName            *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_RouteConfigurationOverrideActionParameters populates our RouteConfigurationOverrideActionParameters from the provided source RouteConfigurationOverrideActionParameters
func (parameters *RouteConfigurationOverrideActionParameters) AssignProperties_From_RouteConfigurationOverrideActionParameters(source *storage.RouteConfigurationOverrideActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CacheConfiguration
	if source.CacheConfiguration != nil {
		var cacheConfiguration CacheConfiguration
		err := cacheConfiguration.AssignProperties_From_CacheConfiguration(source.CacheConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CacheConfiguration() to populate field CacheConfiguration")
		}
		parameters.CacheConfiguration = &cacheConfiguration
	} else {
		parameters.CacheConfiguration = nil
	}

	// OriginGroupOverride
	if source.OriginGroupOverride != nil {
		var originGroupOverride OriginGroupOverride
		err := originGroupOverride.AssignProperties_From_OriginGroupOverride(source.OriginGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OriginGroupOverride() to populate field OriginGroupOverride")
		}
		parameters.OriginGroupOverride = &originGroupOverride
	} else {
		parameters.OriginGroupOverride = nil
	}

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForRouteConfigurationOverrideActionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRouteConfigurationOverrideActionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_RouteConfigurationOverrideActionParameters populates the provided destination RouteConfigurationOverrideActionParameters from our RouteConfigurationOverrideActionParameters
func (parameters *RouteConfigurationOverrideActionParameters) AssignProperties_To_RouteConfigurationOverrideActionParameters(destination *storage.RouteConfigurationOverrideActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// CacheConfiguration
	if parameters.CacheConfiguration != nil {
		var cacheConfiguration storage.CacheConfiguration
		err := parameters.CacheConfiguration.AssignProperties_To_CacheConfiguration(&cacheConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CacheConfiguration() to populate field CacheConfiguration")
		}
		destination.CacheConfiguration = &cacheConfiguration
	} else {
		destination.CacheConfiguration = nil
	}

	// OriginGroupOverride
	if parameters.OriginGroupOverride != nil {
		var originGroupOverride storage.OriginGroupOverride
		err := parameters.OriginGroupOverride.AssignProperties_To_OriginGroupOverride(&originGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OriginGroupOverride() to populate field OriginGroupOverride")
		}
		destination.OriginGroupOverride = &originGroupOverride
	} else {
		destination.OriginGroupOverride = nil
	}

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForRouteConfigurationOverrideActionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRouteConfigurationOverrideActionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.RouteConfigurationOverrideActionParameters_STATUS
// Defines the parameters for the route configuration override action.
type RouteConfigurationOverrideActionParameters_STATUS struct {
	CacheConfiguration  *CacheConfiguration_STATUS  `json:"cacheConfiguration,omitempty"`
	OriginGroupOverride *OriginGroupOverride_STATUS `json:"originGroupOverride,omitempty"`
	PropertyBag         genruntime.PropertyBag      `json:"$propertyBag,omitempty"`
	TypeName            *string                     `json:"typeName,omitempty"`
}

// AssignProperties_From_RouteConfigurationOverrideActionParameters_STATUS populates our RouteConfigurationOverrideActionParameters_STATUS from the provided source RouteConfigurationOverrideActionParameters_STATUS
func (parameters *RouteConfigurationOverrideActionParameters_STATUS) AssignProperties_From_RouteConfigurationOverrideActionParameters_STATUS(source *storage.RouteConfigurationOverrideActionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CacheConfiguration
	if source.CacheConfiguration != nil {
		var cacheConfiguration CacheConfiguration_STATUS
		err := cacheConfiguration.AssignProperties_From_CacheConfiguration_STATUS(source.CacheConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CacheConfiguration_STATUS() to populate field CacheConfiguration")
		}
		parameters.CacheConfiguration = &cacheConfiguration
	} else {
		parameters.CacheConfiguration = nil
	}

	// OriginGroupOverride
	if source.OriginGroupOverride != nil {
		var originGroupOverride OriginGroupOverride_STATUS
		err := originGroupOverride.AssignProperties_From_OriginGroupOverride_STATUS(source.OriginGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OriginGroupOverride_STATUS() to populate field OriginGroupOverride")
		}
		parameters.OriginGroupOverride = &originGroupOverride
	} else {
		parameters.OriginGroupOverride = nil
	}

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForRouteConfigurationOverrideActionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRouteConfigurationOverrideActionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_RouteConfigurationOverrideActionParameters_STATUS populates the provided destination RouteConfigurationOverrideActionParameters_STATUS from our RouteConfigurationOverrideActionParameters_STATUS
func (parameters *RouteConfigurationOverrideActionParameters_STATUS) AssignProperties_To_RouteConfigurationOverrideActionParameters_STATUS(destination *storage.RouteConfigurationOverrideActionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// CacheConfiguration
	if parameters.CacheConfiguration != nil {
		var cacheConfiguration storage.CacheConfiguration_STATUS
		err := parameters.CacheConfiguration.AssignProperties_To_CacheConfiguration_STATUS(&cacheConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CacheConfiguration_STATUS() to populate field CacheConfiguration")
		}
		destination.CacheConfiguration = &cacheConfiguration
	} else {
		destination.CacheConfiguration = nil
	}

	// OriginGroupOverride
	if parameters.OriginGroupOverride != nil {
		var originGroupOverride storage.OriginGroupOverride_STATUS
		err := parameters.OriginGroupOverride.AssignProperties_To_OriginGroupOverride_STATUS(&originGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OriginGroupOverride_STATUS() to populate field OriginGroupOverride")
		}
		destination.OriginGroupOverride = &originGroupOverride
	} else {
		destination.OriginGroupOverride = nil
	}

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForRouteConfigurationOverrideActionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRouteConfigurationOverrideActionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.ServerPortMatchConditionParameters
// Defines the parameters for ServerPort match conditions
type ServerPortMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_ServerPortMatchConditionParameters populates our ServerPortMatchConditionParameters from the provided source ServerPortMatchConditionParameters
func (parameters *ServerPortMatchConditionParameters) AssignProperties_From_ServerPortMatchConditionParameters(source *storage.ServerPortMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForServerPortMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForServerPortMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ServerPortMatchConditionParameters populates the provided destination ServerPortMatchConditionParameters from our ServerPortMatchConditionParameters
func (parameters *ServerPortMatchConditionParameters) AssignProperties_To_ServerPortMatchConditionParameters(destination *storage.ServerPortMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForServerPortMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForServerPortMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.ServerPortMatchConditionParameters_STATUS
// Defines the parameters for ServerPort match conditions
type ServerPortMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_ServerPortMatchConditionParameters_STATUS populates our ServerPortMatchConditionParameters_STATUS from the provided source ServerPortMatchConditionParameters_STATUS
func (parameters *ServerPortMatchConditionParameters_STATUS) AssignProperties_From_ServerPortMatchConditionParameters_STATUS(source *storage.ServerPortMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForServerPortMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForServerPortMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ServerPortMatchConditionParameters_STATUS populates the provided destination ServerPortMatchConditionParameters_STATUS from our ServerPortMatchConditionParameters_STATUS
func (parameters *ServerPortMatchConditionParameters_STATUS) AssignProperties_To_ServerPortMatchConditionParameters_STATUS(destination *storage.ServerPortMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForServerPortMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForServerPortMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.SocketAddrMatchConditionParameters
// Defines the parameters for SocketAddress match conditions
type SocketAddrMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_SocketAddrMatchConditionParameters populates our SocketAddrMatchConditionParameters from the provided source SocketAddrMatchConditionParameters
func (parameters *SocketAddrMatchConditionParameters) AssignProperties_From_SocketAddrMatchConditionParameters(source *storage.SocketAddrMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForSocketAddrMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForSocketAddrMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_SocketAddrMatchConditionParameters populates the provided destination SocketAddrMatchConditionParameters from our SocketAddrMatchConditionParameters
func (parameters *SocketAddrMatchConditionParameters) AssignProperties_To_SocketAddrMatchConditionParameters(destination *storage.SocketAddrMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSocketAddrMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForSocketAddrMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.SocketAddrMatchConditionParameters_STATUS
// Defines the parameters for SocketAddress match conditions
type SocketAddrMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_SocketAddrMatchConditionParameters_STATUS populates our SocketAddrMatchConditionParameters_STATUS from the provided source SocketAddrMatchConditionParameters_STATUS
func (parameters *SocketAddrMatchConditionParameters_STATUS) AssignProperties_From_SocketAddrMatchConditionParameters_STATUS(source *storage.SocketAddrMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForSocketAddrMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForSocketAddrMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_SocketAddrMatchConditionParameters_STATUS populates the provided destination SocketAddrMatchConditionParameters_STATUS from our SocketAddrMatchConditionParameters_STATUS
func (parameters *SocketAddrMatchConditionParameters_STATUS) AssignProperties_To_SocketAddrMatchConditionParameters_STATUS(destination *storage.SocketAddrMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSocketAddrMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForSocketAddrMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.SslProtocolMatchConditionParameters
// Defines the parameters for SslProtocol match conditions
type SslProtocolMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_SslProtocolMatchConditionParameters populates our SslProtocolMatchConditionParameters from the provided source SslProtocolMatchConditionParameters
func (parameters *SslProtocolMatchConditionParameters) AssignProperties_From_SslProtocolMatchConditionParameters(source *storage.SslProtocolMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForSslProtocolMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForSslProtocolMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_SslProtocolMatchConditionParameters populates the provided destination SslProtocolMatchConditionParameters from our SslProtocolMatchConditionParameters
func (parameters *SslProtocolMatchConditionParameters) AssignProperties_To_SslProtocolMatchConditionParameters(destination *storage.SslProtocolMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSslProtocolMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForSslProtocolMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.SslProtocolMatchConditionParameters_STATUS
// Defines the parameters for SslProtocol match conditions
type SslProtocolMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_SslProtocolMatchConditionParameters_STATUS populates our SslProtocolMatchConditionParameters_STATUS from the provided source SslProtocolMatchConditionParameters_STATUS
func (parameters *SslProtocolMatchConditionParameters_STATUS) AssignProperties_From_SslProtocolMatchConditionParameters_STATUS(source *storage.SslProtocolMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForSslProtocolMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForSslProtocolMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_SslProtocolMatchConditionParameters_STATUS populates the provided destination SslProtocolMatchConditionParameters_STATUS from our SslProtocolMatchConditionParameters_STATUS
func (parameters *SslProtocolMatchConditionParameters_STATUS) AssignProperties_To_SslProtocolMatchConditionParameters_STATUS(destination *storage.SslProtocolMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSslProtocolMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForSslProtocolMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.UrlFileExtensionMatchConditionParameters
// Defines the parameters for UrlFileExtension match conditions
type UrlFileExtensionMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_UrlFileExtensionMatchConditionParameters populates our UrlFileExtensionMatchConditionParameters from the provided source UrlFileExtensionMatchConditionParameters
func (parameters *UrlFileExtensionMatchConditionParameters) AssignProperties_From_UrlFileExtensionMatchConditionParameters(source *storage.UrlFileExtensionMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlFileExtensionMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlFileExtensionMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlFileExtensionMatchConditionParameters populates the provided destination UrlFileExtensionMatchConditionParameters from our UrlFileExtensionMatchConditionParameters
func (parameters *UrlFileExtensionMatchConditionParameters) AssignProperties_To_UrlFileExtensionMatchConditionParameters(destination *storage.UrlFileExtensionMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlFileExtensionMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlFileExtensionMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.UrlFileExtensionMatchConditionParameters_STATUS
// Defines the parameters for UrlFileExtension match conditions
type UrlFileExtensionMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_UrlFileExtensionMatchConditionParameters_STATUS populates our UrlFileExtensionMatchConditionParameters_STATUS from the provided source UrlFileExtensionMatchConditionParameters_STATUS
func (parameters *UrlFileExtensionMatchConditionParameters_STATUS) AssignProperties_From_UrlFileExtensionMatchConditionParameters_STATUS(source *storage.UrlFileExtensionMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlFileExtensionMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlFileExtensionMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlFileExtensionMatchConditionParameters_STATUS populates the provided destination UrlFileExtensionMatchConditionParameters_STATUS from our UrlFileExtensionMatchConditionParameters_STATUS
func (parameters *UrlFileExtensionMatchConditionParameters_STATUS) AssignProperties_To_UrlFileExtensionMatchConditionParameters_STATUS(destination *storage.UrlFileExtensionMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlFileExtensionMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlFileExtensionMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.UrlFileNameMatchConditionParameters
// Defines the parameters for UrlFilename match conditions
type UrlFileNameMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_UrlFileNameMatchConditionParameters populates our UrlFileNameMatchConditionParameters from the provided source UrlFileNameMatchConditionParameters
func (parameters *UrlFileNameMatchConditionParameters) AssignProperties_From_UrlFileNameMatchConditionParameters(source *storage.UrlFileNameMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlFileNameMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlFileNameMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlFileNameMatchConditionParameters populates the provided destination UrlFileNameMatchConditionParameters from our UrlFileNameMatchConditionParameters
func (parameters *UrlFileNameMatchConditionParameters) AssignProperties_To_UrlFileNameMatchConditionParameters(destination *storage.UrlFileNameMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlFileNameMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlFileNameMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.UrlFileNameMatchConditionParameters_STATUS
// Defines the parameters for UrlFilename match conditions
type UrlFileNameMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_UrlFileNameMatchConditionParameters_STATUS populates our UrlFileNameMatchConditionParameters_STATUS from the provided source UrlFileNameMatchConditionParameters_STATUS
func (parameters *UrlFileNameMatchConditionParameters_STATUS) AssignProperties_From_UrlFileNameMatchConditionParameters_STATUS(source *storage.UrlFileNameMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlFileNameMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlFileNameMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlFileNameMatchConditionParameters_STATUS populates the provided destination UrlFileNameMatchConditionParameters_STATUS from our UrlFileNameMatchConditionParameters_STATUS
func (parameters *UrlFileNameMatchConditionParameters_STATUS) AssignProperties_To_UrlFileNameMatchConditionParameters_STATUS(destination *storage.UrlFileNameMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlFileNameMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlFileNameMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.UrlPathMatchConditionParameters
// Defines the parameters for UrlPath match conditions
type UrlPathMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_UrlPathMatchConditionParameters populates our UrlPathMatchConditionParameters from the provided source UrlPathMatchConditionParameters
func (parameters *UrlPathMatchConditionParameters) AssignProperties_From_UrlPathMatchConditionParameters(source *storage.UrlPathMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlPathMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlPathMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlPathMatchConditionParameters populates the provided destination UrlPathMatchConditionParameters from our UrlPathMatchConditionParameters
func (parameters *UrlPathMatchConditionParameters) AssignProperties_To_UrlPathMatchConditionParameters(destination *storage.UrlPathMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlPathMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlPathMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.UrlPathMatchConditionParameters_STATUS
// Defines the parameters for UrlPath match conditions
type UrlPathMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_UrlPathMatchConditionParameters_STATUS populates our UrlPathMatchConditionParameters_STATUS from the provided source UrlPathMatchConditionParameters_STATUS
func (parameters *UrlPathMatchConditionParameters_STATUS) AssignProperties_From_UrlPathMatchConditionParameters_STATUS(source *storage.UrlPathMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlPathMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlPathMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlPathMatchConditionParameters_STATUS populates the provided destination UrlPathMatchConditionParameters_STATUS from our UrlPathMatchConditionParameters_STATUS
func (parameters *UrlPathMatchConditionParameters_STATUS) AssignProperties_To_UrlPathMatchConditionParameters_STATUS(destination *storage.UrlPathMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlPathMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlPathMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.UrlRedirectActionParameters
// Defines the parameters for the url redirect action.
type UrlRedirectActionParameters struct {
	CustomFragment      *string                `json:"customFragment,omitempty"`
	CustomHostname      *string                `json:"customHostname,omitempty"`
	CustomPath          *string                `json:"customPath,omitempty"`
	CustomQueryString   *string                `json:"customQueryString,omitempty"`
	DestinationProtocol *string                `json:"destinationProtocol,omitempty"`
	PropertyBag         genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	RedirectType        *string                `json:"redirectType,omitempty"`
	TypeName            *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_UrlRedirectActionParameters populates our UrlRedirectActionParameters from the provided source UrlRedirectActionParameters
func (parameters *UrlRedirectActionParameters) AssignProperties_From_UrlRedirectActionParameters(source *storage.UrlRedirectActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CustomFragment
	parameters.CustomFragment = genruntime.ClonePointerToString(source.CustomFragment)

	// CustomHostname
	parameters.CustomHostname = genruntime.ClonePointerToString(source.CustomHostname)

	// CustomPath
	parameters.CustomPath = genruntime.ClonePointerToString(source.CustomPath)

	// CustomQueryString
	parameters.CustomQueryString = genruntime.ClonePointerToString(source.CustomQueryString)

	// DestinationProtocol
	parameters.DestinationProtocol = genruntime.ClonePointerToString(source.DestinationProtocol)

	// RedirectType
	parameters.RedirectType = genruntime.ClonePointerToString(source.RedirectType)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlRedirectActionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlRedirectActionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlRedirectActionParameters populates the provided destination UrlRedirectActionParameters from our UrlRedirectActionParameters
func (parameters *UrlRedirectActionParameters) AssignProperties_To_UrlRedirectActionParameters(destination *storage.UrlRedirectActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// CustomFragment
	destination.CustomFragment = genruntime.ClonePointerToString(parameters.CustomFragment)

	// CustomHostname
	destination.CustomHostname = genruntime.ClonePointerToString(parameters.CustomHostname)

	// CustomPath
	destination.CustomPath = genruntime.ClonePointerToString(parameters.CustomPath)

	// CustomQueryString
	destination.CustomQueryString = genruntime.ClonePointerToString(parameters.CustomQueryString)

	// DestinationProtocol
	destination.DestinationProtocol = genruntime.ClonePointerToString(parameters.DestinationProtocol)

	// RedirectType
	destination.RedirectType = genruntime.ClonePointerToString(parameters.RedirectType)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlRedirectActionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlRedirectActionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.UrlRedirectActionParameters_STATUS
// Defines the parameters for the url redirect action.
type UrlRedirectActionParameters_STATUS struct {
	CustomFragment      *string                `json:"customFragment,omitempty"`
	CustomHostname      *string                `json:"customHostname,omitempty"`
	CustomPath          *string                `json:"customPath,omitempty"`
	CustomQueryString   *string                `json:"customQueryString,omitempty"`
	DestinationProtocol *string                `json:"destinationProtocol,omitempty"`
	PropertyBag         genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	RedirectType        *string                `json:"redirectType,omitempty"`
	TypeName            *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_UrlRedirectActionParameters_STATUS populates our UrlRedirectActionParameters_STATUS from the provided source UrlRedirectActionParameters_STATUS
func (parameters *UrlRedirectActionParameters_STATUS) AssignProperties_From_UrlRedirectActionParameters_STATUS(source *storage.UrlRedirectActionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CustomFragment
	parameters.CustomFragment = genruntime.ClonePointerToString(source.CustomFragment)

	// CustomHostname
	parameters.CustomHostname = genruntime.ClonePointerToString(source.CustomHostname)

	// CustomPath
	parameters.CustomPath = genruntime.ClonePointerToString(source.CustomPath)

	// CustomQueryString
	parameters.CustomQueryString = genruntime.ClonePointerToString(source.CustomQueryString)

	// DestinationProtocol
	parameters.DestinationProtocol = genruntime.ClonePointerToString(source.DestinationProtocol)

	// RedirectType
	parameters.RedirectType = genruntime.ClonePointerToString(source.RedirectType)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlRedirectActionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlRedirectActionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlRedirectActionParameters_STATUS populates the provided destination UrlRedirectActionParameters_STATUS from our UrlRedirectActionParameters_STATUS
func (parameters *UrlRedirectActionParameters_STATUS) AssignProperties_To_UrlRedirectActionParameters_STATUS(destination *storage.UrlRedirectActionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// CustomFragment
	destination.CustomFragment = genruntime.ClonePointerToString(parameters.CustomFragment)

	// CustomHostname
	destination.CustomHostname = genruntime.ClonePointerToString(parameters.CustomHostname)

	// CustomPath
	destination.CustomPath = genruntime.ClonePointerToString(parameters.CustomPath)

	// CustomQueryString
	destination.CustomQueryString = genruntime.ClonePointerToString(parameters.CustomQueryString)

	// DestinationProtocol
	destination.DestinationProtocol = genruntime.ClonePointerToString(parameters.DestinationProtocol)

	// RedirectType
	destination.RedirectType = genruntime.ClonePointerToString(parameters.RedirectType)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlRedirectActionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlRedirectActionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.UrlRewriteActionParameters
// Defines the parameters for the url rewrite action.
type UrlRewriteActionParameters struct {
	Destination           *string                `json:"destination,omitempty"`
	PreserveUnmatchedPath *bool                  `json:"preserveUnmatchedPath,omitempty"`
	PropertyBag           genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SourcePattern         *string                `json:"sourcePattern,omitempty"`
	TypeName              *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_UrlRewriteActionParameters populates our UrlRewriteActionParameters from the provided source UrlRewriteActionParameters
func (parameters *UrlRewriteActionParameters) AssignProperties_From_UrlRewriteActionParameters(source *storage.UrlRewriteActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Destination
	parameters.Destination = genruntime.ClonePointerToString(source.Destination)

	// PreserveUnmatchedPath
	if source.PreserveUnmatchedPath != nil {
		preserveUnmatchedPath := *source.PreserveUnmatchedPath
		parameters.PreserveUnmatchedPath = &preserveUnmatchedPath
	} else {
		parameters.PreserveUnmatchedPath = nil
	}

	// SourcePattern
	parameters.SourcePattern = genruntime.ClonePointerToString(source.SourcePattern)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlRewriteActionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlRewriteActionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlRewriteActionParameters populates the provided destination UrlRewriteActionParameters from our UrlRewriteActionParameters
func (parameters *UrlRewriteActionParameters) AssignProperties_To_UrlRewriteActionParameters(destination *storage.UrlRewriteActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// Destination
	destination.Destination = genruntime.ClonePointerToString(parameters.Destination)

	// PreserveUnmatchedPath
	if parameters.PreserveUnmatchedPath != nil {
		preserveUnmatchedPath := *parameters.PreserveUnmatchedPath
		destination.PreserveUnmatchedPath = &preserveUnmatchedPath
	} else {
		destination.PreserveUnmatchedPath = nil
	}

	// SourcePattern
	destination.SourcePattern = genruntime.ClonePointerToString(parameters.SourcePattern)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlRewriteActionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlRewriteActionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.UrlRewriteActionParameters_STATUS
// Defines the parameters for the url rewrite action.
type UrlRewriteActionParameters_STATUS struct {
	Destination           *string                `json:"destination,omitempty"`
	PreserveUnmatchedPath *bool                  `json:"preserveUnmatchedPath,omitempty"`
	PropertyBag           genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SourcePattern         *string                `json:"sourcePattern,omitempty"`
	TypeName              *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_UrlRewriteActionParameters_STATUS populates our UrlRewriteActionParameters_STATUS from the provided source UrlRewriteActionParameters_STATUS
func (parameters *UrlRewriteActionParameters_STATUS) AssignProperties_From_UrlRewriteActionParameters_STATUS(source *storage.UrlRewriteActionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Destination
	parameters.Destination = genruntime.ClonePointerToString(source.Destination)

	// PreserveUnmatchedPath
	if source.PreserveUnmatchedPath != nil {
		preserveUnmatchedPath := *source.PreserveUnmatchedPath
		parameters.PreserveUnmatchedPath = &preserveUnmatchedPath
	} else {
		parameters.PreserveUnmatchedPath = nil
	}

	// SourcePattern
	parameters.SourcePattern = genruntime.ClonePointerToString(source.SourcePattern)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlRewriteActionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlRewriteActionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlRewriteActionParameters_STATUS populates the provided destination UrlRewriteActionParameters_STATUS from our UrlRewriteActionParameters_STATUS
func (parameters *UrlRewriteActionParameters_STATUS) AssignProperties_To_UrlRewriteActionParameters_STATUS(destination *storage.UrlRewriteActionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// Destination
	destination.Destination = genruntime.ClonePointerToString(parameters.Destination)

	// PreserveUnmatchedPath
	if parameters.PreserveUnmatchedPath != nil {
		preserveUnmatchedPath := *parameters.PreserveUnmatchedPath
		destination.PreserveUnmatchedPath = &preserveUnmatchedPath
	} else {
		destination.PreserveUnmatchedPath = nil
	}

	// SourcePattern
	destination.SourcePattern = genruntime.ClonePointerToString(parameters.SourcePattern)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlRewriteActionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlRewriteActionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.UrlSigningActionParameters
// Defines the parameters for the Url Signing action.
type UrlSigningActionParameters struct {
	Algorithm             *string                     `json:"algorithm,omitempty"`
	ParameterNameOverride []UrlSigningParamIdentifier `json:"parameterNameOverride,omitempty"`
	PropertyBag           genruntime.PropertyBag      `json:"$propertyBag,omitempty"`
	TypeName              *string                     `json:"typeName,omitempty"`
}

// AssignProperties_From_UrlSigningActionParameters populates our UrlSigningActionParameters from the provided source UrlSigningActionParameters
func (parameters *UrlSigningActionParameters) AssignProperties_From_UrlSigningActionParameters(source *storage.UrlSigningActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Algorithm
	parameters.Algorithm = genruntime.ClonePointerToString(source.Algorithm)

	// ParameterNameOverride
	if source.ParameterNameOverride != nil {
		parameterNameOverrideList := make([]UrlSigningParamIdentifier, len(source.ParameterNameOverride))
		for parameterNameOverrideIndex, parameterNameOverrideItem := range source.ParameterNameOverride {
			// Shadow the loop variable to avoid aliasing
			parameterNameOverrideItem := parameterNameOverrideItem
			var parameterNameOverride UrlSigningParamIdentifier
			err := parameterNameOverride.AssignProperties_From_UrlSigningParamIdentifier(&parameterNameOverrideItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_UrlSigningParamIdentifier() to populate field ParameterNameOverride")
			}
			parameterNameOverrideList[parameterNameOverrideIndex] = parameterNameOverride
		}
		parameters.ParameterNameOverride = parameterNameOverrideList
	} else {
		parameters.ParameterNameOverride = nil
	}

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlSigningActionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlSigningActionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlSigningActionParameters populates the provided destination UrlSigningActionParameters from our UrlSigningActionParameters
func (parameters *UrlSigningActionParameters) AssignProperties_To_UrlSigningActionParameters(destination *storage.UrlSigningActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// Algorithm
	destination.Algorithm = genruntime.ClonePointerToString(parameters.Algorithm)

	// ParameterNameOverride
	if parameters.ParameterNameOverride != nil {
		parameterNameOverrideList := make([]storage.UrlSigningParamIdentifier, len(parameters.ParameterNameOverride))
		for parameterNameOverrideIndex, parameterNameOverrideItem := range parameters.ParameterNameOverride {
			// Shadow the loop variable to avoid aliasing
			parameterNameOverrideItem := parameterNameOverrideItem
			var parameterNameOverride storage.UrlSigningParamIdentifier
			err := parameterNameOverrideItem.AssignProperties_To_UrlSigningParamIdentifier(&parameterNameOverride)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_UrlSigningParamIdentifier() to populate field ParameterNameOverride")
			}
			parameterNameOverrideList[parameterNameOverrideIndex] = parameterNameOverride
		}
		destination.ParameterNameOverride = parameterNameOverrideList
	} else {
		destination.ParameterNameOverride = nil
	}

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlSigningActionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlSigningActionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.UrlSigningActionParameters_STATUS
// Defines the parameters for the Url Signing action.
type UrlSigningActionParameters_STATUS struct {
	Algorithm             *string                            `json:"algorithm,omitempty"`
	ParameterNameOverride []UrlSigningParamIdentifier_STATUS `json:"parameterNameOverride,omitempty"`
	PropertyBag           genruntime.PropertyBag             `json:"$propertyBag,omitempty"`
	TypeName              *string                            `json:"typeName,omitempty"`
}

// AssignProperties_From_UrlSigningActionParameters_STATUS populates our UrlSigningActionParameters_STATUS from the provided source UrlSigningActionParameters_STATUS
func (parameters *UrlSigningActionParameters_STATUS) AssignProperties_From_UrlSigningActionParameters_STATUS(source *storage.UrlSigningActionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Algorithm
	parameters.Algorithm = genruntime.ClonePointerToString(source.Algorithm)

	// ParameterNameOverride
	if source.ParameterNameOverride != nil {
		parameterNameOverrideList := make([]UrlSigningParamIdentifier_STATUS, len(source.ParameterNameOverride))
		for parameterNameOverrideIndex, parameterNameOverrideItem := range source.ParameterNameOverride {
			// Shadow the loop variable to avoid aliasing
			parameterNameOverrideItem := parameterNameOverrideItem
			var parameterNameOverride UrlSigningParamIdentifier_STATUS
			err := parameterNameOverride.AssignProperties_From_UrlSigningParamIdentifier_STATUS(&parameterNameOverrideItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_UrlSigningParamIdentifier_STATUS() to populate field ParameterNameOverride")
			}
			parameterNameOverrideList[parameterNameOverrideIndex] = parameterNameOverride
		}
		parameters.ParameterNameOverride = parameterNameOverrideList
	} else {
		parameters.ParameterNameOverride = nil
	}

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlSigningActionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlSigningActionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlSigningActionParameters_STATUS populates the provided destination UrlSigningActionParameters_STATUS from our UrlSigningActionParameters_STATUS
func (parameters *UrlSigningActionParameters_STATUS) AssignProperties_To_UrlSigningActionParameters_STATUS(destination *storage.UrlSigningActionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// Algorithm
	destination.Algorithm = genruntime.ClonePointerToString(parameters.Algorithm)

	// ParameterNameOverride
	if parameters.ParameterNameOverride != nil {
		parameterNameOverrideList := make([]storage.UrlSigningParamIdentifier_STATUS, len(parameters.ParameterNameOverride))
		for parameterNameOverrideIndex, parameterNameOverrideItem := range parameters.ParameterNameOverride {
			// Shadow the loop variable to avoid aliasing
			parameterNameOverrideItem := parameterNameOverrideItem
			var parameterNameOverride storage.UrlSigningParamIdentifier_STATUS
			err := parameterNameOverrideItem.AssignProperties_To_UrlSigningParamIdentifier_STATUS(&parameterNameOverride)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_UrlSigningParamIdentifier_STATUS() to populate field ParameterNameOverride")
			}
			parameterNameOverrideList[parameterNameOverrideIndex] = parameterNameOverride
		}
		destination.ParameterNameOverride = parameterNameOverrideList
	} else {
		destination.ParameterNameOverride = nil
	}

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlSigningActionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlSigningActionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForCacheExpirationActionParameters interface {
	AssignPropertiesFrom(src *storage.CacheExpirationActionParameters) error
	AssignPropertiesTo(dst *storage.CacheExpirationActionParameters) error
}

type augmentConversionForCacheExpirationActionParameters_STATUS interface {
	AssignPropertiesFrom(src *storage.CacheExpirationActionParameters_STATUS) error
	AssignPropertiesTo(dst *storage.CacheExpirationActionParameters_STATUS) error
}

type augmentConversionForCacheKeyQueryStringActionParameters interface {
	AssignPropertiesFrom(src *storage.CacheKeyQueryStringActionParameters) error
	AssignPropertiesTo(dst *storage.CacheKeyQueryStringActionParameters) error
}

type augmentConversionForCacheKeyQueryStringActionParameters_STATUS interface {
	AssignPropertiesFrom(src *storage.CacheKeyQueryStringActionParameters_STATUS) error
	AssignPropertiesTo(dst *storage.CacheKeyQueryStringActionParameters_STATUS) error
}

type augmentConversionForClientPortMatchConditionParameters interface {
	AssignPropertiesFrom(src *storage.ClientPortMatchConditionParameters) error
	AssignPropertiesTo(dst *storage.ClientPortMatchConditionParameters) error
}

type augmentConversionForClientPortMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *storage.ClientPortMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *storage.ClientPortMatchConditionParameters_STATUS) error
}

type augmentConversionForCookiesMatchConditionParameters interface {
	AssignPropertiesFrom(src *storage.CookiesMatchConditionParameters) error
	AssignPropertiesTo(dst *storage.CookiesMatchConditionParameters) error
}

type augmentConversionForCookiesMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *storage.CookiesMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *storage.CookiesMatchConditionParameters_STATUS) error
}

type augmentConversionForHeaderActionParameters interface {
	AssignPropertiesFrom(src *storage.HeaderActionParameters) error
	AssignPropertiesTo(dst *storage.HeaderActionParameters) error
}

type augmentConversionForHeaderActionParameters_STATUS interface {
	AssignPropertiesFrom(src *storage.HeaderActionParameters_STATUS) error
	AssignPropertiesTo(dst *storage.HeaderActionParameters_STATUS) error
}

type augmentConversionForHostNameMatchConditionParameters interface {
	AssignPropertiesFrom(src *storage.HostNameMatchConditionParameters) error
	AssignPropertiesTo(dst *storage.HostNameMatchConditionParameters) error
}

type augmentConversionForHostNameMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *storage.HostNameMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *storage.HostNameMatchConditionParameters_STATUS) error
}

type augmentConversionForHttpVersionMatchConditionParameters interface {
	AssignPropertiesFrom(src *storage.HttpVersionMatchConditionParameters) error
	AssignPropertiesTo(dst *storage.HttpVersionMatchConditionParameters) error
}

type augmentConversionForHttpVersionMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *storage.HttpVersionMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *storage.HttpVersionMatchConditionParameters_STATUS) error
}

type augmentConversionForIsDeviceMatchConditionParameters interface {
	AssignPropertiesFrom(src *storage.IsDeviceMatchConditionParameters) error
	AssignPropertiesTo(dst *storage.IsDeviceMatchConditionParameters) error
}

type augmentConversionForIsDeviceMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *storage.IsDeviceMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *storage.IsDeviceMatchConditionParameters_STATUS) error
}

type augmentConversionForOriginGroupOverrideActionParameters interface {
	AssignPropertiesFrom(src *storage.OriginGroupOverrideActionParameters) error
	AssignPropertiesTo(dst *storage.OriginGroupOverrideActionParameters) error
}

type augmentConversionForOriginGroupOverrideActionParameters_STATUS interface {
	AssignPropertiesFrom(src *storage.OriginGroupOverrideActionParameters_STATUS) error
	AssignPropertiesTo(dst *storage.OriginGroupOverrideActionParameters_STATUS) error
}

type augmentConversionForPostArgsMatchConditionParameters interface {
	AssignPropertiesFrom(src *storage.PostArgsMatchConditionParameters) error
	AssignPropertiesTo(dst *storage.PostArgsMatchConditionParameters) error
}

type augmentConversionForPostArgsMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *storage.PostArgsMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *storage.PostArgsMatchConditionParameters_STATUS) error
}

type augmentConversionForQueryStringMatchConditionParameters interface {
	AssignPropertiesFrom(src *storage.QueryStringMatchConditionParameters) error
	AssignPropertiesTo(dst *storage.QueryStringMatchConditionParameters) error
}

type augmentConversionForQueryStringMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *storage.QueryStringMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *storage.QueryStringMatchConditionParameters_STATUS) error
}

type augmentConversionForRemoteAddressMatchConditionParameters interface {
	AssignPropertiesFrom(src *storage.RemoteAddressMatchConditionParameters) error
	AssignPropertiesTo(dst *storage.RemoteAddressMatchConditionParameters) error
}

type augmentConversionForRemoteAddressMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *storage.RemoteAddressMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *storage.RemoteAddressMatchConditionParameters_STATUS) error
}

type augmentConversionForRequestBodyMatchConditionParameters interface {
	AssignPropertiesFrom(src *storage.RequestBodyMatchConditionParameters) error
	AssignPropertiesTo(dst *storage.RequestBodyMatchConditionParameters) error
}

type augmentConversionForRequestBodyMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *storage.RequestBodyMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *storage.RequestBodyMatchConditionParameters_STATUS) error
}

type augmentConversionForRequestHeaderMatchConditionParameters interface {
	AssignPropertiesFrom(src *storage.RequestHeaderMatchConditionParameters) error
	AssignPropertiesTo(dst *storage.RequestHeaderMatchConditionParameters) error
}

type augmentConversionForRequestHeaderMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *storage.RequestHeaderMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *storage.RequestHeaderMatchConditionParameters_STATUS) error
}

type augmentConversionForRequestMethodMatchConditionParameters interface {
	AssignPropertiesFrom(src *storage.RequestMethodMatchConditionParameters) error
	AssignPropertiesTo(dst *storage.RequestMethodMatchConditionParameters) error
}

type augmentConversionForRequestMethodMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *storage.RequestMethodMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *storage.RequestMethodMatchConditionParameters_STATUS) error
}

type augmentConversionForRequestSchemeMatchConditionParameters interface {
	AssignPropertiesFrom(src *storage.RequestSchemeMatchConditionParameters) error
	AssignPropertiesTo(dst *storage.RequestSchemeMatchConditionParameters) error
}

type augmentConversionForRequestSchemeMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *storage.RequestSchemeMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *storage.RequestSchemeMatchConditionParameters_STATUS) error
}

type augmentConversionForRequestUriMatchConditionParameters interface {
	AssignPropertiesFrom(src *storage.RequestUriMatchConditionParameters) error
	AssignPropertiesTo(dst *storage.RequestUriMatchConditionParameters) error
}

type augmentConversionForRequestUriMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *storage.RequestUriMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *storage.RequestUriMatchConditionParameters_STATUS) error
}

type augmentConversionForRouteConfigurationOverrideActionParameters interface {
	AssignPropertiesFrom(src *storage.RouteConfigurationOverrideActionParameters) error
	AssignPropertiesTo(dst *storage.RouteConfigurationOverrideActionParameters) error
}

type augmentConversionForRouteConfigurationOverrideActionParameters_STATUS interface {
	AssignPropertiesFrom(src *storage.RouteConfigurationOverrideActionParameters_STATUS) error
	AssignPropertiesTo(dst *storage.RouteConfigurationOverrideActionParameters_STATUS) error
}

type augmentConversionForServerPortMatchConditionParameters interface {
	AssignPropertiesFrom(src *storage.ServerPortMatchConditionParameters) error
	AssignPropertiesTo(dst *storage.ServerPortMatchConditionParameters) error
}

type augmentConversionForServerPortMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *storage.ServerPortMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *storage.ServerPortMatchConditionParameters_STATUS) error
}

type augmentConversionForSocketAddrMatchConditionParameters interface {
	AssignPropertiesFrom(src *storage.SocketAddrMatchConditionParameters) error
	AssignPropertiesTo(dst *storage.SocketAddrMatchConditionParameters) error
}

type augmentConversionForSocketAddrMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *storage.SocketAddrMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *storage.SocketAddrMatchConditionParameters_STATUS) error
}

type augmentConversionForSslProtocolMatchConditionParameters interface {
	AssignPropertiesFrom(src *storage.SslProtocolMatchConditionParameters) error
	AssignPropertiesTo(dst *storage.SslProtocolMatchConditionParameters) error
}

type augmentConversionForSslProtocolMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *storage.SslProtocolMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *storage.SslProtocolMatchConditionParameters_STATUS) error
}

type augmentConversionForUrlFileExtensionMatchConditionParameters interface {
	AssignPropertiesFrom(src *storage.UrlFileExtensionMatchConditionParameters) error
	AssignPropertiesTo(dst *storage.UrlFileExtensionMatchConditionParameters) error
}

type augmentConversionForUrlFileExtensionMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *storage.UrlFileExtensionMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *storage.UrlFileExtensionMatchConditionParameters_STATUS) error
}

type augmentConversionForUrlFileNameMatchConditionParameters interface {
	AssignPropertiesFrom(src *storage.UrlFileNameMatchConditionParameters) error
	AssignPropertiesTo(dst *storage.UrlFileNameMatchConditionParameters) error
}

type augmentConversionForUrlFileNameMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *storage.UrlFileNameMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *storage.UrlFileNameMatchConditionParameters_STATUS) error
}

type augmentConversionForUrlPathMatchConditionParameters interface {
	AssignPropertiesFrom(src *storage.UrlPathMatchConditionParameters) error
	AssignPropertiesTo(dst *storage.UrlPathMatchConditionParameters) error
}

type augmentConversionForUrlPathMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *storage.UrlPathMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *storage.UrlPathMatchConditionParameters_STATUS) error
}

type augmentConversionForUrlRedirectActionParameters interface {
	AssignPropertiesFrom(src *storage.UrlRedirectActionParameters) error
	AssignPropertiesTo(dst *storage.UrlRedirectActionParameters) error
}

type augmentConversionForUrlRedirectActionParameters_STATUS interface {
	AssignPropertiesFrom(src *storage.UrlRedirectActionParameters_STATUS) error
	AssignPropertiesTo(dst *storage.UrlRedirectActionParameters_STATUS) error
}

type augmentConversionForUrlRewriteActionParameters interface {
	AssignPropertiesFrom(src *storage.UrlRewriteActionParameters) error
	AssignPropertiesTo(dst *storage.UrlRewriteActionParameters) error
}

type augmentConversionForUrlRewriteActionParameters_STATUS interface {
	AssignPropertiesFrom(src *storage.UrlRewriteActionParameters_STATUS) error
	AssignPropertiesTo(dst *storage.UrlRewriteActionParameters_STATUS) error
}

type augmentConversionForUrlSigningActionParameters interface {
	AssignPropertiesFrom(src *storage.UrlSigningActionParameters) error
	AssignPropertiesTo(dst *storage.UrlSigningActionParameters) error
}

type augmentConversionForUrlSigningActionParameters_STATUS interface {
	AssignPropertiesFrom(src *storage.UrlSigningActionParameters_STATUS) error
	AssignPropertiesTo(dst *storage.UrlSigningActionParameters_STATUS) error
}

// Storage version of v1api20210601.CacheConfiguration
// Caching settings for a caching-type route. To disable caching, do not provide a cacheConfiguration object.
type CacheConfiguration struct {
	CacheBehavior              *string                `json:"cacheBehavior,omitempty"`
	CacheDuration              *string                `json:"cacheDuration,omitempty"`
	IsCompressionEnabled       *string                `json:"isCompressionEnabled,omitempty"`
	PropertyBag                genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	QueryParameters            *string                `json:"queryParameters,omitempty"`
	QueryStringCachingBehavior *string                `json:"queryStringCachingBehavior,omitempty"`
}

// AssignProperties_From_CacheConfiguration populates our CacheConfiguration from the provided source CacheConfiguration
func (configuration *CacheConfiguration) AssignProperties_From_CacheConfiguration(source *storage.CacheConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CacheBehavior
	configuration.CacheBehavior = genruntime.ClonePointerToString(source.CacheBehavior)

	// CacheDuration
	configuration.CacheDuration = genruntime.ClonePointerToString(source.CacheDuration)

	// IsCompressionEnabled
	configuration.IsCompressionEnabled = genruntime.ClonePointerToString(source.IsCompressionEnabled)

	// QueryParameters
	configuration.QueryParameters = genruntime.ClonePointerToString(source.QueryParameters)

	// QueryStringCachingBehavior
	configuration.QueryStringCachingBehavior = genruntime.ClonePointerToString(source.QueryStringCachingBehavior)

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForCacheConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForCacheConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_CacheConfiguration populates the provided destination CacheConfiguration from our CacheConfiguration
func (configuration *CacheConfiguration) AssignProperties_To_CacheConfiguration(destination *storage.CacheConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// CacheBehavior
	destination.CacheBehavior = genruntime.ClonePointerToString(configuration.CacheBehavior)

	// CacheDuration
	destination.CacheDuration = genruntime.ClonePointerToString(configuration.CacheDuration)

	// IsCompressionEnabled
	destination.IsCompressionEnabled = genruntime.ClonePointerToString(configuration.IsCompressionEnabled)

	// QueryParameters
	destination.QueryParameters = genruntime.ClonePointerToString(configuration.QueryParameters)

	// QueryStringCachingBehavior
	destination.QueryStringCachingBehavior = genruntime.ClonePointerToString(configuration.QueryStringCachingBehavior)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForCacheConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForCacheConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.CacheConfiguration_STATUS
// Caching settings for a caching-type route. To disable caching, do not provide a cacheConfiguration object.
type CacheConfiguration_STATUS struct {
	CacheBehavior              *string                `json:"cacheBehavior,omitempty"`
	CacheDuration              *string                `json:"cacheDuration,omitempty"`
	IsCompressionEnabled       *string                `json:"isCompressionEnabled,omitempty"`
	PropertyBag                genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	QueryParameters            *string                `json:"queryParameters,omitempty"`
	QueryStringCachingBehavior *string                `json:"queryStringCachingBehavior,omitempty"`
}

// AssignProperties_From_CacheConfiguration_STATUS populates our CacheConfiguration_STATUS from the provided source CacheConfiguration_STATUS
func (configuration *CacheConfiguration_STATUS) AssignProperties_From_CacheConfiguration_STATUS(source *storage.CacheConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CacheBehavior
	configuration.CacheBehavior = genruntime.ClonePointerToString(source.CacheBehavior)

	// CacheDuration
	configuration.CacheDuration = genruntime.ClonePointerToString(source.CacheDuration)

	// IsCompressionEnabled
	configuration.IsCompressionEnabled = genruntime.ClonePointerToString(source.IsCompressionEnabled)

	// QueryParameters
	configuration.QueryParameters = genruntime.ClonePointerToString(source.QueryParameters)

	// QueryStringCachingBehavior
	configuration.QueryStringCachingBehavior = genruntime.ClonePointerToString(source.QueryStringCachingBehavior)

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForCacheConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForCacheConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_CacheConfiguration_STATUS populates the provided destination CacheConfiguration_STATUS from our CacheConfiguration_STATUS
func (configuration *CacheConfiguration_STATUS) AssignProperties_To_CacheConfiguration_STATUS(destination *storage.CacheConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// CacheBehavior
	destination.CacheBehavior = genruntime.ClonePointerToString(configuration.CacheBehavior)

	// CacheDuration
	destination.CacheDuration = genruntime.ClonePointerToString(configuration.CacheDuration)

	// IsCompressionEnabled
	destination.IsCompressionEnabled = genruntime.ClonePointerToString(configuration.IsCompressionEnabled)

	// QueryParameters
	destination.QueryParameters = genruntime.ClonePointerToString(configuration.QueryParameters)

	// QueryStringCachingBehavior
	destination.QueryStringCachingBehavior = genruntime.ClonePointerToString(configuration.QueryStringCachingBehavior)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForCacheConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForCacheConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.OriginGroupOverride
// Defines the parameters for the origin group override configuration.
type OriginGroupOverride struct {
	ForwardingProtocol *string                `json:"forwardingProtocol,omitempty"`
	OriginGroup        *ResourceReference     `json:"originGroup,omitempty"`
	PropertyBag        genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_OriginGroupOverride populates our OriginGroupOverride from the provided source OriginGroupOverride
func (override *OriginGroupOverride) AssignProperties_From_OriginGroupOverride(source *storage.OriginGroupOverride) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ForwardingProtocol
	override.ForwardingProtocol = genruntime.ClonePointerToString(source.ForwardingProtocol)

	// OriginGroup
	if source.OriginGroup != nil {
		var originGroup ResourceReference
		err := originGroup.AssignProperties_From_ResourceReference(source.OriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceReference() to populate field OriginGroup")
		}
		override.OriginGroup = &originGroup
	} else {
		override.OriginGroup = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		override.PropertyBag = propertyBag
	} else {
		override.PropertyBag = nil
	}

	// Invoke the augmentConversionForOriginGroupOverride interface (if implemented) to customize the conversion
	var overrideAsAny any = override
	if augmentedOverride, ok := overrideAsAny.(augmentConversionForOriginGroupOverride); ok {
		err := augmentedOverride.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_OriginGroupOverride populates the provided destination OriginGroupOverride from our OriginGroupOverride
func (override *OriginGroupOverride) AssignProperties_To_OriginGroupOverride(destination *storage.OriginGroupOverride) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(override.PropertyBag)

	// ForwardingProtocol
	destination.ForwardingProtocol = genruntime.ClonePointerToString(override.ForwardingProtocol)

	// OriginGroup
	if override.OriginGroup != nil {
		var originGroup storage.ResourceReference
		err := override.OriginGroup.AssignProperties_To_ResourceReference(&originGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceReference() to populate field OriginGroup")
		}
		destination.OriginGroup = &originGroup
	} else {
		destination.OriginGroup = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForOriginGroupOverride interface (if implemented) to customize the conversion
	var overrideAsAny any = override
	if augmentedOverride, ok := overrideAsAny.(augmentConversionForOriginGroupOverride); ok {
		err := augmentedOverride.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.OriginGroupOverride_STATUS
// Defines the parameters for the origin group override configuration.
type OriginGroupOverride_STATUS struct {
	ForwardingProtocol *string                   `json:"forwardingProtocol,omitempty"`
	OriginGroup        *ResourceReference_STATUS `json:"originGroup,omitempty"`
	PropertyBag        genruntime.PropertyBag    `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_OriginGroupOverride_STATUS populates our OriginGroupOverride_STATUS from the provided source OriginGroupOverride_STATUS
func (override *OriginGroupOverride_STATUS) AssignProperties_From_OriginGroupOverride_STATUS(source *storage.OriginGroupOverride_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ForwardingProtocol
	override.ForwardingProtocol = genruntime.ClonePointerToString(source.ForwardingProtocol)

	// OriginGroup
	if source.OriginGroup != nil {
		var originGroup ResourceReference_STATUS
		err := originGroup.AssignProperties_From_ResourceReference_STATUS(source.OriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceReference_STATUS() to populate field OriginGroup")
		}
		override.OriginGroup = &originGroup
	} else {
		override.OriginGroup = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		override.PropertyBag = propertyBag
	} else {
		override.PropertyBag = nil
	}

	// Invoke the augmentConversionForOriginGroupOverride_STATUS interface (if implemented) to customize the conversion
	var overrideAsAny any = override
	if augmentedOverride, ok := overrideAsAny.(augmentConversionForOriginGroupOverride_STATUS); ok {
		err := augmentedOverride.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_OriginGroupOverride_STATUS populates the provided destination OriginGroupOverride_STATUS from our OriginGroupOverride_STATUS
func (override *OriginGroupOverride_STATUS) AssignProperties_To_OriginGroupOverride_STATUS(destination *storage.OriginGroupOverride_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(override.PropertyBag)

	// ForwardingProtocol
	destination.ForwardingProtocol = genruntime.ClonePointerToString(override.ForwardingProtocol)

	// OriginGroup
	if override.OriginGroup != nil {
		var originGroup storage.ResourceReference_STATUS
		err := override.OriginGroup.AssignProperties_To_ResourceReference_STATUS(&originGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceReference_STATUS() to populate field OriginGroup")
		}
		destination.OriginGroup = &originGroup
	} else {
		destination.OriginGroup = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForOriginGroupOverride_STATUS interface (if implemented) to customize the conversion
	var overrideAsAny any = override
	if augmentedOverride, ok := overrideAsAny.(augmentConversionForOriginGroupOverride_STATUS); ok {
		err := augmentedOverride.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.UrlSigningParamIdentifier
// Defines how to identify a parameter for a specific purpose e.g. expires
type UrlSigningParamIdentifier struct {
	ParamIndicator *string                `json:"paramIndicator,omitempty"`
	ParamName      *string                `json:"paramName,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_UrlSigningParamIdentifier populates our UrlSigningParamIdentifier from the provided source UrlSigningParamIdentifier
func (identifier *UrlSigningParamIdentifier) AssignProperties_From_UrlSigningParamIdentifier(source *storage.UrlSigningParamIdentifier) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ParamIndicator
	identifier.ParamIndicator = genruntime.ClonePointerToString(source.ParamIndicator)

	// ParamName
	identifier.ParamName = genruntime.ClonePointerToString(source.ParamName)

	// Update the property bag
	if len(propertyBag) > 0 {
		identifier.PropertyBag = propertyBag
	} else {
		identifier.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlSigningParamIdentifier interface (if implemented) to customize the conversion
	var identifierAsAny any = identifier
	if augmentedIdentifier, ok := identifierAsAny.(augmentConversionForUrlSigningParamIdentifier); ok {
		err := augmentedIdentifier.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlSigningParamIdentifier populates the provided destination UrlSigningParamIdentifier from our UrlSigningParamIdentifier
func (identifier *UrlSigningParamIdentifier) AssignProperties_To_UrlSigningParamIdentifier(destination *storage.UrlSigningParamIdentifier) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(identifier.PropertyBag)

	// ParamIndicator
	destination.ParamIndicator = genruntime.ClonePointerToString(identifier.ParamIndicator)

	// ParamName
	destination.ParamName = genruntime.ClonePointerToString(identifier.ParamName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlSigningParamIdentifier interface (if implemented) to customize the conversion
	var identifierAsAny any = identifier
	if augmentedIdentifier, ok := identifierAsAny.(augmentConversionForUrlSigningParamIdentifier); ok {
		err := augmentedIdentifier.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20210601.UrlSigningParamIdentifier_STATUS
// Defines how to identify a parameter for a specific purpose e.g. expires
type UrlSigningParamIdentifier_STATUS struct {
	ParamIndicator *string                `json:"paramIndicator,omitempty"`
	ParamName      *string                `json:"paramName,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_UrlSigningParamIdentifier_STATUS populates our UrlSigningParamIdentifier_STATUS from the provided source UrlSigningParamIdentifier_STATUS
func (identifier *UrlSigningParamIdentifier_STATUS) AssignProperties_From_UrlSigningParamIdentifier_STATUS(source *storage.UrlSigningParamIdentifier_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ParamIndicator
	identifier.ParamIndicator = genruntime.ClonePointerToString(source.ParamIndicator)

	// ParamName
	identifier.ParamName = genruntime.ClonePointerToString(source.ParamName)

	// Update the property bag
	if len(propertyBag) > 0 {
		identifier.PropertyBag = propertyBag
	} else {
		identifier.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlSigningParamIdentifier_STATUS interface (if implemented) to customize the conversion
	var identifierAsAny any = identifier
	if augmentedIdentifier, ok := identifierAsAny.(augmentConversionForUrlSigningParamIdentifier_STATUS); ok {
		err := augmentedIdentifier.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlSigningParamIdentifier_STATUS populates the provided destination UrlSigningParamIdentifier_STATUS from our UrlSigningParamIdentifier_STATUS
func (identifier *UrlSigningParamIdentifier_STATUS) AssignProperties_To_UrlSigningParamIdentifier_STATUS(destination *storage.UrlSigningParamIdentifier_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(identifier.PropertyBag)

	// ParamIndicator
	destination.ParamIndicator = genruntime.ClonePointerToString(identifier.ParamIndicator)

	// ParamName
	destination.ParamName = genruntime.ClonePointerToString(identifier.ParamName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlSigningParamIdentifier_STATUS interface (if implemented) to customize the conversion
	var identifierAsAny any = identifier
	if augmentedIdentifier, ok := identifierAsAny.(augmentConversionForUrlSigningParamIdentifier_STATUS); ok {
		err := augmentedIdentifier.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForCacheConfiguration interface {
	AssignPropertiesFrom(src *storage.CacheConfiguration) error
	AssignPropertiesTo(dst *storage.CacheConfiguration) error
}

type augmentConversionForCacheConfiguration_STATUS interface {
	AssignPropertiesFrom(src *storage.CacheConfiguration_STATUS) error
	AssignPropertiesTo(dst *storage.CacheConfiguration_STATUS) error
}

type augmentConversionForOriginGroupOverride interface {
	AssignPropertiesFrom(src *storage.OriginGroupOverride) error
	AssignPropertiesTo(dst *storage.OriginGroupOverride) error
}

type augmentConversionForOriginGroupOverride_STATUS interface {
	AssignPropertiesFrom(src *storage.OriginGroupOverride_STATUS) error
	AssignPropertiesTo(dst *storage.OriginGroupOverride_STATUS) error
}

type augmentConversionForUrlSigningParamIdentifier interface {
	AssignPropertiesFrom(src *storage.UrlSigningParamIdentifier) error
	AssignPropertiesTo(dst *storage.UrlSigningParamIdentifier) error
}

type augmentConversionForUrlSigningParamIdentifier_STATUS interface {
	AssignPropertiesFrom(src *storage.UrlSigningParamIdentifier_STATUS) error
	AssignPropertiesTo(dst *storage.UrlSigningParamIdentifier_STATUS) error
}

func init() {
	SchemeBuilder.Register(&ProfilesEndpoint{}, &ProfilesEndpointList{})
}
