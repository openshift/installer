// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20220301

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/compute/v1api20220301/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/compute/v1api20220301/storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/pkg/errors"
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /compute/resource-manager/Microsoft.Compute/ComputeRP/stable/2022-03-01/virtualMachine.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}
type VirtualMachine struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              VirtualMachine_Spec   `json:"spec,omitempty"`
	Status            VirtualMachine_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &VirtualMachine{}

// GetConditions returns the conditions of the resource
func (machine *VirtualMachine) GetConditions() conditions.Conditions {
	return machine.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (machine *VirtualMachine) SetConditions(conditions conditions.Conditions) {
	machine.Status.Conditions = conditions
}

var _ conversion.Convertible = &VirtualMachine{}

// ConvertFrom populates our VirtualMachine from the provided hub VirtualMachine
func (machine *VirtualMachine) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.VirtualMachine)
	if !ok {
		return fmt.Errorf("expected compute/v1api20220301/storage/VirtualMachine but received %T instead", hub)
	}

	return machine.AssignProperties_From_VirtualMachine(source)
}

// ConvertTo populates the provided hub VirtualMachine from our VirtualMachine
func (machine *VirtualMachine) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.VirtualMachine)
	if !ok {
		return fmt.Errorf("expected compute/v1api20220301/storage/VirtualMachine but received %T instead", hub)
	}

	return machine.AssignProperties_To_VirtualMachine(destination)
}

// +kubebuilder:webhook:path=/mutate-compute-azure-com-v1api20220301-virtualmachine,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=compute.azure.com,resources=virtualmachines,verbs=create;update,versions=v1api20220301,name=default.v1api20220301.virtualmachines.compute.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &VirtualMachine{}

// Default applies defaults to the VirtualMachine resource
func (machine *VirtualMachine) Default() {
	machine.defaultImpl()
	var temp any = machine
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (machine *VirtualMachine) defaultAzureName() {
	if machine.Spec.AzureName == "" {
		machine.Spec.AzureName = machine.Name
	}
}

// defaultImpl applies the code generated defaults to the VirtualMachine resource
func (machine *VirtualMachine) defaultImpl() { machine.defaultAzureName() }

var _ configmaps.Exporter = &VirtualMachine{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (machine *VirtualMachine) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if machine.Spec.OperatorSpec == nil {
		return nil
	}
	return machine.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &VirtualMachine{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (machine *VirtualMachine) SecretDestinationExpressions() []*core.DestinationExpression {
	if machine.Spec.OperatorSpec == nil {
		return nil
	}
	return machine.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &VirtualMachine{}

// InitializeSpec initializes the spec for this resource from the given status
func (machine *VirtualMachine) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*VirtualMachine_STATUS); ok {
		return machine.Spec.Initialize_From_VirtualMachine_STATUS(s)
	}

	return fmt.Errorf("expected Status of type VirtualMachine_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &VirtualMachine{}

// AzureName returns the Azure name of the resource
func (machine *VirtualMachine) AzureName() string {
	return machine.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2022-03-01"
func (machine VirtualMachine) GetAPIVersion() string {
	return "2022-03-01"
}

// GetResourceScope returns the scope of the resource
func (machine *VirtualMachine) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (machine *VirtualMachine) GetSpec() genruntime.ConvertibleSpec {
	return &machine.Spec
}

// GetStatus returns the status of this resource
func (machine *VirtualMachine) GetStatus() genruntime.ConvertibleStatus {
	return &machine.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (machine *VirtualMachine) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Compute/virtualMachines"
func (machine *VirtualMachine) GetType() string {
	return "Microsoft.Compute/virtualMachines"
}

// NewEmptyStatus returns a new empty (blank) status
func (machine *VirtualMachine) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &VirtualMachine_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (machine *VirtualMachine) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(machine.Spec)
	return machine.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (machine *VirtualMachine) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*VirtualMachine_STATUS); ok {
		machine.Status = *st
		return nil
	}

	// Convert status to required version
	var st VirtualMachine_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	machine.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-compute-azure-com-v1api20220301-virtualmachine,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=compute.azure.com,resources=virtualmachines,verbs=create;update,versions=v1api20220301,name=validate.v1api20220301.virtualmachines.compute.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &VirtualMachine{}

// ValidateCreate validates the creation of the resource
func (machine *VirtualMachine) ValidateCreate() (admission.Warnings, error) {
	validations := machine.createValidations()
	var temp any = machine
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	return genruntime.ValidateCreate(validations)
}

// ValidateDelete validates the deletion of the resource
func (machine *VirtualMachine) ValidateDelete() (admission.Warnings, error) {
	validations := machine.deleteValidations()
	var temp any = machine
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	return genruntime.ValidateDelete(validations)
}

// ValidateUpdate validates an update of the resource
func (machine *VirtualMachine) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	validations := machine.updateValidations()
	var temp any = machine
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	return genruntime.ValidateUpdate(old, validations)
}

// createValidations validates the creation of the resource
func (machine *VirtualMachine) createValidations() []func() (admission.Warnings, error) {
	return []func() (admission.Warnings, error){machine.validateResourceReferences, machine.validateOwnerReference, machine.validateSecretDestinations, machine.validateConfigMapDestinations}
}

// deleteValidations validates the deletion of the resource
func (machine *VirtualMachine) deleteValidations() []func() (admission.Warnings, error) {
	return nil
}

// updateValidations validates the update of the resource
func (machine *VirtualMachine) updateValidations() []func(old runtime.Object) (admission.Warnings, error) {
	return []func(old runtime.Object) (admission.Warnings, error){
		func(old runtime.Object) (admission.Warnings, error) {
			return machine.validateResourceReferences()
		},
		machine.validateWriteOnceProperties,
		func(old runtime.Object) (admission.Warnings, error) {
			return machine.validateOwnerReference()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return machine.validateSecretDestinations()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return machine.validateConfigMapDestinations()
		},
	}
}

// validateConfigMapDestinations validates there are no colliding genruntime.ConfigMapDestinations
func (machine *VirtualMachine) validateConfigMapDestinations() (admission.Warnings, error) {
	if machine.Spec.OperatorSpec == nil {
		return nil, nil
	}
	return configmaps.ValidateDestinations(machine, nil, machine.Spec.OperatorSpec.ConfigMapExpressions)
}

// validateOwnerReference validates the owner field
func (machine *VirtualMachine) validateOwnerReference() (admission.Warnings, error) {
	return genruntime.ValidateOwner(machine)
}

// validateResourceReferences validates all resource references
func (machine *VirtualMachine) validateResourceReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindResourceReferences(&machine.Spec)
	if err != nil {
		return nil, err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateSecretDestinations validates there are no colliding genruntime.SecretDestination's
func (machine *VirtualMachine) validateSecretDestinations() (admission.Warnings, error) {
	if machine.Spec.OperatorSpec == nil {
		return nil, nil
	}
	return secrets.ValidateDestinations(machine, nil, machine.Spec.OperatorSpec.SecretExpressions)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (machine *VirtualMachine) validateWriteOnceProperties(old runtime.Object) (admission.Warnings, error) {
	oldObj, ok := old.(*VirtualMachine)
	if !ok {
		return nil, nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, machine)
}

// AssignProperties_From_VirtualMachine populates our VirtualMachine from the provided source VirtualMachine
func (machine *VirtualMachine) AssignProperties_From_VirtualMachine(source *storage.VirtualMachine) error {

	// ObjectMeta
	machine.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec VirtualMachine_Spec
	err := spec.AssignProperties_From_VirtualMachine_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_VirtualMachine_Spec() to populate field Spec")
	}
	machine.Spec = spec

	// Status
	var status VirtualMachine_STATUS
	err = status.AssignProperties_From_VirtualMachine_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_VirtualMachine_STATUS() to populate field Status")
	}
	machine.Status = status

	// No error
	return nil
}

// AssignProperties_To_VirtualMachine populates the provided destination VirtualMachine from our VirtualMachine
func (machine *VirtualMachine) AssignProperties_To_VirtualMachine(destination *storage.VirtualMachine) error {

	// ObjectMeta
	destination.ObjectMeta = *machine.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.VirtualMachine_Spec
	err := machine.Spec.AssignProperties_To_VirtualMachine_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_VirtualMachine_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.VirtualMachine_STATUS
	err = machine.Status.AssignProperties_To_VirtualMachine_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_VirtualMachine_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (machine *VirtualMachine) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: machine.Spec.OriginalVersion(),
		Kind:    "VirtualMachine",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /compute/resource-manager/Microsoft.Compute/ComputeRP/stable/2022-03-01/virtualMachine.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachines/{vmName}
type VirtualMachineList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []VirtualMachine `json:"items"`
}

type VirtualMachine_Spec struct {
	// AdditionalCapabilities: Specifies additional capabilities enabled or disabled on the virtual machine.
	AdditionalCapabilities *AdditionalCapabilities `json:"additionalCapabilities,omitempty"`

	// ApplicationProfile: Specifies the gallery applications that should be made available to the VM/VMSS
	ApplicationProfile *ApplicationProfile `json:"applicationProfile,omitempty"`

	// AvailabilitySet: Specifies information about the availability set that the virtual machine should be assigned to.
	// Virtual machines specified in the same availability set are allocated to different nodes to maximize availability. For
	// more information about availability sets, see [Availability sets
	// overview](https://docs.microsoft.com/azure/virtual-machines/availability-set-overview).
	// For more information on Azure planned maintenance, see [Maintenance and updates for Virtual Machines in
	// Azure](https://docs.microsoft.com/azure/virtual-machines/maintenance-and-updates)
	// Currently, a VM can only be added to availability set at creation time. The availability set to which the VM is being
	// added should be under the same resource group as the availability set resource. An existing VM cannot be added to an
	// availability set.
	// This property cannot exist along with a non-null properties.virtualMachineScaleSet reference.
	AvailabilitySet *SubResource `json:"availabilitySet,omitempty"`

	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// BillingProfile: Specifies the billing related details of a Azure Spot virtual machine.
	// Minimum api-version: 2019-03-01.
	BillingProfile *BillingProfile `json:"billingProfile,omitempty"`

	// CapacityReservation: Specifies information about the capacity reservation that is used to allocate virtual machine.
	// Minimum api-version: 2021-04-01.
	CapacityReservation *CapacityReservationProfile `json:"capacityReservation,omitempty"`

	// DiagnosticsProfile: Specifies the boot diagnostic settings state.
	// Minimum api-version: 2015-06-15.
	DiagnosticsProfile *DiagnosticsProfile `json:"diagnosticsProfile,omitempty"`

	// EvictionPolicy: Specifies the eviction policy for the Azure Spot virtual machine and Azure Spot scale set.
	// For Azure Spot virtual machines, both 'Deallocate' and 'Delete' are supported and the minimum api-version is 2019-03-01.
	// For Azure Spot scale sets, both 'Deallocate' and 'Delete' are supported and the minimum api-version is
	// 2017-10-30-preview.
	EvictionPolicy *EvictionPolicy `json:"evictionPolicy,omitempty"`

	// ExtendedLocation: The extended location of the Virtual Machine.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`

	// ExtensionsTimeBudget: Specifies the time alloted for all extensions to start. The time duration should be between 15
	// minutes and 120 minutes (inclusive) and should be specified in ISO 8601 format. The default value is 90 minutes
	// (PT1H30M).
	// Minimum api-version: 2020-06-01
	ExtensionsTimeBudget *string `json:"extensionsTimeBudget,omitempty"`

	// HardwareProfile: Specifies the hardware settings for the virtual machine.
	HardwareProfile *HardwareProfile `json:"hardwareProfile,omitempty"`

	// Host: Specifies information about the dedicated host that the virtual machine resides in.
	// Minimum api-version: 2018-10-01.
	Host *SubResource `json:"host,omitempty"`

	// HostGroup: Specifies information about the dedicated host group that the virtual machine resides in.
	// Minimum api-version: 2020-06-01.
	// NOTE: User cannot specify both host and hostGroup properties.
	HostGroup *SubResource `json:"hostGroup,omitempty"`

	// Identity: The identity of the virtual machine, if configured.
	Identity *VirtualMachineIdentity `json:"identity,omitempty"`

	// LicenseType: Specifies that the image or disk that is being used was licensed on-premises.
	// Possible values for Windows Server operating system are:
	// Windows_Client
	// Windows_Server
	// Possible values for Linux Server operating system are:
	// RHEL_BYOS (for RHEL)
	// SLES_BYOS (for SUSE)
	// For more information, see [Azure Hybrid Use Benefit for Windows
	// Server](https://docs.microsoft.com/azure/virtual-machines/windows/hybrid-use-benefit-licensing)
	// [Azure Hybrid Use Benefit for Linux
	// Server](https://docs.microsoft.com/azure/virtual-machines/linux/azure-hybrid-benefit-linux)
	// Minimum api-version: 2015-06-15
	LicenseType *string `json:"licenseType,omitempty"`

	// +kubebuilder:validation:Required
	// Location: Resource location
	Location *string `json:"location,omitempty"`

	// NetworkProfile: Specifies the network interfaces of the virtual machine.
	NetworkProfile *NetworkProfile `json:"networkProfile,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *VirtualMachineOperatorSpec `json:"operatorSpec,omitempty"`

	// OsProfile: Specifies the operating system settings used while creating the virtual machine. Some of the settings cannot
	// be changed once VM is provisioned.
	OsProfile *OSProfile `json:"osProfile,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// Plan: Specifies information about the marketplace image used to create the virtual machine. This element is only used
	// for marketplace images. Before you can use a marketplace image from an API, you must enable the image for programmatic
	// use.  In the Azure portal, find the marketplace image that you want to use and then click Want to deploy
	// programmatically, Get Started ->. Enter any required information and then click Save.
	Plan *Plan `json:"plan,omitempty"`

	// PlatformFaultDomain: Specifies the scale set logical fault domain into which the Virtual Machine will be created. By
	// default, the Virtual Machine will by automatically assigned to a fault domain that best maintains balance across
	// available fault domains.
	// <li>This is applicable only if the 'virtualMachineScaleSet' property of this Virtual Machine is set.<li>The Virtual
	// Machine Scale Set that is referenced, must have 'platformFaultDomainCount' &gt; 1.<li>This property cannot be updated
	// once the Virtual Machine is created.<li>Fault domain assignment can be viewed in the Virtual Machine Instance View.
	// Minimum api‐version: 2020‐12‐01
	PlatformFaultDomain *int `json:"platformFaultDomain,omitempty"`

	// Priority: Specifies the priority for the virtual machine.
	// Minimum api-version: 2019-03-01
	Priority *Priority `json:"priority,omitempty"`

	// ProximityPlacementGroup: Specifies information about the proximity placement group that the virtual machine should be
	// assigned to.
	// Minimum api-version: 2018-04-01.
	ProximityPlacementGroup *SubResource `json:"proximityPlacementGroup,omitempty"`

	// ScheduledEventsProfile: Specifies Scheduled Event related configurations.
	ScheduledEventsProfile *ScheduledEventsProfile `json:"scheduledEventsProfile,omitempty"`

	// SecurityProfile: Specifies the Security related profile settings for the virtual machine.
	SecurityProfile *SecurityProfile `json:"securityProfile,omitempty"`

	// StorageProfile: Specifies the storage settings for the virtual machine disks.
	StorageProfile *StorageProfile `json:"storageProfile,omitempty"`

	// Tags: Resource tags
	Tags map[string]string `json:"tags,omitempty"`

	// UserData: UserData for the VM, which must be base-64 encoded. Customer should not pass any secrets in here.
	// Minimum api-version: 2021-03-01
	UserData *string `json:"userData,omitempty"`

	// VirtualMachineScaleSet: Specifies information about the virtual machine scale set that the virtual machine should be
	// assigned to. Virtual machines specified in the same virtual machine scale set are allocated to different nodes to
	// maximize availability. Currently, a VM can only be added to virtual machine scale set at creation time. An existing VM
	// cannot be added to a virtual machine scale set.
	// This property cannot exist along with a non-null properties.availabilitySet reference.
	// Minimum api‐version: 2019‐03‐01
	VirtualMachineScaleSet *SubResource `json:"virtualMachineScaleSet,omitempty"`

	// Zones: The virtual machine zones.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachine_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (machine *VirtualMachine_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if machine == nil {
		return nil, nil
	}
	result := &arm.VirtualMachine_Spec{}

	// Set property "ExtendedLocation":
	if machine.ExtendedLocation != nil {
		extendedLocation_ARM, err := (*machine.ExtendedLocation).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		extendedLocation := *extendedLocation_ARM.(*arm.ExtendedLocation)
		result.ExtendedLocation = &extendedLocation
	}

	// Set property "Identity":
	if machine.Identity != nil {
		identity_ARM, err := (*machine.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*arm.VirtualMachineIdentity)
		result.Identity = &identity
	}

	// Set property "Location":
	if machine.Location != nil {
		location := *machine.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Plan":
	if machine.Plan != nil {
		plan_ARM, err := (*machine.Plan).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		plan := *plan_ARM.(*arm.Plan)
		result.Plan = &plan
	}

	// Set property "Properties":
	if machine.AdditionalCapabilities != nil ||
		machine.ApplicationProfile != nil ||
		machine.AvailabilitySet != nil ||
		machine.BillingProfile != nil ||
		machine.CapacityReservation != nil ||
		machine.DiagnosticsProfile != nil ||
		machine.EvictionPolicy != nil ||
		machine.ExtensionsTimeBudget != nil ||
		machine.HardwareProfile != nil ||
		machine.Host != nil ||
		machine.HostGroup != nil ||
		machine.LicenseType != nil ||
		machine.NetworkProfile != nil ||
		machine.OsProfile != nil ||
		machine.PlatformFaultDomain != nil ||
		machine.Priority != nil ||
		machine.ProximityPlacementGroup != nil ||
		machine.ScheduledEventsProfile != nil ||
		machine.SecurityProfile != nil ||
		machine.StorageProfile != nil ||
		machine.UserData != nil ||
		machine.VirtualMachineScaleSet != nil {
		result.Properties = &arm.VirtualMachineProperties{}
	}
	if machine.AdditionalCapabilities != nil {
		additionalCapabilities_ARM, err := (*machine.AdditionalCapabilities).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		additionalCapabilities := *additionalCapabilities_ARM.(*arm.AdditionalCapabilities)
		result.Properties.AdditionalCapabilities = &additionalCapabilities
	}
	if machine.ApplicationProfile != nil {
		applicationProfile_ARM, err := (*machine.ApplicationProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		applicationProfile := *applicationProfile_ARM.(*arm.ApplicationProfile)
		result.Properties.ApplicationProfile = &applicationProfile
	}
	if machine.AvailabilitySet != nil {
		availabilitySet_ARM, err := (*machine.AvailabilitySet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		availabilitySet := *availabilitySet_ARM.(*arm.SubResource)
		result.Properties.AvailabilitySet = &availabilitySet
	}
	if machine.BillingProfile != nil {
		billingProfile_ARM, err := (*machine.BillingProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		billingProfile := *billingProfile_ARM.(*arm.BillingProfile)
		result.Properties.BillingProfile = &billingProfile
	}
	if machine.CapacityReservation != nil {
		capacityReservation_ARM, err := (*machine.CapacityReservation).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		capacityReservation := *capacityReservation_ARM.(*arm.CapacityReservationProfile)
		result.Properties.CapacityReservation = &capacityReservation
	}
	if machine.DiagnosticsProfile != nil {
		diagnosticsProfile_ARM, err := (*machine.DiagnosticsProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		diagnosticsProfile := *diagnosticsProfile_ARM.(*arm.DiagnosticsProfile)
		result.Properties.DiagnosticsProfile = &diagnosticsProfile
	}
	if machine.EvictionPolicy != nil {
		var temp string
		temp = string(*machine.EvictionPolicy)
		evictionPolicy := arm.EvictionPolicy(temp)
		result.Properties.EvictionPolicy = &evictionPolicy
	}
	if machine.ExtensionsTimeBudget != nil {
		extensionsTimeBudget := *machine.ExtensionsTimeBudget
		result.Properties.ExtensionsTimeBudget = &extensionsTimeBudget
	}
	if machine.HardwareProfile != nil {
		hardwareProfile_ARM, err := (*machine.HardwareProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		hardwareProfile := *hardwareProfile_ARM.(*arm.HardwareProfile)
		result.Properties.HardwareProfile = &hardwareProfile
	}
	if machine.Host != nil {
		host_ARM, err := (*machine.Host).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		host := *host_ARM.(*arm.SubResource)
		result.Properties.Host = &host
	}
	if machine.HostGroup != nil {
		hostGroup_ARM, err := (*machine.HostGroup).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		hostGroup := *hostGroup_ARM.(*arm.SubResource)
		result.Properties.HostGroup = &hostGroup
	}
	if machine.LicenseType != nil {
		licenseType := *machine.LicenseType
		result.Properties.LicenseType = &licenseType
	}
	if machine.NetworkProfile != nil {
		networkProfile_ARM, err := (*machine.NetworkProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		networkProfile := *networkProfile_ARM.(*arm.NetworkProfile)
		result.Properties.NetworkProfile = &networkProfile
	}
	if machine.OsProfile != nil {
		osProfile_ARM, err := (*machine.OsProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		osProfile := *osProfile_ARM.(*arm.OSProfile)
		result.Properties.OsProfile = &osProfile
	}
	if machine.PlatformFaultDomain != nil {
		platformFaultDomain := *machine.PlatformFaultDomain
		result.Properties.PlatformFaultDomain = &platformFaultDomain
	}
	if machine.Priority != nil {
		var temp string
		temp = string(*machine.Priority)
		priority := arm.Priority(temp)
		result.Properties.Priority = &priority
	}
	if machine.ProximityPlacementGroup != nil {
		proximityPlacementGroup_ARM, err := (*machine.ProximityPlacementGroup).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		proximityPlacementGroup := *proximityPlacementGroup_ARM.(*arm.SubResource)
		result.Properties.ProximityPlacementGroup = &proximityPlacementGroup
	}
	if machine.ScheduledEventsProfile != nil {
		scheduledEventsProfile_ARM, err := (*machine.ScheduledEventsProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		scheduledEventsProfile := *scheduledEventsProfile_ARM.(*arm.ScheduledEventsProfile)
		result.Properties.ScheduledEventsProfile = &scheduledEventsProfile
	}
	if machine.SecurityProfile != nil {
		securityProfile_ARM, err := (*machine.SecurityProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		securityProfile := *securityProfile_ARM.(*arm.SecurityProfile)
		result.Properties.SecurityProfile = &securityProfile
	}
	if machine.StorageProfile != nil {
		storageProfile_ARM, err := (*machine.StorageProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		storageProfile := *storageProfile_ARM.(*arm.StorageProfile)
		result.Properties.StorageProfile = &storageProfile
	}
	if machine.UserData != nil {
		userData := *machine.UserData
		result.Properties.UserData = &userData
	}
	if machine.VirtualMachineScaleSet != nil {
		virtualMachineScaleSet_ARM, err := (*machine.VirtualMachineScaleSet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		virtualMachineScaleSet := *virtualMachineScaleSet_ARM.(*arm.SubResource)
		result.Properties.VirtualMachineScaleSet = &virtualMachineScaleSet
	}

	// Set property "Tags":
	if machine.Tags != nil {
		result.Tags = make(map[string]string, len(machine.Tags))
		for key, value := range machine.Tags {
			result.Tags[key] = value
		}
	}

	// Set property "Zones":
	for _, item := range machine.Zones {
		result.Zones = append(result.Zones, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (machine *VirtualMachine_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachine_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (machine *VirtualMachine_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachine_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachine_Spec, got %T", armInput)
	}

	// Set property "AdditionalCapabilities":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AdditionalCapabilities != nil {
			var additionalCapabilities1 AdditionalCapabilities
			err := additionalCapabilities1.PopulateFromARM(owner, *typedInput.Properties.AdditionalCapabilities)
			if err != nil {
				return err
			}
			additionalCapabilities := additionalCapabilities1
			machine.AdditionalCapabilities = &additionalCapabilities
		}
	}

	// Set property "ApplicationProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ApplicationProfile != nil {
			var applicationProfile1 ApplicationProfile
			err := applicationProfile1.PopulateFromARM(owner, *typedInput.Properties.ApplicationProfile)
			if err != nil {
				return err
			}
			applicationProfile := applicationProfile1
			machine.ApplicationProfile = &applicationProfile
		}
	}

	// Set property "AvailabilitySet":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AvailabilitySet != nil {
			var availabilitySet1 SubResource
			err := availabilitySet1.PopulateFromARM(owner, *typedInput.Properties.AvailabilitySet)
			if err != nil {
				return err
			}
			availabilitySet := availabilitySet1
			machine.AvailabilitySet = &availabilitySet
		}
	}

	// Set property "AzureName":
	machine.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "BillingProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BillingProfile != nil {
			var billingProfile1 BillingProfile
			err := billingProfile1.PopulateFromARM(owner, *typedInput.Properties.BillingProfile)
			if err != nil {
				return err
			}
			billingProfile := billingProfile1
			machine.BillingProfile = &billingProfile
		}
	}

	// Set property "CapacityReservation":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CapacityReservation != nil {
			var capacityReservation1 CapacityReservationProfile
			err := capacityReservation1.PopulateFromARM(owner, *typedInput.Properties.CapacityReservation)
			if err != nil {
				return err
			}
			capacityReservation := capacityReservation1
			machine.CapacityReservation = &capacityReservation
		}
	}

	// Set property "DiagnosticsProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DiagnosticsProfile != nil {
			var diagnosticsProfile1 DiagnosticsProfile
			err := diagnosticsProfile1.PopulateFromARM(owner, *typedInput.Properties.DiagnosticsProfile)
			if err != nil {
				return err
			}
			diagnosticsProfile := diagnosticsProfile1
			machine.DiagnosticsProfile = &diagnosticsProfile
		}
	}

	// Set property "EvictionPolicy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EvictionPolicy != nil {
			var temp string
			temp = string(*typedInput.Properties.EvictionPolicy)
			evictionPolicy := EvictionPolicy(temp)
			machine.EvictionPolicy = &evictionPolicy
		}
	}

	// Set property "ExtendedLocation":
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		machine.ExtendedLocation = &extendedLocation
	}

	// Set property "ExtensionsTimeBudget":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ExtensionsTimeBudget != nil {
			extensionsTimeBudget := *typedInput.Properties.ExtensionsTimeBudget
			machine.ExtensionsTimeBudget = &extensionsTimeBudget
		}
	}

	// Set property "HardwareProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HardwareProfile != nil {
			var hardwareProfile1 HardwareProfile
			err := hardwareProfile1.PopulateFromARM(owner, *typedInput.Properties.HardwareProfile)
			if err != nil {
				return err
			}
			hardwareProfile := hardwareProfile1
			machine.HardwareProfile = &hardwareProfile
		}
	}

	// Set property "Host":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Host != nil {
			var host1 SubResource
			err := host1.PopulateFromARM(owner, *typedInput.Properties.Host)
			if err != nil {
				return err
			}
			host := host1
			machine.Host = &host
		}
	}

	// Set property "HostGroup":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostGroup != nil {
			var hostGroup1 SubResource
			err := hostGroup1.PopulateFromARM(owner, *typedInput.Properties.HostGroup)
			if err != nil {
				return err
			}
			hostGroup := hostGroup1
			machine.HostGroup = &hostGroup
		}
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 VirtualMachineIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		machine.Identity = &identity
	}

	// Set property "LicenseType":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LicenseType != nil {
			licenseType := *typedInput.Properties.LicenseType
			machine.LicenseType = &licenseType
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		machine.Location = &location
	}

	// Set property "NetworkProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkProfile != nil {
			var networkProfile1 NetworkProfile
			err := networkProfile1.PopulateFromARM(owner, *typedInput.Properties.NetworkProfile)
			if err != nil {
				return err
			}
			networkProfile := networkProfile1
			machine.NetworkProfile = &networkProfile
		}
	}

	// no assignment for property "OperatorSpec"

	// Set property "OsProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OsProfile != nil {
			var osProfile1 OSProfile
			err := osProfile1.PopulateFromARM(owner, *typedInput.Properties.OsProfile)
			if err != nil {
				return err
			}
			osProfile := osProfile1
			machine.OsProfile = &osProfile
		}
	}

	// Set property "Owner":
	machine.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "Plan":
	if typedInput.Plan != nil {
		var plan1 Plan
		err := plan1.PopulateFromARM(owner, *typedInput.Plan)
		if err != nil {
			return err
		}
		plan := plan1
		machine.Plan = &plan
	}

	// Set property "PlatformFaultDomain":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PlatformFaultDomain != nil {
			platformFaultDomain := *typedInput.Properties.PlatformFaultDomain
			machine.PlatformFaultDomain = &platformFaultDomain
		}
	}

	// Set property "Priority":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Priority != nil {
			var temp string
			temp = string(*typedInput.Properties.Priority)
			priority := Priority(temp)
			machine.Priority = &priority
		}
	}

	// Set property "ProximityPlacementGroup":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProximityPlacementGroup != nil {
			var proximityPlacementGroup1 SubResource
			err := proximityPlacementGroup1.PopulateFromARM(owner, *typedInput.Properties.ProximityPlacementGroup)
			if err != nil {
				return err
			}
			proximityPlacementGroup := proximityPlacementGroup1
			machine.ProximityPlacementGroup = &proximityPlacementGroup
		}
	}

	// Set property "ScheduledEventsProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ScheduledEventsProfile != nil {
			var scheduledEventsProfile1 ScheduledEventsProfile
			err := scheduledEventsProfile1.PopulateFromARM(owner, *typedInput.Properties.ScheduledEventsProfile)
			if err != nil {
				return err
			}
			scheduledEventsProfile := scheduledEventsProfile1
			machine.ScheduledEventsProfile = &scheduledEventsProfile
		}
	}

	// Set property "SecurityProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SecurityProfile != nil {
			var securityProfile1 SecurityProfile
			err := securityProfile1.PopulateFromARM(owner, *typedInput.Properties.SecurityProfile)
			if err != nil {
				return err
			}
			securityProfile := securityProfile1
			machine.SecurityProfile = &securityProfile
		}
	}

	// Set property "StorageProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.StorageProfile != nil {
			var storageProfile1 StorageProfile
			err := storageProfile1.PopulateFromARM(owner, *typedInput.Properties.StorageProfile)
			if err != nil {
				return err
			}
			storageProfile := storageProfile1
			machine.StorageProfile = &storageProfile
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		machine.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			machine.Tags[key] = value
		}
	}

	// Set property "UserData":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.UserData != nil {
			userData := *typedInput.Properties.UserData
			machine.UserData = &userData
		}
	}

	// Set property "VirtualMachineScaleSet":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VirtualMachineScaleSet != nil {
			var virtualMachineScaleSet1 SubResource
			err := virtualMachineScaleSet1.PopulateFromARM(owner, *typedInput.Properties.VirtualMachineScaleSet)
			if err != nil {
				return err
			}
			virtualMachineScaleSet := virtualMachineScaleSet1
			machine.VirtualMachineScaleSet = &virtualMachineScaleSet
		}
	}

	// Set property "Zones":
	for _, item := range typedInput.Zones {
		machine.Zones = append(machine.Zones, item)
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &VirtualMachine_Spec{}

// ConvertSpecFrom populates our VirtualMachine_Spec from the provided source
func (machine *VirtualMachine_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.VirtualMachine_Spec)
	if ok {
		// Populate our instance from source
		return machine.AssignProperties_From_VirtualMachine_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.VirtualMachine_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = machine.AssignProperties_From_VirtualMachine_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our VirtualMachine_Spec
func (machine *VirtualMachine_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.VirtualMachine_Spec)
	if ok {
		// Populate destination from our instance
		return machine.AssignProperties_To_VirtualMachine_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.VirtualMachine_Spec{}
	err := machine.AssignProperties_To_VirtualMachine_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_VirtualMachine_Spec populates our VirtualMachine_Spec from the provided source VirtualMachine_Spec
func (machine *VirtualMachine_Spec) AssignProperties_From_VirtualMachine_Spec(source *storage.VirtualMachine_Spec) error {

	// AdditionalCapabilities
	if source.AdditionalCapabilities != nil {
		var additionalCapability AdditionalCapabilities
		err := additionalCapability.AssignProperties_From_AdditionalCapabilities(source.AdditionalCapabilities)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AdditionalCapabilities() to populate field AdditionalCapabilities")
		}
		machine.AdditionalCapabilities = &additionalCapability
	} else {
		machine.AdditionalCapabilities = nil
	}

	// ApplicationProfile
	if source.ApplicationProfile != nil {
		var applicationProfile ApplicationProfile
		err := applicationProfile.AssignProperties_From_ApplicationProfile(source.ApplicationProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApplicationProfile() to populate field ApplicationProfile")
		}
		machine.ApplicationProfile = &applicationProfile
	} else {
		machine.ApplicationProfile = nil
	}

	// AvailabilitySet
	if source.AvailabilitySet != nil {
		var availabilitySet SubResource
		err := availabilitySet.AssignProperties_From_SubResource(source.AvailabilitySet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field AvailabilitySet")
		}
		machine.AvailabilitySet = &availabilitySet
	} else {
		machine.AvailabilitySet = nil
	}

	// AzureName
	machine.AzureName = source.AzureName

	// BillingProfile
	if source.BillingProfile != nil {
		var billingProfile BillingProfile
		err := billingProfile.AssignProperties_From_BillingProfile(source.BillingProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BillingProfile() to populate field BillingProfile")
		}
		machine.BillingProfile = &billingProfile
	} else {
		machine.BillingProfile = nil
	}

	// CapacityReservation
	if source.CapacityReservation != nil {
		var capacityReservation CapacityReservationProfile
		err := capacityReservation.AssignProperties_From_CapacityReservationProfile(source.CapacityReservation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CapacityReservationProfile() to populate field CapacityReservation")
		}
		machine.CapacityReservation = &capacityReservation
	} else {
		machine.CapacityReservation = nil
	}

	// DiagnosticsProfile
	if source.DiagnosticsProfile != nil {
		var diagnosticsProfile DiagnosticsProfile
		err := diagnosticsProfile.AssignProperties_From_DiagnosticsProfile(source.DiagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DiagnosticsProfile() to populate field DiagnosticsProfile")
		}
		machine.DiagnosticsProfile = &diagnosticsProfile
	} else {
		machine.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	if source.EvictionPolicy != nil {
		evictionPolicy := *source.EvictionPolicy
		evictionPolicyTemp := genruntime.ToEnum(evictionPolicy, evictionPolicy_Values)
		machine.EvictionPolicy = &evictionPolicyTemp
	} else {
		machine.EvictionPolicy = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation
		err := extendedLocation.AssignProperties_From_ExtendedLocation(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ExtendedLocation() to populate field ExtendedLocation")
		}
		machine.ExtendedLocation = &extendedLocation
	} else {
		machine.ExtendedLocation = nil
	}

	// ExtensionsTimeBudget
	machine.ExtensionsTimeBudget = genruntime.ClonePointerToString(source.ExtensionsTimeBudget)

	// HardwareProfile
	if source.HardwareProfile != nil {
		var hardwareProfile HardwareProfile
		err := hardwareProfile.AssignProperties_From_HardwareProfile(source.HardwareProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HardwareProfile() to populate field HardwareProfile")
		}
		machine.HardwareProfile = &hardwareProfile
	} else {
		machine.HardwareProfile = nil
	}

	// Host
	if source.Host != nil {
		var host SubResource
		err := host.AssignProperties_From_SubResource(source.Host)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field Host")
		}
		machine.Host = &host
	} else {
		machine.Host = nil
	}

	// HostGroup
	if source.HostGroup != nil {
		var hostGroup SubResource
		err := hostGroup.AssignProperties_From_SubResource(source.HostGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field HostGroup")
		}
		machine.HostGroup = &hostGroup
	} else {
		machine.HostGroup = nil
	}

	// Identity
	if source.Identity != nil {
		var identity VirtualMachineIdentity
		err := identity.AssignProperties_From_VirtualMachineIdentity(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineIdentity() to populate field Identity")
		}
		machine.Identity = &identity
	} else {
		machine.Identity = nil
	}

	// LicenseType
	machine.LicenseType = genruntime.ClonePointerToString(source.LicenseType)

	// Location
	machine.Location = genruntime.ClonePointerToString(source.Location)

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile NetworkProfile
		err := networkProfile.AssignProperties_From_NetworkProfile(source.NetworkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_NetworkProfile() to populate field NetworkProfile")
		}
		machine.NetworkProfile = &networkProfile
	} else {
		machine.NetworkProfile = nil
	}

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec VirtualMachineOperatorSpec
		err := operatorSpec.AssignProperties_From_VirtualMachineOperatorSpec(source.OperatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineOperatorSpec() to populate field OperatorSpec")
		}
		machine.OperatorSpec = &operatorSpec
	} else {
		machine.OperatorSpec = nil
	}

	// OsProfile
	if source.OsProfile != nil {
		var osProfile OSProfile
		err := osProfile.AssignProperties_From_OSProfile(source.OsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OSProfile() to populate field OsProfile")
		}
		machine.OsProfile = &osProfile
	} else {
		machine.OsProfile = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		machine.Owner = &owner
	} else {
		machine.Owner = nil
	}

	// Plan
	if source.Plan != nil {
		var plan Plan
		err := plan.AssignProperties_From_Plan(source.Plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Plan() to populate field Plan")
		}
		machine.Plan = &plan
	} else {
		machine.Plan = nil
	}

	// PlatformFaultDomain
	machine.PlatformFaultDomain = genruntime.ClonePointerToInt(source.PlatformFaultDomain)

	// Priority
	if source.Priority != nil {
		priority := *source.Priority
		priorityTemp := genruntime.ToEnum(priority, priority_Values)
		machine.Priority = &priorityTemp
	} else {
		machine.Priority = nil
	}

	// ProximityPlacementGroup
	if source.ProximityPlacementGroup != nil {
		var proximityPlacementGroup SubResource
		err := proximityPlacementGroup.AssignProperties_From_SubResource(source.ProximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field ProximityPlacementGroup")
		}
		machine.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		machine.ProximityPlacementGroup = nil
	}

	// ScheduledEventsProfile
	if source.ScheduledEventsProfile != nil {
		var scheduledEventsProfile ScheduledEventsProfile
		err := scheduledEventsProfile.AssignProperties_From_ScheduledEventsProfile(source.ScheduledEventsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ScheduledEventsProfile() to populate field ScheduledEventsProfile")
		}
		machine.ScheduledEventsProfile = &scheduledEventsProfile
	} else {
		machine.ScheduledEventsProfile = nil
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		var securityProfile SecurityProfile
		err := securityProfile.AssignProperties_From_SecurityProfile(source.SecurityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SecurityProfile() to populate field SecurityProfile")
		}
		machine.SecurityProfile = &securityProfile
	} else {
		machine.SecurityProfile = nil
	}

	// StorageProfile
	if source.StorageProfile != nil {
		var storageProfile StorageProfile
		err := storageProfile.AssignProperties_From_StorageProfile(source.StorageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_StorageProfile() to populate field StorageProfile")
		}
		machine.StorageProfile = &storageProfile
	} else {
		machine.StorageProfile = nil
	}

	// Tags
	machine.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// UserData
	machine.UserData = genruntime.ClonePointerToString(source.UserData)

	// VirtualMachineScaleSet
	if source.VirtualMachineScaleSet != nil {
		var virtualMachineScaleSet SubResource
		err := virtualMachineScaleSet.AssignProperties_From_SubResource(source.VirtualMachineScaleSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field VirtualMachineScaleSet")
		}
		machine.VirtualMachineScaleSet = &virtualMachineScaleSet
	} else {
		machine.VirtualMachineScaleSet = nil
	}

	// Zones
	machine.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachine_Spec populates the provided destination VirtualMachine_Spec from our VirtualMachine_Spec
func (machine *VirtualMachine_Spec) AssignProperties_To_VirtualMachine_Spec(destination *storage.VirtualMachine_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalCapabilities
	if machine.AdditionalCapabilities != nil {
		var additionalCapability storage.AdditionalCapabilities
		err := machine.AdditionalCapabilities.AssignProperties_To_AdditionalCapabilities(&additionalCapability)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AdditionalCapabilities() to populate field AdditionalCapabilities")
		}
		destination.AdditionalCapabilities = &additionalCapability
	} else {
		destination.AdditionalCapabilities = nil
	}

	// ApplicationProfile
	if machine.ApplicationProfile != nil {
		var applicationProfile storage.ApplicationProfile
		err := machine.ApplicationProfile.AssignProperties_To_ApplicationProfile(&applicationProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApplicationProfile() to populate field ApplicationProfile")
		}
		destination.ApplicationProfile = &applicationProfile
	} else {
		destination.ApplicationProfile = nil
	}

	// AvailabilitySet
	if machine.AvailabilitySet != nil {
		var availabilitySet storage.SubResource
		err := machine.AvailabilitySet.AssignProperties_To_SubResource(&availabilitySet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field AvailabilitySet")
		}
		destination.AvailabilitySet = &availabilitySet
	} else {
		destination.AvailabilitySet = nil
	}

	// AzureName
	destination.AzureName = machine.AzureName

	// BillingProfile
	if machine.BillingProfile != nil {
		var billingProfile storage.BillingProfile
		err := machine.BillingProfile.AssignProperties_To_BillingProfile(&billingProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BillingProfile() to populate field BillingProfile")
		}
		destination.BillingProfile = &billingProfile
	} else {
		destination.BillingProfile = nil
	}

	// CapacityReservation
	if machine.CapacityReservation != nil {
		var capacityReservation storage.CapacityReservationProfile
		err := machine.CapacityReservation.AssignProperties_To_CapacityReservationProfile(&capacityReservation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CapacityReservationProfile() to populate field CapacityReservation")
		}
		destination.CapacityReservation = &capacityReservation
	} else {
		destination.CapacityReservation = nil
	}

	// DiagnosticsProfile
	if machine.DiagnosticsProfile != nil {
		var diagnosticsProfile storage.DiagnosticsProfile
		err := machine.DiagnosticsProfile.AssignProperties_To_DiagnosticsProfile(&diagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DiagnosticsProfile() to populate field DiagnosticsProfile")
		}
		destination.DiagnosticsProfile = &diagnosticsProfile
	} else {
		destination.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	if machine.EvictionPolicy != nil {
		evictionPolicy := string(*machine.EvictionPolicy)
		destination.EvictionPolicy = &evictionPolicy
	} else {
		destination.EvictionPolicy = nil
	}

	// ExtendedLocation
	if machine.ExtendedLocation != nil {
		var extendedLocation storage.ExtendedLocation
		err := machine.ExtendedLocation.AssignProperties_To_ExtendedLocation(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ExtendedLocation() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// ExtensionsTimeBudget
	destination.ExtensionsTimeBudget = genruntime.ClonePointerToString(machine.ExtensionsTimeBudget)

	// HardwareProfile
	if machine.HardwareProfile != nil {
		var hardwareProfile storage.HardwareProfile
		err := machine.HardwareProfile.AssignProperties_To_HardwareProfile(&hardwareProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HardwareProfile() to populate field HardwareProfile")
		}
		destination.HardwareProfile = &hardwareProfile
	} else {
		destination.HardwareProfile = nil
	}

	// Host
	if machine.Host != nil {
		var host storage.SubResource
		err := machine.Host.AssignProperties_To_SubResource(&host)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field Host")
		}
		destination.Host = &host
	} else {
		destination.Host = nil
	}

	// HostGroup
	if machine.HostGroup != nil {
		var hostGroup storage.SubResource
		err := machine.HostGroup.AssignProperties_To_SubResource(&hostGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field HostGroup")
		}
		destination.HostGroup = &hostGroup
	} else {
		destination.HostGroup = nil
	}

	// Identity
	if machine.Identity != nil {
		var identity storage.VirtualMachineIdentity
		err := machine.Identity.AssignProperties_To_VirtualMachineIdentity(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// LicenseType
	destination.LicenseType = genruntime.ClonePointerToString(machine.LicenseType)

	// Location
	destination.Location = genruntime.ClonePointerToString(machine.Location)

	// NetworkProfile
	if machine.NetworkProfile != nil {
		var networkProfile storage.NetworkProfile
		err := machine.NetworkProfile.AssignProperties_To_NetworkProfile(&networkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_NetworkProfile() to populate field NetworkProfile")
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// OperatorSpec
	if machine.OperatorSpec != nil {
		var operatorSpec storage.VirtualMachineOperatorSpec
		err := machine.OperatorSpec.AssignProperties_To_VirtualMachineOperatorSpec(&operatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = machine.OriginalVersion()

	// OsProfile
	if machine.OsProfile != nil {
		var osProfile storage.OSProfile
		err := machine.OsProfile.AssignProperties_To_OSProfile(&osProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OSProfile() to populate field OsProfile")
		}
		destination.OsProfile = &osProfile
	} else {
		destination.OsProfile = nil
	}

	// Owner
	if machine.Owner != nil {
		owner := machine.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Plan
	if machine.Plan != nil {
		var plan storage.Plan
		err := machine.Plan.AssignProperties_To_Plan(&plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Plan() to populate field Plan")
		}
		destination.Plan = &plan
	} else {
		destination.Plan = nil
	}

	// PlatformFaultDomain
	destination.PlatformFaultDomain = genruntime.ClonePointerToInt(machine.PlatformFaultDomain)

	// Priority
	if machine.Priority != nil {
		priority := string(*machine.Priority)
		destination.Priority = &priority
	} else {
		destination.Priority = nil
	}

	// ProximityPlacementGroup
	if machine.ProximityPlacementGroup != nil {
		var proximityPlacementGroup storage.SubResource
		err := machine.ProximityPlacementGroup.AssignProperties_To_SubResource(&proximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field ProximityPlacementGroup")
		}
		destination.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		destination.ProximityPlacementGroup = nil
	}

	// ScheduledEventsProfile
	if machine.ScheduledEventsProfile != nil {
		var scheduledEventsProfile storage.ScheduledEventsProfile
		err := machine.ScheduledEventsProfile.AssignProperties_To_ScheduledEventsProfile(&scheduledEventsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ScheduledEventsProfile() to populate field ScheduledEventsProfile")
		}
		destination.ScheduledEventsProfile = &scheduledEventsProfile
	} else {
		destination.ScheduledEventsProfile = nil
	}

	// SecurityProfile
	if machine.SecurityProfile != nil {
		var securityProfile storage.SecurityProfile
		err := machine.SecurityProfile.AssignProperties_To_SecurityProfile(&securityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SecurityProfile() to populate field SecurityProfile")
		}
		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// StorageProfile
	if machine.StorageProfile != nil {
		var storageProfile storage.StorageProfile
		err := machine.StorageProfile.AssignProperties_To_StorageProfile(&storageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_StorageProfile() to populate field StorageProfile")
		}
		destination.StorageProfile = &storageProfile
	} else {
		destination.StorageProfile = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(machine.Tags)

	// UserData
	destination.UserData = genruntime.ClonePointerToString(machine.UserData)

	// VirtualMachineScaleSet
	if machine.VirtualMachineScaleSet != nil {
		var virtualMachineScaleSet storage.SubResource
		err := machine.VirtualMachineScaleSet.AssignProperties_To_SubResource(&virtualMachineScaleSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field VirtualMachineScaleSet")
		}
		destination.VirtualMachineScaleSet = &virtualMachineScaleSet
	} else {
		destination.VirtualMachineScaleSet = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(machine.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualMachine_STATUS populates our VirtualMachine_Spec from the provided source VirtualMachine_STATUS
func (machine *VirtualMachine_Spec) Initialize_From_VirtualMachine_STATUS(source *VirtualMachine_STATUS) error {

	// AdditionalCapabilities
	if source.AdditionalCapabilities != nil {
		var additionalCapability AdditionalCapabilities
		err := additionalCapability.Initialize_From_AdditionalCapabilities_STATUS(source.AdditionalCapabilities)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_AdditionalCapabilities_STATUS() to populate field AdditionalCapabilities")
		}
		machine.AdditionalCapabilities = &additionalCapability
	} else {
		machine.AdditionalCapabilities = nil
	}

	// ApplicationProfile
	if source.ApplicationProfile != nil {
		var applicationProfile ApplicationProfile
		err := applicationProfile.Initialize_From_ApplicationProfile_STATUS(source.ApplicationProfile)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ApplicationProfile_STATUS() to populate field ApplicationProfile")
		}
		machine.ApplicationProfile = &applicationProfile
	} else {
		machine.ApplicationProfile = nil
	}

	// AvailabilitySet
	if source.AvailabilitySet != nil {
		var availabilitySet SubResource
		err := availabilitySet.Initialize_From_SubResource_STATUS(source.AvailabilitySet)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SubResource_STATUS() to populate field AvailabilitySet")
		}
		machine.AvailabilitySet = &availabilitySet
	} else {
		machine.AvailabilitySet = nil
	}

	// BillingProfile
	if source.BillingProfile != nil {
		var billingProfile BillingProfile
		err := billingProfile.Initialize_From_BillingProfile_STATUS(source.BillingProfile)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_BillingProfile_STATUS() to populate field BillingProfile")
		}
		machine.BillingProfile = &billingProfile
	} else {
		machine.BillingProfile = nil
	}

	// CapacityReservation
	if source.CapacityReservation != nil {
		var capacityReservation CapacityReservationProfile
		err := capacityReservation.Initialize_From_CapacityReservationProfile_STATUS(source.CapacityReservation)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_CapacityReservationProfile_STATUS() to populate field CapacityReservation")
		}
		machine.CapacityReservation = &capacityReservation
	} else {
		machine.CapacityReservation = nil
	}

	// DiagnosticsProfile
	if source.DiagnosticsProfile != nil {
		var diagnosticsProfile DiagnosticsProfile
		err := diagnosticsProfile.Initialize_From_DiagnosticsProfile_STATUS(source.DiagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DiagnosticsProfile_STATUS() to populate field DiagnosticsProfile")
		}
		machine.DiagnosticsProfile = &diagnosticsProfile
	} else {
		machine.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	if source.EvictionPolicy != nil {
		evictionPolicy := genruntime.ToEnum(string(*source.EvictionPolicy), evictionPolicy_Values)
		machine.EvictionPolicy = &evictionPolicy
	} else {
		machine.EvictionPolicy = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation
		err := extendedLocation.Initialize_From_ExtendedLocation_STATUS(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ExtendedLocation_STATUS() to populate field ExtendedLocation")
		}
		machine.ExtendedLocation = &extendedLocation
	} else {
		machine.ExtendedLocation = nil
	}

	// ExtensionsTimeBudget
	machine.ExtensionsTimeBudget = genruntime.ClonePointerToString(source.ExtensionsTimeBudget)

	// HardwareProfile
	if source.HardwareProfile != nil {
		var hardwareProfile HardwareProfile
		err := hardwareProfile.Initialize_From_HardwareProfile_STATUS(source.HardwareProfile)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_HardwareProfile_STATUS() to populate field HardwareProfile")
		}
		machine.HardwareProfile = &hardwareProfile
	} else {
		machine.HardwareProfile = nil
	}

	// Host
	if source.Host != nil {
		var host SubResource
		err := host.Initialize_From_SubResource_STATUS(source.Host)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SubResource_STATUS() to populate field Host")
		}
		machine.Host = &host
	} else {
		machine.Host = nil
	}

	// HostGroup
	if source.HostGroup != nil {
		var hostGroup SubResource
		err := hostGroup.Initialize_From_SubResource_STATUS(source.HostGroup)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SubResource_STATUS() to populate field HostGroup")
		}
		machine.HostGroup = &hostGroup
	} else {
		machine.HostGroup = nil
	}

	// Identity
	if source.Identity != nil {
		var identity VirtualMachineIdentity
		err := identity.Initialize_From_VirtualMachineIdentity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_VirtualMachineIdentity_STATUS() to populate field Identity")
		}
		machine.Identity = &identity
	} else {
		machine.Identity = nil
	}

	// LicenseType
	machine.LicenseType = genruntime.ClonePointerToString(source.LicenseType)

	// Location
	machine.Location = genruntime.ClonePointerToString(source.Location)

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile NetworkProfile
		err := networkProfile.Initialize_From_NetworkProfile_STATUS(source.NetworkProfile)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_NetworkProfile_STATUS() to populate field NetworkProfile")
		}
		machine.NetworkProfile = &networkProfile
	} else {
		machine.NetworkProfile = nil
	}

	// OsProfile
	if source.OsProfile != nil {
		var osProfile OSProfile
		err := osProfile.Initialize_From_OSProfile_STATUS(source.OsProfile)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_OSProfile_STATUS() to populate field OsProfile")
		}
		machine.OsProfile = &osProfile
	} else {
		machine.OsProfile = nil
	}

	// Plan
	if source.Plan != nil {
		var plan Plan
		err := plan.Initialize_From_Plan_STATUS(source.Plan)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_Plan_STATUS() to populate field Plan")
		}
		machine.Plan = &plan
	} else {
		machine.Plan = nil
	}

	// PlatformFaultDomain
	machine.PlatformFaultDomain = genruntime.ClonePointerToInt(source.PlatformFaultDomain)

	// Priority
	if source.Priority != nil {
		priority := genruntime.ToEnum(string(*source.Priority), priority_Values)
		machine.Priority = &priority
	} else {
		machine.Priority = nil
	}

	// ProximityPlacementGroup
	if source.ProximityPlacementGroup != nil {
		var proximityPlacementGroup SubResource
		err := proximityPlacementGroup.Initialize_From_SubResource_STATUS(source.ProximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SubResource_STATUS() to populate field ProximityPlacementGroup")
		}
		machine.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		machine.ProximityPlacementGroup = nil
	}

	// ScheduledEventsProfile
	if source.ScheduledEventsProfile != nil {
		var scheduledEventsProfile ScheduledEventsProfile
		err := scheduledEventsProfile.Initialize_From_ScheduledEventsProfile_STATUS(source.ScheduledEventsProfile)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ScheduledEventsProfile_STATUS() to populate field ScheduledEventsProfile")
		}
		machine.ScheduledEventsProfile = &scheduledEventsProfile
	} else {
		machine.ScheduledEventsProfile = nil
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		var securityProfile SecurityProfile
		err := securityProfile.Initialize_From_SecurityProfile_STATUS(source.SecurityProfile)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SecurityProfile_STATUS() to populate field SecurityProfile")
		}
		machine.SecurityProfile = &securityProfile
	} else {
		machine.SecurityProfile = nil
	}

	// StorageProfile
	if source.StorageProfile != nil {
		var storageProfile StorageProfile
		err := storageProfile.Initialize_From_StorageProfile_STATUS(source.StorageProfile)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_StorageProfile_STATUS() to populate field StorageProfile")
		}
		machine.StorageProfile = &storageProfile
	} else {
		machine.StorageProfile = nil
	}

	// Tags
	machine.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// UserData
	machine.UserData = genruntime.ClonePointerToString(source.UserData)

	// VirtualMachineScaleSet
	if source.VirtualMachineScaleSet != nil {
		var virtualMachineScaleSet SubResource
		err := virtualMachineScaleSet.Initialize_From_SubResource_STATUS(source.VirtualMachineScaleSet)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SubResource_STATUS() to populate field VirtualMachineScaleSet")
		}
		machine.VirtualMachineScaleSet = &virtualMachineScaleSet
	} else {
		machine.VirtualMachineScaleSet = nil
	}

	// Zones
	machine.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (machine *VirtualMachine_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (machine *VirtualMachine_Spec) SetAzureName(azureName string) { machine.AzureName = azureName }

// Describes a Virtual Machine.
type VirtualMachine_STATUS struct {
	// AdditionalCapabilities: Specifies additional capabilities enabled or disabled on the virtual machine.
	AdditionalCapabilities *AdditionalCapabilities_STATUS `json:"additionalCapabilities,omitempty"`

	// ApplicationProfile: Specifies the gallery applications that should be made available to the VM/VMSS
	ApplicationProfile *ApplicationProfile_STATUS `json:"applicationProfile,omitempty"`

	// AvailabilitySet: Specifies information about the availability set that the virtual machine should be assigned to.
	// Virtual machines specified in the same availability set are allocated to different nodes to maximize availability. For
	// more information about availability sets, see [Availability sets
	// overview](https://docs.microsoft.com/azure/virtual-machines/availability-set-overview).
	// For more information on Azure planned maintenance, see [Maintenance and updates for Virtual Machines in
	// Azure](https://docs.microsoft.com/azure/virtual-machines/maintenance-and-updates)
	// Currently, a VM can only be added to availability set at creation time. The availability set to which the VM is being
	// added should be under the same resource group as the availability set resource. An existing VM cannot be added to an
	// availability set.
	// This property cannot exist along with a non-null properties.virtualMachineScaleSet reference.
	AvailabilitySet *SubResource_STATUS `json:"availabilitySet,omitempty"`

	// BillingProfile: Specifies the billing related details of a Azure Spot virtual machine.
	// Minimum api-version: 2019-03-01.
	BillingProfile *BillingProfile_STATUS `json:"billingProfile,omitempty"`

	// CapacityReservation: Specifies information about the capacity reservation that is used to allocate virtual machine.
	// Minimum api-version: 2021-04-01.
	CapacityReservation *CapacityReservationProfile_STATUS `json:"capacityReservation,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// DiagnosticsProfile: Specifies the boot diagnostic settings state.
	// Minimum api-version: 2015-06-15.
	DiagnosticsProfile *DiagnosticsProfile_STATUS `json:"diagnosticsProfile,omitempty"`

	// EvictionPolicy: Specifies the eviction policy for the Azure Spot virtual machine and Azure Spot scale set.
	// For Azure Spot virtual machines, both 'Deallocate' and 'Delete' are supported and the minimum api-version is 2019-03-01.
	// For Azure Spot scale sets, both 'Deallocate' and 'Delete' are supported and the minimum api-version is
	// 2017-10-30-preview.
	EvictionPolicy *EvictionPolicy_STATUS `json:"evictionPolicy,omitempty"`

	// ExtendedLocation: The extended location of the Virtual Machine.
	ExtendedLocation *ExtendedLocation_STATUS `json:"extendedLocation,omitempty"`

	// ExtensionsTimeBudget: Specifies the time alloted for all extensions to start. The time duration should be between 15
	// minutes and 120 minutes (inclusive) and should be specified in ISO 8601 format. The default value is 90 minutes
	// (PT1H30M).
	// Minimum api-version: 2020-06-01
	ExtensionsTimeBudget *string `json:"extensionsTimeBudget,omitempty"`

	// HardwareProfile: Specifies the hardware settings for the virtual machine.
	HardwareProfile *HardwareProfile_STATUS `json:"hardwareProfile,omitempty"`

	// Host: Specifies information about the dedicated host that the virtual machine resides in.
	// Minimum api-version: 2018-10-01.
	Host *SubResource_STATUS `json:"host,omitempty"`

	// HostGroup: Specifies information about the dedicated host group that the virtual machine resides in.
	// Minimum api-version: 2020-06-01.
	// NOTE: User cannot specify both host and hostGroup properties.
	HostGroup *SubResource_STATUS `json:"hostGroup,omitempty"`

	// Id: Resource Id
	Id *string `json:"id,omitempty"`

	// Identity: The identity of the virtual machine, if configured.
	Identity *VirtualMachineIdentity_STATUS `json:"identity,omitempty"`

	// InstanceView: The virtual machine instance view.
	InstanceView *VirtualMachineInstanceView_STATUS `json:"instanceView,omitempty"`

	// LicenseType: Specifies that the image or disk that is being used was licensed on-premises.
	// Possible values for Windows Server operating system are:
	// Windows_Client
	// Windows_Server
	// Possible values for Linux Server operating system are:
	// RHEL_BYOS (for RHEL)
	// SLES_BYOS (for SUSE)
	// For more information, see [Azure Hybrid Use Benefit for Windows
	// Server](https://docs.microsoft.com/azure/virtual-machines/windows/hybrid-use-benefit-licensing)
	// [Azure Hybrid Use Benefit for Linux
	// Server](https://docs.microsoft.com/azure/virtual-machines/linux/azure-hybrid-benefit-linux)
	// Minimum api-version: 2015-06-15
	LicenseType *string `json:"licenseType,omitempty"`

	// Location: Resource location
	Location *string `json:"location,omitempty"`

	// Name: Resource name
	Name *string `json:"name,omitempty"`

	// NetworkProfile: Specifies the network interfaces of the virtual machine.
	NetworkProfile *NetworkProfile_STATUS `json:"networkProfile,omitempty"`

	// OsProfile: Specifies the operating system settings used while creating the virtual machine. Some of the settings cannot
	// be changed once VM is provisioned.
	OsProfile *OSProfile_STATUS `json:"osProfile,omitempty"`

	// Plan: Specifies information about the marketplace image used to create the virtual machine. This element is only used
	// for marketplace images. Before you can use a marketplace image from an API, you must enable the image for programmatic
	// use.  In the Azure portal, find the marketplace image that you want to use and then click Want to deploy
	// programmatically, Get Started ->. Enter any required information and then click Save.
	Plan *Plan_STATUS `json:"plan,omitempty"`

	// PlatformFaultDomain: Specifies the scale set logical fault domain into which the Virtual Machine will be created. By
	// default, the Virtual Machine will by automatically assigned to a fault domain that best maintains balance across
	// available fault domains.
	// <li>This is applicable only if the 'virtualMachineScaleSet' property of this Virtual Machine is set.<li>The Virtual
	// Machine Scale Set that is referenced, must have 'platformFaultDomainCount' &gt; 1.<li>This property cannot be updated
	// once the Virtual Machine is created.<li>Fault domain assignment can be viewed in the Virtual Machine Instance View.
	// Minimum api‐version: 2020‐12‐01
	PlatformFaultDomain *int `json:"platformFaultDomain,omitempty"`

	// Priority: Specifies the priority for the virtual machine.
	// Minimum api-version: 2019-03-01
	Priority *Priority_STATUS `json:"priority,omitempty"`

	// ProvisioningState: The provisioning state, which only appears in the response.
	ProvisioningState *string `json:"provisioningState,omitempty"`

	// ProximityPlacementGroup: Specifies information about the proximity placement group that the virtual machine should be
	// assigned to.
	// Minimum api-version: 2018-04-01.
	ProximityPlacementGroup *SubResource_STATUS `json:"proximityPlacementGroup,omitempty"`

	// Resources: The virtual machine child extension resources.
	Resources []VirtualMachineExtension_STATUS `json:"resources,omitempty"`

	// ScheduledEventsProfile: Specifies Scheduled Event related configurations.
	ScheduledEventsProfile *ScheduledEventsProfile_STATUS `json:"scheduledEventsProfile,omitempty"`

	// SecurityProfile: Specifies the Security related profile settings for the virtual machine.
	SecurityProfile *SecurityProfile_STATUS `json:"securityProfile,omitempty"`

	// StorageProfile: Specifies the storage settings for the virtual machine disks.
	StorageProfile *StorageProfile_STATUS `json:"storageProfile,omitempty"`

	// Tags: Resource tags
	Tags map[string]string `json:"tags,omitempty"`

	// TimeCreated: Specifies the time at which the Virtual Machine resource was created.
	// Minimum api-version: 2022-03-01.
	TimeCreated *string `json:"timeCreated,omitempty"`

	// Type: Resource type
	Type *string `json:"type,omitempty"`

	// UserData: UserData for the VM, which must be base-64 encoded. Customer should not pass any secrets in here.
	// Minimum api-version: 2021-03-01
	UserData *string `json:"userData,omitempty"`

	// VirtualMachineScaleSet: Specifies information about the virtual machine scale set that the virtual machine should be
	// assigned to. Virtual machines specified in the same virtual machine scale set are allocated to different nodes to
	// maximize availability. Currently, a VM can only be added to virtual machine scale set at creation time. An existing VM
	// cannot be added to a virtual machine scale set.
	// This property cannot exist along with a non-null properties.availabilitySet reference.
	// Minimum api‐version: 2019‐03‐01
	VirtualMachineScaleSet *SubResource_STATUS `json:"virtualMachineScaleSet,omitempty"`

	// VmId: Specifies the VM unique ID which is a 128-bits identifier that is encoded and stored in all Azure IaaS VMs SMBIOS
	// and can be read using platform BIOS commands.
	VmId *string `json:"vmId,omitempty"`

	// Zones: The virtual machine zones.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.ConvertibleStatus = &VirtualMachine_STATUS{}

// ConvertStatusFrom populates our VirtualMachine_STATUS from the provided source
func (machine *VirtualMachine_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.VirtualMachine_STATUS)
	if ok {
		// Populate our instance from source
		return machine.AssignProperties_From_VirtualMachine_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.VirtualMachine_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = machine.AssignProperties_From_VirtualMachine_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our VirtualMachine_STATUS
func (machine *VirtualMachine_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.VirtualMachine_STATUS)
	if ok {
		// Populate destination from our instance
		return machine.AssignProperties_To_VirtualMachine_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.VirtualMachine_STATUS{}
	err := machine.AssignProperties_To_VirtualMachine_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &VirtualMachine_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (machine *VirtualMachine_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachine_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (machine *VirtualMachine_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachine_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachine_STATUS, got %T", armInput)
	}

	// Set property "AdditionalCapabilities":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AdditionalCapabilities != nil {
			var additionalCapabilities1 AdditionalCapabilities_STATUS
			err := additionalCapabilities1.PopulateFromARM(owner, *typedInput.Properties.AdditionalCapabilities)
			if err != nil {
				return err
			}
			additionalCapabilities := additionalCapabilities1
			machine.AdditionalCapabilities = &additionalCapabilities
		}
	}

	// Set property "ApplicationProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ApplicationProfile != nil {
			var applicationProfile1 ApplicationProfile_STATUS
			err := applicationProfile1.PopulateFromARM(owner, *typedInput.Properties.ApplicationProfile)
			if err != nil {
				return err
			}
			applicationProfile := applicationProfile1
			machine.ApplicationProfile = &applicationProfile
		}
	}

	// Set property "AvailabilitySet":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AvailabilitySet != nil {
			var availabilitySet1 SubResource_STATUS
			err := availabilitySet1.PopulateFromARM(owner, *typedInput.Properties.AvailabilitySet)
			if err != nil {
				return err
			}
			availabilitySet := availabilitySet1
			machine.AvailabilitySet = &availabilitySet
		}
	}

	// Set property "BillingProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.BillingProfile != nil {
			var billingProfile1 BillingProfile_STATUS
			err := billingProfile1.PopulateFromARM(owner, *typedInput.Properties.BillingProfile)
			if err != nil {
				return err
			}
			billingProfile := billingProfile1
			machine.BillingProfile = &billingProfile
		}
	}

	// Set property "CapacityReservation":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CapacityReservation != nil {
			var capacityReservation1 CapacityReservationProfile_STATUS
			err := capacityReservation1.PopulateFromARM(owner, *typedInput.Properties.CapacityReservation)
			if err != nil {
				return err
			}
			capacityReservation := capacityReservation1
			machine.CapacityReservation = &capacityReservation
		}
	}

	// no assignment for property "Conditions"

	// Set property "DiagnosticsProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DiagnosticsProfile != nil {
			var diagnosticsProfile1 DiagnosticsProfile_STATUS
			err := diagnosticsProfile1.PopulateFromARM(owner, *typedInput.Properties.DiagnosticsProfile)
			if err != nil {
				return err
			}
			diagnosticsProfile := diagnosticsProfile1
			machine.DiagnosticsProfile = &diagnosticsProfile
		}
	}

	// Set property "EvictionPolicy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EvictionPolicy != nil {
			var temp string
			temp = string(*typedInput.Properties.EvictionPolicy)
			evictionPolicy := EvictionPolicy_STATUS(temp)
			machine.EvictionPolicy = &evictionPolicy
		}
	}

	// Set property "ExtendedLocation":
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_STATUS
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		machine.ExtendedLocation = &extendedLocation
	}

	// Set property "ExtensionsTimeBudget":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ExtensionsTimeBudget != nil {
			extensionsTimeBudget := *typedInput.Properties.ExtensionsTimeBudget
			machine.ExtensionsTimeBudget = &extensionsTimeBudget
		}
	}

	// Set property "HardwareProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HardwareProfile != nil {
			var hardwareProfile1 HardwareProfile_STATUS
			err := hardwareProfile1.PopulateFromARM(owner, *typedInput.Properties.HardwareProfile)
			if err != nil {
				return err
			}
			hardwareProfile := hardwareProfile1
			machine.HardwareProfile = &hardwareProfile
		}
	}

	// Set property "Host":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Host != nil {
			var host1 SubResource_STATUS
			err := host1.PopulateFromARM(owner, *typedInput.Properties.Host)
			if err != nil {
				return err
			}
			host := host1
			machine.Host = &host
		}
	}

	// Set property "HostGroup":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostGroup != nil {
			var hostGroup1 SubResource_STATUS
			err := hostGroup1.PopulateFromARM(owner, *typedInput.Properties.HostGroup)
			if err != nil {
				return err
			}
			hostGroup := hostGroup1
			machine.HostGroup = &hostGroup
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		machine.Id = &id
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 VirtualMachineIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		machine.Identity = &identity
	}

	// Set property "InstanceView":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.InstanceView != nil {
			var instanceView1 VirtualMachineInstanceView_STATUS
			err := instanceView1.PopulateFromARM(owner, *typedInput.Properties.InstanceView)
			if err != nil {
				return err
			}
			instanceView := instanceView1
			machine.InstanceView = &instanceView
		}
	}

	// Set property "LicenseType":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.LicenseType != nil {
			licenseType := *typedInput.Properties.LicenseType
			machine.LicenseType = &licenseType
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		machine.Location = &location
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		machine.Name = &name
	}

	// Set property "NetworkProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkProfile != nil {
			var networkProfile1 NetworkProfile_STATUS
			err := networkProfile1.PopulateFromARM(owner, *typedInput.Properties.NetworkProfile)
			if err != nil {
				return err
			}
			networkProfile := networkProfile1
			machine.NetworkProfile = &networkProfile
		}
	}

	// Set property "OsProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OsProfile != nil {
			var osProfile1 OSProfile_STATUS
			err := osProfile1.PopulateFromARM(owner, *typedInput.Properties.OsProfile)
			if err != nil {
				return err
			}
			osProfile := osProfile1
			machine.OsProfile = &osProfile
		}
	}

	// Set property "Plan":
	if typedInput.Plan != nil {
		var plan1 Plan_STATUS
		err := plan1.PopulateFromARM(owner, *typedInput.Plan)
		if err != nil {
			return err
		}
		plan := plan1
		machine.Plan = &plan
	}

	// Set property "PlatformFaultDomain":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PlatformFaultDomain != nil {
			platformFaultDomain := *typedInput.Properties.PlatformFaultDomain
			machine.PlatformFaultDomain = &platformFaultDomain
		}
	}

	// Set property "Priority":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Priority != nil {
			var temp string
			temp = string(*typedInput.Properties.Priority)
			priority := Priority_STATUS(temp)
			machine.Priority = &priority
		}
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			machine.ProvisioningState = &provisioningState
		}
	}

	// Set property "ProximityPlacementGroup":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProximityPlacementGroup != nil {
			var proximityPlacementGroup1 SubResource_STATUS
			err := proximityPlacementGroup1.PopulateFromARM(owner, *typedInput.Properties.ProximityPlacementGroup)
			if err != nil {
				return err
			}
			proximityPlacementGroup := proximityPlacementGroup1
			machine.ProximityPlacementGroup = &proximityPlacementGroup
		}
	}

	// Set property "Resources":
	for _, item := range typedInput.Resources {
		var item1 VirtualMachineExtension_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		machine.Resources = append(machine.Resources, item1)
	}

	// Set property "ScheduledEventsProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ScheduledEventsProfile != nil {
			var scheduledEventsProfile1 ScheduledEventsProfile_STATUS
			err := scheduledEventsProfile1.PopulateFromARM(owner, *typedInput.Properties.ScheduledEventsProfile)
			if err != nil {
				return err
			}
			scheduledEventsProfile := scheduledEventsProfile1
			machine.ScheduledEventsProfile = &scheduledEventsProfile
		}
	}

	// Set property "SecurityProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SecurityProfile != nil {
			var securityProfile1 SecurityProfile_STATUS
			err := securityProfile1.PopulateFromARM(owner, *typedInput.Properties.SecurityProfile)
			if err != nil {
				return err
			}
			securityProfile := securityProfile1
			machine.SecurityProfile = &securityProfile
		}
	}

	// Set property "StorageProfile":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.StorageProfile != nil {
			var storageProfile1 StorageProfile_STATUS
			err := storageProfile1.PopulateFromARM(owner, *typedInput.Properties.StorageProfile)
			if err != nil {
				return err
			}
			storageProfile := storageProfile1
			machine.StorageProfile = &storageProfile
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		machine.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			machine.Tags[key] = value
		}
	}

	// Set property "TimeCreated":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TimeCreated != nil {
			timeCreated := *typedInput.Properties.TimeCreated
			machine.TimeCreated = &timeCreated
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		machine.Type = &typeVar
	}

	// Set property "UserData":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.UserData != nil {
			userData := *typedInput.Properties.UserData
			machine.UserData = &userData
		}
	}

	// Set property "VirtualMachineScaleSet":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VirtualMachineScaleSet != nil {
			var virtualMachineScaleSet1 SubResource_STATUS
			err := virtualMachineScaleSet1.PopulateFromARM(owner, *typedInput.Properties.VirtualMachineScaleSet)
			if err != nil {
				return err
			}
			virtualMachineScaleSet := virtualMachineScaleSet1
			machine.VirtualMachineScaleSet = &virtualMachineScaleSet
		}
	}

	// Set property "VmId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VmId != nil {
			vmId := *typedInput.Properties.VmId
			machine.VmId = &vmId
		}
	}

	// Set property "Zones":
	for _, item := range typedInput.Zones {
		machine.Zones = append(machine.Zones, item)
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachine_STATUS populates our VirtualMachine_STATUS from the provided source VirtualMachine_STATUS
func (machine *VirtualMachine_STATUS) AssignProperties_From_VirtualMachine_STATUS(source *storage.VirtualMachine_STATUS) error {

	// AdditionalCapabilities
	if source.AdditionalCapabilities != nil {
		var additionalCapability AdditionalCapabilities_STATUS
		err := additionalCapability.AssignProperties_From_AdditionalCapabilities_STATUS(source.AdditionalCapabilities)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AdditionalCapabilities_STATUS() to populate field AdditionalCapabilities")
		}
		machine.AdditionalCapabilities = &additionalCapability
	} else {
		machine.AdditionalCapabilities = nil
	}

	// ApplicationProfile
	if source.ApplicationProfile != nil {
		var applicationProfile ApplicationProfile_STATUS
		err := applicationProfile.AssignProperties_From_ApplicationProfile_STATUS(source.ApplicationProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApplicationProfile_STATUS() to populate field ApplicationProfile")
		}
		machine.ApplicationProfile = &applicationProfile
	} else {
		machine.ApplicationProfile = nil
	}

	// AvailabilitySet
	if source.AvailabilitySet != nil {
		var availabilitySet SubResource_STATUS
		err := availabilitySet.AssignProperties_From_SubResource_STATUS(source.AvailabilitySet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field AvailabilitySet")
		}
		machine.AvailabilitySet = &availabilitySet
	} else {
		machine.AvailabilitySet = nil
	}

	// BillingProfile
	if source.BillingProfile != nil {
		var billingProfile BillingProfile_STATUS
		err := billingProfile.AssignProperties_From_BillingProfile_STATUS(source.BillingProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BillingProfile_STATUS() to populate field BillingProfile")
		}
		machine.BillingProfile = &billingProfile
	} else {
		machine.BillingProfile = nil
	}

	// CapacityReservation
	if source.CapacityReservation != nil {
		var capacityReservation CapacityReservationProfile_STATUS
		err := capacityReservation.AssignProperties_From_CapacityReservationProfile_STATUS(source.CapacityReservation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CapacityReservationProfile_STATUS() to populate field CapacityReservation")
		}
		machine.CapacityReservation = &capacityReservation
	} else {
		machine.CapacityReservation = nil
	}

	// Conditions
	machine.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// DiagnosticsProfile
	if source.DiagnosticsProfile != nil {
		var diagnosticsProfile DiagnosticsProfile_STATUS
		err := diagnosticsProfile.AssignProperties_From_DiagnosticsProfile_STATUS(source.DiagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DiagnosticsProfile_STATUS() to populate field DiagnosticsProfile")
		}
		machine.DiagnosticsProfile = &diagnosticsProfile
	} else {
		machine.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	if source.EvictionPolicy != nil {
		evictionPolicy := *source.EvictionPolicy
		evictionPolicyTemp := genruntime.ToEnum(evictionPolicy, evictionPolicy_STATUS_Values)
		machine.EvictionPolicy = &evictionPolicyTemp
	} else {
		machine.EvictionPolicy = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_STATUS
		err := extendedLocation.AssignProperties_From_ExtendedLocation_STATUS(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ExtendedLocation_STATUS() to populate field ExtendedLocation")
		}
		machine.ExtendedLocation = &extendedLocation
	} else {
		machine.ExtendedLocation = nil
	}

	// ExtensionsTimeBudget
	machine.ExtensionsTimeBudget = genruntime.ClonePointerToString(source.ExtensionsTimeBudget)

	// HardwareProfile
	if source.HardwareProfile != nil {
		var hardwareProfile HardwareProfile_STATUS
		err := hardwareProfile.AssignProperties_From_HardwareProfile_STATUS(source.HardwareProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HardwareProfile_STATUS() to populate field HardwareProfile")
		}
		machine.HardwareProfile = &hardwareProfile
	} else {
		machine.HardwareProfile = nil
	}

	// Host
	if source.Host != nil {
		var host SubResource_STATUS
		err := host.AssignProperties_From_SubResource_STATUS(source.Host)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field Host")
		}
		machine.Host = &host
	} else {
		machine.Host = nil
	}

	// HostGroup
	if source.HostGroup != nil {
		var hostGroup SubResource_STATUS
		err := hostGroup.AssignProperties_From_SubResource_STATUS(source.HostGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field HostGroup")
		}
		machine.HostGroup = &hostGroup
	} else {
		machine.HostGroup = nil
	}

	// Id
	machine.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity VirtualMachineIdentity_STATUS
		err := identity.AssignProperties_From_VirtualMachineIdentity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineIdentity_STATUS() to populate field Identity")
		}
		machine.Identity = &identity
	} else {
		machine.Identity = nil
	}

	// InstanceView
	if source.InstanceView != nil {
		var instanceView VirtualMachineInstanceView_STATUS
		err := instanceView.AssignProperties_From_VirtualMachineInstanceView_STATUS(source.InstanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineInstanceView_STATUS() to populate field InstanceView")
		}
		machine.InstanceView = &instanceView
	} else {
		machine.InstanceView = nil
	}

	// LicenseType
	machine.LicenseType = genruntime.ClonePointerToString(source.LicenseType)

	// Location
	machine.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	machine.Name = genruntime.ClonePointerToString(source.Name)

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile NetworkProfile_STATUS
		err := networkProfile.AssignProperties_From_NetworkProfile_STATUS(source.NetworkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_NetworkProfile_STATUS() to populate field NetworkProfile")
		}
		machine.NetworkProfile = &networkProfile
	} else {
		machine.NetworkProfile = nil
	}

	// OsProfile
	if source.OsProfile != nil {
		var osProfile OSProfile_STATUS
		err := osProfile.AssignProperties_From_OSProfile_STATUS(source.OsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OSProfile_STATUS() to populate field OsProfile")
		}
		machine.OsProfile = &osProfile
	} else {
		machine.OsProfile = nil
	}

	// Plan
	if source.Plan != nil {
		var plan Plan_STATUS
		err := plan.AssignProperties_From_Plan_STATUS(source.Plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Plan_STATUS() to populate field Plan")
		}
		machine.Plan = &plan
	} else {
		machine.Plan = nil
	}

	// PlatformFaultDomain
	machine.PlatformFaultDomain = genruntime.ClonePointerToInt(source.PlatformFaultDomain)

	// Priority
	if source.Priority != nil {
		priority := *source.Priority
		priorityTemp := genruntime.ToEnum(priority, priority_STATUS_Values)
		machine.Priority = &priorityTemp
	} else {
		machine.Priority = nil
	}

	// ProvisioningState
	machine.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// ProximityPlacementGroup
	if source.ProximityPlacementGroup != nil {
		var proximityPlacementGroup SubResource_STATUS
		err := proximityPlacementGroup.AssignProperties_From_SubResource_STATUS(source.ProximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field ProximityPlacementGroup")
		}
		machine.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		machine.ProximityPlacementGroup = nil
	}

	// Resources
	if source.Resources != nil {
		resourceList := make([]VirtualMachineExtension_STATUS, len(source.Resources))
		for resourceIndex, resourceItem := range source.Resources {
			// Shadow the loop variable to avoid aliasing
			resourceItem := resourceItem
			var resource VirtualMachineExtension_STATUS
			err := resource.AssignProperties_From_VirtualMachineExtension_STATUS(&resourceItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineExtension_STATUS() to populate field Resources")
			}
			resourceList[resourceIndex] = resource
		}
		machine.Resources = resourceList
	} else {
		machine.Resources = nil
	}

	// ScheduledEventsProfile
	if source.ScheduledEventsProfile != nil {
		var scheduledEventsProfile ScheduledEventsProfile_STATUS
		err := scheduledEventsProfile.AssignProperties_From_ScheduledEventsProfile_STATUS(source.ScheduledEventsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ScheduledEventsProfile_STATUS() to populate field ScheduledEventsProfile")
		}
		machine.ScheduledEventsProfile = &scheduledEventsProfile
	} else {
		machine.ScheduledEventsProfile = nil
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		var securityProfile SecurityProfile_STATUS
		err := securityProfile.AssignProperties_From_SecurityProfile_STATUS(source.SecurityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SecurityProfile_STATUS() to populate field SecurityProfile")
		}
		machine.SecurityProfile = &securityProfile
	} else {
		machine.SecurityProfile = nil
	}

	// StorageProfile
	if source.StorageProfile != nil {
		var storageProfile StorageProfile_STATUS
		err := storageProfile.AssignProperties_From_StorageProfile_STATUS(source.StorageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_StorageProfile_STATUS() to populate field StorageProfile")
		}
		machine.StorageProfile = &storageProfile
	} else {
		machine.StorageProfile = nil
	}

	// Tags
	machine.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TimeCreated
	machine.TimeCreated = genruntime.ClonePointerToString(source.TimeCreated)

	// Type
	machine.Type = genruntime.ClonePointerToString(source.Type)

	// UserData
	machine.UserData = genruntime.ClonePointerToString(source.UserData)

	// VirtualMachineScaleSet
	if source.VirtualMachineScaleSet != nil {
		var virtualMachineScaleSet SubResource_STATUS
		err := virtualMachineScaleSet.AssignProperties_From_SubResource_STATUS(source.VirtualMachineScaleSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field VirtualMachineScaleSet")
		}
		machine.VirtualMachineScaleSet = &virtualMachineScaleSet
	} else {
		machine.VirtualMachineScaleSet = nil
	}

	// VmId
	machine.VmId = genruntime.ClonePointerToString(source.VmId)

	// Zones
	machine.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachine_STATUS populates the provided destination VirtualMachine_STATUS from our VirtualMachine_STATUS
func (machine *VirtualMachine_STATUS) AssignProperties_To_VirtualMachine_STATUS(destination *storage.VirtualMachine_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalCapabilities
	if machine.AdditionalCapabilities != nil {
		var additionalCapability storage.AdditionalCapabilities_STATUS
		err := machine.AdditionalCapabilities.AssignProperties_To_AdditionalCapabilities_STATUS(&additionalCapability)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AdditionalCapabilities_STATUS() to populate field AdditionalCapabilities")
		}
		destination.AdditionalCapabilities = &additionalCapability
	} else {
		destination.AdditionalCapabilities = nil
	}

	// ApplicationProfile
	if machine.ApplicationProfile != nil {
		var applicationProfile storage.ApplicationProfile_STATUS
		err := machine.ApplicationProfile.AssignProperties_To_ApplicationProfile_STATUS(&applicationProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApplicationProfile_STATUS() to populate field ApplicationProfile")
		}
		destination.ApplicationProfile = &applicationProfile
	} else {
		destination.ApplicationProfile = nil
	}

	// AvailabilitySet
	if machine.AvailabilitySet != nil {
		var availabilitySet storage.SubResource_STATUS
		err := machine.AvailabilitySet.AssignProperties_To_SubResource_STATUS(&availabilitySet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field AvailabilitySet")
		}
		destination.AvailabilitySet = &availabilitySet
	} else {
		destination.AvailabilitySet = nil
	}

	// BillingProfile
	if machine.BillingProfile != nil {
		var billingProfile storage.BillingProfile_STATUS
		err := machine.BillingProfile.AssignProperties_To_BillingProfile_STATUS(&billingProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BillingProfile_STATUS() to populate field BillingProfile")
		}
		destination.BillingProfile = &billingProfile
	} else {
		destination.BillingProfile = nil
	}

	// CapacityReservation
	if machine.CapacityReservation != nil {
		var capacityReservation storage.CapacityReservationProfile_STATUS
		err := machine.CapacityReservation.AssignProperties_To_CapacityReservationProfile_STATUS(&capacityReservation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CapacityReservationProfile_STATUS() to populate field CapacityReservation")
		}
		destination.CapacityReservation = &capacityReservation
	} else {
		destination.CapacityReservation = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(machine.Conditions)

	// DiagnosticsProfile
	if machine.DiagnosticsProfile != nil {
		var diagnosticsProfile storage.DiagnosticsProfile_STATUS
		err := machine.DiagnosticsProfile.AssignProperties_To_DiagnosticsProfile_STATUS(&diagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DiagnosticsProfile_STATUS() to populate field DiagnosticsProfile")
		}
		destination.DiagnosticsProfile = &diagnosticsProfile
	} else {
		destination.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	if machine.EvictionPolicy != nil {
		evictionPolicy := string(*machine.EvictionPolicy)
		destination.EvictionPolicy = &evictionPolicy
	} else {
		destination.EvictionPolicy = nil
	}

	// ExtendedLocation
	if machine.ExtendedLocation != nil {
		var extendedLocation storage.ExtendedLocation_STATUS
		err := machine.ExtendedLocation.AssignProperties_To_ExtendedLocation_STATUS(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ExtendedLocation_STATUS() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// ExtensionsTimeBudget
	destination.ExtensionsTimeBudget = genruntime.ClonePointerToString(machine.ExtensionsTimeBudget)

	// HardwareProfile
	if machine.HardwareProfile != nil {
		var hardwareProfile storage.HardwareProfile_STATUS
		err := machine.HardwareProfile.AssignProperties_To_HardwareProfile_STATUS(&hardwareProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HardwareProfile_STATUS() to populate field HardwareProfile")
		}
		destination.HardwareProfile = &hardwareProfile
	} else {
		destination.HardwareProfile = nil
	}

	// Host
	if machine.Host != nil {
		var host storage.SubResource_STATUS
		err := machine.Host.AssignProperties_To_SubResource_STATUS(&host)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field Host")
		}
		destination.Host = &host
	} else {
		destination.Host = nil
	}

	// HostGroup
	if machine.HostGroup != nil {
		var hostGroup storage.SubResource_STATUS
		err := machine.HostGroup.AssignProperties_To_SubResource_STATUS(&hostGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field HostGroup")
		}
		destination.HostGroup = &hostGroup
	} else {
		destination.HostGroup = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(machine.Id)

	// Identity
	if machine.Identity != nil {
		var identity storage.VirtualMachineIdentity_STATUS
		err := machine.Identity.AssignProperties_To_VirtualMachineIdentity_STATUS(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// InstanceView
	if machine.InstanceView != nil {
		var instanceView storage.VirtualMachineInstanceView_STATUS
		err := machine.InstanceView.AssignProperties_To_VirtualMachineInstanceView_STATUS(&instanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineInstanceView_STATUS() to populate field InstanceView")
		}
		destination.InstanceView = &instanceView
	} else {
		destination.InstanceView = nil
	}

	// LicenseType
	destination.LicenseType = genruntime.ClonePointerToString(machine.LicenseType)

	// Location
	destination.Location = genruntime.ClonePointerToString(machine.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(machine.Name)

	// NetworkProfile
	if machine.NetworkProfile != nil {
		var networkProfile storage.NetworkProfile_STATUS
		err := machine.NetworkProfile.AssignProperties_To_NetworkProfile_STATUS(&networkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_NetworkProfile_STATUS() to populate field NetworkProfile")
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// OsProfile
	if machine.OsProfile != nil {
		var osProfile storage.OSProfile_STATUS
		err := machine.OsProfile.AssignProperties_To_OSProfile_STATUS(&osProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OSProfile_STATUS() to populate field OsProfile")
		}
		destination.OsProfile = &osProfile
	} else {
		destination.OsProfile = nil
	}

	// Plan
	if machine.Plan != nil {
		var plan storage.Plan_STATUS
		err := machine.Plan.AssignProperties_To_Plan_STATUS(&plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Plan_STATUS() to populate field Plan")
		}
		destination.Plan = &plan
	} else {
		destination.Plan = nil
	}

	// PlatformFaultDomain
	destination.PlatformFaultDomain = genruntime.ClonePointerToInt(machine.PlatformFaultDomain)

	// Priority
	if machine.Priority != nil {
		priority := string(*machine.Priority)
		destination.Priority = &priority
	} else {
		destination.Priority = nil
	}

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(machine.ProvisioningState)

	// ProximityPlacementGroup
	if machine.ProximityPlacementGroup != nil {
		var proximityPlacementGroup storage.SubResource_STATUS
		err := machine.ProximityPlacementGroup.AssignProperties_To_SubResource_STATUS(&proximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field ProximityPlacementGroup")
		}
		destination.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		destination.ProximityPlacementGroup = nil
	}

	// Resources
	if machine.Resources != nil {
		resourceList := make([]storage.VirtualMachineExtension_STATUS, len(machine.Resources))
		for resourceIndex, resourceItem := range machine.Resources {
			// Shadow the loop variable to avoid aliasing
			resourceItem := resourceItem
			var resource storage.VirtualMachineExtension_STATUS
			err := resourceItem.AssignProperties_To_VirtualMachineExtension_STATUS(&resource)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineExtension_STATUS() to populate field Resources")
			}
			resourceList[resourceIndex] = resource
		}
		destination.Resources = resourceList
	} else {
		destination.Resources = nil
	}

	// ScheduledEventsProfile
	if machine.ScheduledEventsProfile != nil {
		var scheduledEventsProfile storage.ScheduledEventsProfile_STATUS
		err := machine.ScheduledEventsProfile.AssignProperties_To_ScheduledEventsProfile_STATUS(&scheduledEventsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ScheduledEventsProfile_STATUS() to populate field ScheduledEventsProfile")
		}
		destination.ScheduledEventsProfile = &scheduledEventsProfile
	} else {
		destination.ScheduledEventsProfile = nil
	}

	// SecurityProfile
	if machine.SecurityProfile != nil {
		var securityProfile storage.SecurityProfile_STATUS
		err := machine.SecurityProfile.AssignProperties_To_SecurityProfile_STATUS(&securityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SecurityProfile_STATUS() to populate field SecurityProfile")
		}
		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// StorageProfile
	if machine.StorageProfile != nil {
		var storageProfile storage.StorageProfile_STATUS
		err := machine.StorageProfile.AssignProperties_To_StorageProfile_STATUS(&storageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_StorageProfile_STATUS() to populate field StorageProfile")
		}
		destination.StorageProfile = &storageProfile
	} else {
		destination.StorageProfile = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(machine.Tags)

	// TimeCreated
	destination.TimeCreated = genruntime.ClonePointerToString(machine.TimeCreated)

	// Type
	destination.Type = genruntime.ClonePointerToString(machine.Type)

	// UserData
	destination.UserData = genruntime.ClonePointerToString(machine.UserData)

	// VirtualMachineScaleSet
	if machine.VirtualMachineScaleSet != nil {
		var virtualMachineScaleSet storage.SubResource_STATUS
		err := machine.VirtualMachineScaleSet.AssignProperties_To_SubResource_STATUS(&virtualMachineScaleSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field VirtualMachineScaleSet")
		}
		destination.VirtualMachineScaleSet = &virtualMachineScaleSet
	} else {
		destination.VirtualMachineScaleSet = nil
	}

	// VmId
	destination.VmId = genruntime.ClonePointerToString(machine.VmId)

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(machine.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Enables or disables a capability on the virtual machine or virtual machine scale set.
type AdditionalCapabilities struct {
	// HibernationEnabled: The flag that enables or disables hibernation capability on the VM.
	HibernationEnabled *bool `json:"hibernationEnabled,omitempty"`

	// UltraSSDEnabled: The flag that enables or disables a capability to have one or more managed data disks with UltraSSD_LRS
	// storage account type on the VM or VMSS. Managed disks with storage account type UltraSSD_LRS can be added to a virtual
	// machine or virtual machine scale set only if this property is enabled.
	UltraSSDEnabled *bool `json:"ultraSSDEnabled,omitempty"`
}

var _ genruntime.ARMTransformer = &AdditionalCapabilities{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (capabilities *AdditionalCapabilities) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if capabilities == nil {
		return nil, nil
	}
	result := &arm.AdditionalCapabilities{}

	// Set property "HibernationEnabled":
	if capabilities.HibernationEnabled != nil {
		hibernationEnabled := *capabilities.HibernationEnabled
		result.HibernationEnabled = &hibernationEnabled
	}

	// Set property "UltraSSDEnabled":
	if capabilities.UltraSSDEnabled != nil {
		ultraSSDEnabled := *capabilities.UltraSSDEnabled
		result.UltraSSDEnabled = &ultraSSDEnabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (capabilities *AdditionalCapabilities) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AdditionalCapabilities{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (capabilities *AdditionalCapabilities) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AdditionalCapabilities)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AdditionalCapabilities, got %T", armInput)
	}

	// Set property "HibernationEnabled":
	if typedInput.HibernationEnabled != nil {
		hibernationEnabled := *typedInput.HibernationEnabled
		capabilities.HibernationEnabled = &hibernationEnabled
	}

	// Set property "UltraSSDEnabled":
	if typedInput.UltraSSDEnabled != nil {
		ultraSSDEnabled := *typedInput.UltraSSDEnabled
		capabilities.UltraSSDEnabled = &ultraSSDEnabled
	}

	// No error
	return nil
}

// AssignProperties_From_AdditionalCapabilities populates our AdditionalCapabilities from the provided source AdditionalCapabilities
func (capabilities *AdditionalCapabilities) AssignProperties_From_AdditionalCapabilities(source *storage.AdditionalCapabilities) error {

	// HibernationEnabled
	if source.HibernationEnabled != nil {
		hibernationEnabled := *source.HibernationEnabled
		capabilities.HibernationEnabled = &hibernationEnabled
	} else {
		capabilities.HibernationEnabled = nil
	}

	// UltraSSDEnabled
	if source.UltraSSDEnabled != nil {
		ultraSSDEnabled := *source.UltraSSDEnabled
		capabilities.UltraSSDEnabled = &ultraSSDEnabled
	} else {
		capabilities.UltraSSDEnabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AdditionalCapabilities populates the provided destination AdditionalCapabilities from our AdditionalCapabilities
func (capabilities *AdditionalCapabilities) AssignProperties_To_AdditionalCapabilities(destination *storage.AdditionalCapabilities) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HibernationEnabled
	if capabilities.HibernationEnabled != nil {
		hibernationEnabled := *capabilities.HibernationEnabled
		destination.HibernationEnabled = &hibernationEnabled
	} else {
		destination.HibernationEnabled = nil
	}

	// UltraSSDEnabled
	if capabilities.UltraSSDEnabled != nil {
		ultraSSDEnabled := *capabilities.UltraSSDEnabled
		destination.UltraSSDEnabled = &ultraSSDEnabled
	} else {
		destination.UltraSSDEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AdditionalCapabilities_STATUS populates our AdditionalCapabilities from the provided source AdditionalCapabilities_STATUS
func (capabilities *AdditionalCapabilities) Initialize_From_AdditionalCapabilities_STATUS(source *AdditionalCapabilities_STATUS) error {

	// HibernationEnabled
	if source.HibernationEnabled != nil {
		hibernationEnabled := *source.HibernationEnabled
		capabilities.HibernationEnabled = &hibernationEnabled
	} else {
		capabilities.HibernationEnabled = nil
	}

	// UltraSSDEnabled
	if source.UltraSSDEnabled != nil {
		ultraSSDEnabled := *source.UltraSSDEnabled
		capabilities.UltraSSDEnabled = &ultraSSDEnabled
	} else {
		capabilities.UltraSSDEnabled = nil
	}

	// No error
	return nil
}

// Enables or disables a capability on the virtual machine or virtual machine scale set.
type AdditionalCapabilities_STATUS struct {
	// HibernationEnabled: The flag that enables or disables hibernation capability on the VM.
	HibernationEnabled *bool `json:"hibernationEnabled,omitempty"`

	// UltraSSDEnabled: The flag that enables or disables a capability to have one or more managed data disks with UltraSSD_LRS
	// storage account type on the VM or VMSS. Managed disks with storage account type UltraSSD_LRS can be added to a virtual
	// machine or virtual machine scale set only if this property is enabled.
	UltraSSDEnabled *bool `json:"ultraSSDEnabled,omitempty"`
}

var _ genruntime.FromARMConverter = &AdditionalCapabilities_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (capabilities *AdditionalCapabilities_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AdditionalCapabilities_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (capabilities *AdditionalCapabilities_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AdditionalCapabilities_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AdditionalCapabilities_STATUS, got %T", armInput)
	}

	// Set property "HibernationEnabled":
	if typedInput.HibernationEnabled != nil {
		hibernationEnabled := *typedInput.HibernationEnabled
		capabilities.HibernationEnabled = &hibernationEnabled
	}

	// Set property "UltraSSDEnabled":
	if typedInput.UltraSSDEnabled != nil {
		ultraSSDEnabled := *typedInput.UltraSSDEnabled
		capabilities.UltraSSDEnabled = &ultraSSDEnabled
	}

	// No error
	return nil
}

// AssignProperties_From_AdditionalCapabilities_STATUS populates our AdditionalCapabilities_STATUS from the provided source AdditionalCapabilities_STATUS
func (capabilities *AdditionalCapabilities_STATUS) AssignProperties_From_AdditionalCapabilities_STATUS(source *storage.AdditionalCapabilities_STATUS) error {

	// HibernationEnabled
	if source.HibernationEnabled != nil {
		hibernationEnabled := *source.HibernationEnabled
		capabilities.HibernationEnabled = &hibernationEnabled
	} else {
		capabilities.HibernationEnabled = nil
	}

	// UltraSSDEnabled
	if source.UltraSSDEnabled != nil {
		ultraSSDEnabled := *source.UltraSSDEnabled
		capabilities.UltraSSDEnabled = &ultraSSDEnabled
	} else {
		capabilities.UltraSSDEnabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AdditionalCapabilities_STATUS populates the provided destination AdditionalCapabilities_STATUS from our AdditionalCapabilities_STATUS
func (capabilities *AdditionalCapabilities_STATUS) AssignProperties_To_AdditionalCapabilities_STATUS(destination *storage.AdditionalCapabilities_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HibernationEnabled
	if capabilities.HibernationEnabled != nil {
		hibernationEnabled := *capabilities.HibernationEnabled
		destination.HibernationEnabled = &hibernationEnabled
	} else {
		destination.HibernationEnabled = nil
	}

	// UltraSSDEnabled
	if capabilities.UltraSSDEnabled != nil {
		ultraSSDEnabled := *capabilities.UltraSSDEnabled
		destination.UltraSSDEnabled = &ultraSSDEnabled
	} else {
		destination.UltraSSDEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Contains the list of gallery applications that should be made available to the VM/VMSS
type ApplicationProfile struct {
	// GalleryApplications: Specifies the gallery applications that should be made available to the VM/VMSS
	GalleryApplications []VMGalleryApplication `json:"galleryApplications,omitempty"`
}

var _ genruntime.ARMTransformer = &ApplicationProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ApplicationProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ApplicationProfile{}

	// Set property "GalleryApplications":
	for _, item := range profile.GalleryApplications {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.GalleryApplications = append(result.GalleryApplications, *item_ARM.(*arm.VMGalleryApplication))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ApplicationProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ApplicationProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationProfile, got %T", armInput)
	}

	// Set property "GalleryApplications":
	for _, item := range typedInput.GalleryApplications {
		var item1 VMGalleryApplication
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.GalleryApplications = append(profile.GalleryApplications, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationProfile populates our ApplicationProfile from the provided source ApplicationProfile
func (profile *ApplicationProfile) AssignProperties_From_ApplicationProfile(source *storage.ApplicationProfile) error {

	// GalleryApplications
	if source.GalleryApplications != nil {
		galleryApplicationList := make([]VMGalleryApplication, len(source.GalleryApplications))
		for galleryApplicationIndex, galleryApplicationItem := range source.GalleryApplications {
			// Shadow the loop variable to avoid aliasing
			galleryApplicationItem := galleryApplicationItem
			var galleryApplication VMGalleryApplication
			err := galleryApplication.AssignProperties_From_VMGalleryApplication(&galleryApplicationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VMGalleryApplication() to populate field GalleryApplications")
			}
			galleryApplicationList[galleryApplicationIndex] = galleryApplication
		}
		profile.GalleryApplications = galleryApplicationList
	} else {
		profile.GalleryApplications = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationProfile populates the provided destination ApplicationProfile from our ApplicationProfile
func (profile *ApplicationProfile) AssignProperties_To_ApplicationProfile(destination *storage.ApplicationProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// GalleryApplications
	if profile.GalleryApplications != nil {
		galleryApplicationList := make([]storage.VMGalleryApplication, len(profile.GalleryApplications))
		for galleryApplicationIndex, galleryApplicationItem := range profile.GalleryApplications {
			// Shadow the loop variable to avoid aliasing
			galleryApplicationItem := galleryApplicationItem
			var galleryApplication storage.VMGalleryApplication
			err := galleryApplicationItem.AssignProperties_To_VMGalleryApplication(&galleryApplication)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VMGalleryApplication() to populate field GalleryApplications")
			}
			galleryApplicationList[galleryApplicationIndex] = galleryApplication
		}
		destination.GalleryApplications = galleryApplicationList
	} else {
		destination.GalleryApplications = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApplicationProfile_STATUS populates our ApplicationProfile from the provided source ApplicationProfile_STATUS
func (profile *ApplicationProfile) Initialize_From_ApplicationProfile_STATUS(source *ApplicationProfile_STATUS) error {

	// GalleryApplications
	if source.GalleryApplications != nil {
		galleryApplicationList := make([]VMGalleryApplication, len(source.GalleryApplications))
		for galleryApplicationIndex, galleryApplicationItem := range source.GalleryApplications {
			// Shadow the loop variable to avoid aliasing
			galleryApplicationItem := galleryApplicationItem
			var galleryApplication VMGalleryApplication
			err := galleryApplication.Initialize_From_VMGalleryApplication_STATUS(&galleryApplicationItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_VMGalleryApplication_STATUS() to populate field GalleryApplications")
			}
			galleryApplicationList[galleryApplicationIndex] = galleryApplication
		}
		profile.GalleryApplications = galleryApplicationList
	} else {
		profile.GalleryApplications = nil
	}

	// No error
	return nil
}

// Contains the list of gallery applications that should be made available to the VM/VMSS
type ApplicationProfile_STATUS struct {
	// GalleryApplications: Specifies the gallery applications that should be made available to the VM/VMSS
	GalleryApplications []VMGalleryApplication_STATUS `json:"galleryApplications,omitempty"`
}

var _ genruntime.FromARMConverter = &ApplicationProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ApplicationProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApplicationProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ApplicationProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApplicationProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApplicationProfile_STATUS, got %T", armInput)
	}

	// Set property "GalleryApplications":
	for _, item := range typedInput.GalleryApplications {
		var item1 VMGalleryApplication_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.GalleryApplications = append(profile.GalleryApplications, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ApplicationProfile_STATUS populates our ApplicationProfile_STATUS from the provided source ApplicationProfile_STATUS
func (profile *ApplicationProfile_STATUS) AssignProperties_From_ApplicationProfile_STATUS(source *storage.ApplicationProfile_STATUS) error {

	// GalleryApplications
	if source.GalleryApplications != nil {
		galleryApplicationList := make([]VMGalleryApplication_STATUS, len(source.GalleryApplications))
		for galleryApplicationIndex, galleryApplicationItem := range source.GalleryApplications {
			// Shadow the loop variable to avoid aliasing
			galleryApplicationItem := galleryApplicationItem
			var galleryApplication VMGalleryApplication_STATUS
			err := galleryApplication.AssignProperties_From_VMGalleryApplication_STATUS(&galleryApplicationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VMGalleryApplication_STATUS() to populate field GalleryApplications")
			}
			galleryApplicationList[galleryApplicationIndex] = galleryApplication
		}
		profile.GalleryApplications = galleryApplicationList
	} else {
		profile.GalleryApplications = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApplicationProfile_STATUS populates the provided destination ApplicationProfile_STATUS from our ApplicationProfile_STATUS
func (profile *ApplicationProfile_STATUS) AssignProperties_To_ApplicationProfile_STATUS(destination *storage.ApplicationProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// GalleryApplications
	if profile.GalleryApplications != nil {
		galleryApplicationList := make([]storage.VMGalleryApplication_STATUS, len(profile.GalleryApplications))
		for galleryApplicationIndex, galleryApplicationItem := range profile.GalleryApplications {
			// Shadow the loop variable to avoid aliasing
			galleryApplicationItem := galleryApplicationItem
			var galleryApplication storage.VMGalleryApplication_STATUS
			err := galleryApplicationItem.AssignProperties_To_VMGalleryApplication_STATUS(&galleryApplication)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VMGalleryApplication_STATUS() to populate field GalleryApplications")
			}
			galleryApplicationList[galleryApplicationIndex] = galleryApplication
		}
		destination.GalleryApplications = galleryApplicationList
	} else {
		destination.GalleryApplications = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Specifies the billing related details of a Azure Spot VM or VMSS.
// Minimum api-version: 2019-03-01.
type BillingProfile struct {
	// MaxPrice: Specifies the maximum price you are willing to pay for a Azure Spot VM/VMSS. This price is in US Dollars.
	// This price will be compared with the current Azure Spot price for the VM size. Also, the prices are compared at the time
	// of create/update of Azure Spot VM/VMSS and the operation will only succeed if  the maxPrice is greater than the current
	// Azure Spot price.
	// The maxPrice will also be used for evicting a Azure Spot VM/VMSS if the current Azure Spot price goes beyond the
	// maxPrice after creation of VM/VMSS.
	// Possible values are:
	// - Any decimal value greater than zero. Example: 0.01538
	// -1 – indicates default price to be up-to on-demand.
	// You can set the maxPrice to -1 to indicate that the Azure Spot VM/VMSS should not be evicted for price reasons. Also,
	// the default max price is -1 if it is not provided by you.
	// Minimum api-version: 2019-03-01.
	MaxPrice *float64 `json:"maxPrice,omitempty"`
}

var _ genruntime.ARMTransformer = &BillingProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *BillingProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.BillingProfile{}

	// Set property "MaxPrice":
	if profile.MaxPrice != nil {
		maxPrice := *profile.MaxPrice
		result.MaxPrice = &maxPrice
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *BillingProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BillingProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *BillingProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BillingProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BillingProfile, got %T", armInput)
	}

	// Set property "MaxPrice":
	if typedInput.MaxPrice != nil {
		maxPrice := *typedInput.MaxPrice
		profile.MaxPrice = &maxPrice
	}

	// No error
	return nil
}

// AssignProperties_From_BillingProfile populates our BillingProfile from the provided source BillingProfile
func (profile *BillingProfile) AssignProperties_From_BillingProfile(source *storage.BillingProfile) error {

	// MaxPrice
	if source.MaxPrice != nil {
		maxPrice := *source.MaxPrice
		profile.MaxPrice = &maxPrice
	} else {
		profile.MaxPrice = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BillingProfile populates the provided destination BillingProfile from our BillingProfile
func (profile *BillingProfile) AssignProperties_To_BillingProfile(destination *storage.BillingProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MaxPrice
	if profile.MaxPrice != nil {
		maxPrice := *profile.MaxPrice
		destination.MaxPrice = &maxPrice
	} else {
		destination.MaxPrice = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_BillingProfile_STATUS populates our BillingProfile from the provided source BillingProfile_STATUS
func (profile *BillingProfile) Initialize_From_BillingProfile_STATUS(source *BillingProfile_STATUS) error {

	// MaxPrice
	if source.MaxPrice != nil {
		maxPrice := *source.MaxPrice
		profile.MaxPrice = &maxPrice
	} else {
		profile.MaxPrice = nil
	}

	// No error
	return nil
}

// Specifies the billing related details of a Azure Spot VM or VMSS.
// Minimum api-version: 2019-03-01.
type BillingProfile_STATUS struct {
	// MaxPrice: Specifies the maximum price you are willing to pay for a Azure Spot VM/VMSS. This price is in US Dollars.
	// This price will be compared with the current Azure Spot price for the VM size. Also, the prices are compared at the time
	// of create/update of Azure Spot VM/VMSS and the operation will only succeed if  the maxPrice is greater than the current
	// Azure Spot price.
	// The maxPrice will also be used for evicting a Azure Spot VM/VMSS if the current Azure Spot price goes beyond the
	// maxPrice after creation of VM/VMSS.
	// Possible values are:
	// - Any decimal value greater than zero. Example: 0.01538
	// -1 – indicates default price to be up-to on-demand.
	// You can set the maxPrice to -1 to indicate that the Azure Spot VM/VMSS should not be evicted for price reasons. Also,
	// the default max price is -1 if it is not provided by you.
	// Minimum api-version: 2019-03-01.
	MaxPrice *float64 `json:"maxPrice,omitempty"`
}

var _ genruntime.FromARMConverter = &BillingProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *BillingProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BillingProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *BillingProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BillingProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BillingProfile_STATUS, got %T", armInput)
	}

	// Set property "MaxPrice":
	if typedInput.MaxPrice != nil {
		maxPrice := *typedInput.MaxPrice
		profile.MaxPrice = &maxPrice
	}

	// No error
	return nil
}

// AssignProperties_From_BillingProfile_STATUS populates our BillingProfile_STATUS from the provided source BillingProfile_STATUS
func (profile *BillingProfile_STATUS) AssignProperties_From_BillingProfile_STATUS(source *storage.BillingProfile_STATUS) error {

	// MaxPrice
	if source.MaxPrice != nil {
		maxPrice := *source.MaxPrice
		profile.MaxPrice = &maxPrice
	} else {
		profile.MaxPrice = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BillingProfile_STATUS populates the provided destination BillingProfile_STATUS from our BillingProfile_STATUS
func (profile *BillingProfile_STATUS) AssignProperties_To_BillingProfile_STATUS(destination *storage.BillingProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MaxPrice
	if profile.MaxPrice != nil {
		maxPrice := *profile.MaxPrice
		destination.MaxPrice = &maxPrice
	} else {
		destination.MaxPrice = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The parameters of a capacity reservation Profile.
type CapacityReservationProfile struct {
	// CapacityReservationGroup: Specifies the capacity reservation group resource id that should be used for allocating the
	// virtual machine or scaleset vm instances provided enough capacity has been reserved. Please refer to
	// https://aka.ms/CapacityReservation for more details.
	CapacityReservationGroup *SubResource `json:"capacityReservationGroup,omitempty"`
}

var _ genruntime.ARMTransformer = &CapacityReservationProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *CapacityReservationProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.CapacityReservationProfile{}

	// Set property "CapacityReservationGroup":
	if profile.CapacityReservationGroup != nil {
		capacityReservationGroup_ARM, err := (*profile.CapacityReservationGroup).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		capacityReservationGroup := *capacityReservationGroup_ARM.(*arm.SubResource)
		result.CapacityReservationGroup = &capacityReservationGroup
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *CapacityReservationProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CapacityReservationProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *CapacityReservationProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CapacityReservationProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CapacityReservationProfile, got %T", armInput)
	}

	// Set property "CapacityReservationGroup":
	if typedInput.CapacityReservationGroup != nil {
		var capacityReservationGroup1 SubResource
		err := capacityReservationGroup1.PopulateFromARM(owner, *typedInput.CapacityReservationGroup)
		if err != nil {
			return err
		}
		capacityReservationGroup := capacityReservationGroup1
		profile.CapacityReservationGroup = &capacityReservationGroup
	}

	// No error
	return nil
}

// AssignProperties_From_CapacityReservationProfile populates our CapacityReservationProfile from the provided source CapacityReservationProfile
func (profile *CapacityReservationProfile) AssignProperties_From_CapacityReservationProfile(source *storage.CapacityReservationProfile) error {

	// CapacityReservationGroup
	if source.CapacityReservationGroup != nil {
		var capacityReservationGroup SubResource
		err := capacityReservationGroup.AssignProperties_From_SubResource(source.CapacityReservationGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field CapacityReservationGroup")
		}
		profile.CapacityReservationGroup = &capacityReservationGroup
	} else {
		profile.CapacityReservationGroup = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CapacityReservationProfile populates the provided destination CapacityReservationProfile from our CapacityReservationProfile
func (profile *CapacityReservationProfile) AssignProperties_To_CapacityReservationProfile(destination *storage.CapacityReservationProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CapacityReservationGroup
	if profile.CapacityReservationGroup != nil {
		var capacityReservationGroup storage.SubResource
		err := profile.CapacityReservationGroup.AssignProperties_To_SubResource(&capacityReservationGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field CapacityReservationGroup")
		}
		destination.CapacityReservationGroup = &capacityReservationGroup
	} else {
		destination.CapacityReservationGroup = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_CapacityReservationProfile_STATUS populates our CapacityReservationProfile from the provided source CapacityReservationProfile_STATUS
func (profile *CapacityReservationProfile) Initialize_From_CapacityReservationProfile_STATUS(source *CapacityReservationProfile_STATUS) error {

	// CapacityReservationGroup
	if source.CapacityReservationGroup != nil {
		var capacityReservationGroup SubResource
		err := capacityReservationGroup.Initialize_From_SubResource_STATUS(source.CapacityReservationGroup)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SubResource_STATUS() to populate field CapacityReservationGroup")
		}
		profile.CapacityReservationGroup = &capacityReservationGroup
	} else {
		profile.CapacityReservationGroup = nil
	}

	// No error
	return nil
}

// The parameters of a capacity reservation Profile.
type CapacityReservationProfile_STATUS struct {
	// CapacityReservationGroup: Specifies the capacity reservation group resource id that should be used for allocating the
	// virtual machine or scaleset vm instances provided enough capacity has been reserved. Please refer to
	// https://aka.ms/CapacityReservation for more details.
	CapacityReservationGroup *SubResource_STATUS `json:"capacityReservationGroup,omitempty"`
}

var _ genruntime.FromARMConverter = &CapacityReservationProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *CapacityReservationProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CapacityReservationProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *CapacityReservationProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CapacityReservationProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CapacityReservationProfile_STATUS, got %T", armInput)
	}

	// Set property "CapacityReservationGroup":
	if typedInput.CapacityReservationGroup != nil {
		var capacityReservationGroup1 SubResource_STATUS
		err := capacityReservationGroup1.PopulateFromARM(owner, *typedInput.CapacityReservationGroup)
		if err != nil {
			return err
		}
		capacityReservationGroup := capacityReservationGroup1
		profile.CapacityReservationGroup = &capacityReservationGroup
	}

	// No error
	return nil
}

// AssignProperties_From_CapacityReservationProfile_STATUS populates our CapacityReservationProfile_STATUS from the provided source CapacityReservationProfile_STATUS
func (profile *CapacityReservationProfile_STATUS) AssignProperties_From_CapacityReservationProfile_STATUS(source *storage.CapacityReservationProfile_STATUS) error {

	// CapacityReservationGroup
	if source.CapacityReservationGroup != nil {
		var capacityReservationGroup SubResource_STATUS
		err := capacityReservationGroup.AssignProperties_From_SubResource_STATUS(source.CapacityReservationGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field CapacityReservationGroup")
		}
		profile.CapacityReservationGroup = &capacityReservationGroup
	} else {
		profile.CapacityReservationGroup = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CapacityReservationProfile_STATUS populates the provided destination CapacityReservationProfile_STATUS from our CapacityReservationProfile_STATUS
func (profile *CapacityReservationProfile_STATUS) AssignProperties_To_CapacityReservationProfile_STATUS(destination *storage.CapacityReservationProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CapacityReservationGroup
	if profile.CapacityReservationGroup != nil {
		var capacityReservationGroup storage.SubResource_STATUS
		err := profile.CapacityReservationGroup.AssignProperties_To_SubResource_STATUS(&capacityReservationGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field CapacityReservationGroup")
		}
		destination.CapacityReservationGroup = &capacityReservationGroup
	} else {
		destination.CapacityReservationGroup = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Specifies the boot diagnostic settings state.
// Minimum api-version: 2015-06-15.
type DiagnosticsProfile struct {
	// BootDiagnostics: Boot Diagnostics is a debugging feature which allows you to view Console Output and Screenshot to
	// diagnose VM status.
	// NOTE: If storageUri is being specified then ensure that the storage account is in the same region and subscription as
	// the VM.
	// You can easily view the output of your console log.
	// Azure also enables you to see a screenshot of the VM from the hypervisor.
	BootDiagnostics *BootDiagnostics `json:"bootDiagnostics,omitempty"`
}

var _ genruntime.ARMTransformer = &DiagnosticsProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *DiagnosticsProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.DiagnosticsProfile{}

	// Set property "BootDiagnostics":
	if profile.BootDiagnostics != nil {
		bootDiagnostics_ARM, err := (*profile.BootDiagnostics).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		bootDiagnostics := *bootDiagnostics_ARM.(*arm.BootDiagnostics)
		result.BootDiagnostics = &bootDiagnostics
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *DiagnosticsProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DiagnosticsProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *DiagnosticsProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DiagnosticsProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DiagnosticsProfile, got %T", armInput)
	}

	// Set property "BootDiagnostics":
	if typedInput.BootDiagnostics != nil {
		var bootDiagnostics1 BootDiagnostics
		err := bootDiagnostics1.PopulateFromARM(owner, *typedInput.BootDiagnostics)
		if err != nil {
			return err
		}
		bootDiagnostics := bootDiagnostics1
		profile.BootDiagnostics = &bootDiagnostics
	}

	// No error
	return nil
}

// AssignProperties_From_DiagnosticsProfile populates our DiagnosticsProfile from the provided source DiagnosticsProfile
func (profile *DiagnosticsProfile) AssignProperties_From_DiagnosticsProfile(source *storage.DiagnosticsProfile) error {

	// BootDiagnostics
	if source.BootDiagnostics != nil {
		var bootDiagnostic BootDiagnostics
		err := bootDiagnostic.AssignProperties_From_BootDiagnostics(source.BootDiagnostics)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BootDiagnostics() to populate field BootDiagnostics")
		}
		profile.BootDiagnostics = &bootDiagnostic
	} else {
		profile.BootDiagnostics = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DiagnosticsProfile populates the provided destination DiagnosticsProfile from our DiagnosticsProfile
func (profile *DiagnosticsProfile) AssignProperties_To_DiagnosticsProfile(destination *storage.DiagnosticsProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BootDiagnostics
	if profile.BootDiagnostics != nil {
		var bootDiagnostic storage.BootDiagnostics
		err := profile.BootDiagnostics.AssignProperties_To_BootDiagnostics(&bootDiagnostic)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BootDiagnostics() to populate field BootDiagnostics")
		}
		destination.BootDiagnostics = &bootDiagnostic
	} else {
		destination.BootDiagnostics = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DiagnosticsProfile_STATUS populates our DiagnosticsProfile from the provided source DiagnosticsProfile_STATUS
func (profile *DiagnosticsProfile) Initialize_From_DiagnosticsProfile_STATUS(source *DiagnosticsProfile_STATUS) error {

	// BootDiagnostics
	if source.BootDiagnostics != nil {
		var bootDiagnostic BootDiagnostics
		err := bootDiagnostic.Initialize_From_BootDiagnostics_STATUS(source.BootDiagnostics)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_BootDiagnostics_STATUS() to populate field BootDiagnostics")
		}
		profile.BootDiagnostics = &bootDiagnostic
	} else {
		profile.BootDiagnostics = nil
	}

	// No error
	return nil
}

// Specifies the boot diagnostic settings state.
// Minimum api-version: 2015-06-15.
type DiagnosticsProfile_STATUS struct {
	// BootDiagnostics: Boot Diagnostics is a debugging feature which allows you to view Console Output and Screenshot to
	// diagnose VM status.
	// NOTE: If storageUri is being specified then ensure that the storage account is in the same region and subscription as
	// the VM.
	// You can easily view the output of your console log.
	// Azure also enables you to see a screenshot of the VM from the hypervisor.
	BootDiagnostics *BootDiagnostics_STATUS `json:"bootDiagnostics,omitempty"`
}

var _ genruntime.FromARMConverter = &DiagnosticsProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *DiagnosticsProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DiagnosticsProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *DiagnosticsProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DiagnosticsProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DiagnosticsProfile_STATUS, got %T", armInput)
	}

	// Set property "BootDiagnostics":
	if typedInput.BootDiagnostics != nil {
		var bootDiagnostics1 BootDiagnostics_STATUS
		err := bootDiagnostics1.PopulateFromARM(owner, *typedInput.BootDiagnostics)
		if err != nil {
			return err
		}
		bootDiagnostics := bootDiagnostics1
		profile.BootDiagnostics = &bootDiagnostics
	}

	// No error
	return nil
}

// AssignProperties_From_DiagnosticsProfile_STATUS populates our DiagnosticsProfile_STATUS from the provided source DiagnosticsProfile_STATUS
func (profile *DiagnosticsProfile_STATUS) AssignProperties_From_DiagnosticsProfile_STATUS(source *storage.DiagnosticsProfile_STATUS) error {

	// BootDiagnostics
	if source.BootDiagnostics != nil {
		var bootDiagnostic BootDiagnostics_STATUS
		err := bootDiagnostic.AssignProperties_From_BootDiagnostics_STATUS(source.BootDiagnostics)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BootDiagnostics_STATUS() to populate field BootDiagnostics")
		}
		profile.BootDiagnostics = &bootDiagnostic
	} else {
		profile.BootDiagnostics = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DiagnosticsProfile_STATUS populates the provided destination DiagnosticsProfile_STATUS from our DiagnosticsProfile_STATUS
func (profile *DiagnosticsProfile_STATUS) AssignProperties_To_DiagnosticsProfile_STATUS(destination *storage.DiagnosticsProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BootDiagnostics
	if profile.BootDiagnostics != nil {
		var bootDiagnostic storage.BootDiagnostics_STATUS
		err := profile.BootDiagnostics.AssignProperties_To_BootDiagnostics_STATUS(&bootDiagnostic)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BootDiagnostics_STATUS() to populate field BootDiagnostics")
		}
		destination.BootDiagnostics = &bootDiagnostic
	} else {
		destination.BootDiagnostics = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Specifies the eviction policy for the Azure Spot VM/VMSS
// +kubebuilder:validation:Enum={"Deallocate","Delete"}
type EvictionPolicy string

const (
	EvictionPolicy_Deallocate = EvictionPolicy("Deallocate")
	EvictionPolicy_Delete     = EvictionPolicy("Delete")
)

// Mapping from string to EvictionPolicy
var evictionPolicy_Values = map[string]EvictionPolicy{
	"deallocate": EvictionPolicy_Deallocate,
	"delete":     EvictionPolicy_Delete,
}

// Specifies the eviction policy for the Azure Spot VM/VMSS
type EvictionPolicy_STATUS string

const (
	EvictionPolicy_STATUS_Deallocate = EvictionPolicy_STATUS("Deallocate")
	EvictionPolicy_STATUS_Delete     = EvictionPolicy_STATUS("Delete")
)

// Mapping from string to EvictionPolicy_STATUS
var evictionPolicy_STATUS_Values = map[string]EvictionPolicy_STATUS{
	"deallocate": EvictionPolicy_STATUS_Deallocate,
	"delete":     EvictionPolicy_STATUS_Delete,
}

// Specifies the hardware settings for the virtual machine.
type HardwareProfile struct {
	// VmSize: Specifies the size of the virtual machine.
	// The enum data type is currently deprecated and will be removed by December 23rd 2023.
	// Recommended way to get the list of available sizes is using these APIs:
	// [List all available virtual machine sizes in an availability
	// set](https://docs.microsoft.com/rest/api/compute/availabilitysets/listavailablesizes)
	// [List all available virtual machine sizes in a region]( https://docs.microsoft.com/rest/api/compute/resourceskus/list)
	// [List all available virtual machine sizes for
	// resizing](https://docs.microsoft.com/rest/api/compute/virtualmachines/listavailablesizes). For more information about
	// virtual machine sizes, see [Sizes for virtual machines](https://docs.microsoft.com/azure/virtual-machines/sizes).
	// The available VM sizes depend on region and availability set.
	VmSize *string `json:"vmSize,omitempty"`

	// VmSizeProperties: Specifies the properties for customizing the size of the virtual machine. Minimum api-version:
	// 2021-07-01.
	// This feature is still in preview mode and is not supported for VirtualMachineScaleSet.
	// Please follow the instructions in [VM Customization](https://aka.ms/vmcustomization) for more details.
	VmSizeProperties *VMSizeProperties `json:"vmSizeProperties,omitempty"`
}

var _ genruntime.ARMTransformer = &HardwareProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *HardwareProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.HardwareProfile{}

	// Set property "VmSize":
	if profile.VmSize != nil {
		vmSize := *profile.VmSize
		result.VmSize = &vmSize
	}

	// Set property "VmSizeProperties":
	if profile.VmSizeProperties != nil {
		vmSizeProperties_ARM, err := (*profile.VmSizeProperties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		vmSizeProperties := *vmSizeProperties_ARM.(*arm.VMSizeProperties)
		result.VmSizeProperties = &vmSizeProperties
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *HardwareProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HardwareProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *HardwareProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HardwareProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HardwareProfile, got %T", armInput)
	}

	// Set property "VmSize":
	if typedInput.VmSize != nil {
		vmSize := *typedInput.VmSize
		profile.VmSize = &vmSize
	}

	// Set property "VmSizeProperties":
	if typedInput.VmSizeProperties != nil {
		var vmSizeProperties1 VMSizeProperties
		err := vmSizeProperties1.PopulateFromARM(owner, *typedInput.VmSizeProperties)
		if err != nil {
			return err
		}
		vmSizeProperties := vmSizeProperties1
		profile.VmSizeProperties = &vmSizeProperties
	}

	// No error
	return nil
}

// AssignProperties_From_HardwareProfile populates our HardwareProfile from the provided source HardwareProfile
func (profile *HardwareProfile) AssignProperties_From_HardwareProfile(source *storage.HardwareProfile) error {

	// VmSize
	profile.VmSize = genruntime.ClonePointerToString(source.VmSize)

	// VmSizeProperties
	if source.VmSizeProperties != nil {
		var vmSizeProperty VMSizeProperties
		err := vmSizeProperty.AssignProperties_From_VMSizeProperties(source.VmSizeProperties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VMSizeProperties() to populate field VmSizeProperties")
		}
		profile.VmSizeProperties = &vmSizeProperty
	} else {
		profile.VmSizeProperties = nil
	}

	// No error
	return nil
}

// AssignProperties_To_HardwareProfile populates the provided destination HardwareProfile from our HardwareProfile
func (profile *HardwareProfile) AssignProperties_To_HardwareProfile(destination *storage.HardwareProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// VmSize
	destination.VmSize = genruntime.ClonePointerToString(profile.VmSize)

	// VmSizeProperties
	if profile.VmSizeProperties != nil {
		var vmSizeProperty storage.VMSizeProperties
		err := profile.VmSizeProperties.AssignProperties_To_VMSizeProperties(&vmSizeProperty)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VMSizeProperties() to populate field VmSizeProperties")
		}
		destination.VmSizeProperties = &vmSizeProperty
	} else {
		destination.VmSizeProperties = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_HardwareProfile_STATUS populates our HardwareProfile from the provided source HardwareProfile_STATUS
func (profile *HardwareProfile) Initialize_From_HardwareProfile_STATUS(source *HardwareProfile_STATUS) error {

	// VmSize
	if source.VmSize != nil {
		vmSize := string(*source.VmSize)
		profile.VmSize = &vmSize
	} else {
		profile.VmSize = nil
	}

	// VmSizeProperties
	if source.VmSizeProperties != nil {
		var vmSizeProperty VMSizeProperties
		err := vmSizeProperty.Initialize_From_VMSizeProperties_STATUS(source.VmSizeProperties)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_VMSizeProperties_STATUS() to populate field VmSizeProperties")
		}
		profile.VmSizeProperties = &vmSizeProperty
	} else {
		profile.VmSizeProperties = nil
	}

	// No error
	return nil
}

// Specifies the hardware settings for the virtual machine.
type HardwareProfile_STATUS struct {
	// VmSize: Specifies the size of the virtual machine.
	// The enum data type is currently deprecated and will be removed by December 23rd 2023.
	// Recommended way to get the list of available sizes is using these APIs:
	// [List all available virtual machine sizes in an availability
	// set](https://docs.microsoft.com/rest/api/compute/availabilitysets/listavailablesizes)
	// [List all available virtual machine sizes in a region]( https://docs.microsoft.com/rest/api/compute/resourceskus/list)
	// [List all available virtual machine sizes for
	// resizing](https://docs.microsoft.com/rest/api/compute/virtualmachines/listavailablesizes). For more information about
	// virtual machine sizes, see [Sizes for virtual machines](https://docs.microsoft.com/azure/virtual-machines/sizes).
	// The available VM sizes depend on region and availability set.
	VmSize *HardwareProfile_VmSize_STATUS `json:"vmSize,omitempty"`

	// VmSizeProperties: Specifies the properties for customizing the size of the virtual machine. Minimum api-version:
	// 2021-07-01.
	// This feature is still in preview mode and is not supported for VirtualMachineScaleSet.
	// Please follow the instructions in [VM Customization](https://aka.ms/vmcustomization) for more details.
	VmSizeProperties *VMSizeProperties_STATUS `json:"vmSizeProperties,omitempty"`
}

var _ genruntime.FromARMConverter = &HardwareProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *HardwareProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HardwareProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *HardwareProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HardwareProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HardwareProfile_STATUS, got %T", armInput)
	}

	// Set property "VmSize":
	if typedInput.VmSize != nil {
		var temp string
		temp = string(*typedInput.VmSize)
		vmSize := HardwareProfile_VmSize_STATUS(temp)
		profile.VmSize = &vmSize
	}

	// Set property "VmSizeProperties":
	if typedInput.VmSizeProperties != nil {
		var vmSizeProperties1 VMSizeProperties_STATUS
		err := vmSizeProperties1.PopulateFromARM(owner, *typedInput.VmSizeProperties)
		if err != nil {
			return err
		}
		vmSizeProperties := vmSizeProperties1
		profile.VmSizeProperties = &vmSizeProperties
	}

	// No error
	return nil
}

// AssignProperties_From_HardwareProfile_STATUS populates our HardwareProfile_STATUS from the provided source HardwareProfile_STATUS
func (profile *HardwareProfile_STATUS) AssignProperties_From_HardwareProfile_STATUS(source *storage.HardwareProfile_STATUS) error {

	// VmSize
	if source.VmSize != nil {
		vmSize := *source.VmSize
		vmSizeTemp := genruntime.ToEnum(vmSize, hardwareProfile_VmSize_STATUS_Values)
		profile.VmSize = &vmSizeTemp
	} else {
		profile.VmSize = nil
	}

	// VmSizeProperties
	if source.VmSizeProperties != nil {
		var vmSizeProperty VMSizeProperties_STATUS
		err := vmSizeProperty.AssignProperties_From_VMSizeProperties_STATUS(source.VmSizeProperties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VMSizeProperties_STATUS() to populate field VmSizeProperties")
		}
		profile.VmSizeProperties = &vmSizeProperty
	} else {
		profile.VmSizeProperties = nil
	}

	// No error
	return nil
}

// AssignProperties_To_HardwareProfile_STATUS populates the provided destination HardwareProfile_STATUS from our HardwareProfile_STATUS
func (profile *HardwareProfile_STATUS) AssignProperties_To_HardwareProfile_STATUS(destination *storage.HardwareProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// VmSize
	if profile.VmSize != nil {
		vmSize := string(*profile.VmSize)
		destination.VmSize = &vmSize
	} else {
		destination.VmSize = nil
	}

	// VmSizeProperties
	if profile.VmSizeProperties != nil {
		var vmSizeProperty storage.VMSizeProperties_STATUS
		err := profile.VmSizeProperties.AssignProperties_To_VMSizeProperties_STATUS(&vmSizeProperty)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VMSizeProperties_STATUS() to populate field VmSizeProperties")
		}
		destination.VmSizeProperties = &vmSizeProperty
	} else {
		destination.VmSizeProperties = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Specifies the network interfaces or the networking configuration of the virtual machine.
type NetworkProfile struct {
	// NetworkApiVersion: specifies the Microsoft.Network API version used when creating networking resources in the Network
	// Interface Configurations
	NetworkApiVersion *NetworkProfile_NetworkApiVersion `json:"networkApiVersion,omitempty"`

	// NetworkInterfaceConfigurations: Specifies the networking configurations that will be used to create the virtual machine
	// networking resources.
	NetworkInterfaceConfigurations []VirtualMachineNetworkInterfaceConfiguration `json:"networkInterfaceConfigurations,omitempty"`

	// NetworkInterfaces: Specifies the list of resource Ids for the network interfaces associated with the virtual machine.
	NetworkInterfaces []NetworkInterfaceReference `json:"networkInterfaces,omitempty"`
}

var _ genruntime.ARMTransformer = &NetworkProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *NetworkProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.NetworkProfile{}

	// Set property "NetworkApiVersion":
	if profile.NetworkApiVersion != nil {
		var temp string
		temp = string(*profile.NetworkApiVersion)
		networkApiVersion := arm.NetworkProfile_NetworkApiVersion(temp)
		result.NetworkApiVersion = &networkApiVersion
	}

	// Set property "NetworkInterfaceConfigurations":
	for _, item := range profile.NetworkInterfaceConfigurations {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.NetworkInterfaceConfigurations = append(result.NetworkInterfaceConfigurations, *item_ARM.(*arm.VirtualMachineNetworkInterfaceConfiguration))
	}

	// Set property "NetworkInterfaces":
	for _, item := range profile.NetworkInterfaces {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.NetworkInterfaces = append(result.NetworkInterfaces, *item_ARM.(*arm.NetworkInterfaceReference))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *NetworkProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NetworkProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *NetworkProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NetworkProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NetworkProfile, got %T", armInput)
	}

	// Set property "NetworkApiVersion":
	if typedInput.NetworkApiVersion != nil {
		var temp string
		temp = string(*typedInput.NetworkApiVersion)
		networkApiVersion := NetworkProfile_NetworkApiVersion(temp)
		profile.NetworkApiVersion = &networkApiVersion
	}

	// Set property "NetworkInterfaceConfigurations":
	for _, item := range typedInput.NetworkInterfaceConfigurations {
		var item1 VirtualMachineNetworkInterfaceConfiguration
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.NetworkInterfaceConfigurations = append(profile.NetworkInterfaceConfigurations, item1)
	}

	// Set property "NetworkInterfaces":
	for _, item := range typedInput.NetworkInterfaces {
		var item1 NetworkInterfaceReference
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.NetworkInterfaces = append(profile.NetworkInterfaces, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_NetworkProfile populates our NetworkProfile from the provided source NetworkProfile
func (profile *NetworkProfile) AssignProperties_From_NetworkProfile(source *storage.NetworkProfile) error {

	// NetworkApiVersion
	if source.NetworkApiVersion != nil {
		networkApiVersion := *source.NetworkApiVersion
		networkApiVersionTemp := genruntime.ToEnum(networkApiVersion, networkProfile_NetworkApiVersion_Values)
		profile.NetworkApiVersion = &networkApiVersionTemp
	} else {
		profile.NetworkApiVersion = nil
	}

	// NetworkInterfaceConfigurations
	if source.NetworkInterfaceConfigurations != nil {
		networkInterfaceConfigurationList := make([]VirtualMachineNetworkInterfaceConfiguration, len(source.NetworkInterfaceConfigurations))
		for networkInterfaceConfigurationIndex, networkInterfaceConfigurationItem := range source.NetworkInterfaceConfigurations {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceConfigurationItem := networkInterfaceConfigurationItem
			var networkInterfaceConfiguration VirtualMachineNetworkInterfaceConfiguration
			err := networkInterfaceConfiguration.AssignProperties_From_VirtualMachineNetworkInterfaceConfiguration(&networkInterfaceConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineNetworkInterfaceConfiguration() to populate field NetworkInterfaceConfigurations")
			}
			networkInterfaceConfigurationList[networkInterfaceConfigurationIndex] = networkInterfaceConfiguration
		}
		profile.NetworkInterfaceConfigurations = networkInterfaceConfigurationList
	} else {
		profile.NetworkInterfaceConfigurations = nil
	}

	// NetworkInterfaces
	if source.NetworkInterfaces != nil {
		networkInterfaceList := make([]NetworkInterfaceReference, len(source.NetworkInterfaces))
		for networkInterfaceIndex, networkInterfaceItem := range source.NetworkInterfaces {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceItem := networkInterfaceItem
			var networkInterface NetworkInterfaceReference
			err := networkInterface.AssignProperties_From_NetworkInterfaceReference(&networkInterfaceItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_NetworkInterfaceReference() to populate field NetworkInterfaces")
			}
			networkInterfaceList[networkInterfaceIndex] = networkInterface
		}
		profile.NetworkInterfaces = networkInterfaceList
	} else {
		profile.NetworkInterfaces = nil
	}

	// No error
	return nil
}

// AssignProperties_To_NetworkProfile populates the provided destination NetworkProfile from our NetworkProfile
func (profile *NetworkProfile) AssignProperties_To_NetworkProfile(destination *storage.NetworkProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// NetworkApiVersion
	if profile.NetworkApiVersion != nil {
		networkApiVersion := string(*profile.NetworkApiVersion)
		destination.NetworkApiVersion = &networkApiVersion
	} else {
		destination.NetworkApiVersion = nil
	}

	// NetworkInterfaceConfigurations
	if profile.NetworkInterfaceConfigurations != nil {
		networkInterfaceConfigurationList := make([]storage.VirtualMachineNetworkInterfaceConfiguration, len(profile.NetworkInterfaceConfigurations))
		for networkInterfaceConfigurationIndex, networkInterfaceConfigurationItem := range profile.NetworkInterfaceConfigurations {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceConfigurationItem := networkInterfaceConfigurationItem
			var networkInterfaceConfiguration storage.VirtualMachineNetworkInterfaceConfiguration
			err := networkInterfaceConfigurationItem.AssignProperties_To_VirtualMachineNetworkInterfaceConfiguration(&networkInterfaceConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineNetworkInterfaceConfiguration() to populate field NetworkInterfaceConfigurations")
			}
			networkInterfaceConfigurationList[networkInterfaceConfigurationIndex] = networkInterfaceConfiguration
		}
		destination.NetworkInterfaceConfigurations = networkInterfaceConfigurationList
	} else {
		destination.NetworkInterfaceConfigurations = nil
	}

	// NetworkInterfaces
	if profile.NetworkInterfaces != nil {
		networkInterfaceList := make([]storage.NetworkInterfaceReference, len(profile.NetworkInterfaces))
		for networkInterfaceIndex, networkInterfaceItem := range profile.NetworkInterfaces {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceItem := networkInterfaceItem
			var networkInterface storage.NetworkInterfaceReference
			err := networkInterfaceItem.AssignProperties_To_NetworkInterfaceReference(&networkInterface)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_NetworkInterfaceReference() to populate field NetworkInterfaces")
			}
			networkInterfaceList[networkInterfaceIndex] = networkInterface
		}
		destination.NetworkInterfaces = networkInterfaceList
	} else {
		destination.NetworkInterfaces = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_NetworkProfile_STATUS populates our NetworkProfile from the provided source NetworkProfile_STATUS
func (profile *NetworkProfile) Initialize_From_NetworkProfile_STATUS(source *NetworkProfile_STATUS) error {

	// NetworkApiVersion
	if source.NetworkApiVersion != nil {
		networkApiVersion := genruntime.ToEnum(string(*source.NetworkApiVersion), networkProfile_NetworkApiVersion_Values)
		profile.NetworkApiVersion = &networkApiVersion
	} else {
		profile.NetworkApiVersion = nil
	}

	// NetworkInterfaceConfigurations
	if source.NetworkInterfaceConfigurations != nil {
		networkInterfaceConfigurationList := make([]VirtualMachineNetworkInterfaceConfiguration, len(source.NetworkInterfaceConfigurations))
		for networkInterfaceConfigurationIndex, networkInterfaceConfigurationItem := range source.NetworkInterfaceConfigurations {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceConfigurationItem := networkInterfaceConfigurationItem
			var networkInterfaceConfiguration VirtualMachineNetworkInterfaceConfiguration
			err := networkInterfaceConfiguration.Initialize_From_VirtualMachineNetworkInterfaceConfiguration_STATUS(&networkInterfaceConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_VirtualMachineNetworkInterfaceConfiguration_STATUS() to populate field NetworkInterfaceConfigurations")
			}
			networkInterfaceConfigurationList[networkInterfaceConfigurationIndex] = networkInterfaceConfiguration
		}
		profile.NetworkInterfaceConfigurations = networkInterfaceConfigurationList
	} else {
		profile.NetworkInterfaceConfigurations = nil
	}

	// NetworkInterfaces
	if source.NetworkInterfaces != nil {
		networkInterfaceList := make([]NetworkInterfaceReference, len(source.NetworkInterfaces))
		for networkInterfaceIndex, networkInterfaceItem := range source.NetworkInterfaces {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceItem := networkInterfaceItem
			var networkInterface NetworkInterfaceReference
			err := networkInterface.Initialize_From_NetworkInterfaceReference_STATUS(&networkInterfaceItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_NetworkInterfaceReference_STATUS() to populate field NetworkInterfaces")
			}
			networkInterfaceList[networkInterfaceIndex] = networkInterface
		}
		profile.NetworkInterfaces = networkInterfaceList
	} else {
		profile.NetworkInterfaces = nil
	}

	// No error
	return nil
}

// Specifies the network interfaces or the networking configuration of the virtual machine.
type NetworkProfile_STATUS struct {
	// NetworkApiVersion: specifies the Microsoft.Network API version used when creating networking resources in the Network
	// Interface Configurations
	NetworkApiVersion *NetworkProfile_NetworkApiVersion_STATUS `json:"networkApiVersion,omitempty"`

	// NetworkInterfaceConfigurations: Specifies the networking configurations that will be used to create the virtual machine
	// networking resources.
	NetworkInterfaceConfigurations []VirtualMachineNetworkInterfaceConfiguration_STATUS `json:"networkInterfaceConfigurations,omitempty"`

	// NetworkInterfaces: Specifies the list of resource Ids for the network interfaces associated with the virtual machine.
	NetworkInterfaces []NetworkInterfaceReference_STATUS `json:"networkInterfaces,omitempty"`
}

var _ genruntime.FromARMConverter = &NetworkProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *NetworkProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NetworkProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *NetworkProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NetworkProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NetworkProfile_STATUS, got %T", armInput)
	}

	// Set property "NetworkApiVersion":
	if typedInput.NetworkApiVersion != nil {
		var temp string
		temp = string(*typedInput.NetworkApiVersion)
		networkApiVersion := NetworkProfile_NetworkApiVersion_STATUS(temp)
		profile.NetworkApiVersion = &networkApiVersion
	}

	// Set property "NetworkInterfaceConfigurations":
	for _, item := range typedInput.NetworkInterfaceConfigurations {
		var item1 VirtualMachineNetworkInterfaceConfiguration_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.NetworkInterfaceConfigurations = append(profile.NetworkInterfaceConfigurations, item1)
	}

	// Set property "NetworkInterfaces":
	for _, item := range typedInput.NetworkInterfaces {
		var item1 NetworkInterfaceReference_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.NetworkInterfaces = append(profile.NetworkInterfaces, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_NetworkProfile_STATUS populates our NetworkProfile_STATUS from the provided source NetworkProfile_STATUS
func (profile *NetworkProfile_STATUS) AssignProperties_From_NetworkProfile_STATUS(source *storage.NetworkProfile_STATUS) error {

	// NetworkApiVersion
	if source.NetworkApiVersion != nil {
		networkApiVersion := *source.NetworkApiVersion
		networkApiVersionTemp := genruntime.ToEnum(networkApiVersion, networkProfile_NetworkApiVersion_STATUS_Values)
		profile.NetworkApiVersion = &networkApiVersionTemp
	} else {
		profile.NetworkApiVersion = nil
	}

	// NetworkInterfaceConfigurations
	if source.NetworkInterfaceConfigurations != nil {
		networkInterfaceConfigurationList := make([]VirtualMachineNetworkInterfaceConfiguration_STATUS, len(source.NetworkInterfaceConfigurations))
		for networkInterfaceConfigurationIndex, networkInterfaceConfigurationItem := range source.NetworkInterfaceConfigurations {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceConfigurationItem := networkInterfaceConfigurationItem
			var networkInterfaceConfiguration VirtualMachineNetworkInterfaceConfiguration_STATUS
			err := networkInterfaceConfiguration.AssignProperties_From_VirtualMachineNetworkInterfaceConfiguration_STATUS(&networkInterfaceConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineNetworkInterfaceConfiguration_STATUS() to populate field NetworkInterfaceConfigurations")
			}
			networkInterfaceConfigurationList[networkInterfaceConfigurationIndex] = networkInterfaceConfiguration
		}
		profile.NetworkInterfaceConfigurations = networkInterfaceConfigurationList
	} else {
		profile.NetworkInterfaceConfigurations = nil
	}

	// NetworkInterfaces
	if source.NetworkInterfaces != nil {
		networkInterfaceList := make([]NetworkInterfaceReference_STATUS, len(source.NetworkInterfaces))
		for networkInterfaceIndex, networkInterfaceItem := range source.NetworkInterfaces {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceItem := networkInterfaceItem
			var networkInterface NetworkInterfaceReference_STATUS
			err := networkInterface.AssignProperties_From_NetworkInterfaceReference_STATUS(&networkInterfaceItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_NetworkInterfaceReference_STATUS() to populate field NetworkInterfaces")
			}
			networkInterfaceList[networkInterfaceIndex] = networkInterface
		}
		profile.NetworkInterfaces = networkInterfaceList
	} else {
		profile.NetworkInterfaces = nil
	}

	// No error
	return nil
}

// AssignProperties_To_NetworkProfile_STATUS populates the provided destination NetworkProfile_STATUS from our NetworkProfile_STATUS
func (profile *NetworkProfile_STATUS) AssignProperties_To_NetworkProfile_STATUS(destination *storage.NetworkProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// NetworkApiVersion
	if profile.NetworkApiVersion != nil {
		networkApiVersion := string(*profile.NetworkApiVersion)
		destination.NetworkApiVersion = &networkApiVersion
	} else {
		destination.NetworkApiVersion = nil
	}

	// NetworkInterfaceConfigurations
	if profile.NetworkInterfaceConfigurations != nil {
		networkInterfaceConfigurationList := make([]storage.VirtualMachineNetworkInterfaceConfiguration_STATUS, len(profile.NetworkInterfaceConfigurations))
		for networkInterfaceConfigurationIndex, networkInterfaceConfigurationItem := range profile.NetworkInterfaceConfigurations {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceConfigurationItem := networkInterfaceConfigurationItem
			var networkInterfaceConfiguration storage.VirtualMachineNetworkInterfaceConfiguration_STATUS
			err := networkInterfaceConfigurationItem.AssignProperties_To_VirtualMachineNetworkInterfaceConfiguration_STATUS(&networkInterfaceConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineNetworkInterfaceConfiguration_STATUS() to populate field NetworkInterfaceConfigurations")
			}
			networkInterfaceConfigurationList[networkInterfaceConfigurationIndex] = networkInterfaceConfiguration
		}
		destination.NetworkInterfaceConfigurations = networkInterfaceConfigurationList
	} else {
		destination.NetworkInterfaceConfigurations = nil
	}

	// NetworkInterfaces
	if profile.NetworkInterfaces != nil {
		networkInterfaceList := make([]storage.NetworkInterfaceReference_STATUS, len(profile.NetworkInterfaces))
		for networkInterfaceIndex, networkInterfaceItem := range profile.NetworkInterfaces {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceItem := networkInterfaceItem
			var networkInterface storage.NetworkInterfaceReference_STATUS
			err := networkInterfaceItem.AssignProperties_To_NetworkInterfaceReference_STATUS(&networkInterface)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_NetworkInterfaceReference_STATUS() to populate field NetworkInterfaces")
			}
			networkInterfaceList[networkInterfaceIndex] = networkInterface
		}
		destination.NetworkInterfaces = networkInterfaceList
	} else {
		destination.NetworkInterfaces = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Specifies the operating system settings for the virtual machine. Some of the settings cannot be changed once VM is
// provisioned.
type OSProfile struct {
	// AdminPassword: Specifies the password of the administrator account.
	// Minimum-length (Windows): 8 characters
	// Minimum-length (Linux): 6 characters
	// Max-length (Windows): 123 characters
	// Max-length (Linux): 72 characters
	// Complexity requirements: 3 out of 4 conditions below need to be fulfilled
	// Has lower characters
	// Has upper characters
	// Has a digit
	// Has a special character (Regex match [\W_])
	// Disallowed values: "abc@123", "P@$$w0rd", "P@ssw0rd", "P@ssword123", "Pa$$word", "pass@word1", "Password!", "Password1",
	// "Password22", "iloveyou!"
	// For resetting the password, see [How to reset the Remote Desktop service or its login password in a Windows
	// VM](https://docs.microsoft.com/troubleshoot/azure/virtual-machines/reset-rdp)
	// For resetting root password, see [Manage users, SSH, and check or repair disks on Azure Linux VMs using the VMAccess
	// Extension](https://docs.microsoft.com/troubleshoot/azure/virtual-machines/troubleshoot-ssh-connection)
	AdminPassword *genruntime.SecretReference `json:"adminPassword,omitempty"`

	// AdminUsername: Specifies the name of the administrator account.
	// This property cannot be updated after the VM is created.
	// Windows-only restriction: Cannot end in "."
	// Disallowed values: "administrator", "admin", "user", "user1", "test", "user2", "test1", "user3", "admin1", "1", "123",
	// "a", "actuser", "adm", "admin2", "aspnet", "backup", "console", "david", "guest", "john", "owner", "root", "server",
	// "sql", "support", "support_388945a0", "sys", "test2", "test3", "user4", "user5".
	// Minimum-length (Linux): 1  character
	// Max-length (Linux): 64 characters
	// Max-length (Windows): 20 characters.
	AdminUsername *string `json:"adminUsername,omitempty"`

	// AllowExtensionOperations: Specifies whether extension operations should be allowed on the virtual machine.
	// This may only be set to False when no extensions are present on the virtual machine.
	AllowExtensionOperations *bool `json:"allowExtensionOperations,omitempty"`

	// ComputerName: Specifies the host OS name of the virtual machine.
	// This name cannot be updated after the VM is created.
	// Max-length (Windows): 15 characters
	// Max-length (Linux): 64 characters.
	// For naming conventions and restrictions see [Azure infrastructure services implementation
	// guidelines](https://docs.microsoft.com/azure/azure-resource-manager/management/resource-name-rules).
	ComputerName *string `json:"computerName,omitempty"`

	// CustomData: Specifies a base-64 encoded string of custom data. The base-64 encoded string is decoded to a binary array
	// that is saved as a file on the Virtual Machine. The maximum length of the binary array is 65535 bytes.
	// Note: Do not pass any secrets or passwords in customData property
	// This property cannot be updated after the VM is created.
	// customData is passed to the VM to be saved as a file, for more information see [Custom Data on Azure
	// VMs](https://azure.microsoft.com/blog/custom-data-and-cloud-init-on-windows-azure/)
	// For using cloud-init for your Linux VM, see [Using cloud-init to customize a Linux VM during
	// creation](https://docs.microsoft.com/azure/virtual-machines/linux/using-cloud-init)
	CustomData *string `json:"customData,omitempty"`

	// LinuxConfiguration: Specifies the Linux operating system settings on the virtual machine.
	// For a list of supported Linux distributions, see [Linux on Azure-Endorsed
	// Distributions](https://docs.microsoft.com/azure/virtual-machines/linux/endorsed-distros).
	LinuxConfiguration *LinuxConfiguration `json:"linuxConfiguration,omitempty"`

	// RequireGuestProvisionSignal: Optional property which must either be set to True or omitted.
	RequireGuestProvisionSignal *bool `json:"requireGuestProvisionSignal,omitempty"`

	// Secrets: Specifies set of certificates that should be installed onto the virtual machine. To install certificates on a
	// virtual machine it is recommended to use the [Azure Key Vault virtual machine extension for
	// Linux](https://docs.microsoft.com/azure/virtual-machines/extensions/key-vault-linux) or the [Azure Key Vault virtual
	// machine extension for Windows](https://docs.microsoft.com/azure/virtual-machines/extensions/key-vault-windows).
	Secrets []VaultSecretGroup `json:"secrets,omitempty"`

	// WindowsConfiguration: Specifies Windows operating system settings on the virtual machine.
	WindowsConfiguration *WindowsConfiguration `json:"windowsConfiguration,omitempty"`
}

var _ genruntime.ARMTransformer = &OSProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *OSProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.OSProfile{}

	// Set property "AdminPassword":
	if profile.AdminPassword != nil {
		adminPasswordSecret, err := resolved.ResolvedSecrets.Lookup(*profile.AdminPassword)
		if err != nil {
			return nil, errors.Wrap(err, "looking up secret for property AdminPassword")
		}
		adminPassword := adminPasswordSecret
		result.AdminPassword = &adminPassword
	}

	// Set property "AdminUsername":
	if profile.AdminUsername != nil {
		adminUsername := *profile.AdminUsername
		result.AdminUsername = &adminUsername
	}

	// Set property "AllowExtensionOperations":
	if profile.AllowExtensionOperations != nil {
		allowExtensionOperations := *profile.AllowExtensionOperations
		result.AllowExtensionOperations = &allowExtensionOperations
	}

	// Set property "ComputerName":
	if profile.ComputerName != nil {
		computerName := *profile.ComputerName
		result.ComputerName = &computerName
	}

	// Set property "CustomData":
	if profile.CustomData != nil {
		customData := *profile.CustomData
		result.CustomData = &customData
	}

	// Set property "LinuxConfiguration":
	if profile.LinuxConfiguration != nil {
		linuxConfiguration_ARM, err := (*profile.LinuxConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		linuxConfiguration := *linuxConfiguration_ARM.(*arm.LinuxConfiguration)
		result.LinuxConfiguration = &linuxConfiguration
	}

	// Set property "RequireGuestProvisionSignal":
	if profile.RequireGuestProvisionSignal != nil {
		requireGuestProvisionSignal := *profile.RequireGuestProvisionSignal
		result.RequireGuestProvisionSignal = &requireGuestProvisionSignal
	}

	// Set property "Secrets":
	for _, item := range profile.Secrets {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Secrets = append(result.Secrets, *item_ARM.(*arm.VaultSecretGroup))
	}

	// Set property "WindowsConfiguration":
	if profile.WindowsConfiguration != nil {
		windowsConfiguration_ARM, err := (*profile.WindowsConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		windowsConfiguration := *windowsConfiguration_ARM.(*arm.WindowsConfiguration)
		result.WindowsConfiguration = &windowsConfiguration
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *OSProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.OSProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *OSProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.OSProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.OSProfile, got %T", armInput)
	}

	// no assignment for property "AdminPassword"

	// Set property "AdminUsername":
	if typedInput.AdminUsername != nil {
		adminUsername := *typedInput.AdminUsername
		profile.AdminUsername = &adminUsername
	}

	// Set property "AllowExtensionOperations":
	if typedInput.AllowExtensionOperations != nil {
		allowExtensionOperations := *typedInput.AllowExtensionOperations
		profile.AllowExtensionOperations = &allowExtensionOperations
	}

	// Set property "ComputerName":
	if typedInput.ComputerName != nil {
		computerName := *typedInput.ComputerName
		profile.ComputerName = &computerName
	}

	// Set property "CustomData":
	if typedInput.CustomData != nil {
		customData := *typedInput.CustomData
		profile.CustomData = &customData
	}

	// Set property "LinuxConfiguration":
	if typedInput.LinuxConfiguration != nil {
		var linuxConfiguration1 LinuxConfiguration
		err := linuxConfiguration1.PopulateFromARM(owner, *typedInput.LinuxConfiguration)
		if err != nil {
			return err
		}
		linuxConfiguration := linuxConfiguration1
		profile.LinuxConfiguration = &linuxConfiguration
	}

	// Set property "RequireGuestProvisionSignal":
	if typedInput.RequireGuestProvisionSignal != nil {
		requireGuestProvisionSignal := *typedInput.RequireGuestProvisionSignal
		profile.RequireGuestProvisionSignal = &requireGuestProvisionSignal
	}

	// Set property "Secrets":
	for _, item := range typedInput.Secrets {
		var item1 VaultSecretGroup
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.Secrets = append(profile.Secrets, item1)
	}

	// Set property "WindowsConfiguration":
	if typedInput.WindowsConfiguration != nil {
		var windowsConfiguration1 WindowsConfiguration
		err := windowsConfiguration1.PopulateFromARM(owner, *typedInput.WindowsConfiguration)
		if err != nil {
			return err
		}
		windowsConfiguration := windowsConfiguration1
		profile.WindowsConfiguration = &windowsConfiguration
	}

	// No error
	return nil
}

// AssignProperties_From_OSProfile populates our OSProfile from the provided source OSProfile
func (profile *OSProfile) AssignProperties_From_OSProfile(source *storage.OSProfile) error {

	// AdminPassword
	if source.AdminPassword != nil {
		adminPassword := source.AdminPassword.Copy()
		profile.AdminPassword = &adminPassword
	} else {
		profile.AdminPassword = nil
	}

	// AdminUsername
	profile.AdminUsername = genruntime.ClonePointerToString(source.AdminUsername)

	// AllowExtensionOperations
	if source.AllowExtensionOperations != nil {
		allowExtensionOperation := *source.AllowExtensionOperations
		profile.AllowExtensionOperations = &allowExtensionOperation
	} else {
		profile.AllowExtensionOperations = nil
	}

	// ComputerName
	profile.ComputerName = genruntime.ClonePointerToString(source.ComputerName)

	// CustomData
	profile.CustomData = genruntime.ClonePointerToString(source.CustomData)

	// LinuxConfiguration
	if source.LinuxConfiguration != nil {
		var linuxConfiguration LinuxConfiguration
		err := linuxConfiguration.AssignProperties_From_LinuxConfiguration(source.LinuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_LinuxConfiguration() to populate field LinuxConfiguration")
		}
		profile.LinuxConfiguration = &linuxConfiguration
	} else {
		profile.LinuxConfiguration = nil
	}

	// RequireGuestProvisionSignal
	if source.RequireGuestProvisionSignal != nil {
		requireGuestProvisionSignal := *source.RequireGuestProvisionSignal
		profile.RequireGuestProvisionSignal = &requireGuestProvisionSignal
	} else {
		profile.RequireGuestProvisionSignal = nil
	}

	// Secrets
	if source.Secrets != nil {
		secretList := make([]VaultSecretGroup, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret VaultSecretGroup
			err := secret.AssignProperties_From_VaultSecretGroup(&secretItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VaultSecretGroup() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		profile.Secrets = secretList
	} else {
		profile.Secrets = nil
	}

	// WindowsConfiguration
	if source.WindowsConfiguration != nil {
		var windowsConfiguration WindowsConfiguration
		err := windowsConfiguration.AssignProperties_From_WindowsConfiguration(source.WindowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WindowsConfiguration() to populate field WindowsConfiguration")
		}
		profile.WindowsConfiguration = &windowsConfiguration
	} else {
		profile.WindowsConfiguration = nil
	}

	// No error
	return nil
}

// AssignProperties_To_OSProfile populates the provided destination OSProfile from our OSProfile
func (profile *OSProfile) AssignProperties_To_OSProfile(destination *storage.OSProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminPassword
	if profile.AdminPassword != nil {
		adminPassword := profile.AdminPassword.Copy()
		destination.AdminPassword = &adminPassword
	} else {
		destination.AdminPassword = nil
	}

	// AdminUsername
	destination.AdminUsername = genruntime.ClonePointerToString(profile.AdminUsername)

	// AllowExtensionOperations
	if profile.AllowExtensionOperations != nil {
		allowExtensionOperation := *profile.AllowExtensionOperations
		destination.AllowExtensionOperations = &allowExtensionOperation
	} else {
		destination.AllowExtensionOperations = nil
	}

	// ComputerName
	destination.ComputerName = genruntime.ClonePointerToString(profile.ComputerName)

	// CustomData
	destination.CustomData = genruntime.ClonePointerToString(profile.CustomData)

	// LinuxConfiguration
	if profile.LinuxConfiguration != nil {
		var linuxConfiguration storage.LinuxConfiguration
		err := profile.LinuxConfiguration.AssignProperties_To_LinuxConfiguration(&linuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_LinuxConfiguration() to populate field LinuxConfiguration")
		}
		destination.LinuxConfiguration = &linuxConfiguration
	} else {
		destination.LinuxConfiguration = nil
	}

	// RequireGuestProvisionSignal
	if profile.RequireGuestProvisionSignal != nil {
		requireGuestProvisionSignal := *profile.RequireGuestProvisionSignal
		destination.RequireGuestProvisionSignal = &requireGuestProvisionSignal
	} else {
		destination.RequireGuestProvisionSignal = nil
	}

	// Secrets
	if profile.Secrets != nil {
		secretList := make([]storage.VaultSecretGroup, len(profile.Secrets))
		for secretIndex, secretItem := range profile.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret storage.VaultSecretGroup
			err := secretItem.AssignProperties_To_VaultSecretGroup(&secret)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VaultSecretGroup() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		destination.Secrets = secretList
	} else {
		destination.Secrets = nil
	}

	// WindowsConfiguration
	if profile.WindowsConfiguration != nil {
		var windowsConfiguration storage.WindowsConfiguration
		err := profile.WindowsConfiguration.AssignProperties_To_WindowsConfiguration(&windowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WindowsConfiguration() to populate field WindowsConfiguration")
		}
		destination.WindowsConfiguration = &windowsConfiguration
	} else {
		destination.WindowsConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_OSProfile_STATUS populates our OSProfile from the provided source OSProfile_STATUS
func (profile *OSProfile) Initialize_From_OSProfile_STATUS(source *OSProfile_STATUS) error {

	// AdminUsername
	profile.AdminUsername = genruntime.ClonePointerToString(source.AdminUsername)

	// AllowExtensionOperations
	if source.AllowExtensionOperations != nil {
		allowExtensionOperation := *source.AllowExtensionOperations
		profile.AllowExtensionOperations = &allowExtensionOperation
	} else {
		profile.AllowExtensionOperations = nil
	}

	// ComputerName
	profile.ComputerName = genruntime.ClonePointerToString(source.ComputerName)

	// CustomData
	profile.CustomData = genruntime.ClonePointerToString(source.CustomData)

	// LinuxConfiguration
	if source.LinuxConfiguration != nil {
		var linuxConfiguration LinuxConfiguration
		err := linuxConfiguration.Initialize_From_LinuxConfiguration_STATUS(source.LinuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_LinuxConfiguration_STATUS() to populate field LinuxConfiguration")
		}
		profile.LinuxConfiguration = &linuxConfiguration
	} else {
		profile.LinuxConfiguration = nil
	}

	// RequireGuestProvisionSignal
	if source.RequireGuestProvisionSignal != nil {
		requireGuestProvisionSignal := *source.RequireGuestProvisionSignal
		profile.RequireGuestProvisionSignal = &requireGuestProvisionSignal
	} else {
		profile.RequireGuestProvisionSignal = nil
	}

	// Secrets
	if source.Secrets != nil {
		secretList := make([]VaultSecretGroup, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret VaultSecretGroup
			err := secret.Initialize_From_VaultSecretGroup_STATUS(&secretItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_VaultSecretGroup_STATUS() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		profile.Secrets = secretList
	} else {
		profile.Secrets = nil
	}

	// WindowsConfiguration
	if source.WindowsConfiguration != nil {
		var windowsConfiguration WindowsConfiguration
		err := windowsConfiguration.Initialize_From_WindowsConfiguration_STATUS(source.WindowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_WindowsConfiguration_STATUS() to populate field WindowsConfiguration")
		}
		profile.WindowsConfiguration = &windowsConfiguration
	} else {
		profile.WindowsConfiguration = nil
	}

	// No error
	return nil
}

// Specifies the operating system settings for the virtual machine. Some of the settings cannot be changed once VM is
// provisioned.
type OSProfile_STATUS struct {
	// AdminUsername: Specifies the name of the administrator account.
	// This property cannot be updated after the VM is created.
	// Windows-only restriction: Cannot end in "."
	// Disallowed values: "administrator", "admin", "user", "user1", "test", "user2", "test1", "user3", "admin1", "1", "123",
	// "a", "actuser", "adm", "admin2", "aspnet", "backup", "console", "david", "guest", "john", "owner", "root", "server",
	// "sql", "support", "support_388945a0", "sys", "test2", "test3", "user4", "user5".
	// Minimum-length (Linux): 1  character
	// Max-length (Linux): 64 characters
	// Max-length (Windows): 20 characters.
	AdminUsername *string `json:"adminUsername,omitempty"`

	// AllowExtensionOperations: Specifies whether extension operations should be allowed on the virtual machine.
	// This may only be set to False when no extensions are present on the virtual machine.
	AllowExtensionOperations *bool `json:"allowExtensionOperations,omitempty"`

	// ComputerName: Specifies the host OS name of the virtual machine.
	// This name cannot be updated after the VM is created.
	// Max-length (Windows): 15 characters
	// Max-length (Linux): 64 characters.
	// For naming conventions and restrictions see [Azure infrastructure services implementation
	// guidelines](https://docs.microsoft.com/azure/azure-resource-manager/management/resource-name-rules).
	ComputerName *string `json:"computerName,omitempty"`

	// CustomData: Specifies a base-64 encoded string of custom data. The base-64 encoded string is decoded to a binary array
	// that is saved as a file on the Virtual Machine. The maximum length of the binary array is 65535 bytes.
	// Note: Do not pass any secrets or passwords in customData property
	// This property cannot be updated after the VM is created.
	// customData is passed to the VM to be saved as a file, for more information see [Custom Data on Azure
	// VMs](https://azure.microsoft.com/blog/custom-data-and-cloud-init-on-windows-azure/)
	// For using cloud-init for your Linux VM, see [Using cloud-init to customize a Linux VM during
	// creation](https://docs.microsoft.com/azure/virtual-machines/linux/using-cloud-init)
	CustomData *string `json:"customData,omitempty"`

	// LinuxConfiguration: Specifies the Linux operating system settings on the virtual machine.
	// For a list of supported Linux distributions, see [Linux on Azure-Endorsed
	// Distributions](https://docs.microsoft.com/azure/virtual-machines/linux/endorsed-distros).
	LinuxConfiguration *LinuxConfiguration_STATUS `json:"linuxConfiguration,omitempty"`

	// RequireGuestProvisionSignal: Optional property which must either be set to True or omitted.
	RequireGuestProvisionSignal *bool `json:"requireGuestProvisionSignal,omitempty"`

	// Secrets: Specifies set of certificates that should be installed onto the virtual machine. To install certificates on a
	// virtual machine it is recommended to use the [Azure Key Vault virtual machine extension for
	// Linux](https://docs.microsoft.com/azure/virtual-machines/extensions/key-vault-linux) or the [Azure Key Vault virtual
	// machine extension for Windows](https://docs.microsoft.com/azure/virtual-machines/extensions/key-vault-windows).
	Secrets []VaultSecretGroup_STATUS `json:"secrets,omitempty"`

	// WindowsConfiguration: Specifies Windows operating system settings on the virtual machine.
	WindowsConfiguration *WindowsConfiguration_STATUS `json:"windowsConfiguration,omitempty"`
}

var _ genruntime.FromARMConverter = &OSProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *OSProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.OSProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *OSProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.OSProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.OSProfile_STATUS, got %T", armInput)
	}

	// Set property "AdminUsername":
	if typedInput.AdminUsername != nil {
		adminUsername := *typedInput.AdminUsername
		profile.AdminUsername = &adminUsername
	}

	// Set property "AllowExtensionOperations":
	if typedInput.AllowExtensionOperations != nil {
		allowExtensionOperations := *typedInput.AllowExtensionOperations
		profile.AllowExtensionOperations = &allowExtensionOperations
	}

	// Set property "ComputerName":
	if typedInput.ComputerName != nil {
		computerName := *typedInput.ComputerName
		profile.ComputerName = &computerName
	}

	// Set property "CustomData":
	if typedInput.CustomData != nil {
		customData := *typedInput.CustomData
		profile.CustomData = &customData
	}

	// Set property "LinuxConfiguration":
	if typedInput.LinuxConfiguration != nil {
		var linuxConfiguration1 LinuxConfiguration_STATUS
		err := linuxConfiguration1.PopulateFromARM(owner, *typedInput.LinuxConfiguration)
		if err != nil {
			return err
		}
		linuxConfiguration := linuxConfiguration1
		profile.LinuxConfiguration = &linuxConfiguration
	}

	// Set property "RequireGuestProvisionSignal":
	if typedInput.RequireGuestProvisionSignal != nil {
		requireGuestProvisionSignal := *typedInput.RequireGuestProvisionSignal
		profile.RequireGuestProvisionSignal = &requireGuestProvisionSignal
	}

	// Set property "Secrets":
	for _, item := range typedInput.Secrets {
		var item1 VaultSecretGroup_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.Secrets = append(profile.Secrets, item1)
	}

	// Set property "WindowsConfiguration":
	if typedInput.WindowsConfiguration != nil {
		var windowsConfiguration1 WindowsConfiguration_STATUS
		err := windowsConfiguration1.PopulateFromARM(owner, *typedInput.WindowsConfiguration)
		if err != nil {
			return err
		}
		windowsConfiguration := windowsConfiguration1
		profile.WindowsConfiguration = &windowsConfiguration
	}

	// No error
	return nil
}

// AssignProperties_From_OSProfile_STATUS populates our OSProfile_STATUS from the provided source OSProfile_STATUS
func (profile *OSProfile_STATUS) AssignProperties_From_OSProfile_STATUS(source *storage.OSProfile_STATUS) error {

	// AdminUsername
	profile.AdminUsername = genruntime.ClonePointerToString(source.AdminUsername)

	// AllowExtensionOperations
	if source.AllowExtensionOperations != nil {
		allowExtensionOperation := *source.AllowExtensionOperations
		profile.AllowExtensionOperations = &allowExtensionOperation
	} else {
		profile.AllowExtensionOperations = nil
	}

	// ComputerName
	profile.ComputerName = genruntime.ClonePointerToString(source.ComputerName)

	// CustomData
	profile.CustomData = genruntime.ClonePointerToString(source.CustomData)

	// LinuxConfiguration
	if source.LinuxConfiguration != nil {
		var linuxConfiguration LinuxConfiguration_STATUS
		err := linuxConfiguration.AssignProperties_From_LinuxConfiguration_STATUS(source.LinuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_LinuxConfiguration_STATUS() to populate field LinuxConfiguration")
		}
		profile.LinuxConfiguration = &linuxConfiguration
	} else {
		profile.LinuxConfiguration = nil
	}

	// RequireGuestProvisionSignal
	if source.RequireGuestProvisionSignal != nil {
		requireGuestProvisionSignal := *source.RequireGuestProvisionSignal
		profile.RequireGuestProvisionSignal = &requireGuestProvisionSignal
	} else {
		profile.RequireGuestProvisionSignal = nil
	}

	// Secrets
	if source.Secrets != nil {
		secretList := make([]VaultSecretGroup_STATUS, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret VaultSecretGroup_STATUS
			err := secret.AssignProperties_From_VaultSecretGroup_STATUS(&secretItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VaultSecretGroup_STATUS() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		profile.Secrets = secretList
	} else {
		profile.Secrets = nil
	}

	// WindowsConfiguration
	if source.WindowsConfiguration != nil {
		var windowsConfiguration WindowsConfiguration_STATUS
		err := windowsConfiguration.AssignProperties_From_WindowsConfiguration_STATUS(source.WindowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WindowsConfiguration_STATUS() to populate field WindowsConfiguration")
		}
		profile.WindowsConfiguration = &windowsConfiguration
	} else {
		profile.WindowsConfiguration = nil
	}

	// No error
	return nil
}

// AssignProperties_To_OSProfile_STATUS populates the provided destination OSProfile_STATUS from our OSProfile_STATUS
func (profile *OSProfile_STATUS) AssignProperties_To_OSProfile_STATUS(destination *storage.OSProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminUsername
	destination.AdminUsername = genruntime.ClonePointerToString(profile.AdminUsername)

	// AllowExtensionOperations
	if profile.AllowExtensionOperations != nil {
		allowExtensionOperation := *profile.AllowExtensionOperations
		destination.AllowExtensionOperations = &allowExtensionOperation
	} else {
		destination.AllowExtensionOperations = nil
	}

	// ComputerName
	destination.ComputerName = genruntime.ClonePointerToString(profile.ComputerName)

	// CustomData
	destination.CustomData = genruntime.ClonePointerToString(profile.CustomData)

	// LinuxConfiguration
	if profile.LinuxConfiguration != nil {
		var linuxConfiguration storage.LinuxConfiguration_STATUS
		err := profile.LinuxConfiguration.AssignProperties_To_LinuxConfiguration_STATUS(&linuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_LinuxConfiguration_STATUS() to populate field LinuxConfiguration")
		}
		destination.LinuxConfiguration = &linuxConfiguration
	} else {
		destination.LinuxConfiguration = nil
	}

	// RequireGuestProvisionSignal
	if profile.RequireGuestProvisionSignal != nil {
		requireGuestProvisionSignal := *profile.RequireGuestProvisionSignal
		destination.RequireGuestProvisionSignal = &requireGuestProvisionSignal
	} else {
		destination.RequireGuestProvisionSignal = nil
	}

	// Secrets
	if profile.Secrets != nil {
		secretList := make([]storage.VaultSecretGroup_STATUS, len(profile.Secrets))
		for secretIndex, secretItem := range profile.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret storage.VaultSecretGroup_STATUS
			err := secretItem.AssignProperties_To_VaultSecretGroup_STATUS(&secret)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VaultSecretGroup_STATUS() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		destination.Secrets = secretList
	} else {
		destination.Secrets = nil
	}

	// WindowsConfiguration
	if profile.WindowsConfiguration != nil {
		var windowsConfiguration storage.WindowsConfiguration_STATUS
		err := profile.WindowsConfiguration.AssignProperties_To_WindowsConfiguration_STATUS(&windowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WindowsConfiguration_STATUS() to populate field WindowsConfiguration")
		}
		destination.WindowsConfiguration = &windowsConfiguration
	} else {
		destination.WindowsConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Specifies information about the marketplace image used to create the virtual machine. This element is only used for
// marketplace images. Before you can use a marketplace image from an API, you must enable the image for programmatic use.
// In the Azure portal, find the marketplace image that you want to use and then click Want to deploy programmatically,
// Get Started ->. Enter any required information and then click Save.
type Plan struct {
	// Name: The plan ID.
	Name *string `json:"name,omitempty"`

	// Product: Specifies the product of the image from the marketplace. This is the same value as Offer under the
	// imageReference element.
	Product *string `json:"product,omitempty"`

	// PromotionCode: The promotion code.
	PromotionCode *string `json:"promotionCode,omitempty"`

	// Publisher: The publisher ID.
	Publisher *string `json:"publisher,omitempty"`
}

var _ genruntime.ARMTransformer = &Plan{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (plan *Plan) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if plan == nil {
		return nil, nil
	}
	result := &arm.Plan{}

	// Set property "Name":
	if plan.Name != nil {
		name := *plan.Name
		result.Name = &name
	}

	// Set property "Product":
	if plan.Product != nil {
		product := *plan.Product
		result.Product = &product
	}

	// Set property "PromotionCode":
	if plan.PromotionCode != nil {
		promotionCode := *plan.PromotionCode
		result.PromotionCode = &promotionCode
	}

	// Set property "Publisher":
	if plan.Publisher != nil {
		publisher := *plan.Publisher
		result.Publisher = &publisher
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (plan *Plan) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Plan{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (plan *Plan) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Plan)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Plan, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		plan.Name = &name
	}

	// Set property "Product":
	if typedInput.Product != nil {
		product := *typedInput.Product
		plan.Product = &product
	}

	// Set property "PromotionCode":
	if typedInput.PromotionCode != nil {
		promotionCode := *typedInput.PromotionCode
		plan.PromotionCode = &promotionCode
	}

	// Set property "Publisher":
	if typedInput.Publisher != nil {
		publisher := *typedInput.Publisher
		plan.Publisher = &publisher
	}

	// No error
	return nil
}

// AssignProperties_From_Plan populates our Plan from the provided source Plan
func (plan *Plan) AssignProperties_From_Plan(source *storage.Plan) error {

	// Name
	plan.Name = genruntime.ClonePointerToString(source.Name)

	// Product
	plan.Product = genruntime.ClonePointerToString(source.Product)

	// PromotionCode
	plan.PromotionCode = genruntime.ClonePointerToString(source.PromotionCode)

	// Publisher
	plan.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// No error
	return nil
}

// AssignProperties_To_Plan populates the provided destination Plan from our Plan
func (plan *Plan) AssignProperties_To_Plan(destination *storage.Plan) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(plan.Name)

	// Product
	destination.Product = genruntime.ClonePointerToString(plan.Product)

	// PromotionCode
	destination.PromotionCode = genruntime.ClonePointerToString(plan.PromotionCode)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(plan.Publisher)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Plan_STATUS populates our Plan from the provided source Plan_STATUS
func (plan *Plan) Initialize_From_Plan_STATUS(source *Plan_STATUS) error {

	// Name
	plan.Name = genruntime.ClonePointerToString(source.Name)

	// Product
	plan.Product = genruntime.ClonePointerToString(source.Product)

	// PromotionCode
	plan.PromotionCode = genruntime.ClonePointerToString(source.PromotionCode)

	// Publisher
	plan.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// No error
	return nil
}

// Specifies information about the marketplace image used to create the virtual machine. This element is only used for
// marketplace images. Before you can use a marketplace image from an API, you must enable the image for programmatic use.
// In the Azure portal, find the marketplace image that you want to use and then click Want to deploy programmatically,
// Get Started ->. Enter any required information and then click Save.
type Plan_STATUS struct {
	// Name: The plan ID.
	Name *string `json:"name,omitempty"`

	// Product: Specifies the product of the image from the marketplace. This is the same value as Offer under the
	// imageReference element.
	Product *string `json:"product,omitempty"`

	// PromotionCode: The promotion code.
	PromotionCode *string `json:"promotionCode,omitempty"`

	// Publisher: The publisher ID.
	Publisher *string `json:"publisher,omitempty"`
}

var _ genruntime.FromARMConverter = &Plan_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (plan *Plan_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Plan_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (plan *Plan_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Plan_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Plan_STATUS, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		plan.Name = &name
	}

	// Set property "Product":
	if typedInput.Product != nil {
		product := *typedInput.Product
		plan.Product = &product
	}

	// Set property "PromotionCode":
	if typedInput.PromotionCode != nil {
		promotionCode := *typedInput.PromotionCode
		plan.PromotionCode = &promotionCode
	}

	// Set property "Publisher":
	if typedInput.Publisher != nil {
		publisher := *typedInput.Publisher
		plan.Publisher = &publisher
	}

	// No error
	return nil
}

// AssignProperties_From_Plan_STATUS populates our Plan_STATUS from the provided source Plan_STATUS
func (plan *Plan_STATUS) AssignProperties_From_Plan_STATUS(source *storage.Plan_STATUS) error {

	// Name
	plan.Name = genruntime.ClonePointerToString(source.Name)

	// Product
	plan.Product = genruntime.ClonePointerToString(source.Product)

	// PromotionCode
	plan.PromotionCode = genruntime.ClonePointerToString(source.PromotionCode)

	// Publisher
	plan.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// No error
	return nil
}

// AssignProperties_To_Plan_STATUS populates the provided destination Plan_STATUS from our Plan_STATUS
func (plan *Plan_STATUS) AssignProperties_To_Plan_STATUS(destination *storage.Plan_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(plan.Name)

	// Product
	destination.Product = genruntime.ClonePointerToString(plan.Product)

	// PromotionCode
	destination.PromotionCode = genruntime.ClonePointerToString(plan.PromotionCode)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(plan.Publisher)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Specifies the priority for a standalone virtual machine or the virtual machines in the scale set.
// 'Low' enum
// will be deprecated in the future, please use 'Spot' as the enum to deploy Azure Spot VM/VMSS.
// +kubebuilder:validation:Enum={"Low","Regular","Spot"}
type Priority string

const (
	Priority_Low     = Priority("Low")
	Priority_Regular = Priority("Regular")
	Priority_Spot    = Priority("Spot")
)

// Mapping from string to Priority
var priority_Values = map[string]Priority{
	"low":     Priority_Low,
	"regular": Priority_Regular,
	"spot":    Priority_Spot,
}

// Specifies the priority for a standalone virtual machine or the virtual machines in the scale set.
// 'Low' enum
// will be deprecated in the future, please use 'Spot' as the enum to deploy Azure Spot VM/VMSS.
type Priority_STATUS string

const (
	Priority_STATUS_Low     = Priority_STATUS("Low")
	Priority_STATUS_Regular = Priority_STATUS("Regular")
	Priority_STATUS_Spot    = Priority_STATUS("Spot")
)

// Mapping from string to Priority_STATUS
var priority_STATUS_Values = map[string]Priority_STATUS{
	"low":     Priority_STATUS_Low,
	"regular": Priority_STATUS_Regular,
	"spot":    Priority_STATUS_Spot,
}

type ScheduledEventsProfile struct {
	// TerminateNotificationProfile: Specifies Terminate Scheduled Event related configurations.
	TerminateNotificationProfile *TerminateNotificationProfile `json:"terminateNotificationProfile,omitempty"`
}

var _ genruntime.ARMTransformer = &ScheduledEventsProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ScheduledEventsProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ScheduledEventsProfile{}

	// Set property "TerminateNotificationProfile":
	if profile.TerminateNotificationProfile != nil {
		terminateNotificationProfile_ARM, err := (*profile.TerminateNotificationProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		terminateNotificationProfile := *terminateNotificationProfile_ARM.(*arm.TerminateNotificationProfile)
		result.TerminateNotificationProfile = &terminateNotificationProfile
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ScheduledEventsProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ScheduledEventsProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ScheduledEventsProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ScheduledEventsProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ScheduledEventsProfile, got %T", armInput)
	}

	// Set property "TerminateNotificationProfile":
	if typedInput.TerminateNotificationProfile != nil {
		var terminateNotificationProfile1 TerminateNotificationProfile
		err := terminateNotificationProfile1.PopulateFromARM(owner, *typedInput.TerminateNotificationProfile)
		if err != nil {
			return err
		}
		terminateNotificationProfile := terminateNotificationProfile1
		profile.TerminateNotificationProfile = &terminateNotificationProfile
	}

	// No error
	return nil
}

// AssignProperties_From_ScheduledEventsProfile populates our ScheduledEventsProfile from the provided source ScheduledEventsProfile
func (profile *ScheduledEventsProfile) AssignProperties_From_ScheduledEventsProfile(source *storage.ScheduledEventsProfile) error {

	// TerminateNotificationProfile
	if source.TerminateNotificationProfile != nil {
		var terminateNotificationProfile TerminateNotificationProfile
		err := terminateNotificationProfile.AssignProperties_From_TerminateNotificationProfile(source.TerminateNotificationProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_TerminateNotificationProfile() to populate field TerminateNotificationProfile")
		}
		profile.TerminateNotificationProfile = &terminateNotificationProfile
	} else {
		profile.TerminateNotificationProfile = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ScheduledEventsProfile populates the provided destination ScheduledEventsProfile from our ScheduledEventsProfile
func (profile *ScheduledEventsProfile) AssignProperties_To_ScheduledEventsProfile(destination *storage.ScheduledEventsProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// TerminateNotificationProfile
	if profile.TerminateNotificationProfile != nil {
		var terminateNotificationProfile storage.TerminateNotificationProfile
		err := profile.TerminateNotificationProfile.AssignProperties_To_TerminateNotificationProfile(&terminateNotificationProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_TerminateNotificationProfile() to populate field TerminateNotificationProfile")
		}
		destination.TerminateNotificationProfile = &terminateNotificationProfile
	} else {
		destination.TerminateNotificationProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ScheduledEventsProfile_STATUS populates our ScheduledEventsProfile from the provided source ScheduledEventsProfile_STATUS
func (profile *ScheduledEventsProfile) Initialize_From_ScheduledEventsProfile_STATUS(source *ScheduledEventsProfile_STATUS) error {

	// TerminateNotificationProfile
	if source.TerminateNotificationProfile != nil {
		var terminateNotificationProfile TerminateNotificationProfile
		err := terminateNotificationProfile.Initialize_From_TerminateNotificationProfile_STATUS(source.TerminateNotificationProfile)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_TerminateNotificationProfile_STATUS() to populate field TerminateNotificationProfile")
		}
		profile.TerminateNotificationProfile = &terminateNotificationProfile
	} else {
		profile.TerminateNotificationProfile = nil
	}

	// No error
	return nil
}

type ScheduledEventsProfile_STATUS struct {
	// TerminateNotificationProfile: Specifies Terminate Scheduled Event related configurations.
	TerminateNotificationProfile *TerminateNotificationProfile_STATUS `json:"terminateNotificationProfile,omitempty"`
}

var _ genruntime.FromARMConverter = &ScheduledEventsProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ScheduledEventsProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ScheduledEventsProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ScheduledEventsProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ScheduledEventsProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ScheduledEventsProfile_STATUS, got %T", armInput)
	}

	// Set property "TerminateNotificationProfile":
	if typedInput.TerminateNotificationProfile != nil {
		var terminateNotificationProfile1 TerminateNotificationProfile_STATUS
		err := terminateNotificationProfile1.PopulateFromARM(owner, *typedInput.TerminateNotificationProfile)
		if err != nil {
			return err
		}
		terminateNotificationProfile := terminateNotificationProfile1
		profile.TerminateNotificationProfile = &terminateNotificationProfile
	}

	// No error
	return nil
}

// AssignProperties_From_ScheduledEventsProfile_STATUS populates our ScheduledEventsProfile_STATUS from the provided source ScheduledEventsProfile_STATUS
func (profile *ScheduledEventsProfile_STATUS) AssignProperties_From_ScheduledEventsProfile_STATUS(source *storage.ScheduledEventsProfile_STATUS) error {

	// TerminateNotificationProfile
	if source.TerminateNotificationProfile != nil {
		var terminateNotificationProfile TerminateNotificationProfile_STATUS
		err := terminateNotificationProfile.AssignProperties_From_TerminateNotificationProfile_STATUS(source.TerminateNotificationProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_TerminateNotificationProfile_STATUS() to populate field TerminateNotificationProfile")
		}
		profile.TerminateNotificationProfile = &terminateNotificationProfile
	} else {
		profile.TerminateNotificationProfile = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ScheduledEventsProfile_STATUS populates the provided destination ScheduledEventsProfile_STATUS from our ScheduledEventsProfile_STATUS
func (profile *ScheduledEventsProfile_STATUS) AssignProperties_To_ScheduledEventsProfile_STATUS(destination *storage.ScheduledEventsProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// TerminateNotificationProfile
	if profile.TerminateNotificationProfile != nil {
		var terminateNotificationProfile storage.TerminateNotificationProfile_STATUS
		err := profile.TerminateNotificationProfile.AssignProperties_To_TerminateNotificationProfile_STATUS(&terminateNotificationProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_TerminateNotificationProfile_STATUS() to populate field TerminateNotificationProfile")
		}
		destination.TerminateNotificationProfile = &terminateNotificationProfile
	} else {
		destination.TerminateNotificationProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Specifies the Security profile settings for the virtual machine or virtual machine scale set.
type SecurityProfile struct {
	// EncryptionAtHost: This property can be used by user in the request to enable or disable the Host Encryption for the
	// virtual machine or virtual machine scale set. This will enable the encryption for all the disks including Resource/Temp
	// disk at host itself.
	// Default: The Encryption at host will be disabled unless this property is set to true for the resource.
	EncryptionAtHost *bool `json:"encryptionAtHost,omitempty"`

	// SecurityType: Specifies the SecurityType of the virtual machine. It has to be set to any specified value to enable
	// UefiSettings.
	// Default: UefiSettings will not be enabled unless this property is set.
	SecurityType *SecurityProfile_SecurityType `json:"securityType,omitempty"`

	// UefiSettings: Specifies the security settings like secure boot and vTPM used while creating the virtual machine.
	// Minimum api-version: 2020-12-01
	UefiSettings *UefiSettings `json:"uefiSettings,omitempty"`
}

var _ genruntime.ARMTransformer = &SecurityProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *SecurityProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.SecurityProfile{}

	// Set property "EncryptionAtHost":
	if profile.EncryptionAtHost != nil {
		encryptionAtHost := *profile.EncryptionAtHost
		result.EncryptionAtHost = &encryptionAtHost
	}

	// Set property "SecurityType":
	if profile.SecurityType != nil {
		var temp string
		temp = string(*profile.SecurityType)
		securityType := arm.SecurityProfile_SecurityType(temp)
		result.SecurityType = &securityType
	}

	// Set property "UefiSettings":
	if profile.UefiSettings != nil {
		uefiSettings_ARM, err := (*profile.UefiSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		uefiSettings := *uefiSettings_ARM.(*arm.UefiSettings)
		result.UefiSettings = &uefiSettings
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *SecurityProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SecurityProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *SecurityProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SecurityProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SecurityProfile, got %T", armInput)
	}

	// Set property "EncryptionAtHost":
	if typedInput.EncryptionAtHost != nil {
		encryptionAtHost := *typedInput.EncryptionAtHost
		profile.EncryptionAtHost = &encryptionAtHost
	}

	// Set property "SecurityType":
	if typedInput.SecurityType != nil {
		var temp string
		temp = string(*typedInput.SecurityType)
		securityType := SecurityProfile_SecurityType(temp)
		profile.SecurityType = &securityType
	}

	// Set property "UefiSettings":
	if typedInput.UefiSettings != nil {
		var uefiSettings1 UefiSettings
		err := uefiSettings1.PopulateFromARM(owner, *typedInput.UefiSettings)
		if err != nil {
			return err
		}
		uefiSettings := uefiSettings1
		profile.UefiSettings = &uefiSettings
	}

	// No error
	return nil
}

// AssignProperties_From_SecurityProfile populates our SecurityProfile from the provided source SecurityProfile
func (profile *SecurityProfile) AssignProperties_From_SecurityProfile(source *storage.SecurityProfile) error {

	// EncryptionAtHost
	if source.EncryptionAtHost != nil {
		encryptionAtHost := *source.EncryptionAtHost
		profile.EncryptionAtHost = &encryptionAtHost
	} else {
		profile.EncryptionAtHost = nil
	}

	// SecurityType
	if source.SecurityType != nil {
		securityType := *source.SecurityType
		securityTypeTemp := genruntime.ToEnum(securityType, securityProfile_SecurityType_Values)
		profile.SecurityType = &securityTypeTemp
	} else {
		profile.SecurityType = nil
	}

	// UefiSettings
	if source.UefiSettings != nil {
		var uefiSetting UefiSettings
		err := uefiSetting.AssignProperties_From_UefiSettings(source.UefiSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UefiSettings() to populate field UefiSettings")
		}
		profile.UefiSettings = &uefiSetting
	} else {
		profile.UefiSettings = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SecurityProfile populates the provided destination SecurityProfile from our SecurityProfile
func (profile *SecurityProfile) AssignProperties_To_SecurityProfile(destination *storage.SecurityProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EncryptionAtHost
	if profile.EncryptionAtHost != nil {
		encryptionAtHost := *profile.EncryptionAtHost
		destination.EncryptionAtHost = &encryptionAtHost
	} else {
		destination.EncryptionAtHost = nil
	}

	// SecurityType
	if profile.SecurityType != nil {
		securityType := string(*profile.SecurityType)
		destination.SecurityType = &securityType
	} else {
		destination.SecurityType = nil
	}

	// UefiSettings
	if profile.UefiSettings != nil {
		var uefiSetting storage.UefiSettings
		err := profile.UefiSettings.AssignProperties_To_UefiSettings(&uefiSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UefiSettings() to populate field UefiSettings")
		}
		destination.UefiSettings = &uefiSetting
	} else {
		destination.UefiSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_SecurityProfile_STATUS populates our SecurityProfile from the provided source SecurityProfile_STATUS
func (profile *SecurityProfile) Initialize_From_SecurityProfile_STATUS(source *SecurityProfile_STATUS) error {

	// EncryptionAtHost
	if source.EncryptionAtHost != nil {
		encryptionAtHost := *source.EncryptionAtHost
		profile.EncryptionAtHost = &encryptionAtHost
	} else {
		profile.EncryptionAtHost = nil
	}

	// SecurityType
	if source.SecurityType != nil {
		securityType := genruntime.ToEnum(string(*source.SecurityType), securityProfile_SecurityType_Values)
		profile.SecurityType = &securityType
	} else {
		profile.SecurityType = nil
	}

	// UefiSettings
	if source.UefiSettings != nil {
		var uefiSetting UefiSettings
		err := uefiSetting.Initialize_From_UefiSettings_STATUS(source.UefiSettings)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_UefiSettings_STATUS() to populate field UefiSettings")
		}
		profile.UefiSettings = &uefiSetting
	} else {
		profile.UefiSettings = nil
	}

	// No error
	return nil
}

// Specifies the Security profile settings for the virtual machine or virtual machine scale set.
type SecurityProfile_STATUS struct {
	// EncryptionAtHost: This property can be used by user in the request to enable or disable the Host Encryption for the
	// virtual machine or virtual machine scale set. This will enable the encryption for all the disks including Resource/Temp
	// disk at host itself.
	// Default: The Encryption at host will be disabled unless this property is set to true for the resource.
	EncryptionAtHost *bool `json:"encryptionAtHost,omitempty"`

	// SecurityType: Specifies the SecurityType of the virtual machine. It has to be set to any specified value to enable
	// UefiSettings.
	// Default: UefiSettings will not be enabled unless this property is set.
	SecurityType *SecurityProfile_SecurityType_STATUS `json:"securityType,omitempty"`

	// UefiSettings: Specifies the security settings like secure boot and vTPM used while creating the virtual machine.
	// Minimum api-version: 2020-12-01
	UefiSettings *UefiSettings_STATUS `json:"uefiSettings,omitempty"`
}

var _ genruntime.FromARMConverter = &SecurityProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *SecurityProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SecurityProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *SecurityProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SecurityProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SecurityProfile_STATUS, got %T", armInput)
	}

	// Set property "EncryptionAtHost":
	if typedInput.EncryptionAtHost != nil {
		encryptionAtHost := *typedInput.EncryptionAtHost
		profile.EncryptionAtHost = &encryptionAtHost
	}

	// Set property "SecurityType":
	if typedInput.SecurityType != nil {
		var temp string
		temp = string(*typedInput.SecurityType)
		securityType := SecurityProfile_SecurityType_STATUS(temp)
		profile.SecurityType = &securityType
	}

	// Set property "UefiSettings":
	if typedInput.UefiSettings != nil {
		var uefiSettings1 UefiSettings_STATUS
		err := uefiSettings1.PopulateFromARM(owner, *typedInput.UefiSettings)
		if err != nil {
			return err
		}
		uefiSettings := uefiSettings1
		profile.UefiSettings = &uefiSettings
	}

	// No error
	return nil
}

// AssignProperties_From_SecurityProfile_STATUS populates our SecurityProfile_STATUS from the provided source SecurityProfile_STATUS
func (profile *SecurityProfile_STATUS) AssignProperties_From_SecurityProfile_STATUS(source *storage.SecurityProfile_STATUS) error {

	// EncryptionAtHost
	if source.EncryptionAtHost != nil {
		encryptionAtHost := *source.EncryptionAtHost
		profile.EncryptionAtHost = &encryptionAtHost
	} else {
		profile.EncryptionAtHost = nil
	}

	// SecurityType
	if source.SecurityType != nil {
		securityType := *source.SecurityType
		securityTypeTemp := genruntime.ToEnum(securityType, securityProfile_SecurityType_STATUS_Values)
		profile.SecurityType = &securityTypeTemp
	} else {
		profile.SecurityType = nil
	}

	// UefiSettings
	if source.UefiSettings != nil {
		var uefiSetting UefiSettings_STATUS
		err := uefiSetting.AssignProperties_From_UefiSettings_STATUS(source.UefiSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UefiSettings_STATUS() to populate field UefiSettings")
		}
		profile.UefiSettings = &uefiSetting
	} else {
		profile.UefiSettings = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SecurityProfile_STATUS populates the provided destination SecurityProfile_STATUS from our SecurityProfile_STATUS
func (profile *SecurityProfile_STATUS) AssignProperties_To_SecurityProfile_STATUS(destination *storage.SecurityProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EncryptionAtHost
	if profile.EncryptionAtHost != nil {
		encryptionAtHost := *profile.EncryptionAtHost
		destination.EncryptionAtHost = &encryptionAtHost
	} else {
		destination.EncryptionAtHost = nil
	}

	// SecurityType
	if profile.SecurityType != nil {
		securityType := string(*profile.SecurityType)
		destination.SecurityType = &securityType
	} else {
		destination.SecurityType = nil
	}

	// UefiSettings
	if profile.UefiSettings != nil {
		var uefiSetting storage.UefiSettings_STATUS
		err := profile.UefiSettings.AssignProperties_To_UefiSettings_STATUS(&uefiSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UefiSettings_STATUS() to populate field UefiSettings")
		}
		destination.UefiSettings = &uefiSetting
	} else {
		destination.UefiSettings = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Specifies the storage settings for the virtual machine disks.
type StorageProfile struct {
	// DataDisks: Specifies the parameters that are used to add a data disk to a virtual machine.
	// For more information about disks, see [About disks and VHDs for Azure virtual
	// machines](https://docs.microsoft.com/azure/virtual-machines/managed-disks-overview).
	DataDisks []DataDisk `json:"dataDisks,omitempty"`

	// ImageReference: Specifies information about the image to use. You can specify information about platform images,
	// marketplace images, or virtual machine images. This element is required when you want to use a platform image,
	// marketplace image, or virtual machine image, but is not used in other creation operations.
	ImageReference *ImageReference `json:"imageReference,omitempty"`

	// OsDisk: Specifies information about the operating system disk used by the virtual machine.
	// For more information about disks, see [About disks and VHDs for Azure virtual
	// machines](https://docs.microsoft.com/azure/virtual-machines/managed-disks-overview).
	OsDisk *OSDisk `json:"osDisk,omitempty"`
}

var _ genruntime.ARMTransformer = &StorageProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *StorageProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.StorageProfile{}

	// Set property "DataDisks":
	for _, item := range profile.DataDisks {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.DataDisks = append(result.DataDisks, *item_ARM.(*arm.DataDisk))
	}

	// Set property "ImageReference":
	if profile.ImageReference != nil {
		imageReference_ARM, err := (*profile.ImageReference).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		imageReference := *imageReference_ARM.(*arm.ImageReference)
		result.ImageReference = &imageReference
	}

	// Set property "OsDisk":
	if profile.OsDisk != nil {
		osDisk_ARM, err := (*profile.OsDisk).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		osDisk := *osDisk_ARM.(*arm.OSDisk)
		result.OsDisk = &osDisk
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *StorageProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.StorageProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *StorageProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.StorageProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.StorageProfile, got %T", armInput)
	}

	// Set property "DataDisks":
	for _, item := range typedInput.DataDisks {
		var item1 DataDisk
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.DataDisks = append(profile.DataDisks, item1)
	}

	// Set property "ImageReference":
	if typedInput.ImageReference != nil {
		var imageReference1 ImageReference
		err := imageReference1.PopulateFromARM(owner, *typedInput.ImageReference)
		if err != nil {
			return err
		}
		imageReference := imageReference1
		profile.ImageReference = &imageReference
	}

	// Set property "OsDisk":
	if typedInput.OsDisk != nil {
		var osDisk1 OSDisk
		err := osDisk1.PopulateFromARM(owner, *typedInput.OsDisk)
		if err != nil {
			return err
		}
		osDisk := osDisk1
		profile.OsDisk = &osDisk
	}

	// No error
	return nil
}

// AssignProperties_From_StorageProfile populates our StorageProfile from the provided source StorageProfile
func (profile *StorageProfile) AssignProperties_From_StorageProfile(source *storage.StorageProfile) error {

	// DataDisks
	if source.DataDisks != nil {
		dataDiskList := make([]DataDisk, len(source.DataDisks))
		for dataDiskIndex, dataDiskItem := range source.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk DataDisk
			err := dataDisk.AssignProperties_From_DataDisk(&dataDiskItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DataDisk() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		profile.DataDisks = dataDiskList
	} else {
		profile.DataDisks = nil
	}

	// ImageReference
	if source.ImageReference != nil {
		var imageReference ImageReference
		err := imageReference.AssignProperties_From_ImageReference(source.ImageReference)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ImageReference() to populate field ImageReference")
		}
		profile.ImageReference = &imageReference
	} else {
		profile.ImageReference = nil
	}

	// OsDisk
	if source.OsDisk != nil {
		var osDisk OSDisk
		err := osDisk.AssignProperties_From_OSDisk(source.OsDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OSDisk() to populate field OsDisk")
		}
		profile.OsDisk = &osDisk
	} else {
		profile.OsDisk = nil
	}

	// No error
	return nil
}

// AssignProperties_To_StorageProfile populates the provided destination StorageProfile from our StorageProfile
func (profile *StorageProfile) AssignProperties_To_StorageProfile(destination *storage.StorageProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataDisks
	if profile.DataDisks != nil {
		dataDiskList := make([]storage.DataDisk, len(profile.DataDisks))
		for dataDiskIndex, dataDiskItem := range profile.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk storage.DataDisk
			err := dataDiskItem.AssignProperties_To_DataDisk(&dataDisk)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DataDisk() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		destination.DataDisks = dataDiskList
	} else {
		destination.DataDisks = nil
	}

	// ImageReference
	if profile.ImageReference != nil {
		var imageReference storage.ImageReference
		err := profile.ImageReference.AssignProperties_To_ImageReference(&imageReference)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ImageReference() to populate field ImageReference")
		}
		destination.ImageReference = &imageReference
	} else {
		destination.ImageReference = nil
	}

	// OsDisk
	if profile.OsDisk != nil {
		var osDisk storage.OSDisk
		err := profile.OsDisk.AssignProperties_To_OSDisk(&osDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OSDisk() to populate field OsDisk")
		}
		destination.OsDisk = &osDisk
	} else {
		destination.OsDisk = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_StorageProfile_STATUS populates our StorageProfile from the provided source StorageProfile_STATUS
func (profile *StorageProfile) Initialize_From_StorageProfile_STATUS(source *StorageProfile_STATUS) error {

	// DataDisks
	if source.DataDisks != nil {
		dataDiskList := make([]DataDisk, len(source.DataDisks))
		for dataDiskIndex, dataDiskItem := range source.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk DataDisk
			err := dataDisk.Initialize_From_DataDisk_STATUS(&dataDiskItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_DataDisk_STATUS() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		profile.DataDisks = dataDiskList
	} else {
		profile.DataDisks = nil
	}

	// ImageReference
	if source.ImageReference != nil {
		var imageReference ImageReference
		err := imageReference.Initialize_From_ImageReference_STATUS(source.ImageReference)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ImageReference_STATUS() to populate field ImageReference")
		}
		profile.ImageReference = &imageReference
	} else {
		profile.ImageReference = nil
	}

	// OsDisk
	if source.OsDisk != nil {
		var osDisk OSDisk
		err := osDisk.Initialize_From_OSDisk_STATUS(source.OsDisk)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_OSDisk_STATUS() to populate field OsDisk")
		}
		profile.OsDisk = &osDisk
	} else {
		profile.OsDisk = nil
	}

	// No error
	return nil
}

// Specifies the storage settings for the virtual machine disks.
type StorageProfile_STATUS struct {
	// DataDisks: Specifies the parameters that are used to add a data disk to a virtual machine.
	// For more information about disks, see [About disks and VHDs for Azure virtual
	// machines](https://docs.microsoft.com/azure/virtual-machines/managed-disks-overview).
	DataDisks []DataDisk_STATUS `json:"dataDisks,omitempty"`

	// ImageReference: Specifies information about the image to use. You can specify information about platform images,
	// marketplace images, or virtual machine images. This element is required when you want to use a platform image,
	// marketplace image, or virtual machine image, but is not used in other creation operations.
	ImageReference *ImageReference_STATUS `json:"imageReference,omitempty"`

	// OsDisk: Specifies information about the operating system disk used by the virtual machine.
	// For more information about disks, see [About disks and VHDs for Azure virtual
	// machines](https://docs.microsoft.com/azure/virtual-machines/managed-disks-overview).
	OsDisk *OSDisk_STATUS `json:"osDisk,omitempty"`
}

var _ genruntime.FromARMConverter = &StorageProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *StorageProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.StorageProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *StorageProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.StorageProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.StorageProfile_STATUS, got %T", armInput)
	}

	// Set property "DataDisks":
	for _, item := range typedInput.DataDisks {
		var item1 DataDisk_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.DataDisks = append(profile.DataDisks, item1)
	}

	// Set property "ImageReference":
	if typedInput.ImageReference != nil {
		var imageReference1 ImageReference_STATUS
		err := imageReference1.PopulateFromARM(owner, *typedInput.ImageReference)
		if err != nil {
			return err
		}
		imageReference := imageReference1
		profile.ImageReference = &imageReference
	}

	// Set property "OsDisk":
	if typedInput.OsDisk != nil {
		var osDisk1 OSDisk_STATUS
		err := osDisk1.PopulateFromARM(owner, *typedInput.OsDisk)
		if err != nil {
			return err
		}
		osDisk := osDisk1
		profile.OsDisk = &osDisk
	}

	// No error
	return nil
}

// AssignProperties_From_StorageProfile_STATUS populates our StorageProfile_STATUS from the provided source StorageProfile_STATUS
func (profile *StorageProfile_STATUS) AssignProperties_From_StorageProfile_STATUS(source *storage.StorageProfile_STATUS) error {

	// DataDisks
	if source.DataDisks != nil {
		dataDiskList := make([]DataDisk_STATUS, len(source.DataDisks))
		for dataDiskIndex, dataDiskItem := range source.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk DataDisk_STATUS
			err := dataDisk.AssignProperties_From_DataDisk_STATUS(&dataDiskItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DataDisk_STATUS() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		profile.DataDisks = dataDiskList
	} else {
		profile.DataDisks = nil
	}

	// ImageReference
	if source.ImageReference != nil {
		var imageReference ImageReference_STATUS
		err := imageReference.AssignProperties_From_ImageReference_STATUS(source.ImageReference)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ImageReference_STATUS() to populate field ImageReference")
		}
		profile.ImageReference = &imageReference
	} else {
		profile.ImageReference = nil
	}

	// OsDisk
	if source.OsDisk != nil {
		var osDisk OSDisk_STATUS
		err := osDisk.AssignProperties_From_OSDisk_STATUS(source.OsDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OSDisk_STATUS() to populate field OsDisk")
		}
		profile.OsDisk = &osDisk
	} else {
		profile.OsDisk = nil
	}

	// No error
	return nil
}

// AssignProperties_To_StorageProfile_STATUS populates the provided destination StorageProfile_STATUS from our StorageProfile_STATUS
func (profile *StorageProfile_STATUS) AssignProperties_To_StorageProfile_STATUS(destination *storage.StorageProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataDisks
	if profile.DataDisks != nil {
		dataDiskList := make([]storage.DataDisk_STATUS, len(profile.DataDisks))
		for dataDiskIndex, dataDiskItem := range profile.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk storage.DataDisk_STATUS
			err := dataDiskItem.AssignProperties_To_DataDisk_STATUS(&dataDisk)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DataDisk_STATUS() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		destination.DataDisks = dataDiskList
	} else {
		destination.DataDisks = nil
	}

	// ImageReference
	if profile.ImageReference != nil {
		var imageReference storage.ImageReference_STATUS
		err := profile.ImageReference.AssignProperties_To_ImageReference_STATUS(&imageReference)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ImageReference_STATUS() to populate field ImageReference")
		}
		destination.ImageReference = &imageReference
	} else {
		destination.ImageReference = nil
	}

	// OsDisk
	if profile.OsDisk != nil {
		var osDisk storage.OSDisk_STATUS
		err := profile.OsDisk.AssignProperties_To_OSDisk_STATUS(&osDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OSDisk_STATUS() to populate field OsDisk")
		}
		destination.OsDisk = &osDisk
	} else {
		destination.OsDisk = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes a Virtual Machine Extension.
type VirtualMachineExtension_STATUS struct {
	// AutoUpgradeMinorVersion: Indicates whether the extension should use a newer minor version if one is available at
	// deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this
	// property set to true.
	AutoUpgradeMinorVersion *bool `json:"autoUpgradeMinorVersion,omitempty"`

	// EnableAutomaticUpgrade: Indicates whether the extension should be automatically upgraded by the platform if there is a
	// newer version of the extension available.
	EnableAutomaticUpgrade *bool `json:"enableAutomaticUpgrade,omitempty"`

	// ForceUpdateTag: How the extension handler should be forced to update even if the extension configuration has not changed.
	ForceUpdateTag *string `json:"forceUpdateTag,omitempty"`

	// Id: Resource Id
	Id *string `json:"id,omitempty"`

	// InstanceView: The virtual machine extension instance view.
	InstanceView *VirtualMachineExtensionInstanceView_STATUS `json:"instanceView,omitempty"`

	// Location: Resource location
	Location *string `json:"location,omitempty"`

	// Name: Resource name
	Name *string `json:"name,omitempty"`

	// PropertiesType: Specifies the type of the extension; an example is "CustomScriptExtension".
	PropertiesType *string `json:"properties_type,omitempty"`

	// ProtectedSettingsFromKeyVault: The extensions protected settings that are passed by reference, and consumed from key
	// vault
	ProtectedSettingsFromKeyVault *KeyVaultSecretReference_STATUS `json:"protectedSettingsFromKeyVault,omitempty"`

	// ProvisioningState: The provisioning state, which only appears in the response.
	ProvisioningState *string `json:"provisioningState,omitempty"`

	// Publisher: The name of the extension handler publisher.
	Publisher *string `json:"publisher,omitempty"`

	// Settings: Json formatted public settings for the extension.
	Settings map[string]v1.JSON `json:"settings,omitempty"`

	// SuppressFailures: Indicates whether failures stemming from the extension will be suppressed (Operational failures such
	// as not connecting to the VM will not be suppressed regardless of this value). The default is false.
	SuppressFailures *bool `json:"suppressFailures,omitempty"`

	// Tags: Resource tags
	Tags map[string]string `json:"tags,omitempty"`

	// Type: Resource type
	Type *string `json:"type,omitempty"`

	// TypeHandlerVersion: Specifies the version of the script handler.
	TypeHandlerVersion *string `json:"typeHandlerVersion,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineExtension_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (extension *VirtualMachineExtension_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineExtension_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (extension *VirtualMachineExtension_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineExtension_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineExtension_STATUS, got %T", armInput)
	}

	// Set property "AutoUpgradeMinorVersion":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutoUpgradeMinorVersion != nil {
			autoUpgradeMinorVersion := *typedInput.Properties.AutoUpgradeMinorVersion
			extension.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
		}
	}

	// Set property "EnableAutomaticUpgrade":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableAutomaticUpgrade != nil {
			enableAutomaticUpgrade := *typedInput.Properties.EnableAutomaticUpgrade
			extension.EnableAutomaticUpgrade = &enableAutomaticUpgrade
		}
	}

	// Set property "ForceUpdateTag":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ForceUpdateTag != nil {
			forceUpdateTag := *typedInput.Properties.ForceUpdateTag
			extension.ForceUpdateTag = &forceUpdateTag
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		extension.Id = &id
	}

	// Set property "InstanceView":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.InstanceView != nil {
			var instanceView1 VirtualMachineExtensionInstanceView_STATUS
			err := instanceView1.PopulateFromARM(owner, *typedInput.Properties.InstanceView)
			if err != nil {
				return err
			}
			instanceView := instanceView1
			extension.InstanceView = &instanceView
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		extension.Location = &location
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		extension.Name = &name
	}

	// Set property "PropertiesType":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Type != nil {
			propertiesType := *typedInput.Properties.Type
			extension.PropertiesType = &propertiesType
		}
	}

	// Set property "ProtectedSettingsFromKeyVault":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProtectedSettingsFromKeyVault != nil {
			var protectedSettingsFromKeyVault1 KeyVaultSecretReference_STATUS
			err := protectedSettingsFromKeyVault1.PopulateFromARM(owner, *typedInput.Properties.ProtectedSettingsFromKeyVault)
			if err != nil {
				return err
			}
			protectedSettingsFromKeyVault := protectedSettingsFromKeyVault1
			extension.ProtectedSettingsFromKeyVault = &protectedSettingsFromKeyVault
		}
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			extension.ProvisioningState = &provisioningState
		}
	}

	// Set property "Publisher":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Publisher != nil {
			publisher := *typedInput.Properties.Publisher
			extension.Publisher = &publisher
		}
	}

	// Set property "Settings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Settings != nil {
			extension.Settings = make(map[string]v1.JSON, len(typedInput.Properties.Settings))
			for key, value := range typedInput.Properties.Settings {
				extension.Settings[key] = *value.DeepCopy()
			}
		}
	}

	// Set property "SuppressFailures":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SuppressFailures != nil {
			suppressFailures := *typedInput.Properties.SuppressFailures
			extension.SuppressFailures = &suppressFailures
		}
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		extension.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			extension.Tags[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		extension.Type = &typeVar
	}

	// Set property "TypeHandlerVersion":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TypeHandlerVersion != nil {
			typeHandlerVersion := *typedInput.Properties.TypeHandlerVersion
			extension.TypeHandlerVersion = &typeHandlerVersion
		}
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineExtension_STATUS populates our VirtualMachineExtension_STATUS from the provided source VirtualMachineExtension_STATUS
func (extension *VirtualMachineExtension_STATUS) AssignProperties_From_VirtualMachineExtension_STATUS(source *storage.VirtualMachineExtension_STATUS) error {

	// AutoUpgradeMinorVersion
	if source.AutoUpgradeMinorVersion != nil {
		autoUpgradeMinorVersion := *source.AutoUpgradeMinorVersion
		extension.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
	} else {
		extension.AutoUpgradeMinorVersion = nil
	}

	// EnableAutomaticUpgrade
	if source.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *source.EnableAutomaticUpgrade
		extension.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	} else {
		extension.EnableAutomaticUpgrade = nil
	}

	// ForceUpdateTag
	extension.ForceUpdateTag = genruntime.ClonePointerToString(source.ForceUpdateTag)

	// Id
	extension.Id = genruntime.ClonePointerToString(source.Id)

	// InstanceView
	if source.InstanceView != nil {
		var instanceView VirtualMachineExtensionInstanceView_STATUS
		err := instanceView.AssignProperties_From_VirtualMachineExtensionInstanceView_STATUS(source.InstanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineExtensionInstanceView_STATUS() to populate field InstanceView")
		}
		extension.InstanceView = &instanceView
	} else {
		extension.InstanceView = nil
	}

	// Location
	extension.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	extension.Name = genruntime.ClonePointerToString(source.Name)

	// PropertiesType
	extension.PropertiesType = genruntime.ClonePointerToString(source.PropertiesType)

	// ProtectedSettingsFromKeyVault
	if source.ProtectedSettingsFromKeyVault != nil {
		var protectedSettingsFromKeyVault KeyVaultSecretReference_STATUS
		err := protectedSettingsFromKeyVault.AssignProperties_From_KeyVaultSecretReference_STATUS(source.ProtectedSettingsFromKeyVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_KeyVaultSecretReference_STATUS() to populate field ProtectedSettingsFromKeyVault")
		}
		extension.ProtectedSettingsFromKeyVault = &protectedSettingsFromKeyVault
	} else {
		extension.ProtectedSettingsFromKeyVault = nil
	}

	// ProvisioningState
	extension.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// Publisher
	extension.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// Settings
	if source.Settings != nil {
		settingMap := make(map[string]v1.JSON, len(source.Settings))
		for settingKey, settingValue := range source.Settings {
			// Shadow the loop variable to avoid aliasing
			settingValue := settingValue
			settingMap[settingKey] = *settingValue.DeepCopy()
		}
		extension.Settings = settingMap
	} else {
		extension.Settings = nil
	}

	// SuppressFailures
	if source.SuppressFailures != nil {
		suppressFailure := *source.SuppressFailures
		extension.SuppressFailures = &suppressFailure
	} else {
		extension.SuppressFailures = nil
	}

	// Tags
	extension.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	extension.Type = genruntime.ClonePointerToString(source.Type)

	// TypeHandlerVersion
	extension.TypeHandlerVersion = genruntime.ClonePointerToString(source.TypeHandlerVersion)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineExtension_STATUS populates the provided destination VirtualMachineExtension_STATUS from our VirtualMachineExtension_STATUS
func (extension *VirtualMachineExtension_STATUS) AssignProperties_To_VirtualMachineExtension_STATUS(destination *storage.VirtualMachineExtension_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AutoUpgradeMinorVersion
	if extension.AutoUpgradeMinorVersion != nil {
		autoUpgradeMinorVersion := *extension.AutoUpgradeMinorVersion
		destination.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
	} else {
		destination.AutoUpgradeMinorVersion = nil
	}

	// EnableAutomaticUpgrade
	if extension.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *extension.EnableAutomaticUpgrade
		destination.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	} else {
		destination.EnableAutomaticUpgrade = nil
	}

	// ForceUpdateTag
	destination.ForceUpdateTag = genruntime.ClonePointerToString(extension.ForceUpdateTag)

	// Id
	destination.Id = genruntime.ClonePointerToString(extension.Id)

	// InstanceView
	if extension.InstanceView != nil {
		var instanceView storage.VirtualMachineExtensionInstanceView_STATUS
		err := extension.InstanceView.AssignProperties_To_VirtualMachineExtensionInstanceView_STATUS(&instanceView)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineExtensionInstanceView_STATUS() to populate field InstanceView")
		}
		destination.InstanceView = &instanceView
	} else {
		destination.InstanceView = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(extension.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(extension.Name)

	// PropertiesType
	destination.PropertiesType = genruntime.ClonePointerToString(extension.PropertiesType)

	// ProtectedSettingsFromKeyVault
	if extension.ProtectedSettingsFromKeyVault != nil {
		var protectedSettingsFromKeyVault storage.KeyVaultSecretReference_STATUS
		err := extension.ProtectedSettingsFromKeyVault.AssignProperties_To_KeyVaultSecretReference_STATUS(&protectedSettingsFromKeyVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_KeyVaultSecretReference_STATUS() to populate field ProtectedSettingsFromKeyVault")
		}
		destination.ProtectedSettingsFromKeyVault = &protectedSettingsFromKeyVault
	} else {
		destination.ProtectedSettingsFromKeyVault = nil
	}

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(extension.ProvisioningState)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(extension.Publisher)

	// Settings
	if extension.Settings != nil {
		settingMap := make(map[string]v1.JSON, len(extension.Settings))
		for settingKey, settingValue := range extension.Settings {
			// Shadow the loop variable to avoid aliasing
			settingValue := settingValue
			settingMap[settingKey] = *settingValue.DeepCopy()
		}
		destination.Settings = settingMap
	} else {
		destination.Settings = nil
	}

	// SuppressFailures
	if extension.SuppressFailures != nil {
		suppressFailure := *extension.SuppressFailures
		destination.SuppressFailures = &suppressFailure
	} else {
		destination.SuppressFailures = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(extension.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(extension.Type)

	// TypeHandlerVersion
	destination.TypeHandlerVersion = genruntime.ClonePointerToString(extension.TypeHandlerVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Identity for the virtual machine.
type VirtualMachineIdentity struct {
	// Type: The type of identity used for the virtual machine. The type 'SystemAssigned, UserAssigned' includes both an
	// implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the
	// virtual machine.
	Type *VirtualMachineIdentity_Type `json:"type,omitempty"`

	// UserAssignedIdentities: The list of user identities associated with the Virtual Machine. The user identity dictionary
	// key references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities []UserAssignedIdentityDetails `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *VirtualMachineIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &arm.VirtualMachineIdentity{}

	// Set property "Type":
	if identity.Type != nil {
		var temp string
		temp = string(*identity.Type)
		typeVar := arm.VirtualMachineIdentity_Type(temp)
		result.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	result.UserAssignedIdentities = make(map[string]arm.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
	for _, ident := range identity.UserAssignedIdentities {
		identARMID, err := resolved.ResolvedReferences.Lookup(ident.Reference)
		if err != nil {
			return nil, err
		}
		key := identARMID
		result.UserAssignedIdentities[key] = arm.UserAssignedIdentityDetails{}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *VirtualMachineIdentity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineIdentity{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *VirtualMachineIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineIdentity)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineIdentity, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := VirtualMachineIdentity_Type(temp)
		identity.Type = &typeVar
	}

	// no assignment for property "UserAssignedIdentities"

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineIdentity populates our VirtualMachineIdentity from the provided source VirtualMachineIdentity
func (identity *VirtualMachineIdentity) AssignProperties_From_VirtualMachineIdentity(source *storage.VirtualMachineIdentity) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, virtualMachineIdentity_Type_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, len(source.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity UserAssignedIdentityDetails
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentityDetails(&userAssignedIdentityItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineIdentity populates the provided destination VirtualMachineIdentity from our VirtualMachineIdentity
func (identity *VirtualMachineIdentity) AssignProperties_To_VirtualMachineIdentity(destination *storage.VirtualMachineIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]storage.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity storage.UserAssignedIdentityDetails
			err := userAssignedIdentityItem.AssignProperties_To_UserAssignedIdentityDetails(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityList
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualMachineIdentity_STATUS populates our VirtualMachineIdentity from the provided source VirtualMachineIdentity_STATUS
func (identity *VirtualMachineIdentity) Initialize_From_VirtualMachineIdentity_STATUS(source *VirtualMachineIdentity_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := genruntime.ToEnum(string(*source.Type), virtualMachineIdentity_Type_Values)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, 0, len(source.UserAssignedIdentities))
		for userAssignedIdentitiesKey := range source.UserAssignedIdentities {
			userAssignedIdentitiesRef := genruntime.CreateResourceReferenceFromARMID(userAssignedIdentitiesKey)
			userAssignedIdentityList = append(userAssignedIdentityList, UserAssignedIdentityDetails{Reference: userAssignedIdentitiesRef})
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// Identity for the virtual machine.
type VirtualMachineIdentity_STATUS struct {
	// PrincipalId: The principal id of virtual machine identity. This property will only be provided for a system assigned
	// identity.
	PrincipalId *string `json:"principalId,omitempty"`

	// TenantId: The tenant id associated with the virtual machine. This property will only be provided for a system assigned
	// identity.
	TenantId *string `json:"tenantId,omitempty"`

	// Type: The type of identity used for the virtual machine. The type 'SystemAssigned, UserAssigned' includes both an
	// implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the
	// virtual machine.
	Type *VirtualMachineIdentity_Type_STATUS `json:"type,omitempty"`

	// UserAssignedIdentities: The list of user identities associated with the Virtual Machine. The user identity dictionary
	// key references will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities map[string]VirtualMachineIdentity_UserAssignedIdentities_STATUS `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *VirtualMachineIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineIdentity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *VirtualMachineIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineIdentity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineIdentity_STATUS, got %T", armInput)
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		identity.TenantId = &tenantId
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := VirtualMachineIdentity_Type_STATUS(temp)
		identity.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	if typedInput.UserAssignedIdentities != nil {
		identity.UserAssignedIdentities = make(map[string]VirtualMachineIdentity_UserAssignedIdentities_STATUS, len(typedInput.UserAssignedIdentities))
		for key, value := range typedInput.UserAssignedIdentities {
			var value1 VirtualMachineIdentity_UserAssignedIdentities_STATUS
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			identity.UserAssignedIdentities[key] = value1
		}
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineIdentity_STATUS populates our VirtualMachineIdentity_STATUS from the provided source VirtualMachineIdentity_STATUS
func (identity *VirtualMachineIdentity_STATUS) AssignProperties_From_VirtualMachineIdentity_STATUS(source *storage.VirtualMachineIdentity_STATUS) error {

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, virtualMachineIdentity_Type_STATUS_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]VirtualMachineIdentity_UserAssignedIdentities_STATUS, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity VirtualMachineIdentity_UserAssignedIdentities_STATUS
			err := userAssignedIdentity.AssignProperties_From_VirtualMachineIdentity_UserAssignedIdentities_STATUS(&userAssignedIdentityValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineIdentity_UserAssignedIdentities_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineIdentity_STATUS populates the provided destination VirtualMachineIdentity_STATUS from our VirtualMachineIdentity_STATUS
func (identity *VirtualMachineIdentity_STATUS) AssignProperties_To_VirtualMachineIdentity_STATUS(destination *storage.VirtualMachineIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]storage.VirtualMachineIdentity_UserAssignedIdentities_STATUS, len(identity.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity storage.VirtualMachineIdentity_UserAssignedIdentities_STATUS
			err := userAssignedIdentityValue.AssignProperties_To_VirtualMachineIdentity_UserAssignedIdentities_STATUS(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineIdentity_UserAssignedIdentities_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The instance view of a virtual machine.
type VirtualMachineInstanceView_STATUS struct {
	// AssignedHost: Resource id of the dedicated host, on which the virtual machine is allocated through automatic placement,
	// when the virtual machine is associated with a dedicated host group that has automatic placement enabled.
	// Minimum api-version: 2020-06-01.
	AssignedHost *string `json:"assignedHost,omitempty"`

	// BootDiagnostics: Boot Diagnostics is a debugging feature which allows you to view Console Output and Screenshot to
	// diagnose VM status.
	// You can easily view the output of your console log.
	// Azure also enables you to see a screenshot of the VM from the hypervisor.
	BootDiagnostics *BootDiagnosticsInstanceView_STATUS `json:"bootDiagnostics,omitempty"`

	// ComputerName: The computer name assigned to the virtual machine.
	ComputerName *string `json:"computerName,omitempty"`

	// Disks: The virtual machine disk information.
	Disks []DiskInstanceView_STATUS `json:"disks,omitempty"`

	// Extensions: The extensions information.
	Extensions []VirtualMachineExtensionInstanceView_STATUS `json:"extensions,omitempty"`

	// HyperVGeneration: Specifies the HyperVGeneration Type associated with a resource
	HyperVGeneration *VirtualMachineInstanceView_HyperVGeneration_STATUS `json:"hyperVGeneration,omitempty"`

	// MaintenanceRedeployStatus: The Maintenance Operation status on the virtual machine.
	MaintenanceRedeployStatus *MaintenanceRedeployStatus_STATUS `json:"maintenanceRedeployStatus,omitempty"`

	// OsName: The Operating System running on the virtual machine.
	OsName *string `json:"osName,omitempty"`

	// OsVersion: The version of Operating System running on the virtual machine.
	OsVersion *string `json:"osVersion,omitempty"`

	// PatchStatus: [Preview Feature] The status of virtual machine patch operations.
	PatchStatus *VirtualMachinePatchStatus_STATUS `json:"patchStatus,omitempty"`

	// PlatformFaultDomain: Specifies the fault domain of the virtual machine.
	PlatformFaultDomain *int `json:"platformFaultDomain,omitempty"`

	// PlatformUpdateDomain: Specifies the update domain of the virtual machine.
	PlatformUpdateDomain *int `json:"platformUpdateDomain,omitempty"`

	// RdpThumbPrint: The Remote desktop certificate thumbprint.
	RdpThumbPrint *string `json:"rdpThumbPrint,omitempty"`

	// Statuses: The resource status information.
	Statuses []InstanceViewStatus_STATUS `json:"statuses,omitempty"`

	// VmAgent: The VM Agent running on the virtual machine.
	VmAgent *VirtualMachineAgentInstanceView_STATUS `json:"vmAgent,omitempty"`

	// VmHealth: The health status for the VM.
	VmHealth *VirtualMachineHealthStatus_STATUS `json:"vmHealth,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineInstanceView_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (view *VirtualMachineInstanceView_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineInstanceView_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (view *VirtualMachineInstanceView_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineInstanceView_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineInstanceView_STATUS, got %T", armInput)
	}

	// Set property "AssignedHost":
	if typedInput.AssignedHost != nil {
		assignedHost := *typedInput.AssignedHost
		view.AssignedHost = &assignedHost
	}

	// Set property "BootDiagnostics":
	if typedInput.BootDiagnostics != nil {
		var bootDiagnostics1 BootDiagnosticsInstanceView_STATUS
		err := bootDiagnostics1.PopulateFromARM(owner, *typedInput.BootDiagnostics)
		if err != nil {
			return err
		}
		bootDiagnostics := bootDiagnostics1
		view.BootDiagnostics = &bootDiagnostics
	}

	// Set property "ComputerName":
	if typedInput.ComputerName != nil {
		computerName := *typedInput.ComputerName
		view.ComputerName = &computerName
	}

	// Set property "Disks":
	for _, item := range typedInput.Disks {
		var item1 DiskInstanceView_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		view.Disks = append(view.Disks, item1)
	}

	// Set property "Extensions":
	for _, item := range typedInput.Extensions {
		var item1 VirtualMachineExtensionInstanceView_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		view.Extensions = append(view.Extensions, item1)
	}

	// Set property "HyperVGeneration":
	if typedInput.HyperVGeneration != nil {
		var temp string
		temp = string(*typedInput.HyperVGeneration)
		hyperVGeneration := VirtualMachineInstanceView_HyperVGeneration_STATUS(temp)
		view.HyperVGeneration = &hyperVGeneration
	}

	// Set property "MaintenanceRedeployStatus":
	if typedInput.MaintenanceRedeployStatus != nil {
		var maintenanceRedeployStatus1 MaintenanceRedeployStatus_STATUS
		err := maintenanceRedeployStatus1.PopulateFromARM(owner, *typedInput.MaintenanceRedeployStatus)
		if err != nil {
			return err
		}
		maintenanceRedeployStatus := maintenanceRedeployStatus1
		view.MaintenanceRedeployStatus = &maintenanceRedeployStatus
	}

	// Set property "OsName":
	if typedInput.OsName != nil {
		osName := *typedInput.OsName
		view.OsName = &osName
	}

	// Set property "OsVersion":
	if typedInput.OsVersion != nil {
		osVersion := *typedInput.OsVersion
		view.OsVersion = &osVersion
	}

	// Set property "PatchStatus":
	if typedInput.PatchStatus != nil {
		var patchStatus1 VirtualMachinePatchStatus_STATUS
		err := patchStatus1.PopulateFromARM(owner, *typedInput.PatchStatus)
		if err != nil {
			return err
		}
		patchStatus := patchStatus1
		view.PatchStatus = &patchStatus
	}

	// Set property "PlatformFaultDomain":
	if typedInput.PlatformFaultDomain != nil {
		platformFaultDomain := *typedInput.PlatformFaultDomain
		view.PlatformFaultDomain = &platformFaultDomain
	}

	// Set property "PlatformUpdateDomain":
	if typedInput.PlatformUpdateDomain != nil {
		platformUpdateDomain := *typedInput.PlatformUpdateDomain
		view.PlatformUpdateDomain = &platformUpdateDomain
	}

	// Set property "RdpThumbPrint":
	if typedInput.RdpThumbPrint != nil {
		rdpThumbPrint := *typedInput.RdpThumbPrint
		view.RdpThumbPrint = &rdpThumbPrint
	}

	// Set property "Statuses":
	for _, item := range typedInput.Statuses {
		var item1 InstanceViewStatus_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		view.Statuses = append(view.Statuses, item1)
	}

	// Set property "VmAgent":
	if typedInput.VmAgent != nil {
		var vmAgent1 VirtualMachineAgentInstanceView_STATUS
		err := vmAgent1.PopulateFromARM(owner, *typedInput.VmAgent)
		if err != nil {
			return err
		}
		vmAgent := vmAgent1
		view.VmAgent = &vmAgent
	}

	// Set property "VmHealth":
	if typedInput.VmHealth != nil {
		var vmHealth1 VirtualMachineHealthStatus_STATUS
		err := vmHealth1.PopulateFromARM(owner, *typedInput.VmHealth)
		if err != nil {
			return err
		}
		vmHealth := vmHealth1
		view.VmHealth = &vmHealth
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineInstanceView_STATUS populates our VirtualMachineInstanceView_STATUS from the provided source VirtualMachineInstanceView_STATUS
func (view *VirtualMachineInstanceView_STATUS) AssignProperties_From_VirtualMachineInstanceView_STATUS(source *storage.VirtualMachineInstanceView_STATUS) error {

	// AssignedHost
	view.AssignedHost = genruntime.ClonePointerToString(source.AssignedHost)

	// BootDiagnostics
	if source.BootDiagnostics != nil {
		var bootDiagnostic BootDiagnosticsInstanceView_STATUS
		err := bootDiagnostic.AssignProperties_From_BootDiagnosticsInstanceView_STATUS(source.BootDiagnostics)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BootDiagnosticsInstanceView_STATUS() to populate field BootDiagnostics")
		}
		view.BootDiagnostics = &bootDiagnostic
	} else {
		view.BootDiagnostics = nil
	}

	// ComputerName
	view.ComputerName = genruntime.ClonePointerToString(source.ComputerName)

	// Disks
	if source.Disks != nil {
		diskList := make([]DiskInstanceView_STATUS, len(source.Disks))
		for diskIndex, diskItem := range source.Disks {
			// Shadow the loop variable to avoid aliasing
			diskItem := diskItem
			var disk DiskInstanceView_STATUS
			err := disk.AssignProperties_From_DiskInstanceView_STATUS(&diskItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DiskInstanceView_STATUS() to populate field Disks")
			}
			diskList[diskIndex] = disk
		}
		view.Disks = diskList
	} else {
		view.Disks = nil
	}

	// Extensions
	if source.Extensions != nil {
		extensionList := make([]VirtualMachineExtensionInstanceView_STATUS, len(source.Extensions))
		for extensionIndex, extensionItem := range source.Extensions {
			// Shadow the loop variable to avoid aliasing
			extensionItem := extensionItem
			var extension VirtualMachineExtensionInstanceView_STATUS
			err := extension.AssignProperties_From_VirtualMachineExtensionInstanceView_STATUS(&extensionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineExtensionInstanceView_STATUS() to populate field Extensions")
			}
			extensionList[extensionIndex] = extension
		}
		view.Extensions = extensionList
	} else {
		view.Extensions = nil
	}

	// HyperVGeneration
	if source.HyperVGeneration != nil {
		hyperVGeneration := *source.HyperVGeneration
		hyperVGenerationTemp := genruntime.ToEnum(hyperVGeneration, virtualMachineInstanceView_HyperVGeneration_STATUS_Values)
		view.HyperVGeneration = &hyperVGenerationTemp
	} else {
		view.HyperVGeneration = nil
	}

	// MaintenanceRedeployStatus
	if source.MaintenanceRedeployStatus != nil {
		var maintenanceRedeployStatus MaintenanceRedeployStatus_STATUS
		err := maintenanceRedeployStatus.AssignProperties_From_MaintenanceRedeployStatus_STATUS(source.MaintenanceRedeployStatus)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_MaintenanceRedeployStatus_STATUS() to populate field MaintenanceRedeployStatus")
		}
		view.MaintenanceRedeployStatus = &maintenanceRedeployStatus
	} else {
		view.MaintenanceRedeployStatus = nil
	}

	// OsName
	view.OsName = genruntime.ClonePointerToString(source.OsName)

	// OsVersion
	view.OsVersion = genruntime.ClonePointerToString(source.OsVersion)

	// PatchStatus
	if source.PatchStatus != nil {
		var patchStatus VirtualMachinePatchStatus_STATUS
		err := patchStatus.AssignProperties_From_VirtualMachinePatchStatus_STATUS(source.PatchStatus)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachinePatchStatus_STATUS() to populate field PatchStatus")
		}
		view.PatchStatus = &patchStatus
	} else {
		view.PatchStatus = nil
	}

	// PlatformFaultDomain
	view.PlatformFaultDomain = genruntime.ClonePointerToInt(source.PlatformFaultDomain)

	// PlatformUpdateDomain
	view.PlatformUpdateDomain = genruntime.ClonePointerToInt(source.PlatformUpdateDomain)

	// RdpThumbPrint
	view.RdpThumbPrint = genruntime.ClonePointerToString(source.RdpThumbPrint)

	// Statuses
	if source.Statuses != nil {
		statusList := make([]InstanceViewStatus_STATUS, len(source.Statuses))
		for statusIndex, statusItem := range source.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status InstanceViewStatus_STATUS
			err := status.AssignProperties_From_InstanceViewStatus_STATUS(&statusItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_InstanceViewStatus_STATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		view.Statuses = statusList
	} else {
		view.Statuses = nil
	}

	// VmAgent
	if source.VmAgent != nil {
		var vmAgent VirtualMachineAgentInstanceView_STATUS
		err := vmAgent.AssignProperties_From_VirtualMachineAgentInstanceView_STATUS(source.VmAgent)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineAgentInstanceView_STATUS() to populate field VmAgent")
		}
		view.VmAgent = &vmAgent
	} else {
		view.VmAgent = nil
	}

	// VmHealth
	if source.VmHealth != nil {
		var vmHealth VirtualMachineHealthStatus_STATUS
		err := vmHealth.AssignProperties_From_VirtualMachineHealthStatus_STATUS(source.VmHealth)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineHealthStatus_STATUS() to populate field VmHealth")
		}
		view.VmHealth = &vmHealth
	} else {
		view.VmHealth = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineInstanceView_STATUS populates the provided destination VirtualMachineInstanceView_STATUS from our VirtualMachineInstanceView_STATUS
func (view *VirtualMachineInstanceView_STATUS) AssignProperties_To_VirtualMachineInstanceView_STATUS(destination *storage.VirtualMachineInstanceView_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AssignedHost
	destination.AssignedHost = genruntime.ClonePointerToString(view.AssignedHost)

	// BootDiagnostics
	if view.BootDiagnostics != nil {
		var bootDiagnostic storage.BootDiagnosticsInstanceView_STATUS
		err := view.BootDiagnostics.AssignProperties_To_BootDiagnosticsInstanceView_STATUS(&bootDiagnostic)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BootDiagnosticsInstanceView_STATUS() to populate field BootDiagnostics")
		}
		destination.BootDiagnostics = &bootDiagnostic
	} else {
		destination.BootDiagnostics = nil
	}

	// ComputerName
	destination.ComputerName = genruntime.ClonePointerToString(view.ComputerName)

	// Disks
	if view.Disks != nil {
		diskList := make([]storage.DiskInstanceView_STATUS, len(view.Disks))
		for diskIndex, diskItem := range view.Disks {
			// Shadow the loop variable to avoid aliasing
			diskItem := diskItem
			var disk storage.DiskInstanceView_STATUS
			err := diskItem.AssignProperties_To_DiskInstanceView_STATUS(&disk)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DiskInstanceView_STATUS() to populate field Disks")
			}
			diskList[diskIndex] = disk
		}
		destination.Disks = diskList
	} else {
		destination.Disks = nil
	}

	// Extensions
	if view.Extensions != nil {
		extensionList := make([]storage.VirtualMachineExtensionInstanceView_STATUS, len(view.Extensions))
		for extensionIndex, extensionItem := range view.Extensions {
			// Shadow the loop variable to avoid aliasing
			extensionItem := extensionItem
			var extension storage.VirtualMachineExtensionInstanceView_STATUS
			err := extensionItem.AssignProperties_To_VirtualMachineExtensionInstanceView_STATUS(&extension)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineExtensionInstanceView_STATUS() to populate field Extensions")
			}
			extensionList[extensionIndex] = extension
		}
		destination.Extensions = extensionList
	} else {
		destination.Extensions = nil
	}

	// HyperVGeneration
	if view.HyperVGeneration != nil {
		hyperVGeneration := string(*view.HyperVGeneration)
		destination.HyperVGeneration = &hyperVGeneration
	} else {
		destination.HyperVGeneration = nil
	}

	// MaintenanceRedeployStatus
	if view.MaintenanceRedeployStatus != nil {
		var maintenanceRedeployStatus storage.MaintenanceRedeployStatus_STATUS
		err := view.MaintenanceRedeployStatus.AssignProperties_To_MaintenanceRedeployStatus_STATUS(&maintenanceRedeployStatus)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_MaintenanceRedeployStatus_STATUS() to populate field MaintenanceRedeployStatus")
		}
		destination.MaintenanceRedeployStatus = &maintenanceRedeployStatus
	} else {
		destination.MaintenanceRedeployStatus = nil
	}

	// OsName
	destination.OsName = genruntime.ClonePointerToString(view.OsName)

	// OsVersion
	destination.OsVersion = genruntime.ClonePointerToString(view.OsVersion)

	// PatchStatus
	if view.PatchStatus != nil {
		var patchStatus storage.VirtualMachinePatchStatus_STATUS
		err := view.PatchStatus.AssignProperties_To_VirtualMachinePatchStatus_STATUS(&patchStatus)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachinePatchStatus_STATUS() to populate field PatchStatus")
		}
		destination.PatchStatus = &patchStatus
	} else {
		destination.PatchStatus = nil
	}

	// PlatformFaultDomain
	destination.PlatformFaultDomain = genruntime.ClonePointerToInt(view.PlatformFaultDomain)

	// PlatformUpdateDomain
	destination.PlatformUpdateDomain = genruntime.ClonePointerToInt(view.PlatformUpdateDomain)

	// RdpThumbPrint
	destination.RdpThumbPrint = genruntime.ClonePointerToString(view.RdpThumbPrint)

	// Statuses
	if view.Statuses != nil {
		statusList := make([]storage.InstanceViewStatus_STATUS, len(view.Statuses))
		for statusIndex, statusItem := range view.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status storage.InstanceViewStatus_STATUS
			err := statusItem.AssignProperties_To_InstanceViewStatus_STATUS(&status)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_InstanceViewStatus_STATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		destination.Statuses = statusList
	} else {
		destination.Statuses = nil
	}

	// VmAgent
	if view.VmAgent != nil {
		var vmAgent storage.VirtualMachineAgentInstanceView_STATUS
		err := view.VmAgent.AssignProperties_To_VirtualMachineAgentInstanceView_STATUS(&vmAgent)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineAgentInstanceView_STATUS() to populate field VmAgent")
		}
		destination.VmAgent = &vmAgent
	} else {
		destination.VmAgent = nil
	}

	// VmHealth
	if view.VmHealth != nil {
		var vmHealth storage.VirtualMachineHealthStatus_STATUS
		err := view.VmHealth.AssignProperties_To_VirtualMachineHealthStatus_STATUS(&vmHealth)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineHealthStatus_STATUS() to populate field VmHealth")
		}
		destination.VmHealth = &vmHealth
	} else {
		destination.VmHealth = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type VirtualMachineOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_VirtualMachineOperatorSpec populates our VirtualMachineOperatorSpec from the provided source VirtualMachineOperatorSpec
func (operator *VirtualMachineOperatorSpec) AssignProperties_From_VirtualMachineOperatorSpec(source *storage.VirtualMachineOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineOperatorSpec populates the provided destination VirtualMachineOperatorSpec from our VirtualMachineOperatorSpec
func (operator *VirtualMachineOperatorSpec) AssignProperties_To_VirtualMachineOperatorSpec(destination *storage.VirtualMachineOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Boot Diagnostics is a debugging feature which allows you to view Console Output and Screenshot to diagnose VM status.
// You can easily view the output of your console log.
// Azure also enables you to see a screenshot of the
// VM from the hypervisor.
type BootDiagnostics struct {
	// Enabled: Whether boot diagnostics should be enabled on the Virtual Machine.
	Enabled *bool `json:"enabled,omitempty"`

	// StorageUri: Uri of the storage account to use for placing the console output and screenshot.
	// If storageUri is not specified while enabling boot diagnostics, managed storage will be used.
	StorageUri *string `json:"storageUri,omitempty"`
}

var _ genruntime.ARMTransformer = &BootDiagnostics{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (diagnostics *BootDiagnostics) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if diagnostics == nil {
		return nil, nil
	}
	result := &arm.BootDiagnostics{}

	// Set property "Enabled":
	if diagnostics.Enabled != nil {
		enabled := *diagnostics.Enabled
		result.Enabled = &enabled
	}

	// Set property "StorageUri":
	if diagnostics.StorageUri != nil {
		storageUri := *diagnostics.StorageUri
		result.StorageUri = &storageUri
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (diagnostics *BootDiagnostics) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BootDiagnostics{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (diagnostics *BootDiagnostics) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BootDiagnostics)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BootDiagnostics, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		diagnostics.Enabled = &enabled
	}

	// Set property "StorageUri":
	if typedInput.StorageUri != nil {
		storageUri := *typedInput.StorageUri
		diagnostics.StorageUri = &storageUri
	}

	// No error
	return nil
}

// AssignProperties_From_BootDiagnostics populates our BootDiagnostics from the provided source BootDiagnostics
func (diagnostics *BootDiagnostics) AssignProperties_From_BootDiagnostics(source *storage.BootDiagnostics) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		diagnostics.Enabled = &enabled
	} else {
		diagnostics.Enabled = nil
	}

	// StorageUri
	diagnostics.StorageUri = genruntime.ClonePointerToString(source.StorageUri)

	// No error
	return nil
}

// AssignProperties_To_BootDiagnostics populates the provided destination BootDiagnostics from our BootDiagnostics
func (diagnostics *BootDiagnostics) AssignProperties_To_BootDiagnostics(destination *storage.BootDiagnostics) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if diagnostics.Enabled != nil {
		enabled := *diagnostics.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// StorageUri
	destination.StorageUri = genruntime.ClonePointerToString(diagnostics.StorageUri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_BootDiagnostics_STATUS populates our BootDiagnostics from the provided source BootDiagnostics_STATUS
func (diagnostics *BootDiagnostics) Initialize_From_BootDiagnostics_STATUS(source *BootDiagnostics_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		diagnostics.Enabled = &enabled
	} else {
		diagnostics.Enabled = nil
	}

	// StorageUri
	diagnostics.StorageUri = genruntime.ClonePointerToString(source.StorageUri)

	// No error
	return nil
}

// Boot Diagnostics is a debugging feature which allows you to view Console Output and Screenshot to diagnose VM status.
// You can easily view the output of your console log.
// Azure also enables you to see a screenshot of the
// VM from the hypervisor.
type BootDiagnostics_STATUS struct {
	// Enabled: Whether boot diagnostics should be enabled on the Virtual Machine.
	Enabled *bool `json:"enabled,omitempty"`

	// StorageUri: Uri of the storage account to use for placing the console output and screenshot.
	// If storageUri is not specified while enabling boot diagnostics, managed storage will be used.
	StorageUri *string `json:"storageUri,omitempty"`
}

var _ genruntime.FromARMConverter = &BootDiagnostics_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (diagnostics *BootDiagnostics_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BootDiagnostics_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (diagnostics *BootDiagnostics_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BootDiagnostics_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BootDiagnostics_STATUS, got %T", armInput)
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		diagnostics.Enabled = &enabled
	}

	// Set property "StorageUri":
	if typedInput.StorageUri != nil {
		storageUri := *typedInput.StorageUri
		diagnostics.StorageUri = &storageUri
	}

	// No error
	return nil
}

// AssignProperties_From_BootDiagnostics_STATUS populates our BootDiagnostics_STATUS from the provided source BootDiagnostics_STATUS
func (diagnostics *BootDiagnostics_STATUS) AssignProperties_From_BootDiagnostics_STATUS(source *storage.BootDiagnostics_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		diagnostics.Enabled = &enabled
	} else {
		diagnostics.Enabled = nil
	}

	// StorageUri
	diagnostics.StorageUri = genruntime.ClonePointerToString(source.StorageUri)

	// No error
	return nil
}

// AssignProperties_To_BootDiagnostics_STATUS populates the provided destination BootDiagnostics_STATUS from our BootDiagnostics_STATUS
func (diagnostics *BootDiagnostics_STATUS) AssignProperties_To_BootDiagnostics_STATUS(destination *storage.BootDiagnostics_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if diagnostics.Enabled != nil {
		enabled := *diagnostics.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// StorageUri
	destination.StorageUri = genruntime.ClonePointerToString(diagnostics.StorageUri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The instance view of a virtual machine boot diagnostics.
type BootDiagnosticsInstanceView_STATUS struct {
	// ConsoleScreenshotBlobUri: The console screenshot blob URI.
	// NOTE: This will not be set if boot diagnostics is currently enabled with managed storage.
	ConsoleScreenshotBlobUri *string `json:"consoleScreenshotBlobUri,omitempty"`

	// SerialConsoleLogBlobUri: The serial console log blob Uri.
	// NOTE: This will not be set if boot diagnostics is currently enabled with managed storage.
	SerialConsoleLogBlobUri *string `json:"serialConsoleLogBlobUri,omitempty"`

	// Status: The boot diagnostics status information for the VM.
	// NOTE: It will be set only if there are errors encountered in enabling boot diagnostics.
	Status *InstanceViewStatus_STATUS `json:"status,omitempty"`
}

var _ genruntime.FromARMConverter = &BootDiagnosticsInstanceView_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (view *BootDiagnosticsInstanceView_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BootDiagnosticsInstanceView_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (view *BootDiagnosticsInstanceView_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BootDiagnosticsInstanceView_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BootDiagnosticsInstanceView_STATUS, got %T", armInput)
	}

	// Set property "ConsoleScreenshotBlobUri":
	if typedInput.ConsoleScreenshotBlobUri != nil {
		consoleScreenshotBlobUri := *typedInput.ConsoleScreenshotBlobUri
		view.ConsoleScreenshotBlobUri = &consoleScreenshotBlobUri
	}

	// Set property "SerialConsoleLogBlobUri":
	if typedInput.SerialConsoleLogBlobUri != nil {
		serialConsoleLogBlobUri := *typedInput.SerialConsoleLogBlobUri
		view.SerialConsoleLogBlobUri = &serialConsoleLogBlobUri
	}

	// Set property "Status":
	if typedInput.Status != nil {
		var status1 InstanceViewStatus_STATUS
		err := status1.PopulateFromARM(owner, *typedInput.Status)
		if err != nil {
			return err
		}
		status := status1
		view.Status = &status
	}

	// No error
	return nil
}

// AssignProperties_From_BootDiagnosticsInstanceView_STATUS populates our BootDiagnosticsInstanceView_STATUS from the provided source BootDiagnosticsInstanceView_STATUS
func (view *BootDiagnosticsInstanceView_STATUS) AssignProperties_From_BootDiagnosticsInstanceView_STATUS(source *storage.BootDiagnosticsInstanceView_STATUS) error {

	// ConsoleScreenshotBlobUri
	view.ConsoleScreenshotBlobUri = genruntime.ClonePointerToString(source.ConsoleScreenshotBlobUri)

	// SerialConsoleLogBlobUri
	view.SerialConsoleLogBlobUri = genruntime.ClonePointerToString(source.SerialConsoleLogBlobUri)

	// Status
	if source.Status != nil {
		var status InstanceViewStatus_STATUS
		err := status.AssignProperties_From_InstanceViewStatus_STATUS(source.Status)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_InstanceViewStatus_STATUS() to populate field Status")
		}
		view.Status = &status
	} else {
		view.Status = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BootDiagnosticsInstanceView_STATUS populates the provided destination BootDiagnosticsInstanceView_STATUS from our BootDiagnosticsInstanceView_STATUS
func (view *BootDiagnosticsInstanceView_STATUS) AssignProperties_To_BootDiagnosticsInstanceView_STATUS(destination *storage.BootDiagnosticsInstanceView_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConsoleScreenshotBlobUri
	destination.ConsoleScreenshotBlobUri = genruntime.ClonePointerToString(view.ConsoleScreenshotBlobUri)

	// SerialConsoleLogBlobUri
	destination.SerialConsoleLogBlobUri = genruntime.ClonePointerToString(view.SerialConsoleLogBlobUri)

	// Status
	if view.Status != nil {
		var status storage.InstanceViewStatus_STATUS
		err := view.Status.AssignProperties_To_InstanceViewStatus_STATUS(&status)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_InstanceViewStatus_STATUS() to populate field Status")
		}
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes a data disk.
type DataDisk struct {
	// Caching: Specifies the caching requirements.
	// Possible values are:
	// None
	// ReadOnly
	// ReadWrite
	// Default: None for Standard storage. ReadOnly for Premium storage
	Caching *Caching `json:"caching,omitempty"`

	// +kubebuilder:validation:Required
	// CreateOption: Specifies how the virtual machine should be created.
	// Possible values are:
	// Attach \u2013 This value is used when you are using a specialized disk to create the virtual machine.
	// FromImage \u2013 This value is used when you are using an image to create the virtual machine. If you are using a
	// platform image, you also use the imageReference element described above. If you are using a marketplace image, you  also
	// use the plan element previously described.
	CreateOption *CreateOption `json:"createOption,omitempty"`

	// DeleteOption: Specifies whether data disk should be deleted or detached upon VM deletion.
	// Possible values:
	// Delete If this value is used, the data disk is deleted when VM is deleted.
	// Detach If this value is used, the data disk is retained after VM is deleted.
	// The default value is set to detach
	DeleteOption *DeleteOption `json:"deleteOption,omitempty"`

	// DetachOption: Specifies the detach behavior to be used while detaching a disk or which is already in the process of
	// detachment from the virtual machine. Supported values: ForceDetach.
	// detachOption: ForceDetach is applicable only for managed data disks. If a previous detachment attempt of the data disk
	// did not complete due to an unexpected failure from the virtual machine and the disk is still not released then use
	// force-detach as a last resort option to detach the disk forcibly from the VM. All writes might not have been flushed
	// when using this detach behavior.
	// This feature is still in preview mode and is not supported for VirtualMachineScaleSet. To force-detach a data disk
	// update toBeDetached to 'true' along with setting detachOption: 'ForceDetach'.
	DetachOption *DetachOption `json:"detachOption,omitempty"`

	// DiskSizeGB: Specifies the size of an empty data disk in gigabytes. This element can be used to overwrite the size of the
	// disk in a virtual machine image.
	// This value cannot be larger than 1023 GB
	DiskSizeGB *int `json:"diskSizeGB,omitempty"`

	// Image: The source user image virtual hard disk. The virtual hard disk will be copied before being attached to the
	// virtual machine. If SourceImage is provided, the destination virtual hard drive must not exist.
	Image *VirtualHardDisk `json:"image,omitempty"`

	// +kubebuilder:validation:Required
	// Lun: Specifies the logical unit number of the data disk. This value is used to identify data disks within the VM and
	// therefore must be unique for each data disk attached to a VM.
	Lun *int `json:"lun,omitempty"`

	// ManagedDisk: The managed disk parameters.
	ManagedDisk *ManagedDiskParameters `json:"managedDisk,omitempty"`

	// Name: The disk name.
	Name *string `json:"name,omitempty"`

	// ToBeDetached: Specifies whether the data disk is in process of detachment from the VirtualMachine/VirtualMachineScaleset
	ToBeDetached *bool `json:"toBeDetached,omitempty"`

	// Vhd: The virtual hard disk.
	Vhd *VirtualHardDisk `json:"vhd,omitempty"`

	// WriteAcceleratorEnabled: Specifies whether writeAccelerator should be enabled or disabled on the disk.
	WriteAcceleratorEnabled *bool `json:"writeAcceleratorEnabled,omitempty"`
}

var _ genruntime.ARMTransformer = &DataDisk{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (disk *DataDisk) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if disk == nil {
		return nil, nil
	}
	result := &arm.DataDisk{}

	// Set property "Caching":
	if disk.Caching != nil {
		var temp string
		temp = string(*disk.Caching)
		caching := arm.Caching(temp)
		result.Caching = &caching
	}

	// Set property "CreateOption":
	if disk.CreateOption != nil {
		var temp string
		temp = string(*disk.CreateOption)
		createOption := arm.CreateOption(temp)
		result.CreateOption = &createOption
	}

	// Set property "DeleteOption":
	if disk.DeleteOption != nil {
		var temp string
		temp = string(*disk.DeleteOption)
		deleteOption := arm.DeleteOption(temp)
		result.DeleteOption = &deleteOption
	}

	// Set property "DetachOption":
	if disk.DetachOption != nil {
		var temp string
		temp = string(*disk.DetachOption)
		detachOption := arm.DetachOption(temp)
		result.DetachOption = &detachOption
	}

	// Set property "DiskSizeGB":
	if disk.DiskSizeGB != nil {
		diskSizeGB := *disk.DiskSizeGB
		result.DiskSizeGB = &diskSizeGB
	}

	// Set property "Image":
	if disk.Image != nil {
		image_ARM, err := (*disk.Image).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		image := *image_ARM.(*arm.VirtualHardDisk)
		result.Image = &image
	}

	// Set property "Lun":
	if disk.Lun != nil {
		lun := *disk.Lun
		result.Lun = &lun
	}

	// Set property "ManagedDisk":
	if disk.ManagedDisk != nil {
		managedDisk_ARM, err := (*disk.ManagedDisk).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		managedDisk := *managedDisk_ARM.(*arm.ManagedDiskParameters)
		result.ManagedDisk = &managedDisk
	}

	// Set property "Name":
	if disk.Name != nil {
		name := *disk.Name
		result.Name = &name
	}

	// Set property "ToBeDetached":
	if disk.ToBeDetached != nil {
		toBeDetached := *disk.ToBeDetached
		result.ToBeDetached = &toBeDetached
	}

	// Set property "Vhd":
	if disk.Vhd != nil {
		vhd_ARM, err := (*disk.Vhd).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		vhd := *vhd_ARM.(*arm.VirtualHardDisk)
		result.Vhd = &vhd
	}

	// Set property "WriteAcceleratorEnabled":
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		result.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (disk *DataDisk) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DataDisk{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (disk *DataDisk) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DataDisk)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DataDisk, got %T", armInput)
	}

	// Set property "Caching":
	if typedInput.Caching != nil {
		var temp string
		temp = string(*typedInput.Caching)
		caching := Caching(temp)
		disk.Caching = &caching
	}

	// Set property "CreateOption":
	if typedInput.CreateOption != nil {
		var temp string
		temp = string(*typedInput.CreateOption)
		createOption := CreateOption(temp)
		disk.CreateOption = &createOption
	}

	// Set property "DeleteOption":
	if typedInput.DeleteOption != nil {
		var temp string
		temp = string(*typedInput.DeleteOption)
		deleteOption := DeleteOption(temp)
		disk.DeleteOption = &deleteOption
	}

	// Set property "DetachOption":
	if typedInput.DetachOption != nil {
		var temp string
		temp = string(*typedInput.DetachOption)
		detachOption := DetachOption(temp)
		disk.DetachOption = &detachOption
	}

	// Set property "DiskSizeGB":
	if typedInput.DiskSizeGB != nil {
		diskSizeGB := *typedInput.DiskSizeGB
		disk.DiskSizeGB = &diskSizeGB
	}

	// Set property "Image":
	if typedInput.Image != nil {
		var image1 VirtualHardDisk
		err := image1.PopulateFromARM(owner, *typedInput.Image)
		if err != nil {
			return err
		}
		image := image1
		disk.Image = &image
	}

	// Set property "Lun":
	if typedInput.Lun != nil {
		lun := *typedInput.Lun
		disk.Lun = &lun
	}

	// Set property "ManagedDisk":
	if typedInput.ManagedDisk != nil {
		var managedDisk1 ManagedDiskParameters
		err := managedDisk1.PopulateFromARM(owner, *typedInput.ManagedDisk)
		if err != nil {
			return err
		}
		managedDisk := managedDisk1
		disk.ManagedDisk = &managedDisk
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		disk.Name = &name
	}

	// Set property "ToBeDetached":
	if typedInput.ToBeDetached != nil {
		toBeDetached := *typedInput.ToBeDetached
		disk.ToBeDetached = &toBeDetached
	}

	// Set property "Vhd":
	if typedInput.Vhd != nil {
		var vhd1 VirtualHardDisk
		err := vhd1.PopulateFromARM(owner, *typedInput.Vhd)
		if err != nil {
			return err
		}
		vhd := vhd1
		disk.Vhd = &vhd
	}

	// Set property "WriteAcceleratorEnabled":
	if typedInput.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *typedInput.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}

	// No error
	return nil
}

// AssignProperties_From_DataDisk populates our DataDisk from the provided source DataDisk
func (disk *DataDisk) AssignProperties_From_DataDisk(source *storage.DataDisk) error {

	// Caching
	if source.Caching != nil {
		caching := *source.Caching
		cachingTemp := genruntime.ToEnum(caching, caching_Values)
		disk.Caching = &cachingTemp
	} else {
		disk.Caching = nil
	}

	// CreateOption
	if source.CreateOption != nil {
		createOption := *source.CreateOption
		createOptionTemp := genruntime.ToEnum(createOption, createOption_Values)
		disk.CreateOption = &createOptionTemp
	} else {
		disk.CreateOption = nil
	}

	// DeleteOption
	if source.DeleteOption != nil {
		deleteOption := *source.DeleteOption
		deleteOptionTemp := genruntime.ToEnum(deleteOption, deleteOption_Values)
		disk.DeleteOption = &deleteOptionTemp
	} else {
		disk.DeleteOption = nil
	}

	// DetachOption
	if source.DetachOption != nil {
		detachOption := *source.DetachOption
		detachOptionTemp := genruntime.ToEnum(detachOption, detachOption_Values)
		disk.DetachOption = &detachOptionTemp
	} else {
		disk.DetachOption = nil
	}

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// Image
	if source.Image != nil {
		var image VirtualHardDisk
		err := image.AssignProperties_From_VirtualHardDisk(source.Image)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualHardDisk() to populate field Image")
		}
		disk.Image = &image
	} else {
		disk.Image = nil
	}

	// Lun
	disk.Lun = genruntime.ClonePointerToInt(source.Lun)

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk ManagedDiskParameters
		err := managedDisk.AssignProperties_From_ManagedDiskParameters(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedDiskParameters() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// ToBeDetached
	if source.ToBeDetached != nil {
		toBeDetached := *source.ToBeDetached
		disk.ToBeDetached = &toBeDetached
	} else {
		disk.ToBeDetached = nil
	}

	// Vhd
	if source.Vhd != nil {
		var vhd VirtualHardDisk
		err := vhd.AssignProperties_From_VirtualHardDisk(source.Vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualHardDisk() to populate field Vhd")
		}
		disk.Vhd = &vhd
	} else {
		disk.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DataDisk populates the provided destination DataDisk from our DataDisk
func (disk *DataDisk) AssignProperties_To_DataDisk(destination *storage.DataDisk) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Caching
	if disk.Caching != nil {
		caching := string(*disk.Caching)
		destination.Caching = &caching
	} else {
		destination.Caching = nil
	}

	// CreateOption
	if disk.CreateOption != nil {
		createOption := string(*disk.CreateOption)
		destination.CreateOption = &createOption
	} else {
		destination.CreateOption = nil
	}

	// DeleteOption
	if disk.DeleteOption != nil {
		deleteOption := string(*disk.DeleteOption)
		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// DetachOption
	if disk.DetachOption != nil {
		detachOption := string(*disk.DetachOption)
		destination.DetachOption = &detachOption
	} else {
		destination.DetachOption = nil
	}

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// Image
	if disk.Image != nil {
		var image storage.VirtualHardDisk
		err := disk.Image.AssignProperties_To_VirtualHardDisk(&image)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualHardDisk() to populate field Image")
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// Lun
	destination.Lun = genruntime.ClonePointerToInt(disk.Lun)

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk storage.ManagedDiskParameters
		err := disk.ManagedDisk.AssignProperties_To_ManagedDiskParameters(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedDiskParameters() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// ToBeDetached
	if disk.ToBeDetached != nil {
		toBeDetached := *disk.ToBeDetached
		destination.ToBeDetached = &toBeDetached
	} else {
		destination.ToBeDetached = nil
	}

	// Vhd
	if disk.Vhd != nil {
		var vhd storage.VirtualHardDisk
		err := disk.Vhd.AssignProperties_To_VirtualHardDisk(&vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualHardDisk() to populate field Vhd")
		}
		destination.Vhd = &vhd
	} else {
		destination.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DataDisk_STATUS populates our DataDisk from the provided source DataDisk_STATUS
func (disk *DataDisk) Initialize_From_DataDisk_STATUS(source *DataDisk_STATUS) error {

	// Caching
	if source.Caching != nil {
		caching := genruntime.ToEnum(string(*source.Caching), caching_Values)
		disk.Caching = &caching
	} else {
		disk.Caching = nil
	}

	// CreateOption
	if source.CreateOption != nil {
		createOption := genruntime.ToEnum(string(*source.CreateOption), createOption_Values)
		disk.CreateOption = &createOption
	} else {
		disk.CreateOption = nil
	}

	// DeleteOption
	if source.DeleteOption != nil {
		deleteOption := genruntime.ToEnum(string(*source.DeleteOption), deleteOption_Values)
		disk.DeleteOption = &deleteOption
	} else {
		disk.DeleteOption = nil
	}

	// DetachOption
	if source.DetachOption != nil {
		detachOption := genruntime.ToEnum(string(*source.DetachOption), detachOption_Values)
		disk.DetachOption = &detachOption
	} else {
		disk.DetachOption = nil
	}

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// Image
	if source.Image != nil {
		var image VirtualHardDisk
		err := image.Initialize_From_VirtualHardDisk_STATUS(source.Image)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_VirtualHardDisk_STATUS() to populate field Image")
		}
		disk.Image = &image
	} else {
		disk.Image = nil
	}

	// Lun
	disk.Lun = genruntime.ClonePointerToInt(source.Lun)

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk ManagedDiskParameters
		err := managedDisk.Initialize_From_ManagedDiskParameters_STATUS(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ManagedDiskParameters_STATUS() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// ToBeDetached
	if source.ToBeDetached != nil {
		toBeDetached := *source.ToBeDetached
		disk.ToBeDetached = &toBeDetached
	} else {
		disk.ToBeDetached = nil
	}

	// Vhd
	if source.Vhd != nil {
		var vhd VirtualHardDisk
		err := vhd.Initialize_From_VirtualHardDisk_STATUS(source.Vhd)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_VirtualHardDisk_STATUS() to populate field Vhd")
		}
		disk.Vhd = &vhd
	} else {
		disk.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// No error
	return nil
}

// Describes a data disk.
type DataDisk_STATUS struct {
	// Caching: Specifies the caching requirements.
	// Possible values are:
	// None
	// ReadOnly
	// ReadWrite
	// Default: None for Standard storage. ReadOnly for Premium storage
	Caching *Caching_STATUS `json:"caching,omitempty"`

	// CreateOption: Specifies how the virtual machine should be created.
	// Possible values are:
	// Attach \u2013 This value is used when you are using a specialized disk to create the virtual machine.
	// FromImage \u2013 This value is used when you are using an image to create the virtual machine. If you are using a
	// platform image, you also use the imageReference element described above. If you are using a marketplace image, you  also
	// use the plan element previously described.
	CreateOption *CreateOption_STATUS `json:"createOption,omitempty"`

	// DeleteOption: Specifies whether data disk should be deleted or detached upon VM deletion.
	// Possible values:
	// Delete If this value is used, the data disk is deleted when VM is deleted.
	// Detach If this value is used, the data disk is retained after VM is deleted.
	// The default value is set to detach
	DeleteOption *DeleteOption_STATUS `json:"deleteOption,omitempty"`

	// DetachOption: Specifies the detach behavior to be used while detaching a disk or which is already in the process of
	// detachment from the virtual machine. Supported values: ForceDetach.
	// detachOption: ForceDetach is applicable only for managed data disks. If a previous detachment attempt of the data disk
	// did not complete due to an unexpected failure from the virtual machine and the disk is still not released then use
	// force-detach as a last resort option to detach the disk forcibly from the VM. All writes might not have been flushed
	// when using this detach behavior.
	// This feature is still in preview mode and is not supported for VirtualMachineScaleSet. To force-detach a data disk
	// update toBeDetached to 'true' along with setting detachOption: 'ForceDetach'.
	DetachOption *DetachOption_STATUS `json:"detachOption,omitempty"`

	// DiskIOPSReadWrite: Specifies the Read-Write IOPS for the managed disk when StorageAccountType is UltraSSD_LRS. Returned
	// only for VirtualMachine ScaleSet VM disks. Can be updated only via updates to the VirtualMachine Scale Set.
	DiskIOPSReadWrite *int `json:"diskIOPSReadWrite,omitempty"`

	// DiskMBpsReadWrite: Specifies the bandwidth in MB per second for the managed disk when StorageAccountType is
	// UltraSSD_LRS. Returned only for VirtualMachine ScaleSet VM disks. Can be updated only via updates to the VirtualMachine
	// Scale Set.
	DiskMBpsReadWrite *int `json:"diskMBpsReadWrite,omitempty"`

	// DiskSizeGB: Specifies the size of an empty data disk in gigabytes. This element can be used to overwrite the size of the
	// disk in a virtual machine image.
	// This value cannot be larger than 1023 GB
	DiskSizeGB *int `json:"diskSizeGB,omitempty"`

	// Image: The source user image virtual hard disk. The virtual hard disk will be copied before being attached to the
	// virtual machine. If SourceImage is provided, the destination virtual hard drive must not exist.
	Image *VirtualHardDisk_STATUS `json:"image,omitempty"`

	// Lun: Specifies the logical unit number of the data disk. This value is used to identify data disks within the VM and
	// therefore must be unique for each data disk attached to a VM.
	Lun *int `json:"lun,omitempty"`

	// ManagedDisk: The managed disk parameters.
	ManagedDisk *ManagedDiskParameters_STATUS `json:"managedDisk,omitempty"`

	// Name: The disk name.
	Name *string `json:"name,omitempty"`

	// ToBeDetached: Specifies whether the data disk is in process of detachment from the VirtualMachine/VirtualMachineScaleset
	ToBeDetached *bool `json:"toBeDetached,omitempty"`

	// Vhd: The virtual hard disk.
	Vhd *VirtualHardDisk_STATUS `json:"vhd,omitempty"`

	// WriteAcceleratorEnabled: Specifies whether writeAccelerator should be enabled or disabled on the disk.
	WriteAcceleratorEnabled *bool `json:"writeAcceleratorEnabled,omitempty"`
}

var _ genruntime.FromARMConverter = &DataDisk_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (disk *DataDisk_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DataDisk_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (disk *DataDisk_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DataDisk_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DataDisk_STATUS, got %T", armInput)
	}

	// Set property "Caching":
	if typedInput.Caching != nil {
		var temp string
		temp = string(*typedInput.Caching)
		caching := Caching_STATUS(temp)
		disk.Caching = &caching
	}

	// Set property "CreateOption":
	if typedInput.CreateOption != nil {
		var temp string
		temp = string(*typedInput.CreateOption)
		createOption := CreateOption_STATUS(temp)
		disk.CreateOption = &createOption
	}

	// Set property "DeleteOption":
	if typedInput.DeleteOption != nil {
		var temp string
		temp = string(*typedInput.DeleteOption)
		deleteOption := DeleteOption_STATUS(temp)
		disk.DeleteOption = &deleteOption
	}

	// Set property "DetachOption":
	if typedInput.DetachOption != nil {
		var temp string
		temp = string(*typedInput.DetachOption)
		detachOption := DetachOption_STATUS(temp)
		disk.DetachOption = &detachOption
	}

	// Set property "DiskIOPSReadWrite":
	if typedInput.DiskIOPSReadWrite != nil {
		diskIOPSReadWrite := *typedInput.DiskIOPSReadWrite
		disk.DiskIOPSReadWrite = &diskIOPSReadWrite
	}

	// Set property "DiskMBpsReadWrite":
	if typedInput.DiskMBpsReadWrite != nil {
		diskMBpsReadWrite := *typedInput.DiskMBpsReadWrite
		disk.DiskMBpsReadWrite = &diskMBpsReadWrite
	}

	// Set property "DiskSizeGB":
	if typedInput.DiskSizeGB != nil {
		diskSizeGB := *typedInput.DiskSizeGB
		disk.DiskSizeGB = &diskSizeGB
	}

	// Set property "Image":
	if typedInput.Image != nil {
		var image1 VirtualHardDisk_STATUS
		err := image1.PopulateFromARM(owner, *typedInput.Image)
		if err != nil {
			return err
		}
		image := image1
		disk.Image = &image
	}

	// Set property "Lun":
	if typedInput.Lun != nil {
		lun := *typedInput.Lun
		disk.Lun = &lun
	}

	// Set property "ManagedDisk":
	if typedInput.ManagedDisk != nil {
		var managedDisk1 ManagedDiskParameters_STATUS
		err := managedDisk1.PopulateFromARM(owner, *typedInput.ManagedDisk)
		if err != nil {
			return err
		}
		managedDisk := managedDisk1
		disk.ManagedDisk = &managedDisk
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		disk.Name = &name
	}

	// Set property "ToBeDetached":
	if typedInput.ToBeDetached != nil {
		toBeDetached := *typedInput.ToBeDetached
		disk.ToBeDetached = &toBeDetached
	}

	// Set property "Vhd":
	if typedInput.Vhd != nil {
		var vhd1 VirtualHardDisk_STATUS
		err := vhd1.PopulateFromARM(owner, *typedInput.Vhd)
		if err != nil {
			return err
		}
		vhd := vhd1
		disk.Vhd = &vhd
	}

	// Set property "WriteAcceleratorEnabled":
	if typedInput.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *typedInput.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}

	// No error
	return nil
}

// AssignProperties_From_DataDisk_STATUS populates our DataDisk_STATUS from the provided source DataDisk_STATUS
func (disk *DataDisk_STATUS) AssignProperties_From_DataDisk_STATUS(source *storage.DataDisk_STATUS) error {

	// Caching
	if source.Caching != nil {
		caching := *source.Caching
		cachingTemp := genruntime.ToEnum(caching, caching_STATUS_Values)
		disk.Caching = &cachingTemp
	} else {
		disk.Caching = nil
	}

	// CreateOption
	if source.CreateOption != nil {
		createOption := *source.CreateOption
		createOptionTemp := genruntime.ToEnum(createOption, createOption_STATUS_Values)
		disk.CreateOption = &createOptionTemp
	} else {
		disk.CreateOption = nil
	}

	// DeleteOption
	if source.DeleteOption != nil {
		deleteOption := *source.DeleteOption
		deleteOptionTemp := genruntime.ToEnum(deleteOption, deleteOption_STATUS_Values)
		disk.DeleteOption = &deleteOptionTemp
	} else {
		disk.DeleteOption = nil
	}

	// DetachOption
	if source.DetachOption != nil {
		detachOption := *source.DetachOption
		detachOptionTemp := genruntime.ToEnum(detachOption, detachOption_STATUS_Values)
		disk.DetachOption = &detachOptionTemp
	} else {
		disk.DetachOption = nil
	}

	// DiskIOPSReadWrite
	disk.DiskIOPSReadWrite = genruntime.ClonePointerToInt(source.DiskIOPSReadWrite)

	// DiskMBpsReadWrite
	disk.DiskMBpsReadWrite = genruntime.ClonePointerToInt(source.DiskMBpsReadWrite)

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// Image
	if source.Image != nil {
		var image VirtualHardDisk_STATUS
		err := image.AssignProperties_From_VirtualHardDisk_STATUS(source.Image)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualHardDisk_STATUS() to populate field Image")
		}
		disk.Image = &image
	} else {
		disk.Image = nil
	}

	// Lun
	disk.Lun = genruntime.ClonePointerToInt(source.Lun)

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk ManagedDiskParameters_STATUS
		err := managedDisk.AssignProperties_From_ManagedDiskParameters_STATUS(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedDiskParameters_STATUS() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// ToBeDetached
	if source.ToBeDetached != nil {
		toBeDetached := *source.ToBeDetached
		disk.ToBeDetached = &toBeDetached
	} else {
		disk.ToBeDetached = nil
	}

	// Vhd
	if source.Vhd != nil {
		var vhd VirtualHardDisk_STATUS
		err := vhd.AssignProperties_From_VirtualHardDisk_STATUS(source.Vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualHardDisk_STATUS() to populate field Vhd")
		}
		disk.Vhd = &vhd
	} else {
		disk.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DataDisk_STATUS populates the provided destination DataDisk_STATUS from our DataDisk_STATUS
func (disk *DataDisk_STATUS) AssignProperties_To_DataDisk_STATUS(destination *storage.DataDisk_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Caching
	if disk.Caching != nil {
		caching := string(*disk.Caching)
		destination.Caching = &caching
	} else {
		destination.Caching = nil
	}

	// CreateOption
	if disk.CreateOption != nil {
		createOption := string(*disk.CreateOption)
		destination.CreateOption = &createOption
	} else {
		destination.CreateOption = nil
	}

	// DeleteOption
	if disk.DeleteOption != nil {
		deleteOption := string(*disk.DeleteOption)
		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// DetachOption
	if disk.DetachOption != nil {
		detachOption := string(*disk.DetachOption)
		destination.DetachOption = &detachOption
	} else {
		destination.DetachOption = nil
	}

	// DiskIOPSReadWrite
	destination.DiskIOPSReadWrite = genruntime.ClonePointerToInt(disk.DiskIOPSReadWrite)

	// DiskMBpsReadWrite
	destination.DiskMBpsReadWrite = genruntime.ClonePointerToInt(disk.DiskMBpsReadWrite)

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// Image
	if disk.Image != nil {
		var image storage.VirtualHardDisk_STATUS
		err := disk.Image.AssignProperties_To_VirtualHardDisk_STATUS(&image)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualHardDisk_STATUS() to populate field Image")
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// Lun
	destination.Lun = genruntime.ClonePointerToInt(disk.Lun)

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk storage.ManagedDiskParameters_STATUS
		err := disk.ManagedDisk.AssignProperties_To_ManagedDiskParameters_STATUS(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedDiskParameters_STATUS() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// ToBeDetached
	if disk.ToBeDetached != nil {
		toBeDetached := *disk.ToBeDetached
		destination.ToBeDetached = &toBeDetached
	} else {
		destination.ToBeDetached = nil
	}

	// Vhd
	if disk.Vhd != nil {
		var vhd storage.VirtualHardDisk_STATUS
		err := disk.Vhd.AssignProperties_To_VirtualHardDisk_STATUS(&vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualHardDisk_STATUS() to populate field Vhd")
		}
		destination.Vhd = &vhd
	} else {
		destination.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The instance view of the disk.
type DiskInstanceView_STATUS struct {
	// EncryptionSettings: Specifies the encryption settings for the OS Disk.
	// Minimum api-version: 2015-06-15
	EncryptionSettings []DiskEncryptionSettings_STATUS `json:"encryptionSettings,omitempty"`

	// Name: The disk name.
	Name *string `json:"name,omitempty"`

	// Statuses: The resource status information.
	Statuses []InstanceViewStatus_STATUS `json:"statuses,omitempty"`
}

var _ genruntime.FromARMConverter = &DiskInstanceView_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (view *DiskInstanceView_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DiskInstanceView_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (view *DiskInstanceView_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DiskInstanceView_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DiskInstanceView_STATUS, got %T", armInput)
	}

	// Set property "EncryptionSettings":
	for _, item := range typedInput.EncryptionSettings {
		var item1 DiskEncryptionSettings_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		view.EncryptionSettings = append(view.EncryptionSettings, item1)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		view.Name = &name
	}

	// Set property "Statuses":
	for _, item := range typedInput.Statuses {
		var item1 InstanceViewStatus_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		view.Statuses = append(view.Statuses, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_DiskInstanceView_STATUS populates our DiskInstanceView_STATUS from the provided source DiskInstanceView_STATUS
func (view *DiskInstanceView_STATUS) AssignProperties_From_DiskInstanceView_STATUS(source *storage.DiskInstanceView_STATUS) error {

	// EncryptionSettings
	if source.EncryptionSettings != nil {
		encryptionSettingList := make([]DiskEncryptionSettings_STATUS, len(source.EncryptionSettings))
		for encryptionSettingIndex, encryptionSettingItem := range source.EncryptionSettings {
			// Shadow the loop variable to avoid aliasing
			encryptionSettingItem := encryptionSettingItem
			var encryptionSetting DiskEncryptionSettings_STATUS
			err := encryptionSetting.AssignProperties_From_DiskEncryptionSettings_STATUS(&encryptionSettingItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DiskEncryptionSettings_STATUS() to populate field EncryptionSettings")
			}
			encryptionSettingList[encryptionSettingIndex] = encryptionSetting
		}
		view.EncryptionSettings = encryptionSettingList
	} else {
		view.EncryptionSettings = nil
	}

	// Name
	view.Name = genruntime.ClonePointerToString(source.Name)

	// Statuses
	if source.Statuses != nil {
		statusList := make([]InstanceViewStatus_STATUS, len(source.Statuses))
		for statusIndex, statusItem := range source.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status InstanceViewStatus_STATUS
			err := status.AssignProperties_From_InstanceViewStatus_STATUS(&statusItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_InstanceViewStatus_STATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		view.Statuses = statusList
	} else {
		view.Statuses = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DiskInstanceView_STATUS populates the provided destination DiskInstanceView_STATUS from our DiskInstanceView_STATUS
func (view *DiskInstanceView_STATUS) AssignProperties_To_DiskInstanceView_STATUS(destination *storage.DiskInstanceView_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EncryptionSettings
	if view.EncryptionSettings != nil {
		encryptionSettingList := make([]storage.DiskEncryptionSettings_STATUS, len(view.EncryptionSettings))
		for encryptionSettingIndex, encryptionSettingItem := range view.EncryptionSettings {
			// Shadow the loop variable to avoid aliasing
			encryptionSettingItem := encryptionSettingItem
			var encryptionSetting storage.DiskEncryptionSettings_STATUS
			err := encryptionSettingItem.AssignProperties_To_DiskEncryptionSettings_STATUS(&encryptionSetting)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DiskEncryptionSettings_STATUS() to populate field EncryptionSettings")
			}
			encryptionSettingList[encryptionSettingIndex] = encryptionSetting
		}
		destination.EncryptionSettings = encryptionSettingList
	} else {
		destination.EncryptionSettings = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(view.Name)

	// Statuses
	if view.Statuses != nil {
		statusList := make([]storage.InstanceViewStatus_STATUS, len(view.Statuses))
		for statusIndex, statusItem := range view.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status storage.InstanceViewStatus_STATUS
			err := statusItem.AssignProperties_To_InstanceViewStatus_STATUS(&status)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_InstanceViewStatus_STATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		destination.Statuses = statusList
	} else {
		destination.Statuses = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type HardwareProfile_VmSize_STATUS string

const (
	HardwareProfile_VmSize_STATUS_Basic_A0           = HardwareProfile_VmSize_STATUS("Basic_A0")
	HardwareProfile_VmSize_STATUS_Basic_A1           = HardwareProfile_VmSize_STATUS("Basic_A1")
	HardwareProfile_VmSize_STATUS_Basic_A2           = HardwareProfile_VmSize_STATUS("Basic_A2")
	HardwareProfile_VmSize_STATUS_Basic_A3           = HardwareProfile_VmSize_STATUS("Basic_A3")
	HardwareProfile_VmSize_STATUS_Basic_A4           = HardwareProfile_VmSize_STATUS("Basic_A4")
	HardwareProfile_VmSize_STATUS_Standard_A0        = HardwareProfile_VmSize_STATUS("Standard_A0")
	HardwareProfile_VmSize_STATUS_Standard_A1        = HardwareProfile_VmSize_STATUS("Standard_A1")
	HardwareProfile_VmSize_STATUS_Standard_A10       = HardwareProfile_VmSize_STATUS("Standard_A10")
	HardwareProfile_VmSize_STATUS_Standard_A11       = HardwareProfile_VmSize_STATUS("Standard_A11")
	HardwareProfile_VmSize_STATUS_Standard_A1_V2     = HardwareProfile_VmSize_STATUS("Standard_A1_v2")
	HardwareProfile_VmSize_STATUS_Standard_A2        = HardwareProfile_VmSize_STATUS("Standard_A2")
	HardwareProfile_VmSize_STATUS_Standard_A2M_V2    = HardwareProfile_VmSize_STATUS("Standard_A2m_v2")
	HardwareProfile_VmSize_STATUS_Standard_A2_V2     = HardwareProfile_VmSize_STATUS("Standard_A2_v2")
	HardwareProfile_VmSize_STATUS_Standard_A3        = HardwareProfile_VmSize_STATUS("Standard_A3")
	HardwareProfile_VmSize_STATUS_Standard_A4        = HardwareProfile_VmSize_STATUS("Standard_A4")
	HardwareProfile_VmSize_STATUS_Standard_A4M_V2    = HardwareProfile_VmSize_STATUS("Standard_A4m_v2")
	HardwareProfile_VmSize_STATUS_Standard_A4_V2     = HardwareProfile_VmSize_STATUS("Standard_A4_v2")
	HardwareProfile_VmSize_STATUS_Standard_A5        = HardwareProfile_VmSize_STATUS("Standard_A5")
	HardwareProfile_VmSize_STATUS_Standard_A6        = HardwareProfile_VmSize_STATUS("Standard_A6")
	HardwareProfile_VmSize_STATUS_Standard_A7        = HardwareProfile_VmSize_STATUS("Standard_A7")
	HardwareProfile_VmSize_STATUS_Standard_A8        = HardwareProfile_VmSize_STATUS("Standard_A8")
	HardwareProfile_VmSize_STATUS_Standard_A8M_V2    = HardwareProfile_VmSize_STATUS("Standard_A8m_v2")
	HardwareProfile_VmSize_STATUS_Standard_A8_V2     = HardwareProfile_VmSize_STATUS("Standard_A8_v2")
	HardwareProfile_VmSize_STATUS_Standard_A9        = HardwareProfile_VmSize_STATUS("Standard_A9")
	HardwareProfile_VmSize_STATUS_Standard_B1Ms      = HardwareProfile_VmSize_STATUS("Standard_B1ms")
	HardwareProfile_VmSize_STATUS_Standard_B1S       = HardwareProfile_VmSize_STATUS("Standard_B1s")
	HardwareProfile_VmSize_STATUS_Standard_B2Ms      = HardwareProfile_VmSize_STATUS("Standard_B2ms")
	HardwareProfile_VmSize_STATUS_Standard_B2S       = HardwareProfile_VmSize_STATUS("Standard_B2s")
	HardwareProfile_VmSize_STATUS_Standard_B4Ms      = HardwareProfile_VmSize_STATUS("Standard_B4ms")
	HardwareProfile_VmSize_STATUS_Standard_B8Ms      = HardwareProfile_VmSize_STATUS("Standard_B8ms")
	HardwareProfile_VmSize_STATUS_Standard_D1        = HardwareProfile_VmSize_STATUS("Standard_D1")
	HardwareProfile_VmSize_STATUS_Standard_D11       = HardwareProfile_VmSize_STATUS("Standard_D11")
	HardwareProfile_VmSize_STATUS_Standard_D11_V2    = HardwareProfile_VmSize_STATUS("Standard_D11_v2")
	HardwareProfile_VmSize_STATUS_Standard_D12       = HardwareProfile_VmSize_STATUS("Standard_D12")
	HardwareProfile_VmSize_STATUS_Standard_D12_V2    = HardwareProfile_VmSize_STATUS("Standard_D12_v2")
	HardwareProfile_VmSize_STATUS_Standard_D13       = HardwareProfile_VmSize_STATUS("Standard_D13")
	HardwareProfile_VmSize_STATUS_Standard_D13_V2    = HardwareProfile_VmSize_STATUS("Standard_D13_v2")
	HardwareProfile_VmSize_STATUS_Standard_D14       = HardwareProfile_VmSize_STATUS("Standard_D14")
	HardwareProfile_VmSize_STATUS_Standard_D14_V2    = HardwareProfile_VmSize_STATUS("Standard_D14_v2")
	HardwareProfile_VmSize_STATUS_Standard_D15_V2    = HardwareProfile_VmSize_STATUS("Standard_D15_v2")
	HardwareProfile_VmSize_STATUS_Standard_D16S_V3   = HardwareProfile_VmSize_STATUS("Standard_D16s_v3")
	HardwareProfile_VmSize_STATUS_Standard_D16_V3    = HardwareProfile_VmSize_STATUS("Standard_D16_v3")
	HardwareProfile_VmSize_STATUS_Standard_D1_V2     = HardwareProfile_VmSize_STATUS("Standard_D1_v2")
	HardwareProfile_VmSize_STATUS_Standard_D2        = HardwareProfile_VmSize_STATUS("Standard_D2")
	HardwareProfile_VmSize_STATUS_Standard_D2S_V3    = HardwareProfile_VmSize_STATUS("Standard_D2s_v3")
	HardwareProfile_VmSize_STATUS_Standard_D2_V2     = HardwareProfile_VmSize_STATUS("Standard_D2_v2")
	HardwareProfile_VmSize_STATUS_Standard_D2_V3     = HardwareProfile_VmSize_STATUS("Standard_D2_v3")
	HardwareProfile_VmSize_STATUS_Standard_D3        = HardwareProfile_VmSize_STATUS("Standard_D3")
	HardwareProfile_VmSize_STATUS_Standard_D32S_V3   = HardwareProfile_VmSize_STATUS("Standard_D32s_v3")
	HardwareProfile_VmSize_STATUS_Standard_D32_V3    = HardwareProfile_VmSize_STATUS("Standard_D32_v3")
	HardwareProfile_VmSize_STATUS_Standard_D3_V2     = HardwareProfile_VmSize_STATUS("Standard_D3_v2")
	HardwareProfile_VmSize_STATUS_Standard_D4        = HardwareProfile_VmSize_STATUS("Standard_D4")
	HardwareProfile_VmSize_STATUS_Standard_D4S_V3    = HardwareProfile_VmSize_STATUS("Standard_D4s_v3")
	HardwareProfile_VmSize_STATUS_Standard_D4_V2     = HardwareProfile_VmSize_STATUS("Standard_D4_v2")
	HardwareProfile_VmSize_STATUS_Standard_D4_V3     = HardwareProfile_VmSize_STATUS("Standard_D4_v3")
	HardwareProfile_VmSize_STATUS_Standard_D5_V2     = HardwareProfile_VmSize_STATUS("Standard_D5_v2")
	HardwareProfile_VmSize_STATUS_Standard_D64S_V3   = HardwareProfile_VmSize_STATUS("Standard_D64s_v3")
	HardwareProfile_VmSize_STATUS_Standard_D64_V3    = HardwareProfile_VmSize_STATUS("Standard_D64_v3")
	HardwareProfile_VmSize_STATUS_Standard_D8S_V3    = HardwareProfile_VmSize_STATUS("Standard_D8s_v3")
	HardwareProfile_VmSize_STATUS_Standard_D8_V3     = HardwareProfile_VmSize_STATUS("Standard_D8_v3")
	HardwareProfile_VmSize_STATUS_Standard_DS1       = HardwareProfile_VmSize_STATUS("Standard_DS1")
	HardwareProfile_VmSize_STATUS_Standard_DS11      = HardwareProfile_VmSize_STATUS("Standard_DS11")
	HardwareProfile_VmSize_STATUS_Standard_DS11_V2   = HardwareProfile_VmSize_STATUS("Standard_DS11_v2")
	HardwareProfile_VmSize_STATUS_Standard_DS12      = HardwareProfile_VmSize_STATUS("Standard_DS12")
	HardwareProfile_VmSize_STATUS_Standard_DS12_V2   = HardwareProfile_VmSize_STATUS("Standard_DS12_v2")
	HardwareProfile_VmSize_STATUS_Standard_DS13      = HardwareProfile_VmSize_STATUS("Standard_DS13")
	HardwareProfile_VmSize_STATUS_Standard_DS132_V2  = HardwareProfile_VmSize_STATUS("Standard_DS13-2_v2")
	HardwareProfile_VmSize_STATUS_Standard_DS134_V2  = HardwareProfile_VmSize_STATUS("Standard_DS13-4_v2")
	HardwareProfile_VmSize_STATUS_Standard_DS13_V2   = HardwareProfile_VmSize_STATUS("Standard_DS13_v2")
	HardwareProfile_VmSize_STATUS_Standard_DS14      = HardwareProfile_VmSize_STATUS("Standard_DS14")
	HardwareProfile_VmSize_STATUS_Standard_DS144_V2  = HardwareProfile_VmSize_STATUS("Standard_DS14-4_v2")
	HardwareProfile_VmSize_STATUS_Standard_DS148_V2  = HardwareProfile_VmSize_STATUS("Standard_DS14-8_v2")
	HardwareProfile_VmSize_STATUS_Standard_DS14_V2   = HardwareProfile_VmSize_STATUS("Standard_DS14_v2")
	HardwareProfile_VmSize_STATUS_Standard_DS15_V2   = HardwareProfile_VmSize_STATUS("Standard_DS15_v2")
	HardwareProfile_VmSize_STATUS_Standard_DS1_V2    = HardwareProfile_VmSize_STATUS("Standard_DS1_v2")
	HardwareProfile_VmSize_STATUS_Standard_DS2       = HardwareProfile_VmSize_STATUS("Standard_DS2")
	HardwareProfile_VmSize_STATUS_Standard_DS2_V2    = HardwareProfile_VmSize_STATUS("Standard_DS2_v2")
	HardwareProfile_VmSize_STATUS_Standard_DS3       = HardwareProfile_VmSize_STATUS("Standard_DS3")
	HardwareProfile_VmSize_STATUS_Standard_DS3_V2    = HardwareProfile_VmSize_STATUS("Standard_DS3_v2")
	HardwareProfile_VmSize_STATUS_Standard_DS4       = HardwareProfile_VmSize_STATUS("Standard_DS4")
	HardwareProfile_VmSize_STATUS_Standard_DS4_V2    = HardwareProfile_VmSize_STATUS("Standard_DS4_v2")
	HardwareProfile_VmSize_STATUS_Standard_DS5_V2    = HardwareProfile_VmSize_STATUS("Standard_DS5_v2")
	HardwareProfile_VmSize_STATUS_Standard_E16S_V3   = HardwareProfile_VmSize_STATUS("Standard_E16s_v3")
	HardwareProfile_VmSize_STATUS_Standard_E16_V3    = HardwareProfile_VmSize_STATUS("Standard_E16_v3")
	HardwareProfile_VmSize_STATUS_Standard_E2S_V3    = HardwareProfile_VmSize_STATUS("Standard_E2s_v3")
	HardwareProfile_VmSize_STATUS_Standard_E2_V3     = HardwareProfile_VmSize_STATUS("Standard_E2_v3")
	HardwareProfile_VmSize_STATUS_Standard_E3216_V3  = HardwareProfile_VmSize_STATUS("Standard_E32-16_v3")
	HardwareProfile_VmSize_STATUS_Standard_E328S_V3  = HardwareProfile_VmSize_STATUS("Standard_E32-8s_v3")
	HardwareProfile_VmSize_STATUS_Standard_E32S_V3   = HardwareProfile_VmSize_STATUS("Standard_E32s_v3")
	HardwareProfile_VmSize_STATUS_Standard_E32_V3    = HardwareProfile_VmSize_STATUS("Standard_E32_v3")
	HardwareProfile_VmSize_STATUS_Standard_E4S_V3    = HardwareProfile_VmSize_STATUS("Standard_E4s_v3")
	HardwareProfile_VmSize_STATUS_Standard_E4_V3     = HardwareProfile_VmSize_STATUS("Standard_E4_v3")
	HardwareProfile_VmSize_STATUS_Standard_E6416S_V3 = HardwareProfile_VmSize_STATUS("Standard_E64-16s_v3")
	HardwareProfile_VmSize_STATUS_Standard_E6432S_V3 = HardwareProfile_VmSize_STATUS("Standard_E64-32s_v3")
	HardwareProfile_VmSize_STATUS_Standard_E64S_V3   = HardwareProfile_VmSize_STATUS("Standard_E64s_v3")
	HardwareProfile_VmSize_STATUS_Standard_E64_V3    = HardwareProfile_VmSize_STATUS("Standard_E64_v3")
	HardwareProfile_VmSize_STATUS_Standard_E8S_V3    = HardwareProfile_VmSize_STATUS("Standard_E8s_v3")
	HardwareProfile_VmSize_STATUS_Standard_E8_V3     = HardwareProfile_VmSize_STATUS("Standard_E8_v3")
	HardwareProfile_VmSize_STATUS_Standard_F1        = HardwareProfile_VmSize_STATUS("Standard_F1")
	HardwareProfile_VmSize_STATUS_Standard_F16       = HardwareProfile_VmSize_STATUS("Standard_F16")
	HardwareProfile_VmSize_STATUS_Standard_F16S      = HardwareProfile_VmSize_STATUS("Standard_F16s")
	HardwareProfile_VmSize_STATUS_Standard_F16S_V2   = HardwareProfile_VmSize_STATUS("Standard_F16s_v2")
	HardwareProfile_VmSize_STATUS_Standard_F1S       = HardwareProfile_VmSize_STATUS("Standard_F1s")
	HardwareProfile_VmSize_STATUS_Standard_F2        = HardwareProfile_VmSize_STATUS("Standard_F2")
	HardwareProfile_VmSize_STATUS_Standard_F2S       = HardwareProfile_VmSize_STATUS("Standard_F2s")
	HardwareProfile_VmSize_STATUS_Standard_F2S_V2    = HardwareProfile_VmSize_STATUS("Standard_F2s_v2")
	HardwareProfile_VmSize_STATUS_Standard_F32S_V2   = HardwareProfile_VmSize_STATUS("Standard_F32s_v2")
	HardwareProfile_VmSize_STATUS_Standard_F4        = HardwareProfile_VmSize_STATUS("Standard_F4")
	HardwareProfile_VmSize_STATUS_Standard_F4S       = HardwareProfile_VmSize_STATUS("Standard_F4s")
	HardwareProfile_VmSize_STATUS_Standard_F4S_V2    = HardwareProfile_VmSize_STATUS("Standard_F4s_v2")
	HardwareProfile_VmSize_STATUS_Standard_F64S_V2   = HardwareProfile_VmSize_STATUS("Standard_F64s_v2")
	HardwareProfile_VmSize_STATUS_Standard_F72S_V2   = HardwareProfile_VmSize_STATUS("Standard_F72s_v2")
	HardwareProfile_VmSize_STATUS_Standard_F8        = HardwareProfile_VmSize_STATUS("Standard_F8")
	HardwareProfile_VmSize_STATUS_Standard_F8S       = HardwareProfile_VmSize_STATUS("Standard_F8s")
	HardwareProfile_VmSize_STATUS_Standard_F8S_V2    = HardwareProfile_VmSize_STATUS("Standard_F8s_v2")
	HardwareProfile_VmSize_STATUS_Standard_G1        = HardwareProfile_VmSize_STATUS("Standard_G1")
	HardwareProfile_VmSize_STATUS_Standard_G2        = HardwareProfile_VmSize_STATUS("Standard_G2")
	HardwareProfile_VmSize_STATUS_Standard_G3        = HardwareProfile_VmSize_STATUS("Standard_G3")
	HardwareProfile_VmSize_STATUS_Standard_G4        = HardwareProfile_VmSize_STATUS("Standard_G4")
	HardwareProfile_VmSize_STATUS_Standard_G5        = HardwareProfile_VmSize_STATUS("Standard_G5")
	HardwareProfile_VmSize_STATUS_Standard_GS1       = HardwareProfile_VmSize_STATUS("Standard_GS1")
	HardwareProfile_VmSize_STATUS_Standard_GS2       = HardwareProfile_VmSize_STATUS("Standard_GS2")
	HardwareProfile_VmSize_STATUS_Standard_GS3       = HardwareProfile_VmSize_STATUS("Standard_GS3")
	HardwareProfile_VmSize_STATUS_Standard_GS4       = HardwareProfile_VmSize_STATUS("Standard_GS4")
	HardwareProfile_VmSize_STATUS_Standard_GS44      = HardwareProfile_VmSize_STATUS("Standard_GS4-4")
	HardwareProfile_VmSize_STATUS_Standard_GS48      = HardwareProfile_VmSize_STATUS("Standard_GS4-8")
	HardwareProfile_VmSize_STATUS_Standard_GS5       = HardwareProfile_VmSize_STATUS("Standard_GS5")
	HardwareProfile_VmSize_STATUS_Standard_GS516     = HardwareProfile_VmSize_STATUS("Standard_GS5-16")
	HardwareProfile_VmSize_STATUS_Standard_GS58      = HardwareProfile_VmSize_STATUS("Standard_GS5-8")
	HardwareProfile_VmSize_STATUS_Standard_H16       = HardwareProfile_VmSize_STATUS("Standard_H16")
	HardwareProfile_VmSize_STATUS_Standard_H16M      = HardwareProfile_VmSize_STATUS("Standard_H16m")
	HardwareProfile_VmSize_STATUS_Standard_H16Mr     = HardwareProfile_VmSize_STATUS("Standard_H16mr")
	HardwareProfile_VmSize_STATUS_Standard_H16R      = HardwareProfile_VmSize_STATUS("Standard_H16r")
	HardwareProfile_VmSize_STATUS_Standard_H8        = HardwareProfile_VmSize_STATUS("Standard_H8")
	HardwareProfile_VmSize_STATUS_Standard_H8M       = HardwareProfile_VmSize_STATUS("Standard_H8m")
	HardwareProfile_VmSize_STATUS_Standard_L16S      = HardwareProfile_VmSize_STATUS("Standard_L16s")
	HardwareProfile_VmSize_STATUS_Standard_L32S      = HardwareProfile_VmSize_STATUS("Standard_L32s")
	HardwareProfile_VmSize_STATUS_Standard_L4S       = HardwareProfile_VmSize_STATUS("Standard_L4s")
	HardwareProfile_VmSize_STATUS_Standard_L8S       = HardwareProfile_VmSize_STATUS("Standard_L8s")
	HardwareProfile_VmSize_STATUS_Standard_M12832Ms  = HardwareProfile_VmSize_STATUS("Standard_M128-32ms")
	HardwareProfile_VmSize_STATUS_Standard_M12864Ms  = HardwareProfile_VmSize_STATUS("Standard_M128-64ms")
	HardwareProfile_VmSize_STATUS_Standard_M128Ms    = HardwareProfile_VmSize_STATUS("Standard_M128ms")
	HardwareProfile_VmSize_STATUS_Standard_M128S     = HardwareProfile_VmSize_STATUS("Standard_M128s")
	HardwareProfile_VmSize_STATUS_Standard_M6416Ms   = HardwareProfile_VmSize_STATUS("Standard_M64-16ms")
	HardwareProfile_VmSize_STATUS_Standard_M6432Ms   = HardwareProfile_VmSize_STATUS("Standard_M64-32ms")
	HardwareProfile_VmSize_STATUS_Standard_M64Ms     = HardwareProfile_VmSize_STATUS("Standard_M64ms")
	HardwareProfile_VmSize_STATUS_Standard_M64S      = HardwareProfile_VmSize_STATUS("Standard_M64s")
	HardwareProfile_VmSize_STATUS_Standard_NC12      = HardwareProfile_VmSize_STATUS("Standard_NC12")
	HardwareProfile_VmSize_STATUS_Standard_NC12S_V2  = HardwareProfile_VmSize_STATUS("Standard_NC12s_v2")
	HardwareProfile_VmSize_STATUS_Standard_NC12S_V3  = HardwareProfile_VmSize_STATUS("Standard_NC12s_v3")
	HardwareProfile_VmSize_STATUS_Standard_NC24      = HardwareProfile_VmSize_STATUS("Standard_NC24")
	HardwareProfile_VmSize_STATUS_Standard_NC24R     = HardwareProfile_VmSize_STATUS("Standard_NC24r")
	HardwareProfile_VmSize_STATUS_Standard_NC24Rs_V2 = HardwareProfile_VmSize_STATUS("Standard_NC24rs_v2")
	HardwareProfile_VmSize_STATUS_Standard_NC24Rs_V3 = HardwareProfile_VmSize_STATUS("Standard_NC24rs_v3")
	HardwareProfile_VmSize_STATUS_Standard_NC24S_V2  = HardwareProfile_VmSize_STATUS("Standard_NC24s_v2")
	HardwareProfile_VmSize_STATUS_Standard_NC24S_V3  = HardwareProfile_VmSize_STATUS("Standard_NC24s_v3")
	HardwareProfile_VmSize_STATUS_Standard_NC6       = HardwareProfile_VmSize_STATUS("Standard_NC6")
	HardwareProfile_VmSize_STATUS_Standard_NC6S_V2   = HardwareProfile_VmSize_STATUS("Standard_NC6s_v2")
	HardwareProfile_VmSize_STATUS_Standard_NC6S_V3   = HardwareProfile_VmSize_STATUS("Standard_NC6s_v3")
	HardwareProfile_VmSize_STATUS_Standard_ND12S     = HardwareProfile_VmSize_STATUS("Standard_ND12s")
	HardwareProfile_VmSize_STATUS_Standard_ND24Rs    = HardwareProfile_VmSize_STATUS("Standard_ND24rs")
	HardwareProfile_VmSize_STATUS_Standard_ND24S     = HardwareProfile_VmSize_STATUS("Standard_ND24s")
	HardwareProfile_VmSize_STATUS_Standard_ND6S      = HardwareProfile_VmSize_STATUS("Standard_ND6s")
	HardwareProfile_VmSize_STATUS_Standard_NV12      = HardwareProfile_VmSize_STATUS("Standard_NV12")
	HardwareProfile_VmSize_STATUS_Standard_NV24      = HardwareProfile_VmSize_STATUS("Standard_NV24")
	HardwareProfile_VmSize_STATUS_Standard_NV6       = HardwareProfile_VmSize_STATUS("Standard_NV6")
)

// Mapping from string to HardwareProfile_VmSize_STATUS
var hardwareProfile_VmSize_STATUS_Values = map[string]HardwareProfile_VmSize_STATUS{
	"basic_a0":            HardwareProfile_VmSize_STATUS_Basic_A0,
	"basic_a1":            HardwareProfile_VmSize_STATUS_Basic_A1,
	"basic_a2":            HardwareProfile_VmSize_STATUS_Basic_A2,
	"basic_a3":            HardwareProfile_VmSize_STATUS_Basic_A3,
	"basic_a4":            HardwareProfile_VmSize_STATUS_Basic_A4,
	"standard_a0":         HardwareProfile_VmSize_STATUS_Standard_A0,
	"standard_a1":         HardwareProfile_VmSize_STATUS_Standard_A1,
	"standard_a10":        HardwareProfile_VmSize_STATUS_Standard_A10,
	"standard_a11":        HardwareProfile_VmSize_STATUS_Standard_A11,
	"standard_a1_v2":      HardwareProfile_VmSize_STATUS_Standard_A1_V2,
	"standard_a2":         HardwareProfile_VmSize_STATUS_Standard_A2,
	"standard_a2m_v2":     HardwareProfile_VmSize_STATUS_Standard_A2M_V2,
	"standard_a2_v2":      HardwareProfile_VmSize_STATUS_Standard_A2_V2,
	"standard_a3":         HardwareProfile_VmSize_STATUS_Standard_A3,
	"standard_a4":         HardwareProfile_VmSize_STATUS_Standard_A4,
	"standard_a4m_v2":     HardwareProfile_VmSize_STATUS_Standard_A4M_V2,
	"standard_a4_v2":      HardwareProfile_VmSize_STATUS_Standard_A4_V2,
	"standard_a5":         HardwareProfile_VmSize_STATUS_Standard_A5,
	"standard_a6":         HardwareProfile_VmSize_STATUS_Standard_A6,
	"standard_a7":         HardwareProfile_VmSize_STATUS_Standard_A7,
	"standard_a8":         HardwareProfile_VmSize_STATUS_Standard_A8,
	"standard_a8m_v2":     HardwareProfile_VmSize_STATUS_Standard_A8M_V2,
	"standard_a8_v2":      HardwareProfile_VmSize_STATUS_Standard_A8_V2,
	"standard_a9":         HardwareProfile_VmSize_STATUS_Standard_A9,
	"standard_b1ms":       HardwareProfile_VmSize_STATUS_Standard_B1Ms,
	"standard_b1s":        HardwareProfile_VmSize_STATUS_Standard_B1S,
	"standard_b2ms":       HardwareProfile_VmSize_STATUS_Standard_B2Ms,
	"standard_b2s":        HardwareProfile_VmSize_STATUS_Standard_B2S,
	"standard_b4ms":       HardwareProfile_VmSize_STATUS_Standard_B4Ms,
	"standard_b8ms":       HardwareProfile_VmSize_STATUS_Standard_B8Ms,
	"standard_d1":         HardwareProfile_VmSize_STATUS_Standard_D1,
	"standard_d11":        HardwareProfile_VmSize_STATUS_Standard_D11,
	"standard_d11_v2":     HardwareProfile_VmSize_STATUS_Standard_D11_V2,
	"standard_d12":        HardwareProfile_VmSize_STATUS_Standard_D12,
	"standard_d12_v2":     HardwareProfile_VmSize_STATUS_Standard_D12_V2,
	"standard_d13":        HardwareProfile_VmSize_STATUS_Standard_D13,
	"standard_d13_v2":     HardwareProfile_VmSize_STATUS_Standard_D13_V2,
	"standard_d14":        HardwareProfile_VmSize_STATUS_Standard_D14,
	"standard_d14_v2":     HardwareProfile_VmSize_STATUS_Standard_D14_V2,
	"standard_d15_v2":     HardwareProfile_VmSize_STATUS_Standard_D15_V2,
	"standard_d16s_v3":    HardwareProfile_VmSize_STATUS_Standard_D16S_V3,
	"standard_d16_v3":     HardwareProfile_VmSize_STATUS_Standard_D16_V3,
	"standard_d1_v2":      HardwareProfile_VmSize_STATUS_Standard_D1_V2,
	"standard_d2":         HardwareProfile_VmSize_STATUS_Standard_D2,
	"standard_d2s_v3":     HardwareProfile_VmSize_STATUS_Standard_D2S_V3,
	"standard_d2_v2":      HardwareProfile_VmSize_STATUS_Standard_D2_V2,
	"standard_d2_v3":      HardwareProfile_VmSize_STATUS_Standard_D2_V3,
	"standard_d3":         HardwareProfile_VmSize_STATUS_Standard_D3,
	"standard_d32s_v3":    HardwareProfile_VmSize_STATUS_Standard_D32S_V3,
	"standard_d32_v3":     HardwareProfile_VmSize_STATUS_Standard_D32_V3,
	"standard_d3_v2":      HardwareProfile_VmSize_STATUS_Standard_D3_V2,
	"standard_d4":         HardwareProfile_VmSize_STATUS_Standard_D4,
	"standard_d4s_v3":     HardwareProfile_VmSize_STATUS_Standard_D4S_V3,
	"standard_d4_v2":      HardwareProfile_VmSize_STATUS_Standard_D4_V2,
	"standard_d4_v3":      HardwareProfile_VmSize_STATUS_Standard_D4_V3,
	"standard_d5_v2":      HardwareProfile_VmSize_STATUS_Standard_D5_V2,
	"standard_d64s_v3":    HardwareProfile_VmSize_STATUS_Standard_D64S_V3,
	"standard_d64_v3":     HardwareProfile_VmSize_STATUS_Standard_D64_V3,
	"standard_d8s_v3":     HardwareProfile_VmSize_STATUS_Standard_D8S_V3,
	"standard_d8_v3":      HardwareProfile_VmSize_STATUS_Standard_D8_V3,
	"standard_ds1":        HardwareProfile_VmSize_STATUS_Standard_DS1,
	"standard_ds11":       HardwareProfile_VmSize_STATUS_Standard_DS11,
	"standard_ds11_v2":    HardwareProfile_VmSize_STATUS_Standard_DS11_V2,
	"standard_ds12":       HardwareProfile_VmSize_STATUS_Standard_DS12,
	"standard_ds12_v2":    HardwareProfile_VmSize_STATUS_Standard_DS12_V2,
	"standard_ds13":       HardwareProfile_VmSize_STATUS_Standard_DS13,
	"standard_ds13-2_v2":  HardwareProfile_VmSize_STATUS_Standard_DS132_V2,
	"standard_ds13-4_v2":  HardwareProfile_VmSize_STATUS_Standard_DS134_V2,
	"standard_ds13_v2":    HardwareProfile_VmSize_STATUS_Standard_DS13_V2,
	"standard_ds14":       HardwareProfile_VmSize_STATUS_Standard_DS14,
	"standard_ds14-4_v2":  HardwareProfile_VmSize_STATUS_Standard_DS144_V2,
	"standard_ds14-8_v2":  HardwareProfile_VmSize_STATUS_Standard_DS148_V2,
	"standard_ds14_v2":    HardwareProfile_VmSize_STATUS_Standard_DS14_V2,
	"standard_ds15_v2":    HardwareProfile_VmSize_STATUS_Standard_DS15_V2,
	"standard_ds1_v2":     HardwareProfile_VmSize_STATUS_Standard_DS1_V2,
	"standard_ds2":        HardwareProfile_VmSize_STATUS_Standard_DS2,
	"standard_ds2_v2":     HardwareProfile_VmSize_STATUS_Standard_DS2_V2,
	"standard_ds3":        HardwareProfile_VmSize_STATUS_Standard_DS3,
	"standard_ds3_v2":     HardwareProfile_VmSize_STATUS_Standard_DS3_V2,
	"standard_ds4":        HardwareProfile_VmSize_STATUS_Standard_DS4,
	"standard_ds4_v2":     HardwareProfile_VmSize_STATUS_Standard_DS4_V2,
	"standard_ds5_v2":     HardwareProfile_VmSize_STATUS_Standard_DS5_V2,
	"standard_e16s_v3":    HardwareProfile_VmSize_STATUS_Standard_E16S_V3,
	"standard_e16_v3":     HardwareProfile_VmSize_STATUS_Standard_E16_V3,
	"standard_e2s_v3":     HardwareProfile_VmSize_STATUS_Standard_E2S_V3,
	"standard_e2_v3":      HardwareProfile_VmSize_STATUS_Standard_E2_V3,
	"standard_e32-16_v3":  HardwareProfile_VmSize_STATUS_Standard_E3216_V3,
	"standard_e32-8s_v3":  HardwareProfile_VmSize_STATUS_Standard_E328S_V3,
	"standard_e32s_v3":    HardwareProfile_VmSize_STATUS_Standard_E32S_V3,
	"standard_e32_v3":     HardwareProfile_VmSize_STATUS_Standard_E32_V3,
	"standard_e4s_v3":     HardwareProfile_VmSize_STATUS_Standard_E4S_V3,
	"standard_e4_v3":      HardwareProfile_VmSize_STATUS_Standard_E4_V3,
	"standard_e64-16s_v3": HardwareProfile_VmSize_STATUS_Standard_E6416S_V3,
	"standard_e64-32s_v3": HardwareProfile_VmSize_STATUS_Standard_E6432S_V3,
	"standard_e64s_v3":    HardwareProfile_VmSize_STATUS_Standard_E64S_V3,
	"standard_e64_v3":     HardwareProfile_VmSize_STATUS_Standard_E64_V3,
	"standard_e8s_v3":     HardwareProfile_VmSize_STATUS_Standard_E8S_V3,
	"standard_e8_v3":      HardwareProfile_VmSize_STATUS_Standard_E8_V3,
	"standard_f1":         HardwareProfile_VmSize_STATUS_Standard_F1,
	"standard_f16":        HardwareProfile_VmSize_STATUS_Standard_F16,
	"standard_f16s":       HardwareProfile_VmSize_STATUS_Standard_F16S,
	"standard_f16s_v2":    HardwareProfile_VmSize_STATUS_Standard_F16S_V2,
	"standard_f1s":        HardwareProfile_VmSize_STATUS_Standard_F1S,
	"standard_f2":         HardwareProfile_VmSize_STATUS_Standard_F2,
	"standard_f2s":        HardwareProfile_VmSize_STATUS_Standard_F2S,
	"standard_f2s_v2":     HardwareProfile_VmSize_STATUS_Standard_F2S_V2,
	"standard_f32s_v2":    HardwareProfile_VmSize_STATUS_Standard_F32S_V2,
	"standard_f4":         HardwareProfile_VmSize_STATUS_Standard_F4,
	"standard_f4s":        HardwareProfile_VmSize_STATUS_Standard_F4S,
	"standard_f4s_v2":     HardwareProfile_VmSize_STATUS_Standard_F4S_V2,
	"standard_f64s_v2":    HardwareProfile_VmSize_STATUS_Standard_F64S_V2,
	"standard_f72s_v2":    HardwareProfile_VmSize_STATUS_Standard_F72S_V2,
	"standard_f8":         HardwareProfile_VmSize_STATUS_Standard_F8,
	"standard_f8s":        HardwareProfile_VmSize_STATUS_Standard_F8S,
	"standard_f8s_v2":     HardwareProfile_VmSize_STATUS_Standard_F8S_V2,
	"standard_g1":         HardwareProfile_VmSize_STATUS_Standard_G1,
	"standard_g2":         HardwareProfile_VmSize_STATUS_Standard_G2,
	"standard_g3":         HardwareProfile_VmSize_STATUS_Standard_G3,
	"standard_g4":         HardwareProfile_VmSize_STATUS_Standard_G4,
	"standard_g5":         HardwareProfile_VmSize_STATUS_Standard_G5,
	"standard_gs1":        HardwareProfile_VmSize_STATUS_Standard_GS1,
	"standard_gs2":        HardwareProfile_VmSize_STATUS_Standard_GS2,
	"standard_gs3":        HardwareProfile_VmSize_STATUS_Standard_GS3,
	"standard_gs4":        HardwareProfile_VmSize_STATUS_Standard_GS4,
	"standard_gs4-4":      HardwareProfile_VmSize_STATUS_Standard_GS44,
	"standard_gs4-8":      HardwareProfile_VmSize_STATUS_Standard_GS48,
	"standard_gs5":        HardwareProfile_VmSize_STATUS_Standard_GS5,
	"standard_gs5-16":     HardwareProfile_VmSize_STATUS_Standard_GS516,
	"standard_gs5-8":      HardwareProfile_VmSize_STATUS_Standard_GS58,
	"standard_h16":        HardwareProfile_VmSize_STATUS_Standard_H16,
	"standard_h16m":       HardwareProfile_VmSize_STATUS_Standard_H16M,
	"standard_h16mr":      HardwareProfile_VmSize_STATUS_Standard_H16Mr,
	"standard_h16r":       HardwareProfile_VmSize_STATUS_Standard_H16R,
	"standard_h8":         HardwareProfile_VmSize_STATUS_Standard_H8,
	"standard_h8m":        HardwareProfile_VmSize_STATUS_Standard_H8M,
	"standard_l16s":       HardwareProfile_VmSize_STATUS_Standard_L16S,
	"standard_l32s":       HardwareProfile_VmSize_STATUS_Standard_L32S,
	"standard_l4s":        HardwareProfile_VmSize_STATUS_Standard_L4S,
	"standard_l8s":        HardwareProfile_VmSize_STATUS_Standard_L8S,
	"standard_m128-32ms":  HardwareProfile_VmSize_STATUS_Standard_M12832Ms,
	"standard_m128-64ms":  HardwareProfile_VmSize_STATUS_Standard_M12864Ms,
	"standard_m128ms":     HardwareProfile_VmSize_STATUS_Standard_M128Ms,
	"standard_m128s":      HardwareProfile_VmSize_STATUS_Standard_M128S,
	"standard_m64-16ms":   HardwareProfile_VmSize_STATUS_Standard_M6416Ms,
	"standard_m64-32ms":   HardwareProfile_VmSize_STATUS_Standard_M6432Ms,
	"standard_m64ms":      HardwareProfile_VmSize_STATUS_Standard_M64Ms,
	"standard_m64s":       HardwareProfile_VmSize_STATUS_Standard_M64S,
	"standard_nc12":       HardwareProfile_VmSize_STATUS_Standard_NC12,
	"standard_nc12s_v2":   HardwareProfile_VmSize_STATUS_Standard_NC12S_V2,
	"standard_nc12s_v3":   HardwareProfile_VmSize_STATUS_Standard_NC12S_V3,
	"standard_nc24":       HardwareProfile_VmSize_STATUS_Standard_NC24,
	"standard_nc24r":      HardwareProfile_VmSize_STATUS_Standard_NC24R,
	"standard_nc24rs_v2":  HardwareProfile_VmSize_STATUS_Standard_NC24Rs_V2,
	"standard_nc24rs_v3":  HardwareProfile_VmSize_STATUS_Standard_NC24Rs_V3,
	"standard_nc24s_v2":   HardwareProfile_VmSize_STATUS_Standard_NC24S_V2,
	"standard_nc24s_v3":   HardwareProfile_VmSize_STATUS_Standard_NC24S_V3,
	"standard_nc6":        HardwareProfile_VmSize_STATUS_Standard_NC6,
	"standard_nc6s_v2":    HardwareProfile_VmSize_STATUS_Standard_NC6S_V2,
	"standard_nc6s_v3":    HardwareProfile_VmSize_STATUS_Standard_NC6S_V3,
	"standard_nd12s":      HardwareProfile_VmSize_STATUS_Standard_ND12S,
	"standard_nd24rs":     HardwareProfile_VmSize_STATUS_Standard_ND24Rs,
	"standard_nd24s":      HardwareProfile_VmSize_STATUS_Standard_ND24S,
	"standard_nd6s":       HardwareProfile_VmSize_STATUS_Standard_ND6S,
	"standard_nv12":       HardwareProfile_VmSize_STATUS_Standard_NV12,
	"standard_nv24":       HardwareProfile_VmSize_STATUS_Standard_NV24,
	"standard_nv6":        HardwareProfile_VmSize_STATUS_Standard_NV6,
}

// Specifies information about the image to use. You can specify information about platform images, marketplace images, or
// virtual machine images. This element is required when you want to use a platform image, marketplace image, or virtual
// machine image, but is not used in other creation operations. NOTE: Image reference publisher and offer can only be set
// when you create the scale set.
type ImageReference struct {
	// CommunityGalleryImageId: Specified the community gallery image unique id for vm deployment. This can be fetched from
	// community gallery image GET call.
	CommunityGalleryImageId *string `json:"communityGalleryImageId,omitempty"`

	// Offer: Specifies the offer of the platform image or marketplace image used to create the virtual machine.
	Offer *string `json:"offer,omitempty"`

	// Publisher: The image publisher.
	Publisher *string `json:"publisher,omitempty"`

	// Reference: Resource Id
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`

	// SharedGalleryImageId: Specified the shared gallery image unique id for vm deployment. This can be fetched from shared
	// gallery image GET call.
	SharedGalleryImageId *string `json:"sharedGalleryImageId,omitempty"`

	// Sku: The image SKU.
	Sku *string `json:"sku,omitempty"`

	// Version: Specifies the version of the platform image or marketplace image used to create the virtual machine. The
	// allowed formats are Major.Minor.Build or 'latest'. Major, Minor, and Build are decimal numbers. Specify 'latest' to use
	// the latest version of an image available at deploy time. Even if you use 'latest', the VM image will not automatically
	// update after deploy time even if a new version becomes available. Please do not use field 'version' for gallery image
	// deployment, gallery image should always use 'id' field for deployment, to use 'latest' version of gallery image, just
	// set
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/images/{imageName}'
	// in the 'id' field without version input.
	Version *string `json:"version,omitempty"`
}

var _ genruntime.ARMTransformer = &ImageReference{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (reference *ImageReference) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if reference == nil {
		return nil, nil
	}
	result := &arm.ImageReference{}

	// Set property "CommunityGalleryImageId":
	if reference.CommunityGalleryImageId != nil {
		communityGalleryImageId := *reference.CommunityGalleryImageId
		result.CommunityGalleryImageId = &communityGalleryImageId
	}

	// Set property "Id":
	if reference.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*reference.Reference)
		if err != nil {
			return nil, err
		}
		reference1 := referenceARMID
		result.Id = &reference1
	}

	// Set property "Offer":
	if reference.Offer != nil {
		offer := *reference.Offer
		result.Offer = &offer
	}

	// Set property "Publisher":
	if reference.Publisher != nil {
		publisher := *reference.Publisher
		result.Publisher = &publisher
	}

	// Set property "SharedGalleryImageId":
	if reference.SharedGalleryImageId != nil {
		sharedGalleryImageId := *reference.SharedGalleryImageId
		result.SharedGalleryImageId = &sharedGalleryImageId
	}

	// Set property "Sku":
	if reference.Sku != nil {
		sku := *reference.Sku
		result.Sku = &sku
	}

	// Set property "Version":
	if reference.Version != nil {
		version := *reference.Version
		result.Version = &version
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *ImageReference) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ImageReference{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *ImageReference) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ImageReference)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ImageReference, got %T", armInput)
	}

	// Set property "CommunityGalleryImageId":
	if typedInput.CommunityGalleryImageId != nil {
		communityGalleryImageId := *typedInput.CommunityGalleryImageId
		reference.CommunityGalleryImageId = &communityGalleryImageId
	}

	// Set property "Offer":
	if typedInput.Offer != nil {
		offer := *typedInput.Offer
		reference.Offer = &offer
	}

	// Set property "Publisher":
	if typedInput.Publisher != nil {
		publisher := *typedInput.Publisher
		reference.Publisher = &publisher
	}

	// no assignment for property "Reference"

	// Set property "SharedGalleryImageId":
	if typedInput.SharedGalleryImageId != nil {
		sharedGalleryImageId := *typedInput.SharedGalleryImageId
		reference.SharedGalleryImageId = &sharedGalleryImageId
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		sku := *typedInput.Sku
		reference.Sku = &sku
	}

	// Set property "Version":
	if typedInput.Version != nil {
		version := *typedInput.Version
		reference.Version = &version
	}

	// No error
	return nil
}

// AssignProperties_From_ImageReference populates our ImageReference from the provided source ImageReference
func (reference *ImageReference) AssignProperties_From_ImageReference(source *storage.ImageReference) error {

	// CommunityGalleryImageId
	reference.CommunityGalleryImageId = genruntime.ClonePointerToString(source.CommunityGalleryImageId)

	// Offer
	reference.Offer = genruntime.ClonePointerToString(source.Offer)

	// Publisher
	reference.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// Reference
	if source.Reference != nil {
		referenceTemp := source.Reference.Copy()
		reference.Reference = &referenceTemp
	} else {
		reference.Reference = nil
	}

	// SharedGalleryImageId
	reference.SharedGalleryImageId = genruntime.ClonePointerToString(source.SharedGalleryImageId)

	// Sku
	reference.Sku = genruntime.ClonePointerToString(source.Sku)

	// Version
	reference.Version = genruntime.ClonePointerToString(source.Version)

	// No error
	return nil
}

// AssignProperties_To_ImageReference populates the provided destination ImageReference from our ImageReference
func (reference *ImageReference) AssignProperties_To_ImageReference(destination *storage.ImageReference) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CommunityGalleryImageId
	destination.CommunityGalleryImageId = genruntime.ClonePointerToString(reference.CommunityGalleryImageId)

	// Offer
	destination.Offer = genruntime.ClonePointerToString(reference.Offer)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(reference.Publisher)

	// Reference
	if reference.Reference != nil {
		referenceTemp := reference.Reference.Copy()
		destination.Reference = &referenceTemp
	} else {
		destination.Reference = nil
	}

	// SharedGalleryImageId
	destination.SharedGalleryImageId = genruntime.ClonePointerToString(reference.SharedGalleryImageId)

	// Sku
	destination.Sku = genruntime.ClonePointerToString(reference.Sku)

	// Version
	destination.Version = genruntime.ClonePointerToString(reference.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ImageReference_STATUS populates our ImageReference from the provided source ImageReference_STATUS
func (reference *ImageReference) Initialize_From_ImageReference_STATUS(source *ImageReference_STATUS) error {

	// CommunityGalleryImageId
	reference.CommunityGalleryImageId = genruntime.ClonePointerToString(source.CommunityGalleryImageId)

	// Offer
	reference.Offer = genruntime.ClonePointerToString(source.Offer)

	// Publisher
	reference.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// Reference
	if source.Id != nil {
		referenceTemp := genruntime.CreateResourceReferenceFromARMID(*source.Id)
		reference.Reference = &referenceTemp
	} else {
		reference.Reference = nil
	}

	// SharedGalleryImageId
	reference.SharedGalleryImageId = genruntime.ClonePointerToString(source.SharedGalleryImageId)

	// Sku
	reference.Sku = genruntime.ClonePointerToString(source.Sku)

	// Version
	reference.Version = genruntime.ClonePointerToString(source.Version)

	// No error
	return nil
}

// Specifies information about the image to use. You can specify information about platform images, marketplace images, or
// virtual machine images. This element is required when you want to use a platform image, marketplace image, or virtual
// machine image, but is not used in other creation operations. NOTE: Image reference publisher and offer can only be set
// when you create the scale set.
type ImageReference_STATUS struct {
	// CommunityGalleryImageId: Specified the community gallery image unique id for vm deployment. This can be fetched from
	// community gallery image GET call.
	CommunityGalleryImageId *string `json:"communityGalleryImageId,omitempty"`

	// ExactVersion: Specifies in decimal numbers, the version of platform image or marketplace image used to create the
	// virtual machine. This readonly field differs from 'version', only if the value specified in 'version' field is 'latest'.
	ExactVersion *string `json:"exactVersion,omitempty"`

	// Id: Resource Id
	Id *string `json:"id,omitempty"`

	// Offer: Specifies the offer of the platform image or marketplace image used to create the virtual machine.
	Offer *string `json:"offer,omitempty"`

	// Publisher: The image publisher.
	Publisher *string `json:"publisher,omitempty"`

	// SharedGalleryImageId: Specified the shared gallery image unique id for vm deployment. This can be fetched from shared
	// gallery image GET call.
	SharedGalleryImageId *string `json:"sharedGalleryImageId,omitempty"`

	// Sku: The image SKU.
	Sku *string `json:"sku,omitempty"`

	// Version: Specifies the version of the platform image or marketplace image used to create the virtual machine. The
	// allowed formats are Major.Minor.Build or 'latest'. Major, Minor, and Build are decimal numbers. Specify 'latest' to use
	// the latest version of an image available at deploy time. Even if you use 'latest', the VM image will not automatically
	// update after deploy time even if a new version becomes available. Please do not use field 'version' for gallery image
	// deployment, gallery image should always use 'id' field for deployment, to use 'latest' version of gallery image, just
	// set
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/images/{imageName}'
	// in the 'id' field without version input.
	Version *string `json:"version,omitempty"`
}

var _ genruntime.FromARMConverter = &ImageReference_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *ImageReference_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ImageReference_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *ImageReference_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ImageReference_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ImageReference_STATUS, got %T", armInput)
	}

	// Set property "CommunityGalleryImageId":
	if typedInput.CommunityGalleryImageId != nil {
		communityGalleryImageId := *typedInput.CommunityGalleryImageId
		reference.CommunityGalleryImageId = &communityGalleryImageId
	}

	// Set property "ExactVersion":
	if typedInput.ExactVersion != nil {
		exactVersion := *typedInput.ExactVersion
		reference.ExactVersion = &exactVersion
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		reference.Id = &id
	}

	// Set property "Offer":
	if typedInput.Offer != nil {
		offer := *typedInput.Offer
		reference.Offer = &offer
	}

	// Set property "Publisher":
	if typedInput.Publisher != nil {
		publisher := *typedInput.Publisher
		reference.Publisher = &publisher
	}

	// Set property "SharedGalleryImageId":
	if typedInput.SharedGalleryImageId != nil {
		sharedGalleryImageId := *typedInput.SharedGalleryImageId
		reference.SharedGalleryImageId = &sharedGalleryImageId
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		sku := *typedInput.Sku
		reference.Sku = &sku
	}

	// Set property "Version":
	if typedInput.Version != nil {
		version := *typedInput.Version
		reference.Version = &version
	}

	// No error
	return nil
}

// AssignProperties_From_ImageReference_STATUS populates our ImageReference_STATUS from the provided source ImageReference_STATUS
func (reference *ImageReference_STATUS) AssignProperties_From_ImageReference_STATUS(source *storage.ImageReference_STATUS) error {

	// CommunityGalleryImageId
	reference.CommunityGalleryImageId = genruntime.ClonePointerToString(source.CommunityGalleryImageId)

	// ExactVersion
	reference.ExactVersion = genruntime.ClonePointerToString(source.ExactVersion)

	// Id
	reference.Id = genruntime.ClonePointerToString(source.Id)

	// Offer
	reference.Offer = genruntime.ClonePointerToString(source.Offer)

	// Publisher
	reference.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// SharedGalleryImageId
	reference.SharedGalleryImageId = genruntime.ClonePointerToString(source.SharedGalleryImageId)

	// Sku
	reference.Sku = genruntime.ClonePointerToString(source.Sku)

	// Version
	reference.Version = genruntime.ClonePointerToString(source.Version)

	// No error
	return nil
}

// AssignProperties_To_ImageReference_STATUS populates the provided destination ImageReference_STATUS from our ImageReference_STATUS
func (reference *ImageReference_STATUS) AssignProperties_To_ImageReference_STATUS(destination *storage.ImageReference_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CommunityGalleryImageId
	destination.CommunityGalleryImageId = genruntime.ClonePointerToString(reference.CommunityGalleryImageId)

	// ExactVersion
	destination.ExactVersion = genruntime.ClonePointerToString(reference.ExactVersion)

	// Id
	destination.Id = genruntime.ClonePointerToString(reference.Id)

	// Offer
	destination.Offer = genruntime.ClonePointerToString(reference.Offer)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(reference.Publisher)

	// SharedGalleryImageId
	destination.SharedGalleryImageId = genruntime.ClonePointerToString(reference.SharedGalleryImageId)

	// Sku
	destination.Sku = genruntime.ClonePointerToString(reference.Sku)

	// Version
	destination.Version = genruntime.ClonePointerToString(reference.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Instance view status.
type InstanceViewStatus_STATUS struct {
	// Code: The status code.
	Code *string `json:"code,omitempty"`

	// DisplayStatus: The short localizable label for the status.
	DisplayStatus *string `json:"displayStatus,omitempty"`

	// Level: The level code.
	Level *InstanceViewStatus_Level_STATUS `json:"level,omitempty"`

	// Message: The detailed status message, including for alerts and error messages.
	Message *string `json:"message,omitempty"`

	// Time: The time of the status.
	Time *string `json:"time,omitempty"`
}

var _ genruntime.FromARMConverter = &InstanceViewStatus_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (status *InstanceViewStatus_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.InstanceViewStatus_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (status *InstanceViewStatus_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.InstanceViewStatus_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.InstanceViewStatus_STATUS, got %T", armInput)
	}

	// Set property "Code":
	if typedInput.Code != nil {
		code := *typedInput.Code
		status.Code = &code
	}

	// Set property "DisplayStatus":
	if typedInput.DisplayStatus != nil {
		displayStatus := *typedInput.DisplayStatus
		status.DisplayStatus = &displayStatus
	}

	// Set property "Level":
	if typedInput.Level != nil {
		var temp string
		temp = string(*typedInput.Level)
		level := InstanceViewStatus_Level_STATUS(temp)
		status.Level = &level
	}

	// Set property "Message":
	if typedInput.Message != nil {
		message := *typedInput.Message
		status.Message = &message
	}

	// Set property "Time":
	if typedInput.Time != nil {
		time := *typedInput.Time
		status.Time = &time
	}

	// No error
	return nil
}

// AssignProperties_From_InstanceViewStatus_STATUS populates our InstanceViewStatus_STATUS from the provided source InstanceViewStatus_STATUS
func (status *InstanceViewStatus_STATUS) AssignProperties_From_InstanceViewStatus_STATUS(source *storage.InstanceViewStatus_STATUS) error {

	// Code
	status.Code = genruntime.ClonePointerToString(source.Code)

	// DisplayStatus
	status.DisplayStatus = genruntime.ClonePointerToString(source.DisplayStatus)

	// Level
	if source.Level != nil {
		level := *source.Level
		levelTemp := genruntime.ToEnum(level, instanceViewStatus_Level_STATUS_Values)
		status.Level = &levelTemp
	} else {
		status.Level = nil
	}

	// Message
	status.Message = genruntime.ClonePointerToString(source.Message)

	// Time
	status.Time = genruntime.ClonePointerToString(source.Time)

	// No error
	return nil
}

// AssignProperties_To_InstanceViewStatus_STATUS populates the provided destination InstanceViewStatus_STATUS from our InstanceViewStatus_STATUS
func (status *InstanceViewStatus_STATUS) AssignProperties_To_InstanceViewStatus_STATUS(destination *storage.InstanceViewStatus_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Code
	destination.Code = genruntime.ClonePointerToString(status.Code)

	// DisplayStatus
	destination.DisplayStatus = genruntime.ClonePointerToString(status.DisplayStatus)

	// Level
	if status.Level != nil {
		level := string(*status.Level)
		destination.Level = &level
	} else {
		destination.Level = nil
	}

	// Message
	destination.Message = genruntime.ClonePointerToString(status.Message)

	// Time
	destination.Time = genruntime.ClonePointerToString(status.Time)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Specifies the Linux operating system settings on the virtual machine.
// For a list of supported Linux
// distributions, see [Linux on Azure-Endorsed
// Distributions](https://docs.microsoft.com/azure/virtual-machines/linux/endorsed-distros).
type LinuxConfiguration struct {
	// DisablePasswordAuthentication: Specifies whether password authentication should be disabled.
	DisablePasswordAuthentication *bool `json:"disablePasswordAuthentication,omitempty"`

	// PatchSettings: [Preview Feature] Specifies settings related to VM Guest Patching on Linux.
	PatchSettings *LinuxPatchSettings `json:"patchSettings,omitempty"`

	// ProvisionVMAgent: Indicates whether virtual machine agent should be provisioned on the virtual machine.
	// When this property is not specified in the request body, default behavior is to set it to true.  This will ensure that
	// VM Agent is installed on the VM so that extensions can be added to the VM later.
	ProvisionVMAgent *bool `json:"provisionVMAgent,omitempty"`

	// Ssh: Specifies the ssh key configuration for a Linux OS.
	Ssh *SshConfiguration `json:"ssh,omitempty"`
}

var _ genruntime.ARMTransformer = &LinuxConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *LinuxConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.LinuxConfiguration{}

	// Set property "DisablePasswordAuthentication":
	if configuration.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *configuration.DisablePasswordAuthentication
		result.DisablePasswordAuthentication = &disablePasswordAuthentication
	}

	// Set property "PatchSettings":
	if configuration.PatchSettings != nil {
		patchSettings_ARM, err := (*configuration.PatchSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		patchSettings := *patchSettings_ARM.(*arm.LinuxPatchSettings)
		result.PatchSettings = &patchSettings
	}

	// Set property "ProvisionVMAgent":
	if configuration.ProvisionVMAgent != nil {
		provisionVMAgent := *configuration.ProvisionVMAgent
		result.ProvisionVMAgent = &provisionVMAgent
	}

	// Set property "Ssh":
	if configuration.Ssh != nil {
		ssh_ARM, err := (*configuration.Ssh).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		ssh := *ssh_ARM.(*arm.SshConfiguration)
		result.Ssh = &ssh
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *LinuxConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.LinuxConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *LinuxConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.LinuxConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.LinuxConfiguration, got %T", armInput)
	}

	// Set property "DisablePasswordAuthentication":
	if typedInput.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *typedInput.DisablePasswordAuthentication
		configuration.DisablePasswordAuthentication = &disablePasswordAuthentication
	}

	// Set property "PatchSettings":
	if typedInput.PatchSettings != nil {
		var patchSettings1 LinuxPatchSettings
		err := patchSettings1.PopulateFromARM(owner, *typedInput.PatchSettings)
		if err != nil {
			return err
		}
		patchSettings := patchSettings1
		configuration.PatchSettings = &patchSettings
	}

	// Set property "ProvisionVMAgent":
	if typedInput.ProvisionVMAgent != nil {
		provisionVMAgent := *typedInput.ProvisionVMAgent
		configuration.ProvisionVMAgent = &provisionVMAgent
	}

	// Set property "Ssh":
	if typedInput.Ssh != nil {
		var ssh1 SshConfiguration
		err := ssh1.PopulateFromARM(owner, *typedInput.Ssh)
		if err != nil {
			return err
		}
		ssh := ssh1
		configuration.Ssh = &ssh
	}

	// No error
	return nil
}

// AssignProperties_From_LinuxConfiguration populates our LinuxConfiguration from the provided source LinuxConfiguration
func (configuration *LinuxConfiguration) AssignProperties_From_LinuxConfiguration(source *storage.LinuxConfiguration) error {

	// DisablePasswordAuthentication
	if source.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *source.DisablePasswordAuthentication
		configuration.DisablePasswordAuthentication = &disablePasswordAuthentication
	} else {
		configuration.DisablePasswordAuthentication = nil
	}

	// PatchSettings
	if source.PatchSettings != nil {
		var patchSetting LinuxPatchSettings
		err := patchSetting.AssignProperties_From_LinuxPatchSettings(source.PatchSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_LinuxPatchSettings() to populate field PatchSettings")
		}
		configuration.PatchSettings = &patchSetting
	} else {
		configuration.PatchSettings = nil
	}

	// ProvisionVMAgent
	if source.ProvisionVMAgent != nil {
		provisionVMAgent := *source.ProvisionVMAgent
		configuration.ProvisionVMAgent = &provisionVMAgent
	} else {
		configuration.ProvisionVMAgent = nil
	}

	// Ssh
	if source.Ssh != nil {
		var ssh SshConfiguration
		err := ssh.AssignProperties_From_SshConfiguration(source.Ssh)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SshConfiguration() to populate field Ssh")
		}
		configuration.Ssh = &ssh
	} else {
		configuration.Ssh = nil
	}

	// No error
	return nil
}

// AssignProperties_To_LinuxConfiguration populates the provided destination LinuxConfiguration from our LinuxConfiguration
func (configuration *LinuxConfiguration) AssignProperties_To_LinuxConfiguration(destination *storage.LinuxConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DisablePasswordAuthentication
	if configuration.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *configuration.DisablePasswordAuthentication
		destination.DisablePasswordAuthentication = &disablePasswordAuthentication
	} else {
		destination.DisablePasswordAuthentication = nil
	}

	// PatchSettings
	if configuration.PatchSettings != nil {
		var patchSetting storage.LinuxPatchSettings
		err := configuration.PatchSettings.AssignProperties_To_LinuxPatchSettings(&patchSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_LinuxPatchSettings() to populate field PatchSettings")
		}
		destination.PatchSettings = &patchSetting
	} else {
		destination.PatchSettings = nil
	}

	// ProvisionVMAgent
	if configuration.ProvisionVMAgent != nil {
		provisionVMAgent := *configuration.ProvisionVMAgent
		destination.ProvisionVMAgent = &provisionVMAgent
	} else {
		destination.ProvisionVMAgent = nil
	}

	// Ssh
	if configuration.Ssh != nil {
		var ssh storage.SshConfiguration
		err := configuration.Ssh.AssignProperties_To_SshConfiguration(&ssh)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SshConfiguration() to populate field Ssh")
		}
		destination.Ssh = &ssh
	} else {
		destination.Ssh = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_LinuxConfiguration_STATUS populates our LinuxConfiguration from the provided source LinuxConfiguration_STATUS
func (configuration *LinuxConfiguration) Initialize_From_LinuxConfiguration_STATUS(source *LinuxConfiguration_STATUS) error {

	// DisablePasswordAuthentication
	if source.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *source.DisablePasswordAuthentication
		configuration.DisablePasswordAuthentication = &disablePasswordAuthentication
	} else {
		configuration.DisablePasswordAuthentication = nil
	}

	// PatchSettings
	if source.PatchSettings != nil {
		var patchSetting LinuxPatchSettings
		err := patchSetting.Initialize_From_LinuxPatchSettings_STATUS(source.PatchSettings)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_LinuxPatchSettings_STATUS() to populate field PatchSettings")
		}
		configuration.PatchSettings = &patchSetting
	} else {
		configuration.PatchSettings = nil
	}

	// ProvisionVMAgent
	if source.ProvisionVMAgent != nil {
		provisionVMAgent := *source.ProvisionVMAgent
		configuration.ProvisionVMAgent = &provisionVMAgent
	} else {
		configuration.ProvisionVMAgent = nil
	}

	// Ssh
	if source.Ssh != nil {
		var ssh SshConfiguration
		err := ssh.Initialize_From_SshConfiguration_STATUS(source.Ssh)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SshConfiguration_STATUS() to populate field Ssh")
		}
		configuration.Ssh = &ssh
	} else {
		configuration.Ssh = nil
	}

	// No error
	return nil
}

// Specifies the Linux operating system settings on the virtual machine.
// For a list of supported Linux
// distributions, see [Linux on Azure-Endorsed
// Distributions](https://docs.microsoft.com/azure/virtual-machines/linux/endorsed-distros).
type LinuxConfiguration_STATUS struct {
	// DisablePasswordAuthentication: Specifies whether password authentication should be disabled.
	DisablePasswordAuthentication *bool `json:"disablePasswordAuthentication,omitempty"`

	// PatchSettings: [Preview Feature] Specifies settings related to VM Guest Patching on Linux.
	PatchSettings *LinuxPatchSettings_STATUS `json:"patchSettings,omitempty"`

	// ProvisionVMAgent: Indicates whether virtual machine agent should be provisioned on the virtual machine.
	// When this property is not specified in the request body, default behavior is to set it to true.  This will ensure that
	// VM Agent is installed on the VM so that extensions can be added to the VM later.
	ProvisionVMAgent *bool `json:"provisionVMAgent,omitempty"`

	// Ssh: Specifies the ssh key configuration for a Linux OS.
	Ssh *SshConfiguration_STATUS `json:"ssh,omitempty"`
}

var _ genruntime.FromARMConverter = &LinuxConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *LinuxConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.LinuxConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *LinuxConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.LinuxConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.LinuxConfiguration_STATUS, got %T", armInput)
	}

	// Set property "DisablePasswordAuthentication":
	if typedInput.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *typedInput.DisablePasswordAuthentication
		configuration.DisablePasswordAuthentication = &disablePasswordAuthentication
	}

	// Set property "PatchSettings":
	if typedInput.PatchSettings != nil {
		var patchSettings1 LinuxPatchSettings_STATUS
		err := patchSettings1.PopulateFromARM(owner, *typedInput.PatchSettings)
		if err != nil {
			return err
		}
		patchSettings := patchSettings1
		configuration.PatchSettings = &patchSettings
	}

	// Set property "ProvisionVMAgent":
	if typedInput.ProvisionVMAgent != nil {
		provisionVMAgent := *typedInput.ProvisionVMAgent
		configuration.ProvisionVMAgent = &provisionVMAgent
	}

	// Set property "Ssh":
	if typedInput.Ssh != nil {
		var ssh1 SshConfiguration_STATUS
		err := ssh1.PopulateFromARM(owner, *typedInput.Ssh)
		if err != nil {
			return err
		}
		ssh := ssh1
		configuration.Ssh = &ssh
	}

	// No error
	return nil
}

// AssignProperties_From_LinuxConfiguration_STATUS populates our LinuxConfiguration_STATUS from the provided source LinuxConfiguration_STATUS
func (configuration *LinuxConfiguration_STATUS) AssignProperties_From_LinuxConfiguration_STATUS(source *storage.LinuxConfiguration_STATUS) error {

	// DisablePasswordAuthentication
	if source.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *source.DisablePasswordAuthentication
		configuration.DisablePasswordAuthentication = &disablePasswordAuthentication
	} else {
		configuration.DisablePasswordAuthentication = nil
	}

	// PatchSettings
	if source.PatchSettings != nil {
		var patchSetting LinuxPatchSettings_STATUS
		err := patchSetting.AssignProperties_From_LinuxPatchSettings_STATUS(source.PatchSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_LinuxPatchSettings_STATUS() to populate field PatchSettings")
		}
		configuration.PatchSettings = &patchSetting
	} else {
		configuration.PatchSettings = nil
	}

	// ProvisionVMAgent
	if source.ProvisionVMAgent != nil {
		provisionVMAgent := *source.ProvisionVMAgent
		configuration.ProvisionVMAgent = &provisionVMAgent
	} else {
		configuration.ProvisionVMAgent = nil
	}

	// Ssh
	if source.Ssh != nil {
		var ssh SshConfiguration_STATUS
		err := ssh.AssignProperties_From_SshConfiguration_STATUS(source.Ssh)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SshConfiguration_STATUS() to populate field Ssh")
		}
		configuration.Ssh = &ssh
	} else {
		configuration.Ssh = nil
	}

	// No error
	return nil
}

// AssignProperties_To_LinuxConfiguration_STATUS populates the provided destination LinuxConfiguration_STATUS from our LinuxConfiguration_STATUS
func (configuration *LinuxConfiguration_STATUS) AssignProperties_To_LinuxConfiguration_STATUS(destination *storage.LinuxConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DisablePasswordAuthentication
	if configuration.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *configuration.DisablePasswordAuthentication
		destination.DisablePasswordAuthentication = &disablePasswordAuthentication
	} else {
		destination.DisablePasswordAuthentication = nil
	}

	// PatchSettings
	if configuration.PatchSettings != nil {
		var patchSetting storage.LinuxPatchSettings_STATUS
		err := configuration.PatchSettings.AssignProperties_To_LinuxPatchSettings_STATUS(&patchSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_LinuxPatchSettings_STATUS() to populate field PatchSettings")
		}
		destination.PatchSettings = &patchSetting
	} else {
		destination.PatchSettings = nil
	}

	// ProvisionVMAgent
	if configuration.ProvisionVMAgent != nil {
		provisionVMAgent := *configuration.ProvisionVMAgent
		destination.ProvisionVMAgent = &provisionVMAgent
	} else {
		destination.ProvisionVMAgent = nil
	}

	// Ssh
	if configuration.Ssh != nil {
		var ssh storage.SshConfiguration_STATUS
		err := configuration.Ssh.AssignProperties_To_SshConfiguration_STATUS(&ssh)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SshConfiguration_STATUS() to populate field Ssh")
		}
		destination.Ssh = &ssh
	} else {
		destination.Ssh = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Maintenance Operation Status.
type MaintenanceRedeployStatus_STATUS struct {
	// IsCustomerInitiatedMaintenanceAllowed: True, if customer is allowed to perform Maintenance.
	IsCustomerInitiatedMaintenanceAllowed *bool `json:"isCustomerInitiatedMaintenanceAllowed,omitempty"`

	// LastOperationMessage: Message returned for the last Maintenance Operation.
	LastOperationMessage *string `json:"lastOperationMessage,omitempty"`

	// LastOperationResultCode: The Last Maintenance Operation Result Code.
	LastOperationResultCode *MaintenanceRedeployStatus_LastOperationResultCode_STATUS `json:"lastOperationResultCode,omitempty"`

	// MaintenanceWindowEndTime: End Time for the Maintenance Window.
	MaintenanceWindowEndTime *string `json:"maintenanceWindowEndTime,omitempty"`

	// MaintenanceWindowStartTime: Start Time for the Maintenance Window.
	MaintenanceWindowStartTime *string `json:"maintenanceWindowStartTime,omitempty"`

	// PreMaintenanceWindowEndTime: End Time for the Pre Maintenance Window.
	PreMaintenanceWindowEndTime *string `json:"preMaintenanceWindowEndTime,omitempty"`

	// PreMaintenanceWindowStartTime: Start Time for the Pre Maintenance Window.
	PreMaintenanceWindowStartTime *string `json:"preMaintenanceWindowStartTime,omitempty"`
}

var _ genruntime.FromARMConverter = &MaintenanceRedeployStatus_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (status *MaintenanceRedeployStatus_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.MaintenanceRedeployStatus_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (status *MaintenanceRedeployStatus_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.MaintenanceRedeployStatus_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.MaintenanceRedeployStatus_STATUS, got %T", armInput)
	}

	// Set property "IsCustomerInitiatedMaintenanceAllowed":
	if typedInput.IsCustomerInitiatedMaintenanceAllowed != nil {
		isCustomerInitiatedMaintenanceAllowed := *typedInput.IsCustomerInitiatedMaintenanceAllowed
		status.IsCustomerInitiatedMaintenanceAllowed = &isCustomerInitiatedMaintenanceAllowed
	}

	// Set property "LastOperationMessage":
	if typedInput.LastOperationMessage != nil {
		lastOperationMessage := *typedInput.LastOperationMessage
		status.LastOperationMessage = &lastOperationMessage
	}

	// Set property "LastOperationResultCode":
	if typedInput.LastOperationResultCode != nil {
		var temp string
		temp = string(*typedInput.LastOperationResultCode)
		lastOperationResultCode := MaintenanceRedeployStatus_LastOperationResultCode_STATUS(temp)
		status.LastOperationResultCode = &lastOperationResultCode
	}

	// Set property "MaintenanceWindowEndTime":
	if typedInput.MaintenanceWindowEndTime != nil {
		maintenanceWindowEndTime := *typedInput.MaintenanceWindowEndTime
		status.MaintenanceWindowEndTime = &maintenanceWindowEndTime
	}

	// Set property "MaintenanceWindowStartTime":
	if typedInput.MaintenanceWindowStartTime != nil {
		maintenanceWindowStartTime := *typedInput.MaintenanceWindowStartTime
		status.MaintenanceWindowStartTime = &maintenanceWindowStartTime
	}

	// Set property "PreMaintenanceWindowEndTime":
	if typedInput.PreMaintenanceWindowEndTime != nil {
		preMaintenanceWindowEndTime := *typedInput.PreMaintenanceWindowEndTime
		status.PreMaintenanceWindowEndTime = &preMaintenanceWindowEndTime
	}

	// Set property "PreMaintenanceWindowStartTime":
	if typedInput.PreMaintenanceWindowStartTime != nil {
		preMaintenanceWindowStartTime := *typedInput.PreMaintenanceWindowStartTime
		status.PreMaintenanceWindowStartTime = &preMaintenanceWindowStartTime
	}

	// No error
	return nil
}

// AssignProperties_From_MaintenanceRedeployStatus_STATUS populates our MaintenanceRedeployStatus_STATUS from the provided source MaintenanceRedeployStatus_STATUS
func (status *MaintenanceRedeployStatus_STATUS) AssignProperties_From_MaintenanceRedeployStatus_STATUS(source *storage.MaintenanceRedeployStatus_STATUS) error {

	// IsCustomerInitiatedMaintenanceAllowed
	if source.IsCustomerInitiatedMaintenanceAllowed != nil {
		isCustomerInitiatedMaintenanceAllowed := *source.IsCustomerInitiatedMaintenanceAllowed
		status.IsCustomerInitiatedMaintenanceAllowed = &isCustomerInitiatedMaintenanceAllowed
	} else {
		status.IsCustomerInitiatedMaintenanceAllowed = nil
	}

	// LastOperationMessage
	status.LastOperationMessage = genruntime.ClonePointerToString(source.LastOperationMessage)

	// LastOperationResultCode
	if source.LastOperationResultCode != nil {
		lastOperationResultCode := *source.LastOperationResultCode
		lastOperationResultCodeTemp := genruntime.ToEnum(lastOperationResultCode, maintenanceRedeployStatus_LastOperationResultCode_STATUS_Values)
		status.LastOperationResultCode = &lastOperationResultCodeTemp
	} else {
		status.LastOperationResultCode = nil
	}

	// MaintenanceWindowEndTime
	status.MaintenanceWindowEndTime = genruntime.ClonePointerToString(source.MaintenanceWindowEndTime)

	// MaintenanceWindowStartTime
	status.MaintenanceWindowStartTime = genruntime.ClonePointerToString(source.MaintenanceWindowStartTime)

	// PreMaintenanceWindowEndTime
	status.PreMaintenanceWindowEndTime = genruntime.ClonePointerToString(source.PreMaintenanceWindowEndTime)

	// PreMaintenanceWindowStartTime
	status.PreMaintenanceWindowStartTime = genruntime.ClonePointerToString(source.PreMaintenanceWindowStartTime)

	// No error
	return nil
}

// AssignProperties_To_MaintenanceRedeployStatus_STATUS populates the provided destination MaintenanceRedeployStatus_STATUS from our MaintenanceRedeployStatus_STATUS
func (status *MaintenanceRedeployStatus_STATUS) AssignProperties_To_MaintenanceRedeployStatus_STATUS(destination *storage.MaintenanceRedeployStatus_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IsCustomerInitiatedMaintenanceAllowed
	if status.IsCustomerInitiatedMaintenanceAllowed != nil {
		isCustomerInitiatedMaintenanceAllowed := *status.IsCustomerInitiatedMaintenanceAllowed
		destination.IsCustomerInitiatedMaintenanceAllowed = &isCustomerInitiatedMaintenanceAllowed
	} else {
		destination.IsCustomerInitiatedMaintenanceAllowed = nil
	}

	// LastOperationMessage
	destination.LastOperationMessage = genruntime.ClonePointerToString(status.LastOperationMessage)

	// LastOperationResultCode
	if status.LastOperationResultCode != nil {
		lastOperationResultCode := string(*status.LastOperationResultCode)
		destination.LastOperationResultCode = &lastOperationResultCode
	} else {
		destination.LastOperationResultCode = nil
	}

	// MaintenanceWindowEndTime
	destination.MaintenanceWindowEndTime = genruntime.ClonePointerToString(status.MaintenanceWindowEndTime)

	// MaintenanceWindowStartTime
	destination.MaintenanceWindowStartTime = genruntime.ClonePointerToString(status.MaintenanceWindowStartTime)

	// PreMaintenanceWindowEndTime
	destination.PreMaintenanceWindowEndTime = genruntime.ClonePointerToString(status.PreMaintenanceWindowEndTime)

	// PreMaintenanceWindowStartTime
	destination.PreMaintenanceWindowStartTime = genruntime.ClonePointerToString(status.PreMaintenanceWindowStartTime)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes a network interface reference.
type NetworkInterfaceReference struct {
	// DeleteOption: Specify what happens to the network interface when the VM is deleted
	DeleteOption *NetworkInterfaceReferenceProperties_DeleteOption `json:"deleteOption,omitempty"`

	// Primary: Specifies the primary network interface in case the virtual machine has more than 1 network interface.
	Primary *bool `json:"primary,omitempty"`

	// Reference: Resource Id
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &NetworkInterfaceReference{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (reference *NetworkInterfaceReference) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if reference == nil {
		return nil, nil
	}
	result := &arm.NetworkInterfaceReference{}

	// Set property "Id":
	if reference.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*reference.Reference)
		if err != nil {
			return nil, err
		}
		reference1 := referenceARMID
		result.Id = &reference1
	}

	// Set property "Properties":
	if reference.DeleteOption != nil || reference.Primary != nil {
		result.Properties = &arm.NetworkInterfaceReferenceProperties{}
	}
	if reference.DeleteOption != nil {
		var temp string
		temp = string(*reference.DeleteOption)
		deleteOption := arm.NetworkInterfaceReferenceProperties_DeleteOption(temp)
		result.Properties.DeleteOption = &deleteOption
	}
	if reference.Primary != nil {
		primary := *reference.Primary
		result.Properties.Primary = &primary
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *NetworkInterfaceReference) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NetworkInterfaceReference{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *NetworkInterfaceReference) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NetworkInterfaceReference)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NetworkInterfaceReference, got %T", armInput)
	}

	// Set property "DeleteOption":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DeleteOption != nil {
			var temp string
			temp = string(*typedInput.Properties.DeleteOption)
			deleteOption := NetworkInterfaceReferenceProperties_DeleteOption(temp)
			reference.DeleteOption = &deleteOption
		}
	}

	// Set property "Primary":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			reference.Primary = &primary
		}
	}

	// no assignment for property "Reference"

	// No error
	return nil
}

// AssignProperties_From_NetworkInterfaceReference populates our NetworkInterfaceReference from the provided source NetworkInterfaceReference
func (reference *NetworkInterfaceReference) AssignProperties_From_NetworkInterfaceReference(source *storage.NetworkInterfaceReference) error {

	// DeleteOption
	if source.DeleteOption != nil {
		deleteOption := *source.DeleteOption
		deleteOptionTemp := genruntime.ToEnum(deleteOption, networkInterfaceReferenceProperties_DeleteOption_Values)
		reference.DeleteOption = &deleteOptionTemp
	} else {
		reference.DeleteOption = nil
	}

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		reference.Primary = &primary
	} else {
		reference.Primary = nil
	}

	// Reference
	if source.Reference != nil {
		referenceTemp := source.Reference.Copy()
		reference.Reference = &referenceTemp
	} else {
		reference.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_NetworkInterfaceReference populates the provided destination NetworkInterfaceReference from our NetworkInterfaceReference
func (reference *NetworkInterfaceReference) AssignProperties_To_NetworkInterfaceReference(destination *storage.NetworkInterfaceReference) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DeleteOption
	if reference.DeleteOption != nil {
		deleteOption := string(*reference.DeleteOption)
		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// Primary
	if reference.Primary != nil {
		primary := *reference.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// Reference
	if reference.Reference != nil {
		referenceTemp := reference.Reference.Copy()
		destination.Reference = &referenceTemp
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_NetworkInterfaceReference_STATUS populates our NetworkInterfaceReference from the provided source NetworkInterfaceReference_STATUS
func (reference *NetworkInterfaceReference) Initialize_From_NetworkInterfaceReference_STATUS(source *NetworkInterfaceReference_STATUS) error {

	// DeleteOption
	if source.DeleteOption != nil {
		deleteOption := genruntime.ToEnum(string(*source.DeleteOption), networkInterfaceReferenceProperties_DeleteOption_Values)
		reference.DeleteOption = &deleteOption
	} else {
		reference.DeleteOption = nil
	}

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		reference.Primary = &primary
	} else {
		reference.Primary = nil
	}

	// Reference
	if source.Id != nil {
		referenceTemp := genruntime.CreateResourceReferenceFromARMID(*source.Id)
		reference.Reference = &referenceTemp
	} else {
		reference.Reference = nil
	}

	// No error
	return nil
}

// Describes a network interface reference.
type NetworkInterfaceReference_STATUS struct {
	// DeleteOption: Specify what happens to the network interface when the VM is deleted
	DeleteOption *NetworkInterfaceReferenceProperties_DeleteOption_STATUS `json:"deleteOption,omitempty"`

	// Id: Resource Id
	Id *string `json:"id,omitempty"`

	// Primary: Specifies the primary network interface in case the virtual machine has more than 1 network interface.
	Primary *bool `json:"primary,omitempty"`
}

var _ genruntime.FromARMConverter = &NetworkInterfaceReference_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *NetworkInterfaceReference_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NetworkInterfaceReference_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *NetworkInterfaceReference_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NetworkInterfaceReference_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NetworkInterfaceReference_STATUS, got %T", armInput)
	}

	// Set property "DeleteOption":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DeleteOption != nil {
			var temp string
			temp = string(*typedInput.Properties.DeleteOption)
			deleteOption := NetworkInterfaceReferenceProperties_DeleteOption_STATUS(temp)
			reference.DeleteOption = &deleteOption
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		reference.Id = &id
	}

	// Set property "Primary":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			reference.Primary = &primary
		}
	}

	// No error
	return nil
}

// AssignProperties_From_NetworkInterfaceReference_STATUS populates our NetworkInterfaceReference_STATUS from the provided source NetworkInterfaceReference_STATUS
func (reference *NetworkInterfaceReference_STATUS) AssignProperties_From_NetworkInterfaceReference_STATUS(source *storage.NetworkInterfaceReference_STATUS) error {

	// DeleteOption
	if source.DeleteOption != nil {
		deleteOption := *source.DeleteOption
		deleteOptionTemp := genruntime.ToEnum(deleteOption, networkInterfaceReferenceProperties_DeleteOption_STATUS_Values)
		reference.DeleteOption = &deleteOptionTemp
	} else {
		reference.DeleteOption = nil
	}

	// Id
	reference.Id = genruntime.ClonePointerToString(source.Id)

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		reference.Primary = &primary
	} else {
		reference.Primary = nil
	}

	// No error
	return nil
}

// AssignProperties_To_NetworkInterfaceReference_STATUS populates the provided destination NetworkInterfaceReference_STATUS from our NetworkInterfaceReference_STATUS
func (reference *NetworkInterfaceReference_STATUS) AssignProperties_To_NetworkInterfaceReference_STATUS(destination *storage.NetworkInterfaceReference_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DeleteOption
	if reference.DeleteOption != nil {
		deleteOption := string(*reference.DeleteOption)
		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(reference.Id)

	// Primary
	if reference.Primary != nil {
		primary := *reference.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"2020-11-01"}
type NetworkProfile_NetworkApiVersion string

const NetworkProfile_NetworkApiVersion_20201101 = NetworkProfile_NetworkApiVersion("2020-11-01")

// Mapping from string to NetworkProfile_NetworkApiVersion
var networkProfile_NetworkApiVersion_Values = map[string]NetworkProfile_NetworkApiVersion{
	"2020-11-01": NetworkProfile_NetworkApiVersion_20201101,
}

type NetworkProfile_NetworkApiVersion_STATUS string

const NetworkProfile_NetworkApiVersion_STATUS_20201101 = NetworkProfile_NetworkApiVersion_STATUS("2020-11-01")

// Mapping from string to NetworkProfile_NetworkApiVersion_STATUS
var networkProfile_NetworkApiVersion_STATUS_Values = map[string]NetworkProfile_NetworkApiVersion_STATUS{
	"2020-11-01": NetworkProfile_NetworkApiVersion_STATUS_20201101,
}

// Specifies information about the operating system disk used by the virtual machine.
// For more information about
// disks, see [About disks and VHDs for Azure virtual
// machines](https://docs.microsoft.com/azure/virtual-machines/managed-disks-overview).
type OSDisk struct {
	// Caching: Specifies the caching requirements.
	// Possible values are:
	// None
	// ReadOnly
	// ReadWrite
	// Default: None for Standard storage. ReadOnly for Premium storage.
	Caching *Caching `json:"caching,omitempty"`

	// +kubebuilder:validation:Required
	// CreateOption: Specifies how the virtual machine should be created.
	// Possible values are:
	// Attach \u2013 This value is used when you are using a specialized disk to create the virtual machine.
	// FromImage \u2013 This value is used when you are using an image to create the virtual machine. If you are using a
	// platform image, you also use the imageReference element described above. If you are using a marketplace image, you  also
	// use the plan element previously described.
	CreateOption *CreateOption `json:"createOption,omitempty"`

	// DeleteOption: Specifies whether OS Disk should be deleted or detached upon VM deletion.
	// Possible values:
	// Delete If this value is used, the OS disk is deleted when VM is deleted.
	// Detach If this value is used, the os disk is retained after VM is deleted.
	// The default value is set to detach. For an ephemeral OS Disk, the default value is set to Delete. User cannot change the
	// delete option for ephemeral OS Disk.
	DeleteOption *DeleteOption `json:"deleteOption,omitempty"`

	// DiffDiskSettings: Specifies the ephemeral Disk Settings for the operating system disk used by the virtual machine.
	DiffDiskSettings *DiffDiskSettings `json:"diffDiskSettings,omitempty"`

	// DiskSizeGB: Specifies the size of an empty data disk in gigabytes. This element can be used to overwrite the size of the
	// disk in a virtual machine image.
	// This value cannot be larger than 1023 GB
	DiskSizeGB *int `json:"diskSizeGB,omitempty"`

	// EncryptionSettings: Specifies the encryption settings for the OS Disk.
	// Minimum api-version: 2015-06-15
	EncryptionSettings *DiskEncryptionSettings `json:"encryptionSettings,omitempty"`

	// Image: The source user image virtual hard disk. The virtual hard disk will be copied before being attached to the
	// virtual machine. If SourceImage is provided, the destination virtual hard drive must not exist.
	Image *VirtualHardDisk `json:"image,omitempty"`

	// ManagedDisk: The managed disk parameters.
	ManagedDisk *ManagedDiskParameters `json:"managedDisk,omitempty"`

	// Name: The disk name.
	Name *string `json:"name,omitempty"`

	// OsType: This property allows you to specify the type of the OS that is included in the disk if creating a VM from
	// user-image or a specialized VHD.
	// Possible values are:
	// Windows
	// Linux
	OsType *OSDisk_OsType `json:"osType,omitempty"`

	// Vhd: The virtual hard disk.
	Vhd *VirtualHardDisk `json:"vhd,omitempty"`

	// WriteAcceleratorEnabled: Specifies whether writeAccelerator should be enabled or disabled on the disk.
	WriteAcceleratorEnabled *bool `json:"writeAcceleratorEnabled,omitempty"`
}

var _ genruntime.ARMTransformer = &OSDisk{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (disk *OSDisk) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if disk == nil {
		return nil, nil
	}
	result := &arm.OSDisk{}

	// Set property "Caching":
	if disk.Caching != nil {
		var temp string
		temp = string(*disk.Caching)
		caching := arm.Caching(temp)
		result.Caching = &caching
	}

	// Set property "CreateOption":
	if disk.CreateOption != nil {
		var temp string
		temp = string(*disk.CreateOption)
		createOption := arm.CreateOption(temp)
		result.CreateOption = &createOption
	}

	// Set property "DeleteOption":
	if disk.DeleteOption != nil {
		var temp string
		temp = string(*disk.DeleteOption)
		deleteOption := arm.DeleteOption(temp)
		result.DeleteOption = &deleteOption
	}

	// Set property "DiffDiskSettings":
	if disk.DiffDiskSettings != nil {
		diffDiskSettings_ARM, err := (*disk.DiffDiskSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		diffDiskSettings := *diffDiskSettings_ARM.(*arm.DiffDiskSettings)
		result.DiffDiskSettings = &diffDiskSettings
	}

	// Set property "DiskSizeGB":
	if disk.DiskSizeGB != nil {
		diskSizeGB := *disk.DiskSizeGB
		result.DiskSizeGB = &diskSizeGB
	}

	// Set property "EncryptionSettings":
	if disk.EncryptionSettings != nil {
		encryptionSettings_ARM, err := (*disk.EncryptionSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		encryptionSettings := *encryptionSettings_ARM.(*arm.DiskEncryptionSettings)
		result.EncryptionSettings = &encryptionSettings
	}

	// Set property "Image":
	if disk.Image != nil {
		image_ARM, err := (*disk.Image).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		image := *image_ARM.(*arm.VirtualHardDisk)
		result.Image = &image
	}

	// Set property "ManagedDisk":
	if disk.ManagedDisk != nil {
		managedDisk_ARM, err := (*disk.ManagedDisk).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		managedDisk := *managedDisk_ARM.(*arm.ManagedDiskParameters)
		result.ManagedDisk = &managedDisk
	}

	// Set property "Name":
	if disk.Name != nil {
		name := *disk.Name
		result.Name = &name
	}

	// Set property "OsType":
	if disk.OsType != nil {
		var temp string
		temp = string(*disk.OsType)
		osType := arm.OSDisk_OsType(temp)
		result.OsType = &osType
	}

	// Set property "Vhd":
	if disk.Vhd != nil {
		vhd_ARM, err := (*disk.Vhd).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		vhd := *vhd_ARM.(*arm.VirtualHardDisk)
		result.Vhd = &vhd
	}

	// Set property "WriteAcceleratorEnabled":
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		result.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (disk *OSDisk) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.OSDisk{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (disk *OSDisk) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.OSDisk)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.OSDisk, got %T", armInput)
	}

	// Set property "Caching":
	if typedInput.Caching != nil {
		var temp string
		temp = string(*typedInput.Caching)
		caching := Caching(temp)
		disk.Caching = &caching
	}

	// Set property "CreateOption":
	if typedInput.CreateOption != nil {
		var temp string
		temp = string(*typedInput.CreateOption)
		createOption := CreateOption(temp)
		disk.CreateOption = &createOption
	}

	// Set property "DeleteOption":
	if typedInput.DeleteOption != nil {
		var temp string
		temp = string(*typedInput.DeleteOption)
		deleteOption := DeleteOption(temp)
		disk.DeleteOption = &deleteOption
	}

	// Set property "DiffDiskSettings":
	if typedInput.DiffDiskSettings != nil {
		var diffDiskSettings1 DiffDiskSettings
		err := diffDiskSettings1.PopulateFromARM(owner, *typedInput.DiffDiskSettings)
		if err != nil {
			return err
		}
		diffDiskSettings := diffDiskSettings1
		disk.DiffDiskSettings = &diffDiskSettings
	}

	// Set property "DiskSizeGB":
	if typedInput.DiskSizeGB != nil {
		diskSizeGB := *typedInput.DiskSizeGB
		disk.DiskSizeGB = &diskSizeGB
	}

	// Set property "EncryptionSettings":
	if typedInput.EncryptionSettings != nil {
		var encryptionSettings1 DiskEncryptionSettings
		err := encryptionSettings1.PopulateFromARM(owner, *typedInput.EncryptionSettings)
		if err != nil {
			return err
		}
		encryptionSettings := encryptionSettings1
		disk.EncryptionSettings = &encryptionSettings
	}

	// Set property "Image":
	if typedInput.Image != nil {
		var image1 VirtualHardDisk
		err := image1.PopulateFromARM(owner, *typedInput.Image)
		if err != nil {
			return err
		}
		image := image1
		disk.Image = &image
	}

	// Set property "ManagedDisk":
	if typedInput.ManagedDisk != nil {
		var managedDisk1 ManagedDiskParameters
		err := managedDisk1.PopulateFromARM(owner, *typedInput.ManagedDisk)
		if err != nil {
			return err
		}
		managedDisk := managedDisk1
		disk.ManagedDisk = &managedDisk
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		disk.Name = &name
	}

	// Set property "OsType":
	if typedInput.OsType != nil {
		var temp string
		temp = string(*typedInput.OsType)
		osType := OSDisk_OsType(temp)
		disk.OsType = &osType
	}

	// Set property "Vhd":
	if typedInput.Vhd != nil {
		var vhd1 VirtualHardDisk
		err := vhd1.PopulateFromARM(owner, *typedInput.Vhd)
		if err != nil {
			return err
		}
		vhd := vhd1
		disk.Vhd = &vhd
	}

	// Set property "WriteAcceleratorEnabled":
	if typedInput.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *typedInput.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}

	// No error
	return nil
}

// AssignProperties_From_OSDisk populates our OSDisk from the provided source OSDisk
func (disk *OSDisk) AssignProperties_From_OSDisk(source *storage.OSDisk) error {

	// Caching
	if source.Caching != nil {
		caching := *source.Caching
		cachingTemp := genruntime.ToEnum(caching, caching_Values)
		disk.Caching = &cachingTemp
	} else {
		disk.Caching = nil
	}

	// CreateOption
	if source.CreateOption != nil {
		createOption := *source.CreateOption
		createOptionTemp := genruntime.ToEnum(createOption, createOption_Values)
		disk.CreateOption = &createOptionTemp
	} else {
		disk.CreateOption = nil
	}

	// DeleteOption
	if source.DeleteOption != nil {
		deleteOption := *source.DeleteOption
		deleteOptionTemp := genruntime.ToEnum(deleteOption, deleteOption_Values)
		disk.DeleteOption = &deleteOptionTemp
	} else {
		disk.DeleteOption = nil
	}

	// DiffDiskSettings
	if source.DiffDiskSettings != nil {
		var diffDiskSetting DiffDiskSettings
		err := diffDiskSetting.AssignProperties_From_DiffDiskSettings(source.DiffDiskSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DiffDiskSettings() to populate field DiffDiskSettings")
		}
		disk.DiffDiskSettings = &diffDiskSetting
	} else {
		disk.DiffDiskSettings = nil
	}

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// EncryptionSettings
	if source.EncryptionSettings != nil {
		var encryptionSetting DiskEncryptionSettings
		err := encryptionSetting.AssignProperties_From_DiskEncryptionSettings(source.EncryptionSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DiskEncryptionSettings() to populate field EncryptionSettings")
		}
		disk.EncryptionSettings = &encryptionSetting
	} else {
		disk.EncryptionSettings = nil
	}

	// Image
	if source.Image != nil {
		var image VirtualHardDisk
		err := image.AssignProperties_From_VirtualHardDisk(source.Image)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualHardDisk() to populate field Image")
		}
		disk.Image = &image
	} else {
		disk.Image = nil
	}

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk ManagedDiskParameters
		err := managedDisk.AssignProperties_From_ManagedDiskParameters(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedDiskParameters() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// OsType
	if source.OsType != nil {
		osType := *source.OsType
		osTypeTemp := genruntime.ToEnum(osType, oSDisk_OsType_Values)
		disk.OsType = &osTypeTemp
	} else {
		disk.OsType = nil
	}

	// Vhd
	if source.Vhd != nil {
		var vhd VirtualHardDisk
		err := vhd.AssignProperties_From_VirtualHardDisk(source.Vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualHardDisk() to populate field Vhd")
		}
		disk.Vhd = &vhd
	} else {
		disk.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_OSDisk populates the provided destination OSDisk from our OSDisk
func (disk *OSDisk) AssignProperties_To_OSDisk(destination *storage.OSDisk) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Caching
	if disk.Caching != nil {
		caching := string(*disk.Caching)
		destination.Caching = &caching
	} else {
		destination.Caching = nil
	}

	// CreateOption
	if disk.CreateOption != nil {
		createOption := string(*disk.CreateOption)
		destination.CreateOption = &createOption
	} else {
		destination.CreateOption = nil
	}

	// DeleteOption
	if disk.DeleteOption != nil {
		deleteOption := string(*disk.DeleteOption)
		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// DiffDiskSettings
	if disk.DiffDiskSettings != nil {
		var diffDiskSetting storage.DiffDiskSettings
		err := disk.DiffDiskSettings.AssignProperties_To_DiffDiskSettings(&diffDiskSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DiffDiskSettings() to populate field DiffDiskSettings")
		}
		destination.DiffDiskSettings = &diffDiskSetting
	} else {
		destination.DiffDiskSettings = nil
	}

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// EncryptionSettings
	if disk.EncryptionSettings != nil {
		var encryptionSetting storage.DiskEncryptionSettings
		err := disk.EncryptionSettings.AssignProperties_To_DiskEncryptionSettings(&encryptionSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DiskEncryptionSettings() to populate field EncryptionSettings")
		}
		destination.EncryptionSettings = &encryptionSetting
	} else {
		destination.EncryptionSettings = nil
	}

	// Image
	if disk.Image != nil {
		var image storage.VirtualHardDisk
		err := disk.Image.AssignProperties_To_VirtualHardDisk(&image)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualHardDisk() to populate field Image")
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk storage.ManagedDiskParameters
		err := disk.ManagedDisk.AssignProperties_To_ManagedDiskParameters(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedDiskParameters() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// OsType
	if disk.OsType != nil {
		osType := string(*disk.OsType)
		destination.OsType = &osType
	} else {
		destination.OsType = nil
	}

	// Vhd
	if disk.Vhd != nil {
		var vhd storage.VirtualHardDisk
		err := disk.Vhd.AssignProperties_To_VirtualHardDisk(&vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualHardDisk() to populate field Vhd")
		}
		destination.Vhd = &vhd
	} else {
		destination.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_OSDisk_STATUS populates our OSDisk from the provided source OSDisk_STATUS
func (disk *OSDisk) Initialize_From_OSDisk_STATUS(source *OSDisk_STATUS) error {

	// Caching
	if source.Caching != nil {
		caching := genruntime.ToEnum(string(*source.Caching), caching_Values)
		disk.Caching = &caching
	} else {
		disk.Caching = nil
	}

	// CreateOption
	if source.CreateOption != nil {
		createOption := genruntime.ToEnum(string(*source.CreateOption), createOption_Values)
		disk.CreateOption = &createOption
	} else {
		disk.CreateOption = nil
	}

	// DeleteOption
	if source.DeleteOption != nil {
		deleteOption := genruntime.ToEnum(string(*source.DeleteOption), deleteOption_Values)
		disk.DeleteOption = &deleteOption
	} else {
		disk.DeleteOption = nil
	}

	// DiffDiskSettings
	if source.DiffDiskSettings != nil {
		var diffDiskSetting DiffDiskSettings
		err := diffDiskSetting.Initialize_From_DiffDiskSettings_STATUS(source.DiffDiskSettings)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DiffDiskSettings_STATUS() to populate field DiffDiskSettings")
		}
		disk.DiffDiskSettings = &diffDiskSetting
	} else {
		disk.DiffDiskSettings = nil
	}

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// EncryptionSettings
	if source.EncryptionSettings != nil {
		var encryptionSetting DiskEncryptionSettings
		err := encryptionSetting.Initialize_From_DiskEncryptionSettings_STATUS(source.EncryptionSettings)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DiskEncryptionSettings_STATUS() to populate field EncryptionSettings")
		}
		disk.EncryptionSettings = &encryptionSetting
	} else {
		disk.EncryptionSettings = nil
	}

	// Image
	if source.Image != nil {
		var image VirtualHardDisk
		err := image.Initialize_From_VirtualHardDisk_STATUS(source.Image)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_VirtualHardDisk_STATUS() to populate field Image")
		}
		disk.Image = &image
	} else {
		disk.Image = nil
	}

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk ManagedDiskParameters
		err := managedDisk.Initialize_From_ManagedDiskParameters_STATUS(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ManagedDiskParameters_STATUS() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// OsType
	if source.OsType != nil {
		osType := genruntime.ToEnum(string(*source.OsType), oSDisk_OsType_Values)
		disk.OsType = &osType
	} else {
		disk.OsType = nil
	}

	// Vhd
	if source.Vhd != nil {
		var vhd VirtualHardDisk
		err := vhd.Initialize_From_VirtualHardDisk_STATUS(source.Vhd)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_VirtualHardDisk_STATUS() to populate field Vhd")
		}
		disk.Vhd = &vhd
	} else {
		disk.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// No error
	return nil
}

// Specifies information about the operating system disk used by the virtual machine.
// For more information about
// disks, see [About disks and VHDs for Azure virtual
// machines](https://docs.microsoft.com/azure/virtual-machines/managed-disks-overview).
type OSDisk_STATUS struct {
	// Caching: Specifies the caching requirements.
	// Possible values are:
	// None
	// ReadOnly
	// ReadWrite
	// Default: None for Standard storage. ReadOnly for Premium storage.
	Caching *Caching_STATUS `json:"caching,omitempty"`

	// CreateOption: Specifies how the virtual machine should be created.
	// Possible values are:
	// Attach \u2013 This value is used when you are using a specialized disk to create the virtual machine.
	// FromImage \u2013 This value is used when you are using an image to create the virtual machine. If you are using a
	// platform image, you also use the imageReference element described above. If you are using a marketplace image, you  also
	// use the plan element previously described.
	CreateOption *CreateOption_STATUS `json:"createOption,omitempty"`

	// DeleteOption: Specifies whether OS Disk should be deleted or detached upon VM deletion.
	// Possible values:
	// Delete If this value is used, the OS disk is deleted when VM is deleted.
	// Detach If this value is used, the os disk is retained after VM is deleted.
	// The default value is set to detach. For an ephemeral OS Disk, the default value is set to Delete. User cannot change the
	// delete option for ephemeral OS Disk.
	DeleteOption *DeleteOption_STATUS `json:"deleteOption,omitempty"`

	// DiffDiskSettings: Specifies the ephemeral Disk Settings for the operating system disk used by the virtual machine.
	DiffDiskSettings *DiffDiskSettings_STATUS `json:"diffDiskSettings,omitempty"`

	// DiskSizeGB: Specifies the size of an empty data disk in gigabytes. This element can be used to overwrite the size of the
	// disk in a virtual machine image.
	// This value cannot be larger than 1023 GB
	DiskSizeGB *int `json:"diskSizeGB,omitempty"`

	// EncryptionSettings: Specifies the encryption settings for the OS Disk.
	// Minimum api-version: 2015-06-15
	EncryptionSettings *DiskEncryptionSettings_STATUS `json:"encryptionSettings,omitempty"`

	// Image: The source user image virtual hard disk. The virtual hard disk will be copied before being attached to the
	// virtual machine. If SourceImage is provided, the destination virtual hard drive must not exist.
	Image *VirtualHardDisk_STATUS `json:"image,omitempty"`

	// ManagedDisk: The managed disk parameters.
	ManagedDisk *ManagedDiskParameters_STATUS `json:"managedDisk,omitempty"`

	// Name: The disk name.
	Name *string `json:"name,omitempty"`

	// OsType: This property allows you to specify the type of the OS that is included in the disk if creating a VM from
	// user-image or a specialized VHD.
	// Possible values are:
	// Windows
	// Linux
	OsType *OSDisk_OsType_STATUS `json:"osType,omitempty"`

	// Vhd: The virtual hard disk.
	Vhd *VirtualHardDisk_STATUS `json:"vhd,omitempty"`

	// WriteAcceleratorEnabled: Specifies whether writeAccelerator should be enabled or disabled on the disk.
	WriteAcceleratorEnabled *bool `json:"writeAcceleratorEnabled,omitempty"`
}

var _ genruntime.FromARMConverter = &OSDisk_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (disk *OSDisk_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.OSDisk_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (disk *OSDisk_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.OSDisk_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.OSDisk_STATUS, got %T", armInput)
	}

	// Set property "Caching":
	if typedInput.Caching != nil {
		var temp string
		temp = string(*typedInput.Caching)
		caching := Caching_STATUS(temp)
		disk.Caching = &caching
	}

	// Set property "CreateOption":
	if typedInput.CreateOption != nil {
		var temp string
		temp = string(*typedInput.CreateOption)
		createOption := CreateOption_STATUS(temp)
		disk.CreateOption = &createOption
	}

	// Set property "DeleteOption":
	if typedInput.DeleteOption != nil {
		var temp string
		temp = string(*typedInput.DeleteOption)
		deleteOption := DeleteOption_STATUS(temp)
		disk.DeleteOption = &deleteOption
	}

	// Set property "DiffDiskSettings":
	if typedInput.DiffDiskSettings != nil {
		var diffDiskSettings1 DiffDiskSettings_STATUS
		err := diffDiskSettings1.PopulateFromARM(owner, *typedInput.DiffDiskSettings)
		if err != nil {
			return err
		}
		diffDiskSettings := diffDiskSettings1
		disk.DiffDiskSettings = &diffDiskSettings
	}

	// Set property "DiskSizeGB":
	if typedInput.DiskSizeGB != nil {
		diskSizeGB := *typedInput.DiskSizeGB
		disk.DiskSizeGB = &diskSizeGB
	}

	// Set property "EncryptionSettings":
	if typedInput.EncryptionSettings != nil {
		var encryptionSettings1 DiskEncryptionSettings_STATUS
		err := encryptionSettings1.PopulateFromARM(owner, *typedInput.EncryptionSettings)
		if err != nil {
			return err
		}
		encryptionSettings := encryptionSettings1
		disk.EncryptionSettings = &encryptionSettings
	}

	// Set property "Image":
	if typedInput.Image != nil {
		var image1 VirtualHardDisk_STATUS
		err := image1.PopulateFromARM(owner, *typedInput.Image)
		if err != nil {
			return err
		}
		image := image1
		disk.Image = &image
	}

	// Set property "ManagedDisk":
	if typedInput.ManagedDisk != nil {
		var managedDisk1 ManagedDiskParameters_STATUS
		err := managedDisk1.PopulateFromARM(owner, *typedInput.ManagedDisk)
		if err != nil {
			return err
		}
		managedDisk := managedDisk1
		disk.ManagedDisk = &managedDisk
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		disk.Name = &name
	}

	// Set property "OsType":
	if typedInput.OsType != nil {
		var temp string
		temp = string(*typedInput.OsType)
		osType := OSDisk_OsType_STATUS(temp)
		disk.OsType = &osType
	}

	// Set property "Vhd":
	if typedInput.Vhd != nil {
		var vhd1 VirtualHardDisk_STATUS
		err := vhd1.PopulateFromARM(owner, *typedInput.Vhd)
		if err != nil {
			return err
		}
		vhd := vhd1
		disk.Vhd = &vhd
	}

	// Set property "WriteAcceleratorEnabled":
	if typedInput.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *typedInput.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}

	// No error
	return nil
}

// AssignProperties_From_OSDisk_STATUS populates our OSDisk_STATUS from the provided source OSDisk_STATUS
func (disk *OSDisk_STATUS) AssignProperties_From_OSDisk_STATUS(source *storage.OSDisk_STATUS) error {

	// Caching
	if source.Caching != nil {
		caching := *source.Caching
		cachingTemp := genruntime.ToEnum(caching, caching_STATUS_Values)
		disk.Caching = &cachingTemp
	} else {
		disk.Caching = nil
	}

	// CreateOption
	if source.CreateOption != nil {
		createOption := *source.CreateOption
		createOptionTemp := genruntime.ToEnum(createOption, createOption_STATUS_Values)
		disk.CreateOption = &createOptionTemp
	} else {
		disk.CreateOption = nil
	}

	// DeleteOption
	if source.DeleteOption != nil {
		deleteOption := *source.DeleteOption
		deleteOptionTemp := genruntime.ToEnum(deleteOption, deleteOption_STATUS_Values)
		disk.DeleteOption = &deleteOptionTemp
	} else {
		disk.DeleteOption = nil
	}

	// DiffDiskSettings
	if source.DiffDiskSettings != nil {
		var diffDiskSetting DiffDiskSettings_STATUS
		err := diffDiskSetting.AssignProperties_From_DiffDiskSettings_STATUS(source.DiffDiskSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DiffDiskSettings_STATUS() to populate field DiffDiskSettings")
		}
		disk.DiffDiskSettings = &diffDiskSetting
	} else {
		disk.DiffDiskSettings = nil
	}

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// EncryptionSettings
	if source.EncryptionSettings != nil {
		var encryptionSetting DiskEncryptionSettings_STATUS
		err := encryptionSetting.AssignProperties_From_DiskEncryptionSettings_STATUS(source.EncryptionSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DiskEncryptionSettings_STATUS() to populate field EncryptionSettings")
		}
		disk.EncryptionSettings = &encryptionSetting
	} else {
		disk.EncryptionSettings = nil
	}

	// Image
	if source.Image != nil {
		var image VirtualHardDisk_STATUS
		err := image.AssignProperties_From_VirtualHardDisk_STATUS(source.Image)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualHardDisk_STATUS() to populate field Image")
		}
		disk.Image = &image
	} else {
		disk.Image = nil
	}

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk ManagedDiskParameters_STATUS
		err := managedDisk.AssignProperties_From_ManagedDiskParameters_STATUS(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedDiskParameters_STATUS() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// OsType
	if source.OsType != nil {
		osType := *source.OsType
		osTypeTemp := genruntime.ToEnum(osType, oSDisk_OsType_STATUS_Values)
		disk.OsType = &osTypeTemp
	} else {
		disk.OsType = nil
	}

	// Vhd
	if source.Vhd != nil {
		var vhd VirtualHardDisk_STATUS
		err := vhd.AssignProperties_From_VirtualHardDisk_STATUS(source.Vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualHardDisk_STATUS() to populate field Vhd")
		}
		disk.Vhd = &vhd
	} else {
		disk.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_OSDisk_STATUS populates the provided destination OSDisk_STATUS from our OSDisk_STATUS
func (disk *OSDisk_STATUS) AssignProperties_To_OSDisk_STATUS(destination *storage.OSDisk_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Caching
	if disk.Caching != nil {
		caching := string(*disk.Caching)
		destination.Caching = &caching
	} else {
		destination.Caching = nil
	}

	// CreateOption
	if disk.CreateOption != nil {
		createOption := string(*disk.CreateOption)
		destination.CreateOption = &createOption
	} else {
		destination.CreateOption = nil
	}

	// DeleteOption
	if disk.DeleteOption != nil {
		deleteOption := string(*disk.DeleteOption)
		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// DiffDiskSettings
	if disk.DiffDiskSettings != nil {
		var diffDiskSetting storage.DiffDiskSettings_STATUS
		err := disk.DiffDiskSettings.AssignProperties_To_DiffDiskSettings_STATUS(&diffDiskSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DiffDiskSettings_STATUS() to populate field DiffDiskSettings")
		}
		destination.DiffDiskSettings = &diffDiskSetting
	} else {
		destination.DiffDiskSettings = nil
	}

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// EncryptionSettings
	if disk.EncryptionSettings != nil {
		var encryptionSetting storage.DiskEncryptionSettings_STATUS
		err := disk.EncryptionSettings.AssignProperties_To_DiskEncryptionSettings_STATUS(&encryptionSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DiskEncryptionSettings_STATUS() to populate field EncryptionSettings")
		}
		destination.EncryptionSettings = &encryptionSetting
	} else {
		destination.EncryptionSettings = nil
	}

	// Image
	if disk.Image != nil {
		var image storage.VirtualHardDisk_STATUS
		err := disk.Image.AssignProperties_To_VirtualHardDisk_STATUS(&image)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualHardDisk_STATUS() to populate field Image")
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk storage.ManagedDiskParameters_STATUS
		err := disk.ManagedDisk.AssignProperties_To_ManagedDiskParameters_STATUS(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedDiskParameters_STATUS() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// OsType
	if disk.OsType != nil {
		osType := string(*disk.OsType)
		destination.OsType = &osType
	} else {
		destination.OsType = nil
	}

	// Vhd
	if disk.Vhd != nil {
		var vhd storage.VirtualHardDisk_STATUS
		err := disk.Vhd.AssignProperties_To_VirtualHardDisk_STATUS(&vhd)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualHardDisk_STATUS() to populate field Vhd")
		}
		destination.Vhd = &vhd
	} else {
		destination.Vhd = nil
	}

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"ConfidentialVM","TrustedLaunch"}
type SecurityProfile_SecurityType string

const (
	SecurityProfile_SecurityType_ConfidentialVM = SecurityProfile_SecurityType("ConfidentialVM")
	SecurityProfile_SecurityType_TrustedLaunch  = SecurityProfile_SecurityType("TrustedLaunch")
)

// Mapping from string to SecurityProfile_SecurityType
var securityProfile_SecurityType_Values = map[string]SecurityProfile_SecurityType{
	"confidentialvm": SecurityProfile_SecurityType_ConfidentialVM,
	"trustedlaunch":  SecurityProfile_SecurityType_TrustedLaunch,
}

type SecurityProfile_SecurityType_STATUS string

const (
	SecurityProfile_SecurityType_STATUS_ConfidentialVM = SecurityProfile_SecurityType_STATUS("ConfidentialVM")
	SecurityProfile_SecurityType_STATUS_TrustedLaunch  = SecurityProfile_SecurityType_STATUS("TrustedLaunch")
)

// Mapping from string to SecurityProfile_SecurityType_STATUS
var securityProfile_SecurityType_STATUS_Values = map[string]SecurityProfile_SecurityType_STATUS{
	"confidentialvm": SecurityProfile_SecurityType_STATUS_ConfidentialVM,
	"trustedlaunch":  SecurityProfile_SecurityType_STATUS_TrustedLaunch,
}

type TerminateNotificationProfile struct {
	// Enable: Specifies whether the Terminate Scheduled event is enabled or disabled.
	Enable *bool `json:"enable,omitempty"`

	// NotBeforeTimeout: Configurable length of time a Virtual Machine being deleted will have to potentially approve the
	// Terminate Scheduled Event before the event is auto approved (timed out). The configuration must be specified in ISO 8601
	// format, the default value is 5 minutes (PT5M)
	NotBeforeTimeout *string `json:"notBeforeTimeout,omitempty"`
}

var _ genruntime.ARMTransformer = &TerminateNotificationProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *TerminateNotificationProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.TerminateNotificationProfile{}

	// Set property "Enable":
	if profile.Enable != nil {
		enable := *profile.Enable
		result.Enable = &enable
	}

	// Set property "NotBeforeTimeout":
	if profile.NotBeforeTimeout != nil {
		notBeforeTimeout := *profile.NotBeforeTimeout
		result.NotBeforeTimeout = &notBeforeTimeout
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *TerminateNotificationProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TerminateNotificationProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *TerminateNotificationProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TerminateNotificationProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TerminateNotificationProfile, got %T", armInput)
	}

	// Set property "Enable":
	if typedInput.Enable != nil {
		enable := *typedInput.Enable
		profile.Enable = &enable
	}

	// Set property "NotBeforeTimeout":
	if typedInput.NotBeforeTimeout != nil {
		notBeforeTimeout := *typedInput.NotBeforeTimeout
		profile.NotBeforeTimeout = &notBeforeTimeout
	}

	// No error
	return nil
}

// AssignProperties_From_TerminateNotificationProfile populates our TerminateNotificationProfile from the provided source TerminateNotificationProfile
func (profile *TerminateNotificationProfile) AssignProperties_From_TerminateNotificationProfile(source *storage.TerminateNotificationProfile) error {

	// Enable
	if source.Enable != nil {
		enable := *source.Enable
		profile.Enable = &enable
	} else {
		profile.Enable = nil
	}

	// NotBeforeTimeout
	profile.NotBeforeTimeout = genruntime.ClonePointerToString(source.NotBeforeTimeout)

	// No error
	return nil
}

// AssignProperties_To_TerminateNotificationProfile populates the provided destination TerminateNotificationProfile from our TerminateNotificationProfile
func (profile *TerminateNotificationProfile) AssignProperties_To_TerminateNotificationProfile(destination *storage.TerminateNotificationProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enable
	if profile.Enable != nil {
		enable := *profile.Enable
		destination.Enable = &enable
	} else {
		destination.Enable = nil
	}

	// NotBeforeTimeout
	destination.NotBeforeTimeout = genruntime.ClonePointerToString(profile.NotBeforeTimeout)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_TerminateNotificationProfile_STATUS populates our TerminateNotificationProfile from the provided source TerminateNotificationProfile_STATUS
func (profile *TerminateNotificationProfile) Initialize_From_TerminateNotificationProfile_STATUS(source *TerminateNotificationProfile_STATUS) error {

	// Enable
	if source.Enable != nil {
		enable := *source.Enable
		profile.Enable = &enable
	} else {
		profile.Enable = nil
	}

	// NotBeforeTimeout
	profile.NotBeforeTimeout = genruntime.ClonePointerToString(source.NotBeforeTimeout)

	// No error
	return nil
}

type TerminateNotificationProfile_STATUS struct {
	// Enable: Specifies whether the Terminate Scheduled event is enabled or disabled.
	Enable *bool `json:"enable,omitempty"`

	// NotBeforeTimeout: Configurable length of time a Virtual Machine being deleted will have to potentially approve the
	// Terminate Scheduled Event before the event is auto approved (timed out). The configuration must be specified in ISO 8601
	// format, the default value is 5 minutes (PT5M)
	NotBeforeTimeout *string `json:"notBeforeTimeout,omitempty"`
}

var _ genruntime.FromARMConverter = &TerminateNotificationProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *TerminateNotificationProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TerminateNotificationProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *TerminateNotificationProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TerminateNotificationProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TerminateNotificationProfile_STATUS, got %T", armInput)
	}

	// Set property "Enable":
	if typedInput.Enable != nil {
		enable := *typedInput.Enable
		profile.Enable = &enable
	}

	// Set property "NotBeforeTimeout":
	if typedInput.NotBeforeTimeout != nil {
		notBeforeTimeout := *typedInput.NotBeforeTimeout
		profile.NotBeforeTimeout = &notBeforeTimeout
	}

	// No error
	return nil
}

// AssignProperties_From_TerminateNotificationProfile_STATUS populates our TerminateNotificationProfile_STATUS from the provided source TerminateNotificationProfile_STATUS
func (profile *TerminateNotificationProfile_STATUS) AssignProperties_From_TerminateNotificationProfile_STATUS(source *storage.TerminateNotificationProfile_STATUS) error {

	// Enable
	if source.Enable != nil {
		enable := *source.Enable
		profile.Enable = &enable
	} else {
		profile.Enable = nil
	}

	// NotBeforeTimeout
	profile.NotBeforeTimeout = genruntime.ClonePointerToString(source.NotBeforeTimeout)

	// No error
	return nil
}

// AssignProperties_To_TerminateNotificationProfile_STATUS populates the provided destination TerminateNotificationProfile_STATUS from our TerminateNotificationProfile_STATUS
func (profile *TerminateNotificationProfile_STATUS) AssignProperties_To_TerminateNotificationProfile_STATUS(destination *storage.TerminateNotificationProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enable
	if profile.Enable != nil {
		enable := *profile.Enable
		destination.Enable = &enable
	} else {
		destination.Enable = nil
	}

	// NotBeforeTimeout
	destination.NotBeforeTimeout = genruntime.ClonePointerToString(profile.NotBeforeTimeout)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Specifies the security settings like secure boot and vTPM used while creating the virtual machine.
// Minimum
// api-version: 2020-12-01
type UefiSettings struct {
	// SecureBootEnabled: Specifies whether secure boot should be enabled on the virtual machine.
	// Minimum api-version: 2020-12-01
	SecureBootEnabled *bool `json:"secureBootEnabled,omitempty"`

	// VTpmEnabled: Specifies whether vTPM should be enabled on the virtual machine.
	// Minimum api-version: 2020-12-01
	VTpmEnabled *bool `json:"vTpmEnabled,omitempty"`
}

var _ genruntime.ARMTransformer = &UefiSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *UefiSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.UefiSettings{}

	// Set property "SecureBootEnabled":
	if settings.SecureBootEnabled != nil {
		secureBootEnabled := *settings.SecureBootEnabled
		result.SecureBootEnabled = &secureBootEnabled
	}

	// Set property "VTpmEnabled":
	if settings.VTpmEnabled != nil {
		vTpmEnabled := *settings.VTpmEnabled
		result.VTpmEnabled = &vTpmEnabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *UefiSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UefiSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *UefiSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UefiSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UefiSettings, got %T", armInput)
	}

	// Set property "SecureBootEnabled":
	if typedInput.SecureBootEnabled != nil {
		secureBootEnabled := *typedInput.SecureBootEnabled
		settings.SecureBootEnabled = &secureBootEnabled
	}

	// Set property "VTpmEnabled":
	if typedInput.VTpmEnabled != nil {
		vTpmEnabled := *typedInput.VTpmEnabled
		settings.VTpmEnabled = &vTpmEnabled
	}

	// No error
	return nil
}

// AssignProperties_From_UefiSettings populates our UefiSettings from the provided source UefiSettings
func (settings *UefiSettings) AssignProperties_From_UefiSettings(source *storage.UefiSettings) error {

	// SecureBootEnabled
	if source.SecureBootEnabled != nil {
		secureBootEnabled := *source.SecureBootEnabled
		settings.SecureBootEnabled = &secureBootEnabled
	} else {
		settings.SecureBootEnabled = nil
	}

	// VTpmEnabled
	if source.VTpmEnabled != nil {
		vTpmEnabled := *source.VTpmEnabled
		settings.VTpmEnabled = &vTpmEnabled
	} else {
		settings.VTpmEnabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UefiSettings populates the provided destination UefiSettings from our UefiSettings
func (settings *UefiSettings) AssignProperties_To_UefiSettings(destination *storage.UefiSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SecureBootEnabled
	if settings.SecureBootEnabled != nil {
		secureBootEnabled := *settings.SecureBootEnabled
		destination.SecureBootEnabled = &secureBootEnabled
	} else {
		destination.SecureBootEnabled = nil
	}

	// VTpmEnabled
	if settings.VTpmEnabled != nil {
		vTpmEnabled := *settings.VTpmEnabled
		destination.VTpmEnabled = &vTpmEnabled
	} else {
		destination.VTpmEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_UefiSettings_STATUS populates our UefiSettings from the provided source UefiSettings_STATUS
func (settings *UefiSettings) Initialize_From_UefiSettings_STATUS(source *UefiSettings_STATUS) error {

	// SecureBootEnabled
	if source.SecureBootEnabled != nil {
		secureBootEnabled := *source.SecureBootEnabled
		settings.SecureBootEnabled = &secureBootEnabled
	} else {
		settings.SecureBootEnabled = nil
	}

	// VTpmEnabled
	if source.VTpmEnabled != nil {
		vTpmEnabled := *source.VTpmEnabled
		settings.VTpmEnabled = &vTpmEnabled
	} else {
		settings.VTpmEnabled = nil
	}

	// No error
	return nil
}

// Specifies the security settings like secure boot and vTPM used while creating the virtual machine.
// Minimum
// api-version: 2020-12-01
type UefiSettings_STATUS struct {
	// SecureBootEnabled: Specifies whether secure boot should be enabled on the virtual machine.
	// Minimum api-version: 2020-12-01
	SecureBootEnabled *bool `json:"secureBootEnabled,omitempty"`

	// VTpmEnabled: Specifies whether vTPM should be enabled on the virtual machine.
	// Minimum api-version: 2020-12-01
	VTpmEnabled *bool `json:"vTpmEnabled,omitempty"`
}

var _ genruntime.FromARMConverter = &UefiSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *UefiSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UefiSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *UefiSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UefiSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UefiSettings_STATUS, got %T", armInput)
	}

	// Set property "SecureBootEnabled":
	if typedInput.SecureBootEnabled != nil {
		secureBootEnabled := *typedInput.SecureBootEnabled
		settings.SecureBootEnabled = &secureBootEnabled
	}

	// Set property "VTpmEnabled":
	if typedInput.VTpmEnabled != nil {
		vTpmEnabled := *typedInput.VTpmEnabled
		settings.VTpmEnabled = &vTpmEnabled
	}

	// No error
	return nil
}

// AssignProperties_From_UefiSettings_STATUS populates our UefiSettings_STATUS from the provided source UefiSettings_STATUS
func (settings *UefiSettings_STATUS) AssignProperties_From_UefiSettings_STATUS(source *storage.UefiSettings_STATUS) error {

	// SecureBootEnabled
	if source.SecureBootEnabled != nil {
		secureBootEnabled := *source.SecureBootEnabled
		settings.SecureBootEnabled = &secureBootEnabled
	} else {
		settings.SecureBootEnabled = nil
	}

	// VTpmEnabled
	if source.VTpmEnabled != nil {
		vTpmEnabled := *source.VTpmEnabled
		settings.VTpmEnabled = &vTpmEnabled
	} else {
		settings.VTpmEnabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UefiSettings_STATUS populates the provided destination UefiSettings_STATUS from our UefiSettings_STATUS
func (settings *UefiSettings_STATUS) AssignProperties_To_UefiSettings_STATUS(destination *storage.UefiSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SecureBootEnabled
	if settings.SecureBootEnabled != nil {
		secureBootEnabled := *settings.SecureBootEnabled
		destination.SecureBootEnabled = &secureBootEnabled
	} else {
		destination.SecureBootEnabled = nil
	}

	// VTpmEnabled
	if settings.VTpmEnabled != nil {
		vTpmEnabled := *settings.VTpmEnabled
		destination.VTpmEnabled = &vTpmEnabled
	} else {
		destination.VTpmEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Information about the user assigned identity for the resource
type UserAssignedIdentityDetails struct {
	Reference genruntime.ResourceReference `armReference:"Reference" json:"reference,omitempty"`
}

// AssignProperties_From_UserAssignedIdentityDetails populates our UserAssignedIdentityDetails from the provided source UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_From_UserAssignedIdentityDetails(source *storage.UserAssignedIdentityDetails) error {

	// Reference
	details.Reference = source.Reference.Copy()

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentityDetails populates the provided destination UserAssignedIdentityDetails from our UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_To_UserAssignedIdentityDetails(destination *storage.UserAssignedIdentityDetails) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	destination.Reference = details.Reference.Copy()

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes a set of certificates which are all in the same Key Vault.
type VaultSecretGroup struct {
	// SourceVault: The relative URL of the Key Vault containing all of the certificates in VaultCertificates.
	SourceVault *SubResource `json:"sourceVault,omitempty"`

	// VaultCertificates: The list of key vault references in SourceVault which contain certificates.
	VaultCertificates []VaultCertificate `json:"vaultCertificates,omitempty"`
}

var _ genruntime.ARMTransformer = &VaultSecretGroup{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (group *VaultSecretGroup) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if group == nil {
		return nil, nil
	}
	result := &arm.VaultSecretGroup{}

	// Set property "SourceVault":
	if group.SourceVault != nil {
		sourceVault_ARM, err := (*group.SourceVault).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sourceVault := *sourceVault_ARM.(*arm.SubResource)
		result.SourceVault = &sourceVault
	}

	// Set property "VaultCertificates":
	for _, item := range group.VaultCertificates {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.VaultCertificates = append(result.VaultCertificates, *item_ARM.(*arm.VaultCertificate))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (group *VaultSecretGroup) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VaultSecretGroup{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (group *VaultSecretGroup) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VaultSecretGroup)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VaultSecretGroup, got %T", armInput)
	}

	// Set property "SourceVault":
	if typedInput.SourceVault != nil {
		var sourceVault1 SubResource
		err := sourceVault1.PopulateFromARM(owner, *typedInput.SourceVault)
		if err != nil {
			return err
		}
		sourceVault := sourceVault1
		group.SourceVault = &sourceVault
	}

	// Set property "VaultCertificates":
	for _, item := range typedInput.VaultCertificates {
		var item1 VaultCertificate
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		group.VaultCertificates = append(group.VaultCertificates, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_VaultSecretGroup populates our VaultSecretGroup from the provided source VaultSecretGroup
func (group *VaultSecretGroup) AssignProperties_From_VaultSecretGroup(source *storage.VaultSecretGroup) error {

	// SourceVault
	if source.SourceVault != nil {
		var sourceVault SubResource
		err := sourceVault.AssignProperties_From_SubResource(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SourceVault")
		}
		group.SourceVault = &sourceVault
	} else {
		group.SourceVault = nil
	}

	// VaultCertificates
	if source.VaultCertificates != nil {
		vaultCertificateList := make([]VaultCertificate, len(source.VaultCertificates))
		for vaultCertificateIndex, vaultCertificateItem := range source.VaultCertificates {
			// Shadow the loop variable to avoid aliasing
			vaultCertificateItem := vaultCertificateItem
			var vaultCertificate VaultCertificate
			err := vaultCertificate.AssignProperties_From_VaultCertificate(&vaultCertificateItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VaultCertificate() to populate field VaultCertificates")
			}
			vaultCertificateList[vaultCertificateIndex] = vaultCertificate
		}
		group.VaultCertificates = vaultCertificateList
	} else {
		group.VaultCertificates = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VaultSecretGroup populates the provided destination VaultSecretGroup from our VaultSecretGroup
func (group *VaultSecretGroup) AssignProperties_To_VaultSecretGroup(destination *storage.VaultSecretGroup) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SourceVault
	if group.SourceVault != nil {
		var sourceVault storage.SubResource
		err := group.SourceVault.AssignProperties_To_SubResource(&sourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SourceVault")
		}
		destination.SourceVault = &sourceVault
	} else {
		destination.SourceVault = nil
	}

	// VaultCertificates
	if group.VaultCertificates != nil {
		vaultCertificateList := make([]storage.VaultCertificate, len(group.VaultCertificates))
		for vaultCertificateIndex, vaultCertificateItem := range group.VaultCertificates {
			// Shadow the loop variable to avoid aliasing
			vaultCertificateItem := vaultCertificateItem
			var vaultCertificate storage.VaultCertificate
			err := vaultCertificateItem.AssignProperties_To_VaultCertificate(&vaultCertificate)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VaultCertificate() to populate field VaultCertificates")
			}
			vaultCertificateList[vaultCertificateIndex] = vaultCertificate
		}
		destination.VaultCertificates = vaultCertificateList
	} else {
		destination.VaultCertificates = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VaultSecretGroup_STATUS populates our VaultSecretGroup from the provided source VaultSecretGroup_STATUS
func (group *VaultSecretGroup) Initialize_From_VaultSecretGroup_STATUS(source *VaultSecretGroup_STATUS) error {

	// SourceVault
	if source.SourceVault != nil {
		var sourceVault SubResource
		err := sourceVault.Initialize_From_SubResource_STATUS(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SubResource_STATUS() to populate field SourceVault")
		}
		group.SourceVault = &sourceVault
	} else {
		group.SourceVault = nil
	}

	// VaultCertificates
	if source.VaultCertificates != nil {
		vaultCertificateList := make([]VaultCertificate, len(source.VaultCertificates))
		for vaultCertificateIndex, vaultCertificateItem := range source.VaultCertificates {
			// Shadow the loop variable to avoid aliasing
			vaultCertificateItem := vaultCertificateItem
			var vaultCertificate VaultCertificate
			err := vaultCertificate.Initialize_From_VaultCertificate_STATUS(&vaultCertificateItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_VaultCertificate_STATUS() to populate field VaultCertificates")
			}
			vaultCertificateList[vaultCertificateIndex] = vaultCertificate
		}
		group.VaultCertificates = vaultCertificateList
	} else {
		group.VaultCertificates = nil
	}

	// No error
	return nil
}

// Describes a set of certificates which are all in the same Key Vault.
type VaultSecretGroup_STATUS struct {
	// SourceVault: The relative URL of the Key Vault containing all of the certificates in VaultCertificates.
	SourceVault *SubResource_STATUS `json:"sourceVault,omitempty"`

	// VaultCertificates: The list of key vault references in SourceVault which contain certificates.
	VaultCertificates []VaultCertificate_STATUS `json:"vaultCertificates,omitempty"`
}

var _ genruntime.FromARMConverter = &VaultSecretGroup_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (group *VaultSecretGroup_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VaultSecretGroup_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (group *VaultSecretGroup_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VaultSecretGroup_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VaultSecretGroup_STATUS, got %T", armInput)
	}

	// Set property "SourceVault":
	if typedInput.SourceVault != nil {
		var sourceVault1 SubResource_STATUS
		err := sourceVault1.PopulateFromARM(owner, *typedInput.SourceVault)
		if err != nil {
			return err
		}
		sourceVault := sourceVault1
		group.SourceVault = &sourceVault
	}

	// Set property "VaultCertificates":
	for _, item := range typedInput.VaultCertificates {
		var item1 VaultCertificate_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		group.VaultCertificates = append(group.VaultCertificates, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_VaultSecretGroup_STATUS populates our VaultSecretGroup_STATUS from the provided source VaultSecretGroup_STATUS
func (group *VaultSecretGroup_STATUS) AssignProperties_From_VaultSecretGroup_STATUS(source *storage.VaultSecretGroup_STATUS) error {

	// SourceVault
	if source.SourceVault != nil {
		var sourceVault SubResource_STATUS
		err := sourceVault.AssignProperties_From_SubResource_STATUS(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SourceVault")
		}
		group.SourceVault = &sourceVault
	} else {
		group.SourceVault = nil
	}

	// VaultCertificates
	if source.VaultCertificates != nil {
		vaultCertificateList := make([]VaultCertificate_STATUS, len(source.VaultCertificates))
		for vaultCertificateIndex, vaultCertificateItem := range source.VaultCertificates {
			// Shadow the loop variable to avoid aliasing
			vaultCertificateItem := vaultCertificateItem
			var vaultCertificate VaultCertificate_STATUS
			err := vaultCertificate.AssignProperties_From_VaultCertificate_STATUS(&vaultCertificateItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VaultCertificate_STATUS() to populate field VaultCertificates")
			}
			vaultCertificateList[vaultCertificateIndex] = vaultCertificate
		}
		group.VaultCertificates = vaultCertificateList
	} else {
		group.VaultCertificates = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VaultSecretGroup_STATUS populates the provided destination VaultSecretGroup_STATUS from our VaultSecretGroup_STATUS
func (group *VaultSecretGroup_STATUS) AssignProperties_To_VaultSecretGroup_STATUS(destination *storage.VaultSecretGroup_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SourceVault
	if group.SourceVault != nil {
		var sourceVault storage.SubResource_STATUS
		err := group.SourceVault.AssignProperties_To_SubResource_STATUS(&sourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SourceVault")
		}
		destination.SourceVault = &sourceVault
	} else {
		destination.SourceVault = nil
	}

	// VaultCertificates
	if group.VaultCertificates != nil {
		vaultCertificateList := make([]storage.VaultCertificate_STATUS, len(group.VaultCertificates))
		for vaultCertificateIndex, vaultCertificateItem := range group.VaultCertificates {
			// Shadow the loop variable to avoid aliasing
			vaultCertificateItem := vaultCertificateItem
			var vaultCertificate storage.VaultCertificate_STATUS
			err := vaultCertificateItem.AssignProperties_To_VaultCertificate_STATUS(&vaultCertificate)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VaultCertificate_STATUS() to populate field VaultCertificates")
			}
			vaultCertificateList[vaultCertificateIndex] = vaultCertificate
		}
		destination.VaultCertificates = vaultCertificateList
	} else {
		destination.VaultCertificates = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The instance view of the VM Agent running on the virtual machine.
type VirtualMachineAgentInstanceView_STATUS struct {
	// ExtensionHandlers: The virtual machine extension handler instance view.
	ExtensionHandlers []VirtualMachineExtensionHandlerInstanceView_STATUS `json:"extensionHandlers,omitempty"`

	// Statuses: The resource status information.
	Statuses []InstanceViewStatus_STATUS `json:"statuses,omitempty"`

	// VmAgentVersion: The VM Agent full version.
	VmAgentVersion *string `json:"vmAgentVersion,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineAgentInstanceView_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (view *VirtualMachineAgentInstanceView_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineAgentInstanceView_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (view *VirtualMachineAgentInstanceView_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineAgentInstanceView_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineAgentInstanceView_STATUS, got %T", armInput)
	}

	// Set property "ExtensionHandlers":
	for _, item := range typedInput.ExtensionHandlers {
		var item1 VirtualMachineExtensionHandlerInstanceView_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		view.ExtensionHandlers = append(view.ExtensionHandlers, item1)
	}

	// Set property "Statuses":
	for _, item := range typedInput.Statuses {
		var item1 InstanceViewStatus_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		view.Statuses = append(view.Statuses, item1)
	}

	// Set property "VmAgentVersion":
	if typedInput.VmAgentVersion != nil {
		vmAgentVersion := *typedInput.VmAgentVersion
		view.VmAgentVersion = &vmAgentVersion
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineAgentInstanceView_STATUS populates our VirtualMachineAgentInstanceView_STATUS from the provided source VirtualMachineAgentInstanceView_STATUS
func (view *VirtualMachineAgentInstanceView_STATUS) AssignProperties_From_VirtualMachineAgentInstanceView_STATUS(source *storage.VirtualMachineAgentInstanceView_STATUS) error {

	// ExtensionHandlers
	if source.ExtensionHandlers != nil {
		extensionHandlerList := make([]VirtualMachineExtensionHandlerInstanceView_STATUS, len(source.ExtensionHandlers))
		for extensionHandlerIndex, extensionHandlerItem := range source.ExtensionHandlers {
			// Shadow the loop variable to avoid aliasing
			extensionHandlerItem := extensionHandlerItem
			var extensionHandler VirtualMachineExtensionHandlerInstanceView_STATUS
			err := extensionHandler.AssignProperties_From_VirtualMachineExtensionHandlerInstanceView_STATUS(&extensionHandlerItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineExtensionHandlerInstanceView_STATUS() to populate field ExtensionHandlers")
			}
			extensionHandlerList[extensionHandlerIndex] = extensionHandler
		}
		view.ExtensionHandlers = extensionHandlerList
	} else {
		view.ExtensionHandlers = nil
	}

	// Statuses
	if source.Statuses != nil {
		statusList := make([]InstanceViewStatus_STATUS, len(source.Statuses))
		for statusIndex, statusItem := range source.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status InstanceViewStatus_STATUS
			err := status.AssignProperties_From_InstanceViewStatus_STATUS(&statusItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_InstanceViewStatus_STATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		view.Statuses = statusList
	} else {
		view.Statuses = nil
	}

	// VmAgentVersion
	view.VmAgentVersion = genruntime.ClonePointerToString(source.VmAgentVersion)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineAgentInstanceView_STATUS populates the provided destination VirtualMachineAgentInstanceView_STATUS from our VirtualMachineAgentInstanceView_STATUS
func (view *VirtualMachineAgentInstanceView_STATUS) AssignProperties_To_VirtualMachineAgentInstanceView_STATUS(destination *storage.VirtualMachineAgentInstanceView_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ExtensionHandlers
	if view.ExtensionHandlers != nil {
		extensionHandlerList := make([]storage.VirtualMachineExtensionHandlerInstanceView_STATUS, len(view.ExtensionHandlers))
		for extensionHandlerIndex, extensionHandlerItem := range view.ExtensionHandlers {
			// Shadow the loop variable to avoid aliasing
			extensionHandlerItem := extensionHandlerItem
			var extensionHandler storage.VirtualMachineExtensionHandlerInstanceView_STATUS
			err := extensionHandlerItem.AssignProperties_To_VirtualMachineExtensionHandlerInstanceView_STATUS(&extensionHandler)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineExtensionHandlerInstanceView_STATUS() to populate field ExtensionHandlers")
			}
			extensionHandlerList[extensionHandlerIndex] = extensionHandler
		}
		destination.ExtensionHandlers = extensionHandlerList
	} else {
		destination.ExtensionHandlers = nil
	}

	// Statuses
	if view.Statuses != nil {
		statusList := make([]storage.InstanceViewStatus_STATUS, len(view.Statuses))
		for statusIndex, statusItem := range view.Statuses {
			// Shadow the loop variable to avoid aliasing
			statusItem := statusItem
			var status storage.InstanceViewStatus_STATUS
			err := statusItem.AssignProperties_To_InstanceViewStatus_STATUS(&status)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_InstanceViewStatus_STATUS() to populate field Statuses")
			}
			statusList[statusIndex] = status
		}
		destination.Statuses = statusList
	} else {
		destination.Statuses = nil
	}

	// VmAgentVersion
	destination.VmAgentVersion = genruntime.ClonePointerToString(view.VmAgentVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The health status of the VM.
type VirtualMachineHealthStatus_STATUS struct {
	// Status: The health status information for the VM.
	Status *InstanceViewStatus_STATUS `json:"status,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineHealthStatus_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (status *VirtualMachineHealthStatus_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineHealthStatus_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (status *VirtualMachineHealthStatus_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineHealthStatus_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineHealthStatus_STATUS, got %T", armInput)
	}

	// Set property "Status":
	if typedInput.Status != nil {
		var status2 InstanceViewStatus_STATUS
		err := status2.PopulateFromARM(owner, *typedInput.Status)
		if err != nil {
			return err
		}
		status1 := status2
		status.Status = &status1
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineHealthStatus_STATUS populates our VirtualMachineHealthStatus_STATUS from the provided source VirtualMachineHealthStatus_STATUS
func (status *VirtualMachineHealthStatus_STATUS) AssignProperties_From_VirtualMachineHealthStatus_STATUS(source *storage.VirtualMachineHealthStatus_STATUS) error {

	// Status
	if source.Status != nil {
		var statusLocal InstanceViewStatus_STATUS
		err := statusLocal.AssignProperties_From_InstanceViewStatus_STATUS(source.Status)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_InstanceViewStatus_STATUS() to populate field Status")
		}
		status.Status = &statusLocal
	} else {
		status.Status = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineHealthStatus_STATUS populates the provided destination VirtualMachineHealthStatus_STATUS from our VirtualMachineHealthStatus_STATUS
func (status *VirtualMachineHealthStatus_STATUS) AssignProperties_To_VirtualMachineHealthStatus_STATUS(destination *storage.VirtualMachineHealthStatus_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Status
	if status.Status != nil {
		var statusLocal storage.InstanceViewStatus_STATUS
		err := status.Status.AssignProperties_To_InstanceViewStatus_STATUS(&statusLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_InstanceViewStatus_STATUS() to populate field Status")
		}
		destination.Status = &statusLocal
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"None","SystemAssigned","SystemAssigned, UserAssigned","UserAssigned"}
type VirtualMachineIdentity_Type string

const (
	VirtualMachineIdentity_Type_None                       = VirtualMachineIdentity_Type("None")
	VirtualMachineIdentity_Type_SystemAssigned             = VirtualMachineIdentity_Type("SystemAssigned")
	VirtualMachineIdentity_Type_SystemAssignedUserAssigned = VirtualMachineIdentity_Type("SystemAssigned, UserAssigned")
	VirtualMachineIdentity_Type_UserAssigned               = VirtualMachineIdentity_Type("UserAssigned")
)

// Mapping from string to VirtualMachineIdentity_Type
var virtualMachineIdentity_Type_Values = map[string]VirtualMachineIdentity_Type{
	"none":                         VirtualMachineIdentity_Type_None,
	"systemassigned":               VirtualMachineIdentity_Type_SystemAssigned,
	"systemassigned, userassigned": VirtualMachineIdentity_Type_SystemAssignedUserAssigned,
	"userassigned":                 VirtualMachineIdentity_Type_UserAssigned,
}

type VirtualMachineIdentity_Type_STATUS string

const (
	VirtualMachineIdentity_Type_STATUS_None                       = VirtualMachineIdentity_Type_STATUS("None")
	VirtualMachineIdentity_Type_STATUS_SystemAssigned             = VirtualMachineIdentity_Type_STATUS("SystemAssigned")
	VirtualMachineIdentity_Type_STATUS_SystemAssignedUserAssigned = VirtualMachineIdentity_Type_STATUS("SystemAssigned, UserAssigned")
	VirtualMachineIdentity_Type_STATUS_UserAssigned               = VirtualMachineIdentity_Type_STATUS("UserAssigned")
)

// Mapping from string to VirtualMachineIdentity_Type_STATUS
var virtualMachineIdentity_Type_STATUS_Values = map[string]VirtualMachineIdentity_Type_STATUS{
	"none":                         VirtualMachineIdentity_Type_STATUS_None,
	"systemassigned":               VirtualMachineIdentity_Type_STATUS_SystemAssigned,
	"systemassigned, userassigned": VirtualMachineIdentity_Type_STATUS_SystemAssignedUserAssigned,
	"userassigned":                 VirtualMachineIdentity_Type_STATUS_UserAssigned,
}

type VirtualMachineIdentity_UserAssignedIdentities_STATUS struct {
	// ClientId: The client id of user assigned identity.
	ClientId *string `json:"clientId,omitempty"`

	// PrincipalId: The principal id of user assigned identity.
	PrincipalId *string `json:"principalId,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineIdentity_UserAssignedIdentities_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identities *VirtualMachineIdentity_UserAssignedIdentities_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineIdentity_UserAssignedIdentities_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identities *VirtualMachineIdentity_UserAssignedIdentities_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineIdentity_UserAssignedIdentities_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineIdentity_UserAssignedIdentities_STATUS, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		identities.ClientId = &clientId
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identities.PrincipalId = &principalId
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineIdentity_UserAssignedIdentities_STATUS populates our VirtualMachineIdentity_UserAssignedIdentities_STATUS from the provided source VirtualMachineIdentity_UserAssignedIdentities_STATUS
func (identities *VirtualMachineIdentity_UserAssignedIdentities_STATUS) AssignProperties_From_VirtualMachineIdentity_UserAssignedIdentities_STATUS(source *storage.VirtualMachineIdentity_UserAssignedIdentities_STATUS) error {

	// ClientId
	identities.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// PrincipalId
	identities.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineIdentity_UserAssignedIdentities_STATUS populates the provided destination VirtualMachineIdentity_UserAssignedIdentities_STATUS from our VirtualMachineIdentity_UserAssignedIdentities_STATUS
func (identities *VirtualMachineIdentity_UserAssignedIdentities_STATUS) AssignProperties_To_VirtualMachineIdentity_UserAssignedIdentities_STATUS(destination *storage.VirtualMachineIdentity_UserAssignedIdentities_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identities.ClientId)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identities.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type VirtualMachineInstanceView_HyperVGeneration_STATUS string

const (
	VirtualMachineInstanceView_HyperVGeneration_STATUS_V1 = VirtualMachineInstanceView_HyperVGeneration_STATUS("V1")
	VirtualMachineInstanceView_HyperVGeneration_STATUS_V2 = VirtualMachineInstanceView_HyperVGeneration_STATUS("V2")
)

// Mapping from string to VirtualMachineInstanceView_HyperVGeneration_STATUS
var virtualMachineInstanceView_HyperVGeneration_STATUS_Values = map[string]VirtualMachineInstanceView_HyperVGeneration_STATUS{
	"v1": VirtualMachineInstanceView_HyperVGeneration_STATUS_V1,
	"v2": VirtualMachineInstanceView_HyperVGeneration_STATUS_V2,
}

// Describes a virtual machine network interface configurations.
type VirtualMachineNetworkInterfaceConfiguration struct {
	// DeleteOption: Specify what happens to the network interface when the VM is deleted
	DeleteOption *VirtualMachineNetworkInterfaceConfigurationProperties_DeleteOption `json:"deleteOption,omitempty"`

	// DnsSettings: The dns settings to be applied on the network interfaces.
	DnsSettings       *VirtualMachineNetworkInterfaceDnsSettingsConfiguration `json:"dnsSettings,omitempty"`
	DscpConfiguration *SubResource                                            `json:"dscpConfiguration,omitempty"`

	// EnableAcceleratedNetworking: Specifies whether the network interface is accelerated networking-enabled.
	EnableAcceleratedNetworking *bool `json:"enableAcceleratedNetworking,omitempty"`

	// EnableFpga: Specifies whether the network interface is FPGA networking-enabled.
	EnableFpga *bool `json:"enableFpga,omitempty"`

	// EnableIPForwarding: Whether IP forwarding enabled on this NIC.
	EnableIPForwarding *bool `json:"enableIPForwarding,omitempty"`

	// +kubebuilder:validation:Required
	// IpConfigurations: Specifies the IP configurations of the network interface.
	IpConfigurations []VirtualMachineNetworkInterfaceIPConfiguration `json:"ipConfigurations,omitempty"`

	// +kubebuilder:validation:Required
	// Name: The network interface configuration name.
	Name *string `json:"name,omitempty"`

	// NetworkSecurityGroup: The network security group.
	NetworkSecurityGroup *SubResource `json:"networkSecurityGroup,omitempty"`

	// Primary: Specifies the primary network interface in case the virtual machine has more than 1 network interface.
	Primary *bool `json:"primary,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineNetworkInterfaceConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *VirtualMachineNetworkInterfaceConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.VirtualMachineNetworkInterfaceConfiguration{}

	// Set property "Name":
	if configuration.Name != nil {
		name := *configuration.Name
		result.Name = &name
	}

	// Set property "Properties":
	if configuration.DeleteOption != nil ||
		configuration.DnsSettings != nil ||
		configuration.DscpConfiguration != nil ||
		configuration.EnableAcceleratedNetworking != nil ||
		configuration.EnableFpga != nil ||
		configuration.EnableIPForwarding != nil ||
		configuration.IpConfigurations != nil ||
		configuration.NetworkSecurityGroup != nil ||
		configuration.Primary != nil {
		result.Properties = &arm.VirtualMachineNetworkInterfaceConfigurationProperties{}
	}
	if configuration.DeleteOption != nil {
		var temp string
		temp = string(*configuration.DeleteOption)
		deleteOption := arm.VirtualMachineNetworkInterfaceConfigurationProperties_DeleteOption(temp)
		result.Properties.DeleteOption = &deleteOption
	}
	if configuration.DnsSettings != nil {
		dnsSettings_ARM, err := (*configuration.DnsSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dnsSettings := *dnsSettings_ARM.(*arm.VirtualMachineNetworkInterfaceDnsSettingsConfiguration)
		result.Properties.DnsSettings = &dnsSettings
	}
	if configuration.DscpConfiguration != nil {
		dscpConfiguration_ARM, err := (*configuration.DscpConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dscpConfiguration := *dscpConfiguration_ARM.(*arm.SubResource)
		result.Properties.DscpConfiguration = &dscpConfiguration
	}
	if configuration.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *configuration.EnableAcceleratedNetworking
		result.Properties.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	}
	if configuration.EnableFpga != nil {
		enableFpga := *configuration.EnableFpga
		result.Properties.EnableFpga = &enableFpga
	}
	if configuration.EnableIPForwarding != nil {
		enableIPForwarding := *configuration.EnableIPForwarding
		result.Properties.EnableIPForwarding = &enableIPForwarding
	}
	for _, item := range configuration.IpConfigurations {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.IpConfigurations = append(result.Properties.IpConfigurations, *item_ARM.(*arm.VirtualMachineNetworkInterfaceIPConfiguration))
	}
	if configuration.NetworkSecurityGroup != nil {
		networkSecurityGroup_ARM, err := (*configuration.NetworkSecurityGroup).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		networkSecurityGroup := *networkSecurityGroup_ARM.(*arm.SubResource)
		result.Properties.NetworkSecurityGroup = &networkSecurityGroup
	}
	if configuration.Primary != nil {
		primary := *configuration.Primary
		result.Properties.Primary = &primary
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *VirtualMachineNetworkInterfaceConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineNetworkInterfaceConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *VirtualMachineNetworkInterfaceConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineNetworkInterfaceConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineNetworkInterfaceConfiguration, got %T", armInput)
	}

	// Set property "DeleteOption":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DeleteOption != nil {
			var temp string
			temp = string(*typedInput.Properties.DeleteOption)
			deleteOption := VirtualMachineNetworkInterfaceConfigurationProperties_DeleteOption(temp)
			configuration.DeleteOption = &deleteOption
		}
	}

	// Set property "DnsSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsSettings != nil {
			var dnsSettings1 VirtualMachineNetworkInterfaceDnsSettingsConfiguration
			err := dnsSettings1.PopulateFromARM(owner, *typedInput.Properties.DnsSettings)
			if err != nil {
				return err
			}
			dnsSettings := dnsSettings1
			configuration.DnsSettings = &dnsSettings
		}
	}

	// Set property "DscpConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DscpConfiguration != nil {
			var dscpConfiguration1 SubResource
			err := dscpConfiguration1.PopulateFromARM(owner, *typedInput.Properties.DscpConfiguration)
			if err != nil {
				return err
			}
			dscpConfiguration := dscpConfiguration1
			configuration.DscpConfiguration = &dscpConfiguration
		}
	}

	// Set property "EnableAcceleratedNetworking":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableAcceleratedNetworking != nil {
			enableAcceleratedNetworking := *typedInput.Properties.EnableAcceleratedNetworking
			configuration.EnableAcceleratedNetworking = &enableAcceleratedNetworking
		}
	}

	// Set property "EnableFpga":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableFpga != nil {
			enableFpga := *typedInput.Properties.EnableFpga
			configuration.EnableFpga = &enableFpga
		}
	}

	// Set property "EnableIPForwarding":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableIPForwarding != nil {
			enableIPForwarding := *typedInput.Properties.EnableIPForwarding
			configuration.EnableIPForwarding = &enableIPForwarding
		}
	}

	// Set property "IpConfigurations":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpConfigurations {
			var item1 VirtualMachineNetworkInterfaceIPConfiguration
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.IpConfigurations = append(configuration.IpConfigurations, item1)
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		configuration.Name = &name
	}

	// Set property "NetworkSecurityGroup":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkSecurityGroup != nil {
			var networkSecurityGroup1 SubResource
			err := networkSecurityGroup1.PopulateFromARM(owner, *typedInput.Properties.NetworkSecurityGroup)
			if err != nil {
				return err
			}
			networkSecurityGroup := networkSecurityGroup1
			configuration.NetworkSecurityGroup = &networkSecurityGroup
		}
	}

	// Set property "Primary":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			configuration.Primary = &primary
		}
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineNetworkInterfaceConfiguration populates our VirtualMachineNetworkInterfaceConfiguration from the provided source VirtualMachineNetworkInterfaceConfiguration
func (configuration *VirtualMachineNetworkInterfaceConfiguration) AssignProperties_From_VirtualMachineNetworkInterfaceConfiguration(source *storage.VirtualMachineNetworkInterfaceConfiguration) error {

	// DeleteOption
	if source.DeleteOption != nil {
		deleteOption := *source.DeleteOption
		deleteOptionTemp := genruntime.ToEnum(deleteOption, virtualMachineNetworkInterfaceConfigurationProperties_DeleteOption_Values)
		configuration.DeleteOption = &deleteOptionTemp
	} else {
		configuration.DeleteOption = nil
	}

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting VirtualMachineNetworkInterfaceDnsSettingsConfiguration
		err := dnsSetting.AssignProperties_From_VirtualMachineNetworkInterfaceDnsSettingsConfiguration(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineNetworkInterfaceDnsSettingsConfiguration() to populate field DnsSettings")
		}
		configuration.DnsSettings = &dnsSetting
	} else {
		configuration.DnsSettings = nil
	}

	// DscpConfiguration
	if source.DscpConfiguration != nil {
		var dscpConfiguration SubResource
		err := dscpConfiguration.AssignProperties_From_SubResource(source.DscpConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field DscpConfiguration")
		}
		configuration.DscpConfiguration = &dscpConfiguration
	} else {
		configuration.DscpConfiguration = nil
	}

	// EnableAcceleratedNetworking
	if source.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *source.EnableAcceleratedNetworking
		configuration.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		configuration.EnableAcceleratedNetworking = nil
	}

	// EnableFpga
	if source.EnableFpga != nil {
		enableFpga := *source.EnableFpga
		configuration.EnableFpga = &enableFpga
	} else {
		configuration.EnableFpga = nil
	}

	// EnableIPForwarding
	if source.EnableIPForwarding != nil {
		enableIPForwarding := *source.EnableIPForwarding
		configuration.EnableIPForwarding = &enableIPForwarding
	} else {
		configuration.EnableIPForwarding = nil
	}

	// IpConfigurations
	if source.IpConfigurations != nil {
		ipConfigurationList := make([]VirtualMachineNetworkInterfaceIPConfiguration, len(source.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range source.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration VirtualMachineNetworkInterfaceIPConfiguration
			err := ipConfiguration.AssignProperties_From_VirtualMachineNetworkInterfaceIPConfiguration(&ipConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineNetworkInterfaceIPConfiguration() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		configuration.IpConfigurations = ipConfigurationList
	} else {
		configuration.IpConfigurations = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// NetworkSecurityGroup
	if source.NetworkSecurityGroup != nil {
		var networkSecurityGroup SubResource
		err := networkSecurityGroup.AssignProperties_From_SubResource(source.NetworkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field NetworkSecurityGroup")
		}
		configuration.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		configuration.NetworkSecurityGroup = nil
	}

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		configuration.Primary = &primary
	} else {
		configuration.Primary = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineNetworkInterfaceConfiguration populates the provided destination VirtualMachineNetworkInterfaceConfiguration from our VirtualMachineNetworkInterfaceConfiguration
func (configuration *VirtualMachineNetworkInterfaceConfiguration) AssignProperties_To_VirtualMachineNetworkInterfaceConfiguration(destination *storage.VirtualMachineNetworkInterfaceConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DeleteOption
	if configuration.DeleteOption != nil {
		deleteOption := string(*configuration.DeleteOption)
		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// DnsSettings
	if configuration.DnsSettings != nil {
		var dnsSetting storage.VirtualMachineNetworkInterfaceDnsSettingsConfiguration
		err := configuration.DnsSettings.AssignProperties_To_VirtualMachineNetworkInterfaceDnsSettingsConfiguration(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineNetworkInterfaceDnsSettingsConfiguration() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// DscpConfiguration
	if configuration.DscpConfiguration != nil {
		var dscpConfiguration storage.SubResource
		err := configuration.DscpConfiguration.AssignProperties_To_SubResource(&dscpConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field DscpConfiguration")
		}
		destination.DscpConfiguration = &dscpConfiguration
	} else {
		destination.DscpConfiguration = nil
	}

	// EnableAcceleratedNetworking
	if configuration.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *configuration.EnableAcceleratedNetworking
		destination.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		destination.EnableAcceleratedNetworking = nil
	}

	// EnableFpga
	if configuration.EnableFpga != nil {
		enableFpga := *configuration.EnableFpga
		destination.EnableFpga = &enableFpga
	} else {
		destination.EnableFpga = nil
	}

	// EnableIPForwarding
	if configuration.EnableIPForwarding != nil {
		enableIPForwarding := *configuration.EnableIPForwarding
		destination.EnableIPForwarding = &enableIPForwarding
	} else {
		destination.EnableIPForwarding = nil
	}

	// IpConfigurations
	if configuration.IpConfigurations != nil {
		ipConfigurationList := make([]storage.VirtualMachineNetworkInterfaceIPConfiguration, len(configuration.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range configuration.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration storage.VirtualMachineNetworkInterfaceIPConfiguration
			err := ipConfigurationItem.AssignProperties_To_VirtualMachineNetworkInterfaceIPConfiguration(&ipConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineNetworkInterfaceIPConfiguration() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		destination.IpConfigurations = ipConfigurationList
	} else {
		destination.IpConfigurations = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// NetworkSecurityGroup
	if configuration.NetworkSecurityGroup != nil {
		var networkSecurityGroup storage.SubResource
		err := configuration.NetworkSecurityGroup.AssignProperties_To_SubResource(&networkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field NetworkSecurityGroup")
		}
		destination.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		destination.NetworkSecurityGroup = nil
	}

	// Primary
	if configuration.Primary != nil {
		primary := *configuration.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualMachineNetworkInterfaceConfiguration_STATUS populates our VirtualMachineNetworkInterfaceConfiguration from the provided source VirtualMachineNetworkInterfaceConfiguration_STATUS
func (configuration *VirtualMachineNetworkInterfaceConfiguration) Initialize_From_VirtualMachineNetworkInterfaceConfiguration_STATUS(source *VirtualMachineNetworkInterfaceConfiguration_STATUS) error {

	// DeleteOption
	if source.DeleteOption != nil {
		deleteOption := genruntime.ToEnum(string(*source.DeleteOption), virtualMachineNetworkInterfaceConfigurationProperties_DeleteOption_Values)
		configuration.DeleteOption = &deleteOption
	} else {
		configuration.DeleteOption = nil
	}

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting VirtualMachineNetworkInterfaceDnsSettingsConfiguration
		err := dnsSetting.Initialize_From_VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS() to populate field DnsSettings")
		}
		configuration.DnsSettings = &dnsSetting
	} else {
		configuration.DnsSettings = nil
	}

	// DscpConfiguration
	if source.DscpConfiguration != nil {
		var dscpConfiguration SubResource
		err := dscpConfiguration.Initialize_From_SubResource_STATUS(source.DscpConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SubResource_STATUS() to populate field DscpConfiguration")
		}
		configuration.DscpConfiguration = &dscpConfiguration
	} else {
		configuration.DscpConfiguration = nil
	}

	// EnableAcceleratedNetworking
	if source.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *source.EnableAcceleratedNetworking
		configuration.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		configuration.EnableAcceleratedNetworking = nil
	}

	// EnableFpga
	if source.EnableFpga != nil {
		enableFpga := *source.EnableFpga
		configuration.EnableFpga = &enableFpga
	} else {
		configuration.EnableFpga = nil
	}

	// EnableIPForwarding
	if source.EnableIPForwarding != nil {
		enableIPForwarding := *source.EnableIPForwarding
		configuration.EnableIPForwarding = &enableIPForwarding
	} else {
		configuration.EnableIPForwarding = nil
	}

	// IpConfigurations
	if source.IpConfigurations != nil {
		ipConfigurationList := make([]VirtualMachineNetworkInterfaceIPConfiguration, len(source.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range source.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration VirtualMachineNetworkInterfaceIPConfiguration
			err := ipConfiguration.Initialize_From_VirtualMachineNetworkInterfaceIPConfiguration_STATUS(&ipConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_VirtualMachineNetworkInterfaceIPConfiguration_STATUS() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		configuration.IpConfigurations = ipConfigurationList
	} else {
		configuration.IpConfigurations = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// NetworkSecurityGroup
	if source.NetworkSecurityGroup != nil {
		var networkSecurityGroup SubResource
		err := networkSecurityGroup.Initialize_From_SubResource_STATUS(source.NetworkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SubResource_STATUS() to populate field NetworkSecurityGroup")
		}
		configuration.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		configuration.NetworkSecurityGroup = nil
	}

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		configuration.Primary = &primary
	} else {
		configuration.Primary = nil
	}

	// No error
	return nil
}

// Describes a virtual machine network interface configurations.
type VirtualMachineNetworkInterfaceConfiguration_STATUS struct {
	// DeleteOption: Specify what happens to the network interface when the VM is deleted
	DeleteOption *VirtualMachineNetworkInterfaceConfigurationProperties_DeleteOption_STATUS `json:"deleteOption,omitempty"`

	// DnsSettings: The dns settings to be applied on the network interfaces.
	DnsSettings       *VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS `json:"dnsSettings,omitempty"`
	DscpConfiguration *SubResource_STATUS                                            `json:"dscpConfiguration,omitempty"`

	// EnableAcceleratedNetworking: Specifies whether the network interface is accelerated networking-enabled.
	EnableAcceleratedNetworking *bool `json:"enableAcceleratedNetworking,omitempty"`

	// EnableFpga: Specifies whether the network interface is FPGA networking-enabled.
	EnableFpga *bool `json:"enableFpga,omitempty"`

	// EnableIPForwarding: Whether IP forwarding enabled on this NIC.
	EnableIPForwarding *bool `json:"enableIPForwarding,omitempty"`

	// IpConfigurations: Specifies the IP configurations of the network interface.
	IpConfigurations []VirtualMachineNetworkInterfaceIPConfiguration_STATUS `json:"ipConfigurations,omitempty"`

	// Name: The network interface configuration name.
	Name *string `json:"name,omitempty"`

	// NetworkSecurityGroup: The network security group.
	NetworkSecurityGroup *SubResource_STATUS `json:"networkSecurityGroup,omitempty"`

	// Primary: Specifies the primary network interface in case the virtual machine has more than 1 network interface.
	Primary *bool `json:"primary,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineNetworkInterfaceConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *VirtualMachineNetworkInterfaceConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineNetworkInterfaceConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *VirtualMachineNetworkInterfaceConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineNetworkInterfaceConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineNetworkInterfaceConfiguration_STATUS, got %T", armInput)
	}

	// Set property "DeleteOption":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DeleteOption != nil {
			var temp string
			temp = string(*typedInput.Properties.DeleteOption)
			deleteOption := VirtualMachineNetworkInterfaceConfigurationProperties_DeleteOption_STATUS(temp)
			configuration.DeleteOption = &deleteOption
		}
	}

	// Set property "DnsSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsSettings != nil {
			var dnsSettings1 VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS
			err := dnsSettings1.PopulateFromARM(owner, *typedInput.Properties.DnsSettings)
			if err != nil {
				return err
			}
			dnsSettings := dnsSettings1
			configuration.DnsSettings = &dnsSettings
		}
	}

	// Set property "DscpConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DscpConfiguration != nil {
			var dscpConfiguration1 SubResource_STATUS
			err := dscpConfiguration1.PopulateFromARM(owner, *typedInput.Properties.DscpConfiguration)
			if err != nil {
				return err
			}
			dscpConfiguration := dscpConfiguration1
			configuration.DscpConfiguration = &dscpConfiguration
		}
	}

	// Set property "EnableAcceleratedNetworking":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableAcceleratedNetworking != nil {
			enableAcceleratedNetworking := *typedInput.Properties.EnableAcceleratedNetworking
			configuration.EnableAcceleratedNetworking = &enableAcceleratedNetworking
		}
	}

	// Set property "EnableFpga":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableFpga != nil {
			enableFpga := *typedInput.Properties.EnableFpga
			configuration.EnableFpga = &enableFpga
		}
	}

	// Set property "EnableIPForwarding":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableIPForwarding != nil {
			enableIPForwarding := *typedInput.Properties.EnableIPForwarding
			configuration.EnableIPForwarding = &enableIPForwarding
		}
	}

	// Set property "IpConfigurations":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpConfigurations {
			var item1 VirtualMachineNetworkInterfaceIPConfiguration_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.IpConfigurations = append(configuration.IpConfigurations, item1)
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		configuration.Name = &name
	}

	// Set property "NetworkSecurityGroup":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkSecurityGroup != nil {
			var networkSecurityGroup1 SubResource_STATUS
			err := networkSecurityGroup1.PopulateFromARM(owner, *typedInput.Properties.NetworkSecurityGroup)
			if err != nil {
				return err
			}
			networkSecurityGroup := networkSecurityGroup1
			configuration.NetworkSecurityGroup = &networkSecurityGroup
		}
	}

	// Set property "Primary":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			configuration.Primary = &primary
		}
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineNetworkInterfaceConfiguration_STATUS populates our VirtualMachineNetworkInterfaceConfiguration_STATUS from the provided source VirtualMachineNetworkInterfaceConfiguration_STATUS
func (configuration *VirtualMachineNetworkInterfaceConfiguration_STATUS) AssignProperties_From_VirtualMachineNetworkInterfaceConfiguration_STATUS(source *storage.VirtualMachineNetworkInterfaceConfiguration_STATUS) error {

	// DeleteOption
	if source.DeleteOption != nil {
		deleteOption := *source.DeleteOption
		deleteOptionTemp := genruntime.ToEnum(deleteOption, virtualMachineNetworkInterfaceConfigurationProperties_DeleteOption_STATUS_Values)
		configuration.DeleteOption = &deleteOptionTemp
	} else {
		configuration.DeleteOption = nil
	}

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS
		err := dnsSetting.AssignProperties_From_VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS() to populate field DnsSettings")
		}
		configuration.DnsSettings = &dnsSetting
	} else {
		configuration.DnsSettings = nil
	}

	// DscpConfiguration
	if source.DscpConfiguration != nil {
		var dscpConfiguration SubResource_STATUS
		err := dscpConfiguration.AssignProperties_From_SubResource_STATUS(source.DscpConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field DscpConfiguration")
		}
		configuration.DscpConfiguration = &dscpConfiguration
	} else {
		configuration.DscpConfiguration = nil
	}

	// EnableAcceleratedNetworking
	if source.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *source.EnableAcceleratedNetworking
		configuration.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		configuration.EnableAcceleratedNetworking = nil
	}

	// EnableFpga
	if source.EnableFpga != nil {
		enableFpga := *source.EnableFpga
		configuration.EnableFpga = &enableFpga
	} else {
		configuration.EnableFpga = nil
	}

	// EnableIPForwarding
	if source.EnableIPForwarding != nil {
		enableIPForwarding := *source.EnableIPForwarding
		configuration.EnableIPForwarding = &enableIPForwarding
	} else {
		configuration.EnableIPForwarding = nil
	}

	// IpConfigurations
	if source.IpConfigurations != nil {
		ipConfigurationList := make([]VirtualMachineNetworkInterfaceIPConfiguration_STATUS, len(source.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range source.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration VirtualMachineNetworkInterfaceIPConfiguration_STATUS
			err := ipConfiguration.AssignProperties_From_VirtualMachineNetworkInterfaceIPConfiguration_STATUS(&ipConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineNetworkInterfaceIPConfiguration_STATUS() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		configuration.IpConfigurations = ipConfigurationList
	} else {
		configuration.IpConfigurations = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// NetworkSecurityGroup
	if source.NetworkSecurityGroup != nil {
		var networkSecurityGroup SubResource_STATUS
		err := networkSecurityGroup.AssignProperties_From_SubResource_STATUS(source.NetworkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field NetworkSecurityGroup")
		}
		configuration.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		configuration.NetworkSecurityGroup = nil
	}

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		configuration.Primary = &primary
	} else {
		configuration.Primary = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineNetworkInterfaceConfiguration_STATUS populates the provided destination VirtualMachineNetworkInterfaceConfiguration_STATUS from our VirtualMachineNetworkInterfaceConfiguration_STATUS
func (configuration *VirtualMachineNetworkInterfaceConfiguration_STATUS) AssignProperties_To_VirtualMachineNetworkInterfaceConfiguration_STATUS(destination *storage.VirtualMachineNetworkInterfaceConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DeleteOption
	if configuration.DeleteOption != nil {
		deleteOption := string(*configuration.DeleteOption)
		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// DnsSettings
	if configuration.DnsSettings != nil {
		var dnsSetting storage.VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS
		err := configuration.DnsSettings.AssignProperties_To_VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// DscpConfiguration
	if configuration.DscpConfiguration != nil {
		var dscpConfiguration storage.SubResource_STATUS
		err := configuration.DscpConfiguration.AssignProperties_To_SubResource_STATUS(&dscpConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field DscpConfiguration")
		}
		destination.DscpConfiguration = &dscpConfiguration
	} else {
		destination.DscpConfiguration = nil
	}

	// EnableAcceleratedNetworking
	if configuration.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *configuration.EnableAcceleratedNetworking
		destination.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		destination.EnableAcceleratedNetworking = nil
	}

	// EnableFpga
	if configuration.EnableFpga != nil {
		enableFpga := *configuration.EnableFpga
		destination.EnableFpga = &enableFpga
	} else {
		destination.EnableFpga = nil
	}

	// EnableIPForwarding
	if configuration.EnableIPForwarding != nil {
		enableIPForwarding := *configuration.EnableIPForwarding
		destination.EnableIPForwarding = &enableIPForwarding
	} else {
		destination.EnableIPForwarding = nil
	}

	// IpConfigurations
	if configuration.IpConfigurations != nil {
		ipConfigurationList := make([]storage.VirtualMachineNetworkInterfaceIPConfiguration_STATUS, len(configuration.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range configuration.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration storage.VirtualMachineNetworkInterfaceIPConfiguration_STATUS
			err := ipConfigurationItem.AssignProperties_To_VirtualMachineNetworkInterfaceIPConfiguration_STATUS(&ipConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineNetworkInterfaceIPConfiguration_STATUS() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		destination.IpConfigurations = ipConfigurationList
	} else {
		destination.IpConfigurations = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// NetworkSecurityGroup
	if configuration.NetworkSecurityGroup != nil {
		var networkSecurityGroup storage.SubResource_STATUS
		err := configuration.NetworkSecurityGroup.AssignProperties_To_SubResource_STATUS(&networkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field NetworkSecurityGroup")
		}
		destination.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		destination.NetworkSecurityGroup = nil
	}

	// Primary
	if configuration.Primary != nil {
		primary := *configuration.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The status of virtual machine patch operations.
type VirtualMachinePatchStatus_STATUS struct {
	// AvailablePatchSummary: The available patch summary of the latest assessment operation for the virtual machine.
	AvailablePatchSummary *AvailablePatchSummary_STATUS `json:"availablePatchSummary,omitempty"`

	// ConfigurationStatuses: The enablement status of the specified patchMode
	ConfigurationStatuses []InstanceViewStatus_STATUS `json:"configurationStatuses,omitempty"`

	// LastPatchInstallationSummary: The installation summary of the latest installation operation for the virtual machine.
	LastPatchInstallationSummary *LastPatchInstallationSummary_STATUS `json:"lastPatchInstallationSummary,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachinePatchStatus_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (status *VirtualMachinePatchStatus_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachinePatchStatus_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (status *VirtualMachinePatchStatus_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachinePatchStatus_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachinePatchStatus_STATUS, got %T", armInput)
	}

	// Set property "AvailablePatchSummary":
	if typedInput.AvailablePatchSummary != nil {
		var availablePatchSummary1 AvailablePatchSummary_STATUS
		err := availablePatchSummary1.PopulateFromARM(owner, *typedInput.AvailablePatchSummary)
		if err != nil {
			return err
		}
		availablePatchSummary := availablePatchSummary1
		status.AvailablePatchSummary = &availablePatchSummary
	}

	// Set property "ConfigurationStatuses":
	for _, item := range typedInput.ConfigurationStatuses {
		var item1 InstanceViewStatus_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		status.ConfigurationStatuses = append(status.ConfigurationStatuses, item1)
	}

	// Set property "LastPatchInstallationSummary":
	if typedInput.LastPatchInstallationSummary != nil {
		var lastPatchInstallationSummary1 LastPatchInstallationSummary_STATUS
		err := lastPatchInstallationSummary1.PopulateFromARM(owner, *typedInput.LastPatchInstallationSummary)
		if err != nil {
			return err
		}
		lastPatchInstallationSummary := lastPatchInstallationSummary1
		status.LastPatchInstallationSummary = &lastPatchInstallationSummary
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachinePatchStatus_STATUS populates our VirtualMachinePatchStatus_STATUS from the provided source VirtualMachinePatchStatus_STATUS
func (status *VirtualMachinePatchStatus_STATUS) AssignProperties_From_VirtualMachinePatchStatus_STATUS(source *storage.VirtualMachinePatchStatus_STATUS) error {

	// AvailablePatchSummary
	if source.AvailablePatchSummary != nil {
		var availablePatchSummary AvailablePatchSummary_STATUS
		err := availablePatchSummary.AssignProperties_From_AvailablePatchSummary_STATUS(source.AvailablePatchSummary)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AvailablePatchSummary_STATUS() to populate field AvailablePatchSummary")
		}
		status.AvailablePatchSummary = &availablePatchSummary
	} else {
		status.AvailablePatchSummary = nil
	}

	// ConfigurationStatuses
	if source.ConfigurationStatuses != nil {
		configurationStatusList := make([]InstanceViewStatus_STATUS, len(source.ConfigurationStatuses))
		for configurationStatusIndex, configurationStatusItem := range source.ConfigurationStatuses {
			// Shadow the loop variable to avoid aliasing
			configurationStatusItem := configurationStatusItem
			var configurationStatus InstanceViewStatus_STATUS
			err := configurationStatus.AssignProperties_From_InstanceViewStatus_STATUS(&configurationStatusItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_InstanceViewStatus_STATUS() to populate field ConfigurationStatuses")
			}
			configurationStatusList[configurationStatusIndex] = configurationStatus
		}
		status.ConfigurationStatuses = configurationStatusList
	} else {
		status.ConfigurationStatuses = nil
	}

	// LastPatchInstallationSummary
	if source.LastPatchInstallationSummary != nil {
		var lastPatchInstallationSummary LastPatchInstallationSummary_STATUS
		err := lastPatchInstallationSummary.AssignProperties_From_LastPatchInstallationSummary_STATUS(source.LastPatchInstallationSummary)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_LastPatchInstallationSummary_STATUS() to populate field LastPatchInstallationSummary")
		}
		status.LastPatchInstallationSummary = &lastPatchInstallationSummary
	} else {
		status.LastPatchInstallationSummary = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachinePatchStatus_STATUS populates the provided destination VirtualMachinePatchStatus_STATUS from our VirtualMachinePatchStatus_STATUS
func (status *VirtualMachinePatchStatus_STATUS) AssignProperties_To_VirtualMachinePatchStatus_STATUS(destination *storage.VirtualMachinePatchStatus_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AvailablePatchSummary
	if status.AvailablePatchSummary != nil {
		var availablePatchSummary storage.AvailablePatchSummary_STATUS
		err := status.AvailablePatchSummary.AssignProperties_To_AvailablePatchSummary_STATUS(&availablePatchSummary)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AvailablePatchSummary_STATUS() to populate field AvailablePatchSummary")
		}
		destination.AvailablePatchSummary = &availablePatchSummary
	} else {
		destination.AvailablePatchSummary = nil
	}

	// ConfigurationStatuses
	if status.ConfigurationStatuses != nil {
		configurationStatusList := make([]storage.InstanceViewStatus_STATUS, len(status.ConfigurationStatuses))
		for configurationStatusIndex, configurationStatusItem := range status.ConfigurationStatuses {
			// Shadow the loop variable to avoid aliasing
			configurationStatusItem := configurationStatusItem
			var configurationStatus storage.InstanceViewStatus_STATUS
			err := configurationStatusItem.AssignProperties_To_InstanceViewStatus_STATUS(&configurationStatus)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_InstanceViewStatus_STATUS() to populate field ConfigurationStatuses")
			}
			configurationStatusList[configurationStatusIndex] = configurationStatus
		}
		destination.ConfigurationStatuses = configurationStatusList
	} else {
		destination.ConfigurationStatuses = nil
	}

	// LastPatchInstallationSummary
	if status.LastPatchInstallationSummary != nil {
		var lastPatchInstallationSummary storage.LastPatchInstallationSummary_STATUS
		err := status.LastPatchInstallationSummary.AssignProperties_To_LastPatchInstallationSummary_STATUS(&lastPatchInstallationSummary)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_LastPatchInstallationSummary_STATUS() to populate field LastPatchInstallationSummary")
		}
		destination.LastPatchInstallationSummary = &lastPatchInstallationSummary
	} else {
		destination.LastPatchInstallationSummary = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Specifies the required information to reference a compute gallery application version
type VMGalleryApplication struct {
	// ConfigurationReference: Optional, Specifies the uri to an azure blob that will replace the default configuration for the
	// package if provided
	ConfigurationReference *string `json:"configurationReference,omitempty"`

	// EnableAutomaticUpgrade: If set to true, when a new Gallery Application version is available in PIR/SIG, it will be
	// automatically updated for the VM/VMSS
	EnableAutomaticUpgrade *bool `json:"enableAutomaticUpgrade,omitempty"`

	// Order: Optional, Specifies the order in which the packages have to be installed
	Order *int `json:"order,omitempty"`

	// +kubebuilder:validation:Required
	// PackageReferenceReference: Specifies the GalleryApplicationVersion resource id on the form of
	// /subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/applications/{application}/versions/{version}
	PackageReferenceReference *genruntime.ResourceReference `armReference:"PackageReferenceId" json:"packageReferenceReference,omitempty"`

	// Tags: Optional, Specifies a passthrough value for more generic context.
	Tags *string `json:"tags,omitempty"`

	// TreatFailureAsDeploymentFailure: Optional, If true, any failure for any operation in the VmApplication will fail the
	// deployment
	TreatFailureAsDeploymentFailure *bool `json:"treatFailureAsDeploymentFailure,omitempty"`
}

var _ genruntime.ARMTransformer = &VMGalleryApplication{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (application *VMGalleryApplication) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if application == nil {
		return nil, nil
	}
	result := &arm.VMGalleryApplication{}

	// Set property "ConfigurationReference":
	if application.ConfigurationReference != nil {
		configurationReference := *application.ConfigurationReference
		result.ConfigurationReference = &configurationReference
	}

	// Set property "EnableAutomaticUpgrade":
	if application.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *application.EnableAutomaticUpgrade
		result.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	}

	// Set property "Order":
	if application.Order != nil {
		order := *application.Order
		result.Order = &order
	}

	// Set property "PackageReferenceId":
	if application.PackageReferenceReference != nil {
		packageReferenceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*application.PackageReferenceReference)
		if err != nil {
			return nil, err
		}
		packageReferenceReference := packageReferenceReferenceARMID
		result.PackageReferenceId = &packageReferenceReference
	}

	// Set property "Tags":
	if application.Tags != nil {
		tags := *application.Tags
		result.Tags = &tags
	}

	// Set property "TreatFailureAsDeploymentFailure":
	if application.TreatFailureAsDeploymentFailure != nil {
		treatFailureAsDeploymentFailure := *application.TreatFailureAsDeploymentFailure
		result.TreatFailureAsDeploymentFailure = &treatFailureAsDeploymentFailure
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (application *VMGalleryApplication) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VMGalleryApplication{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (application *VMGalleryApplication) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VMGalleryApplication)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VMGalleryApplication, got %T", armInput)
	}

	// Set property "ConfigurationReference":
	if typedInput.ConfigurationReference != nil {
		configurationReference := *typedInput.ConfigurationReference
		application.ConfigurationReference = &configurationReference
	}

	// Set property "EnableAutomaticUpgrade":
	if typedInput.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *typedInput.EnableAutomaticUpgrade
		application.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	}

	// Set property "Order":
	if typedInput.Order != nil {
		order := *typedInput.Order
		application.Order = &order
	}

	// no assignment for property "PackageReferenceReference"

	// Set property "Tags":
	if typedInput.Tags != nil {
		tags := *typedInput.Tags
		application.Tags = &tags
	}

	// Set property "TreatFailureAsDeploymentFailure":
	if typedInput.TreatFailureAsDeploymentFailure != nil {
		treatFailureAsDeploymentFailure := *typedInput.TreatFailureAsDeploymentFailure
		application.TreatFailureAsDeploymentFailure = &treatFailureAsDeploymentFailure
	}

	// No error
	return nil
}

// AssignProperties_From_VMGalleryApplication populates our VMGalleryApplication from the provided source VMGalleryApplication
func (application *VMGalleryApplication) AssignProperties_From_VMGalleryApplication(source *storage.VMGalleryApplication) error {

	// ConfigurationReference
	application.ConfigurationReference = genruntime.ClonePointerToString(source.ConfigurationReference)

	// EnableAutomaticUpgrade
	if source.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *source.EnableAutomaticUpgrade
		application.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	} else {
		application.EnableAutomaticUpgrade = nil
	}

	// Order
	application.Order = genruntime.ClonePointerToInt(source.Order)

	// PackageReferenceReference
	if source.PackageReferenceReference != nil {
		packageReferenceReference := source.PackageReferenceReference.Copy()
		application.PackageReferenceReference = &packageReferenceReference
	} else {
		application.PackageReferenceReference = nil
	}

	// Tags
	application.Tags = genruntime.ClonePointerToString(source.Tags)

	// TreatFailureAsDeploymentFailure
	if source.TreatFailureAsDeploymentFailure != nil {
		treatFailureAsDeploymentFailure := *source.TreatFailureAsDeploymentFailure
		application.TreatFailureAsDeploymentFailure = &treatFailureAsDeploymentFailure
	} else {
		application.TreatFailureAsDeploymentFailure = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VMGalleryApplication populates the provided destination VMGalleryApplication from our VMGalleryApplication
func (application *VMGalleryApplication) AssignProperties_To_VMGalleryApplication(destination *storage.VMGalleryApplication) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigurationReference
	destination.ConfigurationReference = genruntime.ClonePointerToString(application.ConfigurationReference)

	// EnableAutomaticUpgrade
	if application.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *application.EnableAutomaticUpgrade
		destination.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	} else {
		destination.EnableAutomaticUpgrade = nil
	}

	// Order
	destination.Order = genruntime.ClonePointerToInt(application.Order)

	// PackageReferenceReference
	if application.PackageReferenceReference != nil {
		packageReferenceReference := application.PackageReferenceReference.Copy()
		destination.PackageReferenceReference = &packageReferenceReference
	} else {
		destination.PackageReferenceReference = nil
	}

	// Tags
	destination.Tags = genruntime.ClonePointerToString(application.Tags)

	// TreatFailureAsDeploymentFailure
	if application.TreatFailureAsDeploymentFailure != nil {
		treatFailureAsDeploymentFailure := *application.TreatFailureAsDeploymentFailure
		destination.TreatFailureAsDeploymentFailure = &treatFailureAsDeploymentFailure
	} else {
		destination.TreatFailureAsDeploymentFailure = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VMGalleryApplication_STATUS populates our VMGalleryApplication from the provided source VMGalleryApplication_STATUS
func (application *VMGalleryApplication) Initialize_From_VMGalleryApplication_STATUS(source *VMGalleryApplication_STATUS) error {

	// ConfigurationReference
	application.ConfigurationReference = genruntime.ClonePointerToString(source.ConfigurationReference)

	// EnableAutomaticUpgrade
	if source.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *source.EnableAutomaticUpgrade
		application.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	} else {
		application.EnableAutomaticUpgrade = nil
	}

	// Order
	application.Order = genruntime.ClonePointerToInt(source.Order)

	// PackageReferenceReference
	if source.PackageReferenceId != nil {
		packageReferenceReference := genruntime.CreateResourceReferenceFromARMID(*source.PackageReferenceId)
		application.PackageReferenceReference = &packageReferenceReference
	} else {
		application.PackageReferenceReference = nil
	}

	// Tags
	application.Tags = genruntime.ClonePointerToString(source.Tags)

	// TreatFailureAsDeploymentFailure
	if source.TreatFailureAsDeploymentFailure != nil {
		treatFailureAsDeploymentFailure := *source.TreatFailureAsDeploymentFailure
		application.TreatFailureAsDeploymentFailure = &treatFailureAsDeploymentFailure
	} else {
		application.TreatFailureAsDeploymentFailure = nil
	}

	// No error
	return nil
}

// Specifies the required information to reference a compute gallery application version
type VMGalleryApplication_STATUS struct {
	// ConfigurationReference: Optional, Specifies the uri to an azure blob that will replace the default configuration for the
	// package if provided
	ConfigurationReference *string `json:"configurationReference,omitempty"`

	// EnableAutomaticUpgrade: If set to true, when a new Gallery Application version is available in PIR/SIG, it will be
	// automatically updated for the VM/VMSS
	EnableAutomaticUpgrade *bool `json:"enableAutomaticUpgrade,omitempty"`

	// Order: Optional, Specifies the order in which the packages have to be installed
	Order *int `json:"order,omitempty"`

	// PackageReferenceId: Specifies the GalleryApplicationVersion resource id on the form of
	// /subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/applications/{application}/versions/{version}
	PackageReferenceId *string `json:"packageReferenceId,omitempty"`

	// Tags: Optional, Specifies a passthrough value for more generic context.
	Tags *string `json:"tags,omitempty"`

	// TreatFailureAsDeploymentFailure: Optional, If true, any failure for any operation in the VmApplication will fail the
	// deployment
	TreatFailureAsDeploymentFailure *bool `json:"treatFailureAsDeploymentFailure,omitempty"`
}

var _ genruntime.FromARMConverter = &VMGalleryApplication_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (application *VMGalleryApplication_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VMGalleryApplication_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (application *VMGalleryApplication_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VMGalleryApplication_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VMGalleryApplication_STATUS, got %T", armInput)
	}

	// Set property "ConfigurationReference":
	if typedInput.ConfigurationReference != nil {
		configurationReference := *typedInput.ConfigurationReference
		application.ConfigurationReference = &configurationReference
	}

	// Set property "EnableAutomaticUpgrade":
	if typedInput.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *typedInput.EnableAutomaticUpgrade
		application.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	}

	// Set property "Order":
	if typedInput.Order != nil {
		order := *typedInput.Order
		application.Order = &order
	}

	// Set property "PackageReferenceId":
	if typedInput.PackageReferenceId != nil {
		packageReferenceId := *typedInput.PackageReferenceId
		application.PackageReferenceId = &packageReferenceId
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		tags := *typedInput.Tags
		application.Tags = &tags
	}

	// Set property "TreatFailureAsDeploymentFailure":
	if typedInput.TreatFailureAsDeploymentFailure != nil {
		treatFailureAsDeploymentFailure := *typedInput.TreatFailureAsDeploymentFailure
		application.TreatFailureAsDeploymentFailure = &treatFailureAsDeploymentFailure
	}

	// No error
	return nil
}

// AssignProperties_From_VMGalleryApplication_STATUS populates our VMGalleryApplication_STATUS from the provided source VMGalleryApplication_STATUS
func (application *VMGalleryApplication_STATUS) AssignProperties_From_VMGalleryApplication_STATUS(source *storage.VMGalleryApplication_STATUS) error {

	// ConfigurationReference
	application.ConfigurationReference = genruntime.ClonePointerToString(source.ConfigurationReference)

	// EnableAutomaticUpgrade
	if source.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *source.EnableAutomaticUpgrade
		application.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	} else {
		application.EnableAutomaticUpgrade = nil
	}

	// Order
	application.Order = genruntime.ClonePointerToInt(source.Order)

	// PackageReferenceId
	application.PackageReferenceId = genruntime.ClonePointerToString(source.PackageReferenceId)

	// Tags
	application.Tags = genruntime.ClonePointerToString(source.Tags)

	// TreatFailureAsDeploymentFailure
	if source.TreatFailureAsDeploymentFailure != nil {
		treatFailureAsDeploymentFailure := *source.TreatFailureAsDeploymentFailure
		application.TreatFailureAsDeploymentFailure = &treatFailureAsDeploymentFailure
	} else {
		application.TreatFailureAsDeploymentFailure = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VMGalleryApplication_STATUS populates the provided destination VMGalleryApplication_STATUS from our VMGalleryApplication_STATUS
func (application *VMGalleryApplication_STATUS) AssignProperties_To_VMGalleryApplication_STATUS(destination *storage.VMGalleryApplication_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigurationReference
	destination.ConfigurationReference = genruntime.ClonePointerToString(application.ConfigurationReference)

	// EnableAutomaticUpgrade
	if application.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *application.EnableAutomaticUpgrade
		destination.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	} else {
		destination.EnableAutomaticUpgrade = nil
	}

	// Order
	destination.Order = genruntime.ClonePointerToInt(application.Order)

	// PackageReferenceId
	destination.PackageReferenceId = genruntime.ClonePointerToString(application.PackageReferenceId)

	// Tags
	destination.Tags = genruntime.ClonePointerToString(application.Tags)

	// TreatFailureAsDeploymentFailure
	if application.TreatFailureAsDeploymentFailure != nil {
		treatFailureAsDeploymentFailure := *application.TreatFailureAsDeploymentFailure
		destination.TreatFailureAsDeploymentFailure = &treatFailureAsDeploymentFailure
	} else {
		destination.TreatFailureAsDeploymentFailure = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Specifies VM Size Property settings on the virtual machine.
type VMSizeProperties struct {
	// VCPUsAvailable: Specifies the number of vCPUs available for the VM.
	// When this property is not specified in the request body the default behavior is to set it to the value of vCPUs
	// available for that VM size exposed in api response of [List all available virtual machine sizes in a
	// region](https://docs.microsoft.com/en-us/rest/api/compute/resource-skus/list) .
	VCPUsAvailable *int `json:"vCPUsAvailable,omitempty"`

	// VCPUsPerCore: Specifies the vCPU to physical core ratio.
	// When this property is not specified in the request body the default behavior is set to the value of vCPUsPerCore for the
	// VM Size exposed in api response of [List all available virtual machine sizes in a
	// region](https://docs.microsoft.com/en-us/rest/api/compute/resource-skus/list)
	// Setting this property to 1 also means that hyper-threading is disabled.
	VCPUsPerCore *int `json:"vCPUsPerCore,omitempty"`
}

var _ genruntime.ARMTransformer = &VMSizeProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *VMSizeProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.VMSizeProperties{}

	// Set property "VCPUsAvailable":
	if properties.VCPUsAvailable != nil {
		vcpUsAvailable := *properties.VCPUsAvailable
		result.VCPUsAvailable = &vcpUsAvailable
	}

	// Set property "VCPUsPerCore":
	if properties.VCPUsPerCore != nil {
		vcpUsPerCore := *properties.VCPUsPerCore
		result.VCPUsPerCore = &vcpUsPerCore
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *VMSizeProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VMSizeProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *VMSizeProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VMSizeProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VMSizeProperties, got %T", armInput)
	}

	// Set property "VCPUsAvailable":
	if typedInput.VCPUsAvailable != nil {
		vcpUsAvailable := *typedInput.VCPUsAvailable
		properties.VCPUsAvailable = &vcpUsAvailable
	}

	// Set property "VCPUsPerCore":
	if typedInput.VCPUsPerCore != nil {
		vcpUsPerCore := *typedInput.VCPUsPerCore
		properties.VCPUsPerCore = &vcpUsPerCore
	}

	// No error
	return nil
}

// AssignProperties_From_VMSizeProperties populates our VMSizeProperties from the provided source VMSizeProperties
func (properties *VMSizeProperties) AssignProperties_From_VMSizeProperties(source *storage.VMSizeProperties) error {

	// VCPUsAvailable
	properties.VCPUsAvailable = genruntime.ClonePointerToInt(source.VCPUsAvailable)

	// VCPUsPerCore
	properties.VCPUsPerCore = genruntime.ClonePointerToInt(source.VCPUsPerCore)

	// No error
	return nil
}

// AssignProperties_To_VMSizeProperties populates the provided destination VMSizeProperties from our VMSizeProperties
func (properties *VMSizeProperties) AssignProperties_To_VMSizeProperties(destination *storage.VMSizeProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// VCPUsAvailable
	destination.VCPUsAvailable = genruntime.ClonePointerToInt(properties.VCPUsAvailable)

	// VCPUsPerCore
	destination.VCPUsPerCore = genruntime.ClonePointerToInt(properties.VCPUsPerCore)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VMSizeProperties_STATUS populates our VMSizeProperties from the provided source VMSizeProperties_STATUS
func (properties *VMSizeProperties) Initialize_From_VMSizeProperties_STATUS(source *VMSizeProperties_STATUS) error {

	// VCPUsAvailable
	properties.VCPUsAvailable = genruntime.ClonePointerToInt(source.VCPUsAvailable)

	// VCPUsPerCore
	properties.VCPUsPerCore = genruntime.ClonePointerToInt(source.VCPUsPerCore)

	// No error
	return nil
}

// Specifies VM Size Property settings on the virtual machine.
type VMSizeProperties_STATUS struct {
	// VCPUsAvailable: Specifies the number of vCPUs available for the VM.
	// When this property is not specified in the request body the default behavior is to set it to the value of vCPUs
	// available for that VM size exposed in api response of [List all available virtual machine sizes in a
	// region](https://docs.microsoft.com/en-us/rest/api/compute/resource-skus/list) .
	VCPUsAvailable *int `json:"vCPUsAvailable,omitempty"`

	// VCPUsPerCore: Specifies the vCPU to physical core ratio.
	// When this property is not specified in the request body the default behavior is set to the value of vCPUsPerCore for the
	// VM Size exposed in api response of [List all available virtual machine sizes in a
	// region](https://docs.microsoft.com/en-us/rest/api/compute/resource-skus/list)
	// Setting this property to 1 also means that hyper-threading is disabled.
	VCPUsPerCore *int `json:"vCPUsPerCore,omitempty"`
}

var _ genruntime.FromARMConverter = &VMSizeProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *VMSizeProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VMSizeProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *VMSizeProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VMSizeProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VMSizeProperties_STATUS, got %T", armInput)
	}

	// Set property "VCPUsAvailable":
	if typedInput.VCPUsAvailable != nil {
		vcpUsAvailable := *typedInput.VCPUsAvailable
		properties.VCPUsAvailable = &vcpUsAvailable
	}

	// Set property "VCPUsPerCore":
	if typedInput.VCPUsPerCore != nil {
		vcpUsPerCore := *typedInput.VCPUsPerCore
		properties.VCPUsPerCore = &vcpUsPerCore
	}

	// No error
	return nil
}

// AssignProperties_From_VMSizeProperties_STATUS populates our VMSizeProperties_STATUS from the provided source VMSizeProperties_STATUS
func (properties *VMSizeProperties_STATUS) AssignProperties_From_VMSizeProperties_STATUS(source *storage.VMSizeProperties_STATUS) error {

	// VCPUsAvailable
	properties.VCPUsAvailable = genruntime.ClonePointerToInt(source.VCPUsAvailable)

	// VCPUsPerCore
	properties.VCPUsPerCore = genruntime.ClonePointerToInt(source.VCPUsPerCore)

	// No error
	return nil
}

// AssignProperties_To_VMSizeProperties_STATUS populates the provided destination VMSizeProperties_STATUS from our VMSizeProperties_STATUS
func (properties *VMSizeProperties_STATUS) AssignProperties_To_VMSizeProperties_STATUS(destination *storage.VMSizeProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// VCPUsAvailable
	destination.VCPUsAvailable = genruntime.ClonePointerToInt(properties.VCPUsAvailable)

	// VCPUsPerCore
	destination.VCPUsPerCore = genruntime.ClonePointerToInt(properties.VCPUsPerCore)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Specifies Windows operating system settings on the virtual machine.
type WindowsConfiguration struct {
	// AdditionalUnattendContent: Specifies additional base-64 encoded XML formatted information that can be included in the
	// Unattend.xml file, which is used by Windows Setup.
	AdditionalUnattendContent []AdditionalUnattendContent `json:"additionalUnattendContent,omitempty"`

	// EnableAutomaticUpdates: Indicates whether Automatic Updates is enabled for the Windows virtual machine. Default value is
	// true.
	// For virtual machine scale sets, this property can be updated and updates will take effect on OS reprovisioning.
	EnableAutomaticUpdates *bool `json:"enableAutomaticUpdates,omitempty"`

	// PatchSettings: [Preview Feature] Specifies settings related to VM Guest Patching on Windows.
	PatchSettings *PatchSettings `json:"patchSettings,omitempty"`

	// ProvisionVMAgent: Indicates whether virtual machine agent should be provisioned on the virtual machine.
	// When this property is not specified in the request body, default behavior is to set it to true.  This will ensure that
	// VM Agent is installed on the VM so that extensions can be added to the VM later.
	ProvisionVMAgent *bool `json:"provisionVMAgent,omitempty"`

	// TimeZone: Specifies the time zone of the virtual machine. e.g. "Pacific Standard Time".
	// Possible values can be
	// [TimeZoneInfo.Id](https://docs.microsoft.com/dotnet/api/system.timezoneinfo.id?#System_TimeZoneInfo_Id) value from time
	// zones returned by
	// [TimeZoneInfo.GetSystemTimeZones](https://docs.microsoft.com/dotnet/api/system.timezoneinfo.getsystemtimezones).
	TimeZone *string `json:"timeZone,omitempty"`

	// WinRM: Specifies the Windows Remote Management listeners. This enables remote Windows PowerShell.
	WinRM *WinRMConfiguration `json:"winRM,omitempty"`
}

var _ genruntime.ARMTransformer = &WindowsConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *WindowsConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.WindowsConfiguration{}

	// Set property "AdditionalUnattendContent":
	for _, item := range configuration.AdditionalUnattendContent {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.AdditionalUnattendContent = append(result.AdditionalUnattendContent, *item_ARM.(*arm.AdditionalUnattendContent))
	}

	// Set property "EnableAutomaticUpdates":
	if configuration.EnableAutomaticUpdates != nil {
		enableAutomaticUpdates := *configuration.EnableAutomaticUpdates
		result.EnableAutomaticUpdates = &enableAutomaticUpdates
	}

	// Set property "PatchSettings":
	if configuration.PatchSettings != nil {
		patchSettings_ARM, err := (*configuration.PatchSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		patchSettings := *patchSettings_ARM.(*arm.PatchSettings)
		result.PatchSettings = &patchSettings
	}

	// Set property "ProvisionVMAgent":
	if configuration.ProvisionVMAgent != nil {
		provisionVMAgent := *configuration.ProvisionVMAgent
		result.ProvisionVMAgent = &provisionVMAgent
	}

	// Set property "TimeZone":
	if configuration.TimeZone != nil {
		timeZone := *configuration.TimeZone
		result.TimeZone = &timeZone
	}

	// Set property "WinRM":
	if configuration.WinRM != nil {
		winRM_ARM, err := (*configuration.WinRM).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		winRM := *winRM_ARM.(*arm.WinRMConfiguration)
		result.WinRM = &winRM
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *WindowsConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WindowsConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *WindowsConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WindowsConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WindowsConfiguration, got %T", armInput)
	}

	// Set property "AdditionalUnattendContent":
	for _, item := range typedInput.AdditionalUnattendContent {
		var item1 AdditionalUnattendContent
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		configuration.AdditionalUnattendContent = append(configuration.AdditionalUnattendContent, item1)
	}

	// Set property "EnableAutomaticUpdates":
	if typedInput.EnableAutomaticUpdates != nil {
		enableAutomaticUpdates := *typedInput.EnableAutomaticUpdates
		configuration.EnableAutomaticUpdates = &enableAutomaticUpdates
	}

	// Set property "PatchSettings":
	if typedInput.PatchSettings != nil {
		var patchSettings1 PatchSettings
		err := patchSettings1.PopulateFromARM(owner, *typedInput.PatchSettings)
		if err != nil {
			return err
		}
		patchSettings := patchSettings1
		configuration.PatchSettings = &patchSettings
	}

	// Set property "ProvisionVMAgent":
	if typedInput.ProvisionVMAgent != nil {
		provisionVMAgent := *typedInput.ProvisionVMAgent
		configuration.ProvisionVMAgent = &provisionVMAgent
	}

	// Set property "TimeZone":
	if typedInput.TimeZone != nil {
		timeZone := *typedInput.TimeZone
		configuration.TimeZone = &timeZone
	}

	// Set property "WinRM":
	if typedInput.WinRM != nil {
		var winRM1 WinRMConfiguration
		err := winRM1.PopulateFromARM(owner, *typedInput.WinRM)
		if err != nil {
			return err
		}
		winRM := winRM1
		configuration.WinRM = &winRM
	}

	// No error
	return nil
}

// AssignProperties_From_WindowsConfiguration populates our WindowsConfiguration from the provided source WindowsConfiguration
func (configuration *WindowsConfiguration) AssignProperties_From_WindowsConfiguration(source *storage.WindowsConfiguration) error {

	// AdditionalUnattendContent
	if source.AdditionalUnattendContent != nil {
		additionalUnattendContentList := make([]AdditionalUnattendContent, len(source.AdditionalUnattendContent))
		for additionalUnattendContentIndex, additionalUnattendContentItem := range source.AdditionalUnattendContent {
			// Shadow the loop variable to avoid aliasing
			additionalUnattendContentItem := additionalUnattendContentItem
			var additionalUnattendContent AdditionalUnattendContent
			err := additionalUnattendContent.AssignProperties_From_AdditionalUnattendContent(&additionalUnattendContentItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_AdditionalUnattendContent() to populate field AdditionalUnattendContent")
			}
			additionalUnattendContentList[additionalUnattendContentIndex] = additionalUnattendContent
		}
		configuration.AdditionalUnattendContent = additionalUnattendContentList
	} else {
		configuration.AdditionalUnattendContent = nil
	}

	// EnableAutomaticUpdates
	if source.EnableAutomaticUpdates != nil {
		enableAutomaticUpdate := *source.EnableAutomaticUpdates
		configuration.EnableAutomaticUpdates = &enableAutomaticUpdate
	} else {
		configuration.EnableAutomaticUpdates = nil
	}

	// PatchSettings
	if source.PatchSettings != nil {
		var patchSetting PatchSettings
		err := patchSetting.AssignProperties_From_PatchSettings(source.PatchSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PatchSettings() to populate field PatchSettings")
		}
		configuration.PatchSettings = &patchSetting
	} else {
		configuration.PatchSettings = nil
	}

	// ProvisionVMAgent
	if source.ProvisionVMAgent != nil {
		provisionVMAgent := *source.ProvisionVMAgent
		configuration.ProvisionVMAgent = &provisionVMAgent
	} else {
		configuration.ProvisionVMAgent = nil
	}

	// TimeZone
	configuration.TimeZone = genruntime.ClonePointerToString(source.TimeZone)

	// WinRM
	if source.WinRM != nil {
		var winRM WinRMConfiguration
		err := winRM.AssignProperties_From_WinRMConfiguration(source.WinRM)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WinRMConfiguration() to populate field WinRM")
		}
		configuration.WinRM = &winRM
	} else {
		configuration.WinRM = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WindowsConfiguration populates the provided destination WindowsConfiguration from our WindowsConfiguration
func (configuration *WindowsConfiguration) AssignProperties_To_WindowsConfiguration(destination *storage.WindowsConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalUnattendContent
	if configuration.AdditionalUnattendContent != nil {
		additionalUnattendContentList := make([]storage.AdditionalUnattendContent, len(configuration.AdditionalUnattendContent))
		for additionalUnattendContentIndex, additionalUnattendContentItem := range configuration.AdditionalUnattendContent {
			// Shadow the loop variable to avoid aliasing
			additionalUnattendContentItem := additionalUnattendContentItem
			var additionalUnattendContent storage.AdditionalUnattendContent
			err := additionalUnattendContentItem.AssignProperties_To_AdditionalUnattendContent(&additionalUnattendContent)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_AdditionalUnattendContent() to populate field AdditionalUnattendContent")
			}
			additionalUnattendContentList[additionalUnattendContentIndex] = additionalUnattendContent
		}
		destination.AdditionalUnattendContent = additionalUnattendContentList
	} else {
		destination.AdditionalUnattendContent = nil
	}

	// EnableAutomaticUpdates
	if configuration.EnableAutomaticUpdates != nil {
		enableAutomaticUpdate := *configuration.EnableAutomaticUpdates
		destination.EnableAutomaticUpdates = &enableAutomaticUpdate
	} else {
		destination.EnableAutomaticUpdates = nil
	}

	// PatchSettings
	if configuration.PatchSettings != nil {
		var patchSetting storage.PatchSettings
		err := configuration.PatchSettings.AssignProperties_To_PatchSettings(&patchSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PatchSettings() to populate field PatchSettings")
		}
		destination.PatchSettings = &patchSetting
	} else {
		destination.PatchSettings = nil
	}

	// ProvisionVMAgent
	if configuration.ProvisionVMAgent != nil {
		provisionVMAgent := *configuration.ProvisionVMAgent
		destination.ProvisionVMAgent = &provisionVMAgent
	} else {
		destination.ProvisionVMAgent = nil
	}

	// TimeZone
	destination.TimeZone = genruntime.ClonePointerToString(configuration.TimeZone)

	// WinRM
	if configuration.WinRM != nil {
		var winRM storage.WinRMConfiguration
		err := configuration.WinRM.AssignProperties_To_WinRMConfiguration(&winRM)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WinRMConfiguration() to populate field WinRM")
		}
		destination.WinRM = &winRM
	} else {
		destination.WinRM = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_WindowsConfiguration_STATUS populates our WindowsConfiguration from the provided source WindowsConfiguration_STATUS
func (configuration *WindowsConfiguration) Initialize_From_WindowsConfiguration_STATUS(source *WindowsConfiguration_STATUS) error {

	// AdditionalUnattendContent
	if source.AdditionalUnattendContent != nil {
		additionalUnattendContentList := make([]AdditionalUnattendContent, len(source.AdditionalUnattendContent))
		for additionalUnattendContentIndex, additionalUnattendContentItem := range source.AdditionalUnattendContent {
			// Shadow the loop variable to avoid aliasing
			additionalUnattendContentItem := additionalUnattendContentItem
			var additionalUnattendContent AdditionalUnattendContent
			err := additionalUnattendContent.Initialize_From_AdditionalUnattendContent_STATUS(&additionalUnattendContentItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_AdditionalUnattendContent_STATUS() to populate field AdditionalUnattendContent")
			}
			additionalUnattendContentList[additionalUnattendContentIndex] = additionalUnattendContent
		}
		configuration.AdditionalUnattendContent = additionalUnattendContentList
	} else {
		configuration.AdditionalUnattendContent = nil
	}

	// EnableAutomaticUpdates
	if source.EnableAutomaticUpdates != nil {
		enableAutomaticUpdate := *source.EnableAutomaticUpdates
		configuration.EnableAutomaticUpdates = &enableAutomaticUpdate
	} else {
		configuration.EnableAutomaticUpdates = nil
	}

	// PatchSettings
	if source.PatchSettings != nil {
		var patchSetting PatchSettings
		err := patchSetting.Initialize_From_PatchSettings_STATUS(source.PatchSettings)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_PatchSettings_STATUS() to populate field PatchSettings")
		}
		configuration.PatchSettings = &patchSetting
	} else {
		configuration.PatchSettings = nil
	}

	// ProvisionVMAgent
	if source.ProvisionVMAgent != nil {
		provisionVMAgent := *source.ProvisionVMAgent
		configuration.ProvisionVMAgent = &provisionVMAgent
	} else {
		configuration.ProvisionVMAgent = nil
	}

	// TimeZone
	configuration.TimeZone = genruntime.ClonePointerToString(source.TimeZone)

	// WinRM
	if source.WinRM != nil {
		var winRM WinRMConfiguration
		err := winRM.Initialize_From_WinRMConfiguration_STATUS(source.WinRM)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_WinRMConfiguration_STATUS() to populate field WinRM")
		}
		configuration.WinRM = &winRM
	} else {
		configuration.WinRM = nil
	}

	// No error
	return nil
}

// Specifies Windows operating system settings on the virtual machine.
type WindowsConfiguration_STATUS struct {
	// AdditionalUnattendContent: Specifies additional base-64 encoded XML formatted information that can be included in the
	// Unattend.xml file, which is used by Windows Setup.
	AdditionalUnattendContent []AdditionalUnattendContent_STATUS `json:"additionalUnattendContent,omitempty"`

	// EnableAutomaticUpdates: Indicates whether Automatic Updates is enabled for the Windows virtual machine. Default value is
	// true.
	// For virtual machine scale sets, this property can be updated and updates will take effect on OS reprovisioning.
	EnableAutomaticUpdates *bool `json:"enableAutomaticUpdates,omitempty"`

	// PatchSettings: [Preview Feature] Specifies settings related to VM Guest Patching on Windows.
	PatchSettings *PatchSettings_STATUS `json:"patchSettings,omitempty"`

	// ProvisionVMAgent: Indicates whether virtual machine agent should be provisioned on the virtual machine.
	// When this property is not specified in the request body, default behavior is to set it to true.  This will ensure that
	// VM Agent is installed on the VM so that extensions can be added to the VM later.
	ProvisionVMAgent *bool `json:"provisionVMAgent,omitempty"`

	// TimeZone: Specifies the time zone of the virtual machine. e.g. "Pacific Standard Time".
	// Possible values can be
	// [TimeZoneInfo.Id](https://docs.microsoft.com/dotnet/api/system.timezoneinfo.id?#System_TimeZoneInfo_Id) value from time
	// zones returned by
	// [TimeZoneInfo.GetSystemTimeZones](https://docs.microsoft.com/dotnet/api/system.timezoneinfo.getsystemtimezones).
	TimeZone *string `json:"timeZone,omitempty"`

	// WinRM: Specifies the Windows Remote Management listeners. This enables remote Windows PowerShell.
	WinRM *WinRMConfiguration_STATUS `json:"winRM,omitempty"`
}

var _ genruntime.FromARMConverter = &WindowsConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *WindowsConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WindowsConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *WindowsConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WindowsConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WindowsConfiguration_STATUS, got %T", armInput)
	}

	// Set property "AdditionalUnattendContent":
	for _, item := range typedInput.AdditionalUnattendContent {
		var item1 AdditionalUnattendContent_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		configuration.AdditionalUnattendContent = append(configuration.AdditionalUnattendContent, item1)
	}

	// Set property "EnableAutomaticUpdates":
	if typedInput.EnableAutomaticUpdates != nil {
		enableAutomaticUpdates := *typedInput.EnableAutomaticUpdates
		configuration.EnableAutomaticUpdates = &enableAutomaticUpdates
	}

	// Set property "PatchSettings":
	if typedInput.PatchSettings != nil {
		var patchSettings1 PatchSettings_STATUS
		err := patchSettings1.PopulateFromARM(owner, *typedInput.PatchSettings)
		if err != nil {
			return err
		}
		patchSettings := patchSettings1
		configuration.PatchSettings = &patchSettings
	}

	// Set property "ProvisionVMAgent":
	if typedInput.ProvisionVMAgent != nil {
		provisionVMAgent := *typedInput.ProvisionVMAgent
		configuration.ProvisionVMAgent = &provisionVMAgent
	}

	// Set property "TimeZone":
	if typedInput.TimeZone != nil {
		timeZone := *typedInput.TimeZone
		configuration.TimeZone = &timeZone
	}

	// Set property "WinRM":
	if typedInput.WinRM != nil {
		var winRM1 WinRMConfiguration_STATUS
		err := winRM1.PopulateFromARM(owner, *typedInput.WinRM)
		if err != nil {
			return err
		}
		winRM := winRM1
		configuration.WinRM = &winRM
	}

	// No error
	return nil
}

// AssignProperties_From_WindowsConfiguration_STATUS populates our WindowsConfiguration_STATUS from the provided source WindowsConfiguration_STATUS
func (configuration *WindowsConfiguration_STATUS) AssignProperties_From_WindowsConfiguration_STATUS(source *storage.WindowsConfiguration_STATUS) error {

	// AdditionalUnattendContent
	if source.AdditionalUnattendContent != nil {
		additionalUnattendContentList := make([]AdditionalUnattendContent_STATUS, len(source.AdditionalUnattendContent))
		for additionalUnattendContentIndex, additionalUnattendContentItem := range source.AdditionalUnattendContent {
			// Shadow the loop variable to avoid aliasing
			additionalUnattendContentItem := additionalUnattendContentItem
			var additionalUnattendContent AdditionalUnattendContent_STATUS
			err := additionalUnattendContent.AssignProperties_From_AdditionalUnattendContent_STATUS(&additionalUnattendContentItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_AdditionalUnattendContent_STATUS() to populate field AdditionalUnattendContent")
			}
			additionalUnattendContentList[additionalUnattendContentIndex] = additionalUnattendContent
		}
		configuration.AdditionalUnattendContent = additionalUnattendContentList
	} else {
		configuration.AdditionalUnattendContent = nil
	}

	// EnableAutomaticUpdates
	if source.EnableAutomaticUpdates != nil {
		enableAutomaticUpdate := *source.EnableAutomaticUpdates
		configuration.EnableAutomaticUpdates = &enableAutomaticUpdate
	} else {
		configuration.EnableAutomaticUpdates = nil
	}

	// PatchSettings
	if source.PatchSettings != nil {
		var patchSetting PatchSettings_STATUS
		err := patchSetting.AssignProperties_From_PatchSettings_STATUS(source.PatchSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PatchSettings_STATUS() to populate field PatchSettings")
		}
		configuration.PatchSettings = &patchSetting
	} else {
		configuration.PatchSettings = nil
	}

	// ProvisionVMAgent
	if source.ProvisionVMAgent != nil {
		provisionVMAgent := *source.ProvisionVMAgent
		configuration.ProvisionVMAgent = &provisionVMAgent
	} else {
		configuration.ProvisionVMAgent = nil
	}

	// TimeZone
	configuration.TimeZone = genruntime.ClonePointerToString(source.TimeZone)

	// WinRM
	if source.WinRM != nil {
		var winRM WinRMConfiguration_STATUS
		err := winRM.AssignProperties_From_WinRMConfiguration_STATUS(source.WinRM)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WinRMConfiguration_STATUS() to populate field WinRM")
		}
		configuration.WinRM = &winRM
	} else {
		configuration.WinRM = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WindowsConfiguration_STATUS populates the provided destination WindowsConfiguration_STATUS from our WindowsConfiguration_STATUS
func (configuration *WindowsConfiguration_STATUS) AssignProperties_To_WindowsConfiguration_STATUS(destination *storage.WindowsConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalUnattendContent
	if configuration.AdditionalUnattendContent != nil {
		additionalUnattendContentList := make([]storage.AdditionalUnattendContent_STATUS, len(configuration.AdditionalUnattendContent))
		for additionalUnattendContentIndex, additionalUnattendContentItem := range configuration.AdditionalUnattendContent {
			// Shadow the loop variable to avoid aliasing
			additionalUnattendContentItem := additionalUnattendContentItem
			var additionalUnattendContent storage.AdditionalUnattendContent_STATUS
			err := additionalUnattendContentItem.AssignProperties_To_AdditionalUnattendContent_STATUS(&additionalUnattendContent)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_AdditionalUnattendContent_STATUS() to populate field AdditionalUnattendContent")
			}
			additionalUnattendContentList[additionalUnattendContentIndex] = additionalUnattendContent
		}
		destination.AdditionalUnattendContent = additionalUnattendContentList
	} else {
		destination.AdditionalUnattendContent = nil
	}

	// EnableAutomaticUpdates
	if configuration.EnableAutomaticUpdates != nil {
		enableAutomaticUpdate := *configuration.EnableAutomaticUpdates
		destination.EnableAutomaticUpdates = &enableAutomaticUpdate
	} else {
		destination.EnableAutomaticUpdates = nil
	}

	// PatchSettings
	if configuration.PatchSettings != nil {
		var patchSetting storage.PatchSettings_STATUS
		err := configuration.PatchSettings.AssignProperties_To_PatchSettings_STATUS(&patchSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PatchSettings_STATUS() to populate field PatchSettings")
		}
		destination.PatchSettings = &patchSetting
	} else {
		destination.PatchSettings = nil
	}

	// ProvisionVMAgent
	if configuration.ProvisionVMAgent != nil {
		provisionVMAgent := *configuration.ProvisionVMAgent
		destination.ProvisionVMAgent = &provisionVMAgent
	} else {
		destination.ProvisionVMAgent = nil
	}

	// TimeZone
	destination.TimeZone = genruntime.ClonePointerToString(configuration.TimeZone)

	// WinRM
	if configuration.WinRM != nil {
		var winRM storage.WinRMConfiguration_STATUS
		err := configuration.WinRM.AssignProperties_To_WinRMConfiguration_STATUS(&winRM)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WinRMConfiguration_STATUS() to populate field WinRM")
		}
		destination.WinRM = &winRM
	} else {
		destination.WinRM = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Specifies additional XML formatted information that can be included in the Unattend.xml file, which is used by Windows
// Setup. Contents are defined by setting name, component name, and the pass in which the content is applied.
type AdditionalUnattendContent struct {
	// ComponentName: The component name. Currently, the only allowable value is Microsoft-Windows-Shell-Setup.
	ComponentName *AdditionalUnattendContent_ComponentName `json:"componentName,omitempty"`

	// Content: Specifies the XML formatted content that is added to the unattend.xml file for the specified path and
	// component. The XML must be less than 4KB and must include the root element for the setting or feature that is being
	// inserted.
	Content *string `json:"content,omitempty"`

	// PassName: The pass name. Currently, the only allowable value is OobeSystem.
	PassName *AdditionalUnattendContent_PassName `json:"passName,omitempty"`

	// SettingName: Specifies the name of the setting to which the content applies. Possible values are: FirstLogonCommands and
	// AutoLogon.
	SettingName *AdditionalUnattendContent_SettingName `json:"settingName,omitempty"`
}

var _ genruntime.ARMTransformer = &AdditionalUnattendContent{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (content *AdditionalUnattendContent) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if content == nil {
		return nil, nil
	}
	result := &arm.AdditionalUnattendContent{}

	// Set property "ComponentName":
	if content.ComponentName != nil {
		var temp string
		temp = string(*content.ComponentName)
		componentName := arm.AdditionalUnattendContent_ComponentName(temp)
		result.ComponentName = &componentName
	}

	// Set property "Content":
	if content.Content != nil {
		content1 := *content.Content
		result.Content = &content1
	}

	// Set property "PassName":
	if content.PassName != nil {
		var temp string
		temp = string(*content.PassName)
		passName := arm.AdditionalUnattendContent_PassName(temp)
		result.PassName = &passName
	}

	// Set property "SettingName":
	if content.SettingName != nil {
		var temp string
		temp = string(*content.SettingName)
		settingName := arm.AdditionalUnattendContent_SettingName(temp)
		result.SettingName = &settingName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (content *AdditionalUnattendContent) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AdditionalUnattendContent{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (content *AdditionalUnattendContent) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AdditionalUnattendContent)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AdditionalUnattendContent, got %T", armInput)
	}

	// Set property "ComponentName":
	if typedInput.ComponentName != nil {
		var temp string
		temp = string(*typedInput.ComponentName)
		componentName := AdditionalUnattendContent_ComponentName(temp)
		content.ComponentName = &componentName
	}

	// Set property "Content":
	if typedInput.Content != nil {
		content1 := *typedInput.Content
		content.Content = &content1
	}

	// Set property "PassName":
	if typedInput.PassName != nil {
		var temp string
		temp = string(*typedInput.PassName)
		passName := AdditionalUnattendContent_PassName(temp)
		content.PassName = &passName
	}

	// Set property "SettingName":
	if typedInput.SettingName != nil {
		var temp string
		temp = string(*typedInput.SettingName)
		settingName := AdditionalUnattendContent_SettingName(temp)
		content.SettingName = &settingName
	}

	// No error
	return nil
}

// AssignProperties_From_AdditionalUnattendContent populates our AdditionalUnattendContent from the provided source AdditionalUnattendContent
func (content *AdditionalUnattendContent) AssignProperties_From_AdditionalUnattendContent(source *storage.AdditionalUnattendContent) error {

	// ComponentName
	if source.ComponentName != nil {
		componentName := *source.ComponentName
		componentNameTemp := genruntime.ToEnum(componentName, additionalUnattendContent_ComponentName_Values)
		content.ComponentName = &componentNameTemp
	} else {
		content.ComponentName = nil
	}

	// Content
	content.Content = genruntime.ClonePointerToString(source.Content)

	// PassName
	if source.PassName != nil {
		passName := *source.PassName
		passNameTemp := genruntime.ToEnum(passName, additionalUnattendContent_PassName_Values)
		content.PassName = &passNameTemp
	} else {
		content.PassName = nil
	}

	// SettingName
	if source.SettingName != nil {
		settingName := *source.SettingName
		settingNameTemp := genruntime.ToEnum(settingName, additionalUnattendContent_SettingName_Values)
		content.SettingName = &settingNameTemp
	} else {
		content.SettingName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AdditionalUnattendContent populates the provided destination AdditionalUnattendContent from our AdditionalUnattendContent
func (content *AdditionalUnattendContent) AssignProperties_To_AdditionalUnattendContent(destination *storage.AdditionalUnattendContent) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComponentName
	if content.ComponentName != nil {
		componentName := string(*content.ComponentName)
		destination.ComponentName = &componentName
	} else {
		destination.ComponentName = nil
	}

	// Content
	destination.Content = genruntime.ClonePointerToString(content.Content)

	// PassName
	if content.PassName != nil {
		passName := string(*content.PassName)
		destination.PassName = &passName
	} else {
		destination.PassName = nil
	}

	// SettingName
	if content.SettingName != nil {
		settingName := string(*content.SettingName)
		destination.SettingName = &settingName
	} else {
		destination.SettingName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AdditionalUnattendContent_STATUS populates our AdditionalUnattendContent from the provided source AdditionalUnattendContent_STATUS
func (content *AdditionalUnattendContent) Initialize_From_AdditionalUnattendContent_STATUS(source *AdditionalUnattendContent_STATUS) error {

	// ComponentName
	if source.ComponentName != nil {
		componentName := genruntime.ToEnum(string(*source.ComponentName), additionalUnattendContent_ComponentName_Values)
		content.ComponentName = &componentName
	} else {
		content.ComponentName = nil
	}

	// Content
	content.Content = genruntime.ClonePointerToString(source.Content)

	// PassName
	if source.PassName != nil {
		passName := genruntime.ToEnum(string(*source.PassName), additionalUnattendContent_PassName_Values)
		content.PassName = &passName
	} else {
		content.PassName = nil
	}

	// SettingName
	if source.SettingName != nil {
		settingName := genruntime.ToEnum(string(*source.SettingName), additionalUnattendContent_SettingName_Values)
		content.SettingName = &settingName
	} else {
		content.SettingName = nil
	}

	// No error
	return nil
}

// Specifies additional XML formatted information that can be included in the Unattend.xml file, which is used by Windows
// Setup. Contents are defined by setting name, component name, and the pass in which the content is applied.
type AdditionalUnattendContent_STATUS struct {
	// ComponentName: The component name. Currently, the only allowable value is Microsoft-Windows-Shell-Setup.
	ComponentName *AdditionalUnattendContent_ComponentName_STATUS `json:"componentName,omitempty"`

	// Content: Specifies the XML formatted content that is added to the unattend.xml file for the specified path and
	// component. The XML must be less than 4KB and must include the root element for the setting or feature that is being
	// inserted.
	Content *string `json:"content,omitempty"`

	// PassName: The pass name. Currently, the only allowable value is OobeSystem.
	PassName *AdditionalUnattendContent_PassName_STATUS `json:"passName,omitempty"`

	// SettingName: Specifies the name of the setting to which the content applies. Possible values are: FirstLogonCommands and
	// AutoLogon.
	SettingName *AdditionalUnattendContent_SettingName_STATUS `json:"settingName,omitempty"`
}

var _ genruntime.FromARMConverter = &AdditionalUnattendContent_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (content *AdditionalUnattendContent_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AdditionalUnattendContent_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (content *AdditionalUnattendContent_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AdditionalUnattendContent_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AdditionalUnattendContent_STATUS, got %T", armInput)
	}

	// Set property "ComponentName":
	if typedInput.ComponentName != nil {
		var temp string
		temp = string(*typedInput.ComponentName)
		componentName := AdditionalUnattendContent_ComponentName_STATUS(temp)
		content.ComponentName = &componentName
	}

	// Set property "Content":
	if typedInput.Content != nil {
		content1 := *typedInput.Content
		content.Content = &content1
	}

	// Set property "PassName":
	if typedInput.PassName != nil {
		var temp string
		temp = string(*typedInput.PassName)
		passName := AdditionalUnattendContent_PassName_STATUS(temp)
		content.PassName = &passName
	}

	// Set property "SettingName":
	if typedInput.SettingName != nil {
		var temp string
		temp = string(*typedInput.SettingName)
		settingName := AdditionalUnattendContent_SettingName_STATUS(temp)
		content.SettingName = &settingName
	}

	// No error
	return nil
}

// AssignProperties_From_AdditionalUnattendContent_STATUS populates our AdditionalUnattendContent_STATUS from the provided source AdditionalUnattendContent_STATUS
func (content *AdditionalUnattendContent_STATUS) AssignProperties_From_AdditionalUnattendContent_STATUS(source *storage.AdditionalUnattendContent_STATUS) error {

	// ComponentName
	if source.ComponentName != nil {
		componentName := *source.ComponentName
		componentNameTemp := genruntime.ToEnum(componentName, additionalUnattendContent_ComponentName_STATUS_Values)
		content.ComponentName = &componentNameTemp
	} else {
		content.ComponentName = nil
	}

	// Content
	content.Content = genruntime.ClonePointerToString(source.Content)

	// PassName
	if source.PassName != nil {
		passName := *source.PassName
		passNameTemp := genruntime.ToEnum(passName, additionalUnattendContent_PassName_STATUS_Values)
		content.PassName = &passNameTemp
	} else {
		content.PassName = nil
	}

	// SettingName
	if source.SettingName != nil {
		settingName := *source.SettingName
		settingNameTemp := genruntime.ToEnum(settingName, additionalUnattendContent_SettingName_STATUS_Values)
		content.SettingName = &settingNameTemp
	} else {
		content.SettingName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AdditionalUnattendContent_STATUS populates the provided destination AdditionalUnattendContent_STATUS from our AdditionalUnattendContent_STATUS
func (content *AdditionalUnattendContent_STATUS) AssignProperties_To_AdditionalUnattendContent_STATUS(destination *storage.AdditionalUnattendContent_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComponentName
	if content.ComponentName != nil {
		componentName := string(*content.ComponentName)
		destination.ComponentName = &componentName
	} else {
		destination.ComponentName = nil
	}

	// Content
	destination.Content = genruntime.ClonePointerToString(content.Content)

	// PassName
	if content.PassName != nil {
		passName := string(*content.PassName)
		destination.PassName = &passName
	} else {
		destination.PassName = nil
	}

	// SettingName
	if content.SettingName != nil {
		settingName := string(*content.SettingName)
		destination.SettingName = &settingName
	} else {
		destination.SettingName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes the properties of an virtual machine instance view for available patch summary.
type AvailablePatchSummary_STATUS struct {
	// AssessmentActivityId: The activity ID of the operation that produced this result. It is used to correlate across CRP and
	// extension logs.
	AssessmentActivityId *string `json:"assessmentActivityId,omitempty"`

	// CriticalAndSecurityPatchCount: The number of critical or security patches that have been detected as available and not
	// yet installed.
	CriticalAndSecurityPatchCount *int `json:"criticalAndSecurityPatchCount,omitempty"`

	// Error: The errors that were encountered during execution of the operation. The details array contains the list of them.
	Error *ApiError_STATUS `json:"error,omitempty"`

	// LastModifiedTime: The UTC timestamp when the operation began.
	LastModifiedTime *string `json:"lastModifiedTime,omitempty"`

	// OtherPatchCount: The number of all available patches excluding critical and security.
	OtherPatchCount *int `json:"otherPatchCount,omitempty"`

	// RebootPending: The overall reboot status of the VM. It will be true when partially installed patches require a reboot to
	// complete installation but the reboot has not yet occurred.
	RebootPending *bool `json:"rebootPending,omitempty"`

	// StartTime: The UTC timestamp when the operation began.
	StartTime *string `json:"startTime,omitempty"`

	// Status: The overall success or failure status of the operation. It remains "InProgress" until the operation completes.
	// At that point it will become "Unknown", "Failed", "Succeeded", or "CompletedWithWarnings."
	Status *AvailablePatchSummary_Status_STATUS `json:"status,omitempty"`
}

var _ genruntime.FromARMConverter = &AvailablePatchSummary_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (summary *AvailablePatchSummary_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AvailablePatchSummary_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (summary *AvailablePatchSummary_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AvailablePatchSummary_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AvailablePatchSummary_STATUS, got %T", armInput)
	}

	// Set property "AssessmentActivityId":
	if typedInput.AssessmentActivityId != nil {
		assessmentActivityId := *typedInput.AssessmentActivityId
		summary.AssessmentActivityId = &assessmentActivityId
	}

	// Set property "CriticalAndSecurityPatchCount":
	if typedInput.CriticalAndSecurityPatchCount != nil {
		criticalAndSecurityPatchCount := *typedInput.CriticalAndSecurityPatchCount
		summary.CriticalAndSecurityPatchCount = &criticalAndSecurityPatchCount
	}

	// Set property "Error":
	if typedInput.Error != nil {
		var error1 ApiError_STATUS
		err := error1.PopulateFromARM(owner, *typedInput.Error)
		if err != nil {
			return err
		}
		error := error1
		summary.Error = &error
	}

	// Set property "LastModifiedTime":
	if typedInput.LastModifiedTime != nil {
		lastModifiedTime := *typedInput.LastModifiedTime
		summary.LastModifiedTime = &lastModifiedTime
	}

	// Set property "OtherPatchCount":
	if typedInput.OtherPatchCount != nil {
		otherPatchCount := *typedInput.OtherPatchCount
		summary.OtherPatchCount = &otherPatchCount
	}

	// Set property "RebootPending":
	if typedInput.RebootPending != nil {
		rebootPending := *typedInput.RebootPending
		summary.RebootPending = &rebootPending
	}

	// Set property "StartTime":
	if typedInput.StartTime != nil {
		startTime := *typedInput.StartTime
		summary.StartTime = &startTime
	}

	// Set property "Status":
	if typedInput.Status != nil {
		var temp string
		temp = string(*typedInput.Status)
		status := AvailablePatchSummary_Status_STATUS(temp)
		summary.Status = &status
	}

	// No error
	return nil
}

// AssignProperties_From_AvailablePatchSummary_STATUS populates our AvailablePatchSummary_STATUS from the provided source AvailablePatchSummary_STATUS
func (summary *AvailablePatchSummary_STATUS) AssignProperties_From_AvailablePatchSummary_STATUS(source *storage.AvailablePatchSummary_STATUS) error {

	// AssessmentActivityId
	summary.AssessmentActivityId = genruntime.ClonePointerToString(source.AssessmentActivityId)

	// CriticalAndSecurityPatchCount
	summary.CriticalAndSecurityPatchCount = genruntime.ClonePointerToInt(source.CriticalAndSecurityPatchCount)

	// Error
	if source.Error != nil {
		var error ApiError_STATUS
		err := error.AssignProperties_From_ApiError_STATUS(source.Error)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApiError_STATUS() to populate field Error")
		}
		summary.Error = &error
	} else {
		summary.Error = nil
	}

	// LastModifiedTime
	summary.LastModifiedTime = genruntime.ClonePointerToString(source.LastModifiedTime)

	// OtherPatchCount
	summary.OtherPatchCount = genruntime.ClonePointerToInt(source.OtherPatchCount)

	// RebootPending
	if source.RebootPending != nil {
		rebootPending := *source.RebootPending
		summary.RebootPending = &rebootPending
	} else {
		summary.RebootPending = nil
	}

	// StartTime
	summary.StartTime = genruntime.ClonePointerToString(source.StartTime)

	// Status
	if source.Status != nil {
		status := *source.Status
		statusTemp := genruntime.ToEnum(status, availablePatchSummary_Status_STATUS_Values)
		summary.Status = &statusTemp
	} else {
		summary.Status = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AvailablePatchSummary_STATUS populates the provided destination AvailablePatchSummary_STATUS from our AvailablePatchSummary_STATUS
func (summary *AvailablePatchSummary_STATUS) AssignProperties_To_AvailablePatchSummary_STATUS(destination *storage.AvailablePatchSummary_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AssessmentActivityId
	destination.AssessmentActivityId = genruntime.ClonePointerToString(summary.AssessmentActivityId)

	// CriticalAndSecurityPatchCount
	destination.CriticalAndSecurityPatchCount = genruntime.ClonePointerToInt(summary.CriticalAndSecurityPatchCount)

	// Error
	if summary.Error != nil {
		var error storage.ApiError_STATUS
		err := summary.Error.AssignProperties_To_ApiError_STATUS(&error)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApiError_STATUS() to populate field Error")
		}
		destination.Error = &error
	} else {
		destination.Error = nil
	}

	// LastModifiedTime
	destination.LastModifiedTime = genruntime.ClonePointerToString(summary.LastModifiedTime)

	// OtherPatchCount
	destination.OtherPatchCount = genruntime.ClonePointerToInt(summary.OtherPatchCount)

	// RebootPending
	if summary.RebootPending != nil {
		rebootPending := *summary.RebootPending
		destination.RebootPending = &rebootPending
	} else {
		destination.RebootPending = nil
	}

	// StartTime
	destination.StartTime = genruntime.ClonePointerToString(summary.StartTime)

	// Status
	if summary.Status != nil {
		status := string(*summary.Status)
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Specifies the caching requirements.
// Possible values are:
// None
// ReadOnly
// ReadWrite
// Default: None for Standard storage. ReadOnly for Premium storage
// +kubebuilder:validation:Enum={"None","ReadOnly","ReadWrite"}
type Caching string

const (
	Caching_None      = Caching("None")
	Caching_ReadOnly  = Caching("ReadOnly")
	Caching_ReadWrite = Caching("ReadWrite")
)

// Mapping from string to Caching
var caching_Values = map[string]Caching{
	"none":      Caching_None,
	"readonly":  Caching_ReadOnly,
	"readwrite": Caching_ReadWrite,
}

// Specifies the caching requirements.
// Possible values are:
// None
// ReadOnly
// ReadWrite
// Default: None for Standard storage. ReadOnly for Premium storage
type Caching_STATUS string

const (
	Caching_STATUS_None      = Caching_STATUS("None")
	Caching_STATUS_ReadOnly  = Caching_STATUS("ReadOnly")
	Caching_STATUS_ReadWrite = Caching_STATUS("ReadWrite")
)

// Mapping from string to Caching_STATUS
var caching_STATUS_Values = map[string]Caching_STATUS{
	"none":      Caching_STATUS_None,
	"readonly":  Caching_STATUS_ReadOnly,
	"readwrite": Caching_STATUS_ReadWrite,
}

// Specifies how the virtual machine should be created.
// Possible values are:
// Attach \u2013 This value
// is used when you are using a specialized disk to create the virtual machine.
// FromImage \u2013 This value is
// used when you are using an image to create the virtual machine. If you are using a platform image, you also use the
// imageReference element described above. If you are using a marketplace image, you  also use the plan element previously
// described.
// +kubebuilder:validation:Enum={"Attach","Empty","FromImage"}
type CreateOption string

const (
	CreateOption_Attach    = CreateOption("Attach")
	CreateOption_Empty     = CreateOption("Empty")
	CreateOption_FromImage = CreateOption("FromImage")
)

// Mapping from string to CreateOption
var createOption_Values = map[string]CreateOption{
	"attach":    CreateOption_Attach,
	"empty":     CreateOption_Empty,
	"fromimage": CreateOption_FromImage,
}

// Specifies how the virtual machine should be created.
// Possible values are:
// Attach \u2013 This value
// is used when you are using a specialized disk to create the virtual machine.
// FromImage \u2013 This value is
// used when you are using an image to create the virtual machine. If you are using a platform image, you also use the
// imageReference element described above. If you are using a marketplace image, you  also use the plan element previously
// described.
type CreateOption_STATUS string

const (
	CreateOption_STATUS_Attach    = CreateOption_STATUS("Attach")
	CreateOption_STATUS_Empty     = CreateOption_STATUS("Empty")
	CreateOption_STATUS_FromImage = CreateOption_STATUS("FromImage")
)

// Mapping from string to CreateOption_STATUS
var createOption_STATUS_Values = map[string]CreateOption_STATUS{
	"attach":    CreateOption_STATUS_Attach,
	"empty":     CreateOption_STATUS_Empty,
	"fromimage": CreateOption_STATUS_FromImage,
}

// Specifies the behavior of the managed disk when the VM gets deleted i.e whether the managed disk is deleted or detached.
// Supported values:
// Delete If this value is used, the managed disk is deleted when VM gets deleted.
// Detach If this value is used, the managed disk is retained after VM gets deleted.
// Minimum api-version:
// 2021-03-01
// +kubebuilder:validation:Enum={"Delete","Detach"}
type DeleteOption string

const (
	DeleteOption_Delete = DeleteOption("Delete")
	DeleteOption_Detach = DeleteOption("Detach")
)

// Mapping from string to DeleteOption
var deleteOption_Values = map[string]DeleteOption{
	"delete": DeleteOption_Delete,
	"detach": DeleteOption_Detach,
}

// Specifies the behavior of the managed disk when the VM gets deleted i.e whether the managed disk is deleted or detached.
// Supported values:
// Delete If this value is used, the managed disk is deleted when VM gets deleted.
// Detach If this value is used, the managed disk is retained after VM gets deleted.
// Minimum api-version:
// 2021-03-01
type DeleteOption_STATUS string

const (
	DeleteOption_STATUS_Delete = DeleteOption_STATUS("Delete")
	DeleteOption_STATUS_Detach = DeleteOption_STATUS("Detach")
)

// Mapping from string to DeleteOption_STATUS
var deleteOption_STATUS_Values = map[string]DeleteOption_STATUS{
	"delete": DeleteOption_STATUS_Delete,
	"detach": DeleteOption_STATUS_Detach,
}

// Specifies the detach behavior to be used while detaching a disk or which is already in the process of detachment from
// the virtual machine. Supported values: ForceDetach.
// detachOption: ForceDetach is applicable only for
// managed data disks. If a previous detachment attempt of the data disk did not complete due to an unexpected failure from
// the virtual machine and the disk is still not released then use force-detach as a last resort option to detach the disk
// forcibly from the VM. All writes might not have been flushed when using this detach behavior.
// This feature is
// still in preview mode and is not supported for VirtualMachineScaleSet. To force-detach a data disk update toBeDetached
// to 'true' along with setting detachOption: 'ForceDetach'.
// +kubebuilder:validation:Enum={"ForceDetach"}
type DetachOption string

const DetachOption_ForceDetach = DetachOption("ForceDetach")

// Mapping from string to DetachOption
var detachOption_Values = map[string]DetachOption{
	"forcedetach": DetachOption_ForceDetach,
}

// Specifies the detach behavior to be used while detaching a disk or which is already in the process of detachment from
// the virtual machine. Supported values: ForceDetach.
// detachOption: ForceDetach is applicable only for
// managed data disks. If a previous detachment attempt of the data disk did not complete due to an unexpected failure from
// the virtual machine and the disk is still not released then use force-detach as a last resort option to detach the disk
// forcibly from the VM. All writes might not have been flushed when using this detach behavior.
// This feature is
// still in preview mode and is not supported for VirtualMachineScaleSet. To force-detach a data disk update toBeDetached
// to 'true' along with setting detachOption: 'ForceDetach'.
type DetachOption_STATUS string

const DetachOption_STATUS_ForceDetach = DetachOption_STATUS("ForceDetach")

// Mapping from string to DetachOption_STATUS
var detachOption_STATUS_Values = map[string]DetachOption_STATUS{
	"forcedetach": DetachOption_STATUS_ForceDetach,
}

// Describes the parameters of ephemeral disk settings that can be specified for operating system disk.
// NOTE: The
// ephemeral disk settings can only be specified for managed disk.
type DiffDiskSettings struct {
	// Option: Specifies the ephemeral disk settings for operating system disk.
	Option *DiffDiskOption `json:"option,omitempty"`

	// Placement: Specifies the ephemeral disk placement for operating system disk.
	// Possible values are:
	// CacheDisk
	// ResourceDisk
	// Default: CacheDisk if one is configured for the VM size otherwise ResourceDisk is used.
	// Refer to VM size documentation for Windows VM at https://docs.microsoft.com/azure/virtual-machines/windows/sizes and
	// Linux VM at https://docs.microsoft.com/azure/virtual-machines/linux/sizes to check which VM sizes exposes a cache disk.
	Placement *DiffDiskPlacement `json:"placement,omitempty"`
}

var _ genruntime.ARMTransformer = &DiffDiskSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *DiffDiskSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.DiffDiskSettings{}

	// Set property "Option":
	if settings.Option != nil {
		var temp string
		temp = string(*settings.Option)
		option := arm.DiffDiskOption(temp)
		result.Option = &option
	}

	// Set property "Placement":
	if settings.Placement != nil {
		var temp string
		temp = string(*settings.Placement)
		placement := arm.DiffDiskPlacement(temp)
		result.Placement = &placement
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *DiffDiskSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DiffDiskSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *DiffDiskSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DiffDiskSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DiffDiskSettings, got %T", armInput)
	}

	// Set property "Option":
	if typedInput.Option != nil {
		var temp string
		temp = string(*typedInput.Option)
		option := DiffDiskOption(temp)
		settings.Option = &option
	}

	// Set property "Placement":
	if typedInput.Placement != nil {
		var temp string
		temp = string(*typedInput.Placement)
		placement := DiffDiskPlacement(temp)
		settings.Placement = &placement
	}

	// No error
	return nil
}

// AssignProperties_From_DiffDiskSettings populates our DiffDiskSettings from the provided source DiffDiskSettings
func (settings *DiffDiskSettings) AssignProperties_From_DiffDiskSettings(source *storage.DiffDiskSettings) error {

	// Option
	if source.Option != nil {
		option := *source.Option
		optionTemp := genruntime.ToEnum(option, diffDiskOption_Values)
		settings.Option = &optionTemp
	} else {
		settings.Option = nil
	}

	// Placement
	if source.Placement != nil {
		placement := *source.Placement
		placementTemp := genruntime.ToEnum(placement, diffDiskPlacement_Values)
		settings.Placement = &placementTemp
	} else {
		settings.Placement = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DiffDiskSettings populates the provided destination DiffDiskSettings from our DiffDiskSettings
func (settings *DiffDiskSettings) AssignProperties_To_DiffDiskSettings(destination *storage.DiffDiskSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Option
	if settings.Option != nil {
		option := string(*settings.Option)
		destination.Option = &option
	} else {
		destination.Option = nil
	}

	// Placement
	if settings.Placement != nil {
		placement := string(*settings.Placement)
		destination.Placement = &placement
	} else {
		destination.Placement = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DiffDiskSettings_STATUS populates our DiffDiskSettings from the provided source DiffDiskSettings_STATUS
func (settings *DiffDiskSettings) Initialize_From_DiffDiskSettings_STATUS(source *DiffDiskSettings_STATUS) error {

	// Option
	if source.Option != nil {
		option := genruntime.ToEnum(string(*source.Option), diffDiskOption_Values)
		settings.Option = &option
	} else {
		settings.Option = nil
	}

	// Placement
	if source.Placement != nil {
		placement := genruntime.ToEnum(string(*source.Placement), diffDiskPlacement_Values)
		settings.Placement = &placement
	} else {
		settings.Placement = nil
	}

	// No error
	return nil
}

// Describes the parameters of ephemeral disk settings that can be specified for operating system disk.
// NOTE: The
// ephemeral disk settings can only be specified for managed disk.
type DiffDiskSettings_STATUS struct {
	// Option: Specifies the ephemeral disk settings for operating system disk.
	Option *DiffDiskOption_STATUS `json:"option,omitempty"`

	// Placement: Specifies the ephemeral disk placement for operating system disk.
	// Possible values are:
	// CacheDisk
	// ResourceDisk
	// Default: CacheDisk if one is configured for the VM size otherwise ResourceDisk is used.
	// Refer to VM size documentation for Windows VM at https://docs.microsoft.com/azure/virtual-machines/windows/sizes and
	// Linux VM at https://docs.microsoft.com/azure/virtual-machines/linux/sizes to check which VM sizes exposes a cache disk.
	Placement *DiffDiskPlacement_STATUS `json:"placement,omitempty"`
}

var _ genruntime.FromARMConverter = &DiffDiskSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *DiffDiskSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DiffDiskSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *DiffDiskSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DiffDiskSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DiffDiskSettings_STATUS, got %T", armInput)
	}

	// Set property "Option":
	if typedInput.Option != nil {
		var temp string
		temp = string(*typedInput.Option)
		option := DiffDiskOption_STATUS(temp)
		settings.Option = &option
	}

	// Set property "Placement":
	if typedInput.Placement != nil {
		var temp string
		temp = string(*typedInput.Placement)
		placement := DiffDiskPlacement_STATUS(temp)
		settings.Placement = &placement
	}

	// No error
	return nil
}

// AssignProperties_From_DiffDiskSettings_STATUS populates our DiffDiskSettings_STATUS from the provided source DiffDiskSettings_STATUS
func (settings *DiffDiskSettings_STATUS) AssignProperties_From_DiffDiskSettings_STATUS(source *storage.DiffDiskSettings_STATUS) error {

	// Option
	if source.Option != nil {
		option := *source.Option
		optionTemp := genruntime.ToEnum(option, diffDiskOption_STATUS_Values)
		settings.Option = &optionTemp
	} else {
		settings.Option = nil
	}

	// Placement
	if source.Placement != nil {
		placement := *source.Placement
		placementTemp := genruntime.ToEnum(placement, diffDiskPlacement_STATUS_Values)
		settings.Placement = &placementTemp
	} else {
		settings.Placement = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DiffDiskSettings_STATUS populates the provided destination DiffDiskSettings_STATUS from our DiffDiskSettings_STATUS
func (settings *DiffDiskSettings_STATUS) AssignProperties_To_DiffDiskSettings_STATUS(destination *storage.DiffDiskSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Option
	if settings.Option != nil {
		option := string(*settings.Option)
		destination.Option = &option
	} else {
		destination.Option = nil
	}

	// Placement
	if settings.Placement != nil {
		placement := string(*settings.Placement)
		destination.Placement = &placement
	} else {
		destination.Placement = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes a Encryption Settings for a Disk
type DiskEncryptionSettings struct {
	// DiskEncryptionKey: Specifies the location of the disk encryption key, which is a Key Vault Secret.
	DiskEncryptionKey *KeyVaultSecretReference `json:"diskEncryptionKey,omitempty"`

	// Enabled: Specifies whether disk encryption should be enabled on the virtual machine.
	Enabled *bool `json:"enabled,omitempty"`

	// KeyEncryptionKey: Specifies the location of the key encryption key in Key Vault.
	KeyEncryptionKey *KeyVaultKeyReference `json:"keyEncryptionKey,omitempty"`
}

var _ genruntime.ARMTransformer = &DiskEncryptionSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *DiskEncryptionSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.DiskEncryptionSettings{}

	// Set property "DiskEncryptionKey":
	if settings.DiskEncryptionKey != nil {
		diskEncryptionKey_ARM, err := (*settings.DiskEncryptionKey).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		diskEncryptionKey := *diskEncryptionKey_ARM.(*arm.KeyVaultSecretReference)
		result.DiskEncryptionKey = &diskEncryptionKey
	}

	// Set property "Enabled":
	if settings.Enabled != nil {
		enabled := *settings.Enabled
		result.Enabled = &enabled
	}

	// Set property "KeyEncryptionKey":
	if settings.KeyEncryptionKey != nil {
		keyEncryptionKey_ARM, err := (*settings.KeyEncryptionKey).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		keyEncryptionKey := *keyEncryptionKey_ARM.(*arm.KeyVaultKeyReference)
		result.KeyEncryptionKey = &keyEncryptionKey
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *DiskEncryptionSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DiskEncryptionSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *DiskEncryptionSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DiskEncryptionSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DiskEncryptionSettings, got %T", armInput)
	}

	// Set property "DiskEncryptionKey":
	if typedInput.DiskEncryptionKey != nil {
		var diskEncryptionKey1 KeyVaultSecretReference
		err := diskEncryptionKey1.PopulateFromARM(owner, *typedInput.DiskEncryptionKey)
		if err != nil {
			return err
		}
		diskEncryptionKey := diskEncryptionKey1
		settings.DiskEncryptionKey = &diskEncryptionKey
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		settings.Enabled = &enabled
	}

	// Set property "KeyEncryptionKey":
	if typedInput.KeyEncryptionKey != nil {
		var keyEncryptionKey1 KeyVaultKeyReference
		err := keyEncryptionKey1.PopulateFromARM(owner, *typedInput.KeyEncryptionKey)
		if err != nil {
			return err
		}
		keyEncryptionKey := keyEncryptionKey1
		settings.KeyEncryptionKey = &keyEncryptionKey
	}

	// No error
	return nil
}

// AssignProperties_From_DiskEncryptionSettings populates our DiskEncryptionSettings from the provided source DiskEncryptionSettings
func (settings *DiskEncryptionSettings) AssignProperties_From_DiskEncryptionSettings(source *storage.DiskEncryptionSettings) error {

	// DiskEncryptionKey
	if source.DiskEncryptionKey != nil {
		var diskEncryptionKey KeyVaultSecretReference
		err := diskEncryptionKey.AssignProperties_From_KeyVaultSecretReference(source.DiskEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_KeyVaultSecretReference() to populate field DiskEncryptionKey")
		}
		settings.DiskEncryptionKey = &diskEncryptionKey
	} else {
		settings.DiskEncryptionKey = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		settings.Enabled = &enabled
	} else {
		settings.Enabled = nil
	}

	// KeyEncryptionKey
	if source.KeyEncryptionKey != nil {
		var keyEncryptionKey KeyVaultKeyReference
		err := keyEncryptionKey.AssignProperties_From_KeyVaultKeyReference(source.KeyEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_KeyVaultKeyReference() to populate field KeyEncryptionKey")
		}
		settings.KeyEncryptionKey = &keyEncryptionKey
	} else {
		settings.KeyEncryptionKey = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DiskEncryptionSettings populates the provided destination DiskEncryptionSettings from our DiskEncryptionSettings
func (settings *DiskEncryptionSettings) AssignProperties_To_DiskEncryptionSettings(destination *storage.DiskEncryptionSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DiskEncryptionKey
	if settings.DiskEncryptionKey != nil {
		var diskEncryptionKey storage.KeyVaultSecretReference
		err := settings.DiskEncryptionKey.AssignProperties_To_KeyVaultSecretReference(&diskEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_KeyVaultSecretReference() to populate field DiskEncryptionKey")
		}
		destination.DiskEncryptionKey = &diskEncryptionKey
	} else {
		destination.DiskEncryptionKey = nil
	}

	// Enabled
	if settings.Enabled != nil {
		enabled := *settings.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// KeyEncryptionKey
	if settings.KeyEncryptionKey != nil {
		var keyEncryptionKey storage.KeyVaultKeyReference
		err := settings.KeyEncryptionKey.AssignProperties_To_KeyVaultKeyReference(&keyEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_KeyVaultKeyReference() to populate field KeyEncryptionKey")
		}
		destination.KeyEncryptionKey = &keyEncryptionKey
	} else {
		destination.KeyEncryptionKey = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DiskEncryptionSettings_STATUS populates our DiskEncryptionSettings from the provided source DiskEncryptionSettings_STATUS
func (settings *DiskEncryptionSettings) Initialize_From_DiskEncryptionSettings_STATUS(source *DiskEncryptionSettings_STATUS) error {

	// DiskEncryptionKey
	if source.DiskEncryptionKey != nil {
		var diskEncryptionKey KeyVaultSecretReference
		err := diskEncryptionKey.Initialize_From_KeyVaultSecretReference_STATUS(source.DiskEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_KeyVaultSecretReference_STATUS() to populate field DiskEncryptionKey")
		}
		settings.DiskEncryptionKey = &diskEncryptionKey
	} else {
		settings.DiskEncryptionKey = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		settings.Enabled = &enabled
	} else {
		settings.Enabled = nil
	}

	// KeyEncryptionKey
	if source.KeyEncryptionKey != nil {
		var keyEncryptionKey KeyVaultKeyReference
		err := keyEncryptionKey.Initialize_From_KeyVaultKeyReference_STATUS(source.KeyEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_KeyVaultKeyReference_STATUS() to populate field KeyEncryptionKey")
		}
		settings.KeyEncryptionKey = &keyEncryptionKey
	} else {
		settings.KeyEncryptionKey = nil
	}

	// No error
	return nil
}

// Describes a Encryption Settings for a Disk
type DiskEncryptionSettings_STATUS struct {
	// DiskEncryptionKey: Specifies the location of the disk encryption key, which is a Key Vault Secret.
	DiskEncryptionKey *KeyVaultSecretReference_STATUS `json:"diskEncryptionKey,omitempty"`

	// Enabled: Specifies whether disk encryption should be enabled on the virtual machine.
	Enabled *bool `json:"enabled,omitempty"`

	// KeyEncryptionKey: Specifies the location of the key encryption key in Key Vault.
	KeyEncryptionKey *KeyVaultKeyReference_STATUS `json:"keyEncryptionKey,omitempty"`
}

var _ genruntime.FromARMConverter = &DiskEncryptionSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *DiskEncryptionSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DiskEncryptionSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *DiskEncryptionSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DiskEncryptionSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DiskEncryptionSettings_STATUS, got %T", armInput)
	}

	// Set property "DiskEncryptionKey":
	if typedInput.DiskEncryptionKey != nil {
		var diskEncryptionKey1 KeyVaultSecretReference_STATUS
		err := diskEncryptionKey1.PopulateFromARM(owner, *typedInput.DiskEncryptionKey)
		if err != nil {
			return err
		}
		diskEncryptionKey := diskEncryptionKey1
		settings.DiskEncryptionKey = &diskEncryptionKey
	}

	// Set property "Enabled":
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		settings.Enabled = &enabled
	}

	// Set property "KeyEncryptionKey":
	if typedInput.KeyEncryptionKey != nil {
		var keyEncryptionKey1 KeyVaultKeyReference_STATUS
		err := keyEncryptionKey1.PopulateFromARM(owner, *typedInput.KeyEncryptionKey)
		if err != nil {
			return err
		}
		keyEncryptionKey := keyEncryptionKey1
		settings.KeyEncryptionKey = &keyEncryptionKey
	}

	// No error
	return nil
}

// AssignProperties_From_DiskEncryptionSettings_STATUS populates our DiskEncryptionSettings_STATUS from the provided source DiskEncryptionSettings_STATUS
func (settings *DiskEncryptionSettings_STATUS) AssignProperties_From_DiskEncryptionSettings_STATUS(source *storage.DiskEncryptionSettings_STATUS) error {

	// DiskEncryptionKey
	if source.DiskEncryptionKey != nil {
		var diskEncryptionKey KeyVaultSecretReference_STATUS
		err := diskEncryptionKey.AssignProperties_From_KeyVaultSecretReference_STATUS(source.DiskEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_KeyVaultSecretReference_STATUS() to populate field DiskEncryptionKey")
		}
		settings.DiskEncryptionKey = &diskEncryptionKey
	} else {
		settings.DiskEncryptionKey = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		settings.Enabled = &enabled
	} else {
		settings.Enabled = nil
	}

	// KeyEncryptionKey
	if source.KeyEncryptionKey != nil {
		var keyEncryptionKey KeyVaultKeyReference_STATUS
		err := keyEncryptionKey.AssignProperties_From_KeyVaultKeyReference_STATUS(source.KeyEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_KeyVaultKeyReference_STATUS() to populate field KeyEncryptionKey")
		}
		settings.KeyEncryptionKey = &keyEncryptionKey
	} else {
		settings.KeyEncryptionKey = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DiskEncryptionSettings_STATUS populates the provided destination DiskEncryptionSettings_STATUS from our DiskEncryptionSettings_STATUS
func (settings *DiskEncryptionSettings_STATUS) AssignProperties_To_DiskEncryptionSettings_STATUS(destination *storage.DiskEncryptionSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DiskEncryptionKey
	if settings.DiskEncryptionKey != nil {
		var diskEncryptionKey storage.KeyVaultSecretReference_STATUS
		err := settings.DiskEncryptionKey.AssignProperties_To_KeyVaultSecretReference_STATUS(&diskEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_KeyVaultSecretReference_STATUS() to populate field DiskEncryptionKey")
		}
		destination.DiskEncryptionKey = &diskEncryptionKey
	} else {
		destination.DiskEncryptionKey = nil
	}

	// Enabled
	if settings.Enabled != nil {
		enabled := *settings.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// KeyEncryptionKey
	if settings.KeyEncryptionKey != nil {
		var keyEncryptionKey storage.KeyVaultKeyReference_STATUS
		err := settings.KeyEncryptionKey.AssignProperties_To_KeyVaultKeyReference_STATUS(&keyEncryptionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_KeyVaultKeyReference_STATUS() to populate field KeyEncryptionKey")
		}
		destination.KeyEncryptionKey = &keyEncryptionKey
	} else {
		destination.KeyEncryptionKey = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type InstanceViewStatus_Level_STATUS string

const (
	InstanceViewStatus_Level_STATUS_Error   = InstanceViewStatus_Level_STATUS("Error")
	InstanceViewStatus_Level_STATUS_Info    = InstanceViewStatus_Level_STATUS("Info")
	InstanceViewStatus_Level_STATUS_Warning = InstanceViewStatus_Level_STATUS("Warning")
)

// Mapping from string to InstanceViewStatus_Level_STATUS
var instanceViewStatus_Level_STATUS_Values = map[string]InstanceViewStatus_Level_STATUS{
	"error":   InstanceViewStatus_Level_STATUS_Error,
	"info":    InstanceViewStatus_Level_STATUS_Info,
	"warning": InstanceViewStatus_Level_STATUS_Warning,
}

// Describes the properties of the last installed patch summary.
type LastPatchInstallationSummary_STATUS struct {
	// Error: The errors that were encountered during execution of the operation. The details array contains the list of them.
	Error *ApiError_STATUS `json:"error,omitempty"`

	// ExcludedPatchCount: The number of all available patches but excluded explicitly by a customer-specified exclusion list
	// match.
	ExcludedPatchCount *int `json:"excludedPatchCount,omitempty"`

	// FailedPatchCount: The count of patches that failed installation.
	FailedPatchCount *int `json:"failedPatchCount,omitempty"`

	// InstallationActivityId: The activity ID of the operation that produced this result. It is used to correlate across CRP
	// and extension logs.
	InstallationActivityId *string `json:"installationActivityId,omitempty"`

	// InstalledPatchCount: The count of patches that successfully installed.
	InstalledPatchCount *int `json:"installedPatchCount,omitempty"`

	// LastModifiedTime: The UTC timestamp when the operation began.
	LastModifiedTime *string `json:"lastModifiedTime,omitempty"`

	// MaintenanceWindowExceeded: Describes whether the operation ran out of time before it completed all its intended actions
	MaintenanceWindowExceeded *bool `json:"maintenanceWindowExceeded,omitempty"`

	// NotSelectedPatchCount: The number of all available patches but not going to be installed because it didn't match a
	// classification or inclusion list entry.
	NotSelectedPatchCount *int `json:"notSelectedPatchCount,omitempty"`

	// PendingPatchCount: The number of all available patches expected to be installed over the course of the patch
	// installation operation.
	PendingPatchCount *int `json:"pendingPatchCount,omitempty"`

	// StartTime: The UTC timestamp when the operation began.
	StartTime *string `json:"startTime,omitempty"`

	// Status: The overall success or failure status of the operation. It remains "InProgress" until the operation completes.
	// At that point it will become "Unknown", "Failed", "Succeeded", or "CompletedWithWarnings."
	Status *LastPatchInstallationSummary_Status_STATUS `json:"status,omitempty"`
}

var _ genruntime.FromARMConverter = &LastPatchInstallationSummary_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (summary *LastPatchInstallationSummary_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.LastPatchInstallationSummary_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (summary *LastPatchInstallationSummary_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.LastPatchInstallationSummary_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.LastPatchInstallationSummary_STATUS, got %T", armInput)
	}

	// Set property "Error":
	if typedInput.Error != nil {
		var error1 ApiError_STATUS
		err := error1.PopulateFromARM(owner, *typedInput.Error)
		if err != nil {
			return err
		}
		error := error1
		summary.Error = &error
	}

	// Set property "ExcludedPatchCount":
	if typedInput.ExcludedPatchCount != nil {
		excludedPatchCount := *typedInput.ExcludedPatchCount
		summary.ExcludedPatchCount = &excludedPatchCount
	}

	// Set property "FailedPatchCount":
	if typedInput.FailedPatchCount != nil {
		failedPatchCount := *typedInput.FailedPatchCount
		summary.FailedPatchCount = &failedPatchCount
	}

	// Set property "InstallationActivityId":
	if typedInput.InstallationActivityId != nil {
		installationActivityId := *typedInput.InstallationActivityId
		summary.InstallationActivityId = &installationActivityId
	}

	// Set property "InstalledPatchCount":
	if typedInput.InstalledPatchCount != nil {
		installedPatchCount := *typedInput.InstalledPatchCount
		summary.InstalledPatchCount = &installedPatchCount
	}

	// Set property "LastModifiedTime":
	if typedInput.LastModifiedTime != nil {
		lastModifiedTime := *typedInput.LastModifiedTime
		summary.LastModifiedTime = &lastModifiedTime
	}

	// Set property "MaintenanceWindowExceeded":
	if typedInput.MaintenanceWindowExceeded != nil {
		maintenanceWindowExceeded := *typedInput.MaintenanceWindowExceeded
		summary.MaintenanceWindowExceeded = &maintenanceWindowExceeded
	}

	// Set property "NotSelectedPatchCount":
	if typedInput.NotSelectedPatchCount != nil {
		notSelectedPatchCount := *typedInput.NotSelectedPatchCount
		summary.NotSelectedPatchCount = &notSelectedPatchCount
	}

	// Set property "PendingPatchCount":
	if typedInput.PendingPatchCount != nil {
		pendingPatchCount := *typedInput.PendingPatchCount
		summary.PendingPatchCount = &pendingPatchCount
	}

	// Set property "StartTime":
	if typedInput.StartTime != nil {
		startTime := *typedInput.StartTime
		summary.StartTime = &startTime
	}

	// Set property "Status":
	if typedInput.Status != nil {
		var temp string
		temp = string(*typedInput.Status)
		status := LastPatchInstallationSummary_Status_STATUS(temp)
		summary.Status = &status
	}

	// No error
	return nil
}

// AssignProperties_From_LastPatchInstallationSummary_STATUS populates our LastPatchInstallationSummary_STATUS from the provided source LastPatchInstallationSummary_STATUS
func (summary *LastPatchInstallationSummary_STATUS) AssignProperties_From_LastPatchInstallationSummary_STATUS(source *storage.LastPatchInstallationSummary_STATUS) error {

	// Error
	if source.Error != nil {
		var error ApiError_STATUS
		err := error.AssignProperties_From_ApiError_STATUS(source.Error)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApiError_STATUS() to populate field Error")
		}
		summary.Error = &error
	} else {
		summary.Error = nil
	}

	// ExcludedPatchCount
	summary.ExcludedPatchCount = genruntime.ClonePointerToInt(source.ExcludedPatchCount)

	// FailedPatchCount
	summary.FailedPatchCount = genruntime.ClonePointerToInt(source.FailedPatchCount)

	// InstallationActivityId
	summary.InstallationActivityId = genruntime.ClonePointerToString(source.InstallationActivityId)

	// InstalledPatchCount
	summary.InstalledPatchCount = genruntime.ClonePointerToInt(source.InstalledPatchCount)

	// LastModifiedTime
	summary.LastModifiedTime = genruntime.ClonePointerToString(source.LastModifiedTime)

	// MaintenanceWindowExceeded
	if source.MaintenanceWindowExceeded != nil {
		maintenanceWindowExceeded := *source.MaintenanceWindowExceeded
		summary.MaintenanceWindowExceeded = &maintenanceWindowExceeded
	} else {
		summary.MaintenanceWindowExceeded = nil
	}

	// NotSelectedPatchCount
	summary.NotSelectedPatchCount = genruntime.ClonePointerToInt(source.NotSelectedPatchCount)

	// PendingPatchCount
	summary.PendingPatchCount = genruntime.ClonePointerToInt(source.PendingPatchCount)

	// StartTime
	summary.StartTime = genruntime.ClonePointerToString(source.StartTime)

	// Status
	if source.Status != nil {
		status := *source.Status
		statusTemp := genruntime.ToEnum(status, lastPatchInstallationSummary_Status_STATUS_Values)
		summary.Status = &statusTemp
	} else {
		summary.Status = nil
	}

	// No error
	return nil
}

// AssignProperties_To_LastPatchInstallationSummary_STATUS populates the provided destination LastPatchInstallationSummary_STATUS from our LastPatchInstallationSummary_STATUS
func (summary *LastPatchInstallationSummary_STATUS) AssignProperties_To_LastPatchInstallationSummary_STATUS(destination *storage.LastPatchInstallationSummary_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Error
	if summary.Error != nil {
		var error storage.ApiError_STATUS
		err := summary.Error.AssignProperties_To_ApiError_STATUS(&error)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApiError_STATUS() to populate field Error")
		}
		destination.Error = &error
	} else {
		destination.Error = nil
	}

	// ExcludedPatchCount
	destination.ExcludedPatchCount = genruntime.ClonePointerToInt(summary.ExcludedPatchCount)

	// FailedPatchCount
	destination.FailedPatchCount = genruntime.ClonePointerToInt(summary.FailedPatchCount)

	// InstallationActivityId
	destination.InstallationActivityId = genruntime.ClonePointerToString(summary.InstallationActivityId)

	// InstalledPatchCount
	destination.InstalledPatchCount = genruntime.ClonePointerToInt(summary.InstalledPatchCount)

	// LastModifiedTime
	destination.LastModifiedTime = genruntime.ClonePointerToString(summary.LastModifiedTime)

	// MaintenanceWindowExceeded
	if summary.MaintenanceWindowExceeded != nil {
		maintenanceWindowExceeded := *summary.MaintenanceWindowExceeded
		destination.MaintenanceWindowExceeded = &maintenanceWindowExceeded
	} else {
		destination.MaintenanceWindowExceeded = nil
	}

	// NotSelectedPatchCount
	destination.NotSelectedPatchCount = genruntime.ClonePointerToInt(summary.NotSelectedPatchCount)

	// PendingPatchCount
	destination.PendingPatchCount = genruntime.ClonePointerToInt(summary.PendingPatchCount)

	// StartTime
	destination.StartTime = genruntime.ClonePointerToString(summary.StartTime)

	// Status
	if summary.Status != nil {
		status := string(*summary.Status)
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Specifies settings related to VM Guest Patching on Linux.
type LinuxPatchSettings struct {
	// AssessmentMode: Specifies the mode of VM Guest Patch Assessment for the IaaS virtual machine.
	// Possible values are:
	// ImageDefault - You control the timing of patch assessments on a virtual machine.
	// AutomaticByPlatform - The platform will trigger periodic patch assessments. The property provisionVMAgent must be true.
	AssessmentMode *LinuxPatchSettings_AssessmentMode `json:"assessmentMode,omitempty"`

	// AutomaticByPlatformSettings: Specifies additional settings for patch mode AutomaticByPlatform in VM Guest Patching on
	// Linux.
	AutomaticByPlatformSettings *LinuxVMGuestPatchAutomaticByPlatformSettings `json:"automaticByPlatformSettings,omitempty"`

	// PatchMode: Specifies the mode of VM Guest Patching to IaaS virtual machine or virtual machines associated to virtual
	// machine scale set with OrchestrationMode as Flexible.
	// Possible values are:
	// ImageDefault - The virtual machine's default patching configuration is used.
	// AutomaticByPlatform - The virtual machine will be automatically updated by the platform. The property provisionVMAgent
	// must be true
	PatchMode *LinuxPatchSettings_PatchMode `json:"patchMode,omitempty"`
}

var _ genruntime.ARMTransformer = &LinuxPatchSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *LinuxPatchSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.LinuxPatchSettings{}

	// Set property "AssessmentMode":
	if settings.AssessmentMode != nil {
		var temp string
		temp = string(*settings.AssessmentMode)
		assessmentMode := arm.LinuxPatchSettings_AssessmentMode(temp)
		result.AssessmentMode = &assessmentMode
	}

	// Set property "AutomaticByPlatformSettings":
	if settings.AutomaticByPlatformSettings != nil {
		automaticByPlatformSettings_ARM, err := (*settings.AutomaticByPlatformSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		automaticByPlatformSettings := *automaticByPlatformSettings_ARM.(*arm.LinuxVMGuestPatchAutomaticByPlatformSettings)
		result.AutomaticByPlatformSettings = &automaticByPlatformSettings
	}

	// Set property "PatchMode":
	if settings.PatchMode != nil {
		var temp string
		temp = string(*settings.PatchMode)
		patchMode := arm.LinuxPatchSettings_PatchMode(temp)
		result.PatchMode = &patchMode
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *LinuxPatchSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.LinuxPatchSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *LinuxPatchSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.LinuxPatchSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.LinuxPatchSettings, got %T", armInput)
	}

	// Set property "AssessmentMode":
	if typedInput.AssessmentMode != nil {
		var temp string
		temp = string(*typedInput.AssessmentMode)
		assessmentMode := LinuxPatchSettings_AssessmentMode(temp)
		settings.AssessmentMode = &assessmentMode
	}

	// Set property "AutomaticByPlatformSettings":
	if typedInput.AutomaticByPlatformSettings != nil {
		var automaticByPlatformSettings1 LinuxVMGuestPatchAutomaticByPlatformSettings
		err := automaticByPlatformSettings1.PopulateFromARM(owner, *typedInput.AutomaticByPlatformSettings)
		if err != nil {
			return err
		}
		automaticByPlatformSettings := automaticByPlatformSettings1
		settings.AutomaticByPlatformSettings = &automaticByPlatformSettings
	}

	// Set property "PatchMode":
	if typedInput.PatchMode != nil {
		var temp string
		temp = string(*typedInput.PatchMode)
		patchMode := LinuxPatchSettings_PatchMode(temp)
		settings.PatchMode = &patchMode
	}

	// No error
	return nil
}

// AssignProperties_From_LinuxPatchSettings populates our LinuxPatchSettings from the provided source LinuxPatchSettings
func (settings *LinuxPatchSettings) AssignProperties_From_LinuxPatchSettings(source *storage.LinuxPatchSettings) error {

	// AssessmentMode
	if source.AssessmentMode != nil {
		assessmentMode := *source.AssessmentMode
		assessmentModeTemp := genruntime.ToEnum(assessmentMode, linuxPatchSettings_AssessmentMode_Values)
		settings.AssessmentMode = &assessmentModeTemp
	} else {
		settings.AssessmentMode = nil
	}

	// AutomaticByPlatformSettings
	if source.AutomaticByPlatformSettings != nil {
		var automaticByPlatformSetting LinuxVMGuestPatchAutomaticByPlatformSettings
		err := automaticByPlatformSetting.AssignProperties_From_LinuxVMGuestPatchAutomaticByPlatformSettings(source.AutomaticByPlatformSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_LinuxVMGuestPatchAutomaticByPlatformSettings() to populate field AutomaticByPlatformSettings")
		}
		settings.AutomaticByPlatformSettings = &automaticByPlatformSetting
	} else {
		settings.AutomaticByPlatformSettings = nil
	}

	// PatchMode
	if source.PatchMode != nil {
		patchMode := *source.PatchMode
		patchModeTemp := genruntime.ToEnum(patchMode, linuxPatchSettings_PatchMode_Values)
		settings.PatchMode = &patchModeTemp
	} else {
		settings.PatchMode = nil
	}

	// No error
	return nil
}

// AssignProperties_To_LinuxPatchSettings populates the provided destination LinuxPatchSettings from our LinuxPatchSettings
func (settings *LinuxPatchSettings) AssignProperties_To_LinuxPatchSettings(destination *storage.LinuxPatchSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AssessmentMode
	if settings.AssessmentMode != nil {
		assessmentMode := string(*settings.AssessmentMode)
		destination.AssessmentMode = &assessmentMode
	} else {
		destination.AssessmentMode = nil
	}

	// AutomaticByPlatformSettings
	if settings.AutomaticByPlatformSettings != nil {
		var automaticByPlatformSetting storage.LinuxVMGuestPatchAutomaticByPlatformSettings
		err := settings.AutomaticByPlatformSettings.AssignProperties_To_LinuxVMGuestPatchAutomaticByPlatformSettings(&automaticByPlatformSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_LinuxVMGuestPatchAutomaticByPlatformSettings() to populate field AutomaticByPlatformSettings")
		}
		destination.AutomaticByPlatformSettings = &automaticByPlatformSetting
	} else {
		destination.AutomaticByPlatformSettings = nil
	}

	// PatchMode
	if settings.PatchMode != nil {
		patchMode := string(*settings.PatchMode)
		destination.PatchMode = &patchMode
	} else {
		destination.PatchMode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_LinuxPatchSettings_STATUS populates our LinuxPatchSettings from the provided source LinuxPatchSettings_STATUS
func (settings *LinuxPatchSettings) Initialize_From_LinuxPatchSettings_STATUS(source *LinuxPatchSettings_STATUS) error {

	// AssessmentMode
	if source.AssessmentMode != nil {
		assessmentMode := genruntime.ToEnum(string(*source.AssessmentMode), linuxPatchSettings_AssessmentMode_Values)
		settings.AssessmentMode = &assessmentMode
	} else {
		settings.AssessmentMode = nil
	}

	// AutomaticByPlatformSettings
	if source.AutomaticByPlatformSettings != nil {
		var automaticByPlatformSetting LinuxVMGuestPatchAutomaticByPlatformSettings
		err := automaticByPlatformSetting.Initialize_From_LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS(source.AutomaticByPlatformSettings)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS() to populate field AutomaticByPlatformSettings")
		}
		settings.AutomaticByPlatformSettings = &automaticByPlatformSetting
	} else {
		settings.AutomaticByPlatformSettings = nil
	}

	// PatchMode
	if source.PatchMode != nil {
		patchMode := genruntime.ToEnum(string(*source.PatchMode), linuxPatchSettings_PatchMode_Values)
		settings.PatchMode = &patchMode
	} else {
		settings.PatchMode = nil
	}

	// No error
	return nil
}

// Specifies settings related to VM Guest Patching on Linux.
type LinuxPatchSettings_STATUS struct {
	// AssessmentMode: Specifies the mode of VM Guest Patch Assessment for the IaaS virtual machine.
	// Possible values are:
	// ImageDefault - You control the timing of patch assessments on a virtual machine.
	// AutomaticByPlatform - The platform will trigger periodic patch assessments. The property provisionVMAgent must be true.
	AssessmentMode *LinuxPatchSettings_AssessmentMode_STATUS `json:"assessmentMode,omitempty"`

	// AutomaticByPlatformSettings: Specifies additional settings for patch mode AutomaticByPlatform in VM Guest Patching on
	// Linux.
	AutomaticByPlatformSettings *LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS `json:"automaticByPlatformSettings,omitempty"`

	// PatchMode: Specifies the mode of VM Guest Patching to IaaS virtual machine or virtual machines associated to virtual
	// machine scale set with OrchestrationMode as Flexible.
	// Possible values are:
	// ImageDefault - The virtual machine's default patching configuration is used.
	// AutomaticByPlatform - The virtual machine will be automatically updated by the platform. The property provisionVMAgent
	// must be true
	PatchMode *LinuxPatchSettings_PatchMode_STATUS `json:"patchMode,omitempty"`
}

var _ genruntime.FromARMConverter = &LinuxPatchSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *LinuxPatchSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.LinuxPatchSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *LinuxPatchSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.LinuxPatchSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.LinuxPatchSettings_STATUS, got %T", armInput)
	}

	// Set property "AssessmentMode":
	if typedInput.AssessmentMode != nil {
		var temp string
		temp = string(*typedInput.AssessmentMode)
		assessmentMode := LinuxPatchSettings_AssessmentMode_STATUS(temp)
		settings.AssessmentMode = &assessmentMode
	}

	// Set property "AutomaticByPlatformSettings":
	if typedInput.AutomaticByPlatformSettings != nil {
		var automaticByPlatformSettings1 LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS
		err := automaticByPlatformSettings1.PopulateFromARM(owner, *typedInput.AutomaticByPlatformSettings)
		if err != nil {
			return err
		}
		automaticByPlatformSettings := automaticByPlatformSettings1
		settings.AutomaticByPlatformSettings = &automaticByPlatformSettings
	}

	// Set property "PatchMode":
	if typedInput.PatchMode != nil {
		var temp string
		temp = string(*typedInput.PatchMode)
		patchMode := LinuxPatchSettings_PatchMode_STATUS(temp)
		settings.PatchMode = &patchMode
	}

	// No error
	return nil
}

// AssignProperties_From_LinuxPatchSettings_STATUS populates our LinuxPatchSettings_STATUS from the provided source LinuxPatchSettings_STATUS
func (settings *LinuxPatchSettings_STATUS) AssignProperties_From_LinuxPatchSettings_STATUS(source *storage.LinuxPatchSettings_STATUS) error {

	// AssessmentMode
	if source.AssessmentMode != nil {
		assessmentMode := *source.AssessmentMode
		assessmentModeTemp := genruntime.ToEnum(assessmentMode, linuxPatchSettings_AssessmentMode_STATUS_Values)
		settings.AssessmentMode = &assessmentModeTemp
	} else {
		settings.AssessmentMode = nil
	}

	// AutomaticByPlatformSettings
	if source.AutomaticByPlatformSettings != nil {
		var automaticByPlatformSetting LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS
		err := automaticByPlatformSetting.AssignProperties_From_LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS(source.AutomaticByPlatformSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS() to populate field AutomaticByPlatformSettings")
		}
		settings.AutomaticByPlatformSettings = &automaticByPlatformSetting
	} else {
		settings.AutomaticByPlatformSettings = nil
	}

	// PatchMode
	if source.PatchMode != nil {
		patchMode := *source.PatchMode
		patchModeTemp := genruntime.ToEnum(patchMode, linuxPatchSettings_PatchMode_STATUS_Values)
		settings.PatchMode = &patchModeTemp
	} else {
		settings.PatchMode = nil
	}

	// No error
	return nil
}

// AssignProperties_To_LinuxPatchSettings_STATUS populates the provided destination LinuxPatchSettings_STATUS from our LinuxPatchSettings_STATUS
func (settings *LinuxPatchSettings_STATUS) AssignProperties_To_LinuxPatchSettings_STATUS(destination *storage.LinuxPatchSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AssessmentMode
	if settings.AssessmentMode != nil {
		assessmentMode := string(*settings.AssessmentMode)
		destination.AssessmentMode = &assessmentMode
	} else {
		destination.AssessmentMode = nil
	}

	// AutomaticByPlatformSettings
	if settings.AutomaticByPlatformSettings != nil {
		var automaticByPlatformSetting storage.LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS
		err := settings.AutomaticByPlatformSettings.AssignProperties_To_LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS(&automaticByPlatformSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS() to populate field AutomaticByPlatformSettings")
		}
		destination.AutomaticByPlatformSettings = &automaticByPlatformSetting
	} else {
		destination.AutomaticByPlatformSettings = nil
	}

	// PatchMode
	if settings.PatchMode != nil {
		patchMode := string(*settings.PatchMode)
		destination.PatchMode = &patchMode
	} else {
		destination.PatchMode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type MaintenanceRedeployStatus_LastOperationResultCode_STATUS string

const (
	MaintenanceRedeployStatus_LastOperationResultCode_STATUS_MaintenanceAborted   = MaintenanceRedeployStatus_LastOperationResultCode_STATUS("MaintenanceAborted")
	MaintenanceRedeployStatus_LastOperationResultCode_STATUS_MaintenanceCompleted = MaintenanceRedeployStatus_LastOperationResultCode_STATUS("MaintenanceCompleted")
	MaintenanceRedeployStatus_LastOperationResultCode_STATUS_None                 = MaintenanceRedeployStatus_LastOperationResultCode_STATUS("None")
	MaintenanceRedeployStatus_LastOperationResultCode_STATUS_RetryLater           = MaintenanceRedeployStatus_LastOperationResultCode_STATUS("RetryLater")
)

// Mapping from string to MaintenanceRedeployStatus_LastOperationResultCode_STATUS
var maintenanceRedeployStatus_LastOperationResultCode_STATUS_Values = map[string]MaintenanceRedeployStatus_LastOperationResultCode_STATUS{
	"maintenanceaborted":   MaintenanceRedeployStatus_LastOperationResultCode_STATUS_MaintenanceAborted,
	"maintenancecompleted": MaintenanceRedeployStatus_LastOperationResultCode_STATUS_MaintenanceCompleted,
	"none":                 MaintenanceRedeployStatus_LastOperationResultCode_STATUS_None,
	"retrylater":           MaintenanceRedeployStatus_LastOperationResultCode_STATUS_RetryLater,
}

// The parameters of a managed disk.
type ManagedDiskParameters struct {
	// DiskEncryptionSet: Specifies the customer managed disk encryption set resource id for the managed disk.
	DiskEncryptionSet *SubResource `json:"diskEncryptionSet,omitempty"`

	// Reference: Resource Id
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`

	// SecurityProfile: Specifies the security profile for the managed disk.
	SecurityProfile *VMDiskSecurityProfile `json:"securityProfile,omitempty"`

	// StorageAccountType: Specifies the storage account type for the managed disk. NOTE: UltraSSD_LRS can only be used with
	// data disks, it cannot be used with OS Disk.
	StorageAccountType *StorageAccountType `json:"storageAccountType,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedDiskParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *ManagedDiskParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.ManagedDiskParameters{}

	// Set property "DiskEncryptionSet":
	if parameters.DiskEncryptionSet != nil {
		diskEncryptionSet_ARM, err := (*parameters.DiskEncryptionSet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		diskEncryptionSet := *diskEncryptionSet_ARM.(*arm.SubResource)
		result.DiskEncryptionSet = &diskEncryptionSet
	}

	// Set property "Id":
	if parameters.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*parameters.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property "SecurityProfile":
	if parameters.SecurityProfile != nil {
		securityProfile_ARM, err := (*parameters.SecurityProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		securityProfile := *securityProfile_ARM.(*arm.VMDiskSecurityProfile)
		result.SecurityProfile = &securityProfile
	}

	// Set property "StorageAccountType":
	if parameters.StorageAccountType != nil {
		var temp string
		temp = string(*parameters.StorageAccountType)
		storageAccountType := arm.StorageAccountType(temp)
		result.StorageAccountType = &storageAccountType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *ManagedDiskParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedDiskParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *ManagedDiskParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedDiskParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedDiskParameters, got %T", armInput)
	}

	// Set property "DiskEncryptionSet":
	if typedInput.DiskEncryptionSet != nil {
		var diskEncryptionSet1 SubResource
		err := diskEncryptionSet1.PopulateFromARM(owner, *typedInput.DiskEncryptionSet)
		if err != nil {
			return err
		}
		diskEncryptionSet := diskEncryptionSet1
		parameters.DiskEncryptionSet = &diskEncryptionSet
	}

	// no assignment for property "Reference"

	// Set property "SecurityProfile":
	if typedInput.SecurityProfile != nil {
		var securityProfile1 VMDiskSecurityProfile
		err := securityProfile1.PopulateFromARM(owner, *typedInput.SecurityProfile)
		if err != nil {
			return err
		}
		securityProfile := securityProfile1
		parameters.SecurityProfile = &securityProfile
	}

	// Set property "StorageAccountType":
	if typedInput.StorageAccountType != nil {
		var temp string
		temp = string(*typedInput.StorageAccountType)
		storageAccountType := StorageAccountType(temp)
		parameters.StorageAccountType = &storageAccountType
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedDiskParameters populates our ManagedDiskParameters from the provided source ManagedDiskParameters
func (parameters *ManagedDiskParameters) AssignProperties_From_ManagedDiskParameters(source *storage.ManagedDiskParameters) error {

	// DiskEncryptionSet
	if source.DiskEncryptionSet != nil {
		var diskEncryptionSet SubResource
		err := diskEncryptionSet.AssignProperties_From_SubResource(source.DiskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field DiskEncryptionSet")
		}
		parameters.DiskEncryptionSet = &diskEncryptionSet
	} else {
		parameters.DiskEncryptionSet = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		parameters.Reference = &reference
	} else {
		parameters.Reference = nil
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		var securityProfile VMDiskSecurityProfile
		err := securityProfile.AssignProperties_From_VMDiskSecurityProfile(source.SecurityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VMDiskSecurityProfile() to populate field SecurityProfile")
		}
		parameters.SecurityProfile = &securityProfile
	} else {
		parameters.SecurityProfile = nil
	}

	// StorageAccountType
	if source.StorageAccountType != nil {
		storageAccountType := *source.StorageAccountType
		storageAccountTypeTemp := genruntime.ToEnum(storageAccountType, storageAccountType_Values)
		parameters.StorageAccountType = &storageAccountTypeTemp
	} else {
		parameters.StorageAccountType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedDiskParameters populates the provided destination ManagedDiskParameters from our ManagedDiskParameters
func (parameters *ManagedDiskParameters) AssignProperties_To_ManagedDiskParameters(destination *storage.ManagedDiskParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DiskEncryptionSet
	if parameters.DiskEncryptionSet != nil {
		var diskEncryptionSet storage.SubResource
		err := parameters.DiskEncryptionSet.AssignProperties_To_SubResource(&diskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field DiskEncryptionSet")
		}
		destination.DiskEncryptionSet = &diskEncryptionSet
	} else {
		destination.DiskEncryptionSet = nil
	}

	// Reference
	if parameters.Reference != nil {
		reference := parameters.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// SecurityProfile
	if parameters.SecurityProfile != nil {
		var securityProfile storage.VMDiskSecurityProfile
		err := parameters.SecurityProfile.AssignProperties_To_VMDiskSecurityProfile(&securityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VMDiskSecurityProfile() to populate field SecurityProfile")
		}
		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// StorageAccountType
	if parameters.StorageAccountType != nil {
		storageAccountType := string(*parameters.StorageAccountType)
		destination.StorageAccountType = &storageAccountType
	} else {
		destination.StorageAccountType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ManagedDiskParameters_STATUS populates our ManagedDiskParameters from the provided source ManagedDiskParameters_STATUS
func (parameters *ManagedDiskParameters) Initialize_From_ManagedDiskParameters_STATUS(source *ManagedDiskParameters_STATUS) error {

	// DiskEncryptionSet
	if source.DiskEncryptionSet != nil {
		var diskEncryptionSet SubResource
		err := diskEncryptionSet.Initialize_From_SubResource_STATUS(source.DiskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SubResource_STATUS() to populate field DiskEncryptionSet")
		}
		parameters.DiskEncryptionSet = &diskEncryptionSet
	} else {
		parameters.DiskEncryptionSet = nil
	}

	// Reference
	if source.Id != nil {
		reference := genruntime.CreateResourceReferenceFromARMID(*source.Id)
		parameters.Reference = &reference
	} else {
		parameters.Reference = nil
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		var securityProfile VMDiskSecurityProfile
		err := securityProfile.Initialize_From_VMDiskSecurityProfile_STATUS(source.SecurityProfile)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_VMDiskSecurityProfile_STATUS() to populate field SecurityProfile")
		}
		parameters.SecurityProfile = &securityProfile
	} else {
		parameters.SecurityProfile = nil
	}

	// StorageAccountType
	if source.StorageAccountType != nil {
		storageAccountType := genruntime.ToEnum(string(*source.StorageAccountType), storageAccountType_Values)
		parameters.StorageAccountType = &storageAccountType
	} else {
		parameters.StorageAccountType = nil
	}

	// No error
	return nil
}

// The parameters of a managed disk.
type ManagedDiskParameters_STATUS struct {
	// DiskEncryptionSet: Specifies the customer managed disk encryption set resource id for the managed disk.
	DiskEncryptionSet *SubResource_STATUS `json:"diskEncryptionSet,omitempty"`

	// Id: Resource Id
	Id *string `json:"id,omitempty"`

	// SecurityProfile: Specifies the security profile for the managed disk.
	SecurityProfile *VMDiskSecurityProfile_STATUS `json:"securityProfile,omitempty"`

	// StorageAccountType: Specifies the storage account type for the managed disk. NOTE: UltraSSD_LRS can only be used with
	// data disks, it cannot be used with OS Disk.
	StorageAccountType *StorageAccountType_STATUS `json:"storageAccountType,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedDiskParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *ManagedDiskParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedDiskParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *ManagedDiskParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedDiskParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedDiskParameters_STATUS, got %T", armInput)
	}

	// Set property "DiskEncryptionSet":
	if typedInput.DiskEncryptionSet != nil {
		var diskEncryptionSet1 SubResource_STATUS
		err := diskEncryptionSet1.PopulateFromARM(owner, *typedInput.DiskEncryptionSet)
		if err != nil {
			return err
		}
		diskEncryptionSet := diskEncryptionSet1
		parameters.DiskEncryptionSet = &diskEncryptionSet
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		parameters.Id = &id
	}

	// Set property "SecurityProfile":
	if typedInput.SecurityProfile != nil {
		var securityProfile1 VMDiskSecurityProfile_STATUS
		err := securityProfile1.PopulateFromARM(owner, *typedInput.SecurityProfile)
		if err != nil {
			return err
		}
		securityProfile := securityProfile1
		parameters.SecurityProfile = &securityProfile
	}

	// Set property "StorageAccountType":
	if typedInput.StorageAccountType != nil {
		var temp string
		temp = string(*typedInput.StorageAccountType)
		storageAccountType := StorageAccountType_STATUS(temp)
		parameters.StorageAccountType = &storageAccountType
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedDiskParameters_STATUS populates our ManagedDiskParameters_STATUS from the provided source ManagedDiskParameters_STATUS
func (parameters *ManagedDiskParameters_STATUS) AssignProperties_From_ManagedDiskParameters_STATUS(source *storage.ManagedDiskParameters_STATUS) error {

	// DiskEncryptionSet
	if source.DiskEncryptionSet != nil {
		var diskEncryptionSet SubResource_STATUS
		err := diskEncryptionSet.AssignProperties_From_SubResource_STATUS(source.DiskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field DiskEncryptionSet")
		}
		parameters.DiskEncryptionSet = &diskEncryptionSet
	} else {
		parameters.DiskEncryptionSet = nil
	}

	// Id
	parameters.Id = genruntime.ClonePointerToString(source.Id)

	// SecurityProfile
	if source.SecurityProfile != nil {
		var securityProfile VMDiskSecurityProfile_STATUS
		err := securityProfile.AssignProperties_From_VMDiskSecurityProfile_STATUS(source.SecurityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VMDiskSecurityProfile_STATUS() to populate field SecurityProfile")
		}
		parameters.SecurityProfile = &securityProfile
	} else {
		parameters.SecurityProfile = nil
	}

	// StorageAccountType
	if source.StorageAccountType != nil {
		storageAccountType := *source.StorageAccountType
		storageAccountTypeTemp := genruntime.ToEnum(storageAccountType, storageAccountType_STATUS_Values)
		parameters.StorageAccountType = &storageAccountTypeTemp
	} else {
		parameters.StorageAccountType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedDiskParameters_STATUS populates the provided destination ManagedDiskParameters_STATUS from our ManagedDiskParameters_STATUS
func (parameters *ManagedDiskParameters_STATUS) AssignProperties_To_ManagedDiskParameters_STATUS(destination *storage.ManagedDiskParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DiskEncryptionSet
	if parameters.DiskEncryptionSet != nil {
		var diskEncryptionSet storage.SubResource_STATUS
		err := parameters.DiskEncryptionSet.AssignProperties_To_SubResource_STATUS(&diskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field DiskEncryptionSet")
		}
		destination.DiskEncryptionSet = &diskEncryptionSet
	} else {
		destination.DiskEncryptionSet = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(parameters.Id)

	// SecurityProfile
	if parameters.SecurityProfile != nil {
		var securityProfile storage.VMDiskSecurityProfile_STATUS
		err := parameters.SecurityProfile.AssignProperties_To_VMDiskSecurityProfile_STATUS(&securityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VMDiskSecurityProfile_STATUS() to populate field SecurityProfile")
		}
		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// StorageAccountType
	if parameters.StorageAccountType != nil {
		storageAccountType := string(*parameters.StorageAccountType)
		destination.StorageAccountType = &storageAccountType
	} else {
		destination.StorageAccountType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Delete","Detach"}
type NetworkInterfaceReferenceProperties_DeleteOption string

const (
	NetworkInterfaceReferenceProperties_DeleteOption_Delete = NetworkInterfaceReferenceProperties_DeleteOption("Delete")
	NetworkInterfaceReferenceProperties_DeleteOption_Detach = NetworkInterfaceReferenceProperties_DeleteOption("Detach")
)

// Mapping from string to NetworkInterfaceReferenceProperties_DeleteOption
var networkInterfaceReferenceProperties_DeleteOption_Values = map[string]NetworkInterfaceReferenceProperties_DeleteOption{
	"delete": NetworkInterfaceReferenceProperties_DeleteOption_Delete,
	"detach": NetworkInterfaceReferenceProperties_DeleteOption_Detach,
}

type NetworkInterfaceReferenceProperties_DeleteOption_STATUS string

const (
	NetworkInterfaceReferenceProperties_DeleteOption_STATUS_Delete = NetworkInterfaceReferenceProperties_DeleteOption_STATUS("Delete")
	NetworkInterfaceReferenceProperties_DeleteOption_STATUS_Detach = NetworkInterfaceReferenceProperties_DeleteOption_STATUS("Detach")
)

// Mapping from string to NetworkInterfaceReferenceProperties_DeleteOption_STATUS
var networkInterfaceReferenceProperties_DeleteOption_STATUS_Values = map[string]NetworkInterfaceReferenceProperties_DeleteOption_STATUS{
	"delete": NetworkInterfaceReferenceProperties_DeleteOption_STATUS_Delete,
	"detach": NetworkInterfaceReferenceProperties_DeleteOption_STATUS_Detach,
}

// +kubebuilder:validation:Enum={"Linux","Windows"}
type OSDisk_OsType string

const (
	OSDisk_OsType_Linux   = OSDisk_OsType("Linux")
	OSDisk_OsType_Windows = OSDisk_OsType("Windows")
)

// Mapping from string to OSDisk_OsType
var oSDisk_OsType_Values = map[string]OSDisk_OsType{
	"linux":   OSDisk_OsType_Linux,
	"windows": OSDisk_OsType_Windows,
}

type OSDisk_OsType_STATUS string

const (
	OSDisk_OsType_STATUS_Linux   = OSDisk_OsType_STATUS("Linux")
	OSDisk_OsType_STATUS_Windows = OSDisk_OsType_STATUS("Windows")
)

// Mapping from string to OSDisk_OsType_STATUS
var oSDisk_OsType_STATUS_Values = map[string]OSDisk_OsType_STATUS{
	"linux":   OSDisk_OsType_STATUS_Linux,
	"windows": OSDisk_OsType_STATUS_Windows,
}

// Specifies settings related to VM Guest Patching on Windows.
type PatchSettings struct {
	// AssessmentMode: Specifies the mode of VM Guest patch assessment for the IaaS virtual machine.
	// Possible values are:
	// ImageDefault - You control the timing of patch assessments on a virtual machine.
	// AutomaticByPlatform - The platform will trigger periodic patch assessments. The property provisionVMAgent must be true.
	AssessmentMode *PatchSettings_AssessmentMode `json:"assessmentMode,omitempty"`

	// AutomaticByPlatformSettings: Specifies additional settings for patch mode AutomaticByPlatform in VM Guest Patching on
	// Windows.
	AutomaticByPlatformSettings *WindowsVMGuestPatchAutomaticByPlatformSettings `json:"automaticByPlatformSettings,omitempty"`

	// EnableHotpatching: Enables customers to patch their Azure VMs without requiring a reboot. For enableHotpatching, the
	// 'provisionVMAgent' must be set to true and 'patchMode' must be set to 'AutomaticByPlatform'.
	EnableHotpatching *bool `json:"enableHotpatching,omitempty"`

	// PatchMode: Specifies the mode of VM Guest Patching to IaaS virtual machine or virtual machines associated to virtual
	// machine scale set with OrchestrationMode as Flexible.
	// Possible values are:
	// Manual - You  control the application of patches to a virtual machine. You do this by applying patches manually inside
	// the VM. In this mode, automatic updates are disabled; the property WindowsConfiguration.enableAutomaticUpdates must be
	// false
	// AutomaticByOS - The virtual machine will automatically be updated by the OS. The property
	// WindowsConfiguration.enableAutomaticUpdates must be true.
	// AutomaticByPlatform - the virtual machine will automatically updated by the platform. The properties provisionVMAgent
	// and WindowsConfiguration.enableAutomaticUpdates must be true
	PatchMode *PatchSettings_PatchMode `json:"patchMode,omitempty"`
}

var _ genruntime.ARMTransformer = &PatchSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *PatchSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.PatchSettings{}

	// Set property "AssessmentMode":
	if settings.AssessmentMode != nil {
		var temp string
		temp = string(*settings.AssessmentMode)
		assessmentMode := arm.PatchSettings_AssessmentMode(temp)
		result.AssessmentMode = &assessmentMode
	}

	// Set property "AutomaticByPlatformSettings":
	if settings.AutomaticByPlatformSettings != nil {
		automaticByPlatformSettings_ARM, err := (*settings.AutomaticByPlatformSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		automaticByPlatformSettings := *automaticByPlatformSettings_ARM.(*arm.WindowsVMGuestPatchAutomaticByPlatformSettings)
		result.AutomaticByPlatformSettings = &automaticByPlatformSettings
	}

	// Set property "EnableHotpatching":
	if settings.EnableHotpatching != nil {
		enableHotpatching := *settings.EnableHotpatching
		result.EnableHotpatching = &enableHotpatching
	}

	// Set property "PatchMode":
	if settings.PatchMode != nil {
		var temp string
		temp = string(*settings.PatchMode)
		patchMode := arm.PatchSettings_PatchMode(temp)
		result.PatchMode = &patchMode
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *PatchSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PatchSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *PatchSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PatchSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PatchSettings, got %T", armInput)
	}

	// Set property "AssessmentMode":
	if typedInput.AssessmentMode != nil {
		var temp string
		temp = string(*typedInput.AssessmentMode)
		assessmentMode := PatchSettings_AssessmentMode(temp)
		settings.AssessmentMode = &assessmentMode
	}

	// Set property "AutomaticByPlatformSettings":
	if typedInput.AutomaticByPlatformSettings != nil {
		var automaticByPlatformSettings1 WindowsVMGuestPatchAutomaticByPlatformSettings
		err := automaticByPlatformSettings1.PopulateFromARM(owner, *typedInput.AutomaticByPlatformSettings)
		if err != nil {
			return err
		}
		automaticByPlatformSettings := automaticByPlatformSettings1
		settings.AutomaticByPlatformSettings = &automaticByPlatformSettings
	}

	// Set property "EnableHotpatching":
	if typedInput.EnableHotpatching != nil {
		enableHotpatching := *typedInput.EnableHotpatching
		settings.EnableHotpatching = &enableHotpatching
	}

	// Set property "PatchMode":
	if typedInput.PatchMode != nil {
		var temp string
		temp = string(*typedInput.PatchMode)
		patchMode := PatchSettings_PatchMode(temp)
		settings.PatchMode = &patchMode
	}

	// No error
	return nil
}

// AssignProperties_From_PatchSettings populates our PatchSettings from the provided source PatchSettings
func (settings *PatchSettings) AssignProperties_From_PatchSettings(source *storage.PatchSettings) error {

	// AssessmentMode
	if source.AssessmentMode != nil {
		assessmentMode := *source.AssessmentMode
		assessmentModeTemp := genruntime.ToEnum(assessmentMode, patchSettings_AssessmentMode_Values)
		settings.AssessmentMode = &assessmentModeTemp
	} else {
		settings.AssessmentMode = nil
	}

	// AutomaticByPlatformSettings
	if source.AutomaticByPlatformSettings != nil {
		var automaticByPlatformSetting WindowsVMGuestPatchAutomaticByPlatformSettings
		err := automaticByPlatformSetting.AssignProperties_From_WindowsVMGuestPatchAutomaticByPlatformSettings(source.AutomaticByPlatformSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WindowsVMGuestPatchAutomaticByPlatformSettings() to populate field AutomaticByPlatformSettings")
		}
		settings.AutomaticByPlatformSettings = &automaticByPlatformSetting
	} else {
		settings.AutomaticByPlatformSettings = nil
	}

	// EnableHotpatching
	if source.EnableHotpatching != nil {
		enableHotpatching := *source.EnableHotpatching
		settings.EnableHotpatching = &enableHotpatching
	} else {
		settings.EnableHotpatching = nil
	}

	// PatchMode
	if source.PatchMode != nil {
		patchMode := *source.PatchMode
		patchModeTemp := genruntime.ToEnum(patchMode, patchSettings_PatchMode_Values)
		settings.PatchMode = &patchModeTemp
	} else {
		settings.PatchMode = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PatchSettings populates the provided destination PatchSettings from our PatchSettings
func (settings *PatchSettings) AssignProperties_To_PatchSettings(destination *storage.PatchSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AssessmentMode
	if settings.AssessmentMode != nil {
		assessmentMode := string(*settings.AssessmentMode)
		destination.AssessmentMode = &assessmentMode
	} else {
		destination.AssessmentMode = nil
	}

	// AutomaticByPlatformSettings
	if settings.AutomaticByPlatformSettings != nil {
		var automaticByPlatformSetting storage.WindowsVMGuestPatchAutomaticByPlatformSettings
		err := settings.AutomaticByPlatformSettings.AssignProperties_To_WindowsVMGuestPatchAutomaticByPlatformSettings(&automaticByPlatformSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WindowsVMGuestPatchAutomaticByPlatformSettings() to populate field AutomaticByPlatformSettings")
		}
		destination.AutomaticByPlatformSettings = &automaticByPlatformSetting
	} else {
		destination.AutomaticByPlatformSettings = nil
	}

	// EnableHotpatching
	if settings.EnableHotpatching != nil {
		enableHotpatching := *settings.EnableHotpatching
		destination.EnableHotpatching = &enableHotpatching
	} else {
		destination.EnableHotpatching = nil
	}

	// PatchMode
	if settings.PatchMode != nil {
		patchMode := string(*settings.PatchMode)
		destination.PatchMode = &patchMode
	} else {
		destination.PatchMode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_PatchSettings_STATUS populates our PatchSettings from the provided source PatchSettings_STATUS
func (settings *PatchSettings) Initialize_From_PatchSettings_STATUS(source *PatchSettings_STATUS) error {

	// AssessmentMode
	if source.AssessmentMode != nil {
		assessmentMode := genruntime.ToEnum(string(*source.AssessmentMode), patchSettings_AssessmentMode_Values)
		settings.AssessmentMode = &assessmentMode
	} else {
		settings.AssessmentMode = nil
	}

	// AutomaticByPlatformSettings
	if source.AutomaticByPlatformSettings != nil {
		var automaticByPlatformSetting WindowsVMGuestPatchAutomaticByPlatformSettings
		err := automaticByPlatformSetting.Initialize_From_WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS(source.AutomaticByPlatformSettings)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS() to populate field AutomaticByPlatformSettings")
		}
		settings.AutomaticByPlatformSettings = &automaticByPlatformSetting
	} else {
		settings.AutomaticByPlatformSettings = nil
	}

	// EnableHotpatching
	if source.EnableHotpatching != nil {
		enableHotpatching := *source.EnableHotpatching
		settings.EnableHotpatching = &enableHotpatching
	} else {
		settings.EnableHotpatching = nil
	}

	// PatchMode
	if source.PatchMode != nil {
		patchMode := genruntime.ToEnum(string(*source.PatchMode), patchSettings_PatchMode_Values)
		settings.PatchMode = &patchMode
	} else {
		settings.PatchMode = nil
	}

	// No error
	return nil
}

// Specifies settings related to VM Guest Patching on Windows.
type PatchSettings_STATUS struct {
	// AssessmentMode: Specifies the mode of VM Guest patch assessment for the IaaS virtual machine.
	// Possible values are:
	// ImageDefault - You control the timing of patch assessments on a virtual machine.
	// AutomaticByPlatform - The platform will trigger periodic patch assessments. The property provisionVMAgent must be true.
	AssessmentMode *PatchSettings_AssessmentMode_STATUS `json:"assessmentMode,omitempty"`

	// AutomaticByPlatformSettings: Specifies additional settings for patch mode AutomaticByPlatform in VM Guest Patching on
	// Windows.
	AutomaticByPlatformSettings *WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS `json:"automaticByPlatformSettings,omitempty"`

	// EnableHotpatching: Enables customers to patch their Azure VMs without requiring a reboot. For enableHotpatching, the
	// 'provisionVMAgent' must be set to true and 'patchMode' must be set to 'AutomaticByPlatform'.
	EnableHotpatching *bool `json:"enableHotpatching,omitempty"`

	// PatchMode: Specifies the mode of VM Guest Patching to IaaS virtual machine or virtual machines associated to virtual
	// machine scale set with OrchestrationMode as Flexible.
	// Possible values are:
	// Manual - You  control the application of patches to a virtual machine. You do this by applying patches manually inside
	// the VM. In this mode, automatic updates are disabled; the property WindowsConfiguration.enableAutomaticUpdates must be
	// false
	// AutomaticByOS - The virtual machine will automatically be updated by the OS. The property
	// WindowsConfiguration.enableAutomaticUpdates must be true.
	// AutomaticByPlatform - the virtual machine will automatically updated by the platform. The properties provisionVMAgent
	// and WindowsConfiguration.enableAutomaticUpdates must be true
	PatchMode *PatchSettings_PatchMode_STATUS `json:"patchMode,omitempty"`
}

var _ genruntime.FromARMConverter = &PatchSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *PatchSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PatchSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *PatchSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PatchSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PatchSettings_STATUS, got %T", armInput)
	}

	// Set property "AssessmentMode":
	if typedInput.AssessmentMode != nil {
		var temp string
		temp = string(*typedInput.AssessmentMode)
		assessmentMode := PatchSettings_AssessmentMode_STATUS(temp)
		settings.AssessmentMode = &assessmentMode
	}

	// Set property "AutomaticByPlatformSettings":
	if typedInput.AutomaticByPlatformSettings != nil {
		var automaticByPlatformSettings1 WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS
		err := automaticByPlatformSettings1.PopulateFromARM(owner, *typedInput.AutomaticByPlatformSettings)
		if err != nil {
			return err
		}
		automaticByPlatformSettings := automaticByPlatformSettings1
		settings.AutomaticByPlatformSettings = &automaticByPlatformSettings
	}

	// Set property "EnableHotpatching":
	if typedInput.EnableHotpatching != nil {
		enableHotpatching := *typedInput.EnableHotpatching
		settings.EnableHotpatching = &enableHotpatching
	}

	// Set property "PatchMode":
	if typedInput.PatchMode != nil {
		var temp string
		temp = string(*typedInput.PatchMode)
		patchMode := PatchSettings_PatchMode_STATUS(temp)
		settings.PatchMode = &patchMode
	}

	// No error
	return nil
}

// AssignProperties_From_PatchSettings_STATUS populates our PatchSettings_STATUS from the provided source PatchSettings_STATUS
func (settings *PatchSettings_STATUS) AssignProperties_From_PatchSettings_STATUS(source *storage.PatchSettings_STATUS) error {

	// AssessmentMode
	if source.AssessmentMode != nil {
		assessmentMode := *source.AssessmentMode
		assessmentModeTemp := genruntime.ToEnum(assessmentMode, patchSettings_AssessmentMode_STATUS_Values)
		settings.AssessmentMode = &assessmentModeTemp
	} else {
		settings.AssessmentMode = nil
	}

	// AutomaticByPlatformSettings
	if source.AutomaticByPlatformSettings != nil {
		var automaticByPlatformSetting WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS
		err := automaticByPlatformSetting.AssignProperties_From_WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS(source.AutomaticByPlatformSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS() to populate field AutomaticByPlatformSettings")
		}
		settings.AutomaticByPlatformSettings = &automaticByPlatformSetting
	} else {
		settings.AutomaticByPlatformSettings = nil
	}

	// EnableHotpatching
	if source.EnableHotpatching != nil {
		enableHotpatching := *source.EnableHotpatching
		settings.EnableHotpatching = &enableHotpatching
	} else {
		settings.EnableHotpatching = nil
	}

	// PatchMode
	if source.PatchMode != nil {
		patchMode := *source.PatchMode
		patchModeTemp := genruntime.ToEnum(patchMode, patchSettings_PatchMode_STATUS_Values)
		settings.PatchMode = &patchModeTemp
	} else {
		settings.PatchMode = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PatchSettings_STATUS populates the provided destination PatchSettings_STATUS from our PatchSettings_STATUS
func (settings *PatchSettings_STATUS) AssignProperties_To_PatchSettings_STATUS(destination *storage.PatchSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AssessmentMode
	if settings.AssessmentMode != nil {
		assessmentMode := string(*settings.AssessmentMode)
		destination.AssessmentMode = &assessmentMode
	} else {
		destination.AssessmentMode = nil
	}

	// AutomaticByPlatformSettings
	if settings.AutomaticByPlatformSettings != nil {
		var automaticByPlatformSetting storage.WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS
		err := settings.AutomaticByPlatformSettings.AssignProperties_To_WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS(&automaticByPlatformSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS() to populate field AutomaticByPlatformSettings")
		}
		destination.AutomaticByPlatformSettings = &automaticByPlatformSetting
	} else {
		destination.AutomaticByPlatformSettings = nil
	}

	// EnableHotpatching
	if settings.EnableHotpatching != nil {
		enableHotpatching := *settings.EnableHotpatching
		destination.EnableHotpatching = &enableHotpatching
	} else {
		destination.EnableHotpatching = nil
	}

	// PatchMode
	if settings.PatchMode != nil {
		patchMode := string(*settings.PatchMode)
		destination.PatchMode = &patchMode
	} else {
		destination.PatchMode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// SSH configuration for Linux based VMs running on Azure
type SshConfiguration struct {
	// PublicKeys: The list of SSH public keys used to authenticate with linux based VMs.
	PublicKeys []SshPublicKeySpec `json:"publicKeys,omitempty"`
}

var _ genruntime.ARMTransformer = &SshConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *SshConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.SshConfiguration{}

	// Set property "PublicKeys":
	for _, item := range configuration.PublicKeys {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.PublicKeys = append(result.PublicKeys, *item_ARM.(*arm.SshPublicKeySpec))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *SshConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SshConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *SshConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SshConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SshConfiguration, got %T", armInput)
	}

	// Set property "PublicKeys":
	for _, item := range typedInput.PublicKeys {
		var item1 SshPublicKeySpec
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		configuration.PublicKeys = append(configuration.PublicKeys, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_SshConfiguration populates our SshConfiguration from the provided source SshConfiguration
func (configuration *SshConfiguration) AssignProperties_From_SshConfiguration(source *storage.SshConfiguration) error {

	// PublicKeys
	if source.PublicKeys != nil {
		publicKeyList := make([]SshPublicKeySpec, len(source.PublicKeys))
		for publicKeyIndex, publicKeyItem := range source.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey SshPublicKeySpec
			err := publicKey.AssignProperties_From_SshPublicKeySpec(&publicKeyItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SshPublicKeySpec() to populate field PublicKeys")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		configuration.PublicKeys = publicKeyList
	} else {
		configuration.PublicKeys = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SshConfiguration populates the provided destination SshConfiguration from our SshConfiguration
func (configuration *SshConfiguration) AssignProperties_To_SshConfiguration(destination *storage.SshConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PublicKeys
	if configuration.PublicKeys != nil {
		publicKeyList := make([]storage.SshPublicKeySpec, len(configuration.PublicKeys))
		for publicKeyIndex, publicKeyItem := range configuration.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey storage.SshPublicKeySpec
			err := publicKeyItem.AssignProperties_To_SshPublicKeySpec(&publicKey)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SshPublicKeySpec() to populate field PublicKeys")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		destination.PublicKeys = publicKeyList
	} else {
		destination.PublicKeys = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_SshConfiguration_STATUS populates our SshConfiguration from the provided source SshConfiguration_STATUS
func (configuration *SshConfiguration) Initialize_From_SshConfiguration_STATUS(source *SshConfiguration_STATUS) error {

	// PublicKeys
	if source.PublicKeys != nil {
		publicKeyList := make([]SshPublicKeySpec, len(source.PublicKeys))
		for publicKeyIndex, publicKeyItem := range source.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey SshPublicKeySpec
			err := publicKey.Initialize_From_SshPublicKey_STATUS(&publicKeyItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_SshPublicKey_STATUS() to populate field PublicKeys")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		configuration.PublicKeys = publicKeyList
	} else {
		configuration.PublicKeys = nil
	}

	// No error
	return nil
}

// SSH configuration for Linux based VMs running on Azure
type SshConfiguration_STATUS struct {
	// PublicKeys: The list of SSH public keys used to authenticate with linux based VMs.
	PublicKeys []SshPublicKey_STATUS `json:"publicKeys,omitempty"`
}

var _ genruntime.FromARMConverter = &SshConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *SshConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SshConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *SshConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SshConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SshConfiguration_STATUS, got %T", armInput)
	}

	// Set property "PublicKeys":
	for _, item := range typedInput.PublicKeys {
		var item1 SshPublicKey_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		configuration.PublicKeys = append(configuration.PublicKeys, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_SshConfiguration_STATUS populates our SshConfiguration_STATUS from the provided source SshConfiguration_STATUS
func (configuration *SshConfiguration_STATUS) AssignProperties_From_SshConfiguration_STATUS(source *storage.SshConfiguration_STATUS) error {

	// PublicKeys
	if source.PublicKeys != nil {
		publicKeyList := make([]SshPublicKey_STATUS, len(source.PublicKeys))
		for publicKeyIndex, publicKeyItem := range source.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey SshPublicKey_STATUS
			err := publicKey.AssignProperties_From_SshPublicKey_STATUS(&publicKeyItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SshPublicKey_STATUS() to populate field PublicKeys")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		configuration.PublicKeys = publicKeyList
	} else {
		configuration.PublicKeys = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SshConfiguration_STATUS populates the provided destination SshConfiguration_STATUS from our SshConfiguration_STATUS
func (configuration *SshConfiguration_STATUS) AssignProperties_To_SshConfiguration_STATUS(destination *storage.SshConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PublicKeys
	if configuration.PublicKeys != nil {
		publicKeyList := make([]storage.SshPublicKey_STATUS, len(configuration.PublicKeys))
		for publicKeyIndex, publicKeyItem := range configuration.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey storage.SshPublicKey_STATUS
			err := publicKeyItem.AssignProperties_To_SshPublicKey_STATUS(&publicKey)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SshPublicKey_STATUS() to populate field PublicKeys")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		destination.PublicKeys = publicKeyList
	} else {
		destination.PublicKeys = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes a single certificate reference in a Key Vault, and where the certificate should reside on the VM.
type VaultCertificate struct {
	// CertificateStore: For Windows VMs, specifies the certificate store on the Virtual Machine to which the certificate
	// should be added. The specified certificate store is implicitly in the LocalMachine account.
	// For Linux VMs, the certificate file is placed under the /var/lib/waagent directory, with the file name
	// &lt;UppercaseThumbprint&gt;.crt for the X509 certificate file and &lt;UppercaseThumbprint&gt;.prv for private key. Both
	// of these files are .pem formatted.
	CertificateStore *string `json:"certificateStore,omitempty"`

	// CertificateUrl: This is the URL of a certificate that has been uploaded to Key Vault as a secret. For adding a secret to
	// the Key Vault, see [Add a key or secret to the key
	// vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add). In this case, your certificate needs to
	// be It is the Base64 encoding of the following JSON Object which is encoded in UTF-8:
	// {
	// "data":"<Base64-encoded-certificate>",
	// "dataType":"pfx",
	// "password":"<pfx-file-password>"
	// }
	// To install certificates on a virtual machine it is recommended to use the [Azure Key Vault virtual machine extension for
	// Linux](https://docs.microsoft.com/azure/virtual-machines/extensions/key-vault-linux) or the [Azure Key Vault virtual
	// machine extension for Windows](https://docs.microsoft.com/azure/virtual-machines/extensions/key-vault-windows).
	CertificateUrl *string `json:"certificateUrl,omitempty"`
}

var _ genruntime.ARMTransformer = &VaultCertificate{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (certificate *VaultCertificate) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if certificate == nil {
		return nil, nil
	}
	result := &arm.VaultCertificate{}

	// Set property "CertificateStore":
	if certificate.CertificateStore != nil {
		certificateStore := *certificate.CertificateStore
		result.CertificateStore = &certificateStore
	}

	// Set property "CertificateUrl":
	if certificate.CertificateUrl != nil {
		certificateUrl := *certificate.CertificateUrl
		result.CertificateUrl = &certificateUrl
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (certificate *VaultCertificate) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VaultCertificate{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (certificate *VaultCertificate) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VaultCertificate)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VaultCertificate, got %T", armInput)
	}

	// Set property "CertificateStore":
	if typedInput.CertificateStore != nil {
		certificateStore := *typedInput.CertificateStore
		certificate.CertificateStore = &certificateStore
	}

	// Set property "CertificateUrl":
	if typedInput.CertificateUrl != nil {
		certificateUrl := *typedInput.CertificateUrl
		certificate.CertificateUrl = &certificateUrl
	}

	// No error
	return nil
}

// AssignProperties_From_VaultCertificate populates our VaultCertificate from the provided source VaultCertificate
func (certificate *VaultCertificate) AssignProperties_From_VaultCertificate(source *storage.VaultCertificate) error {

	// CertificateStore
	certificate.CertificateStore = genruntime.ClonePointerToString(source.CertificateStore)

	// CertificateUrl
	certificate.CertificateUrl = genruntime.ClonePointerToString(source.CertificateUrl)

	// No error
	return nil
}

// AssignProperties_To_VaultCertificate populates the provided destination VaultCertificate from our VaultCertificate
func (certificate *VaultCertificate) AssignProperties_To_VaultCertificate(destination *storage.VaultCertificate) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CertificateStore
	destination.CertificateStore = genruntime.ClonePointerToString(certificate.CertificateStore)

	// CertificateUrl
	destination.CertificateUrl = genruntime.ClonePointerToString(certificate.CertificateUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VaultCertificate_STATUS populates our VaultCertificate from the provided source VaultCertificate_STATUS
func (certificate *VaultCertificate) Initialize_From_VaultCertificate_STATUS(source *VaultCertificate_STATUS) error {

	// CertificateStore
	certificate.CertificateStore = genruntime.ClonePointerToString(source.CertificateStore)

	// CertificateUrl
	certificate.CertificateUrl = genruntime.ClonePointerToString(source.CertificateUrl)

	// No error
	return nil
}

// Describes a single certificate reference in a Key Vault, and where the certificate should reside on the VM.
type VaultCertificate_STATUS struct {
	// CertificateStore: For Windows VMs, specifies the certificate store on the Virtual Machine to which the certificate
	// should be added. The specified certificate store is implicitly in the LocalMachine account.
	// For Linux VMs, the certificate file is placed under the /var/lib/waagent directory, with the file name
	// &lt;UppercaseThumbprint&gt;.crt for the X509 certificate file and &lt;UppercaseThumbprint&gt;.prv for private key. Both
	// of these files are .pem formatted.
	CertificateStore *string `json:"certificateStore,omitempty"`

	// CertificateUrl: This is the URL of a certificate that has been uploaded to Key Vault as a secret. For adding a secret to
	// the Key Vault, see [Add a key or secret to the key
	// vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add). In this case, your certificate needs to
	// be It is the Base64 encoding of the following JSON Object which is encoded in UTF-8:
	// {
	// "data":"<Base64-encoded-certificate>",
	// "dataType":"pfx",
	// "password":"<pfx-file-password>"
	// }
	// To install certificates on a virtual machine it is recommended to use the [Azure Key Vault virtual machine extension for
	// Linux](https://docs.microsoft.com/azure/virtual-machines/extensions/key-vault-linux) or the [Azure Key Vault virtual
	// machine extension for Windows](https://docs.microsoft.com/azure/virtual-machines/extensions/key-vault-windows).
	CertificateUrl *string `json:"certificateUrl,omitempty"`
}

var _ genruntime.FromARMConverter = &VaultCertificate_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (certificate *VaultCertificate_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VaultCertificate_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (certificate *VaultCertificate_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VaultCertificate_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VaultCertificate_STATUS, got %T", armInput)
	}

	// Set property "CertificateStore":
	if typedInput.CertificateStore != nil {
		certificateStore := *typedInput.CertificateStore
		certificate.CertificateStore = &certificateStore
	}

	// Set property "CertificateUrl":
	if typedInput.CertificateUrl != nil {
		certificateUrl := *typedInput.CertificateUrl
		certificate.CertificateUrl = &certificateUrl
	}

	// No error
	return nil
}

// AssignProperties_From_VaultCertificate_STATUS populates our VaultCertificate_STATUS from the provided source VaultCertificate_STATUS
func (certificate *VaultCertificate_STATUS) AssignProperties_From_VaultCertificate_STATUS(source *storage.VaultCertificate_STATUS) error {

	// CertificateStore
	certificate.CertificateStore = genruntime.ClonePointerToString(source.CertificateStore)

	// CertificateUrl
	certificate.CertificateUrl = genruntime.ClonePointerToString(source.CertificateUrl)

	// No error
	return nil
}

// AssignProperties_To_VaultCertificate_STATUS populates the provided destination VaultCertificate_STATUS from our VaultCertificate_STATUS
func (certificate *VaultCertificate_STATUS) AssignProperties_To_VaultCertificate_STATUS(destination *storage.VaultCertificate_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CertificateStore
	destination.CertificateStore = genruntime.ClonePointerToString(certificate.CertificateStore)

	// CertificateUrl
	destination.CertificateUrl = genruntime.ClonePointerToString(certificate.CertificateUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes the uri of a disk.
type VirtualHardDisk struct {
	// Uri: Specifies the virtual hard disk's uri.
	Uri *string `json:"uri,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualHardDisk{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (disk *VirtualHardDisk) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if disk == nil {
		return nil, nil
	}
	result := &arm.VirtualHardDisk{}

	// Set property "Uri":
	if disk.Uri != nil {
		uri := *disk.Uri
		result.Uri = &uri
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (disk *VirtualHardDisk) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualHardDisk{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (disk *VirtualHardDisk) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualHardDisk)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualHardDisk, got %T", armInput)
	}

	// Set property "Uri":
	if typedInput.Uri != nil {
		uri := *typedInput.Uri
		disk.Uri = &uri
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualHardDisk populates our VirtualHardDisk from the provided source VirtualHardDisk
func (disk *VirtualHardDisk) AssignProperties_From_VirtualHardDisk(source *storage.VirtualHardDisk) error {

	// Uri
	disk.Uri = genruntime.ClonePointerToString(source.Uri)

	// No error
	return nil
}

// AssignProperties_To_VirtualHardDisk populates the provided destination VirtualHardDisk from our VirtualHardDisk
func (disk *VirtualHardDisk) AssignProperties_To_VirtualHardDisk(destination *storage.VirtualHardDisk) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Uri
	destination.Uri = genruntime.ClonePointerToString(disk.Uri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualHardDisk_STATUS populates our VirtualHardDisk from the provided source VirtualHardDisk_STATUS
func (disk *VirtualHardDisk) Initialize_From_VirtualHardDisk_STATUS(source *VirtualHardDisk_STATUS) error {

	// Uri
	disk.Uri = genruntime.ClonePointerToString(source.Uri)

	// No error
	return nil
}

// Describes the uri of a disk.
type VirtualHardDisk_STATUS struct {
	// Uri: Specifies the virtual hard disk's uri.
	Uri *string `json:"uri,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualHardDisk_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (disk *VirtualHardDisk_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualHardDisk_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (disk *VirtualHardDisk_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualHardDisk_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualHardDisk_STATUS, got %T", armInput)
	}

	// Set property "Uri":
	if typedInput.Uri != nil {
		uri := *typedInput.Uri
		disk.Uri = &uri
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualHardDisk_STATUS populates our VirtualHardDisk_STATUS from the provided source VirtualHardDisk_STATUS
func (disk *VirtualHardDisk_STATUS) AssignProperties_From_VirtualHardDisk_STATUS(source *storage.VirtualHardDisk_STATUS) error {

	// Uri
	disk.Uri = genruntime.ClonePointerToString(source.Uri)

	// No error
	return nil
}

// AssignProperties_To_VirtualHardDisk_STATUS populates the provided destination VirtualHardDisk_STATUS from our VirtualHardDisk_STATUS
func (disk *VirtualHardDisk_STATUS) AssignProperties_To_VirtualHardDisk_STATUS(destination *storage.VirtualHardDisk_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Uri
	destination.Uri = genruntime.ClonePointerToString(disk.Uri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The instance view of a virtual machine extension handler.
type VirtualMachineExtensionHandlerInstanceView_STATUS struct {
	// Status: The extension handler status.
	Status *InstanceViewStatus_STATUS `json:"status,omitempty"`

	// Type: Specifies the type of the extension; an example is "CustomScriptExtension".
	Type *string `json:"type,omitempty"`

	// TypeHandlerVersion: Specifies the version of the script handler.
	TypeHandlerVersion *string `json:"typeHandlerVersion,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineExtensionHandlerInstanceView_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (view *VirtualMachineExtensionHandlerInstanceView_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineExtensionHandlerInstanceView_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (view *VirtualMachineExtensionHandlerInstanceView_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineExtensionHandlerInstanceView_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineExtensionHandlerInstanceView_STATUS, got %T", armInput)
	}

	// Set property "Status":
	if typedInput.Status != nil {
		var status1 InstanceViewStatus_STATUS
		err := status1.PopulateFromARM(owner, *typedInput.Status)
		if err != nil {
			return err
		}
		status := status1
		view.Status = &status
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		view.Type = &typeVar
	}

	// Set property "TypeHandlerVersion":
	if typedInput.TypeHandlerVersion != nil {
		typeHandlerVersion := *typedInput.TypeHandlerVersion
		view.TypeHandlerVersion = &typeHandlerVersion
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineExtensionHandlerInstanceView_STATUS populates our VirtualMachineExtensionHandlerInstanceView_STATUS from the provided source VirtualMachineExtensionHandlerInstanceView_STATUS
func (view *VirtualMachineExtensionHandlerInstanceView_STATUS) AssignProperties_From_VirtualMachineExtensionHandlerInstanceView_STATUS(source *storage.VirtualMachineExtensionHandlerInstanceView_STATUS) error {

	// Status
	if source.Status != nil {
		var status InstanceViewStatus_STATUS
		err := status.AssignProperties_From_InstanceViewStatus_STATUS(source.Status)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_InstanceViewStatus_STATUS() to populate field Status")
		}
		view.Status = &status
	} else {
		view.Status = nil
	}

	// Type
	view.Type = genruntime.ClonePointerToString(source.Type)

	// TypeHandlerVersion
	view.TypeHandlerVersion = genruntime.ClonePointerToString(source.TypeHandlerVersion)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineExtensionHandlerInstanceView_STATUS populates the provided destination VirtualMachineExtensionHandlerInstanceView_STATUS from our VirtualMachineExtensionHandlerInstanceView_STATUS
func (view *VirtualMachineExtensionHandlerInstanceView_STATUS) AssignProperties_To_VirtualMachineExtensionHandlerInstanceView_STATUS(destination *storage.VirtualMachineExtensionHandlerInstanceView_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Status
	if view.Status != nil {
		var status storage.InstanceViewStatus_STATUS
		err := view.Status.AssignProperties_To_InstanceViewStatus_STATUS(&status)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_InstanceViewStatus_STATUS() to populate field Status")
		}
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(view.Type)

	// TypeHandlerVersion
	destination.TypeHandlerVersion = genruntime.ClonePointerToString(view.TypeHandlerVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Delete","Detach"}
type VirtualMachineNetworkInterfaceConfigurationProperties_DeleteOption string

const (
	VirtualMachineNetworkInterfaceConfigurationProperties_DeleteOption_Delete = VirtualMachineNetworkInterfaceConfigurationProperties_DeleteOption("Delete")
	VirtualMachineNetworkInterfaceConfigurationProperties_DeleteOption_Detach = VirtualMachineNetworkInterfaceConfigurationProperties_DeleteOption("Detach")
)

// Mapping from string to VirtualMachineNetworkInterfaceConfigurationProperties_DeleteOption
var virtualMachineNetworkInterfaceConfigurationProperties_DeleteOption_Values = map[string]VirtualMachineNetworkInterfaceConfigurationProperties_DeleteOption{
	"delete": VirtualMachineNetworkInterfaceConfigurationProperties_DeleteOption_Delete,
	"detach": VirtualMachineNetworkInterfaceConfigurationProperties_DeleteOption_Detach,
}

type VirtualMachineNetworkInterfaceConfigurationProperties_DeleteOption_STATUS string

const (
	VirtualMachineNetworkInterfaceConfigurationProperties_DeleteOption_STATUS_Delete = VirtualMachineNetworkInterfaceConfigurationProperties_DeleteOption_STATUS("Delete")
	VirtualMachineNetworkInterfaceConfigurationProperties_DeleteOption_STATUS_Detach = VirtualMachineNetworkInterfaceConfigurationProperties_DeleteOption_STATUS("Detach")
)

// Mapping from string to VirtualMachineNetworkInterfaceConfigurationProperties_DeleteOption_STATUS
var virtualMachineNetworkInterfaceConfigurationProperties_DeleteOption_STATUS_Values = map[string]VirtualMachineNetworkInterfaceConfigurationProperties_DeleteOption_STATUS{
	"delete": VirtualMachineNetworkInterfaceConfigurationProperties_DeleteOption_STATUS_Delete,
	"detach": VirtualMachineNetworkInterfaceConfigurationProperties_DeleteOption_STATUS_Detach,
}

// Describes a virtual machines network configuration's DNS settings.
type VirtualMachineNetworkInterfaceDnsSettingsConfiguration struct {
	// DnsServers: List of DNS servers IP addresses
	DnsServers []string `json:"dnsServers,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineNetworkInterfaceDnsSettingsConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *VirtualMachineNetworkInterfaceDnsSettingsConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.VirtualMachineNetworkInterfaceDnsSettingsConfiguration{}

	// Set property "DnsServers":
	for _, item := range configuration.DnsServers {
		result.DnsServers = append(result.DnsServers, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *VirtualMachineNetworkInterfaceDnsSettingsConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineNetworkInterfaceDnsSettingsConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *VirtualMachineNetworkInterfaceDnsSettingsConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineNetworkInterfaceDnsSettingsConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineNetworkInterfaceDnsSettingsConfiguration, got %T", armInput)
	}

	// Set property "DnsServers":
	for _, item := range typedInput.DnsServers {
		configuration.DnsServers = append(configuration.DnsServers, item)
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineNetworkInterfaceDnsSettingsConfiguration populates our VirtualMachineNetworkInterfaceDnsSettingsConfiguration from the provided source VirtualMachineNetworkInterfaceDnsSettingsConfiguration
func (configuration *VirtualMachineNetworkInterfaceDnsSettingsConfiguration) AssignProperties_From_VirtualMachineNetworkInterfaceDnsSettingsConfiguration(source *storage.VirtualMachineNetworkInterfaceDnsSettingsConfiguration) error {

	// DnsServers
	configuration.DnsServers = genruntime.CloneSliceOfString(source.DnsServers)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineNetworkInterfaceDnsSettingsConfiguration populates the provided destination VirtualMachineNetworkInterfaceDnsSettingsConfiguration from our VirtualMachineNetworkInterfaceDnsSettingsConfiguration
func (configuration *VirtualMachineNetworkInterfaceDnsSettingsConfiguration) AssignProperties_To_VirtualMachineNetworkInterfaceDnsSettingsConfiguration(destination *storage.VirtualMachineNetworkInterfaceDnsSettingsConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsServers
	destination.DnsServers = genruntime.CloneSliceOfString(configuration.DnsServers)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS populates our VirtualMachineNetworkInterfaceDnsSettingsConfiguration from the provided source VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS
func (configuration *VirtualMachineNetworkInterfaceDnsSettingsConfiguration) Initialize_From_VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS(source *VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS) error {

	// DnsServers
	configuration.DnsServers = genruntime.CloneSliceOfString(source.DnsServers)

	// No error
	return nil
}

// Describes a virtual machines network configuration's DNS settings.
type VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS struct {
	// DnsServers: List of DNS servers IP addresses
	DnsServers []string `json:"dnsServers,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS, got %T", armInput)
	}

	// Set property "DnsServers":
	for _, item := range typedInput.DnsServers {
		configuration.DnsServers = append(configuration.DnsServers, item)
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS populates our VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS from the provided source VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS
func (configuration *VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS) AssignProperties_From_VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS(source *storage.VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS) error {

	// DnsServers
	configuration.DnsServers = genruntime.CloneSliceOfString(source.DnsServers)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS populates the provided destination VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS from our VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS
func (configuration *VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS) AssignProperties_To_VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS(destination *storage.VirtualMachineNetworkInterfaceDnsSettingsConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsServers
	destination.DnsServers = genruntime.CloneSliceOfString(configuration.DnsServers)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes a virtual machine network profile's IP configuration.
type VirtualMachineNetworkInterfaceIPConfiguration struct {
	// ApplicationGatewayBackendAddressPools: Specifies an array of references to backend address pools of application
	// gateways. A virtual machine can reference backend address pools of multiple application gateways. Multiple virtual
	// machines cannot use the same application gateway.
	ApplicationGatewayBackendAddressPools []SubResource `json:"applicationGatewayBackendAddressPools,omitempty"`

	// ApplicationSecurityGroups: Specifies an array of references to application security group.
	ApplicationSecurityGroups []SubResource `json:"applicationSecurityGroups,omitempty"`

	// LoadBalancerBackendAddressPools: Specifies an array of references to backend address pools of load balancers. A virtual
	// machine can reference backend address pools of one public and one internal load balancer. [Multiple virtual machines
	// cannot use the same basic sku load balancer].
	LoadBalancerBackendAddressPools []SubResource `json:"loadBalancerBackendAddressPools,omitempty"`

	// +kubebuilder:validation:Required
	// Name: The IP configuration name.
	Name *string `json:"name,omitempty"`

	// Primary: Specifies the primary network interface in case the virtual machine has more than 1 network interface.
	Primary *bool `json:"primary,omitempty"`

	// PrivateIPAddressVersion: Available from Api-Version 2017-03-30 onwards, it represents whether the specific
	// ipconfiguration is IPv4 or IPv6. Default is taken as IPv4.  Possible values are: 'IPv4' and 'IPv6'.
	PrivateIPAddressVersion *VirtualMachineNetworkInterfaceIPConfigurationProperties_PrivateIPAddressVersion `json:"privateIPAddressVersion,omitempty"`

	// PublicIPAddressConfiguration: The publicIPAddressConfiguration.
	PublicIPAddressConfiguration *VirtualMachinePublicIPAddressConfiguration `json:"publicIPAddressConfiguration,omitempty"`

	// Subnet: Specifies the identifier of the subnet.
	Subnet *SubResource `json:"subnet,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineNetworkInterfaceIPConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *VirtualMachineNetworkInterfaceIPConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.VirtualMachineNetworkInterfaceIPConfiguration{}

	// Set property "Name":
	if configuration.Name != nil {
		name := *configuration.Name
		result.Name = &name
	}

	// Set property "Properties":
	if configuration.ApplicationGatewayBackendAddressPools != nil ||
		configuration.ApplicationSecurityGroups != nil ||
		configuration.LoadBalancerBackendAddressPools != nil ||
		configuration.Primary != nil ||
		configuration.PrivateIPAddressVersion != nil ||
		configuration.PublicIPAddressConfiguration != nil ||
		configuration.Subnet != nil {
		result.Properties = &arm.VirtualMachineNetworkInterfaceIPConfigurationProperties{}
	}
	for _, item := range configuration.ApplicationGatewayBackendAddressPools {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.ApplicationGatewayBackendAddressPools = append(result.Properties.ApplicationGatewayBackendAddressPools, *item_ARM.(*arm.SubResource))
	}
	for _, item := range configuration.ApplicationSecurityGroups {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.ApplicationSecurityGroups = append(result.Properties.ApplicationSecurityGroups, *item_ARM.(*arm.SubResource))
	}
	for _, item := range configuration.LoadBalancerBackendAddressPools {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.LoadBalancerBackendAddressPools = append(result.Properties.LoadBalancerBackendAddressPools, *item_ARM.(*arm.SubResource))
	}
	if configuration.Primary != nil {
		primary := *configuration.Primary
		result.Properties.Primary = &primary
	}
	if configuration.PrivateIPAddressVersion != nil {
		var temp string
		temp = string(*configuration.PrivateIPAddressVersion)
		privateIPAddressVersion := arm.VirtualMachineNetworkInterfaceIPConfigurationProperties_PrivateIPAddressVersion(temp)
		result.Properties.PrivateIPAddressVersion = &privateIPAddressVersion
	}
	if configuration.PublicIPAddressConfiguration != nil {
		publicIPAddressConfiguration_ARM, err := (*configuration.PublicIPAddressConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		publicIPAddressConfiguration := *publicIPAddressConfiguration_ARM.(*arm.VirtualMachinePublicIPAddressConfiguration)
		result.Properties.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	}
	if configuration.Subnet != nil {
		subnet_ARM, err := (*configuration.Subnet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		subnet := *subnet_ARM.(*arm.SubResource)
		result.Properties.Subnet = &subnet
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *VirtualMachineNetworkInterfaceIPConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineNetworkInterfaceIPConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *VirtualMachineNetworkInterfaceIPConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineNetworkInterfaceIPConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineNetworkInterfaceIPConfiguration, got %T", armInput)
	}

	// Set property "ApplicationGatewayBackendAddressPools":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationGatewayBackendAddressPools {
			var item1 SubResource
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.ApplicationGatewayBackendAddressPools = append(configuration.ApplicationGatewayBackendAddressPools, item1)
		}
	}

	// Set property "ApplicationSecurityGroups":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationSecurityGroups {
			var item1 SubResource
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.ApplicationSecurityGroups = append(configuration.ApplicationSecurityGroups, item1)
		}
	}

	// Set property "LoadBalancerBackendAddressPools":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancerBackendAddressPools {
			var item1 SubResource
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.LoadBalancerBackendAddressPools = append(configuration.LoadBalancerBackendAddressPools, item1)
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		configuration.Name = &name
	}

	// Set property "Primary":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			configuration.Primary = &primary
		}
	}

	// Set property "PrivateIPAddressVersion":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddressVersion != nil {
			var temp string
			temp = string(*typedInput.Properties.PrivateIPAddressVersion)
			privateIPAddressVersion := VirtualMachineNetworkInterfaceIPConfigurationProperties_PrivateIPAddressVersion(temp)
			configuration.PrivateIPAddressVersion = &privateIPAddressVersion
		}
	}

	// Set property "PublicIPAddressConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddressConfiguration != nil {
			var publicIPAddressConfiguration1 VirtualMachinePublicIPAddressConfiguration
			err := publicIPAddressConfiguration1.PopulateFromARM(owner, *typedInput.Properties.PublicIPAddressConfiguration)
			if err != nil {
				return err
			}
			publicIPAddressConfiguration := publicIPAddressConfiguration1
			configuration.PublicIPAddressConfiguration = &publicIPAddressConfiguration
		}
	}

	// Set property "Subnet":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Subnet != nil {
			var subnet1 SubResource
			err := subnet1.PopulateFromARM(owner, *typedInput.Properties.Subnet)
			if err != nil {
				return err
			}
			subnet := subnet1
			configuration.Subnet = &subnet
		}
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineNetworkInterfaceIPConfiguration populates our VirtualMachineNetworkInterfaceIPConfiguration from the provided source VirtualMachineNetworkInterfaceIPConfiguration
func (configuration *VirtualMachineNetworkInterfaceIPConfiguration) AssignProperties_From_VirtualMachineNetworkInterfaceIPConfiguration(source *storage.VirtualMachineNetworkInterfaceIPConfiguration) error {

	// ApplicationGatewayBackendAddressPools
	if source.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]SubResource, len(source.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range source.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var applicationGatewayBackendAddressPool SubResource
			err := applicationGatewayBackendAddressPool.AssignProperties_From_SubResource(&applicationGatewayBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field ApplicationGatewayBackendAddressPools")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		configuration.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		configuration.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if source.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]SubResource, len(source.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range source.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var applicationSecurityGroup SubResource
			err := applicationSecurityGroup.AssignProperties_From_SubResource(&applicationSecurityGroupItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field ApplicationSecurityGroups")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		configuration.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		configuration.ApplicationSecurityGroups = nil
	}

	// LoadBalancerBackendAddressPools
	if source.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]SubResource, len(source.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range source.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var loadBalancerBackendAddressPool SubResource
			err := loadBalancerBackendAddressPool.AssignProperties_From_SubResource(&loadBalancerBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field LoadBalancerBackendAddressPools")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		configuration.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		configuration.LoadBalancerBackendAddressPools = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		configuration.Primary = &primary
	} else {
		configuration.Primary = nil
	}

	// PrivateIPAddressVersion
	if source.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := *source.PrivateIPAddressVersion
		privateIPAddressVersionTemp := genruntime.ToEnum(privateIPAddressVersion, virtualMachineNetworkInterfaceIPConfigurationProperties_PrivateIPAddressVersion_Values)
		configuration.PrivateIPAddressVersion = &privateIPAddressVersionTemp
	} else {
		configuration.PrivateIPAddressVersion = nil
	}

	// PublicIPAddressConfiguration
	if source.PublicIPAddressConfiguration != nil {
		var publicIPAddressConfiguration VirtualMachinePublicIPAddressConfiguration
		err := publicIPAddressConfiguration.AssignProperties_From_VirtualMachinePublicIPAddressConfiguration(source.PublicIPAddressConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachinePublicIPAddressConfiguration() to populate field PublicIPAddressConfiguration")
		}
		configuration.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	} else {
		configuration.PublicIPAddressConfiguration = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet SubResource
		err := subnet.AssignProperties_From_SubResource(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field Subnet")
		}
		configuration.Subnet = &subnet
	} else {
		configuration.Subnet = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineNetworkInterfaceIPConfiguration populates the provided destination VirtualMachineNetworkInterfaceIPConfiguration from our VirtualMachineNetworkInterfaceIPConfiguration
func (configuration *VirtualMachineNetworkInterfaceIPConfiguration) AssignProperties_To_VirtualMachineNetworkInterfaceIPConfiguration(destination *storage.VirtualMachineNetworkInterfaceIPConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ApplicationGatewayBackendAddressPools
	if configuration.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]storage.SubResource, len(configuration.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range configuration.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var applicationGatewayBackendAddressPool storage.SubResource
			err := applicationGatewayBackendAddressPoolItem.AssignProperties_To_SubResource(&applicationGatewayBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field ApplicationGatewayBackendAddressPools")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		destination.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		destination.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if configuration.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]storage.SubResource, len(configuration.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range configuration.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var applicationSecurityGroup storage.SubResource
			err := applicationSecurityGroupItem.AssignProperties_To_SubResource(&applicationSecurityGroup)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field ApplicationSecurityGroups")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		destination.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		destination.ApplicationSecurityGroups = nil
	}

	// LoadBalancerBackendAddressPools
	if configuration.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]storage.SubResource, len(configuration.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range configuration.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var loadBalancerBackendAddressPool storage.SubResource
			err := loadBalancerBackendAddressPoolItem.AssignProperties_To_SubResource(&loadBalancerBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field LoadBalancerBackendAddressPools")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		destination.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		destination.LoadBalancerBackendAddressPools = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// Primary
	if configuration.Primary != nil {
		primary := *configuration.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// PrivateIPAddressVersion
	if configuration.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := string(*configuration.PrivateIPAddressVersion)
		destination.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		destination.PrivateIPAddressVersion = nil
	}

	// PublicIPAddressConfiguration
	if configuration.PublicIPAddressConfiguration != nil {
		var publicIPAddressConfiguration storage.VirtualMachinePublicIPAddressConfiguration
		err := configuration.PublicIPAddressConfiguration.AssignProperties_To_VirtualMachinePublicIPAddressConfiguration(&publicIPAddressConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachinePublicIPAddressConfiguration() to populate field PublicIPAddressConfiguration")
		}
		destination.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	} else {
		destination.PublicIPAddressConfiguration = nil
	}

	// Subnet
	if configuration.Subnet != nil {
		var subnet storage.SubResource
		err := configuration.Subnet.AssignProperties_To_SubResource(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualMachineNetworkInterfaceIPConfiguration_STATUS populates our VirtualMachineNetworkInterfaceIPConfiguration from the provided source VirtualMachineNetworkInterfaceIPConfiguration_STATUS
func (configuration *VirtualMachineNetworkInterfaceIPConfiguration) Initialize_From_VirtualMachineNetworkInterfaceIPConfiguration_STATUS(source *VirtualMachineNetworkInterfaceIPConfiguration_STATUS) error {

	// ApplicationGatewayBackendAddressPools
	if source.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]SubResource, len(source.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range source.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var applicationGatewayBackendAddressPool SubResource
			err := applicationGatewayBackendAddressPool.Initialize_From_SubResource_STATUS(&applicationGatewayBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_SubResource_STATUS() to populate field ApplicationGatewayBackendAddressPools")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		configuration.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		configuration.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if source.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]SubResource, len(source.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range source.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var applicationSecurityGroup SubResource
			err := applicationSecurityGroup.Initialize_From_SubResource_STATUS(&applicationSecurityGroupItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_SubResource_STATUS() to populate field ApplicationSecurityGroups")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		configuration.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		configuration.ApplicationSecurityGroups = nil
	}

	// LoadBalancerBackendAddressPools
	if source.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]SubResource, len(source.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range source.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var loadBalancerBackendAddressPool SubResource
			err := loadBalancerBackendAddressPool.Initialize_From_SubResource_STATUS(&loadBalancerBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_SubResource_STATUS() to populate field LoadBalancerBackendAddressPools")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		configuration.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		configuration.LoadBalancerBackendAddressPools = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		configuration.Primary = &primary
	} else {
		configuration.Primary = nil
	}

	// PrivateIPAddressVersion
	if source.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := genruntime.ToEnum(string(*source.PrivateIPAddressVersion), virtualMachineNetworkInterfaceIPConfigurationProperties_PrivateIPAddressVersion_Values)
		configuration.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		configuration.PrivateIPAddressVersion = nil
	}

	// PublicIPAddressConfiguration
	if source.PublicIPAddressConfiguration != nil {
		var publicIPAddressConfiguration VirtualMachinePublicIPAddressConfiguration
		err := publicIPAddressConfiguration.Initialize_From_VirtualMachinePublicIPAddressConfiguration_STATUS(source.PublicIPAddressConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_VirtualMachinePublicIPAddressConfiguration_STATUS() to populate field PublicIPAddressConfiguration")
		}
		configuration.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	} else {
		configuration.PublicIPAddressConfiguration = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet SubResource
		err := subnet.Initialize_From_SubResource_STATUS(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SubResource_STATUS() to populate field Subnet")
		}
		configuration.Subnet = &subnet
	} else {
		configuration.Subnet = nil
	}

	// No error
	return nil
}

// Describes a virtual machine network profile's IP configuration.
type VirtualMachineNetworkInterfaceIPConfiguration_STATUS struct {
	// ApplicationGatewayBackendAddressPools: Specifies an array of references to backend address pools of application
	// gateways. A virtual machine can reference backend address pools of multiple application gateways. Multiple virtual
	// machines cannot use the same application gateway.
	ApplicationGatewayBackendAddressPools []SubResource_STATUS `json:"applicationGatewayBackendAddressPools,omitempty"`

	// ApplicationSecurityGroups: Specifies an array of references to application security group.
	ApplicationSecurityGroups []SubResource_STATUS `json:"applicationSecurityGroups,omitempty"`

	// LoadBalancerBackendAddressPools: Specifies an array of references to backend address pools of load balancers. A virtual
	// machine can reference backend address pools of one public and one internal load balancer. [Multiple virtual machines
	// cannot use the same basic sku load balancer].
	LoadBalancerBackendAddressPools []SubResource_STATUS `json:"loadBalancerBackendAddressPools,omitempty"`

	// Name: The IP configuration name.
	Name *string `json:"name,omitempty"`

	// Primary: Specifies the primary network interface in case the virtual machine has more than 1 network interface.
	Primary *bool `json:"primary,omitempty"`

	// PrivateIPAddressVersion: Available from Api-Version 2017-03-30 onwards, it represents whether the specific
	// ipconfiguration is IPv4 or IPv6. Default is taken as IPv4.  Possible values are: 'IPv4' and 'IPv6'.
	PrivateIPAddressVersion *VirtualMachineNetworkInterfaceIPConfigurationProperties_PrivateIPAddressVersion_STATUS `json:"privateIPAddressVersion,omitempty"`

	// PublicIPAddressConfiguration: The publicIPAddressConfiguration.
	PublicIPAddressConfiguration *VirtualMachinePublicIPAddressConfiguration_STATUS `json:"publicIPAddressConfiguration,omitempty"`

	// Subnet: Specifies the identifier of the subnet.
	Subnet *SubResource_STATUS `json:"subnet,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineNetworkInterfaceIPConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *VirtualMachineNetworkInterfaceIPConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineNetworkInterfaceIPConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *VirtualMachineNetworkInterfaceIPConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineNetworkInterfaceIPConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineNetworkInterfaceIPConfiguration_STATUS, got %T", armInput)
	}

	// Set property "ApplicationGatewayBackendAddressPools":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationGatewayBackendAddressPools {
			var item1 SubResource_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.ApplicationGatewayBackendAddressPools = append(configuration.ApplicationGatewayBackendAddressPools, item1)
		}
	}

	// Set property "ApplicationSecurityGroups":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationSecurityGroups {
			var item1 SubResource_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.ApplicationSecurityGroups = append(configuration.ApplicationSecurityGroups, item1)
		}
	}

	// Set property "LoadBalancerBackendAddressPools":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancerBackendAddressPools {
			var item1 SubResource_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.LoadBalancerBackendAddressPools = append(configuration.LoadBalancerBackendAddressPools, item1)
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		configuration.Name = &name
	}

	// Set property "Primary":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			configuration.Primary = &primary
		}
	}

	// Set property "PrivateIPAddressVersion":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddressVersion != nil {
			var temp string
			temp = string(*typedInput.Properties.PrivateIPAddressVersion)
			privateIPAddressVersion := VirtualMachineNetworkInterfaceIPConfigurationProperties_PrivateIPAddressVersion_STATUS(temp)
			configuration.PrivateIPAddressVersion = &privateIPAddressVersion
		}
	}

	// Set property "PublicIPAddressConfiguration":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddressConfiguration != nil {
			var publicIPAddressConfiguration1 VirtualMachinePublicIPAddressConfiguration_STATUS
			err := publicIPAddressConfiguration1.PopulateFromARM(owner, *typedInput.Properties.PublicIPAddressConfiguration)
			if err != nil {
				return err
			}
			publicIPAddressConfiguration := publicIPAddressConfiguration1
			configuration.PublicIPAddressConfiguration = &publicIPAddressConfiguration
		}
	}

	// Set property "Subnet":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Subnet != nil {
			var subnet1 SubResource_STATUS
			err := subnet1.PopulateFromARM(owner, *typedInput.Properties.Subnet)
			if err != nil {
				return err
			}
			subnet := subnet1
			configuration.Subnet = &subnet
		}
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineNetworkInterfaceIPConfiguration_STATUS populates our VirtualMachineNetworkInterfaceIPConfiguration_STATUS from the provided source VirtualMachineNetworkInterfaceIPConfiguration_STATUS
func (configuration *VirtualMachineNetworkInterfaceIPConfiguration_STATUS) AssignProperties_From_VirtualMachineNetworkInterfaceIPConfiguration_STATUS(source *storage.VirtualMachineNetworkInterfaceIPConfiguration_STATUS) error {

	// ApplicationGatewayBackendAddressPools
	if source.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]SubResource_STATUS, len(source.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range source.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var applicationGatewayBackendAddressPool SubResource_STATUS
			err := applicationGatewayBackendAddressPool.AssignProperties_From_SubResource_STATUS(&applicationGatewayBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field ApplicationGatewayBackendAddressPools")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		configuration.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		configuration.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if source.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]SubResource_STATUS, len(source.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range source.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var applicationSecurityGroup SubResource_STATUS
			err := applicationSecurityGroup.AssignProperties_From_SubResource_STATUS(&applicationSecurityGroupItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field ApplicationSecurityGroups")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		configuration.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		configuration.ApplicationSecurityGroups = nil
	}

	// LoadBalancerBackendAddressPools
	if source.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]SubResource_STATUS, len(source.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range source.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var loadBalancerBackendAddressPool SubResource_STATUS
			err := loadBalancerBackendAddressPool.AssignProperties_From_SubResource_STATUS(&loadBalancerBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field LoadBalancerBackendAddressPools")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		configuration.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		configuration.LoadBalancerBackendAddressPools = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		configuration.Primary = &primary
	} else {
		configuration.Primary = nil
	}

	// PrivateIPAddressVersion
	if source.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := *source.PrivateIPAddressVersion
		privateIPAddressVersionTemp := genruntime.ToEnum(privateIPAddressVersion, virtualMachineNetworkInterfaceIPConfigurationProperties_PrivateIPAddressVersion_STATUS_Values)
		configuration.PrivateIPAddressVersion = &privateIPAddressVersionTemp
	} else {
		configuration.PrivateIPAddressVersion = nil
	}

	// PublicIPAddressConfiguration
	if source.PublicIPAddressConfiguration != nil {
		var publicIPAddressConfiguration VirtualMachinePublicIPAddressConfiguration_STATUS
		err := publicIPAddressConfiguration.AssignProperties_From_VirtualMachinePublicIPAddressConfiguration_STATUS(source.PublicIPAddressConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachinePublicIPAddressConfiguration_STATUS() to populate field PublicIPAddressConfiguration")
		}
		configuration.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	} else {
		configuration.PublicIPAddressConfiguration = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet SubResource_STATUS
		err := subnet.AssignProperties_From_SubResource_STATUS(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field Subnet")
		}
		configuration.Subnet = &subnet
	} else {
		configuration.Subnet = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineNetworkInterfaceIPConfiguration_STATUS populates the provided destination VirtualMachineNetworkInterfaceIPConfiguration_STATUS from our VirtualMachineNetworkInterfaceIPConfiguration_STATUS
func (configuration *VirtualMachineNetworkInterfaceIPConfiguration_STATUS) AssignProperties_To_VirtualMachineNetworkInterfaceIPConfiguration_STATUS(destination *storage.VirtualMachineNetworkInterfaceIPConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ApplicationGatewayBackendAddressPools
	if configuration.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]storage.SubResource_STATUS, len(configuration.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range configuration.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var applicationGatewayBackendAddressPool storage.SubResource_STATUS
			err := applicationGatewayBackendAddressPoolItem.AssignProperties_To_SubResource_STATUS(&applicationGatewayBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field ApplicationGatewayBackendAddressPools")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		destination.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		destination.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if configuration.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]storage.SubResource_STATUS, len(configuration.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range configuration.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var applicationSecurityGroup storage.SubResource_STATUS
			err := applicationSecurityGroupItem.AssignProperties_To_SubResource_STATUS(&applicationSecurityGroup)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field ApplicationSecurityGroups")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		destination.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		destination.ApplicationSecurityGroups = nil
	}

	// LoadBalancerBackendAddressPools
	if configuration.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]storage.SubResource_STATUS, len(configuration.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range configuration.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var loadBalancerBackendAddressPool storage.SubResource_STATUS
			err := loadBalancerBackendAddressPoolItem.AssignProperties_To_SubResource_STATUS(&loadBalancerBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field LoadBalancerBackendAddressPools")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		destination.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		destination.LoadBalancerBackendAddressPools = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// Primary
	if configuration.Primary != nil {
		primary := *configuration.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// PrivateIPAddressVersion
	if configuration.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := string(*configuration.PrivateIPAddressVersion)
		destination.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		destination.PrivateIPAddressVersion = nil
	}

	// PublicIPAddressConfiguration
	if configuration.PublicIPAddressConfiguration != nil {
		var publicIPAddressConfiguration storage.VirtualMachinePublicIPAddressConfiguration_STATUS
		err := configuration.PublicIPAddressConfiguration.AssignProperties_To_VirtualMachinePublicIPAddressConfiguration_STATUS(&publicIPAddressConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachinePublicIPAddressConfiguration_STATUS() to populate field PublicIPAddressConfiguration")
		}
		destination.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	} else {
		destination.PublicIPAddressConfiguration = nil
	}

	// Subnet
	if configuration.Subnet != nil {
		var subnet storage.SubResource_STATUS
		err := configuration.Subnet.AssignProperties_To_SubResource_STATUS(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes Windows Remote Management configuration of the VM
type WinRMConfiguration struct {
	// Listeners: The list of Windows Remote Management listeners
	Listeners []WinRMListener `json:"listeners,omitempty"`
}

var _ genruntime.ARMTransformer = &WinRMConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *WinRMConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.WinRMConfiguration{}

	// Set property "Listeners":
	for _, item := range configuration.Listeners {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Listeners = append(result.Listeners, *item_ARM.(*arm.WinRMListener))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *WinRMConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WinRMConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *WinRMConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WinRMConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WinRMConfiguration, got %T", armInput)
	}

	// Set property "Listeners":
	for _, item := range typedInput.Listeners {
		var item1 WinRMListener
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		configuration.Listeners = append(configuration.Listeners, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_WinRMConfiguration populates our WinRMConfiguration from the provided source WinRMConfiguration
func (configuration *WinRMConfiguration) AssignProperties_From_WinRMConfiguration(source *storage.WinRMConfiguration) error {

	// Listeners
	if source.Listeners != nil {
		listenerList := make([]WinRMListener, len(source.Listeners))
		for listenerIndex, listenerItem := range source.Listeners {
			// Shadow the loop variable to avoid aliasing
			listenerItem := listenerItem
			var listener WinRMListener
			err := listener.AssignProperties_From_WinRMListener(&listenerItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_WinRMListener() to populate field Listeners")
			}
			listenerList[listenerIndex] = listener
		}
		configuration.Listeners = listenerList
	} else {
		configuration.Listeners = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WinRMConfiguration populates the provided destination WinRMConfiguration from our WinRMConfiguration
func (configuration *WinRMConfiguration) AssignProperties_To_WinRMConfiguration(destination *storage.WinRMConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Listeners
	if configuration.Listeners != nil {
		listenerList := make([]storage.WinRMListener, len(configuration.Listeners))
		for listenerIndex, listenerItem := range configuration.Listeners {
			// Shadow the loop variable to avoid aliasing
			listenerItem := listenerItem
			var listener storage.WinRMListener
			err := listenerItem.AssignProperties_To_WinRMListener(&listener)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_WinRMListener() to populate field Listeners")
			}
			listenerList[listenerIndex] = listener
		}
		destination.Listeners = listenerList
	} else {
		destination.Listeners = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_WinRMConfiguration_STATUS populates our WinRMConfiguration from the provided source WinRMConfiguration_STATUS
func (configuration *WinRMConfiguration) Initialize_From_WinRMConfiguration_STATUS(source *WinRMConfiguration_STATUS) error {

	// Listeners
	if source.Listeners != nil {
		listenerList := make([]WinRMListener, len(source.Listeners))
		for listenerIndex, listenerItem := range source.Listeners {
			// Shadow the loop variable to avoid aliasing
			listenerItem := listenerItem
			var listener WinRMListener
			err := listener.Initialize_From_WinRMListener_STATUS(&listenerItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_WinRMListener_STATUS() to populate field Listeners")
			}
			listenerList[listenerIndex] = listener
		}
		configuration.Listeners = listenerList
	} else {
		configuration.Listeners = nil
	}

	// No error
	return nil
}

// Describes Windows Remote Management configuration of the VM
type WinRMConfiguration_STATUS struct {
	// Listeners: The list of Windows Remote Management listeners
	Listeners []WinRMListener_STATUS `json:"listeners,omitempty"`
}

var _ genruntime.FromARMConverter = &WinRMConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *WinRMConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WinRMConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *WinRMConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WinRMConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WinRMConfiguration_STATUS, got %T", armInput)
	}

	// Set property "Listeners":
	for _, item := range typedInput.Listeners {
		var item1 WinRMListener_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		configuration.Listeners = append(configuration.Listeners, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_WinRMConfiguration_STATUS populates our WinRMConfiguration_STATUS from the provided source WinRMConfiguration_STATUS
func (configuration *WinRMConfiguration_STATUS) AssignProperties_From_WinRMConfiguration_STATUS(source *storage.WinRMConfiguration_STATUS) error {

	// Listeners
	if source.Listeners != nil {
		listenerList := make([]WinRMListener_STATUS, len(source.Listeners))
		for listenerIndex, listenerItem := range source.Listeners {
			// Shadow the loop variable to avoid aliasing
			listenerItem := listenerItem
			var listener WinRMListener_STATUS
			err := listener.AssignProperties_From_WinRMListener_STATUS(&listenerItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_WinRMListener_STATUS() to populate field Listeners")
			}
			listenerList[listenerIndex] = listener
		}
		configuration.Listeners = listenerList
	} else {
		configuration.Listeners = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WinRMConfiguration_STATUS populates the provided destination WinRMConfiguration_STATUS from our WinRMConfiguration_STATUS
func (configuration *WinRMConfiguration_STATUS) AssignProperties_To_WinRMConfiguration_STATUS(destination *storage.WinRMConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Listeners
	if configuration.Listeners != nil {
		listenerList := make([]storage.WinRMListener_STATUS, len(configuration.Listeners))
		for listenerIndex, listenerItem := range configuration.Listeners {
			// Shadow the loop variable to avoid aliasing
			listenerItem := listenerItem
			var listener storage.WinRMListener_STATUS
			err := listenerItem.AssignProperties_To_WinRMListener_STATUS(&listener)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_WinRMListener_STATUS() to populate field Listeners")
			}
			listenerList[listenerIndex] = listener
		}
		destination.Listeners = listenerList
	} else {
		destination.Listeners = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Microsoft-Windows-Shell-Setup"}
type AdditionalUnattendContent_ComponentName string

const AdditionalUnattendContent_ComponentName_MicrosoftWindowsShellSetup = AdditionalUnattendContent_ComponentName("Microsoft-Windows-Shell-Setup")

// Mapping from string to AdditionalUnattendContent_ComponentName
var additionalUnattendContent_ComponentName_Values = map[string]AdditionalUnattendContent_ComponentName{
	"microsoft-windows-shell-setup": AdditionalUnattendContent_ComponentName_MicrosoftWindowsShellSetup,
}

type AdditionalUnattendContent_ComponentName_STATUS string

const AdditionalUnattendContent_ComponentName_STATUS_MicrosoftWindowsShellSetup = AdditionalUnattendContent_ComponentName_STATUS("Microsoft-Windows-Shell-Setup")

// Mapping from string to AdditionalUnattendContent_ComponentName_STATUS
var additionalUnattendContent_ComponentName_STATUS_Values = map[string]AdditionalUnattendContent_ComponentName_STATUS{
	"microsoft-windows-shell-setup": AdditionalUnattendContent_ComponentName_STATUS_MicrosoftWindowsShellSetup,
}

// +kubebuilder:validation:Enum={"OobeSystem"}
type AdditionalUnattendContent_PassName string

const AdditionalUnattendContent_PassName_OobeSystem = AdditionalUnattendContent_PassName("OobeSystem")

// Mapping from string to AdditionalUnattendContent_PassName
var additionalUnattendContent_PassName_Values = map[string]AdditionalUnattendContent_PassName{
	"oobesystem": AdditionalUnattendContent_PassName_OobeSystem,
}

type AdditionalUnattendContent_PassName_STATUS string

const AdditionalUnattendContent_PassName_STATUS_OobeSystem = AdditionalUnattendContent_PassName_STATUS("OobeSystem")

// Mapping from string to AdditionalUnattendContent_PassName_STATUS
var additionalUnattendContent_PassName_STATUS_Values = map[string]AdditionalUnattendContent_PassName_STATUS{
	"oobesystem": AdditionalUnattendContent_PassName_STATUS_OobeSystem,
}

// +kubebuilder:validation:Enum={"AutoLogon","FirstLogonCommands"}
type AdditionalUnattendContent_SettingName string

const (
	AdditionalUnattendContent_SettingName_AutoLogon          = AdditionalUnattendContent_SettingName("AutoLogon")
	AdditionalUnattendContent_SettingName_FirstLogonCommands = AdditionalUnattendContent_SettingName("FirstLogonCommands")
)

// Mapping from string to AdditionalUnattendContent_SettingName
var additionalUnattendContent_SettingName_Values = map[string]AdditionalUnattendContent_SettingName{
	"autologon":          AdditionalUnattendContent_SettingName_AutoLogon,
	"firstlogoncommands": AdditionalUnattendContent_SettingName_FirstLogonCommands,
}

type AdditionalUnattendContent_SettingName_STATUS string

const (
	AdditionalUnattendContent_SettingName_STATUS_AutoLogon          = AdditionalUnattendContent_SettingName_STATUS("AutoLogon")
	AdditionalUnattendContent_SettingName_STATUS_FirstLogonCommands = AdditionalUnattendContent_SettingName_STATUS("FirstLogonCommands")
)

// Mapping from string to AdditionalUnattendContent_SettingName_STATUS
var additionalUnattendContent_SettingName_STATUS_Values = map[string]AdditionalUnattendContent_SettingName_STATUS{
	"autologon":          AdditionalUnattendContent_SettingName_STATUS_AutoLogon,
	"firstlogoncommands": AdditionalUnattendContent_SettingName_STATUS_FirstLogonCommands,
}

// Api error.
type ApiError_STATUS struct {
	// Code: The error code.
	Code *string `json:"code,omitempty"`

	// Details: The Api error details
	Details []ApiErrorBase_STATUS `json:"details,omitempty"`

	// Innererror: The Api inner error
	Innererror *InnerError_STATUS `json:"innererror,omitempty"`

	// Message: The error message.
	Message *string `json:"message,omitempty"`

	// Target: The target of the particular error.
	Target *string `json:"target,omitempty"`
}

var _ genruntime.FromARMConverter = &ApiError_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (error *ApiError_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApiError_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (error *ApiError_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApiError_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApiError_STATUS, got %T", armInput)
	}

	// Set property "Code":
	if typedInput.Code != nil {
		code := *typedInput.Code
		error.Code = &code
	}

	// Set property "Details":
	for _, item := range typedInput.Details {
		var item1 ApiErrorBase_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		error.Details = append(error.Details, item1)
	}

	// Set property "Innererror":
	if typedInput.Innererror != nil {
		var innererror1 InnerError_STATUS
		err := innererror1.PopulateFromARM(owner, *typedInput.Innererror)
		if err != nil {
			return err
		}
		innererror := innererror1
		error.Innererror = &innererror
	}

	// Set property "Message":
	if typedInput.Message != nil {
		message := *typedInput.Message
		error.Message = &message
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		error.Target = &target
	}

	// No error
	return nil
}

// AssignProperties_From_ApiError_STATUS populates our ApiError_STATUS from the provided source ApiError_STATUS
func (error *ApiError_STATUS) AssignProperties_From_ApiError_STATUS(source *storage.ApiError_STATUS) error {

	// Code
	error.Code = genruntime.ClonePointerToString(source.Code)

	// Details
	if source.Details != nil {
		detailList := make([]ApiErrorBase_STATUS, len(source.Details))
		for detailIndex, detailItem := range source.Details {
			// Shadow the loop variable to avoid aliasing
			detailItem := detailItem
			var detail ApiErrorBase_STATUS
			err := detail.AssignProperties_From_ApiErrorBase_STATUS(&detailItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ApiErrorBase_STATUS() to populate field Details")
			}
			detailList[detailIndex] = detail
		}
		error.Details = detailList
	} else {
		error.Details = nil
	}

	// Innererror
	if source.Innererror != nil {
		var innererror InnerError_STATUS
		err := innererror.AssignProperties_From_InnerError_STATUS(source.Innererror)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_InnerError_STATUS() to populate field Innererror")
		}
		error.Innererror = &innererror
	} else {
		error.Innererror = nil
	}

	// Message
	error.Message = genruntime.ClonePointerToString(source.Message)

	// Target
	error.Target = genruntime.ClonePointerToString(source.Target)

	// No error
	return nil
}

// AssignProperties_To_ApiError_STATUS populates the provided destination ApiError_STATUS from our ApiError_STATUS
func (error *ApiError_STATUS) AssignProperties_To_ApiError_STATUS(destination *storage.ApiError_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Code
	destination.Code = genruntime.ClonePointerToString(error.Code)

	// Details
	if error.Details != nil {
		detailList := make([]storage.ApiErrorBase_STATUS, len(error.Details))
		for detailIndex, detailItem := range error.Details {
			// Shadow the loop variable to avoid aliasing
			detailItem := detailItem
			var detail storage.ApiErrorBase_STATUS
			err := detailItem.AssignProperties_To_ApiErrorBase_STATUS(&detail)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ApiErrorBase_STATUS() to populate field Details")
			}
			detailList[detailIndex] = detail
		}
		destination.Details = detailList
	} else {
		destination.Details = nil
	}

	// Innererror
	if error.Innererror != nil {
		var innererror storage.InnerError_STATUS
		err := error.Innererror.AssignProperties_To_InnerError_STATUS(&innererror)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_InnerError_STATUS() to populate field Innererror")
		}
		destination.Innererror = &innererror
	} else {
		destination.Innererror = nil
	}

	// Message
	destination.Message = genruntime.ClonePointerToString(error.Message)

	// Target
	destination.Target = genruntime.ClonePointerToString(error.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type AvailablePatchSummary_Status_STATUS string

const (
	AvailablePatchSummary_Status_STATUS_CompletedWithWarnings = AvailablePatchSummary_Status_STATUS("CompletedWithWarnings")
	AvailablePatchSummary_Status_STATUS_Failed                = AvailablePatchSummary_Status_STATUS("Failed")
	AvailablePatchSummary_Status_STATUS_InProgress            = AvailablePatchSummary_Status_STATUS("InProgress")
	AvailablePatchSummary_Status_STATUS_Succeeded             = AvailablePatchSummary_Status_STATUS("Succeeded")
	AvailablePatchSummary_Status_STATUS_Unknown               = AvailablePatchSummary_Status_STATUS("Unknown")
)

// Mapping from string to AvailablePatchSummary_Status_STATUS
var availablePatchSummary_Status_STATUS_Values = map[string]AvailablePatchSummary_Status_STATUS{
	"completedwithwarnings": AvailablePatchSummary_Status_STATUS_CompletedWithWarnings,
	"failed":                AvailablePatchSummary_Status_STATUS_Failed,
	"inprogress":            AvailablePatchSummary_Status_STATUS_InProgress,
	"succeeded":             AvailablePatchSummary_Status_STATUS_Succeeded,
	"unknown":               AvailablePatchSummary_Status_STATUS_Unknown,
}

// Specifies the ephemeral disk option for operating system disk.
// +kubebuilder:validation:Enum={"Local"}
type DiffDiskOption string

const DiffDiskOption_Local = DiffDiskOption("Local")

// Mapping from string to DiffDiskOption
var diffDiskOption_Values = map[string]DiffDiskOption{
	"local": DiffDiskOption_Local,
}

// Specifies the ephemeral disk option for operating system disk.
type DiffDiskOption_STATUS string

const DiffDiskOption_STATUS_Local = DiffDiskOption_STATUS("Local")

// Mapping from string to DiffDiskOption_STATUS
var diffDiskOption_STATUS_Values = map[string]DiffDiskOption_STATUS{
	"local": DiffDiskOption_STATUS_Local,
}

// Specifies the ephemeral disk placement for operating system disk. This property can be used by user in the request to
// choose the location i.e, cache disk or resource disk space for Ephemeral OS disk provisioning. For more information on
// Ephemeral OS disk size requirements, please refer Ephemeral OS disk size requirements for Windows VM at
// https://docs.microsoft.com/azure/virtual-machines/windows/ephemeral-os-disks#size-requirements and Linux VM at
// https://docs.microsoft.com/azure/virtual-machines/linux/ephemeral-os-disks#size-requirements
// +kubebuilder:validation:Enum={"CacheDisk","ResourceDisk"}
type DiffDiskPlacement string

const (
	DiffDiskPlacement_CacheDisk    = DiffDiskPlacement("CacheDisk")
	DiffDiskPlacement_ResourceDisk = DiffDiskPlacement("ResourceDisk")
)

// Mapping from string to DiffDiskPlacement
var diffDiskPlacement_Values = map[string]DiffDiskPlacement{
	"cachedisk":    DiffDiskPlacement_CacheDisk,
	"resourcedisk": DiffDiskPlacement_ResourceDisk,
}

// Specifies the ephemeral disk placement for operating system disk. This property can be used by user in the request to
// choose the location i.e, cache disk or resource disk space for Ephemeral OS disk provisioning. For more information on
// Ephemeral OS disk size requirements, please refer Ephemeral OS disk size requirements for Windows VM at
// https://docs.microsoft.com/azure/virtual-machines/windows/ephemeral-os-disks#size-requirements and Linux VM at
// https://docs.microsoft.com/azure/virtual-machines/linux/ephemeral-os-disks#size-requirements
type DiffDiskPlacement_STATUS string

const (
	DiffDiskPlacement_STATUS_CacheDisk    = DiffDiskPlacement_STATUS("CacheDisk")
	DiffDiskPlacement_STATUS_ResourceDisk = DiffDiskPlacement_STATUS("ResourceDisk")
)

// Mapping from string to DiffDiskPlacement_STATUS
var diffDiskPlacement_STATUS_Values = map[string]DiffDiskPlacement_STATUS{
	"cachedisk":    DiffDiskPlacement_STATUS_CacheDisk,
	"resourcedisk": DiffDiskPlacement_STATUS_ResourceDisk,
}

// Describes a reference to Key Vault Key
type KeyVaultKeyReference struct {
	// +kubebuilder:validation:Required
	// KeyUrl: The URL referencing a key encryption key in Key Vault.
	KeyUrl *string `json:"keyUrl,omitempty"`

	// +kubebuilder:validation:Required
	// SourceVault: The relative URL of the Key Vault containing the key.
	SourceVault *SubResource `json:"sourceVault,omitempty"`
}

var _ genruntime.ARMTransformer = &KeyVaultKeyReference{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (reference *KeyVaultKeyReference) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if reference == nil {
		return nil, nil
	}
	result := &arm.KeyVaultKeyReference{}

	// Set property "KeyUrl":
	if reference.KeyUrl != nil {
		keyUrl := *reference.KeyUrl
		result.KeyUrl = &keyUrl
	}

	// Set property "SourceVault":
	if reference.SourceVault != nil {
		sourceVault_ARM, err := (*reference.SourceVault).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sourceVault := *sourceVault_ARM.(*arm.SubResource)
		result.SourceVault = &sourceVault
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *KeyVaultKeyReference) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KeyVaultKeyReference{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *KeyVaultKeyReference) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KeyVaultKeyReference)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KeyVaultKeyReference, got %T", armInput)
	}

	// Set property "KeyUrl":
	if typedInput.KeyUrl != nil {
		keyUrl := *typedInput.KeyUrl
		reference.KeyUrl = &keyUrl
	}

	// Set property "SourceVault":
	if typedInput.SourceVault != nil {
		var sourceVault1 SubResource
		err := sourceVault1.PopulateFromARM(owner, *typedInput.SourceVault)
		if err != nil {
			return err
		}
		sourceVault := sourceVault1
		reference.SourceVault = &sourceVault
	}

	// No error
	return nil
}

// AssignProperties_From_KeyVaultKeyReference populates our KeyVaultKeyReference from the provided source KeyVaultKeyReference
func (reference *KeyVaultKeyReference) AssignProperties_From_KeyVaultKeyReference(source *storage.KeyVaultKeyReference) error {

	// KeyUrl
	reference.KeyUrl = genruntime.ClonePointerToString(source.KeyUrl)

	// SourceVault
	if source.SourceVault != nil {
		var sourceVault SubResource
		err := sourceVault.AssignProperties_From_SubResource(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SourceVault")
		}
		reference.SourceVault = &sourceVault
	} else {
		reference.SourceVault = nil
	}

	// No error
	return nil
}

// AssignProperties_To_KeyVaultKeyReference populates the provided destination KeyVaultKeyReference from our KeyVaultKeyReference
func (reference *KeyVaultKeyReference) AssignProperties_To_KeyVaultKeyReference(destination *storage.KeyVaultKeyReference) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyUrl
	destination.KeyUrl = genruntime.ClonePointerToString(reference.KeyUrl)

	// SourceVault
	if reference.SourceVault != nil {
		var sourceVault storage.SubResource
		err := reference.SourceVault.AssignProperties_To_SubResource(&sourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SourceVault")
		}
		destination.SourceVault = &sourceVault
	} else {
		destination.SourceVault = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_KeyVaultKeyReference_STATUS populates our KeyVaultKeyReference from the provided source KeyVaultKeyReference_STATUS
func (reference *KeyVaultKeyReference) Initialize_From_KeyVaultKeyReference_STATUS(source *KeyVaultKeyReference_STATUS) error {

	// KeyUrl
	reference.KeyUrl = genruntime.ClonePointerToString(source.KeyUrl)

	// SourceVault
	if source.SourceVault != nil {
		var sourceVault SubResource
		err := sourceVault.Initialize_From_SubResource_STATUS(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SubResource_STATUS() to populate field SourceVault")
		}
		reference.SourceVault = &sourceVault
	} else {
		reference.SourceVault = nil
	}

	// No error
	return nil
}

// Describes a reference to Key Vault Key
type KeyVaultKeyReference_STATUS struct {
	// KeyUrl: The URL referencing a key encryption key in Key Vault.
	KeyUrl *string `json:"keyUrl,omitempty"`

	// SourceVault: The relative URL of the Key Vault containing the key.
	SourceVault *SubResource_STATUS `json:"sourceVault,omitempty"`
}

var _ genruntime.FromARMConverter = &KeyVaultKeyReference_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *KeyVaultKeyReference_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KeyVaultKeyReference_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *KeyVaultKeyReference_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KeyVaultKeyReference_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KeyVaultKeyReference_STATUS, got %T", armInput)
	}

	// Set property "KeyUrl":
	if typedInput.KeyUrl != nil {
		keyUrl := *typedInput.KeyUrl
		reference.KeyUrl = &keyUrl
	}

	// Set property "SourceVault":
	if typedInput.SourceVault != nil {
		var sourceVault1 SubResource_STATUS
		err := sourceVault1.PopulateFromARM(owner, *typedInput.SourceVault)
		if err != nil {
			return err
		}
		sourceVault := sourceVault1
		reference.SourceVault = &sourceVault
	}

	// No error
	return nil
}

// AssignProperties_From_KeyVaultKeyReference_STATUS populates our KeyVaultKeyReference_STATUS from the provided source KeyVaultKeyReference_STATUS
func (reference *KeyVaultKeyReference_STATUS) AssignProperties_From_KeyVaultKeyReference_STATUS(source *storage.KeyVaultKeyReference_STATUS) error {

	// KeyUrl
	reference.KeyUrl = genruntime.ClonePointerToString(source.KeyUrl)

	// SourceVault
	if source.SourceVault != nil {
		var sourceVault SubResource_STATUS
		err := sourceVault.AssignProperties_From_SubResource_STATUS(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SourceVault")
		}
		reference.SourceVault = &sourceVault
	} else {
		reference.SourceVault = nil
	}

	// No error
	return nil
}

// AssignProperties_To_KeyVaultKeyReference_STATUS populates the provided destination KeyVaultKeyReference_STATUS from our KeyVaultKeyReference_STATUS
func (reference *KeyVaultKeyReference_STATUS) AssignProperties_To_KeyVaultKeyReference_STATUS(destination *storage.KeyVaultKeyReference_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyUrl
	destination.KeyUrl = genruntime.ClonePointerToString(reference.KeyUrl)

	// SourceVault
	if reference.SourceVault != nil {
		var sourceVault storage.SubResource_STATUS
		err := reference.SourceVault.AssignProperties_To_SubResource_STATUS(&sourceVault)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SourceVault")
		}
		destination.SourceVault = &sourceVault
	} else {
		destination.SourceVault = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type LastPatchInstallationSummary_Status_STATUS string

const (
	LastPatchInstallationSummary_Status_STATUS_CompletedWithWarnings = LastPatchInstallationSummary_Status_STATUS("CompletedWithWarnings")
	LastPatchInstallationSummary_Status_STATUS_Failed                = LastPatchInstallationSummary_Status_STATUS("Failed")
	LastPatchInstallationSummary_Status_STATUS_InProgress            = LastPatchInstallationSummary_Status_STATUS("InProgress")
	LastPatchInstallationSummary_Status_STATUS_Succeeded             = LastPatchInstallationSummary_Status_STATUS("Succeeded")
	LastPatchInstallationSummary_Status_STATUS_Unknown               = LastPatchInstallationSummary_Status_STATUS("Unknown")
)

// Mapping from string to LastPatchInstallationSummary_Status_STATUS
var lastPatchInstallationSummary_Status_STATUS_Values = map[string]LastPatchInstallationSummary_Status_STATUS{
	"completedwithwarnings": LastPatchInstallationSummary_Status_STATUS_CompletedWithWarnings,
	"failed":                LastPatchInstallationSummary_Status_STATUS_Failed,
	"inprogress":            LastPatchInstallationSummary_Status_STATUS_InProgress,
	"succeeded":             LastPatchInstallationSummary_Status_STATUS_Succeeded,
	"unknown":               LastPatchInstallationSummary_Status_STATUS_Unknown,
}

// +kubebuilder:validation:Enum={"AutomaticByPlatform","ImageDefault"}
type LinuxPatchSettings_AssessmentMode string

const (
	LinuxPatchSettings_AssessmentMode_AutomaticByPlatform = LinuxPatchSettings_AssessmentMode("AutomaticByPlatform")
	LinuxPatchSettings_AssessmentMode_ImageDefault        = LinuxPatchSettings_AssessmentMode("ImageDefault")
)

// Mapping from string to LinuxPatchSettings_AssessmentMode
var linuxPatchSettings_AssessmentMode_Values = map[string]LinuxPatchSettings_AssessmentMode{
	"automaticbyplatform": LinuxPatchSettings_AssessmentMode_AutomaticByPlatform,
	"imagedefault":        LinuxPatchSettings_AssessmentMode_ImageDefault,
}

type LinuxPatchSettings_AssessmentMode_STATUS string

const (
	LinuxPatchSettings_AssessmentMode_STATUS_AutomaticByPlatform = LinuxPatchSettings_AssessmentMode_STATUS("AutomaticByPlatform")
	LinuxPatchSettings_AssessmentMode_STATUS_ImageDefault        = LinuxPatchSettings_AssessmentMode_STATUS("ImageDefault")
)

// Mapping from string to LinuxPatchSettings_AssessmentMode_STATUS
var linuxPatchSettings_AssessmentMode_STATUS_Values = map[string]LinuxPatchSettings_AssessmentMode_STATUS{
	"automaticbyplatform": LinuxPatchSettings_AssessmentMode_STATUS_AutomaticByPlatform,
	"imagedefault":        LinuxPatchSettings_AssessmentMode_STATUS_ImageDefault,
}

// +kubebuilder:validation:Enum={"AutomaticByPlatform","ImageDefault"}
type LinuxPatchSettings_PatchMode string

const (
	LinuxPatchSettings_PatchMode_AutomaticByPlatform = LinuxPatchSettings_PatchMode("AutomaticByPlatform")
	LinuxPatchSettings_PatchMode_ImageDefault        = LinuxPatchSettings_PatchMode("ImageDefault")
)

// Mapping from string to LinuxPatchSettings_PatchMode
var linuxPatchSettings_PatchMode_Values = map[string]LinuxPatchSettings_PatchMode{
	"automaticbyplatform": LinuxPatchSettings_PatchMode_AutomaticByPlatform,
	"imagedefault":        LinuxPatchSettings_PatchMode_ImageDefault,
}

type LinuxPatchSettings_PatchMode_STATUS string

const (
	LinuxPatchSettings_PatchMode_STATUS_AutomaticByPlatform = LinuxPatchSettings_PatchMode_STATUS("AutomaticByPlatform")
	LinuxPatchSettings_PatchMode_STATUS_ImageDefault        = LinuxPatchSettings_PatchMode_STATUS("ImageDefault")
)

// Mapping from string to LinuxPatchSettings_PatchMode_STATUS
var linuxPatchSettings_PatchMode_STATUS_Values = map[string]LinuxPatchSettings_PatchMode_STATUS{
	"automaticbyplatform": LinuxPatchSettings_PatchMode_STATUS_AutomaticByPlatform,
	"imagedefault":        LinuxPatchSettings_PatchMode_STATUS_ImageDefault,
}

// Specifies additional settings to be applied when patch mode AutomaticByPlatform is selected in Linux patch settings.
type LinuxVMGuestPatchAutomaticByPlatformSettings struct {
	// RebootSetting: Specifies the reboot setting for all AutomaticByPlatform patch installation operations.
	RebootSetting *LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting `json:"rebootSetting,omitempty"`
}

var _ genruntime.ARMTransformer = &LinuxVMGuestPatchAutomaticByPlatformSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *LinuxVMGuestPatchAutomaticByPlatformSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.LinuxVMGuestPatchAutomaticByPlatformSettings{}

	// Set property "RebootSetting":
	if settings.RebootSetting != nil {
		var temp string
		temp = string(*settings.RebootSetting)
		rebootSetting := arm.LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting(temp)
		result.RebootSetting = &rebootSetting
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *LinuxVMGuestPatchAutomaticByPlatformSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.LinuxVMGuestPatchAutomaticByPlatformSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *LinuxVMGuestPatchAutomaticByPlatformSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.LinuxVMGuestPatchAutomaticByPlatformSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.LinuxVMGuestPatchAutomaticByPlatformSettings, got %T", armInput)
	}

	// Set property "RebootSetting":
	if typedInput.RebootSetting != nil {
		var temp string
		temp = string(*typedInput.RebootSetting)
		rebootSetting := LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting(temp)
		settings.RebootSetting = &rebootSetting
	}

	// No error
	return nil
}

// AssignProperties_From_LinuxVMGuestPatchAutomaticByPlatformSettings populates our LinuxVMGuestPatchAutomaticByPlatformSettings from the provided source LinuxVMGuestPatchAutomaticByPlatformSettings
func (settings *LinuxVMGuestPatchAutomaticByPlatformSettings) AssignProperties_From_LinuxVMGuestPatchAutomaticByPlatformSettings(source *storage.LinuxVMGuestPatchAutomaticByPlatformSettings) error {

	// RebootSetting
	if source.RebootSetting != nil {
		rebootSetting := *source.RebootSetting
		rebootSettingTemp := genruntime.ToEnum(rebootSetting, linuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting_Values)
		settings.RebootSetting = &rebootSettingTemp
	} else {
		settings.RebootSetting = nil
	}

	// No error
	return nil
}

// AssignProperties_To_LinuxVMGuestPatchAutomaticByPlatformSettings populates the provided destination LinuxVMGuestPatchAutomaticByPlatformSettings from our LinuxVMGuestPatchAutomaticByPlatformSettings
func (settings *LinuxVMGuestPatchAutomaticByPlatformSettings) AssignProperties_To_LinuxVMGuestPatchAutomaticByPlatformSettings(destination *storage.LinuxVMGuestPatchAutomaticByPlatformSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RebootSetting
	if settings.RebootSetting != nil {
		rebootSetting := string(*settings.RebootSetting)
		destination.RebootSetting = &rebootSetting
	} else {
		destination.RebootSetting = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS populates our LinuxVMGuestPatchAutomaticByPlatformSettings from the provided source LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS
func (settings *LinuxVMGuestPatchAutomaticByPlatformSettings) Initialize_From_LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS(source *LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS) error {

	// RebootSetting
	if source.RebootSetting != nil {
		rebootSetting := genruntime.ToEnum(string(*source.RebootSetting), linuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting_Values)
		settings.RebootSetting = &rebootSetting
	} else {
		settings.RebootSetting = nil
	}

	// No error
	return nil
}

// Specifies additional settings to be applied when patch mode AutomaticByPlatform is selected in Linux patch settings.
type LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS struct {
	// RebootSetting: Specifies the reboot setting for all AutomaticByPlatform patch installation operations.
	RebootSetting *LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS `json:"rebootSetting,omitempty"`
}

var _ genruntime.FromARMConverter = &LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS, got %T", armInput)
	}

	// Set property "RebootSetting":
	if typedInput.RebootSetting != nil {
		var temp string
		temp = string(*typedInput.RebootSetting)
		rebootSetting := LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS(temp)
		settings.RebootSetting = &rebootSetting
	}

	// No error
	return nil
}

// AssignProperties_From_LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS populates our LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS from the provided source LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS
func (settings *LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS) AssignProperties_From_LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS(source *storage.LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS) error {

	// RebootSetting
	if source.RebootSetting != nil {
		rebootSetting := *source.RebootSetting
		rebootSettingTemp := genruntime.ToEnum(rebootSetting, linuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS_Values)
		settings.RebootSetting = &rebootSettingTemp
	} else {
		settings.RebootSetting = nil
	}

	// No error
	return nil
}

// AssignProperties_To_LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS populates the provided destination LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS from our LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS
func (settings *LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS) AssignProperties_To_LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS(destination *storage.LinuxVMGuestPatchAutomaticByPlatformSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RebootSetting
	if settings.RebootSetting != nil {
		rebootSetting := string(*settings.RebootSetting)
		destination.RebootSetting = &rebootSetting
	} else {
		destination.RebootSetting = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"AutomaticByPlatform","ImageDefault"}
type PatchSettings_AssessmentMode string

const (
	PatchSettings_AssessmentMode_AutomaticByPlatform = PatchSettings_AssessmentMode("AutomaticByPlatform")
	PatchSettings_AssessmentMode_ImageDefault        = PatchSettings_AssessmentMode("ImageDefault")
)

// Mapping from string to PatchSettings_AssessmentMode
var patchSettings_AssessmentMode_Values = map[string]PatchSettings_AssessmentMode{
	"automaticbyplatform": PatchSettings_AssessmentMode_AutomaticByPlatform,
	"imagedefault":        PatchSettings_AssessmentMode_ImageDefault,
}

type PatchSettings_AssessmentMode_STATUS string

const (
	PatchSettings_AssessmentMode_STATUS_AutomaticByPlatform = PatchSettings_AssessmentMode_STATUS("AutomaticByPlatform")
	PatchSettings_AssessmentMode_STATUS_ImageDefault        = PatchSettings_AssessmentMode_STATUS("ImageDefault")
)

// Mapping from string to PatchSettings_AssessmentMode_STATUS
var patchSettings_AssessmentMode_STATUS_Values = map[string]PatchSettings_AssessmentMode_STATUS{
	"automaticbyplatform": PatchSettings_AssessmentMode_STATUS_AutomaticByPlatform,
	"imagedefault":        PatchSettings_AssessmentMode_STATUS_ImageDefault,
}

// +kubebuilder:validation:Enum={"AutomaticByOS","AutomaticByPlatform","Manual"}
type PatchSettings_PatchMode string

const (
	PatchSettings_PatchMode_AutomaticByOS       = PatchSettings_PatchMode("AutomaticByOS")
	PatchSettings_PatchMode_AutomaticByPlatform = PatchSettings_PatchMode("AutomaticByPlatform")
	PatchSettings_PatchMode_Manual              = PatchSettings_PatchMode("Manual")
)

// Mapping from string to PatchSettings_PatchMode
var patchSettings_PatchMode_Values = map[string]PatchSettings_PatchMode{
	"automaticbyos":       PatchSettings_PatchMode_AutomaticByOS,
	"automaticbyplatform": PatchSettings_PatchMode_AutomaticByPlatform,
	"manual":              PatchSettings_PatchMode_Manual,
}

type PatchSettings_PatchMode_STATUS string

const (
	PatchSettings_PatchMode_STATUS_AutomaticByOS       = PatchSettings_PatchMode_STATUS("AutomaticByOS")
	PatchSettings_PatchMode_STATUS_AutomaticByPlatform = PatchSettings_PatchMode_STATUS("AutomaticByPlatform")
	PatchSettings_PatchMode_STATUS_Manual              = PatchSettings_PatchMode_STATUS("Manual")
)

// Mapping from string to PatchSettings_PatchMode_STATUS
var patchSettings_PatchMode_STATUS_Values = map[string]PatchSettings_PatchMode_STATUS{
	"automaticbyos":       PatchSettings_PatchMode_STATUS_AutomaticByOS,
	"automaticbyplatform": PatchSettings_PatchMode_STATUS_AutomaticByPlatform,
	"manual":              PatchSettings_PatchMode_STATUS_Manual,
}

// Contains information about SSH certificate public key and the path on the Linux VM where the public key is placed.
type SshPublicKey_STATUS struct {
	// KeyData: SSH public key certificate used to authenticate with the VM through ssh. The key needs to be at least 2048-bit
	// and in ssh-rsa format.
	// For creating ssh keys, see [Create SSH keys on Linux and Mac for Linux VMs in
	// Azure]https://docs.microsoft.com/azure/virtual-machines/linux/create-ssh-keys-detailed).
	KeyData *string `json:"keyData,omitempty"`

	// Path: Specifies the full path on the created VM where ssh public key is stored. If the file already exists, the
	// specified key is appended to the file. Example: /home/user/.ssh/authorized_keys
	Path *string `json:"path,omitempty"`
}

var _ genruntime.FromARMConverter = &SshPublicKey_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (publicKey *SshPublicKey_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SshPublicKey_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (publicKey *SshPublicKey_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SshPublicKey_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SshPublicKey_STATUS, got %T", armInput)
	}

	// Set property "KeyData":
	if typedInput.KeyData != nil {
		keyData := *typedInput.KeyData
		publicKey.KeyData = &keyData
	}

	// Set property "Path":
	if typedInput.Path != nil {
		path := *typedInput.Path
		publicKey.Path = &path
	}

	// No error
	return nil
}

// AssignProperties_From_SshPublicKey_STATUS populates our SshPublicKey_STATUS from the provided source SshPublicKey_STATUS
func (publicKey *SshPublicKey_STATUS) AssignProperties_From_SshPublicKey_STATUS(source *storage.SshPublicKey_STATUS) error {

	// KeyData
	publicKey.KeyData = genruntime.ClonePointerToString(source.KeyData)

	// Path
	publicKey.Path = genruntime.ClonePointerToString(source.Path)

	// No error
	return nil
}

// AssignProperties_To_SshPublicKey_STATUS populates the provided destination SshPublicKey_STATUS from our SshPublicKey_STATUS
func (publicKey *SshPublicKey_STATUS) AssignProperties_To_SshPublicKey_STATUS(destination *storage.SshPublicKey_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyData
	destination.KeyData = genruntime.ClonePointerToString(publicKey.KeyData)

	// Path
	destination.Path = genruntime.ClonePointerToString(publicKey.Path)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Contains information about SSH certificate public key and the path on the Linux VM where the public key is placed.
type SshPublicKeySpec struct {
	// KeyData: SSH public key certificate used to authenticate with the VM through ssh. The key needs to be at least 2048-bit
	// and in ssh-rsa format.
	// For creating ssh keys, see [Create SSH keys on Linux and Mac for Linux VMs in
	// Azure]https://docs.microsoft.com/azure/virtual-machines/linux/create-ssh-keys-detailed).
	KeyData *string `json:"keyData,omitempty"`

	// Path: Specifies the full path on the created VM where ssh public key is stored. If the file already exists, the
	// specified key is appended to the file. Example: /home/user/.ssh/authorized_keys
	Path *string `json:"path,omitempty"`
}

var _ genruntime.ARMTransformer = &SshPublicKeySpec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (publicKey *SshPublicKeySpec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if publicKey == nil {
		return nil, nil
	}
	result := &arm.SshPublicKeySpec{}

	// Set property "KeyData":
	if publicKey.KeyData != nil {
		keyData := *publicKey.KeyData
		result.KeyData = &keyData
	}

	// Set property "Path":
	if publicKey.Path != nil {
		path := *publicKey.Path
		result.Path = &path
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (publicKey *SshPublicKeySpec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SshPublicKeySpec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (publicKey *SshPublicKeySpec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SshPublicKeySpec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SshPublicKeySpec, got %T", armInput)
	}

	// Set property "KeyData":
	if typedInput.KeyData != nil {
		keyData := *typedInput.KeyData
		publicKey.KeyData = &keyData
	}

	// Set property "Path":
	if typedInput.Path != nil {
		path := *typedInput.Path
		publicKey.Path = &path
	}

	// No error
	return nil
}

// AssignProperties_From_SshPublicKeySpec populates our SshPublicKeySpec from the provided source SshPublicKeySpec
func (publicKey *SshPublicKeySpec) AssignProperties_From_SshPublicKeySpec(source *storage.SshPublicKeySpec) error {

	// KeyData
	publicKey.KeyData = genruntime.ClonePointerToString(source.KeyData)

	// Path
	publicKey.Path = genruntime.ClonePointerToString(source.Path)

	// No error
	return nil
}

// AssignProperties_To_SshPublicKeySpec populates the provided destination SshPublicKeySpec from our SshPublicKeySpec
func (publicKey *SshPublicKeySpec) AssignProperties_To_SshPublicKeySpec(destination *storage.SshPublicKeySpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyData
	destination.KeyData = genruntime.ClonePointerToString(publicKey.KeyData)

	// Path
	destination.Path = genruntime.ClonePointerToString(publicKey.Path)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_SshPublicKey_STATUS populates our SshPublicKeySpec from the provided source SshPublicKey_STATUS
func (publicKey *SshPublicKeySpec) Initialize_From_SshPublicKey_STATUS(source *SshPublicKey_STATUS) error {

	// KeyData
	publicKey.KeyData = genruntime.ClonePointerToString(source.KeyData)

	// Path
	publicKey.Path = genruntime.ClonePointerToString(source.Path)

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"IPv4","IPv6"}
type VirtualMachineNetworkInterfaceIPConfigurationProperties_PrivateIPAddressVersion string

const (
	VirtualMachineNetworkInterfaceIPConfigurationProperties_PrivateIPAddressVersion_IPv4 = VirtualMachineNetworkInterfaceIPConfigurationProperties_PrivateIPAddressVersion("IPv4")
	VirtualMachineNetworkInterfaceIPConfigurationProperties_PrivateIPAddressVersion_IPv6 = VirtualMachineNetworkInterfaceIPConfigurationProperties_PrivateIPAddressVersion("IPv6")
)

// Mapping from string to VirtualMachineNetworkInterfaceIPConfigurationProperties_PrivateIPAddressVersion
var virtualMachineNetworkInterfaceIPConfigurationProperties_PrivateIPAddressVersion_Values = map[string]VirtualMachineNetworkInterfaceIPConfigurationProperties_PrivateIPAddressVersion{
	"ipv4": VirtualMachineNetworkInterfaceIPConfigurationProperties_PrivateIPAddressVersion_IPv4,
	"ipv6": VirtualMachineNetworkInterfaceIPConfigurationProperties_PrivateIPAddressVersion_IPv6,
}

type VirtualMachineNetworkInterfaceIPConfigurationProperties_PrivateIPAddressVersion_STATUS string

const (
	VirtualMachineNetworkInterfaceIPConfigurationProperties_PrivateIPAddressVersion_STATUS_IPv4 = VirtualMachineNetworkInterfaceIPConfigurationProperties_PrivateIPAddressVersion_STATUS("IPv4")
	VirtualMachineNetworkInterfaceIPConfigurationProperties_PrivateIPAddressVersion_STATUS_IPv6 = VirtualMachineNetworkInterfaceIPConfigurationProperties_PrivateIPAddressVersion_STATUS("IPv6")
)

// Mapping from string to VirtualMachineNetworkInterfaceIPConfigurationProperties_PrivateIPAddressVersion_STATUS
var virtualMachineNetworkInterfaceIPConfigurationProperties_PrivateIPAddressVersion_STATUS_Values = map[string]VirtualMachineNetworkInterfaceIPConfigurationProperties_PrivateIPAddressVersion_STATUS{
	"ipv4": VirtualMachineNetworkInterfaceIPConfigurationProperties_PrivateIPAddressVersion_STATUS_IPv4,
	"ipv6": VirtualMachineNetworkInterfaceIPConfigurationProperties_PrivateIPAddressVersion_STATUS_IPv6,
}

// Describes a virtual machines IP Configuration's PublicIPAddress configuration
type VirtualMachinePublicIPAddressConfiguration struct {
	// DeleteOption: Specify what happens to the public IP address when the VM is deleted
	DeleteOption *VirtualMachinePublicIPAddressConfigurationProperties_DeleteOption `json:"deleteOption,omitempty"`

	// DnsSettings: The dns settings to be applied on the publicIP addresses .
	DnsSettings *VirtualMachinePublicIPAddressDnsSettingsConfiguration `json:"dnsSettings,omitempty"`

	// IdleTimeoutInMinutes: The idle timeout of the public IP address.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	// IpTags: The list of IP tags associated with the public IP address.
	IpTags []VirtualMachineIpTag `json:"ipTags,omitempty"`

	// +kubebuilder:validation:Required
	// Name: The publicIP address configuration name.
	Name *string `json:"name,omitempty"`

	// PublicIPAddressVersion: Available from Api-Version 2019-07-01 onwards, it represents whether the specific
	// ipconfiguration is IPv4 or IPv6. Default is taken as IPv4. Possible values are: 'IPv4' and 'IPv6'.
	PublicIPAddressVersion *VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAddressVersion `json:"publicIPAddressVersion,omitempty"`

	// PublicIPAllocationMethod: Specify the public IP allocation type
	PublicIPAllocationMethod *VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAllocationMethod `json:"publicIPAllocationMethod,omitempty"`

	// PublicIPPrefix: The PublicIPPrefix from which to allocate publicIP addresses.
	PublicIPPrefix *SubResource `json:"publicIPPrefix,omitempty"`

	// Sku: Describes the public IP Sku. It can only be set with OrchestrationMode as Flexible.
	Sku *PublicIPAddressSku `json:"sku,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachinePublicIPAddressConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *VirtualMachinePublicIPAddressConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.VirtualMachinePublicIPAddressConfiguration{}

	// Set property "Name":
	if configuration.Name != nil {
		name := *configuration.Name
		result.Name = &name
	}

	// Set property "Properties":
	if configuration.DeleteOption != nil ||
		configuration.DnsSettings != nil ||
		configuration.IdleTimeoutInMinutes != nil ||
		configuration.IpTags != nil ||
		configuration.PublicIPAddressVersion != nil ||
		configuration.PublicIPAllocationMethod != nil ||
		configuration.PublicIPPrefix != nil {
		result.Properties = &arm.VirtualMachinePublicIPAddressConfigurationProperties{}
	}
	if configuration.DeleteOption != nil {
		var temp string
		temp = string(*configuration.DeleteOption)
		deleteOption := arm.VirtualMachinePublicIPAddressConfigurationProperties_DeleteOption(temp)
		result.Properties.DeleteOption = &deleteOption
	}
	if configuration.DnsSettings != nil {
		dnsSettings_ARM, err := (*configuration.DnsSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dnsSettings := *dnsSettings_ARM.(*arm.VirtualMachinePublicIPAddressDnsSettingsConfiguration)
		result.Properties.DnsSettings = &dnsSettings
	}
	if configuration.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinutes := *configuration.IdleTimeoutInMinutes
		result.Properties.IdleTimeoutInMinutes = &idleTimeoutInMinutes
	}
	for _, item := range configuration.IpTags {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.IpTags = append(result.Properties.IpTags, *item_ARM.(*arm.VirtualMachineIpTag))
	}
	if configuration.PublicIPAddressVersion != nil {
		var temp string
		temp = string(*configuration.PublicIPAddressVersion)
		publicIPAddressVersion := arm.VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAddressVersion(temp)
		result.Properties.PublicIPAddressVersion = &publicIPAddressVersion
	}
	if configuration.PublicIPAllocationMethod != nil {
		var temp string
		temp = string(*configuration.PublicIPAllocationMethod)
		publicIPAllocationMethod := arm.VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAllocationMethod(temp)
		result.Properties.PublicIPAllocationMethod = &publicIPAllocationMethod
	}
	if configuration.PublicIPPrefix != nil {
		publicIPPrefix_ARM, err := (*configuration.PublicIPPrefix).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		publicIPPrefix := *publicIPPrefix_ARM.(*arm.SubResource)
		result.Properties.PublicIPPrefix = &publicIPPrefix
	}

	// Set property "Sku":
	if configuration.Sku != nil {
		sku_ARM, err := (*configuration.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := *sku_ARM.(*arm.PublicIPAddressSku)
		result.Sku = &sku
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *VirtualMachinePublicIPAddressConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachinePublicIPAddressConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *VirtualMachinePublicIPAddressConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachinePublicIPAddressConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachinePublicIPAddressConfiguration, got %T", armInput)
	}

	// Set property "DeleteOption":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DeleteOption != nil {
			var temp string
			temp = string(*typedInput.Properties.DeleteOption)
			deleteOption := VirtualMachinePublicIPAddressConfigurationProperties_DeleteOption(temp)
			configuration.DeleteOption = &deleteOption
		}
	}

	// Set property "DnsSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsSettings != nil {
			var dnsSettings1 VirtualMachinePublicIPAddressDnsSettingsConfiguration
			err := dnsSettings1.PopulateFromARM(owner, *typedInput.Properties.DnsSettings)
			if err != nil {
				return err
			}
			dnsSettings := dnsSettings1
			configuration.DnsSettings = &dnsSettings
		}
	}

	// Set property "IdleTimeoutInMinutes":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			configuration.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property "IpTags":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpTags {
			var item1 VirtualMachineIpTag
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.IpTags = append(configuration.IpTags, item1)
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		configuration.Name = &name
	}

	// Set property "PublicIPAddressVersion":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddressVersion != nil {
			var temp string
			temp = string(*typedInput.Properties.PublicIPAddressVersion)
			publicIPAddressVersion := VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAddressVersion(temp)
			configuration.PublicIPAddressVersion = &publicIPAddressVersion
		}
	}

	// Set property "PublicIPAllocationMethod":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAllocationMethod != nil {
			var temp string
			temp = string(*typedInput.Properties.PublicIPAllocationMethod)
			publicIPAllocationMethod := VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAllocationMethod(temp)
			configuration.PublicIPAllocationMethod = &publicIPAllocationMethod
		}
	}

	// Set property "PublicIPPrefix":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPPrefix != nil {
			var publicIPPrefix1 SubResource
			err := publicIPPrefix1.PopulateFromARM(owner, *typedInput.Properties.PublicIPPrefix)
			if err != nil {
				return err
			}
			publicIPPrefix := publicIPPrefix1
			configuration.PublicIPPrefix = &publicIPPrefix
		}
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 PublicIPAddressSku
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		configuration.Sku = &sku
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachinePublicIPAddressConfiguration populates our VirtualMachinePublicIPAddressConfiguration from the provided source VirtualMachinePublicIPAddressConfiguration
func (configuration *VirtualMachinePublicIPAddressConfiguration) AssignProperties_From_VirtualMachinePublicIPAddressConfiguration(source *storage.VirtualMachinePublicIPAddressConfiguration) error {

	// DeleteOption
	if source.DeleteOption != nil {
		deleteOption := *source.DeleteOption
		deleteOptionTemp := genruntime.ToEnum(deleteOption, virtualMachinePublicIPAddressConfigurationProperties_DeleteOption_Values)
		configuration.DeleteOption = &deleteOptionTemp
	} else {
		configuration.DeleteOption = nil
	}

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting VirtualMachinePublicIPAddressDnsSettingsConfiguration
		err := dnsSetting.AssignProperties_From_VirtualMachinePublicIPAddressDnsSettingsConfiguration(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachinePublicIPAddressDnsSettingsConfiguration() to populate field DnsSettings")
		}
		configuration.DnsSettings = &dnsSetting
	} else {
		configuration.DnsSettings = nil
	}

	// IdleTimeoutInMinutes
	configuration.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// IpTags
	if source.IpTags != nil {
		ipTagList := make([]VirtualMachineIpTag, len(source.IpTags))
		for ipTagIndex, ipTagItem := range source.IpTags {
			// Shadow the loop variable to avoid aliasing
			ipTagItem := ipTagItem
			var ipTag VirtualMachineIpTag
			err := ipTag.AssignProperties_From_VirtualMachineIpTag(&ipTagItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineIpTag() to populate field IpTags")
			}
			ipTagList[ipTagIndex] = ipTag
		}
		configuration.IpTags = ipTagList
	} else {
		configuration.IpTags = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// PublicIPAddressVersion
	if source.PublicIPAddressVersion != nil {
		publicIPAddressVersion := *source.PublicIPAddressVersion
		publicIPAddressVersionTemp := genruntime.ToEnum(publicIPAddressVersion, virtualMachinePublicIPAddressConfigurationProperties_PublicIPAddressVersion_Values)
		configuration.PublicIPAddressVersion = &publicIPAddressVersionTemp
	} else {
		configuration.PublicIPAddressVersion = nil
	}

	// PublicIPAllocationMethod
	if source.PublicIPAllocationMethod != nil {
		publicIPAllocationMethod := *source.PublicIPAllocationMethod
		publicIPAllocationMethodTemp := genruntime.ToEnum(publicIPAllocationMethod, virtualMachinePublicIPAddressConfigurationProperties_PublicIPAllocationMethod_Values)
		configuration.PublicIPAllocationMethod = &publicIPAllocationMethodTemp
	} else {
		configuration.PublicIPAllocationMethod = nil
	}

	// PublicIPPrefix
	if source.PublicIPPrefix != nil {
		var publicIPPrefix SubResource
		err := publicIPPrefix.AssignProperties_From_SubResource(source.PublicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field PublicIPPrefix")
		}
		configuration.PublicIPPrefix = &publicIPPrefix
	} else {
		configuration.PublicIPPrefix = nil
	}

	// Sku
	if source.Sku != nil {
		var sku PublicIPAddressSku
		err := sku.AssignProperties_From_PublicIPAddressSku(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PublicIPAddressSku() to populate field Sku")
		}
		configuration.Sku = &sku
	} else {
		configuration.Sku = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachinePublicIPAddressConfiguration populates the provided destination VirtualMachinePublicIPAddressConfiguration from our VirtualMachinePublicIPAddressConfiguration
func (configuration *VirtualMachinePublicIPAddressConfiguration) AssignProperties_To_VirtualMachinePublicIPAddressConfiguration(destination *storage.VirtualMachinePublicIPAddressConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DeleteOption
	if configuration.DeleteOption != nil {
		deleteOption := string(*configuration.DeleteOption)
		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// DnsSettings
	if configuration.DnsSettings != nil {
		var dnsSetting storage.VirtualMachinePublicIPAddressDnsSettingsConfiguration
		err := configuration.DnsSettings.AssignProperties_To_VirtualMachinePublicIPAddressDnsSettingsConfiguration(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachinePublicIPAddressDnsSettingsConfiguration() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(configuration.IdleTimeoutInMinutes)

	// IpTags
	if configuration.IpTags != nil {
		ipTagList := make([]storage.VirtualMachineIpTag, len(configuration.IpTags))
		for ipTagIndex, ipTagItem := range configuration.IpTags {
			// Shadow the loop variable to avoid aliasing
			ipTagItem := ipTagItem
			var ipTag storage.VirtualMachineIpTag
			err := ipTagItem.AssignProperties_To_VirtualMachineIpTag(&ipTag)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineIpTag() to populate field IpTags")
			}
			ipTagList[ipTagIndex] = ipTag
		}
		destination.IpTags = ipTagList
	} else {
		destination.IpTags = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// PublicIPAddressVersion
	if configuration.PublicIPAddressVersion != nil {
		publicIPAddressVersion := string(*configuration.PublicIPAddressVersion)
		destination.PublicIPAddressVersion = &publicIPAddressVersion
	} else {
		destination.PublicIPAddressVersion = nil
	}

	// PublicIPAllocationMethod
	if configuration.PublicIPAllocationMethod != nil {
		publicIPAllocationMethod := string(*configuration.PublicIPAllocationMethod)
		destination.PublicIPAllocationMethod = &publicIPAllocationMethod
	} else {
		destination.PublicIPAllocationMethod = nil
	}

	// PublicIPPrefix
	if configuration.PublicIPPrefix != nil {
		var publicIPPrefix storage.SubResource
		err := configuration.PublicIPPrefix.AssignProperties_To_SubResource(&publicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field PublicIPPrefix")
		}
		destination.PublicIPPrefix = &publicIPPrefix
	} else {
		destination.PublicIPPrefix = nil
	}

	// Sku
	if configuration.Sku != nil {
		var sku storage.PublicIPAddressSku
		err := configuration.Sku.AssignProperties_To_PublicIPAddressSku(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PublicIPAddressSku() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualMachinePublicIPAddressConfiguration_STATUS populates our VirtualMachinePublicIPAddressConfiguration from the provided source VirtualMachinePublicIPAddressConfiguration_STATUS
func (configuration *VirtualMachinePublicIPAddressConfiguration) Initialize_From_VirtualMachinePublicIPAddressConfiguration_STATUS(source *VirtualMachinePublicIPAddressConfiguration_STATUS) error {

	// DeleteOption
	if source.DeleteOption != nil {
		deleteOption := genruntime.ToEnum(string(*source.DeleteOption), virtualMachinePublicIPAddressConfigurationProperties_DeleteOption_Values)
		configuration.DeleteOption = &deleteOption
	} else {
		configuration.DeleteOption = nil
	}

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting VirtualMachinePublicIPAddressDnsSettingsConfiguration
		err := dnsSetting.Initialize_From_VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS() to populate field DnsSettings")
		}
		configuration.DnsSettings = &dnsSetting
	} else {
		configuration.DnsSettings = nil
	}

	// IdleTimeoutInMinutes
	configuration.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// IpTags
	if source.IpTags != nil {
		ipTagList := make([]VirtualMachineIpTag, len(source.IpTags))
		for ipTagIndex, ipTagItem := range source.IpTags {
			// Shadow the loop variable to avoid aliasing
			ipTagItem := ipTagItem
			var ipTag VirtualMachineIpTag
			err := ipTag.Initialize_From_VirtualMachineIpTag_STATUS(&ipTagItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_VirtualMachineIpTag_STATUS() to populate field IpTags")
			}
			ipTagList[ipTagIndex] = ipTag
		}
		configuration.IpTags = ipTagList
	} else {
		configuration.IpTags = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// PublicIPAddressVersion
	if source.PublicIPAddressVersion != nil {
		publicIPAddressVersion := genruntime.ToEnum(string(*source.PublicIPAddressVersion), virtualMachinePublicIPAddressConfigurationProperties_PublicIPAddressVersion_Values)
		configuration.PublicIPAddressVersion = &publicIPAddressVersion
	} else {
		configuration.PublicIPAddressVersion = nil
	}

	// PublicIPAllocationMethod
	if source.PublicIPAllocationMethod != nil {
		publicIPAllocationMethod := genruntime.ToEnum(string(*source.PublicIPAllocationMethod), virtualMachinePublicIPAddressConfigurationProperties_PublicIPAllocationMethod_Values)
		configuration.PublicIPAllocationMethod = &publicIPAllocationMethod
	} else {
		configuration.PublicIPAllocationMethod = nil
	}

	// PublicIPPrefix
	if source.PublicIPPrefix != nil {
		var publicIPPrefix SubResource
		err := publicIPPrefix.Initialize_From_SubResource_STATUS(source.PublicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SubResource_STATUS() to populate field PublicIPPrefix")
		}
		configuration.PublicIPPrefix = &publicIPPrefix
	} else {
		configuration.PublicIPPrefix = nil
	}

	// Sku
	if source.Sku != nil {
		var sku PublicIPAddressSku
		err := sku.Initialize_From_PublicIPAddressSku_STATUS(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_PublicIPAddressSku_STATUS() to populate field Sku")
		}
		configuration.Sku = &sku
	} else {
		configuration.Sku = nil
	}

	// No error
	return nil
}

// Describes a virtual machines IP Configuration's PublicIPAddress configuration
type VirtualMachinePublicIPAddressConfiguration_STATUS struct {
	// DeleteOption: Specify what happens to the public IP address when the VM is deleted
	DeleteOption *VirtualMachinePublicIPAddressConfigurationProperties_DeleteOption_STATUS `json:"deleteOption,omitempty"`

	// DnsSettings: The dns settings to be applied on the publicIP addresses .
	DnsSettings *VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS `json:"dnsSettings,omitempty"`

	// IdleTimeoutInMinutes: The idle timeout of the public IP address.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	// IpTags: The list of IP tags associated with the public IP address.
	IpTags []VirtualMachineIpTag_STATUS `json:"ipTags,omitempty"`

	// Name: The publicIP address configuration name.
	Name *string `json:"name,omitempty"`

	// PublicIPAddressVersion: Available from Api-Version 2019-07-01 onwards, it represents whether the specific
	// ipconfiguration is IPv4 or IPv6. Default is taken as IPv4. Possible values are: 'IPv4' and 'IPv6'.
	PublicIPAddressVersion *VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAddressVersion_STATUS `json:"publicIPAddressVersion,omitempty"`

	// PublicIPAllocationMethod: Specify the public IP allocation type
	PublicIPAllocationMethod *VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAllocationMethod_STATUS `json:"publicIPAllocationMethod,omitempty"`

	// PublicIPPrefix: The PublicIPPrefix from which to allocate publicIP addresses.
	PublicIPPrefix *SubResource_STATUS `json:"publicIPPrefix,omitempty"`

	// Sku: Describes the public IP Sku. It can only be set with OrchestrationMode as Flexible.
	Sku *PublicIPAddressSku_STATUS `json:"sku,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachinePublicIPAddressConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *VirtualMachinePublicIPAddressConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachinePublicIPAddressConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *VirtualMachinePublicIPAddressConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachinePublicIPAddressConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachinePublicIPAddressConfiguration_STATUS, got %T", armInput)
	}

	// Set property "DeleteOption":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DeleteOption != nil {
			var temp string
			temp = string(*typedInput.Properties.DeleteOption)
			deleteOption := VirtualMachinePublicIPAddressConfigurationProperties_DeleteOption_STATUS(temp)
			configuration.DeleteOption = &deleteOption
		}
	}

	// Set property "DnsSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsSettings != nil {
			var dnsSettings1 VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS
			err := dnsSettings1.PopulateFromARM(owner, *typedInput.Properties.DnsSettings)
			if err != nil {
				return err
			}
			dnsSettings := dnsSettings1
			configuration.DnsSettings = &dnsSettings
		}
	}

	// Set property "IdleTimeoutInMinutes":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			configuration.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property "IpTags":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpTags {
			var item1 VirtualMachineIpTag_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			configuration.IpTags = append(configuration.IpTags, item1)
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		configuration.Name = &name
	}

	// Set property "PublicIPAddressVersion":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddressVersion != nil {
			var temp string
			temp = string(*typedInput.Properties.PublicIPAddressVersion)
			publicIPAddressVersion := VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAddressVersion_STATUS(temp)
			configuration.PublicIPAddressVersion = &publicIPAddressVersion
		}
	}

	// Set property "PublicIPAllocationMethod":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAllocationMethod != nil {
			var temp string
			temp = string(*typedInput.Properties.PublicIPAllocationMethod)
			publicIPAllocationMethod := VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAllocationMethod_STATUS(temp)
			configuration.PublicIPAllocationMethod = &publicIPAllocationMethod
		}
	}

	// Set property "PublicIPPrefix":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPPrefix != nil {
			var publicIPPrefix1 SubResource_STATUS
			err := publicIPPrefix1.PopulateFromARM(owner, *typedInput.Properties.PublicIPPrefix)
			if err != nil {
				return err
			}
			publicIPPrefix := publicIPPrefix1
			configuration.PublicIPPrefix = &publicIPPrefix
		}
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 PublicIPAddressSku_STATUS
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		configuration.Sku = &sku
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachinePublicIPAddressConfiguration_STATUS populates our VirtualMachinePublicIPAddressConfiguration_STATUS from the provided source VirtualMachinePublicIPAddressConfiguration_STATUS
func (configuration *VirtualMachinePublicIPAddressConfiguration_STATUS) AssignProperties_From_VirtualMachinePublicIPAddressConfiguration_STATUS(source *storage.VirtualMachinePublicIPAddressConfiguration_STATUS) error {

	// DeleteOption
	if source.DeleteOption != nil {
		deleteOption := *source.DeleteOption
		deleteOptionTemp := genruntime.ToEnum(deleteOption, virtualMachinePublicIPAddressConfigurationProperties_DeleteOption_STATUS_Values)
		configuration.DeleteOption = &deleteOptionTemp
	} else {
		configuration.DeleteOption = nil
	}

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS
		err := dnsSetting.AssignProperties_From_VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS() to populate field DnsSettings")
		}
		configuration.DnsSettings = &dnsSetting
	} else {
		configuration.DnsSettings = nil
	}

	// IdleTimeoutInMinutes
	configuration.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// IpTags
	if source.IpTags != nil {
		ipTagList := make([]VirtualMachineIpTag_STATUS, len(source.IpTags))
		for ipTagIndex, ipTagItem := range source.IpTags {
			// Shadow the loop variable to avoid aliasing
			ipTagItem := ipTagItem
			var ipTag VirtualMachineIpTag_STATUS
			err := ipTag.AssignProperties_From_VirtualMachineIpTag_STATUS(&ipTagItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineIpTag_STATUS() to populate field IpTags")
			}
			ipTagList[ipTagIndex] = ipTag
		}
		configuration.IpTags = ipTagList
	} else {
		configuration.IpTags = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// PublicIPAddressVersion
	if source.PublicIPAddressVersion != nil {
		publicIPAddressVersion := *source.PublicIPAddressVersion
		publicIPAddressVersionTemp := genruntime.ToEnum(publicIPAddressVersion, virtualMachinePublicIPAddressConfigurationProperties_PublicIPAddressVersion_STATUS_Values)
		configuration.PublicIPAddressVersion = &publicIPAddressVersionTemp
	} else {
		configuration.PublicIPAddressVersion = nil
	}

	// PublicIPAllocationMethod
	if source.PublicIPAllocationMethod != nil {
		publicIPAllocationMethod := *source.PublicIPAllocationMethod
		publicIPAllocationMethodTemp := genruntime.ToEnum(publicIPAllocationMethod, virtualMachinePublicIPAddressConfigurationProperties_PublicIPAllocationMethod_STATUS_Values)
		configuration.PublicIPAllocationMethod = &publicIPAllocationMethodTemp
	} else {
		configuration.PublicIPAllocationMethod = nil
	}

	// PublicIPPrefix
	if source.PublicIPPrefix != nil {
		var publicIPPrefix SubResource_STATUS
		err := publicIPPrefix.AssignProperties_From_SubResource_STATUS(source.PublicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field PublicIPPrefix")
		}
		configuration.PublicIPPrefix = &publicIPPrefix
	} else {
		configuration.PublicIPPrefix = nil
	}

	// Sku
	if source.Sku != nil {
		var sku PublicIPAddressSku_STATUS
		err := sku.AssignProperties_From_PublicIPAddressSku_STATUS(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PublicIPAddressSku_STATUS() to populate field Sku")
		}
		configuration.Sku = &sku
	} else {
		configuration.Sku = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachinePublicIPAddressConfiguration_STATUS populates the provided destination VirtualMachinePublicIPAddressConfiguration_STATUS from our VirtualMachinePublicIPAddressConfiguration_STATUS
func (configuration *VirtualMachinePublicIPAddressConfiguration_STATUS) AssignProperties_To_VirtualMachinePublicIPAddressConfiguration_STATUS(destination *storage.VirtualMachinePublicIPAddressConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DeleteOption
	if configuration.DeleteOption != nil {
		deleteOption := string(*configuration.DeleteOption)
		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// DnsSettings
	if configuration.DnsSettings != nil {
		var dnsSetting storage.VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS
		err := configuration.DnsSettings.AssignProperties_To_VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(configuration.IdleTimeoutInMinutes)

	// IpTags
	if configuration.IpTags != nil {
		ipTagList := make([]storage.VirtualMachineIpTag_STATUS, len(configuration.IpTags))
		for ipTagIndex, ipTagItem := range configuration.IpTags {
			// Shadow the loop variable to avoid aliasing
			ipTagItem := ipTagItem
			var ipTag storage.VirtualMachineIpTag_STATUS
			err := ipTagItem.AssignProperties_To_VirtualMachineIpTag_STATUS(&ipTag)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineIpTag_STATUS() to populate field IpTags")
			}
			ipTagList[ipTagIndex] = ipTag
		}
		destination.IpTags = ipTagList
	} else {
		destination.IpTags = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// PublicIPAddressVersion
	if configuration.PublicIPAddressVersion != nil {
		publicIPAddressVersion := string(*configuration.PublicIPAddressVersion)
		destination.PublicIPAddressVersion = &publicIPAddressVersion
	} else {
		destination.PublicIPAddressVersion = nil
	}

	// PublicIPAllocationMethod
	if configuration.PublicIPAllocationMethod != nil {
		publicIPAllocationMethod := string(*configuration.PublicIPAllocationMethod)
		destination.PublicIPAllocationMethod = &publicIPAllocationMethod
	} else {
		destination.PublicIPAllocationMethod = nil
	}

	// PublicIPPrefix
	if configuration.PublicIPPrefix != nil {
		var publicIPPrefix storage.SubResource_STATUS
		err := configuration.PublicIPPrefix.AssignProperties_To_SubResource_STATUS(&publicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field PublicIPPrefix")
		}
		destination.PublicIPPrefix = &publicIPPrefix
	} else {
		destination.PublicIPPrefix = nil
	}

	// Sku
	if configuration.Sku != nil {
		var sku storage.PublicIPAddressSku_STATUS
		err := configuration.Sku.AssignProperties_To_PublicIPAddressSku_STATUS(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PublicIPAddressSku_STATUS() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Specifies the security profile settings for the managed disk.
// NOTE: It can only be set for Confidential VMs
type VMDiskSecurityProfile struct {
	// DiskEncryptionSet: Specifies the customer managed disk encryption set resource id for the managed disk that is used for
	// Customer Managed Key encrypted ConfidentialVM OS Disk and VMGuest blob.
	DiskEncryptionSet *SubResource `json:"diskEncryptionSet,omitempty"`

	// SecurityEncryptionType: Specifies the EncryptionType of the managed disk.
	// It is set to DiskWithVMGuestState for encryption of the managed disk along with VMGuestState blob, and VMGuestStateOnly
	// for encryption of just the VMGuestState blob.
	// NOTE: It can be set for only Confidential VMs.
	SecurityEncryptionType *VMDiskSecurityProfile_SecurityEncryptionType `json:"securityEncryptionType,omitempty"`
}

var _ genruntime.ARMTransformer = &VMDiskSecurityProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *VMDiskSecurityProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.VMDiskSecurityProfile{}

	// Set property "DiskEncryptionSet":
	if profile.DiskEncryptionSet != nil {
		diskEncryptionSet_ARM, err := (*profile.DiskEncryptionSet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		diskEncryptionSet := *diskEncryptionSet_ARM.(*arm.SubResource)
		result.DiskEncryptionSet = &diskEncryptionSet
	}

	// Set property "SecurityEncryptionType":
	if profile.SecurityEncryptionType != nil {
		var temp string
		temp = string(*profile.SecurityEncryptionType)
		securityEncryptionType := arm.VMDiskSecurityProfile_SecurityEncryptionType(temp)
		result.SecurityEncryptionType = &securityEncryptionType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VMDiskSecurityProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VMDiskSecurityProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VMDiskSecurityProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VMDiskSecurityProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VMDiskSecurityProfile, got %T", armInput)
	}

	// Set property "DiskEncryptionSet":
	if typedInput.DiskEncryptionSet != nil {
		var diskEncryptionSet1 SubResource
		err := diskEncryptionSet1.PopulateFromARM(owner, *typedInput.DiskEncryptionSet)
		if err != nil {
			return err
		}
		diskEncryptionSet := diskEncryptionSet1
		profile.DiskEncryptionSet = &diskEncryptionSet
	}

	// Set property "SecurityEncryptionType":
	if typedInput.SecurityEncryptionType != nil {
		var temp string
		temp = string(*typedInput.SecurityEncryptionType)
		securityEncryptionType := VMDiskSecurityProfile_SecurityEncryptionType(temp)
		profile.SecurityEncryptionType = &securityEncryptionType
	}

	// No error
	return nil
}

// AssignProperties_From_VMDiskSecurityProfile populates our VMDiskSecurityProfile from the provided source VMDiskSecurityProfile
func (profile *VMDiskSecurityProfile) AssignProperties_From_VMDiskSecurityProfile(source *storage.VMDiskSecurityProfile) error {

	// DiskEncryptionSet
	if source.DiskEncryptionSet != nil {
		var diskEncryptionSet SubResource
		err := diskEncryptionSet.AssignProperties_From_SubResource(source.DiskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field DiskEncryptionSet")
		}
		profile.DiskEncryptionSet = &diskEncryptionSet
	} else {
		profile.DiskEncryptionSet = nil
	}

	// SecurityEncryptionType
	if source.SecurityEncryptionType != nil {
		securityEncryptionType := *source.SecurityEncryptionType
		securityEncryptionTypeTemp := genruntime.ToEnum(securityEncryptionType, vMDiskSecurityProfile_SecurityEncryptionType_Values)
		profile.SecurityEncryptionType = &securityEncryptionTypeTemp
	} else {
		profile.SecurityEncryptionType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VMDiskSecurityProfile populates the provided destination VMDiskSecurityProfile from our VMDiskSecurityProfile
func (profile *VMDiskSecurityProfile) AssignProperties_To_VMDiskSecurityProfile(destination *storage.VMDiskSecurityProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DiskEncryptionSet
	if profile.DiskEncryptionSet != nil {
		var diskEncryptionSet storage.SubResource
		err := profile.DiskEncryptionSet.AssignProperties_To_SubResource(&diskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field DiskEncryptionSet")
		}
		destination.DiskEncryptionSet = &diskEncryptionSet
	} else {
		destination.DiskEncryptionSet = nil
	}

	// SecurityEncryptionType
	if profile.SecurityEncryptionType != nil {
		securityEncryptionType := string(*profile.SecurityEncryptionType)
		destination.SecurityEncryptionType = &securityEncryptionType
	} else {
		destination.SecurityEncryptionType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VMDiskSecurityProfile_STATUS populates our VMDiskSecurityProfile from the provided source VMDiskSecurityProfile_STATUS
func (profile *VMDiskSecurityProfile) Initialize_From_VMDiskSecurityProfile_STATUS(source *VMDiskSecurityProfile_STATUS) error {

	// DiskEncryptionSet
	if source.DiskEncryptionSet != nil {
		var diskEncryptionSet SubResource
		err := diskEncryptionSet.Initialize_From_SubResource_STATUS(source.DiskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SubResource_STATUS() to populate field DiskEncryptionSet")
		}
		profile.DiskEncryptionSet = &diskEncryptionSet
	} else {
		profile.DiskEncryptionSet = nil
	}

	// SecurityEncryptionType
	if source.SecurityEncryptionType != nil {
		securityEncryptionType := genruntime.ToEnum(string(*source.SecurityEncryptionType), vMDiskSecurityProfile_SecurityEncryptionType_Values)
		profile.SecurityEncryptionType = &securityEncryptionType
	} else {
		profile.SecurityEncryptionType = nil
	}

	// No error
	return nil
}

// Specifies the security profile settings for the managed disk.
// NOTE: It can only be set for Confidential VMs
type VMDiskSecurityProfile_STATUS struct {
	// DiskEncryptionSet: Specifies the customer managed disk encryption set resource id for the managed disk that is used for
	// Customer Managed Key encrypted ConfidentialVM OS Disk and VMGuest blob.
	DiskEncryptionSet *SubResource_STATUS `json:"diskEncryptionSet,omitempty"`

	// SecurityEncryptionType: Specifies the EncryptionType of the managed disk.
	// It is set to DiskWithVMGuestState for encryption of the managed disk along with VMGuestState blob, and VMGuestStateOnly
	// for encryption of just the VMGuestState blob.
	// NOTE: It can be set for only Confidential VMs.
	SecurityEncryptionType *VMDiskSecurityProfile_SecurityEncryptionType_STATUS `json:"securityEncryptionType,omitempty"`
}

var _ genruntime.FromARMConverter = &VMDiskSecurityProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VMDiskSecurityProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VMDiskSecurityProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VMDiskSecurityProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VMDiskSecurityProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VMDiskSecurityProfile_STATUS, got %T", armInput)
	}

	// Set property "DiskEncryptionSet":
	if typedInput.DiskEncryptionSet != nil {
		var diskEncryptionSet1 SubResource_STATUS
		err := diskEncryptionSet1.PopulateFromARM(owner, *typedInput.DiskEncryptionSet)
		if err != nil {
			return err
		}
		diskEncryptionSet := diskEncryptionSet1
		profile.DiskEncryptionSet = &diskEncryptionSet
	}

	// Set property "SecurityEncryptionType":
	if typedInput.SecurityEncryptionType != nil {
		var temp string
		temp = string(*typedInput.SecurityEncryptionType)
		securityEncryptionType := VMDiskSecurityProfile_SecurityEncryptionType_STATUS(temp)
		profile.SecurityEncryptionType = &securityEncryptionType
	}

	// No error
	return nil
}

// AssignProperties_From_VMDiskSecurityProfile_STATUS populates our VMDiskSecurityProfile_STATUS from the provided source VMDiskSecurityProfile_STATUS
func (profile *VMDiskSecurityProfile_STATUS) AssignProperties_From_VMDiskSecurityProfile_STATUS(source *storage.VMDiskSecurityProfile_STATUS) error {

	// DiskEncryptionSet
	if source.DiskEncryptionSet != nil {
		var diskEncryptionSet SubResource_STATUS
		err := diskEncryptionSet.AssignProperties_From_SubResource_STATUS(source.DiskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field DiskEncryptionSet")
		}
		profile.DiskEncryptionSet = &diskEncryptionSet
	} else {
		profile.DiskEncryptionSet = nil
	}

	// SecurityEncryptionType
	if source.SecurityEncryptionType != nil {
		securityEncryptionType := *source.SecurityEncryptionType
		securityEncryptionTypeTemp := genruntime.ToEnum(securityEncryptionType, vMDiskSecurityProfile_SecurityEncryptionType_STATUS_Values)
		profile.SecurityEncryptionType = &securityEncryptionTypeTemp
	} else {
		profile.SecurityEncryptionType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_VMDiskSecurityProfile_STATUS populates the provided destination VMDiskSecurityProfile_STATUS from our VMDiskSecurityProfile_STATUS
func (profile *VMDiskSecurityProfile_STATUS) AssignProperties_To_VMDiskSecurityProfile_STATUS(destination *storage.VMDiskSecurityProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DiskEncryptionSet
	if profile.DiskEncryptionSet != nil {
		var diskEncryptionSet storage.SubResource_STATUS
		err := profile.DiskEncryptionSet.AssignProperties_To_SubResource_STATUS(&diskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field DiskEncryptionSet")
		}
		destination.DiskEncryptionSet = &diskEncryptionSet
	} else {
		destination.DiskEncryptionSet = nil
	}

	// SecurityEncryptionType
	if profile.SecurityEncryptionType != nil {
		securityEncryptionType := string(*profile.SecurityEncryptionType)
		destination.SecurityEncryptionType = &securityEncryptionType
	} else {
		destination.SecurityEncryptionType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Specifies additional settings to be applied when patch mode AutomaticByPlatform is selected in Windows patch settings.
type WindowsVMGuestPatchAutomaticByPlatformSettings struct {
	// RebootSetting: Specifies the reboot setting for all AutomaticByPlatform patch installation operations.
	RebootSetting *WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting `json:"rebootSetting,omitempty"`
}

var _ genruntime.ARMTransformer = &WindowsVMGuestPatchAutomaticByPlatformSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *WindowsVMGuestPatchAutomaticByPlatformSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.WindowsVMGuestPatchAutomaticByPlatformSettings{}

	// Set property "RebootSetting":
	if settings.RebootSetting != nil {
		var temp string
		temp = string(*settings.RebootSetting)
		rebootSetting := arm.WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting(temp)
		result.RebootSetting = &rebootSetting
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *WindowsVMGuestPatchAutomaticByPlatformSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WindowsVMGuestPatchAutomaticByPlatformSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *WindowsVMGuestPatchAutomaticByPlatformSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WindowsVMGuestPatchAutomaticByPlatformSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WindowsVMGuestPatchAutomaticByPlatformSettings, got %T", armInput)
	}

	// Set property "RebootSetting":
	if typedInput.RebootSetting != nil {
		var temp string
		temp = string(*typedInput.RebootSetting)
		rebootSetting := WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting(temp)
		settings.RebootSetting = &rebootSetting
	}

	// No error
	return nil
}

// AssignProperties_From_WindowsVMGuestPatchAutomaticByPlatformSettings populates our WindowsVMGuestPatchAutomaticByPlatformSettings from the provided source WindowsVMGuestPatchAutomaticByPlatformSettings
func (settings *WindowsVMGuestPatchAutomaticByPlatformSettings) AssignProperties_From_WindowsVMGuestPatchAutomaticByPlatformSettings(source *storage.WindowsVMGuestPatchAutomaticByPlatformSettings) error {

	// RebootSetting
	if source.RebootSetting != nil {
		rebootSetting := *source.RebootSetting
		rebootSettingTemp := genruntime.ToEnum(rebootSetting, windowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting_Values)
		settings.RebootSetting = &rebootSettingTemp
	} else {
		settings.RebootSetting = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WindowsVMGuestPatchAutomaticByPlatformSettings populates the provided destination WindowsVMGuestPatchAutomaticByPlatformSettings from our WindowsVMGuestPatchAutomaticByPlatformSettings
func (settings *WindowsVMGuestPatchAutomaticByPlatformSettings) AssignProperties_To_WindowsVMGuestPatchAutomaticByPlatformSettings(destination *storage.WindowsVMGuestPatchAutomaticByPlatformSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RebootSetting
	if settings.RebootSetting != nil {
		rebootSetting := string(*settings.RebootSetting)
		destination.RebootSetting = &rebootSetting
	} else {
		destination.RebootSetting = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS populates our WindowsVMGuestPatchAutomaticByPlatformSettings from the provided source WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS
func (settings *WindowsVMGuestPatchAutomaticByPlatformSettings) Initialize_From_WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS(source *WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS) error {

	// RebootSetting
	if source.RebootSetting != nil {
		rebootSetting := genruntime.ToEnum(string(*source.RebootSetting), windowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting_Values)
		settings.RebootSetting = &rebootSetting
	} else {
		settings.RebootSetting = nil
	}

	// No error
	return nil
}

// Specifies additional settings to be applied when patch mode AutomaticByPlatform is selected in Windows patch settings.
type WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS struct {
	// RebootSetting: Specifies the reboot setting for all AutomaticByPlatform patch installation operations.
	RebootSetting *WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS `json:"rebootSetting,omitempty"`
}

var _ genruntime.FromARMConverter = &WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS, got %T", armInput)
	}

	// Set property "RebootSetting":
	if typedInput.RebootSetting != nil {
		var temp string
		temp = string(*typedInput.RebootSetting)
		rebootSetting := WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS(temp)
		settings.RebootSetting = &rebootSetting
	}

	// No error
	return nil
}

// AssignProperties_From_WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS populates our WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS from the provided source WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS
func (settings *WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS) AssignProperties_From_WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS(source *storage.WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS) error {

	// RebootSetting
	if source.RebootSetting != nil {
		rebootSetting := *source.RebootSetting
		rebootSettingTemp := genruntime.ToEnum(rebootSetting, windowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS_Values)
		settings.RebootSetting = &rebootSettingTemp
	} else {
		settings.RebootSetting = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS populates the provided destination WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS from our WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS
func (settings *WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS) AssignProperties_To_WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS(destination *storage.WindowsVMGuestPatchAutomaticByPlatformSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RebootSetting
	if settings.RebootSetting != nil {
		rebootSetting := string(*settings.RebootSetting)
		destination.RebootSetting = &rebootSetting
	} else {
		destination.RebootSetting = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes Protocol and thumbprint of Windows Remote Management listener
type WinRMListener struct {
	// CertificateUrl: This is the URL of a certificate that has been uploaded to Key Vault as a secret. For adding a secret to
	// the Key Vault, see [Add a key or secret to the key
	// vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add). In this case, your certificate needs to
	// be It is the Base64 encoding of the following JSON Object which is encoded in UTF-8:
	// {
	// "data":"<Base64-encoded-certificate>",
	// "dataType":"pfx",
	// "password":"<pfx-file-password>"
	// }
	// To install certificates on a virtual machine it is recommended to use the [Azure Key Vault virtual machine extension for
	// Linux](https://docs.microsoft.com/azure/virtual-machines/extensions/key-vault-linux) or the [Azure Key Vault virtual
	// machine extension for Windows](https://docs.microsoft.com/azure/virtual-machines/extensions/key-vault-windows).
	CertificateUrl *string `json:"certificateUrl,omitempty"`

	// Protocol: Specifies the protocol of WinRM listener.
	// Possible values are:
	// http
	// https
	Protocol *WinRMListener_Protocol `json:"protocol,omitempty"`
}

var _ genruntime.ARMTransformer = &WinRMListener{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (listener *WinRMListener) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if listener == nil {
		return nil, nil
	}
	result := &arm.WinRMListener{}

	// Set property "CertificateUrl":
	if listener.CertificateUrl != nil {
		certificateUrl := *listener.CertificateUrl
		result.CertificateUrl = &certificateUrl
	}

	// Set property "Protocol":
	if listener.Protocol != nil {
		var temp string
		temp = string(*listener.Protocol)
		protocol := arm.WinRMListener_Protocol(temp)
		result.Protocol = &protocol
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (listener *WinRMListener) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WinRMListener{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (listener *WinRMListener) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WinRMListener)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WinRMListener, got %T", armInput)
	}

	// Set property "CertificateUrl":
	if typedInput.CertificateUrl != nil {
		certificateUrl := *typedInput.CertificateUrl
		listener.CertificateUrl = &certificateUrl
	}

	// Set property "Protocol":
	if typedInput.Protocol != nil {
		var temp string
		temp = string(*typedInput.Protocol)
		protocol := WinRMListener_Protocol(temp)
		listener.Protocol = &protocol
	}

	// No error
	return nil
}

// AssignProperties_From_WinRMListener populates our WinRMListener from the provided source WinRMListener
func (listener *WinRMListener) AssignProperties_From_WinRMListener(source *storage.WinRMListener) error {

	// CertificateUrl
	listener.CertificateUrl = genruntime.ClonePointerToString(source.CertificateUrl)

	// Protocol
	if source.Protocol != nil {
		protocol := *source.Protocol
		protocolTemp := genruntime.ToEnum(protocol, winRMListener_Protocol_Values)
		listener.Protocol = &protocolTemp
	} else {
		listener.Protocol = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WinRMListener populates the provided destination WinRMListener from our WinRMListener
func (listener *WinRMListener) AssignProperties_To_WinRMListener(destination *storage.WinRMListener) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CertificateUrl
	destination.CertificateUrl = genruntime.ClonePointerToString(listener.CertificateUrl)

	// Protocol
	if listener.Protocol != nil {
		protocol := string(*listener.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_WinRMListener_STATUS populates our WinRMListener from the provided source WinRMListener_STATUS
func (listener *WinRMListener) Initialize_From_WinRMListener_STATUS(source *WinRMListener_STATUS) error {

	// CertificateUrl
	listener.CertificateUrl = genruntime.ClonePointerToString(source.CertificateUrl)

	// Protocol
	if source.Protocol != nil {
		protocol := genruntime.ToEnum(string(*source.Protocol), winRMListener_Protocol_Values)
		listener.Protocol = &protocol
	} else {
		listener.Protocol = nil
	}

	// No error
	return nil
}

// Describes Protocol and thumbprint of Windows Remote Management listener
type WinRMListener_STATUS struct {
	// CertificateUrl: This is the URL of a certificate that has been uploaded to Key Vault as a secret. For adding a secret to
	// the Key Vault, see [Add a key or secret to the key
	// vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add). In this case, your certificate needs to
	// be It is the Base64 encoding of the following JSON Object which is encoded in UTF-8:
	// {
	// "data":"<Base64-encoded-certificate>",
	// "dataType":"pfx",
	// "password":"<pfx-file-password>"
	// }
	// To install certificates on a virtual machine it is recommended to use the [Azure Key Vault virtual machine extension for
	// Linux](https://docs.microsoft.com/azure/virtual-machines/extensions/key-vault-linux) or the [Azure Key Vault virtual
	// machine extension for Windows](https://docs.microsoft.com/azure/virtual-machines/extensions/key-vault-windows).
	CertificateUrl *string `json:"certificateUrl,omitempty"`

	// Protocol: Specifies the protocol of WinRM listener.
	// Possible values are:
	// http
	// https
	Protocol *WinRMListener_Protocol_STATUS `json:"protocol,omitempty"`
}

var _ genruntime.FromARMConverter = &WinRMListener_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (listener *WinRMListener_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WinRMListener_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (listener *WinRMListener_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WinRMListener_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WinRMListener_STATUS, got %T", armInput)
	}

	// Set property "CertificateUrl":
	if typedInput.CertificateUrl != nil {
		certificateUrl := *typedInput.CertificateUrl
		listener.CertificateUrl = &certificateUrl
	}

	// Set property "Protocol":
	if typedInput.Protocol != nil {
		var temp string
		temp = string(*typedInput.Protocol)
		protocol := WinRMListener_Protocol_STATUS(temp)
		listener.Protocol = &protocol
	}

	// No error
	return nil
}

// AssignProperties_From_WinRMListener_STATUS populates our WinRMListener_STATUS from the provided source WinRMListener_STATUS
func (listener *WinRMListener_STATUS) AssignProperties_From_WinRMListener_STATUS(source *storage.WinRMListener_STATUS) error {

	// CertificateUrl
	listener.CertificateUrl = genruntime.ClonePointerToString(source.CertificateUrl)

	// Protocol
	if source.Protocol != nil {
		protocol := *source.Protocol
		protocolTemp := genruntime.ToEnum(protocol, winRMListener_Protocol_STATUS_Values)
		listener.Protocol = &protocolTemp
	} else {
		listener.Protocol = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WinRMListener_STATUS populates the provided destination WinRMListener_STATUS from our WinRMListener_STATUS
func (listener *WinRMListener_STATUS) AssignProperties_To_WinRMListener_STATUS(destination *storage.WinRMListener_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CertificateUrl
	destination.CertificateUrl = genruntime.ClonePointerToString(listener.CertificateUrl)

	// Protocol
	if listener.Protocol != nil {
		protocol := string(*listener.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Api error base.
type ApiErrorBase_STATUS struct {
	// Code: The error code.
	Code *string `json:"code,omitempty"`

	// Message: The error message.
	Message *string `json:"message,omitempty"`

	// Target: The target of the particular error.
	Target *string `json:"target,omitempty"`
}

var _ genruntime.FromARMConverter = &ApiErrorBase_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (base *ApiErrorBase_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApiErrorBase_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (base *ApiErrorBase_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApiErrorBase_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApiErrorBase_STATUS, got %T", armInput)
	}

	// Set property "Code":
	if typedInput.Code != nil {
		code := *typedInput.Code
		base.Code = &code
	}

	// Set property "Message":
	if typedInput.Message != nil {
		message := *typedInput.Message
		base.Message = &message
	}

	// Set property "Target":
	if typedInput.Target != nil {
		target := *typedInput.Target
		base.Target = &target
	}

	// No error
	return nil
}

// AssignProperties_From_ApiErrorBase_STATUS populates our ApiErrorBase_STATUS from the provided source ApiErrorBase_STATUS
func (base *ApiErrorBase_STATUS) AssignProperties_From_ApiErrorBase_STATUS(source *storage.ApiErrorBase_STATUS) error {

	// Code
	base.Code = genruntime.ClonePointerToString(source.Code)

	// Message
	base.Message = genruntime.ClonePointerToString(source.Message)

	// Target
	base.Target = genruntime.ClonePointerToString(source.Target)

	// No error
	return nil
}

// AssignProperties_To_ApiErrorBase_STATUS populates the provided destination ApiErrorBase_STATUS from our ApiErrorBase_STATUS
func (base *ApiErrorBase_STATUS) AssignProperties_To_ApiErrorBase_STATUS(destination *storage.ApiErrorBase_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Code
	destination.Code = genruntime.ClonePointerToString(base.Code)

	// Message
	destination.Message = genruntime.ClonePointerToString(base.Message)

	// Target
	destination.Target = genruntime.ClonePointerToString(base.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Inner error details.
type InnerError_STATUS struct {
	// Errordetail: The internal error message or exception dump.
	Errordetail *string `json:"errordetail,omitempty"`

	// Exceptiontype: The exception type.
	Exceptiontype *string `json:"exceptiontype,omitempty"`
}

var _ genruntime.FromARMConverter = &InnerError_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (error *InnerError_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.InnerError_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (error *InnerError_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.InnerError_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.InnerError_STATUS, got %T", armInput)
	}

	// Set property "Errordetail":
	if typedInput.Errordetail != nil {
		errordetail := *typedInput.Errordetail
		error.Errordetail = &errordetail
	}

	// Set property "Exceptiontype":
	if typedInput.Exceptiontype != nil {
		exceptiontype := *typedInput.Exceptiontype
		error.Exceptiontype = &exceptiontype
	}

	// No error
	return nil
}

// AssignProperties_From_InnerError_STATUS populates our InnerError_STATUS from the provided source InnerError_STATUS
func (error *InnerError_STATUS) AssignProperties_From_InnerError_STATUS(source *storage.InnerError_STATUS) error {

	// Errordetail
	error.Errordetail = genruntime.ClonePointerToString(source.Errordetail)

	// Exceptiontype
	error.Exceptiontype = genruntime.ClonePointerToString(source.Exceptiontype)

	// No error
	return nil
}

// AssignProperties_To_InnerError_STATUS populates the provided destination InnerError_STATUS from our InnerError_STATUS
func (error *InnerError_STATUS) AssignProperties_To_InnerError_STATUS(destination *storage.InnerError_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Errordetail
	destination.Errordetail = genruntime.ClonePointerToString(error.Errordetail)

	// Exceptiontype
	destination.Exceptiontype = genruntime.ClonePointerToString(error.Exceptiontype)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Always","IfRequired","Never","Unknown"}
type LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting string

const (
	LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting_Always     = LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting("Always")
	LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting_IfRequired = LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting("IfRequired")
	LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting_Never      = LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting("Never")
	LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting_Unknown    = LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting("Unknown")
)

// Mapping from string to LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting
var linuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting_Values = map[string]LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting{
	"always":     LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting_Always,
	"ifrequired": LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting_IfRequired,
	"never":      LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting_Never,
	"unknown":    LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting_Unknown,
}

type LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS string

const (
	LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS_Always     = LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS("Always")
	LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS_IfRequired = LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS("IfRequired")
	LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS_Never      = LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS("Never")
	LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS_Unknown    = LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS("Unknown")
)

// Mapping from string to LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS
var linuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS_Values = map[string]LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS{
	"always":     LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS_Always,
	"ifrequired": LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS_IfRequired,
	"never":      LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS_Never,
	"unknown":    LinuxVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS_Unknown,
}

// Describes the public IP Sku. It can only be set with OrchestrationMode as Flexible.
type PublicIPAddressSku struct {
	// Name: Specify public IP sku name
	Name *PublicIPAddressSku_Name `json:"name,omitempty"`

	// Tier: Specify public IP sku tier
	Tier *PublicIPAddressSku_Tier `json:"tier,omitempty"`
}

var _ genruntime.ARMTransformer = &PublicIPAddressSku{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (addressSku *PublicIPAddressSku) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if addressSku == nil {
		return nil, nil
	}
	result := &arm.PublicIPAddressSku{}

	// Set property "Name":
	if addressSku.Name != nil {
		var temp string
		temp = string(*addressSku.Name)
		name := arm.PublicIPAddressSku_Name(temp)
		result.Name = &name
	}

	// Set property "Tier":
	if addressSku.Tier != nil {
		var temp string
		temp = string(*addressSku.Tier)
		tier := arm.PublicIPAddressSku_Tier(temp)
		result.Tier = &tier
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (addressSku *PublicIPAddressSku) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PublicIPAddressSku{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (addressSku *PublicIPAddressSku) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PublicIPAddressSku)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PublicIPAddressSku, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		var temp string
		temp = string(*typedInput.Name)
		name := PublicIPAddressSku_Name(temp)
		addressSku.Name = &name
	}

	// Set property "Tier":
	if typedInput.Tier != nil {
		var temp string
		temp = string(*typedInput.Tier)
		tier := PublicIPAddressSku_Tier(temp)
		addressSku.Tier = &tier
	}

	// No error
	return nil
}

// AssignProperties_From_PublicIPAddressSku populates our PublicIPAddressSku from the provided source PublicIPAddressSku
func (addressSku *PublicIPAddressSku) AssignProperties_From_PublicIPAddressSku(source *storage.PublicIPAddressSku) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, publicIPAddressSku_Name_Values)
		addressSku.Name = &nameTemp
	} else {
		addressSku.Name = nil
	}

	// Tier
	if source.Tier != nil {
		tier := *source.Tier
		tierTemp := genruntime.ToEnum(tier, publicIPAddressSku_Tier_Values)
		addressSku.Tier = &tierTemp
	} else {
		addressSku.Tier = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PublicIPAddressSku populates the provided destination PublicIPAddressSku from our PublicIPAddressSku
func (addressSku *PublicIPAddressSku) AssignProperties_To_PublicIPAddressSku(destination *storage.PublicIPAddressSku) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if addressSku.Name != nil {
		name := string(*addressSku.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Tier
	if addressSku.Tier != nil {
		tier := string(*addressSku.Tier)
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_PublicIPAddressSku_STATUS populates our PublicIPAddressSku from the provided source PublicIPAddressSku_STATUS
func (addressSku *PublicIPAddressSku) Initialize_From_PublicIPAddressSku_STATUS(source *PublicIPAddressSku_STATUS) error {

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), publicIPAddressSku_Name_Values)
		addressSku.Name = &name
	} else {
		addressSku.Name = nil
	}

	// Tier
	if source.Tier != nil {
		tier := genruntime.ToEnum(string(*source.Tier), publicIPAddressSku_Tier_Values)
		addressSku.Tier = &tier
	} else {
		addressSku.Tier = nil
	}

	// No error
	return nil
}

// Describes the public IP Sku. It can only be set with OrchestrationMode as Flexible.
type PublicIPAddressSku_STATUS struct {
	// Name: Specify public IP sku name
	Name *PublicIPAddressSku_Name_STATUS `json:"name,omitempty"`

	// Tier: Specify public IP sku tier
	Tier *PublicIPAddressSku_Tier_STATUS `json:"tier,omitempty"`
}

var _ genruntime.FromARMConverter = &PublicIPAddressSku_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (addressSku *PublicIPAddressSku_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PublicIPAddressSku_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (addressSku *PublicIPAddressSku_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PublicIPAddressSku_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PublicIPAddressSku_STATUS, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		var temp string
		temp = string(*typedInput.Name)
		name := PublicIPAddressSku_Name_STATUS(temp)
		addressSku.Name = &name
	}

	// Set property "Tier":
	if typedInput.Tier != nil {
		var temp string
		temp = string(*typedInput.Tier)
		tier := PublicIPAddressSku_Tier_STATUS(temp)
		addressSku.Tier = &tier
	}

	// No error
	return nil
}

// AssignProperties_From_PublicIPAddressSku_STATUS populates our PublicIPAddressSku_STATUS from the provided source PublicIPAddressSku_STATUS
func (addressSku *PublicIPAddressSku_STATUS) AssignProperties_From_PublicIPAddressSku_STATUS(source *storage.PublicIPAddressSku_STATUS) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, publicIPAddressSku_Name_STATUS_Values)
		addressSku.Name = &nameTemp
	} else {
		addressSku.Name = nil
	}

	// Tier
	if source.Tier != nil {
		tier := *source.Tier
		tierTemp := genruntime.ToEnum(tier, publicIPAddressSku_Tier_STATUS_Values)
		addressSku.Tier = &tierTemp
	} else {
		addressSku.Tier = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PublicIPAddressSku_STATUS populates the provided destination PublicIPAddressSku_STATUS from our PublicIPAddressSku_STATUS
func (addressSku *PublicIPAddressSku_STATUS) AssignProperties_To_PublicIPAddressSku_STATUS(destination *storage.PublicIPAddressSku_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if addressSku.Name != nil {
		name := string(*addressSku.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Tier
	if addressSku.Tier != nil {
		tier := string(*addressSku.Tier)
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Contains the IP tag associated with the public IP address.
type VirtualMachineIpTag struct {
	// IpTagType: IP tag type. Example: FirstPartyUsage.
	IpTagType *string `json:"ipTagType,omitempty"`

	// Tag: IP tag associated with the public IP. Example: SQL, Storage etc.
	Tag *string `json:"tag,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineIpTag{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (ipTag *VirtualMachineIpTag) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if ipTag == nil {
		return nil, nil
	}
	result := &arm.VirtualMachineIpTag{}

	// Set property "IpTagType":
	if ipTag.IpTagType != nil {
		ipTagType := *ipTag.IpTagType
		result.IpTagType = &ipTagType
	}

	// Set property "Tag":
	if ipTag.Tag != nil {
		tag := *ipTag.Tag
		result.Tag = &tag
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (ipTag *VirtualMachineIpTag) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineIpTag{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (ipTag *VirtualMachineIpTag) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineIpTag)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineIpTag, got %T", armInput)
	}

	// Set property "IpTagType":
	if typedInput.IpTagType != nil {
		ipTagType := *typedInput.IpTagType
		ipTag.IpTagType = &ipTagType
	}

	// Set property "Tag":
	if typedInput.Tag != nil {
		tag := *typedInput.Tag
		ipTag.Tag = &tag
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineIpTag populates our VirtualMachineIpTag from the provided source VirtualMachineIpTag
func (ipTag *VirtualMachineIpTag) AssignProperties_From_VirtualMachineIpTag(source *storage.VirtualMachineIpTag) error {

	// IpTagType
	ipTag.IpTagType = genruntime.ClonePointerToString(source.IpTagType)

	// Tag
	ipTag.Tag = genruntime.ClonePointerToString(source.Tag)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineIpTag populates the provided destination VirtualMachineIpTag from our VirtualMachineIpTag
func (ipTag *VirtualMachineIpTag) AssignProperties_To_VirtualMachineIpTag(destination *storage.VirtualMachineIpTag) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IpTagType
	destination.IpTagType = genruntime.ClonePointerToString(ipTag.IpTagType)

	// Tag
	destination.Tag = genruntime.ClonePointerToString(ipTag.Tag)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualMachineIpTag_STATUS populates our VirtualMachineIpTag from the provided source VirtualMachineIpTag_STATUS
func (ipTag *VirtualMachineIpTag) Initialize_From_VirtualMachineIpTag_STATUS(source *VirtualMachineIpTag_STATUS) error {

	// IpTagType
	ipTag.IpTagType = genruntime.ClonePointerToString(source.IpTagType)

	// Tag
	ipTag.Tag = genruntime.ClonePointerToString(source.Tag)

	// No error
	return nil
}

// Contains the IP tag associated with the public IP address.
type VirtualMachineIpTag_STATUS struct {
	// IpTagType: IP tag type. Example: FirstPartyUsage.
	IpTagType *string `json:"ipTagType,omitempty"`

	// Tag: IP tag associated with the public IP. Example: SQL, Storage etc.
	Tag *string `json:"tag,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineIpTag_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (ipTag *VirtualMachineIpTag_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachineIpTag_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (ipTag *VirtualMachineIpTag_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachineIpTag_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachineIpTag_STATUS, got %T", armInput)
	}

	// Set property "IpTagType":
	if typedInput.IpTagType != nil {
		ipTagType := *typedInput.IpTagType
		ipTag.IpTagType = &ipTagType
	}

	// Set property "Tag":
	if typedInput.Tag != nil {
		tag := *typedInput.Tag
		ipTag.Tag = &tag
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachineIpTag_STATUS populates our VirtualMachineIpTag_STATUS from the provided source VirtualMachineIpTag_STATUS
func (ipTag *VirtualMachineIpTag_STATUS) AssignProperties_From_VirtualMachineIpTag_STATUS(source *storage.VirtualMachineIpTag_STATUS) error {

	// IpTagType
	ipTag.IpTagType = genruntime.ClonePointerToString(source.IpTagType)

	// Tag
	ipTag.Tag = genruntime.ClonePointerToString(source.Tag)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineIpTag_STATUS populates the provided destination VirtualMachineIpTag_STATUS from our VirtualMachineIpTag_STATUS
func (ipTag *VirtualMachineIpTag_STATUS) AssignProperties_To_VirtualMachineIpTag_STATUS(destination *storage.VirtualMachineIpTag_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IpTagType
	destination.IpTagType = genruntime.ClonePointerToString(ipTag.IpTagType)

	// Tag
	destination.Tag = genruntime.ClonePointerToString(ipTag.Tag)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Delete","Detach"}
type VirtualMachinePublicIPAddressConfigurationProperties_DeleteOption string

const (
	VirtualMachinePublicIPAddressConfigurationProperties_DeleteOption_Delete = VirtualMachinePublicIPAddressConfigurationProperties_DeleteOption("Delete")
	VirtualMachinePublicIPAddressConfigurationProperties_DeleteOption_Detach = VirtualMachinePublicIPAddressConfigurationProperties_DeleteOption("Detach")
)

// Mapping from string to VirtualMachinePublicIPAddressConfigurationProperties_DeleteOption
var virtualMachinePublicIPAddressConfigurationProperties_DeleteOption_Values = map[string]VirtualMachinePublicIPAddressConfigurationProperties_DeleteOption{
	"delete": VirtualMachinePublicIPAddressConfigurationProperties_DeleteOption_Delete,
	"detach": VirtualMachinePublicIPAddressConfigurationProperties_DeleteOption_Detach,
}

type VirtualMachinePublicIPAddressConfigurationProperties_DeleteOption_STATUS string

const (
	VirtualMachinePublicIPAddressConfigurationProperties_DeleteOption_STATUS_Delete = VirtualMachinePublicIPAddressConfigurationProperties_DeleteOption_STATUS("Delete")
	VirtualMachinePublicIPAddressConfigurationProperties_DeleteOption_STATUS_Detach = VirtualMachinePublicIPAddressConfigurationProperties_DeleteOption_STATUS("Detach")
)

// Mapping from string to VirtualMachinePublicIPAddressConfigurationProperties_DeleteOption_STATUS
var virtualMachinePublicIPAddressConfigurationProperties_DeleteOption_STATUS_Values = map[string]VirtualMachinePublicIPAddressConfigurationProperties_DeleteOption_STATUS{
	"delete": VirtualMachinePublicIPAddressConfigurationProperties_DeleteOption_STATUS_Delete,
	"detach": VirtualMachinePublicIPAddressConfigurationProperties_DeleteOption_STATUS_Detach,
}

// +kubebuilder:validation:Enum={"IPv4","IPv6"}
type VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAddressVersion string

const (
	VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAddressVersion_IPv4 = VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAddressVersion("IPv4")
	VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAddressVersion_IPv6 = VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAddressVersion("IPv6")
)

// Mapping from string to VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAddressVersion
var virtualMachinePublicIPAddressConfigurationProperties_PublicIPAddressVersion_Values = map[string]VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAddressVersion{
	"ipv4": VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAddressVersion_IPv4,
	"ipv6": VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAddressVersion_IPv6,
}

type VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAddressVersion_STATUS string

const (
	VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAddressVersion_STATUS_IPv4 = VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAddressVersion_STATUS("IPv4")
	VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAddressVersion_STATUS_IPv6 = VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAddressVersion_STATUS("IPv6")
)

// Mapping from string to VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAddressVersion_STATUS
var virtualMachinePublicIPAddressConfigurationProperties_PublicIPAddressVersion_STATUS_Values = map[string]VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAddressVersion_STATUS{
	"ipv4": VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAddressVersion_STATUS_IPv4,
	"ipv6": VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAddressVersion_STATUS_IPv6,
}

// +kubebuilder:validation:Enum={"Dynamic","Static"}
type VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAllocationMethod string

const (
	VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAllocationMethod_Dynamic = VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAllocationMethod("Dynamic")
	VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAllocationMethod_Static  = VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAllocationMethod("Static")
)

// Mapping from string to VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAllocationMethod
var virtualMachinePublicIPAddressConfigurationProperties_PublicIPAllocationMethod_Values = map[string]VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAllocationMethod{
	"dynamic": VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAllocationMethod_Dynamic,
	"static":  VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAllocationMethod_Static,
}

type VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAllocationMethod_STATUS string

const (
	VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAllocationMethod_STATUS_Dynamic = VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAllocationMethod_STATUS("Dynamic")
	VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAllocationMethod_STATUS_Static  = VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAllocationMethod_STATUS("Static")
)

// Mapping from string to VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAllocationMethod_STATUS
var virtualMachinePublicIPAddressConfigurationProperties_PublicIPAllocationMethod_STATUS_Values = map[string]VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAllocationMethod_STATUS{
	"dynamic": VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAllocationMethod_STATUS_Dynamic,
	"static":  VirtualMachinePublicIPAddressConfigurationProperties_PublicIPAllocationMethod_STATUS_Static,
}

// Describes a virtual machines network configuration's DNS settings.
type VirtualMachinePublicIPAddressDnsSettingsConfiguration struct {
	// +kubebuilder:validation:Required
	// DomainNameLabel: The Domain name label prefix of the PublicIPAddress resources that will be created. The generated name
	// label is the concatenation of the domain name label and vm network profile unique ID.
	DomainNameLabel *string `json:"domainNameLabel,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachinePublicIPAddressDnsSettingsConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *VirtualMachinePublicIPAddressDnsSettingsConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &arm.VirtualMachinePublicIPAddressDnsSettingsConfiguration{}

	// Set property "DomainNameLabel":
	if configuration.DomainNameLabel != nil {
		domainNameLabel := *configuration.DomainNameLabel
		result.DomainNameLabel = &domainNameLabel
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *VirtualMachinePublicIPAddressDnsSettingsConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachinePublicIPAddressDnsSettingsConfiguration{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *VirtualMachinePublicIPAddressDnsSettingsConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachinePublicIPAddressDnsSettingsConfiguration)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachinePublicIPAddressDnsSettingsConfiguration, got %T", armInput)
	}

	// Set property "DomainNameLabel":
	if typedInput.DomainNameLabel != nil {
		domainNameLabel := *typedInput.DomainNameLabel
		configuration.DomainNameLabel = &domainNameLabel
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachinePublicIPAddressDnsSettingsConfiguration populates our VirtualMachinePublicIPAddressDnsSettingsConfiguration from the provided source VirtualMachinePublicIPAddressDnsSettingsConfiguration
func (configuration *VirtualMachinePublicIPAddressDnsSettingsConfiguration) AssignProperties_From_VirtualMachinePublicIPAddressDnsSettingsConfiguration(source *storage.VirtualMachinePublicIPAddressDnsSettingsConfiguration) error {

	// DomainNameLabel
	configuration.DomainNameLabel = genruntime.ClonePointerToString(source.DomainNameLabel)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachinePublicIPAddressDnsSettingsConfiguration populates the provided destination VirtualMachinePublicIPAddressDnsSettingsConfiguration from our VirtualMachinePublicIPAddressDnsSettingsConfiguration
func (configuration *VirtualMachinePublicIPAddressDnsSettingsConfiguration) AssignProperties_To_VirtualMachinePublicIPAddressDnsSettingsConfiguration(destination *storage.VirtualMachinePublicIPAddressDnsSettingsConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DomainNameLabel
	destination.DomainNameLabel = genruntime.ClonePointerToString(configuration.DomainNameLabel)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS populates our VirtualMachinePublicIPAddressDnsSettingsConfiguration from the provided source VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS
func (configuration *VirtualMachinePublicIPAddressDnsSettingsConfiguration) Initialize_From_VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS(source *VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS) error {

	// DomainNameLabel
	configuration.DomainNameLabel = genruntime.ClonePointerToString(source.DomainNameLabel)

	// No error
	return nil
}

// Describes a virtual machines network configuration's DNS settings.
type VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS struct {
	// DomainNameLabel: The Domain name label prefix of the PublicIPAddress resources that will be created. The generated name
	// label is the concatenation of the domain name label and vm network profile unique ID.
	DomainNameLabel *string `json:"domainNameLabel,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS, got %T", armInput)
	}

	// Set property "DomainNameLabel":
	if typedInput.DomainNameLabel != nil {
		domainNameLabel := *typedInput.DomainNameLabel
		configuration.DomainNameLabel = &domainNameLabel
	}

	// No error
	return nil
}

// AssignProperties_From_VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS populates our VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS from the provided source VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS
func (configuration *VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS) AssignProperties_From_VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS(source *storage.VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS) error {

	// DomainNameLabel
	configuration.DomainNameLabel = genruntime.ClonePointerToString(source.DomainNameLabel)

	// No error
	return nil
}

// AssignProperties_To_VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS populates the provided destination VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS from our VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS
func (configuration *VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS) AssignProperties_To_VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS(destination *storage.VirtualMachinePublicIPAddressDnsSettingsConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DomainNameLabel
	destination.DomainNameLabel = genruntime.ClonePointerToString(configuration.DomainNameLabel)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"DiskWithVMGuestState","VMGuestStateOnly"}
type VMDiskSecurityProfile_SecurityEncryptionType string

const (
	VMDiskSecurityProfile_SecurityEncryptionType_DiskWithVMGuestState = VMDiskSecurityProfile_SecurityEncryptionType("DiskWithVMGuestState")
	VMDiskSecurityProfile_SecurityEncryptionType_VMGuestStateOnly     = VMDiskSecurityProfile_SecurityEncryptionType("VMGuestStateOnly")
)

// Mapping from string to VMDiskSecurityProfile_SecurityEncryptionType
var vMDiskSecurityProfile_SecurityEncryptionType_Values = map[string]VMDiskSecurityProfile_SecurityEncryptionType{
	"diskwithvmgueststate": VMDiskSecurityProfile_SecurityEncryptionType_DiskWithVMGuestState,
	"vmgueststateonly":     VMDiskSecurityProfile_SecurityEncryptionType_VMGuestStateOnly,
}

type VMDiskSecurityProfile_SecurityEncryptionType_STATUS string

const (
	VMDiskSecurityProfile_SecurityEncryptionType_STATUS_DiskWithVMGuestState = VMDiskSecurityProfile_SecurityEncryptionType_STATUS("DiskWithVMGuestState")
	VMDiskSecurityProfile_SecurityEncryptionType_STATUS_VMGuestStateOnly     = VMDiskSecurityProfile_SecurityEncryptionType_STATUS("VMGuestStateOnly")
)

// Mapping from string to VMDiskSecurityProfile_SecurityEncryptionType_STATUS
var vMDiskSecurityProfile_SecurityEncryptionType_STATUS_Values = map[string]VMDiskSecurityProfile_SecurityEncryptionType_STATUS{
	"diskwithvmgueststate": VMDiskSecurityProfile_SecurityEncryptionType_STATUS_DiskWithVMGuestState,
	"vmgueststateonly":     VMDiskSecurityProfile_SecurityEncryptionType_STATUS_VMGuestStateOnly,
}

// +kubebuilder:validation:Enum={"Always","IfRequired","Never","Unknown"}
type WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting string

const (
	WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting_Always     = WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting("Always")
	WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting_IfRequired = WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting("IfRequired")
	WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting_Never      = WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting("Never")
	WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting_Unknown    = WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting("Unknown")
)

// Mapping from string to WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting
var windowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting_Values = map[string]WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting{
	"always":     WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting_Always,
	"ifrequired": WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting_IfRequired,
	"never":      WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting_Never,
	"unknown":    WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting_Unknown,
}

type WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS string

const (
	WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS_Always     = WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS("Always")
	WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS_IfRequired = WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS("IfRequired")
	WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS_Never      = WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS("Never")
	WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS_Unknown    = WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS("Unknown")
)

// Mapping from string to WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS
var windowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS_Values = map[string]WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS{
	"always":     WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS_Always,
	"ifrequired": WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS_IfRequired,
	"never":      WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS_Never,
	"unknown":    WindowsVMGuestPatchAutomaticByPlatformSettings_RebootSetting_STATUS_Unknown,
}

// +kubebuilder:validation:Enum={"Http","Https"}
type WinRMListener_Protocol string

const (
	WinRMListener_Protocol_Http  = WinRMListener_Protocol("Http")
	WinRMListener_Protocol_Https = WinRMListener_Protocol("Https")
)

// Mapping from string to WinRMListener_Protocol
var winRMListener_Protocol_Values = map[string]WinRMListener_Protocol{
	"http":  WinRMListener_Protocol_Http,
	"https": WinRMListener_Protocol_Https,
}

type WinRMListener_Protocol_STATUS string

const (
	WinRMListener_Protocol_STATUS_Http  = WinRMListener_Protocol_STATUS("Http")
	WinRMListener_Protocol_STATUS_Https = WinRMListener_Protocol_STATUS("Https")
)

// Mapping from string to WinRMListener_Protocol_STATUS
var winRMListener_Protocol_STATUS_Values = map[string]WinRMListener_Protocol_STATUS{
	"http":  WinRMListener_Protocol_STATUS_Http,
	"https": WinRMListener_Protocol_STATUS_Https,
}

// +kubebuilder:validation:Enum={"Basic","Standard"}
type PublicIPAddressSku_Name string

const (
	PublicIPAddressSku_Name_Basic    = PublicIPAddressSku_Name("Basic")
	PublicIPAddressSku_Name_Standard = PublicIPAddressSku_Name("Standard")
)

// Mapping from string to PublicIPAddressSku_Name
var publicIPAddressSku_Name_Values = map[string]PublicIPAddressSku_Name{
	"basic":    PublicIPAddressSku_Name_Basic,
	"standard": PublicIPAddressSku_Name_Standard,
}

type PublicIPAddressSku_Name_STATUS string

const (
	PublicIPAddressSku_Name_STATUS_Basic    = PublicIPAddressSku_Name_STATUS("Basic")
	PublicIPAddressSku_Name_STATUS_Standard = PublicIPAddressSku_Name_STATUS("Standard")
)

// Mapping from string to PublicIPAddressSku_Name_STATUS
var publicIPAddressSku_Name_STATUS_Values = map[string]PublicIPAddressSku_Name_STATUS{
	"basic":    PublicIPAddressSku_Name_STATUS_Basic,
	"standard": PublicIPAddressSku_Name_STATUS_Standard,
}

// +kubebuilder:validation:Enum={"Global","Regional"}
type PublicIPAddressSku_Tier string

const (
	PublicIPAddressSku_Tier_Global   = PublicIPAddressSku_Tier("Global")
	PublicIPAddressSku_Tier_Regional = PublicIPAddressSku_Tier("Regional")
)

// Mapping from string to PublicIPAddressSku_Tier
var publicIPAddressSku_Tier_Values = map[string]PublicIPAddressSku_Tier{
	"global":   PublicIPAddressSku_Tier_Global,
	"regional": PublicIPAddressSku_Tier_Regional,
}

type PublicIPAddressSku_Tier_STATUS string

const (
	PublicIPAddressSku_Tier_STATUS_Global   = PublicIPAddressSku_Tier_STATUS("Global")
	PublicIPAddressSku_Tier_STATUS_Regional = PublicIPAddressSku_Tier_STATUS("Regional")
)

// Mapping from string to PublicIPAddressSku_Tier_STATUS
var publicIPAddressSku_Tier_STATUS_Values = map[string]PublicIPAddressSku_Tier_STATUS{
	"global":   PublicIPAddressSku_Tier_STATUS_Global,
	"regional": PublicIPAddressSku_Tier_STATUS_Regional,
}

func init() {
	SchemeBuilder.Register(&VirtualMachine{}, &VirtualMachineList{})
}
