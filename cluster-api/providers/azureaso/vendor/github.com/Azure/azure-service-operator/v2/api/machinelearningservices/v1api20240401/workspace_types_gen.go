// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20240401

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/machinelearningservices/v1api20240401/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/machinelearningservices/v1api20240401/storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /machinelearningservices/resource-manager/Microsoft.MachineLearningServices/stable/2024-04-01/workspaceRP.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}
type Workspace struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              Workspace_Spec   `json:"spec,omitempty"`
	Status            Workspace_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &Workspace{}

// GetConditions returns the conditions of the resource
func (workspace *Workspace) GetConditions() conditions.Conditions {
	return workspace.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (workspace *Workspace) SetConditions(conditions conditions.Conditions) {
	workspace.Status.Conditions = conditions
}

var _ conversion.Convertible = &Workspace{}

// ConvertFrom populates our Workspace from the provided hub Workspace
func (workspace *Workspace) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.Workspace)
	if !ok {
		return fmt.Errorf("expected machinelearningservices/v1api20240401/storage/Workspace but received %T instead", hub)
	}

	return workspace.AssignProperties_From_Workspace(source)
}

// ConvertTo populates the provided hub Workspace from our Workspace
func (workspace *Workspace) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.Workspace)
	if !ok {
		return fmt.Errorf("expected machinelearningservices/v1api20240401/storage/Workspace but received %T instead", hub)
	}

	return workspace.AssignProperties_To_Workspace(destination)
}

// +kubebuilder:webhook:path=/mutate-machinelearningservices-azure-com-v1api20240401-workspace,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=machinelearningservices.azure.com,resources=workspaces,verbs=create;update,versions=v1api20240401,name=default.v1api20240401.workspaces.machinelearningservices.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &Workspace{}

// Default applies defaults to the Workspace resource
func (workspace *Workspace) Default() {
	workspace.defaultImpl()
	var temp any = workspace
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (workspace *Workspace) defaultAzureName() {
	if workspace.Spec.AzureName == "" {
		workspace.Spec.AzureName = workspace.Name
	}
}

// defaultImpl applies the code generated defaults to the Workspace resource
func (workspace *Workspace) defaultImpl() { workspace.defaultAzureName() }

var _ configmaps.Exporter = &Workspace{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (workspace *Workspace) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if workspace.Spec.OperatorSpec == nil {
		return nil
	}
	return workspace.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &Workspace{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (workspace *Workspace) SecretDestinationExpressions() []*core.DestinationExpression {
	if workspace.Spec.OperatorSpec == nil {
		return nil
	}
	return workspace.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &Workspace{}

// InitializeSpec initializes the spec for this resource from the given status
func (workspace *Workspace) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*Workspace_STATUS); ok {
		return workspace.Spec.Initialize_From_Workspace_STATUS(s)
	}

	return fmt.Errorf("expected Status of type Workspace_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &Workspace{}

// AzureName returns the Azure name of the resource
func (workspace *Workspace) AzureName() string {
	return workspace.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2024-04-01"
func (workspace Workspace) GetAPIVersion() string {
	return "2024-04-01"
}

// GetResourceScope returns the scope of the resource
func (workspace *Workspace) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (workspace *Workspace) GetSpec() genruntime.ConvertibleSpec {
	return &workspace.Spec
}

// GetStatus returns the status of this resource
func (workspace *Workspace) GetStatus() genruntime.ConvertibleStatus {
	return &workspace.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (workspace *Workspace) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.MachineLearningServices/workspaces"
func (workspace *Workspace) GetType() string {
	return "Microsoft.MachineLearningServices/workspaces"
}

// NewEmptyStatus returns a new empty (blank) status
func (workspace *Workspace) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &Workspace_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (workspace *Workspace) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(workspace.Spec)
	return workspace.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (workspace *Workspace) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*Workspace_STATUS); ok {
		workspace.Status = *st
		return nil
	}

	// Convert status to required version
	var st Workspace_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	workspace.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-machinelearningservices-azure-com-v1api20240401-workspace,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=machinelearningservices.azure.com,resources=workspaces,verbs=create;update,versions=v1api20240401,name=validate.v1api20240401.workspaces.machinelearningservices.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &Workspace{}

// ValidateCreate validates the creation of the resource
func (workspace *Workspace) ValidateCreate() (admission.Warnings, error) {
	validations := workspace.createValidations()
	var temp any = workspace
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	return genruntime.ValidateCreate(validations)
}

// ValidateDelete validates the deletion of the resource
func (workspace *Workspace) ValidateDelete() (admission.Warnings, error) {
	validations := workspace.deleteValidations()
	var temp any = workspace
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	return genruntime.ValidateDelete(validations)
}

// ValidateUpdate validates an update of the resource
func (workspace *Workspace) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	validations := workspace.updateValidations()
	var temp any = workspace
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	return genruntime.ValidateUpdate(old, validations)
}

// createValidations validates the creation of the resource
func (workspace *Workspace) createValidations() []func() (admission.Warnings, error) {
	return []func() (admission.Warnings, error){workspace.validateResourceReferences, workspace.validateOwnerReference, workspace.validateSecretDestinations, workspace.validateConfigMapDestinations, workspace.validateOptionalConfigMapReferences}
}

// deleteValidations validates the deletion of the resource
func (workspace *Workspace) deleteValidations() []func() (admission.Warnings, error) {
	return nil
}

// updateValidations validates the update of the resource
func (workspace *Workspace) updateValidations() []func(old runtime.Object) (admission.Warnings, error) {
	return []func(old runtime.Object) (admission.Warnings, error){
		func(old runtime.Object) (admission.Warnings, error) {
			return workspace.validateResourceReferences()
		},
		workspace.validateWriteOnceProperties,
		func(old runtime.Object) (admission.Warnings, error) {
			return workspace.validateOwnerReference()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return workspace.validateSecretDestinations()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return workspace.validateConfigMapDestinations()
		},
		func(old runtime.Object) (admission.Warnings, error) {
			return workspace.validateOptionalConfigMapReferences()
		},
	}
}

// validateConfigMapDestinations validates there are no colliding genruntime.ConfigMapDestinations
func (workspace *Workspace) validateConfigMapDestinations() (admission.Warnings, error) {
	if workspace.Spec.OperatorSpec == nil {
		return nil, nil
	}
	return configmaps.ValidateDestinations(workspace, nil, workspace.Spec.OperatorSpec.ConfigMapExpressions)
}

// validateOptionalConfigMapReferences validates all optional configmap reference pairs to ensure that at most 1 is set
func (workspace *Workspace) validateOptionalConfigMapReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindOptionalConfigMapReferences(&workspace.Spec)
	if err != nil {
		return nil, err
	}
	return configmaps.ValidateOptionalReferences(refs)
}

// validateOwnerReference validates the owner field
func (workspace *Workspace) validateOwnerReference() (admission.Warnings, error) {
	return genruntime.ValidateOwner(workspace)
}

// validateResourceReferences validates all resource references
func (workspace *Workspace) validateResourceReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindResourceReferences(&workspace.Spec)
	if err != nil {
		return nil, err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateSecretDestinations validates there are no colliding genruntime.SecretDestination's
func (workspace *Workspace) validateSecretDestinations() (admission.Warnings, error) {
	if workspace.Spec.OperatorSpec == nil {
		return nil, nil
	}
	var toValidate []*genruntime.SecretDestination
	if workspace.Spec.OperatorSpec.Secrets != nil {
		toValidate = []*genruntime.SecretDestination{
			workspace.Spec.OperatorSpec.Secrets.AppInsightsInstrumentationKey,
			workspace.Spec.OperatorSpec.Secrets.ContainerRegistryPassword,
			workspace.Spec.OperatorSpec.Secrets.ContainerRegistryPassword2,
			workspace.Spec.OperatorSpec.Secrets.ContainerRegistryUserName,
			workspace.Spec.OperatorSpec.Secrets.PrimaryNotebookAccessKey,
			workspace.Spec.OperatorSpec.Secrets.SecondaryNotebookAccessKey,
			workspace.Spec.OperatorSpec.Secrets.UserStorageKey,
		}
	}
	return secrets.ValidateDestinations(workspace, toValidate, workspace.Spec.OperatorSpec.SecretExpressions)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (workspace *Workspace) validateWriteOnceProperties(old runtime.Object) (admission.Warnings, error) {
	oldObj, ok := old.(*Workspace)
	if !ok {
		return nil, nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, workspace)
}

// AssignProperties_From_Workspace populates our Workspace from the provided source Workspace
func (workspace *Workspace) AssignProperties_From_Workspace(source *storage.Workspace) error {

	// ObjectMeta
	workspace.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec Workspace_Spec
	err := spec.AssignProperties_From_Workspace_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_Workspace_Spec() to populate field Spec")
	}
	workspace.Spec = spec

	// Status
	var status Workspace_STATUS
	err = status.AssignProperties_From_Workspace_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_Workspace_STATUS() to populate field Status")
	}
	workspace.Status = status

	// No error
	return nil
}

// AssignProperties_To_Workspace populates the provided destination Workspace from our Workspace
func (workspace *Workspace) AssignProperties_To_Workspace(destination *storage.Workspace) error {

	// ObjectMeta
	destination.ObjectMeta = *workspace.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.Workspace_Spec
	err := workspace.Spec.AssignProperties_To_Workspace_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_Workspace_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.Workspace_STATUS
	err = workspace.Status.AssignProperties_To_Workspace_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_Workspace_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (workspace *Workspace) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: workspace.Spec.OriginalVersion(),
		Kind:    "Workspace",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /machinelearningservices/resource-manager/Microsoft.MachineLearningServices/stable/2024-04-01/workspaceRP.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}
type WorkspaceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Workspace `json:"items"`
}

type Workspace_Spec struct {
	// AllowPublicAccessWhenBehindVnet: The flag to indicate whether to allow public access when behind VNet.
	AllowPublicAccessWhenBehindVnet *bool `json:"allowPublicAccessWhenBehindVnet,omitempty"`

	// ApplicationInsightsReference: ARM id of the application insights associated with this workspace.
	ApplicationInsightsReference *genruntime.ResourceReference `armReference:"ApplicationInsights" json:"applicationInsightsReference,omitempty"`
	AssociatedWorkspaces         []string                      `json:"associatedWorkspaces,omitempty"`

	// +kubebuilder:validation:Pattern="^[a-zA-Z0-9][a-zA-Z0-9_-]{2,32}$"
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// ContainerRegistryReference: ARM id of the container registry associated with this workspace.
	ContainerRegistryReference *genruntime.ResourceReference `armReference:"ContainerRegistry" json:"containerRegistryReference,omitempty"`

	// Description: The description of this workspace.
	Description *string `json:"description,omitempty"`

	// DiscoveryUrl: Url for the discovery service to identify regional endpoints for machine learning experimentation services
	DiscoveryUrl        *string `json:"discoveryUrl,omitempty"`
	EnableDataIsolation *bool   `json:"enableDataIsolation,omitempty"`

	// Encryption: The encryption settings of Azure ML workspace.
	Encryption *EncryptionProperty `json:"encryption,omitempty"`

	// FeatureStoreSettings: Settings for feature store type workspace.
	FeatureStoreSettings *FeatureStoreSettings `json:"featureStoreSettings,omitempty"`

	// FriendlyName: The friendly name for this workspace. This name in mutable
	FriendlyName *string `json:"friendlyName,omitempty"`

	// HbiWorkspace: The flag to signal HBI data in the workspace and reduce diagnostic data collected by the service
	HbiWorkspace         *bool                         `json:"hbiWorkspace,omitempty"`
	HubResourceReference *genruntime.ResourceReference `armReference:"HubResourceId" json:"hubResourceReference,omitempty"`

	// Identity: The identity of the resource.
	Identity *ManagedServiceIdentity `json:"identity,omitempty"`

	// ImageBuildCompute: The compute name for image build
	ImageBuildCompute *string `json:"imageBuildCompute,omitempty"`

	// KeyVaultReference: ARM id of the key vault associated with this workspace. This cannot be changed once the workspace has
	// been created
	KeyVaultReference *genruntime.ResourceReference `armReference:"KeyVault" json:"keyVaultReference,omitempty"`
	Kind              *string                       `json:"kind,omitempty"`

	// Location: Specifies the location of the resource.
	Location *string `json:"location,omitempty"`

	// ManagedNetwork: Managed Network settings for a machine learning workspace.
	ManagedNetwork *ManagedNetworkSettings `json:"managedNetwork,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *WorkspaceOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// PrimaryUserAssignedIdentityReference: The user assigned identity resource id that represents the workspace identity.
	PrimaryUserAssignedIdentityReference *genruntime.ResourceReference `armReference:"PrimaryUserAssignedIdentity" json:"primaryUserAssignedIdentityReference,omitempty"`

	// PublicNetworkAccess: Whether requests from Public Network are allowed.
	PublicNetworkAccess *WorkspaceProperties_PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// ServerlessComputeSettings: Settings for serverless compute created in the workspace
	ServerlessComputeSettings *ServerlessComputeSettings `json:"serverlessComputeSettings,omitempty"`

	// ServiceManagedResourcesSettings: The service managed resource settings.
	ServiceManagedResourcesSettings *ServiceManagedResourcesSettings `json:"serviceManagedResourcesSettings,omitempty"`

	// SharedPrivateLinkResources: The list of shared private link resources in this workspace.
	SharedPrivateLinkResources []SharedPrivateLinkResource `json:"sharedPrivateLinkResources,omitempty"`

	// Sku: The sku of the workspace.
	Sku *Sku `json:"sku,omitempty"`

	// StorageAccountReference: ARM id of the storage account associated with this workspace. This cannot be changed once the
	// workspace has been created
	StorageAccountReference *genruntime.ResourceReference `armReference:"StorageAccount" json:"storageAccountReference,omitempty"`

	// Tags: Contains resource tags defined as key/value pairs.
	Tags map[string]string `json:"tags,omitempty"`

	// V1LegacyMode: Enabling v1_legacy_mode may prevent you from using features provided by the v2 API.
	V1LegacyMode *bool `json:"v1LegacyMode,omitempty"`

	// WorkspaceHubConfig: WorkspaceHub's configuration object.
	WorkspaceHubConfig *WorkspaceHubConfig `json:"workspaceHubConfig,omitempty"`
}

var _ genruntime.ARMTransformer = &Workspace_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (workspace *Workspace_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if workspace == nil {
		return nil, nil
	}
	result := &arm.Workspace_Spec{}

	// Set property "Identity":
	if workspace.Identity != nil {
		identity_ARM, err := (*workspace.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*arm.ManagedServiceIdentity)
		result.Identity = &identity
	}

	// Set property "Kind":
	if workspace.Kind != nil {
		kind := *workspace.Kind
		result.Kind = &kind
	}

	// Set property "Location":
	if workspace.Location != nil {
		location := *workspace.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if workspace.AllowPublicAccessWhenBehindVnet != nil ||
		workspace.ApplicationInsightsReference != nil ||
		workspace.AssociatedWorkspaces != nil ||
		workspace.ContainerRegistryReference != nil ||
		workspace.Description != nil ||
		workspace.DiscoveryUrl != nil ||
		workspace.EnableDataIsolation != nil ||
		workspace.Encryption != nil ||
		workspace.FeatureStoreSettings != nil ||
		workspace.FriendlyName != nil ||
		workspace.HbiWorkspace != nil ||
		workspace.HubResourceReference != nil ||
		workspace.ImageBuildCompute != nil ||
		workspace.KeyVaultReference != nil ||
		workspace.ManagedNetwork != nil ||
		workspace.PrimaryUserAssignedIdentityReference != nil ||
		workspace.PublicNetworkAccess != nil ||
		workspace.ServerlessComputeSettings != nil ||
		workspace.ServiceManagedResourcesSettings != nil ||
		workspace.SharedPrivateLinkResources != nil ||
		workspace.StorageAccountReference != nil ||
		workspace.V1LegacyMode != nil ||
		workspace.WorkspaceHubConfig != nil {
		result.Properties = &arm.WorkspaceProperties{}
	}
	if workspace.AllowPublicAccessWhenBehindVnet != nil {
		allowPublicAccessWhenBehindVnet := *workspace.AllowPublicAccessWhenBehindVnet
		result.Properties.AllowPublicAccessWhenBehindVnet = &allowPublicAccessWhenBehindVnet
	}
	if workspace.ApplicationInsightsReference != nil {
		applicationInsightsARMID, err := resolved.ResolvedReferences.Lookup(*workspace.ApplicationInsightsReference)
		if err != nil {
			return nil, err
		}
		applicationInsights := applicationInsightsARMID
		result.Properties.ApplicationInsights = &applicationInsights
	}
	for _, item := range workspace.AssociatedWorkspaces {
		result.Properties.AssociatedWorkspaces = append(result.Properties.AssociatedWorkspaces, item)
	}
	if workspace.ContainerRegistryReference != nil {
		containerRegistryARMID, err := resolved.ResolvedReferences.Lookup(*workspace.ContainerRegistryReference)
		if err != nil {
			return nil, err
		}
		containerRegistry := containerRegistryARMID
		result.Properties.ContainerRegistry = &containerRegistry
	}
	if workspace.Description != nil {
		description := *workspace.Description
		result.Properties.Description = &description
	}
	if workspace.DiscoveryUrl != nil {
		discoveryUrl := *workspace.DiscoveryUrl
		result.Properties.DiscoveryUrl = &discoveryUrl
	}
	if workspace.EnableDataIsolation != nil {
		enableDataIsolation := *workspace.EnableDataIsolation
		result.Properties.EnableDataIsolation = &enableDataIsolation
	}
	if workspace.Encryption != nil {
		encryption_ARM, err := (*workspace.Encryption).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		encryption := *encryption_ARM.(*arm.EncryptionProperty)
		result.Properties.Encryption = &encryption
	}
	if workspace.FeatureStoreSettings != nil {
		featureStoreSettings_ARM, err := (*workspace.FeatureStoreSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		featureStoreSettings := *featureStoreSettings_ARM.(*arm.FeatureStoreSettings)
		result.Properties.FeatureStoreSettings = &featureStoreSettings
	}
	if workspace.FriendlyName != nil {
		friendlyName := *workspace.FriendlyName
		result.Properties.FriendlyName = &friendlyName
	}
	if workspace.HbiWorkspace != nil {
		hbiWorkspace := *workspace.HbiWorkspace
		result.Properties.HbiWorkspace = &hbiWorkspace
	}
	if workspace.HubResourceReference != nil {
		hubResourceIdARMID, err := resolved.ResolvedReferences.Lookup(*workspace.HubResourceReference)
		if err != nil {
			return nil, err
		}
		hubResourceId := hubResourceIdARMID
		result.Properties.HubResourceId = &hubResourceId
	}
	if workspace.ImageBuildCompute != nil {
		imageBuildCompute := *workspace.ImageBuildCompute
		result.Properties.ImageBuildCompute = &imageBuildCompute
	}
	if workspace.KeyVaultReference != nil {
		keyVaultARMID, err := resolved.ResolvedReferences.Lookup(*workspace.KeyVaultReference)
		if err != nil {
			return nil, err
		}
		keyVault := keyVaultARMID
		result.Properties.KeyVault = &keyVault
	}
	if workspace.ManagedNetwork != nil {
		managedNetwork_ARM, err := (*workspace.ManagedNetwork).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		managedNetwork := *managedNetwork_ARM.(*arm.ManagedNetworkSettings)
		result.Properties.ManagedNetwork = &managedNetwork
	}
	if workspace.PrimaryUserAssignedIdentityReference != nil {
		primaryUserAssignedIdentityARMID, err := resolved.ResolvedReferences.Lookup(*workspace.PrimaryUserAssignedIdentityReference)
		if err != nil {
			return nil, err
		}
		primaryUserAssignedIdentity := primaryUserAssignedIdentityARMID
		result.Properties.PrimaryUserAssignedIdentity = &primaryUserAssignedIdentity
	}
	if workspace.PublicNetworkAccess != nil {
		var temp string
		temp = string(*workspace.PublicNetworkAccess)
		publicNetworkAccess := arm.WorkspaceProperties_PublicNetworkAccess(temp)
		result.Properties.PublicNetworkAccess = &publicNetworkAccess
	}
	if workspace.ServerlessComputeSettings != nil {
		serverlessComputeSettings_ARM, err := (*workspace.ServerlessComputeSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		serverlessComputeSettings := *serverlessComputeSettings_ARM.(*arm.ServerlessComputeSettings)
		result.Properties.ServerlessComputeSettings = &serverlessComputeSettings
	}
	if workspace.ServiceManagedResourcesSettings != nil {
		serviceManagedResourcesSettings_ARM, err := (*workspace.ServiceManagedResourcesSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		serviceManagedResourcesSettings := *serviceManagedResourcesSettings_ARM.(*arm.ServiceManagedResourcesSettings)
		result.Properties.ServiceManagedResourcesSettings = &serviceManagedResourcesSettings
	}
	for _, item := range workspace.SharedPrivateLinkResources {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.SharedPrivateLinkResources = append(result.Properties.SharedPrivateLinkResources, *item_ARM.(*arm.SharedPrivateLinkResource))
	}
	if workspace.StorageAccountReference != nil {
		storageAccountARMID, err := resolved.ResolvedReferences.Lookup(*workspace.StorageAccountReference)
		if err != nil {
			return nil, err
		}
		storageAccount := storageAccountARMID
		result.Properties.StorageAccount = &storageAccount
	}
	if workspace.V1LegacyMode != nil {
		v1LegacyMode := *workspace.V1LegacyMode
		result.Properties.V1LegacyMode = &v1LegacyMode
	}
	if workspace.WorkspaceHubConfig != nil {
		workspaceHubConfig_ARM, err := (*workspace.WorkspaceHubConfig).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		workspaceHubConfig := *workspaceHubConfig_ARM.(*arm.WorkspaceHubConfig)
		result.Properties.WorkspaceHubConfig = &workspaceHubConfig
	}

	// Set property "Sku":
	if workspace.Sku != nil {
		sku_ARM, err := (*workspace.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := *sku_ARM.(*arm.Sku)
		result.Sku = &sku
	}

	// Set property "Tags":
	if workspace.Tags != nil {
		result.Tags = make(map[string]string, len(workspace.Tags))
		for key, value := range workspace.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (workspace *Workspace_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Workspace_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (workspace *Workspace_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Workspace_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Workspace_Spec, got %T", armInput)
	}

	// Set property "AllowPublicAccessWhenBehindVnet":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AllowPublicAccessWhenBehindVnet != nil {
			allowPublicAccessWhenBehindVnet := *typedInput.Properties.AllowPublicAccessWhenBehindVnet
			workspace.AllowPublicAccessWhenBehindVnet = &allowPublicAccessWhenBehindVnet
		}
	}

	// no assignment for property "ApplicationInsightsReference"

	// Set property "AssociatedWorkspaces":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.AssociatedWorkspaces {
			workspace.AssociatedWorkspaces = append(workspace.AssociatedWorkspaces, item)
		}
	}

	// Set property "AzureName":
	workspace.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// no assignment for property "ContainerRegistryReference"

	// Set property "Description":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Description != nil {
			description := *typedInput.Properties.Description
			workspace.Description = &description
		}
	}

	// Set property "DiscoveryUrl":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DiscoveryUrl != nil {
			discoveryUrl := *typedInput.Properties.DiscoveryUrl
			workspace.DiscoveryUrl = &discoveryUrl
		}
	}

	// Set property "EnableDataIsolation":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableDataIsolation != nil {
			enableDataIsolation := *typedInput.Properties.EnableDataIsolation
			workspace.EnableDataIsolation = &enableDataIsolation
		}
	}

	// Set property "Encryption":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Encryption != nil {
			var encryption1 EncryptionProperty
			err := encryption1.PopulateFromARM(owner, *typedInput.Properties.Encryption)
			if err != nil {
				return err
			}
			encryption := encryption1
			workspace.Encryption = &encryption
		}
	}

	// Set property "FeatureStoreSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FeatureStoreSettings != nil {
			var featureStoreSettings1 FeatureStoreSettings
			err := featureStoreSettings1.PopulateFromARM(owner, *typedInput.Properties.FeatureStoreSettings)
			if err != nil {
				return err
			}
			featureStoreSettings := featureStoreSettings1
			workspace.FeatureStoreSettings = &featureStoreSettings
		}
	}

	// Set property "FriendlyName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FriendlyName != nil {
			friendlyName := *typedInput.Properties.FriendlyName
			workspace.FriendlyName = &friendlyName
		}
	}

	// Set property "HbiWorkspace":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HbiWorkspace != nil {
			hbiWorkspace := *typedInput.Properties.HbiWorkspace
			workspace.HbiWorkspace = &hbiWorkspace
		}
	}

	// no assignment for property "HubResourceReference"

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedServiceIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		workspace.Identity = &identity
	}

	// Set property "ImageBuildCompute":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ImageBuildCompute != nil {
			imageBuildCompute := *typedInput.Properties.ImageBuildCompute
			workspace.ImageBuildCompute = &imageBuildCompute
		}
	}

	// no assignment for property "KeyVaultReference"

	// Set property "Kind":
	if typedInput.Kind != nil {
		kind := *typedInput.Kind
		workspace.Kind = &kind
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		workspace.Location = &location
	}

	// Set property "ManagedNetwork":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ManagedNetwork != nil {
			var managedNetwork1 ManagedNetworkSettings
			err := managedNetwork1.PopulateFromARM(owner, *typedInput.Properties.ManagedNetwork)
			if err != nil {
				return err
			}
			managedNetwork := managedNetwork1
			workspace.ManagedNetwork = &managedNetwork
		}
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	workspace.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// no assignment for property "PrimaryUserAssignedIdentityReference"

	// Set property "PublicNetworkAccess":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicNetworkAccess != nil {
			var temp string
			temp = string(*typedInput.Properties.PublicNetworkAccess)
			publicNetworkAccess := WorkspaceProperties_PublicNetworkAccess(temp)
			workspace.PublicNetworkAccess = &publicNetworkAccess
		}
	}

	// Set property "ServerlessComputeSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ServerlessComputeSettings != nil {
			var serverlessComputeSettings1 ServerlessComputeSettings
			err := serverlessComputeSettings1.PopulateFromARM(owner, *typedInput.Properties.ServerlessComputeSettings)
			if err != nil {
				return err
			}
			serverlessComputeSettings := serverlessComputeSettings1
			workspace.ServerlessComputeSettings = &serverlessComputeSettings
		}
	}

	// Set property "ServiceManagedResourcesSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ServiceManagedResourcesSettings != nil {
			var serviceManagedResourcesSettings1 ServiceManagedResourcesSettings
			err := serviceManagedResourcesSettings1.PopulateFromARM(owner, *typedInput.Properties.ServiceManagedResourcesSettings)
			if err != nil {
				return err
			}
			serviceManagedResourcesSettings := serviceManagedResourcesSettings1
			workspace.ServiceManagedResourcesSettings = &serviceManagedResourcesSettings
		}
	}

	// Set property "SharedPrivateLinkResources":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.SharedPrivateLinkResources {
			var item1 SharedPrivateLinkResource
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			workspace.SharedPrivateLinkResources = append(workspace.SharedPrivateLinkResources, item1)
		}
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 Sku
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		workspace.Sku = &sku
	}

	// no assignment for property "StorageAccountReference"

	// Set property "Tags":
	if typedInput.Tags != nil {
		workspace.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			workspace.Tags[key] = value
		}
	}

	// Set property "V1LegacyMode":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.V1LegacyMode != nil {
			v1LegacyMode := *typedInput.Properties.V1LegacyMode
			workspace.V1LegacyMode = &v1LegacyMode
		}
	}

	// Set property "WorkspaceHubConfig":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.WorkspaceHubConfig != nil {
			var workspaceHubConfig1 WorkspaceHubConfig
			err := workspaceHubConfig1.PopulateFromARM(owner, *typedInput.Properties.WorkspaceHubConfig)
			if err != nil {
				return err
			}
			workspaceHubConfig := workspaceHubConfig1
			workspace.WorkspaceHubConfig = &workspaceHubConfig
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &Workspace_Spec{}

// ConvertSpecFrom populates our Workspace_Spec from the provided source
func (workspace *Workspace_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.Workspace_Spec)
	if ok {
		// Populate our instance from source
		return workspace.AssignProperties_From_Workspace_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.Workspace_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = workspace.AssignProperties_From_Workspace_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our Workspace_Spec
func (workspace *Workspace_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.Workspace_Spec)
	if ok {
		// Populate destination from our instance
		return workspace.AssignProperties_To_Workspace_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.Workspace_Spec{}
	err := workspace.AssignProperties_To_Workspace_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_Workspace_Spec populates our Workspace_Spec from the provided source Workspace_Spec
func (workspace *Workspace_Spec) AssignProperties_From_Workspace_Spec(source *storage.Workspace_Spec) error {

	// AllowPublicAccessWhenBehindVnet
	if source.AllowPublicAccessWhenBehindVnet != nil {
		allowPublicAccessWhenBehindVnet := *source.AllowPublicAccessWhenBehindVnet
		workspace.AllowPublicAccessWhenBehindVnet = &allowPublicAccessWhenBehindVnet
	} else {
		workspace.AllowPublicAccessWhenBehindVnet = nil
	}

	// ApplicationInsightsReference
	if source.ApplicationInsightsReference != nil {
		applicationInsightsReference := source.ApplicationInsightsReference.Copy()
		workspace.ApplicationInsightsReference = &applicationInsightsReference
	} else {
		workspace.ApplicationInsightsReference = nil
	}

	// AssociatedWorkspaces
	workspace.AssociatedWorkspaces = genruntime.CloneSliceOfString(source.AssociatedWorkspaces)

	// AzureName
	workspace.AzureName = source.AzureName

	// ContainerRegistryReference
	if source.ContainerRegistryReference != nil {
		containerRegistryReference := source.ContainerRegistryReference.Copy()
		workspace.ContainerRegistryReference = &containerRegistryReference
	} else {
		workspace.ContainerRegistryReference = nil
	}

	// Description
	workspace.Description = genruntime.ClonePointerToString(source.Description)

	// DiscoveryUrl
	workspace.DiscoveryUrl = genruntime.ClonePointerToString(source.DiscoveryUrl)

	// EnableDataIsolation
	if source.EnableDataIsolation != nil {
		enableDataIsolation := *source.EnableDataIsolation
		workspace.EnableDataIsolation = &enableDataIsolation
	} else {
		workspace.EnableDataIsolation = nil
	}

	// Encryption
	if source.Encryption != nil {
		var encryption EncryptionProperty
		err := encryption.AssignProperties_From_EncryptionProperty(source.Encryption)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_EncryptionProperty() to populate field Encryption")
		}
		workspace.Encryption = &encryption
	} else {
		workspace.Encryption = nil
	}

	// FeatureStoreSettings
	if source.FeatureStoreSettings != nil {
		var featureStoreSetting FeatureStoreSettings
		err := featureStoreSetting.AssignProperties_From_FeatureStoreSettings(source.FeatureStoreSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_FeatureStoreSettings() to populate field FeatureStoreSettings")
		}
		workspace.FeatureStoreSettings = &featureStoreSetting
	} else {
		workspace.FeatureStoreSettings = nil
	}

	// FriendlyName
	workspace.FriendlyName = genruntime.ClonePointerToString(source.FriendlyName)

	// HbiWorkspace
	if source.HbiWorkspace != nil {
		hbiWorkspace := *source.HbiWorkspace
		workspace.HbiWorkspace = &hbiWorkspace
	} else {
		workspace.HbiWorkspace = nil
	}

	// HubResourceReference
	if source.HubResourceReference != nil {
		hubResourceReference := source.HubResourceReference.Copy()
		workspace.HubResourceReference = &hubResourceReference
	} else {
		workspace.HubResourceReference = nil
	}

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity
		err := identity.AssignProperties_From_ManagedServiceIdentity(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity() to populate field Identity")
		}
		workspace.Identity = &identity
	} else {
		workspace.Identity = nil
	}

	// ImageBuildCompute
	workspace.ImageBuildCompute = genruntime.ClonePointerToString(source.ImageBuildCompute)

	// KeyVaultReference
	if source.KeyVaultReference != nil {
		keyVaultReference := source.KeyVaultReference.Copy()
		workspace.KeyVaultReference = &keyVaultReference
	} else {
		workspace.KeyVaultReference = nil
	}

	// Kind
	workspace.Kind = genruntime.ClonePointerToString(source.Kind)

	// Location
	workspace.Location = genruntime.ClonePointerToString(source.Location)

	// ManagedNetwork
	if source.ManagedNetwork != nil {
		var managedNetwork ManagedNetworkSettings
		err := managedNetwork.AssignProperties_From_ManagedNetworkSettings(source.ManagedNetwork)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedNetworkSettings() to populate field ManagedNetwork")
		}
		workspace.ManagedNetwork = &managedNetwork
	} else {
		workspace.ManagedNetwork = nil
	}

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec WorkspaceOperatorSpec
		err := operatorSpec.AssignProperties_From_WorkspaceOperatorSpec(source.OperatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WorkspaceOperatorSpec() to populate field OperatorSpec")
		}
		workspace.OperatorSpec = &operatorSpec
	} else {
		workspace.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		workspace.Owner = &owner
	} else {
		workspace.Owner = nil
	}

	// PrimaryUserAssignedIdentityReference
	if source.PrimaryUserAssignedIdentityReference != nil {
		primaryUserAssignedIdentityReference := source.PrimaryUserAssignedIdentityReference.Copy()
		workspace.PrimaryUserAssignedIdentityReference = &primaryUserAssignedIdentityReference
	} else {
		workspace.PrimaryUserAssignedIdentityReference = nil
	}

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := *source.PublicNetworkAccess
		publicNetworkAccessTemp := genruntime.ToEnum(publicNetworkAccess, workspaceProperties_PublicNetworkAccess_Values)
		workspace.PublicNetworkAccess = &publicNetworkAccessTemp
	} else {
		workspace.PublicNetworkAccess = nil
	}

	// ServerlessComputeSettings
	if source.ServerlessComputeSettings != nil {
		var serverlessComputeSetting ServerlessComputeSettings
		err := serverlessComputeSetting.AssignProperties_From_ServerlessComputeSettings(source.ServerlessComputeSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ServerlessComputeSettings() to populate field ServerlessComputeSettings")
		}
		workspace.ServerlessComputeSettings = &serverlessComputeSetting
	} else {
		workspace.ServerlessComputeSettings = nil
	}

	// ServiceManagedResourcesSettings
	if source.ServiceManagedResourcesSettings != nil {
		var serviceManagedResourcesSetting ServiceManagedResourcesSettings
		err := serviceManagedResourcesSetting.AssignProperties_From_ServiceManagedResourcesSettings(source.ServiceManagedResourcesSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ServiceManagedResourcesSettings() to populate field ServiceManagedResourcesSettings")
		}
		workspace.ServiceManagedResourcesSettings = &serviceManagedResourcesSetting
	} else {
		workspace.ServiceManagedResourcesSettings = nil
	}

	// SharedPrivateLinkResources
	if source.SharedPrivateLinkResources != nil {
		sharedPrivateLinkResourceList := make([]SharedPrivateLinkResource, len(source.SharedPrivateLinkResources))
		for sharedPrivateLinkResourceIndex, sharedPrivateLinkResourceItem := range source.SharedPrivateLinkResources {
			// Shadow the loop variable to avoid aliasing
			sharedPrivateLinkResourceItem := sharedPrivateLinkResourceItem
			var sharedPrivateLinkResource SharedPrivateLinkResource
			err := sharedPrivateLinkResource.AssignProperties_From_SharedPrivateLinkResource(&sharedPrivateLinkResourceItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SharedPrivateLinkResource() to populate field SharedPrivateLinkResources")
			}
			sharedPrivateLinkResourceList[sharedPrivateLinkResourceIndex] = sharedPrivateLinkResource
		}
		workspace.SharedPrivateLinkResources = sharedPrivateLinkResourceList
	} else {
		workspace.SharedPrivateLinkResources = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.AssignProperties_From_Sku(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Sku() to populate field Sku")
		}
		workspace.Sku = &sku
	} else {
		workspace.Sku = nil
	}

	// StorageAccountReference
	if source.StorageAccountReference != nil {
		storageAccountReference := source.StorageAccountReference.Copy()
		workspace.StorageAccountReference = &storageAccountReference
	} else {
		workspace.StorageAccountReference = nil
	}

	// Tags
	workspace.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// V1LegacyMode
	if source.V1LegacyMode != nil {
		v1LegacyMode := *source.V1LegacyMode
		workspace.V1LegacyMode = &v1LegacyMode
	} else {
		workspace.V1LegacyMode = nil
	}

	// WorkspaceHubConfig
	if source.WorkspaceHubConfig != nil {
		var workspaceHubConfig WorkspaceHubConfig
		err := workspaceHubConfig.AssignProperties_From_WorkspaceHubConfig(source.WorkspaceHubConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WorkspaceHubConfig() to populate field WorkspaceHubConfig")
		}
		workspace.WorkspaceHubConfig = &workspaceHubConfig
	} else {
		workspace.WorkspaceHubConfig = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Workspace_Spec populates the provided destination Workspace_Spec from our Workspace_Spec
func (workspace *Workspace_Spec) AssignProperties_To_Workspace_Spec(destination *storage.Workspace_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowPublicAccessWhenBehindVnet
	if workspace.AllowPublicAccessWhenBehindVnet != nil {
		allowPublicAccessWhenBehindVnet := *workspace.AllowPublicAccessWhenBehindVnet
		destination.AllowPublicAccessWhenBehindVnet = &allowPublicAccessWhenBehindVnet
	} else {
		destination.AllowPublicAccessWhenBehindVnet = nil
	}

	// ApplicationInsightsReference
	if workspace.ApplicationInsightsReference != nil {
		applicationInsightsReference := workspace.ApplicationInsightsReference.Copy()
		destination.ApplicationInsightsReference = &applicationInsightsReference
	} else {
		destination.ApplicationInsightsReference = nil
	}

	// AssociatedWorkspaces
	destination.AssociatedWorkspaces = genruntime.CloneSliceOfString(workspace.AssociatedWorkspaces)

	// AzureName
	destination.AzureName = workspace.AzureName

	// ContainerRegistryReference
	if workspace.ContainerRegistryReference != nil {
		containerRegistryReference := workspace.ContainerRegistryReference.Copy()
		destination.ContainerRegistryReference = &containerRegistryReference
	} else {
		destination.ContainerRegistryReference = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(workspace.Description)

	// DiscoveryUrl
	destination.DiscoveryUrl = genruntime.ClonePointerToString(workspace.DiscoveryUrl)

	// EnableDataIsolation
	if workspace.EnableDataIsolation != nil {
		enableDataIsolation := *workspace.EnableDataIsolation
		destination.EnableDataIsolation = &enableDataIsolation
	} else {
		destination.EnableDataIsolation = nil
	}

	// Encryption
	if workspace.Encryption != nil {
		var encryption storage.EncryptionProperty
		err := workspace.Encryption.AssignProperties_To_EncryptionProperty(&encryption)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_EncryptionProperty() to populate field Encryption")
		}
		destination.Encryption = &encryption
	} else {
		destination.Encryption = nil
	}

	// FeatureStoreSettings
	if workspace.FeatureStoreSettings != nil {
		var featureStoreSetting storage.FeatureStoreSettings
		err := workspace.FeatureStoreSettings.AssignProperties_To_FeatureStoreSettings(&featureStoreSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_FeatureStoreSettings() to populate field FeatureStoreSettings")
		}
		destination.FeatureStoreSettings = &featureStoreSetting
	} else {
		destination.FeatureStoreSettings = nil
	}

	// FriendlyName
	destination.FriendlyName = genruntime.ClonePointerToString(workspace.FriendlyName)

	// HbiWorkspace
	if workspace.HbiWorkspace != nil {
		hbiWorkspace := *workspace.HbiWorkspace
		destination.HbiWorkspace = &hbiWorkspace
	} else {
		destination.HbiWorkspace = nil
	}

	// HubResourceReference
	if workspace.HubResourceReference != nil {
		hubResourceReference := workspace.HubResourceReference.Copy()
		destination.HubResourceReference = &hubResourceReference
	} else {
		destination.HubResourceReference = nil
	}

	// Identity
	if workspace.Identity != nil {
		var identity storage.ManagedServiceIdentity
		err := workspace.Identity.AssignProperties_To_ManagedServiceIdentity(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// ImageBuildCompute
	destination.ImageBuildCompute = genruntime.ClonePointerToString(workspace.ImageBuildCompute)

	// KeyVaultReference
	if workspace.KeyVaultReference != nil {
		keyVaultReference := workspace.KeyVaultReference.Copy()
		destination.KeyVaultReference = &keyVaultReference
	} else {
		destination.KeyVaultReference = nil
	}

	// Kind
	destination.Kind = genruntime.ClonePointerToString(workspace.Kind)

	// Location
	destination.Location = genruntime.ClonePointerToString(workspace.Location)

	// ManagedNetwork
	if workspace.ManagedNetwork != nil {
		var managedNetwork storage.ManagedNetworkSettings
		err := workspace.ManagedNetwork.AssignProperties_To_ManagedNetworkSettings(&managedNetwork)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedNetworkSettings() to populate field ManagedNetwork")
		}
		destination.ManagedNetwork = &managedNetwork
	} else {
		destination.ManagedNetwork = nil
	}

	// OperatorSpec
	if workspace.OperatorSpec != nil {
		var operatorSpec storage.WorkspaceOperatorSpec
		err := workspace.OperatorSpec.AssignProperties_To_WorkspaceOperatorSpec(&operatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WorkspaceOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = workspace.OriginalVersion()

	// Owner
	if workspace.Owner != nil {
		owner := workspace.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// PrimaryUserAssignedIdentityReference
	if workspace.PrimaryUserAssignedIdentityReference != nil {
		primaryUserAssignedIdentityReference := workspace.PrimaryUserAssignedIdentityReference.Copy()
		destination.PrimaryUserAssignedIdentityReference = &primaryUserAssignedIdentityReference
	} else {
		destination.PrimaryUserAssignedIdentityReference = nil
	}

	// PublicNetworkAccess
	if workspace.PublicNetworkAccess != nil {
		publicNetworkAccess := string(*workspace.PublicNetworkAccess)
		destination.PublicNetworkAccess = &publicNetworkAccess
	} else {
		destination.PublicNetworkAccess = nil
	}

	// ServerlessComputeSettings
	if workspace.ServerlessComputeSettings != nil {
		var serverlessComputeSetting storage.ServerlessComputeSettings
		err := workspace.ServerlessComputeSettings.AssignProperties_To_ServerlessComputeSettings(&serverlessComputeSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ServerlessComputeSettings() to populate field ServerlessComputeSettings")
		}
		destination.ServerlessComputeSettings = &serverlessComputeSetting
	} else {
		destination.ServerlessComputeSettings = nil
	}

	// ServiceManagedResourcesSettings
	if workspace.ServiceManagedResourcesSettings != nil {
		var serviceManagedResourcesSetting storage.ServiceManagedResourcesSettings
		err := workspace.ServiceManagedResourcesSettings.AssignProperties_To_ServiceManagedResourcesSettings(&serviceManagedResourcesSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ServiceManagedResourcesSettings() to populate field ServiceManagedResourcesSettings")
		}
		destination.ServiceManagedResourcesSettings = &serviceManagedResourcesSetting
	} else {
		destination.ServiceManagedResourcesSettings = nil
	}

	// SharedPrivateLinkResources
	if workspace.SharedPrivateLinkResources != nil {
		sharedPrivateLinkResourceList := make([]storage.SharedPrivateLinkResource, len(workspace.SharedPrivateLinkResources))
		for sharedPrivateLinkResourceIndex, sharedPrivateLinkResourceItem := range workspace.SharedPrivateLinkResources {
			// Shadow the loop variable to avoid aliasing
			sharedPrivateLinkResourceItem := sharedPrivateLinkResourceItem
			var sharedPrivateLinkResource storage.SharedPrivateLinkResource
			err := sharedPrivateLinkResourceItem.AssignProperties_To_SharedPrivateLinkResource(&sharedPrivateLinkResource)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SharedPrivateLinkResource() to populate field SharedPrivateLinkResources")
			}
			sharedPrivateLinkResourceList[sharedPrivateLinkResourceIndex] = sharedPrivateLinkResource
		}
		destination.SharedPrivateLinkResources = sharedPrivateLinkResourceList
	} else {
		destination.SharedPrivateLinkResources = nil
	}

	// Sku
	if workspace.Sku != nil {
		var sku storage.Sku
		err := workspace.Sku.AssignProperties_To_Sku(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Sku() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// StorageAccountReference
	if workspace.StorageAccountReference != nil {
		storageAccountReference := workspace.StorageAccountReference.Copy()
		destination.StorageAccountReference = &storageAccountReference
	} else {
		destination.StorageAccountReference = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(workspace.Tags)

	// V1LegacyMode
	if workspace.V1LegacyMode != nil {
		v1LegacyMode := *workspace.V1LegacyMode
		destination.V1LegacyMode = &v1LegacyMode
	} else {
		destination.V1LegacyMode = nil
	}

	// WorkspaceHubConfig
	if workspace.WorkspaceHubConfig != nil {
		var workspaceHubConfig storage.WorkspaceHubConfig
		err := workspace.WorkspaceHubConfig.AssignProperties_To_WorkspaceHubConfig(&workspaceHubConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WorkspaceHubConfig() to populate field WorkspaceHubConfig")
		}
		destination.WorkspaceHubConfig = &workspaceHubConfig
	} else {
		destination.WorkspaceHubConfig = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Workspace_STATUS populates our Workspace_Spec from the provided source Workspace_STATUS
func (workspace *Workspace_Spec) Initialize_From_Workspace_STATUS(source *Workspace_STATUS) error {

	// AllowPublicAccessWhenBehindVnet
	if source.AllowPublicAccessWhenBehindVnet != nil {
		allowPublicAccessWhenBehindVnet := *source.AllowPublicAccessWhenBehindVnet
		workspace.AllowPublicAccessWhenBehindVnet = &allowPublicAccessWhenBehindVnet
	} else {
		workspace.AllowPublicAccessWhenBehindVnet = nil
	}

	// AssociatedWorkspaces
	workspace.AssociatedWorkspaces = genruntime.CloneSliceOfString(source.AssociatedWorkspaces)

	// Description
	workspace.Description = genruntime.ClonePointerToString(source.Description)

	// DiscoveryUrl
	workspace.DiscoveryUrl = genruntime.ClonePointerToString(source.DiscoveryUrl)

	// EnableDataIsolation
	if source.EnableDataIsolation != nil {
		enableDataIsolation := *source.EnableDataIsolation
		workspace.EnableDataIsolation = &enableDataIsolation
	} else {
		workspace.EnableDataIsolation = nil
	}

	// Encryption
	if source.Encryption != nil {
		var encryption EncryptionProperty
		err := encryption.Initialize_From_EncryptionProperty_STATUS(source.Encryption)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_EncryptionProperty_STATUS() to populate field Encryption")
		}
		workspace.Encryption = &encryption
	} else {
		workspace.Encryption = nil
	}

	// FeatureStoreSettings
	if source.FeatureStoreSettings != nil {
		var featureStoreSetting FeatureStoreSettings
		err := featureStoreSetting.Initialize_From_FeatureStoreSettings_STATUS(source.FeatureStoreSettings)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_FeatureStoreSettings_STATUS() to populate field FeatureStoreSettings")
		}
		workspace.FeatureStoreSettings = &featureStoreSetting
	} else {
		workspace.FeatureStoreSettings = nil
	}

	// FriendlyName
	workspace.FriendlyName = genruntime.ClonePointerToString(source.FriendlyName)

	// HbiWorkspace
	if source.HbiWorkspace != nil {
		hbiWorkspace := *source.HbiWorkspace
		workspace.HbiWorkspace = &hbiWorkspace
	} else {
		workspace.HbiWorkspace = nil
	}

	// HubResourceReference
	if source.HubResourceId != nil {
		hubResourceReference := genruntime.CreateResourceReferenceFromARMID(*source.HubResourceId)
		workspace.HubResourceReference = &hubResourceReference
	} else {
		workspace.HubResourceReference = nil
	}

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity
		err := identity.Initialize_From_ManagedServiceIdentity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		workspace.Identity = &identity
	} else {
		workspace.Identity = nil
	}

	// ImageBuildCompute
	workspace.ImageBuildCompute = genruntime.ClonePointerToString(source.ImageBuildCompute)

	// Kind
	workspace.Kind = genruntime.ClonePointerToString(source.Kind)

	// Location
	workspace.Location = genruntime.ClonePointerToString(source.Location)

	// ManagedNetwork
	if source.ManagedNetwork != nil {
		var managedNetwork ManagedNetworkSettings
		err := managedNetwork.Initialize_From_ManagedNetworkSettings_STATUS(source.ManagedNetwork)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ManagedNetworkSettings_STATUS() to populate field ManagedNetwork")
		}
		workspace.ManagedNetwork = &managedNetwork
	} else {
		workspace.ManagedNetwork = nil
	}

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := genruntime.ToEnum(string(*source.PublicNetworkAccess), workspaceProperties_PublicNetworkAccess_Values)
		workspace.PublicNetworkAccess = &publicNetworkAccess
	} else {
		workspace.PublicNetworkAccess = nil
	}

	// ServerlessComputeSettings
	if source.ServerlessComputeSettings != nil {
		var serverlessComputeSetting ServerlessComputeSettings
		err := serverlessComputeSetting.Initialize_From_ServerlessComputeSettings_STATUS(source.ServerlessComputeSettings)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ServerlessComputeSettings_STATUS() to populate field ServerlessComputeSettings")
		}
		workspace.ServerlessComputeSettings = &serverlessComputeSetting
	} else {
		workspace.ServerlessComputeSettings = nil
	}

	// ServiceManagedResourcesSettings
	if source.ServiceManagedResourcesSettings != nil {
		var serviceManagedResourcesSetting ServiceManagedResourcesSettings
		err := serviceManagedResourcesSetting.Initialize_From_ServiceManagedResourcesSettings_STATUS(source.ServiceManagedResourcesSettings)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ServiceManagedResourcesSettings_STATUS() to populate field ServiceManagedResourcesSettings")
		}
		workspace.ServiceManagedResourcesSettings = &serviceManagedResourcesSetting
	} else {
		workspace.ServiceManagedResourcesSettings = nil
	}

	// SharedPrivateLinkResources
	if source.SharedPrivateLinkResources != nil {
		sharedPrivateLinkResourceList := make([]SharedPrivateLinkResource, len(source.SharedPrivateLinkResources))
		for sharedPrivateLinkResourceIndex, sharedPrivateLinkResourceItem := range source.SharedPrivateLinkResources {
			// Shadow the loop variable to avoid aliasing
			sharedPrivateLinkResourceItem := sharedPrivateLinkResourceItem
			var sharedPrivateLinkResource SharedPrivateLinkResource
			err := sharedPrivateLinkResource.Initialize_From_SharedPrivateLinkResource_STATUS(&sharedPrivateLinkResourceItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_SharedPrivateLinkResource_STATUS() to populate field SharedPrivateLinkResources")
			}
			sharedPrivateLinkResourceList[sharedPrivateLinkResourceIndex] = sharedPrivateLinkResource
		}
		workspace.SharedPrivateLinkResources = sharedPrivateLinkResourceList
	} else {
		workspace.SharedPrivateLinkResources = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.Initialize_From_Sku_STATUS(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_Sku_STATUS() to populate field Sku")
		}
		workspace.Sku = &sku
	} else {
		workspace.Sku = nil
	}

	// Tags
	workspace.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// V1LegacyMode
	if source.V1LegacyMode != nil {
		v1LegacyMode := *source.V1LegacyMode
		workspace.V1LegacyMode = &v1LegacyMode
	} else {
		workspace.V1LegacyMode = nil
	}

	// WorkspaceHubConfig
	if source.WorkspaceHubConfig != nil {
		var workspaceHubConfig WorkspaceHubConfig
		err := workspaceHubConfig.Initialize_From_WorkspaceHubConfig_STATUS(source.WorkspaceHubConfig)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_WorkspaceHubConfig_STATUS() to populate field WorkspaceHubConfig")
		}
		workspace.WorkspaceHubConfig = &workspaceHubConfig
	} else {
		workspace.WorkspaceHubConfig = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (workspace *Workspace_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (workspace *Workspace_Spec) SetAzureName(azureName string) { workspace.AzureName = azureName }

// An object that represents a machine learning workspace.
type Workspace_STATUS struct {
	// AllowPublicAccessWhenBehindVnet: The flag to indicate whether to allow public access when behind VNet.
	AllowPublicAccessWhenBehindVnet *bool `json:"allowPublicAccessWhenBehindVnet,omitempty"`

	// ApplicationInsights: ARM id of the application insights associated with this workspace.
	ApplicationInsights  *string  `json:"applicationInsights,omitempty"`
	AssociatedWorkspaces []string `json:"associatedWorkspaces,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// ContainerRegistry: ARM id of the container registry associated with this workspace.
	ContainerRegistry *string `json:"containerRegistry,omitempty"`

	// Description: The description of this workspace.
	Description *string `json:"description,omitempty"`

	// DiscoveryUrl: Url for the discovery service to identify regional endpoints for machine learning experimentation services
	DiscoveryUrl        *string `json:"discoveryUrl,omitempty"`
	EnableDataIsolation *bool   `json:"enableDataIsolation,omitempty"`

	// Encryption: The encryption settings of Azure ML workspace.
	Encryption *EncryptionProperty_STATUS `json:"encryption,omitempty"`

	// FeatureStoreSettings: Settings for feature store type workspace.
	FeatureStoreSettings *FeatureStoreSettings_STATUS `json:"featureStoreSettings,omitempty"`

	// FriendlyName: The friendly name for this workspace. This name in mutable
	FriendlyName *string `json:"friendlyName,omitempty"`

	// HbiWorkspace: The flag to signal HBI data in the workspace and reduce diagnostic data collected by the service
	HbiWorkspace  *bool   `json:"hbiWorkspace,omitempty"`
	HubResourceId *string `json:"hubResourceId,omitempty"`

	// Id: Fully qualified resource ID for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`

	// Identity: The identity of the resource.
	Identity *ManagedServiceIdentity_STATUS `json:"identity,omitempty"`

	// ImageBuildCompute: The compute name for image build
	ImageBuildCompute *string `json:"imageBuildCompute,omitempty"`

	// KeyVault: ARM id of the key vault associated with this workspace. This cannot be changed once the workspace has been
	// created
	KeyVault *string `json:"keyVault,omitempty"`
	Kind     *string `json:"kind,omitempty"`

	// Location: Specifies the location of the resource.
	Location *string `json:"location,omitempty"`

	// ManagedNetwork: Managed Network settings for a machine learning workspace.
	ManagedNetwork *ManagedNetworkSettings_STATUS `json:"managedNetwork,omitempty"`

	// MlFlowTrackingUri: The URI associated with this workspace that machine learning flow must point at to set up tracking.
	MlFlowTrackingUri *string `json:"mlFlowTrackingUri,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// NotebookInfo: The notebook info of Azure ML workspace.
	NotebookInfo *NotebookResourceInfo_STATUS `json:"notebookInfo,omitempty"`

	// PrimaryUserAssignedIdentity: The user assigned identity resource id that represents the workspace identity.
	PrimaryUserAssignedIdentity *string `json:"primaryUserAssignedIdentity,omitempty"`

	// PrivateEndpointConnections: The list of private endpoint connections in the workspace.
	PrivateEndpointConnections []PrivateEndpointConnection_STATUS `json:"privateEndpointConnections,omitempty"`

	// PrivateLinkCount: Count of private connections in the workspace
	PrivateLinkCount *int `json:"privateLinkCount,omitempty"`

	// ProvisioningState: The current deployment state of workspace resource. The provisioningState is to indicate states for
	// resource provisioning.
	ProvisioningState *WorkspaceProperties_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// PublicNetworkAccess: Whether requests from Public Network are allowed.
	PublicNetworkAccess *WorkspaceProperties_PublicNetworkAccess_STATUS `json:"publicNetworkAccess,omitempty"`

	// ServerlessComputeSettings: Settings for serverless compute created in the workspace
	ServerlessComputeSettings *ServerlessComputeSettings_STATUS `json:"serverlessComputeSettings,omitempty"`

	// ServiceManagedResourcesSettings: The service managed resource settings.
	ServiceManagedResourcesSettings *ServiceManagedResourcesSettings_STATUS `json:"serviceManagedResourcesSettings,omitempty"`

	// ServiceProvisionedResourceGroup: The name of the managed resource group created by workspace RP in customer subscription
	// if the workspace is CMK workspace
	ServiceProvisionedResourceGroup *string `json:"serviceProvisionedResourceGroup,omitempty"`

	// SharedPrivateLinkResources: The list of shared private link resources in this workspace.
	SharedPrivateLinkResources []SharedPrivateLinkResource_STATUS `json:"sharedPrivateLinkResources,omitempty"`

	// Sku: The sku of the workspace.
	Sku *Sku_STATUS `json:"sku,omitempty"`

	// StorageAccount: ARM id of the storage account associated with this workspace. This cannot be changed once the workspace
	// has been created
	StorageAccount *string `json:"storageAccount,omitempty"`

	// StorageHnsEnabled: If the storage associated with the workspace has hierarchical namespace(HNS) enabled.
	StorageHnsEnabled *bool `json:"storageHnsEnabled,omitempty"`

	// SystemData: Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData_STATUS `json:"systemData,omitempty"`

	// Tags: Contains resource tags defined as key/value pairs.
	Tags map[string]string `json:"tags,omitempty"`

	// TenantId: The tenant id associated with this workspace.
	TenantId *string `json:"tenantId,omitempty"`

	// Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`

	// V1LegacyMode: Enabling v1_legacy_mode may prevent you from using features provided by the v2 API.
	V1LegacyMode *bool `json:"v1LegacyMode,omitempty"`

	// WorkspaceHubConfig: WorkspaceHub's configuration object.
	WorkspaceHubConfig *WorkspaceHubConfig_STATUS `json:"workspaceHubConfig,omitempty"`

	// WorkspaceId: The immutable id associated with this workspace.
	WorkspaceId *string `json:"workspaceId,omitempty"`
}

var _ genruntime.ConvertibleStatus = &Workspace_STATUS{}

// ConvertStatusFrom populates our Workspace_STATUS from the provided source
func (workspace *Workspace_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.Workspace_STATUS)
	if ok {
		// Populate our instance from source
		return workspace.AssignProperties_From_Workspace_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.Workspace_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = workspace.AssignProperties_From_Workspace_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our Workspace_STATUS
func (workspace *Workspace_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.Workspace_STATUS)
	if ok {
		// Populate destination from our instance
		return workspace.AssignProperties_To_Workspace_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.Workspace_STATUS{}
	err := workspace.AssignProperties_To_Workspace_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &Workspace_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (workspace *Workspace_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Workspace_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (workspace *Workspace_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Workspace_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Workspace_STATUS, got %T", armInput)
	}

	// Set property "AllowPublicAccessWhenBehindVnet":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AllowPublicAccessWhenBehindVnet != nil {
			allowPublicAccessWhenBehindVnet := *typedInput.Properties.AllowPublicAccessWhenBehindVnet
			workspace.AllowPublicAccessWhenBehindVnet = &allowPublicAccessWhenBehindVnet
		}
	}

	// Set property "ApplicationInsights":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ApplicationInsights != nil {
			applicationInsights := *typedInput.Properties.ApplicationInsights
			workspace.ApplicationInsights = &applicationInsights
		}
	}

	// Set property "AssociatedWorkspaces":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.AssociatedWorkspaces {
			workspace.AssociatedWorkspaces = append(workspace.AssociatedWorkspaces, item)
		}
	}

	// no assignment for property "Conditions"

	// Set property "ContainerRegistry":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ContainerRegistry != nil {
			containerRegistry := *typedInput.Properties.ContainerRegistry
			workspace.ContainerRegistry = &containerRegistry
		}
	}

	// Set property "Description":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Description != nil {
			description := *typedInput.Properties.Description
			workspace.Description = &description
		}
	}

	// Set property "DiscoveryUrl":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DiscoveryUrl != nil {
			discoveryUrl := *typedInput.Properties.DiscoveryUrl
			workspace.DiscoveryUrl = &discoveryUrl
		}
	}

	// Set property "EnableDataIsolation":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableDataIsolation != nil {
			enableDataIsolation := *typedInput.Properties.EnableDataIsolation
			workspace.EnableDataIsolation = &enableDataIsolation
		}
	}

	// Set property "Encryption":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Encryption != nil {
			var encryption1 EncryptionProperty_STATUS
			err := encryption1.PopulateFromARM(owner, *typedInput.Properties.Encryption)
			if err != nil {
				return err
			}
			encryption := encryption1
			workspace.Encryption = &encryption
		}
	}

	// Set property "FeatureStoreSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FeatureStoreSettings != nil {
			var featureStoreSettings1 FeatureStoreSettings_STATUS
			err := featureStoreSettings1.PopulateFromARM(owner, *typedInput.Properties.FeatureStoreSettings)
			if err != nil {
				return err
			}
			featureStoreSettings := featureStoreSettings1
			workspace.FeatureStoreSettings = &featureStoreSettings
		}
	}

	// Set property "FriendlyName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FriendlyName != nil {
			friendlyName := *typedInput.Properties.FriendlyName
			workspace.FriendlyName = &friendlyName
		}
	}

	// Set property "HbiWorkspace":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HbiWorkspace != nil {
			hbiWorkspace := *typedInput.Properties.HbiWorkspace
			workspace.HbiWorkspace = &hbiWorkspace
		}
	}

	// Set property "HubResourceId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HubResourceId != nil {
			hubResourceId := *typedInput.Properties.HubResourceId
			workspace.HubResourceId = &hubResourceId
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		workspace.Id = &id
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedServiceIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		workspace.Identity = &identity
	}

	// Set property "ImageBuildCompute":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ImageBuildCompute != nil {
			imageBuildCompute := *typedInput.Properties.ImageBuildCompute
			workspace.ImageBuildCompute = &imageBuildCompute
		}
	}

	// Set property "KeyVault":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.KeyVault != nil {
			keyVault := *typedInput.Properties.KeyVault
			workspace.KeyVault = &keyVault
		}
	}

	// Set property "Kind":
	if typedInput.Kind != nil {
		kind := *typedInput.Kind
		workspace.Kind = &kind
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		workspace.Location = &location
	}

	// Set property "ManagedNetwork":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ManagedNetwork != nil {
			var managedNetwork1 ManagedNetworkSettings_STATUS
			err := managedNetwork1.PopulateFromARM(owner, *typedInput.Properties.ManagedNetwork)
			if err != nil {
				return err
			}
			managedNetwork := managedNetwork1
			workspace.ManagedNetwork = &managedNetwork
		}
	}

	// Set property "MlFlowTrackingUri":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MlFlowTrackingUri != nil {
			mlFlowTrackingUri := *typedInput.Properties.MlFlowTrackingUri
			workspace.MlFlowTrackingUri = &mlFlowTrackingUri
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		workspace.Name = &name
	}

	// Set property "NotebookInfo":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NotebookInfo != nil {
			var notebookInfo1 NotebookResourceInfo_STATUS
			err := notebookInfo1.PopulateFromARM(owner, *typedInput.Properties.NotebookInfo)
			if err != nil {
				return err
			}
			notebookInfo := notebookInfo1
			workspace.NotebookInfo = &notebookInfo
		}
	}

	// Set property "PrimaryUserAssignedIdentity":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrimaryUserAssignedIdentity != nil {
			primaryUserAssignedIdentity := *typedInput.Properties.PrimaryUserAssignedIdentity
			workspace.PrimaryUserAssignedIdentity = &primaryUserAssignedIdentity
		}
	}

	// Set property "PrivateEndpointConnections":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.PrivateEndpointConnections {
			var item1 PrivateEndpointConnection_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			workspace.PrivateEndpointConnections = append(workspace.PrivateEndpointConnections, item1)
		}
	}

	// Set property "PrivateLinkCount":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateLinkCount != nil {
			privateLinkCount := *typedInput.Properties.PrivateLinkCount
			workspace.PrivateLinkCount = &privateLinkCount
		}
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			var temp string
			temp = string(*typedInput.Properties.ProvisioningState)
			provisioningState := WorkspaceProperties_ProvisioningState_STATUS(temp)
			workspace.ProvisioningState = &provisioningState
		}
	}

	// Set property "PublicNetworkAccess":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicNetworkAccess != nil {
			var temp string
			temp = string(*typedInput.Properties.PublicNetworkAccess)
			publicNetworkAccess := WorkspaceProperties_PublicNetworkAccess_STATUS(temp)
			workspace.PublicNetworkAccess = &publicNetworkAccess
		}
	}

	// Set property "ServerlessComputeSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ServerlessComputeSettings != nil {
			var serverlessComputeSettings1 ServerlessComputeSettings_STATUS
			err := serverlessComputeSettings1.PopulateFromARM(owner, *typedInput.Properties.ServerlessComputeSettings)
			if err != nil {
				return err
			}
			serverlessComputeSettings := serverlessComputeSettings1
			workspace.ServerlessComputeSettings = &serverlessComputeSettings
		}
	}

	// Set property "ServiceManagedResourcesSettings":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ServiceManagedResourcesSettings != nil {
			var serviceManagedResourcesSettings1 ServiceManagedResourcesSettings_STATUS
			err := serviceManagedResourcesSettings1.PopulateFromARM(owner, *typedInput.Properties.ServiceManagedResourcesSettings)
			if err != nil {
				return err
			}
			serviceManagedResourcesSettings := serviceManagedResourcesSettings1
			workspace.ServiceManagedResourcesSettings = &serviceManagedResourcesSettings
		}
	}

	// Set property "ServiceProvisionedResourceGroup":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ServiceProvisionedResourceGroup != nil {
			serviceProvisionedResourceGroup := *typedInput.Properties.ServiceProvisionedResourceGroup
			workspace.ServiceProvisionedResourceGroup = &serviceProvisionedResourceGroup
		}
	}

	// Set property "SharedPrivateLinkResources":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.SharedPrivateLinkResources {
			var item1 SharedPrivateLinkResource_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			workspace.SharedPrivateLinkResources = append(workspace.SharedPrivateLinkResources, item1)
		}
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 Sku_STATUS
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		workspace.Sku = &sku
	}

	// Set property "StorageAccount":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.StorageAccount != nil {
			storageAccount := *typedInput.Properties.StorageAccount
			workspace.StorageAccount = &storageAccount
		}
	}

	// Set property "StorageHnsEnabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.StorageHnsEnabled != nil {
			storageHnsEnabled := *typedInput.Properties.StorageHnsEnabled
			workspace.StorageHnsEnabled = &storageHnsEnabled
		}
	}

	// Set property "SystemData":
	if typedInput.SystemData != nil {
		var systemData1 SystemData_STATUS
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		workspace.SystemData = &systemData
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		workspace.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			workspace.Tags[key] = value
		}
	}

	// Set property "TenantId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TenantId != nil {
			tenantId := *typedInput.Properties.TenantId
			workspace.TenantId = &tenantId
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		workspace.Type = &typeVar
	}

	// Set property "V1LegacyMode":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.V1LegacyMode != nil {
			v1LegacyMode := *typedInput.Properties.V1LegacyMode
			workspace.V1LegacyMode = &v1LegacyMode
		}
	}

	// Set property "WorkspaceHubConfig":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.WorkspaceHubConfig != nil {
			var workspaceHubConfig1 WorkspaceHubConfig_STATUS
			err := workspaceHubConfig1.PopulateFromARM(owner, *typedInput.Properties.WorkspaceHubConfig)
			if err != nil {
				return err
			}
			workspaceHubConfig := workspaceHubConfig1
			workspace.WorkspaceHubConfig = &workspaceHubConfig
		}
	}

	// Set property "WorkspaceId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.WorkspaceId != nil {
			workspaceId := *typedInput.Properties.WorkspaceId
			workspace.WorkspaceId = &workspaceId
		}
	}

	// No error
	return nil
}

// AssignProperties_From_Workspace_STATUS populates our Workspace_STATUS from the provided source Workspace_STATUS
func (workspace *Workspace_STATUS) AssignProperties_From_Workspace_STATUS(source *storage.Workspace_STATUS) error {

	// AllowPublicAccessWhenBehindVnet
	if source.AllowPublicAccessWhenBehindVnet != nil {
		allowPublicAccessWhenBehindVnet := *source.AllowPublicAccessWhenBehindVnet
		workspace.AllowPublicAccessWhenBehindVnet = &allowPublicAccessWhenBehindVnet
	} else {
		workspace.AllowPublicAccessWhenBehindVnet = nil
	}

	// ApplicationInsights
	workspace.ApplicationInsights = genruntime.ClonePointerToString(source.ApplicationInsights)

	// AssociatedWorkspaces
	workspace.AssociatedWorkspaces = genruntime.CloneSliceOfString(source.AssociatedWorkspaces)

	// Conditions
	workspace.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// ContainerRegistry
	workspace.ContainerRegistry = genruntime.ClonePointerToString(source.ContainerRegistry)

	// Description
	workspace.Description = genruntime.ClonePointerToString(source.Description)

	// DiscoveryUrl
	workspace.DiscoveryUrl = genruntime.ClonePointerToString(source.DiscoveryUrl)

	// EnableDataIsolation
	if source.EnableDataIsolation != nil {
		enableDataIsolation := *source.EnableDataIsolation
		workspace.EnableDataIsolation = &enableDataIsolation
	} else {
		workspace.EnableDataIsolation = nil
	}

	// Encryption
	if source.Encryption != nil {
		var encryption EncryptionProperty_STATUS
		err := encryption.AssignProperties_From_EncryptionProperty_STATUS(source.Encryption)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_EncryptionProperty_STATUS() to populate field Encryption")
		}
		workspace.Encryption = &encryption
	} else {
		workspace.Encryption = nil
	}

	// FeatureStoreSettings
	if source.FeatureStoreSettings != nil {
		var featureStoreSetting FeatureStoreSettings_STATUS
		err := featureStoreSetting.AssignProperties_From_FeatureStoreSettings_STATUS(source.FeatureStoreSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_FeatureStoreSettings_STATUS() to populate field FeatureStoreSettings")
		}
		workspace.FeatureStoreSettings = &featureStoreSetting
	} else {
		workspace.FeatureStoreSettings = nil
	}

	// FriendlyName
	workspace.FriendlyName = genruntime.ClonePointerToString(source.FriendlyName)

	// HbiWorkspace
	if source.HbiWorkspace != nil {
		hbiWorkspace := *source.HbiWorkspace
		workspace.HbiWorkspace = &hbiWorkspace
	} else {
		workspace.HbiWorkspace = nil
	}

	// HubResourceId
	workspace.HubResourceId = genruntime.ClonePointerToString(source.HubResourceId)

	// Id
	workspace.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity_STATUS
		err := identity.AssignProperties_From_ManagedServiceIdentity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		workspace.Identity = &identity
	} else {
		workspace.Identity = nil
	}

	// ImageBuildCompute
	workspace.ImageBuildCompute = genruntime.ClonePointerToString(source.ImageBuildCompute)

	// KeyVault
	workspace.KeyVault = genruntime.ClonePointerToString(source.KeyVault)

	// Kind
	workspace.Kind = genruntime.ClonePointerToString(source.Kind)

	// Location
	workspace.Location = genruntime.ClonePointerToString(source.Location)

	// ManagedNetwork
	if source.ManagedNetwork != nil {
		var managedNetwork ManagedNetworkSettings_STATUS
		err := managedNetwork.AssignProperties_From_ManagedNetworkSettings_STATUS(source.ManagedNetwork)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedNetworkSettings_STATUS() to populate field ManagedNetwork")
		}
		workspace.ManagedNetwork = &managedNetwork
	} else {
		workspace.ManagedNetwork = nil
	}

	// MlFlowTrackingUri
	workspace.MlFlowTrackingUri = genruntime.ClonePointerToString(source.MlFlowTrackingUri)

	// Name
	workspace.Name = genruntime.ClonePointerToString(source.Name)

	// NotebookInfo
	if source.NotebookInfo != nil {
		var notebookInfo NotebookResourceInfo_STATUS
		err := notebookInfo.AssignProperties_From_NotebookResourceInfo_STATUS(source.NotebookInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_NotebookResourceInfo_STATUS() to populate field NotebookInfo")
		}
		workspace.NotebookInfo = &notebookInfo
	} else {
		workspace.NotebookInfo = nil
	}

	// PrimaryUserAssignedIdentity
	workspace.PrimaryUserAssignedIdentity = genruntime.ClonePointerToString(source.PrimaryUserAssignedIdentity)

	// PrivateEndpointConnections
	if source.PrivateEndpointConnections != nil {
		privateEndpointConnectionList := make([]PrivateEndpointConnection_STATUS, len(source.PrivateEndpointConnections))
		for privateEndpointConnectionIndex, privateEndpointConnectionItem := range source.PrivateEndpointConnections {
			// Shadow the loop variable to avoid aliasing
			privateEndpointConnectionItem := privateEndpointConnectionItem
			var privateEndpointConnection PrivateEndpointConnection_STATUS
			err := privateEndpointConnection.AssignProperties_From_PrivateEndpointConnection_STATUS(&privateEndpointConnectionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_PrivateEndpointConnection_STATUS() to populate field PrivateEndpointConnections")
			}
			privateEndpointConnectionList[privateEndpointConnectionIndex] = privateEndpointConnection
		}
		workspace.PrivateEndpointConnections = privateEndpointConnectionList
	} else {
		workspace.PrivateEndpointConnections = nil
	}

	// PrivateLinkCount
	workspace.PrivateLinkCount = genruntime.ClonePointerToInt(source.PrivateLinkCount)

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, workspaceProperties_ProvisioningState_STATUS_Values)
		workspace.ProvisioningState = &provisioningStateTemp
	} else {
		workspace.ProvisioningState = nil
	}

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := *source.PublicNetworkAccess
		publicNetworkAccessTemp := genruntime.ToEnum(publicNetworkAccess, workspaceProperties_PublicNetworkAccess_STATUS_Values)
		workspace.PublicNetworkAccess = &publicNetworkAccessTemp
	} else {
		workspace.PublicNetworkAccess = nil
	}

	// ServerlessComputeSettings
	if source.ServerlessComputeSettings != nil {
		var serverlessComputeSetting ServerlessComputeSettings_STATUS
		err := serverlessComputeSetting.AssignProperties_From_ServerlessComputeSettings_STATUS(source.ServerlessComputeSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ServerlessComputeSettings_STATUS() to populate field ServerlessComputeSettings")
		}
		workspace.ServerlessComputeSettings = &serverlessComputeSetting
	} else {
		workspace.ServerlessComputeSettings = nil
	}

	// ServiceManagedResourcesSettings
	if source.ServiceManagedResourcesSettings != nil {
		var serviceManagedResourcesSetting ServiceManagedResourcesSettings_STATUS
		err := serviceManagedResourcesSetting.AssignProperties_From_ServiceManagedResourcesSettings_STATUS(source.ServiceManagedResourcesSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ServiceManagedResourcesSettings_STATUS() to populate field ServiceManagedResourcesSettings")
		}
		workspace.ServiceManagedResourcesSettings = &serviceManagedResourcesSetting
	} else {
		workspace.ServiceManagedResourcesSettings = nil
	}

	// ServiceProvisionedResourceGroup
	workspace.ServiceProvisionedResourceGroup = genruntime.ClonePointerToString(source.ServiceProvisionedResourceGroup)

	// SharedPrivateLinkResources
	if source.SharedPrivateLinkResources != nil {
		sharedPrivateLinkResourceList := make([]SharedPrivateLinkResource_STATUS, len(source.SharedPrivateLinkResources))
		for sharedPrivateLinkResourceIndex, sharedPrivateLinkResourceItem := range source.SharedPrivateLinkResources {
			// Shadow the loop variable to avoid aliasing
			sharedPrivateLinkResourceItem := sharedPrivateLinkResourceItem
			var sharedPrivateLinkResource SharedPrivateLinkResource_STATUS
			err := sharedPrivateLinkResource.AssignProperties_From_SharedPrivateLinkResource_STATUS(&sharedPrivateLinkResourceItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SharedPrivateLinkResource_STATUS() to populate field SharedPrivateLinkResources")
			}
			sharedPrivateLinkResourceList[sharedPrivateLinkResourceIndex] = sharedPrivateLinkResource
		}
		workspace.SharedPrivateLinkResources = sharedPrivateLinkResourceList
	} else {
		workspace.SharedPrivateLinkResources = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku_STATUS
		err := sku.AssignProperties_From_Sku_STATUS(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Sku_STATUS() to populate field Sku")
		}
		workspace.Sku = &sku
	} else {
		workspace.Sku = nil
	}

	// StorageAccount
	workspace.StorageAccount = genruntime.ClonePointerToString(source.StorageAccount)

	// StorageHnsEnabled
	if source.StorageHnsEnabled != nil {
		storageHnsEnabled := *source.StorageHnsEnabled
		workspace.StorageHnsEnabled = &storageHnsEnabled
	} else {
		workspace.StorageHnsEnabled = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		workspace.SystemData = &systemDatum
	} else {
		workspace.SystemData = nil
	}

	// Tags
	workspace.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TenantId
	workspace.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	workspace.Type = genruntime.ClonePointerToString(source.Type)

	// V1LegacyMode
	if source.V1LegacyMode != nil {
		v1LegacyMode := *source.V1LegacyMode
		workspace.V1LegacyMode = &v1LegacyMode
	} else {
		workspace.V1LegacyMode = nil
	}

	// WorkspaceHubConfig
	if source.WorkspaceHubConfig != nil {
		var workspaceHubConfig WorkspaceHubConfig_STATUS
		err := workspaceHubConfig.AssignProperties_From_WorkspaceHubConfig_STATUS(source.WorkspaceHubConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WorkspaceHubConfig_STATUS() to populate field WorkspaceHubConfig")
		}
		workspace.WorkspaceHubConfig = &workspaceHubConfig
	} else {
		workspace.WorkspaceHubConfig = nil
	}

	// WorkspaceId
	workspace.WorkspaceId = genruntime.ClonePointerToString(source.WorkspaceId)

	// No error
	return nil
}

// AssignProperties_To_Workspace_STATUS populates the provided destination Workspace_STATUS from our Workspace_STATUS
func (workspace *Workspace_STATUS) AssignProperties_To_Workspace_STATUS(destination *storage.Workspace_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AllowPublicAccessWhenBehindVnet
	if workspace.AllowPublicAccessWhenBehindVnet != nil {
		allowPublicAccessWhenBehindVnet := *workspace.AllowPublicAccessWhenBehindVnet
		destination.AllowPublicAccessWhenBehindVnet = &allowPublicAccessWhenBehindVnet
	} else {
		destination.AllowPublicAccessWhenBehindVnet = nil
	}

	// ApplicationInsights
	destination.ApplicationInsights = genruntime.ClonePointerToString(workspace.ApplicationInsights)

	// AssociatedWorkspaces
	destination.AssociatedWorkspaces = genruntime.CloneSliceOfString(workspace.AssociatedWorkspaces)

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(workspace.Conditions)

	// ContainerRegistry
	destination.ContainerRegistry = genruntime.ClonePointerToString(workspace.ContainerRegistry)

	// Description
	destination.Description = genruntime.ClonePointerToString(workspace.Description)

	// DiscoveryUrl
	destination.DiscoveryUrl = genruntime.ClonePointerToString(workspace.DiscoveryUrl)

	// EnableDataIsolation
	if workspace.EnableDataIsolation != nil {
		enableDataIsolation := *workspace.EnableDataIsolation
		destination.EnableDataIsolation = &enableDataIsolation
	} else {
		destination.EnableDataIsolation = nil
	}

	// Encryption
	if workspace.Encryption != nil {
		var encryption storage.EncryptionProperty_STATUS
		err := workspace.Encryption.AssignProperties_To_EncryptionProperty_STATUS(&encryption)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_EncryptionProperty_STATUS() to populate field Encryption")
		}
		destination.Encryption = &encryption
	} else {
		destination.Encryption = nil
	}

	// FeatureStoreSettings
	if workspace.FeatureStoreSettings != nil {
		var featureStoreSetting storage.FeatureStoreSettings_STATUS
		err := workspace.FeatureStoreSettings.AssignProperties_To_FeatureStoreSettings_STATUS(&featureStoreSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_FeatureStoreSettings_STATUS() to populate field FeatureStoreSettings")
		}
		destination.FeatureStoreSettings = &featureStoreSetting
	} else {
		destination.FeatureStoreSettings = nil
	}

	// FriendlyName
	destination.FriendlyName = genruntime.ClonePointerToString(workspace.FriendlyName)

	// HbiWorkspace
	if workspace.HbiWorkspace != nil {
		hbiWorkspace := *workspace.HbiWorkspace
		destination.HbiWorkspace = &hbiWorkspace
	} else {
		destination.HbiWorkspace = nil
	}

	// HubResourceId
	destination.HubResourceId = genruntime.ClonePointerToString(workspace.HubResourceId)

	// Id
	destination.Id = genruntime.ClonePointerToString(workspace.Id)

	// Identity
	if workspace.Identity != nil {
		var identity storage.ManagedServiceIdentity_STATUS
		err := workspace.Identity.AssignProperties_To_ManagedServiceIdentity_STATUS(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// ImageBuildCompute
	destination.ImageBuildCompute = genruntime.ClonePointerToString(workspace.ImageBuildCompute)

	// KeyVault
	destination.KeyVault = genruntime.ClonePointerToString(workspace.KeyVault)

	// Kind
	destination.Kind = genruntime.ClonePointerToString(workspace.Kind)

	// Location
	destination.Location = genruntime.ClonePointerToString(workspace.Location)

	// ManagedNetwork
	if workspace.ManagedNetwork != nil {
		var managedNetwork storage.ManagedNetworkSettings_STATUS
		err := workspace.ManagedNetwork.AssignProperties_To_ManagedNetworkSettings_STATUS(&managedNetwork)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedNetworkSettings_STATUS() to populate field ManagedNetwork")
		}
		destination.ManagedNetwork = &managedNetwork
	} else {
		destination.ManagedNetwork = nil
	}

	// MlFlowTrackingUri
	destination.MlFlowTrackingUri = genruntime.ClonePointerToString(workspace.MlFlowTrackingUri)

	// Name
	destination.Name = genruntime.ClonePointerToString(workspace.Name)

	// NotebookInfo
	if workspace.NotebookInfo != nil {
		var notebookInfo storage.NotebookResourceInfo_STATUS
		err := workspace.NotebookInfo.AssignProperties_To_NotebookResourceInfo_STATUS(&notebookInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_NotebookResourceInfo_STATUS() to populate field NotebookInfo")
		}
		destination.NotebookInfo = &notebookInfo
	} else {
		destination.NotebookInfo = nil
	}

	// PrimaryUserAssignedIdentity
	destination.PrimaryUserAssignedIdentity = genruntime.ClonePointerToString(workspace.PrimaryUserAssignedIdentity)

	// PrivateEndpointConnections
	if workspace.PrivateEndpointConnections != nil {
		privateEndpointConnectionList := make([]storage.PrivateEndpointConnection_STATUS, len(workspace.PrivateEndpointConnections))
		for privateEndpointConnectionIndex, privateEndpointConnectionItem := range workspace.PrivateEndpointConnections {
			// Shadow the loop variable to avoid aliasing
			privateEndpointConnectionItem := privateEndpointConnectionItem
			var privateEndpointConnection storage.PrivateEndpointConnection_STATUS
			err := privateEndpointConnectionItem.AssignProperties_To_PrivateEndpointConnection_STATUS(&privateEndpointConnection)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_PrivateEndpointConnection_STATUS() to populate field PrivateEndpointConnections")
			}
			privateEndpointConnectionList[privateEndpointConnectionIndex] = privateEndpointConnection
		}
		destination.PrivateEndpointConnections = privateEndpointConnectionList
	} else {
		destination.PrivateEndpointConnections = nil
	}

	// PrivateLinkCount
	destination.PrivateLinkCount = genruntime.ClonePointerToInt(workspace.PrivateLinkCount)

	// ProvisioningState
	if workspace.ProvisioningState != nil {
		provisioningState := string(*workspace.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// PublicNetworkAccess
	if workspace.PublicNetworkAccess != nil {
		publicNetworkAccess := string(*workspace.PublicNetworkAccess)
		destination.PublicNetworkAccess = &publicNetworkAccess
	} else {
		destination.PublicNetworkAccess = nil
	}

	// ServerlessComputeSettings
	if workspace.ServerlessComputeSettings != nil {
		var serverlessComputeSetting storage.ServerlessComputeSettings_STATUS
		err := workspace.ServerlessComputeSettings.AssignProperties_To_ServerlessComputeSettings_STATUS(&serverlessComputeSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ServerlessComputeSettings_STATUS() to populate field ServerlessComputeSettings")
		}
		destination.ServerlessComputeSettings = &serverlessComputeSetting
	} else {
		destination.ServerlessComputeSettings = nil
	}

	// ServiceManagedResourcesSettings
	if workspace.ServiceManagedResourcesSettings != nil {
		var serviceManagedResourcesSetting storage.ServiceManagedResourcesSettings_STATUS
		err := workspace.ServiceManagedResourcesSettings.AssignProperties_To_ServiceManagedResourcesSettings_STATUS(&serviceManagedResourcesSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ServiceManagedResourcesSettings_STATUS() to populate field ServiceManagedResourcesSettings")
		}
		destination.ServiceManagedResourcesSettings = &serviceManagedResourcesSetting
	} else {
		destination.ServiceManagedResourcesSettings = nil
	}

	// ServiceProvisionedResourceGroup
	destination.ServiceProvisionedResourceGroup = genruntime.ClonePointerToString(workspace.ServiceProvisionedResourceGroup)

	// SharedPrivateLinkResources
	if workspace.SharedPrivateLinkResources != nil {
		sharedPrivateLinkResourceList := make([]storage.SharedPrivateLinkResource_STATUS, len(workspace.SharedPrivateLinkResources))
		for sharedPrivateLinkResourceIndex, sharedPrivateLinkResourceItem := range workspace.SharedPrivateLinkResources {
			// Shadow the loop variable to avoid aliasing
			sharedPrivateLinkResourceItem := sharedPrivateLinkResourceItem
			var sharedPrivateLinkResource storage.SharedPrivateLinkResource_STATUS
			err := sharedPrivateLinkResourceItem.AssignProperties_To_SharedPrivateLinkResource_STATUS(&sharedPrivateLinkResource)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SharedPrivateLinkResource_STATUS() to populate field SharedPrivateLinkResources")
			}
			sharedPrivateLinkResourceList[sharedPrivateLinkResourceIndex] = sharedPrivateLinkResource
		}
		destination.SharedPrivateLinkResources = sharedPrivateLinkResourceList
	} else {
		destination.SharedPrivateLinkResources = nil
	}

	// Sku
	if workspace.Sku != nil {
		var sku storage.Sku_STATUS
		err := workspace.Sku.AssignProperties_To_Sku_STATUS(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Sku_STATUS() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// StorageAccount
	destination.StorageAccount = genruntime.ClonePointerToString(workspace.StorageAccount)

	// StorageHnsEnabled
	if workspace.StorageHnsEnabled != nil {
		storageHnsEnabled := *workspace.StorageHnsEnabled
		destination.StorageHnsEnabled = &storageHnsEnabled
	} else {
		destination.StorageHnsEnabled = nil
	}

	// SystemData
	if workspace.SystemData != nil {
		var systemDatum storage.SystemData_STATUS
		err := workspace.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(workspace.Tags)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(workspace.TenantId)

	// Type
	destination.Type = genruntime.ClonePointerToString(workspace.Type)

	// V1LegacyMode
	if workspace.V1LegacyMode != nil {
		v1LegacyMode := *workspace.V1LegacyMode
		destination.V1LegacyMode = &v1LegacyMode
	} else {
		destination.V1LegacyMode = nil
	}

	// WorkspaceHubConfig
	if workspace.WorkspaceHubConfig != nil {
		var workspaceHubConfig storage.WorkspaceHubConfig_STATUS
		err := workspace.WorkspaceHubConfig.AssignProperties_To_WorkspaceHubConfig_STATUS(&workspaceHubConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WorkspaceHubConfig_STATUS() to populate field WorkspaceHubConfig")
		}
		destination.WorkspaceHubConfig = &workspaceHubConfig
	} else {
		destination.WorkspaceHubConfig = nil
	}

	// WorkspaceId
	destination.WorkspaceId = genruntime.ClonePointerToString(workspace.WorkspaceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type EncryptionProperty struct {
	// Identity: The identity that will be used to access the key vault for encryption at rest.
	Identity *IdentityForCmk `json:"identity,omitempty"`

	// +kubebuilder:validation:Required
	// KeyVaultProperties: Customer Key vault properties.
	KeyVaultProperties *EncryptionKeyVaultProperties `json:"keyVaultProperties,omitempty"`
}

var _ genruntime.ARMTransformer = &EncryptionProperty{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (property *EncryptionProperty) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if property == nil {
		return nil, nil
	}
	result := &arm.EncryptionProperty{}

	// Set property "Identity":
	if property.Identity != nil {
		identity_ARM, err := (*property.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*arm.IdentityForCmk)
		result.Identity = &identity
	}

	// Set property "KeyVaultProperties":
	if property.KeyVaultProperties != nil {
		keyVaultProperties_ARM, err := (*property.KeyVaultProperties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		keyVaultProperties := *keyVaultProperties_ARM.(*arm.EncryptionKeyVaultProperties)
		result.KeyVaultProperties = &keyVaultProperties
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (property *EncryptionProperty) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EncryptionProperty{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (property *EncryptionProperty) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EncryptionProperty)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EncryptionProperty, got %T", armInput)
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 IdentityForCmk
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		property.Identity = &identity
	}

	// Set property "KeyVaultProperties":
	if typedInput.KeyVaultProperties != nil {
		var keyVaultProperties1 EncryptionKeyVaultProperties
		err := keyVaultProperties1.PopulateFromARM(owner, *typedInput.KeyVaultProperties)
		if err != nil {
			return err
		}
		keyVaultProperties := keyVaultProperties1
		property.KeyVaultProperties = &keyVaultProperties
	}

	// No error
	return nil
}

// AssignProperties_From_EncryptionProperty populates our EncryptionProperty from the provided source EncryptionProperty
func (property *EncryptionProperty) AssignProperties_From_EncryptionProperty(source *storage.EncryptionProperty) error {

	// Identity
	if source.Identity != nil {
		var identity IdentityForCmk
		err := identity.AssignProperties_From_IdentityForCmk(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_IdentityForCmk() to populate field Identity")
		}
		property.Identity = &identity
	} else {
		property.Identity = nil
	}

	// KeyVaultProperties
	if source.KeyVaultProperties != nil {
		var keyVaultProperty EncryptionKeyVaultProperties
		err := keyVaultProperty.AssignProperties_From_EncryptionKeyVaultProperties(source.KeyVaultProperties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_EncryptionKeyVaultProperties() to populate field KeyVaultProperties")
		}
		property.KeyVaultProperties = &keyVaultProperty
	} else {
		property.KeyVaultProperties = nil
	}

	// No error
	return nil
}

// AssignProperties_To_EncryptionProperty populates the provided destination EncryptionProperty from our EncryptionProperty
func (property *EncryptionProperty) AssignProperties_To_EncryptionProperty(destination *storage.EncryptionProperty) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Identity
	if property.Identity != nil {
		var identity storage.IdentityForCmk
		err := property.Identity.AssignProperties_To_IdentityForCmk(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_IdentityForCmk() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// KeyVaultProperties
	if property.KeyVaultProperties != nil {
		var keyVaultProperty storage.EncryptionKeyVaultProperties
		err := property.KeyVaultProperties.AssignProperties_To_EncryptionKeyVaultProperties(&keyVaultProperty)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_EncryptionKeyVaultProperties() to populate field KeyVaultProperties")
		}
		destination.KeyVaultProperties = &keyVaultProperty
	} else {
		destination.KeyVaultProperties = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_EncryptionProperty_STATUS populates our EncryptionProperty from the provided source EncryptionProperty_STATUS
func (property *EncryptionProperty) Initialize_From_EncryptionProperty_STATUS(source *EncryptionProperty_STATUS) error {

	// Identity
	if source.Identity != nil {
		var identity IdentityForCmk
		err := identity.Initialize_From_IdentityForCmk_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_IdentityForCmk_STATUS() to populate field Identity")
		}
		property.Identity = &identity
	} else {
		property.Identity = nil
	}

	// KeyVaultProperties
	if source.KeyVaultProperties != nil {
		var keyVaultProperty EncryptionKeyVaultProperties
		err := keyVaultProperty.Initialize_From_EncryptionKeyVaultProperties_STATUS(source.KeyVaultProperties)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_EncryptionKeyVaultProperties_STATUS() to populate field KeyVaultProperties")
		}
		property.KeyVaultProperties = &keyVaultProperty
	} else {
		property.KeyVaultProperties = nil
	}

	// No error
	return nil
}

type EncryptionProperty_STATUS struct {
	// Identity: The identity that will be used to access the key vault for encryption at rest.
	Identity *IdentityForCmk_STATUS `json:"identity,omitempty"`

	// KeyVaultProperties: Customer Key vault properties.
	KeyVaultProperties *EncryptionKeyVaultProperties_STATUS `json:"keyVaultProperties,omitempty"`

	// Status: Indicates whether or not the encryption is enabled for the workspace.
	Status *EncryptionProperty_Status_STATUS `json:"status,omitempty"`
}

var _ genruntime.FromARMConverter = &EncryptionProperty_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (property *EncryptionProperty_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EncryptionProperty_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (property *EncryptionProperty_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EncryptionProperty_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EncryptionProperty_STATUS, got %T", armInput)
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 IdentityForCmk_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		property.Identity = &identity
	}

	// Set property "KeyVaultProperties":
	if typedInput.KeyVaultProperties != nil {
		var keyVaultProperties1 EncryptionKeyVaultProperties_STATUS
		err := keyVaultProperties1.PopulateFromARM(owner, *typedInput.KeyVaultProperties)
		if err != nil {
			return err
		}
		keyVaultProperties := keyVaultProperties1
		property.KeyVaultProperties = &keyVaultProperties
	}

	// Set property "Status":
	if typedInput.Status != nil {
		var temp string
		temp = string(*typedInput.Status)
		status := EncryptionProperty_Status_STATUS(temp)
		property.Status = &status
	}

	// No error
	return nil
}

// AssignProperties_From_EncryptionProperty_STATUS populates our EncryptionProperty_STATUS from the provided source EncryptionProperty_STATUS
func (property *EncryptionProperty_STATUS) AssignProperties_From_EncryptionProperty_STATUS(source *storage.EncryptionProperty_STATUS) error {

	// Identity
	if source.Identity != nil {
		var identity IdentityForCmk_STATUS
		err := identity.AssignProperties_From_IdentityForCmk_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_IdentityForCmk_STATUS() to populate field Identity")
		}
		property.Identity = &identity
	} else {
		property.Identity = nil
	}

	// KeyVaultProperties
	if source.KeyVaultProperties != nil {
		var keyVaultProperty EncryptionKeyVaultProperties_STATUS
		err := keyVaultProperty.AssignProperties_From_EncryptionKeyVaultProperties_STATUS(source.KeyVaultProperties)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_EncryptionKeyVaultProperties_STATUS() to populate field KeyVaultProperties")
		}
		property.KeyVaultProperties = &keyVaultProperty
	} else {
		property.KeyVaultProperties = nil
	}

	// Status
	if source.Status != nil {
		status := *source.Status
		statusTemp := genruntime.ToEnum(status, encryptionProperty_Status_STATUS_Values)
		property.Status = &statusTemp
	} else {
		property.Status = nil
	}

	// No error
	return nil
}

// AssignProperties_To_EncryptionProperty_STATUS populates the provided destination EncryptionProperty_STATUS from our EncryptionProperty_STATUS
func (property *EncryptionProperty_STATUS) AssignProperties_To_EncryptionProperty_STATUS(destination *storage.EncryptionProperty_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Identity
	if property.Identity != nil {
		var identity storage.IdentityForCmk_STATUS
		err := property.Identity.AssignProperties_To_IdentityForCmk_STATUS(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_IdentityForCmk_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// KeyVaultProperties
	if property.KeyVaultProperties != nil {
		var keyVaultProperty storage.EncryptionKeyVaultProperties_STATUS
		err := property.KeyVaultProperties.AssignProperties_To_EncryptionKeyVaultProperties_STATUS(&keyVaultProperty)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_EncryptionKeyVaultProperties_STATUS() to populate field KeyVaultProperties")
		}
		destination.KeyVaultProperties = &keyVaultProperty
	} else {
		destination.KeyVaultProperties = nil
	}

	// Status
	if property.Status != nil {
		status := string(*property.Status)
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Settings for feature store type workspace.
type FeatureStoreSettings struct {
	// ComputeRuntime: Compute runtime config for feature store type workspace.
	ComputeRuntime             *ComputeRuntimeDto `json:"computeRuntime,omitempty"`
	OfflineStoreConnectionName *string            `json:"offlineStoreConnectionName,omitempty"`
	OnlineStoreConnectionName  *string            `json:"onlineStoreConnectionName,omitempty"`
}

var _ genruntime.ARMTransformer = &FeatureStoreSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *FeatureStoreSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.FeatureStoreSettings{}

	// Set property "ComputeRuntime":
	if settings.ComputeRuntime != nil {
		computeRuntime_ARM, err := (*settings.ComputeRuntime).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		computeRuntime := *computeRuntime_ARM.(*arm.ComputeRuntimeDto)
		result.ComputeRuntime = &computeRuntime
	}

	// Set property "OfflineStoreConnectionName":
	if settings.OfflineStoreConnectionName != nil {
		offlineStoreConnectionName := *settings.OfflineStoreConnectionName
		result.OfflineStoreConnectionName = &offlineStoreConnectionName
	}

	// Set property "OnlineStoreConnectionName":
	if settings.OnlineStoreConnectionName != nil {
		onlineStoreConnectionName := *settings.OnlineStoreConnectionName
		result.OnlineStoreConnectionName = &onlineStoreConnectionName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *FeatureStoreSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FeatureStoreSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *FeatureStoreSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FeatureStoreSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FeatureStoreSettings, got %T", armInput)
	}

	// Set property "ComputeRuntime":
	if typedInput.ComputeRuntime != nil {
		var computeRuntime1 ComputeRuntimeDto
		err := computeRuntime1.PopulateFromARM(owner, *typedInput.ComputeRuntime)
		if err != nil {
			return err
		}
		computeRuntime := computeRuntime1
		settings.ComputeRuntime = &computeRuntime
	}

	// Set property "OfflineStoreConnectionName":
	if typedInput.OfflineStoreConnectionName != nil {
		offlineStoreConnectionName := *typedInput.OfflineStoreConnectionName
		settings.OfflineStoreConnectionName = &offlineStoreConnectionName
	}

	// Set property "OnlineStoreConnectionName":
	if typedInput.OnlineStoreConnectionName != nil {
		onlineStoreConnectionName := *typedInput.OnlineStoreConnectionName
		settings.OnlineStoreConnectionName = &onlineStoreConnectionName
	}

	// No error
	return nil
}

// AssignProperties_From_FeatureStoreSettings populates our FeatureStoreSettings from the provided source FeatureStoreSettings
func (settings *FeatureStoreSettings) AssignProperties_From_FeatureStoreSettings(source *storage.FeatureStoreSettings) error {

	// ComputeRuntime
	if source.ComputeRuntime != nil {
		var computeRuntime ComputeRuntimeDto
		err := computeRuntime.AssignProperties_From_ComputeRuntimeDto(source.ComputeRuntime)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ComputeRuntimeDto() to populate field ComputeRuntime")
		}
		settings.ComputeRuntime = &computeRuntime
	} else {
		settings.ComputeRuntime = nil
	}

	// OfflineStoreConnectionName
	settings.OfflineStoreConnectionName = genruntime.ClonePointerToString(source.OfflineStoreConnectionName)

	// OnlineStoreConnectionName
	settings.OnlineStoreConnectionName = genruntime.ClonePointerToString(source.OnlineStoreConnectionName)

	// No error
	return nil
}

// AssignProperties_To_FeatureStoreSettings populates the provided destination FeatureStoreSettings from our FeatureStoreSettings
func (settings *FeatureStoreSettings) AssignProperties_To_FeatureStoreSettings(destination *storage.FeatureStoreSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeRuntime
	if settings.ComputeRuntime != nil {
		var computeRuntime storage.ComputeRuntimeDto
		err := settings.ComputeRuntime.AssignProperties_To_ComputeRuntimeDto(&computeRuntime)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ComputeRuntimeDto() to populate field ComputeRuntime")
		}
		destination.ComputeRuntime = &computeRuntime
	} else {
		destination.ComputeRuntime = nil
	}

	// OfflineStoreConnectionName
	destination.OfflineStoreConnectionName = genruntime.ClonePointerToString(settings.OfflineStoreConnectionName)

	// OnlineStoreConnectionName
	destination.OnlineStoreConnectionName = genruntime.ClonePointerToString(settings.OnlineStoreConnectionName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_FeatureStoreSettings_STATUS populates our FeatureStoreSettings from the provided source FeatureStoreSettings_STATUS
func (settings *FeatureStoreSettings) Initialize_From_FeatureStoreSettings_STATUS(source *FeatureStoreSettings_STATUS) error {

	// ComputeRuntime
	if source.ComputeRuntime != nil {
		var computeRuntime ComputeRuntimeDto
		err := computeRuntime.Initialize_From_ComputeRuntimeDto_STATUS(source.ComputeRuntime)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ComputeRuntimeDto_STATUS() to populate field ComputeRuntime")
		}
		settings.ComputeRuntime = &computeRuntime
	} else {
		settings.ComputeRuntime = nil
	}

	// OfflineStoreConnectionName
	settings.OfflineStoreConnectionName = genruntime.ClonePointerToString(source.OfflineStoreConnectionName)

	// OnlineStoreConnectionName
	settings.OnlineStoreConnectionName = genruntime.ClonePointerToString(source.OnlineStoreConnectionName)

	// No error
	return nil
}

// Settings for feature store type workspace.
type FeatureStoreSettings_STATUS struct {
	// ComputeRuntime: Compute runtime config for feature store type workspace.
	ComputeRuntime             *ComputeRuntimeDto_STATUS `json:"computeRuntime,omitempty"`
	OfflineStoreConnectionName *string                   `json:"offlineStoreConnectionName,omitempty"`
	OnlineStoreConnectionName  *string                   `json:"onlineStoreConnectionName,omitempty"`
}

var _ genruntime.FromARMConverter = &FeatureStoreSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *FeatureStoreSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FeatureStoreSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *FeatureStoreSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FeatureStoreSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FeatureStoreSettings_STATUS, got %T", armInput)
	}

	// Set property "ComputeRuntime":
	if typedInput.ComputeRuntime != nil {
		var computeRuntime1 ComputeRuntimeDto_STATUS
		err := computeRuntime1.PopulateFromARM(owner, *typedInput.ComputeRuntime)
		if err != nil {
			return err
		}
		computeRuntime := computeRuntime1
		settings.ComputeRuntime = &computeRuntime
	}

	// Set property "OfflineStoreConnectionName":
	if typedInput.OfflineStoreConnectionName != nil {
		offlineStoreConnectionName := *typedInput.OfflineStoreConnectionName
		settings.OfflineStoreConnectionName = &offlineStoreConnectionName
	}

	// Set property "OnlineStoreConnectionName":
	if typedInput.OnlineStoreConnectionName != nil {
		onlineStoreConnectionName := *typedInput.OnlineStoreConnectionName
		settings.OnlineStoreConnectionName = &onlineStoreConnectionName
	}

	// No error
	return nil
}

// AssignProperties_From_FeatureStoreSettings_STATUS populates our FeatureStoreSettings_STATUS from the provided source FeatureStoreSettings_STATUS
func (settings *FeatureStoreSettings_STATUS) AssignProperties_From_FeatureStoreSettings_STATUS(source *storage.FeatureStoreSettings_STATUS) error {

	// ComputeRuntime
	if source.ComputeRuntime != nil {
		var computeRuntime ComputeRuntimeDto_STATUS
		err := computeRuntime.AssignProperties_From_ComputeRuntimeDto_STATUS(source.ComputeRuntime)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ComputeRuntimeDto_STATUS() to populate field ComputeRuntime")
		}
		settings.ComputeRuntime = &computeRuntime
	} else {
		settings.ComputeRuntime = nil
	}

	// OfflineStoreConnectionName
	settings.OfflineStoreConnectionName = genruntime.ClonePointerToString(source.OfflineStoreConnectionName)

	// OnlineStoreConnectionName
	settings.OnlineStoreConnectionName = genruntime.ClonePointerToString(source.OnlineStoreConnectionName)

	// No error
	return nil
}

// AssignProperties_To_FeatureStoreSettings_STATUS populates the provided destination FeatureStoreSettings_STATUS from our FeatureStoreSettings_STATUS
func (settings *FeatureStoreSettings_STATUS) AssignProperties_To_FeatureStoreSettings_STATUS(destination *storage.FeatureStoreSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComputeRuntime
	if settings.ComputeRuntime != nil {
		var computeRuntime storage.ComputeRuntimeDto_STATUS
		err := settings.ComputeRuntime.AssignProperties_To_ComputeRuntimeDto_STATUS(&computeRuntime)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ComputeRuntimeDto_STATUS() to populate field ComputeRuntime")
		}
		destination.ComputeRuntime = &computeRuntime
	} else {
		destination.ComputeRuntime = nil
	}

	// OfflineStoreConnectionName
	destination.OfflineStoreConnectionName = genruntime.ClonePointerToString(settings.OfflineStoreConnectionName)

	// OnlineStoreConnectionName
	destination.OnlineStoreConnectionName = genruntime.ClonePointerToString(settings.OnlineStoreConnectionName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Managed Network settings for a machine learning workspace.
type ManagedNetworkSettings struct {
	// IsolationMode: Isolation mode for the managed network of a machine learning workspace.
	IsolationMode *IsolationMode          `json:"isolationMode,omitempty"`
	OutboundRules map[string]OutboundRule `json:"outboundRules,omitempty"`

	// Status: Status of the Provisioning for the managed network of a machine learning workspace.
	Status *ManagedNetworkProvisionStatus `json:"status,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedNetworkSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *ManagedNetworkSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.ManagedNetworkSettings{}

	// Set property "IsolationMode":
	if settings.IsolationMode != nil {
		var temp string
		temp = string(*settings.IsolationMode)
		isolationMode := arm.IsolationMode(temp)
		result.IsolationMode = &isolationMode
	}

	// Set property "OutboundRules":
	if settings.OutboundRules != nil {
		result.OutboundRules = make(map[string]arm.OutboundRule, len(settings.OutboundRules))
		for key, value := range settings.OutboundRules {
			value_ARM, err := value.ConvertToARM(resolved)
			if err != nil {
				return nil, err
			}
			result.OutboundRules[key] = *value_ARM.(*arm.OutboundRule)
		}
	}

	// Set property "Status":
	if settings.Status != nil {
		status_ARM, err := (*settings.Status).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		status := *status_ARM.(*arm.ManagedNetworkProvisionStatus)
		result.Status = &status
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *ManagedNetworkSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedNetworkSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *ManagedNetworkSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedNetworkSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedNetworkSettings, got %T", armInput)
	}

	// Set property "IsolationMode":
	if typedInput.IsolationMode != nil {
		var temp string
		temp = string(*typedInput.IsolationMode)
		isolationMode := IsolationMode(temp)
		settings.IsolationMode = &isolationMode
	}

	// Set property "OutboundRules":
	if typedInput.OutboundRules != nil {
		settings.OutboundRules = make(map[string]OutboundRule, len(typedInput.OutboundRules))
		for key, value := range typedInput.OutboundRules {
			var value1 OutboundRule
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			settings.OutboundRules[key] = value1
		}
	}

	// Set property "Status":
	if typedInput.Status != nil {
		var status1 ManagedNetworkProvisionStatus
		err := status1.PopulateFromARM(owner, *typedInput.Status)
		if err != nil {
			return err
		}
		status := status1
		settings.Status = &status
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedNetworkSettings populates our ManagedNetworkSettings from the provided source ManagedNetworkSettings
func (settings *ManagedNetworkSettings) AssignProperties_From_ManagedNetworkSettings(source *storage.ManagedNetworkSettings) error {

	// IsolationMode
	if source.IsolationMode != nil {
		isolationMode := *source.IsolationMode
		isolationModeTemp := genruntime.ToEnum(isolationMode, isolationMode_Values)
		settings.IsolationMode = &isolationModeTemp
	} else {
		settings.IsolationMode = nil
	}

	// OutboundRules
	if source.OutboundRules != nil {
		outboundRuleMap := make(map[string]OutboundRule, len(source.OutboundRules))
		for outboundRuleKey, outboundRuleValue := range source.OutboundRules {
			// Shadow the loop variable to avoid aliasing
			outboundRuleValue := outboundRuleValue
			var outboundRule OutboundRule
			err := outboundRule.AssignProperties_From_OutboundRule(&outboundRuleValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_OutboundRule() to populate field OutboundRules")
			}
			outboundRuleMap[outboundRuleKey] = outboundRule
		}
		settings.OutboundRules = outboundRuleMap
	} else {
		settings.OutboundRules = nil
	}

	// Status
	if source.Status != nil {
		var status ManagedNetworkProvisionStatus
		err := status.AssignProperties_From_ManagedNetworkProvisionStatus(source.Status)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedNetworkProvisionStatus() to populate field Status")
		}
		settings.Status = &status
	} else {
		settings.Status = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedNetworkSettings populates the provided destination ManagedNetworkSettings from our ManagedNetworkSettings
func (settings *ManagedNetworkSettings) AssignProperties_To_ManagedNetworkSettings(destination *storage.ManagedNetworkSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IsolationMode
	if settings.IsolationMode != nil {
		isolationMode := string(*settings.IsolationMode)
		destination.IsolationMode = &isolationMode
	} else {
		destination.IsolationMode = nil
	}

	// OutboundRules
	if settings.OutboundRules != nil {
		outboundRuleMap := make(map[string]storage.OutboundRule, len(settings.OutboundRules))
		for outboundRuleKey, outboundRuleValue := range settings.OutboundRules {
			// Shadow the loop variable to avoid aliasing
			outboundRuleValue := outboundRuleValue
			var outboundRule storage.OutboundRule
			err := outboundRuleValue.AssignProperties_To_OutboundRule(&outboundRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_OutboundRule() to populate field OutboundRules")
			}
			outboundRuleMap[outboundRuleKey] = outboundRule
		}
		destination.OutboundRules = outboundRuleMap
	} else {
		destination.OutboundRules = nil
	}

	// Status
	if settings.Status != nil {
		var status storage.ManagedNetworkProvisionStatus
		err := settings.Status.AssignProperties_To_ManagedNetworkProvisionStatus(&status)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedNetworkProvisionStatus() to populate field Status")
		}
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ManagedNetworkSettings_STATUS populates our ManagedNetworkSettings from the provided source ManagedNetworkSettings_STATUS
func (settings *ManagedNetworkSettings) Initialize_From_ManagedNetworkSettings_STATUS(source *ManagedNetworkSettings_STATUS) error {

	// IsolationMode
	if source.IsolationMode != nil {
		isolationMode := genruntime.ToEnum(string(*source.IsolationMode), isolationMode_Values)
		settings.IsolationMode = &isolationMode
	} else {
		settings.IsolationMode = nil
	}

	// OutboundRules
	if source.OutboundRules != nil {
		outboundRuleMap := make(map[string]OutboundRule, len(source.OutboundRules))
		for outboundRuleKey, outboundRuleValue := range source.OutboundRules {
			// Shadow the loop variable to avoid aliasing
			outboundRuleValue := outboundRuleValue
			var outboundRule OutboundRule
			err := outboundRule.Initialize_From_OutboundRule_STATUS(&outboundRuleValue)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_OutboundRule_STATUS() to populate field OutboundRules")
			}
			outboundRuleMap[outboundRuleKey] = outboundRule
		}
		settings.OutboundRules = outboundRuleMap
	} else {
		settings.OutboundRules = nil
	}

	// Status
	if source.Status != nil {
		var status ManagedNetworkProvisionStatus
		err := status.Initialize_From_ManagedNetworkProvisionStatus_STATUS(source.Status)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ManagedNetworkProvisionStatus_STATUS() to populate field Status")
		}
		settings.Status = &status
	} else {
		settings.Status = nil
	}

	// No error
	return nil
}

// Managed Network settings for a machine learning workspace.
type ManagedNetworkSettings_STATUS struct {
	// IsolationMode: Isolation mode for the managed network of a machine learning workspace.
	IsolationMode *IsolationMode_STATUS          `json:"isolationMode,omitempty"`
	NetworkId     *string                        `json:"networkId,omitempty"`
	OutboundRules map[string]OutboundRule_STATUS `json:"outboundRules,omitempty"`

	// Status: Status of the Provisioning for the managed network of a machine learning workspace.
	Status *ManagedNetworkProvisionStatus_STATUS `json:"status,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedNetworkSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *ManagedNetworkSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedNetworkSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *ManagedNetworkSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedNetworkSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedNetworkSettings_STATUS, got %T", armInput)
	}

	// Set property "IsolationMode":
	if typedInput.IsolationMode != nil {
		var temp string
		temp = string(*typedInput.IsolationMode)
		isolationMode := IsolationMode_STATUS(temp)
		settings.IsolationMode = &isolationMode
	}

	// Set property "NetworkId":
	if typedInput.NetworkId != nil {
		networkId := *typedInput.NetworkId
		settings.NetworkId = &networkId
	}

	// Set property "OutboundRules":
	if typedInput.OutboundRules != nil {
		settings.OutboundRules = make(map[string]OutboundRule_STATUS, len(typedInput.OutboundRules))
		for key, value := range typedInput.OutboundRules {
			var value1 OutboundRule_STATUS
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			settings.OutboundRules[key] = value1
		}
	}

	// Set property "Status":
	if typedInput.Status != nil {
		var status1 ManagedNetworkProvisionStatus_STATUS
		err := status1.PopulateFromARM(owner, *typedInput.Status)
		if err != nil {
			return err
		}
		status := status1
		settings.Status = &status
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedNetworkSettings_STATUS populates our ManagedNetworkSettings_STATUS from the provided source ManagedNetworkSettings_STATUS
func (settings *ManagedNetworkSettings_STATUS) AssignProperties_From_ManagedNetworkSettings_STATUS(source *storage.ManagedNetworkSettings_STATUS) error {

	// IsolationMode
	if source.IsolationMode != nil {
		isolationMode := *source.IsolationMode
		isolationModeTemp := genruntime.ToEnum(isolationMode, isolationMode_STATUS_Values)
		settings.IsolationMode = &isolationModeTemp
	} else {
		settings.IsolationMode = nil
	}

	// NetworkId
	settings.NetworkId = genruntime.ClonePointerToString(source.NetworkId)

	// OutboundRules
	if source.OutboundRules != nil {
		outboundRuleMap := make(map[string]OutboundRule_STATUS, len(source.OutboundRules))
		for outboundRuleKey, outboundRuleValue := range source.OutboundRules {
			// Shadow the loop variable to avoid aliasing
			outboundRuleValue := outboundRuleValue
			var outboundRule OutboundRule_STATUS
			err := outboundRule.AssignProperties_From_OutboundRule_STATUS(&outboundRuleValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_OutboundRule_STATUS() to populate field OutboundRules")
			}
			outboundRuleMap[outboundRuleKey] = outboundRule
		}
		settings.OutboundRules = outboundRuleMap
	} else {
		settings.OutboundRules = nil
	}

	// Status
	if source.Status != nil {
		var status ManagedNetworkProvisionStatus_STATUS
		err := status.AssignProperties_From_ManagedNetworkProvisionStatus_STATUS(source.Status)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedNetworkProvisionStatus_STATUS() to populate field Status")
		}
		settings.Status = &status
	} else {
		settings.Status = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedNetworkSettings_STATUS populates the provided destination ManagedNetworkSettings_STATUS from our ManagedNetworkSettings_STATUS
func (settings *ManagedNetworkSettings_STATUS) AssignProperties_To_ManagedNetworkSettings_STATUS(destination *storage.ManagedNetworkSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IsolationMode
	if settings.IsolationMode != nil {
		isolationMode := string(*settings.IsolationMode)
		destination.IsolationMode = &isolationMode
	} else {
		destination.IsolationMode = nil
	}

	// NetworkId
	destination.NetworkId = genruntime.ClonePointerToString(settings.NetworkId)

	// OutboundRules
	if settings.OutboundRules != nil {
		outboundRuleMap := make(map[string]storage.OutboundRule_STATUS, len(settings.OutboundRules))
		for outboundRuleKey, outboundRuleValue := range settings.OutboundRules {
			// Shadow the loop variable to avoid aliasing
			outboundRuleValue := outboundRuleValue
			var outboundRule storage.OutboundRule_STATUS
			err := outboundRuleValue.AssignProperties_To_OutboundRule_STATUS(&outboundRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_OutboundRule_STATUS() to populate field OutboundRules")
			}
			outboundRuleMap[outboundRuleKey] = outboundRule
		}
		destination.OutboundRules = outboundRuleMap
	} else {
		destination.OutboundRules = nil
	}

	// Status
	if settings.Status != nil {
		var status storage.ManagedNetworkProvisionStatus_STATUS
		err := settings.Status.AssignProperties_To_ManagedNetworkProvisionStatus_STATUS(&status)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedNetworkProvisionStatus_STATUS() to populate field Status")
		}
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type NotebookResourceInfo_STATUS struct {
	Fqdn *string `json:"fqdn,omitempty"`

	// NotebookPreparationError: The error that occurs when preparing notebook.
	NotebookPreparationError *NotebookPreparationError_STATUS `json:"notebookPreparationError,omitempty"`

	// ResourceId: the data plane resourceId that used to initialize notebook component
	ResourceId *string `json:"resourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &NotebookResourceInfo_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (info *NotebookResourceInfo_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NotebookResourceInfo_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (info *NotebookResourceInfo_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NotebookResourceInfo_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NotebookResourceInfo_STATUS, got %T", armInput)
	}

	// Set property "Fqdn":
	if typedInput.Fqdn != nil {
		fqdn := *typedInput.Fqdn
		info.Fqdn = &fqdn
	}

	// Set property "NotebookPreparationError":
	if typedInput.NotebookPreparationError != nil {
		var notebookPreparationError1 NotebookPreparationError_STATUS
		err := notebookPreparationError1.PopulateFromARM(owner, *typedInput.NotebookPreparationError)
		if err != nil {
			return err
		}
		notebookPreparationError := notebookPreparationError1
		info.NotebookPreparationError = &notebookPreparationError
	}

	// Set property "ResourceId":
	if typedInput.ResourceId != nil {
		resourceId := *typedInput.ResourceId
		info.ResourceId = &resourceId
	}

	// No error
	return nil
}

// AssignProperties_From_NotebookResourceInfo_STATUS populates our NotebookResourceInfo_STATUS from the provided source NotebookResourceInfo_STATUS
func (info *NotebookResourceInfo_STATUS) AssignProperties_From_NotebookResourceInfo_STATUS(source *storage.NotebookResourceInfo_STATUS) error {

	// Fqdn
	info.Fqdn = genruntime.ClonePointerToString(source.Fqdn)

	// NotebookPreparationError
	if source.NotebookPreparationError != nil {
		var notebookPreparationError NotebookPreparationError_STATUS
		err := notebookPreparationError.AssignProperties_From_NotebookPreparationError_STATUS(source.NotebookPreparationError)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_NotebookPreparationError_STATUS() to populate field NotebookPreparationError")
		}
		info.NotebookPreparationError = &notebookPreparationError
	} else {
		info.NotebookPreparationError = nil
	}

	// ResourceId
	info.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// No error
	return nil
}

// AssignProperties_To_NotebookResourceInfo_STATUS populates the provided destination NotebookResourceInfo_STATUS from our NotebookResourceInfo_STATUS
func (info *NotebookResourceInfo_STATUS) AssignProperties_To_NotebookResourceInfo_STATUS(destination *storage.NotebookResourceInfo_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Fqdn
	destination.Fqdn = genruntime.ClonePointerToString(info.Fqdn)

	// NotebookPreparationError
	if info.NotebookPreparationError != nil {
		var notebookPreparationError storage.NotebookPreparationError_STATUS
		err := info.NotebookPreparationError.AssignProperties_To_NotebookPreparationError_STATUS(&notebookPreparationError)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_NotebookPreparationError_STATUS() to populate field NotebookPreparationError")
		}
		destination.NotebookPreparationError = &notebookPreparationError
	} else {
		destination.NotebookPreparationError = nil
	}

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(info.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The Private Endpoint Connection resource.
type PrivateEndpointConnection_STATUS struct {
	// Id: Fully qualified resource ID for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &PrivateEndpointConnection_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (connection *PrivateEndpointConnection_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PrivateEndpointConnection_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (connection *PrivateEndpointConnection_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PrivateEndpointConnection_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PrivateEndpointConnection_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		connection.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_PrivateEndpointConnection_STATUS populates our PrivateEndpointConnection_STATUS from the provided source PrivateEndpointConnection_STATUS
func (connection *PrivateEndpointConnection_STATUS) AssignProperties_From_PrivateEndpointConnection_STATUS(source *storage.PrivateEndpointConnection_STATUS) error {

	// Id
	connection.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_PrivateEndpointConnection_STATUS populates the provided destination PrivateEndpointConnection_STATUS from our PrivateEndpointConnection_STATUS
func (connection *PrivateEndpointConnection_STATUS) AssignProperties_To_PrivateEndpointConnection_STATUS(destination *storage.PrivateEndpointConnection_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(connection.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ServerlessComputeSettings struct {
	// ServerlessComputeCustomSubnetReference: The resource ID of an existing virtual network subnet in which serverless
	// compute nodes should be deployed
	ServerlessComputeCustomSubnetReference *genruntime.ResourceReference `armReference:"ServerlessComputeCustomSubnet" json:"serverlessComputeCustomSubnetReference,omitempty"`

	// ServerlessComputeNoPublicIP: The flag to signal if serverless compute nodes deployed in custom vNet would have no public
	// IP addresses for a workspace with private endpoint
	ServerlessComputeNoPublicIP *bool `json:"serverlessComputeNoPublicIP,omitempty"`
}

var _ genruntime.ARMTransformer = &ServerlessComputeSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *ServerlessComputeSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.ServerlessComputeSettings{}

	// Set property "ServerlessComputeCustomSubnet":
	if settings.ServerlessComputeCustomSubnetReference != nil {
		serverlessComputeCustomSubnetReferenceARMID, err := resolved.ResolvedReferences.Lookup(*settings.ServerlessComputeCustomSubnetReference)
		if err != nil {
			return nil, err
		}
		serverlessComputeCustomSubnetReference := serverlessComputeCustomSubnetReferenceARMID
		result.ServerlessComputeCustomSubnet = &serverlessComputeCustomSubnetReference
	}

	// Set property "ServerlessComputeNoPublicIP":
	if settings.ServerlessComputeNoPublicIP != nil {
		serverlessComputeNoPublicIP := *settings.ServerlessComputeNoPublicIP
		result.ServerlessComputeNoPublicIP = &serverlessComputeNoPublicIP
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *ServerlessComputeSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ServerlessComputeSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *ServerlessComputeSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ServerlessComputeSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ServerlessComputeSettings, got %T", armInput)
	}

	// no assignment for property "ServerlessComputeCustomSubnetReference"

	// Set property "ServerlessComputeNoPublicIP":
	if typedInput.ServerlessComputeNoPublicIP != nil {
		serverlessComputeNoPublicIP := *typedInput.ServerlessComputeNoPublicIP
		settings.ServerlessComputeNoPublicIP = &serverlessComputeNoPublicIP
	}

	// No error
	return nil
}

// AssignProperties_From_ServerlessComputeSettings populates our ServerlessComputeSettings from the provided source ServerlessComputeSettings
func (settings *ServerlessComputeSettings) AssignProperties_From_ServerlessComputeSettings(source *storage.ServerlessComputeSettings) error {

	// ServerlessComputeCustomSubnetReference
	if source.ServerlessComputeCustomSubnetReference != nil {
		serverlessComputeCustomSubnetReference := source.ServerlessComputeCustomSubnetReference.Copy()
		settings.ServerlessComputeCustomSubnetReference = &serverlessComputeCustomSubnetReference
	} else {
		settings.ServerlessComputeCustomSubnetReference = nil
	}

	// ServerlessComputeNoPublicIP
	if source.ServerlessComputeNoPublicIP != nil {
		serverlessComputeNoPublicIP := *source.ServerlessComputeNoPublicIP
		settings.ServerlessComputeNoPublicIP = &serverlessComputeNoPublicIP
	} else {
		settings.ServerlessComputeNoPublicIP = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ServerlessComputeSettings populates the provided destination ServerlessComputeSettings from our ServerlessComputeSettings
func (settings *ServerlessComputeSettings) AssignProperties_To_ServerlessComputeSettings(destination *storage.ServerlessComputeSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ServerlessComputeCustomSubnetReference
	if settings.ServerlessComputeCustomSubnetReference != nil {
		serverlessComputeCustomSubnetReference := settings.ServerlessComputeCustomSubnetReference.Copy()
		destination.ServerlessComputeCustomSubnetReference = &serverlessComputeCustomSubnetReference
	} else {
		destination.ServerlessComputeCustomSubnetReference = nil
	}

	// ServerlessComputeNoPublicIP
	if settings.ServerlessComputeNoPublicIP != nil {
		serverlessComputeNoPublicIP := *settings.ServerlessComputeNoPublicIP
		destination.ServerlessComputeNoPublicIP = &serverlessComputeNoPublicIP
	} else {
		destination.ServerlessComputeNoPublicIP = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ServerlessComputeSettings_STATUS populates our ServerlessComputeSettings from the provided source ServerlessComputeSettings_STATUS
func (settings *ServerlessComputeSettings) Initialize_From_ServerlessComputeSettings_STATUS(source *ServerlessComputeSettings_STATUS) error {

	// ServerlessComputeNoPublicIP
	if source.ServerlessComputeNoPublicIP != nil {
		serverlessComputeNoPublicIP := *source.ServerlessComputeNoPublicIP
		settings.ServerlessComputeNoPublicIP = &serverlessComputeNoPublicIP
	} else {
		settings.ServerlessComputeNoPublicIP = nil
	}

	// No error
	return nil
}

type ServerlessComputeSettings_STATUS struct {
	// ServerlessComputeCustomSubnet: The resource ID of an existing virtual network subnet in which serverless compute nodes
	// should be deployed
	ServerlessComputeCustomSubnet *string `json:"serverlessComputeCustomSubnet,omitempty"`

	// ServerlessComputeNoPublicIP: The flag to signal if serverless compute nodes deployed in custom vNet would have no public
	// IP addresses for a workspace with private endpoint
	ServerlessComputeNoPublicIP *bool `json:"serverlessComputeNoPublicIP,omitempty"`
}

var _ genruntime.FromARMConverter = &ServerlessComputeSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *ServerlessComputeSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ServerlessComputeSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *ServerlessComputeSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ServerlessComputeSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ServerlessComputeSettings_STATUS, got %T", armInput)
	}

	// Set property "ServerlessComputeCustomSubnet":
	if typedInput.ServerlessComputeCustomSubnet != nil {
		serverlessComputeCustomSubnet := *typedInput.ServerlessComputeCustomSubnet
		settings.ServerlessComputeCustomSubnet = &serverlessComputeCustomSubnet
	}

	// Set property "ServerlessComputeNoPublicIP":
	if typedInput.ServerlessComputeNoPublicIP != nil {
		serverlessComputeNoPublicIP := *typedInput.ServerlessComputeNoPublicIP
		settings.ServerlessComputeNoPublicIP = &serverlessComputeNoPublicIP
	}

	// No error
	return nil
}

// AssignProperties_From_ServerlessComputeSettings_STATUS populates our ServerlessComputeSettings_STATUS from the provided source ServerlessComputeSettings_STATUS
func (settings *ServerlessComputeSettings_STATUS) AssignProperties_From_ServerlessComputeSettings_STATUS(source *storage.ServerlessComputeSettings_STATUS) error {

	// ServerlessComputeCustomSubnet
	settings.ServerlessComputeCustomSubnet = genruntime.ClonePointerToString(source.ServerlessComputeCustomSubnet)

	// ServerlessComputeNoPublicIP
	if source.ServerlessComputeNoPublicIP != nil {
		serverlessComputeNoPublicIP := *source.ServerlessComputeNoPublicIP
		settings.ServerlessComputeNoPublicIP = &serverlessComputeNoPublicIP
	} else {
		settings.ServerlessComputeNoPublicIP = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ServerlessComputeSettings_STATUS populates the provided destination ServerlessComputeSettings_STATUS from our ServerlessComputeSettings_STATUS
func (settings *ServerlessComputeSettings_STATUS) AssignProperties_To_ServerlessComputeSettings_STATUS(destination *storage.ServerlessComputeSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ServerlessComputeCustomSubnet
	destination.ServerlessComputeCustomSubnet = genruntime.ClonePointerToString(settings.ServerlessComputeCustomSubnet)

	// ServerlessComputeNoPublicIP
	if settings.ServerlessComputeNoPublicIP != nil {
		serverlessComputeNoPublicIP := *settings.ServerlessComputeNoPublicIP
		destination.ServerlessComputeNoPublicIP = &serverlessComputeNoPublicIP
	} else {
		destination.ServerlessComputeNoPublicIP = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ServiceManagedResourcesSettings struct {
	// CosmosDb: The settings for the service managed cosmosdb account.
	CosmosDb *CosmosDbSettings `json:"cosmosDb,omitempty"`
}

var _ genruntime.ARMTransformer = &ServiceManagedResourcesSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *ServiceManagedResourcesSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.ServiceManagedResourcesSettings{}

	// Set property "CosmosDb":
	if settings.CosmosDb != nil {
		cosmosDb_ARM, err := (*settings.CosmosDb).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		cosmosDb := *cosmosDb_ARM.(*arm.CosmosDbSettings)
		result.CosmosDb = &cosmosDb
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *ServiceManagedResourcesSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ServiceManagedResourcesSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *ServiceManagedResourcesSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ServiceManagedResourcesSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ServiceManagedResourcesSettings, got %T", armInput)
	}

	// Set property "CosmosDb":
	if typedInput.CosmosDb != nil {
		var cosmosDb1 CosmosDbSettings
		err := cosmosDb1.PopulateFromARM(owner, *typedInput.CosmosDb)
		if err != nil {
			return err
		}
		cosmosDb := cosmosDb1
		settings.CosmosDb = &cosmosDb
	}

	// No error
	return nil
}

// AssignProperties_From_ServiceManagedResourcesSettings populates our ServiceManagedResourcesSettings from the provided source ServiceManagedResourcesSettings
func (settings *ServiceManagedResourcesSettings) AssignProperties_From_ServiceManagedResourcesSettings(source *storage.ServiceManagedResourcesSettings) error {

	// CosmosDb
	if source.CosmosDb != nil {
		var cosmosDb CosmosDbSettings
		err := cosmosDb.AssignProperties_From_CosmosDbSettings(source.CosmosDb)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CosmosDbSettings() to populate field CosmosDb")
		}
		settings.CosmosDb = &cosmosDb
	} else {
		settings.CosmosDb = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ServiceManagedResourcesSettings populates the provided destination ServiceManagedResourcesSettings from our ServiceManagedResourcesSettings
func (settings *ServiceManagedResourcesSettings) AssignProperties_To_ServiceManagedResourcesSettings(destination *storage.ServiceManagedResourcesSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CosmosDb
	if settings.CosmosDb != nil {
		var cosmosDb storage.CosmosDbSettings
		err := settings.CosmosDb.AssignProperties_To_CosmosDbSettings(&cosmosDb)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CosmosDbSettings() to populate field CosmosDb")
		}
		destination.CosmosDb = &cosmosDb
	} else {
		destination.CosmosDb = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ServiceManagedResourcesSettings_STATUS populates our ServiceManagedResourcesSettings from the provided source ServiceManagedResourcesSettings_STATUS
func (settings *ServiceManagedResourcesSettings) Initialize_From_ServiceManagedResourcesSettings_STATUS(source *ServiceManagedResourcesSettings_STATUS) error {

	// CosmosDb
	if source.CosmosDb != nil {
		var cosmosDb CosmosDbSettings
		err := cosmosDb.Initialize_From_CosmosDbSettings_STATUS(source.CosmosDb)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_CosmosDbSettings_STATUS() to populate field CosmosDb")
		}
		settings.CosmosDb = &cosmosDb
	} else {
		settings.CosmosDb = nil
	}

	// No error
	return nil
}

type ServiceManagedResourcesSettings_STATUS struct {
	// CosmosDb: The settings for the service managed cosmosdb account.
	CosmosDb *CosmosDbSettings_STATUS `json:"cosmosDb,omitempty"`
}

var _ genruntime.FromARMConverter = &ServiceManagedResourcesSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *ServiceManagedResourcesSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ServiceManagedResourcesSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *ServiceManagedResourcesSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ServiceManagedResourcesSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ServiceManagedResourcesSettings_STATUS, got %T", armInput)
	}

	// Set property "CosmosDb":
	if typedInput.CosmosDb != nil {
		var cosmosDb1 CosmosDbSettings_STATUS
		err := cosmosDb1.PopulateFromARM(owner, *typedInput.CosmosDb)
		if err != nil {
			return err
		}
		cosmosDb := cosmosDb1
		settings.CosmosDb = &cosmosDb
	}

	// No error
	return nil
}

// AssignProperties_From_ServiceManagedResourcesSettings_STATUS populates our ServiceManagedResourcesSettings_STATUS from the provided source ServiceManagedResourcesSettings_STATUS
func (settings *ServiceManagedResourcesSettings_STATUS) AssignProperties_From_ServiceManagedResourcesSettings_STATUS(source *storage.ServiceManagedResourcesSettings_STATUS) error {

	// CosmosDb
	if source.CosmosDb != nil {
		var cosmosDb CosmosDbSettings_STATUS
		err := cosmosDb.AssignProperties_From_CosmosDbSettings_STATUS(source.CosmosDb)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CosmosDbSettings_STATUS() to populate field CosmosDb")
		}
		settings.CosmosDb = &cosmosDb
	} else {
		settings.CosmosDb = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ServiceManagedResourcesSettings_STATUS populates the provided destination ServiceManagedResourcesSettings_STATUS from our ServiceManagedResourcesSettings_STATUS
func (settings *ServiceManagedResourcesSettings_STATUS) AssignProperties_To_ServiceManagedResourcesSettings_STATUS(destination *storage.ServiceManagedResourcesSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CosmosDb
	if settings.CosmosDb != nil {
		var cosmosDb storage.CosmosDbSettings_STATUS
		err := settings.CosmosDb.AssignProperties_To_CosmosDbSettings_STATUS(&cosmosDb)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CosmosDbSettings_STATUS() to populate field CosmosDb")
		}
		destination.CosmosDb = &cosmosDb
	} else {
		destination.CosmosDb = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type SharedPrivateLinkResource struct {
	// GroupId: The private link resource group id.
	GroupId *string `json:"groupId,omitempty"`

	// Name: Unique name of the private link.
	Name *string `json:"name,omitempty"`

	// PrivateLinkResourceReference: The resource id that private link links to.
	PrivateLinkResourceReference *genruntime.ResourceReference `armReference:"PrivateLinkResourceId" json:"privateLinkResourceReference,omitempty"`

	// RequestMessage: Request message.
	RequestMessage *string `json:"requestMessage,omitempty"`

	// Status: Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
	Status *PrivateEndpointServiceConnectionStatus `json:"status,omitempty"`
}

var _ genruntime.ARMTransformer = &SharedPrivateLinkResource{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (resource *SharedPrivateLinkResource) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if resource == nil {
		return nil, nil
	}
	result := &arm.SharedPrivateLinkResource{}

	// Set property "Name":
	if resource.Name != nil {
		name := *resource.Name
		result.Name = &name
	}

	// Set property "Properties":
	if resource.GroupId != nil ||
		resource.PrivateLinkResourceReference != nil ||
		resource.RequestMessage != nil ||
		resource.Status != nil {
		result.Properties = &arm.SharedPrivateLinkResourceProperty{}
	}
	if resource.GroupId != nil {
		groupId := *resource.GroupId
		result.Properties.GroupId = &groupId
	}
	if resource.PrivateLinkResourceReference != nil {
		privateLinkResourceIdARMID, err := resolved.ResolvedReferences.Lookup(*resource.PrivateLinkResourceReference)
		if err != nil {
			return nil, err
		}
		privateLinkResourceId := privateLinkResourceIdARMID
		result.Properties.PrivateLinkResourceId = &privateLinkResourceId
	}
	if resource.RequestMessage != nil {
		requestMessage := *resource.RequestMessage
		result.Properties.RequestMessage = &requestMessage
	}
	if resource.Status != nil {
		var temp string
		temp = string(*resource.Status)
		status := arm.PrivateEndpointServiceConnectionStatus(temp)
		result.Properties.Status = &status
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *SharedPrivateLinkResource) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SharedPrivateLinkResource{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *SharedPrivateLinkResource) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SharedPrivateLinkResource)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SharedPrivateLinkResource, got %T", armInput)
	}

	// Set property "GroupId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.GroupId != nil {
			groupId := *typedInput.Properties.GroupId
			resource.GroupId = &groupId
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		resource.Name = &name
	}

	// no assignment for property "PrivateLinkResourceReference"

	// Set property "RequestMessage":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RequestMessage != nil {
			requestMessage := *typedInput.Properties.RequestMessage
			resource.RequestMessage = &requestMessage
		}
	}

	// Set property "Status":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Status != nil {
			var temp string
			temp = string(*typedInput.Properties.Status)
			status := PrivateEndpointServiceConnectionStatus(temp)
			resource.Status = &status
		}
	}

	// No error
	return nil
}

// AssignProperties_From_SharedPrivateLinkResource populates our SharedPrivateLinkResource from the provided source SharedPrivateLinkResource
func (resource *SharedPrivateLinkResource) AssignProperties_From_SharedPrivateLinkResource(source *storage.SharedPrivateLinkResource) error {

	// GroupId
	resource.GroupId = genruntime.ClonePointerToString(source.GroupId)

	// Name
	resource.Name = genruntime.ClonePointerToString(source.Name)

	// PrivateLinkResourceReference
	if source.PrivateLinkResourceReference != nil {
		privateLinkResourceReference := source.PrivateLinkResourceReference.Copy()
		resource.PrivateLinkResourceReference = &privateLinkResourceReference
	} else {
		resource.PrivateLinkResourceReference = nil
	}

	// RequestMessage
	resource.RequestMessage = genruntime.ClonePointerToString(source.RequestMessage)

	// Status
	if source.Status != nil {
		status := *source.Status
		statusTemp := genruntime.ToEnum(status, privateEndpointServiceConnectionStatus_Values)
		resource.Status = &statusTemp
	} else {
		resource.Status = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SharedPrivateLinkResource populates the provided destination SharedPrivateLinkResource from our SharedPrivateLinkResource
func (resource *SharedPrivateLinkResource) AssignProperties_To_SharedPrivateLinkResource(destination *storage.SharedPrivateLinkResource) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// GroupId
	destination.GroupId = genruntime.ClonePointerToString(resource.GroupId)

	// Name
	destination.Name = genruntime.ClonePointerToString(resource.Name)

	// PrivateLinkResourceReference
	if resource.PrivateLinkResourceReference != nil {
		privateLinkResourceReference := resource.PrivateLinkResourceReference.Copy()
		destination.PrivateLinkResourceReference = &privateLinkResourceReference
	} else {
		destination.PrivateLinkResourceReference = nil
	}

	// RequestMessage
	destination.RequestMessage = genruntime.ClonePointerToString(resource.RequestMessage)

	// Status
	if resource.Status != nil {
		status := string(*resource.Status)
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_SharedPrivateLinkResource_STATUS populates our SharedPrivateLinkResource from the provided source SharedPrivateLinkResource_STATUS
func (resource *SharedPrivateLinkResource) Initialize_From_SharedPrivateLinkResource_STATUS(source *SharedPrivateLinkResource_STATUS) error {

	// GroupId
	resource.GroupId = genruntime.ClonePointerToString(source.GroupId)

	// Name
	resource.Name = genruntime.ClonePointerToString(source.Name)

	// PrivateLinkResourceReference
	if source.PrivateLinkResourceId != nil {
		privateLinkResourceReference := genruntime.CreateResourceReferenceFromARMID(*source.PrivateLinkResourceId)
		resource.PrivateLinkResourceReference = &privateLinkResourceReference
	} else {
		resource.PrivateLinkResourceReference = nil
	}

	// RequestMessage
	resource.RequestMessage = genruntime.ClonePointerToString(source.RequestMessage)

	// Status
	if source.Status != nil {
		status := genruntime.ToEnum(string(*source.Status), privateEndpointServiceConnectionStatus_Values)
		resource.Status = &status
	} else {
		resource.Status = nil
	}

	// No error
	return nil
}

type SharedPrivateLinkResource_STATUS struct {
	// GroupId: The private link resource group id.
	GroupId *string `json:"groupId,omitempty"`

	// Name: Unique name of the private link.
	Name *string `json:"name,omitempty"`

	// PrivateLinkResourceId: The resource id that private link links to.
	PrivateLinkResourceId *string `json:"privateLinkResourceId,omitempty"`

	// RequestMessage: Request message.
	RequestMessage *string `json:"requestMessage,omitempty"`

	// Status: Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
	Status *PrivateEndpointServiceConnectionStatus_STATUS `json:"status,omitempty"`
}

var _ genruntime.FromARMConverter = &SharedPrivateLinkResource_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *SharedPrivateLinkResource_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SharedPrivateLinkResource_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *SharedPrivateLinkResource_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SharedPrivateLinkResource_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SharedPrivateLinkResource_STATUS, got %T", armInput)
	}

	// Set property "GroupId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.GroupId != nil {
			groupId := *typedInput.Properties.GroupId
			resource.GroupId = &groupId
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		resource.Name = &name
	}

	// Set property "PrivateLinkResourceId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateLinkResourceId != nil {
			privateLinkResourceId := *typedInput.Properties.PrivateLinkResourceId
			resource.PrivateLinkResourceId = &privateLinkResourceId
		}
	}

	// Set property "RequestMessage":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RequestMessage != nil {
			requestMessage := *typedInput.Properties.RequestMessage
			resource.RequestMessage = &requestMessage
		}
	}

	// Set property "Status":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Status != nil {
			var temp string
			temp = string(*typedInput.Properties.Status)
			status := PrivateEndpointServiceConnectionStatus_STATUS(temp)
			resource.Status = &status
		}
	}

	// No error
	return nil
}

// AssignProperties_From_SharedPrivateLinkResource_STATUS populates our SharedPrivateLinkResource_STATUS from the provided source SharedPrivateLinkResource_STATUS
func (resource *SharedPrivateLinkResource_STATUS) AssignProperties_From_SharedPrivateLinkResource_STATUS(source *storage.SharedPrivateLinkResource_STATUS) error {

	// GroupId
	resource.GroupId = genruntime.ClonePointerToString(source.GroupId)

	// Name
	resource.Name = genruntime.ClonePointerToString(source.Name)

	// PrivateLinkResourceId
	resource.PrivateLinkResourceId = genruntime.ClonePointerToString(source.PrivateLinkResourceId)

	// RequestMessage
	resource.RequestMessage = genruntime.ClonePointerToString(source.RequestMessage)

	// Status
	if source.Status != nil {
		status := *source.Status
		statusTemp := genruntime.ToEnum(status, privateEndpointServiceConnectionStatus_STATUS_Values)
		resource.Status = &statusTemp
	} else {
		resource.Status = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SharedPrivateLinkResource_STATUS populates the provided destination SharedPrivateLinkResource_STATUS from our SharedPrivateLinkResource_STATUS
func (resource *SharedPrivateLinkResource_STATUS) AssignProperties_To_SharedPrivateLinkResource_STATUS(destination *storage.SharedPrivateLinkResource_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// GroupId
	destination.GroupId = genruntime.ClonePointerToString(resource.GroupId)

	// Name
	destination.Name = genruntime.ClonePointerToString(resource.Name)

	// PrivateLinkResourceId
	destination.PrivateLinkResourceId = genruntime.ClonePointerToString(resource.PrivateLinkResourceId)

	// RequestMessage
	destination.RequestMessage = genruntime.ClonePointerToString(resource.RequestMessage)

	// Status
	if resource.Status != nil {
		status := string(*resource.Status)
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// WorkspaceHub's configuration object.
type WorkspaceHubConfig struct {
	AdditionalWorkspaceStorageAccounts []string `json:"additionalWorkspaceStorageAccounts,omitempty"`
	DefaultWorkspaceResourceGroup      *string  `json:"defaultWorkspaceResourceGroup,omitempty"`
}

var _ genruntime.ARMTransformer = &WorkspaceHubConfig{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (config *WorkspaceHubConfig) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if config == nil {
		return nil, nil
	}
	result := &arm.WorkspaceHubConfig{}

	// Set property "AdditionalWorkspaceStorageAccounts":
	for _, item := range config.AdditionalWorkspaceStorageAccounts {
		result.AdditionalWorkspaceStorageAccounts = append(result.AdditionalWorkspaceStorageAccounts, item)
	}

	// Set property "DefaultWorkspaceResourceGroup":
	if config.DefaultWorkspaceResourceGroup != nil {
		defaultWorkspaceResourceGroup := *config.DefaultWorkspaceResourceGroup
		result.DefaultWorkspaceResourceGroup = &defaultWorkspaceResourceGroup
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *WorkspaceHubConfig) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceHubConfig{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *WorkspaceHubConfig) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspaceHubConfig)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceHubConfig, got %T", armInput)
	}

	// Set property "AdditionalWorkspaceStorageAccounts":
	for _, item := range typedInput.AdditionalWorkspaceStorageAccounts {
		config.AdditionalWorkspaceStorageAccounts = append(config.AdditionalWorkspaceStorageAccounts, item)
	}

	// Set property "DefaultWorkspaceResourceGroup":
	if typedInput.DefaultWorkspaceResourceGroup != nil {
		defaultWorkspaceResourceGroup := *typedInput.DefaultWorkspaceResourceGroup
		config.DefaultWorkspaceResourceGroup = &defaultWorkspaceResourceGroup
	}

	// No error
	return nil
}

// AssignProperties_From_WorkspaceHubConfig populates our WorkspaceHubConfig from the provided source WorkspaceHubConfig
func (config *WorkspaceHubConfig) AssignProperties_From_WorkspaceHubConfig(source *storage.WorkspaceHubConfig) error {

	// AdditionalWorkspaceStorageAccounts
	config.AdditionalWorkspaceStorageAccounts = genruntime.CloneSliceOfString(source.AdditionalWorkspaceStorageAccounts)

	// DefaultWorkspaceResourceGroup
	config.DefaultWorkspaceResourceGroup = genruntime.ClonePointerToString(source.DefaultWorkspaceResourceGroup)

	// No error
	return nil
}

// AssignProperties_To_WorkspaceHubConfig populates the provided destination WorkspaceHubConfig from our WorkspaceHubConfig
func (config *WorkspaceHubConfig) AssignProperties_To_WorkspaceHubConfig(destination *storage.WorkspaceHubConfig) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalWorkspaceStorageAccounts
	destination.AdditionalWorkspaceStorageAccounts = genruntime.CloneSliceOfString(config.AdditionalWorkspaceStorageAccounts)

	// DefaultWorkspaceResourceGroup
	destination.DefaultWorkspaceResourceGroup = genruntime.ClonePointerToString(config.DefaultWorkspaceResourceGroup)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_WorkspaceHubConfig_STATUS populates our WorkspaceHubConfig from the provided source WorkspaceHubConfig_STATUS
func (config *WorkspaceHubConfig) Initialize_From_WorkspaceHubConfig_STATUS(source *WorkspaceHubConfig_STATUS) error {

	// AdditionalWorkspaceStorageAccounts
	config.AdditionalWorkspaceStorageAccounts = genruntime.CloneSliceOfString(source.AdditionalWorkspaceStorageAccounts)

	// DefaultWorkspaceResourceGroup
	config.DefaultWorkspaceResourceGroup = genruntime.ClonePointerToString(source.DefaultWorkspaceResourceGroup)

	// No error
	return nil
}

// WorkspaceHub's configuration object.
type WorkspaceHubConfig_STATUS struct {
	AdditionalWorkspaceStorageAccounts []string `json:"additionalWorkspaceStorageAccounts,omitempty"`
	DefaultWorkspaceResourceGroup      *string  `json:"defaultWorkspaceResourceGroup,omitempty"`
}

var _ genruntime.FromARMConverter = &WorkspaceHubConfig_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (config *WorkspaceHubConfig_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceHubConfig_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (config *WorkspaceHubConfig_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspaceHubConfig_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceHubConfig_STATUS, got %T", armInput)
	}

	// Set property "AdditionalWorkspaceStorageAccounts":
	for _, item := range typedInput.AdditionalWorkspaceStorageAccounts {
		config.AdditionalWorkspaceStorageAccounts = append(config.AdditionalWorkspaceStorageAccounts, item)
	}

	// Set property "DefaultWorkspaceResourceGroup":
	if typedInput.DefaultWorkspaceResourceGroup != nil {
		defaultWorkspaceResourceGroup := *typedInput.DefaultWorkspaceResourceGroup
		config.DefaultWorkspaceResourceGroup = &defaultWorkspaceResourceGroup
	}

	// No error
	return nil
}

// AssignProperties_From_WorkspaceHubConfig_STATUS populates our WorkspaceHubConfig_STATUS from the provided source WorkspaceHubConfig_STATUS
func (config *WorkspaceHubConfig_STATUS) AssignProperties_From_WorkspaceHubConfig_STATUS(source *storage.WorkspaceHubConfig_STATUS) error {

	// AdditionalWorkspaceStorageAccounts
	config.AdditionalWorkspaceStorageAccounts = genruntime.CloneSliceOfString(source.AdditionalWorkspaceStorageAccounts)

	// DefaultWorkspaceResourceGroup
	config.DefaultWorkspaceResourceGroup = genruntime.ClonePointerToString(source.DefaultWorkspaceResourceGroup)

	// No error
	return nil
}

// AssignProperties_To_WorkspaceHubConfig_STATUS populates the provided destination WorkspaceHubConfig_STATUS from our WorkspaceHubConfig_STATUS
func (config *WorkspaceHubConfig_STATUS) AssignProperties_To_WorkspaceHubConfig_STATUS(destination *storage.WorkspaceHubConfig_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalWorkspaceStorageAccounts
	destination.AdditionalWorkspaceStorageAccounts = genruntime.CloneSliceOfString(config.AdditionalWorkspaceStorageAccounts)

	// DefaultWorkspaceResourceGroup
	destination.DefaultWorkspaceResourceGroup = genruntime.ClonePointerToString(config.DefaultWorkspaceResourceGroup)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type WorkspaceOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`

	// Secrets: configures where to place Azure generated secrets.
	Secrets *WorkspaceOperatorSecrets `json:"secrets,omitempty"`
}

// AssignProperties_From_WorkspaceOperatorSpec populates our WorkspaceOperatorSpec from the provided source WorkspaceOperatorSpec
func (operator *WorkspaceOperatorSpec) AssignProperties_From_WorkspaceOperatorSpec(source *storage.WorkspaceOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// Secrets
	if source.Secrets != nil {
		var secret WorkspaceOperatorSecrets
		err := secret.AssignProperties_From_WorkspaceOperatorSecrets(source.Secrets)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WorkspaceOperatorSecrets() to populate field Secrets")
		}
		operator.Secrets = &secret
	} else {
		operator.Secrets = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WorkspaceOperatorSpec populates the provided destination WorkspaceOperatorSpec from our WorkspaceOperatorSpec
func (operator *WorkspaceOperatorSpec) AssignProperties_To_WorkspaceOperatorSpec(destination *storage.WorkspaceOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Secrets
	if operator.Secrets != nil {
		var secret storage.WorkspaceOperatorSecrets
		err := operator.Secrets.AssignProperties_To_WorkspaceOperatorSecrets(&secret)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WorkspaceOperatorSecrets() to populate field Secrets")
		}
		destination.Secrets = &secret
	} else {
		destination.Secrets = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type WorkspaceProperties_ProvisioningState_STATUS string

const (
	WorkspaceProperties_ProvisioningState_STATUS_Canceled  = WorkspaceProperties_ProvisioningState_STATUS("Canceled")
	WorkspaceProperties_ProvisioningState_STATUS_Creating  = WorkspaceProperties_ProvisioningState_STATUS("Creating")
	WorkspaceProperties_ProvisioningState_STATUS_Deleting  = WorkspaceProperties_ProvisioningState_STATUS("Deleting")
	WorkspaceProperties_ProvisioningState_STATUS_Failed    = WorkspaceProperties_ProvisioningState_STATUS("Failed")
	WorkspaceProperties_ProvisioningState_STATUS_Succeeded = WorkspaceProperties_ProvisioningState_STATUS("Succeeded")
	WorkspaceProperties_ProvisioningState_STATUS_Unknown   = WorkspaceProperties_ProvisioningState_STATUS("Unknown")
	WorkspaceProperties_ProvisioningState_STATUS_Updating  = WorkspaceProperties_ProvisioningState_STATUS("Updating")
)

// Mapping from string to WorkspaceProperties_ProvisioningState_STATUS
var workspaceProperties_ProvisioningState_STATUS_Values = map[string]WorkspaceProperties_ProvisioningState_STATUS{
	"canceled":  WorkspaceProperties_ProvisioningState_STATUS_Canceled,
	"creating":  WorkspaceProperties_ProvisioningState_STATUS_Creating,
	"deleting":  WorkspaceProperties_ProvisioningState_STATUS_Deleting,
	"failed":    WorkspaceProperties_ProvisioningState_STATUS_Failed,
	"succeeded": WorkspaceProperties_ProvisioningState_STATUS_Succeeded,
	"unknown":   WorkspaceProperties_ProvisioningState_STATUS_Unknown,
	"updating":  WorkspaceProperties_ProvisioningState_STATUS_Updating,
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type WorkspaceProperties_PublicNetworkAccess string

const (
	WorkspaceProperties_PublicNetworkAccess_Disabled = WorkspaceProperties_PublicNetworkAccess("Disabled")
	WorkspaceProperties_PublicNetworkAccess_Enabled  = WorkspaceProperties_PublicNetworkAccess("Enabled")
)

// Mapping from string to WorkspaceProperties_PublicNetworkAccess
var workspaceProperties_PublicNetworkAccess_Values = map[string]WorkspaceProperties_PublicNetworkAccess{
	"disabled": WorkspaceProperties_PublicNetworkAccess_Disabled,
	"enabled":  WorkspaceProperties_PublicNetworkAccess_Enabled,
}

type WorkspaceProperties_PublicNetworkAccess_STATUS string

const (
	WorkspaceProperties_PublicNetworkAccess_STATUS_Disabled = WorkspaceProperties_PublicNetworkAccess_STATUS("Disabled")
	WorkspaceProperties_PublicNetworkAccess_STATUS_Enabled  = WorkspaceProperties_PublicNetworkAccess_STATUS("Enabled")
)

// Mapping from string to WorkspaceProperties_PublicNetworkAccess_STATUS
var workspaceProperties_PublicNetworkAccess_STATUS_Values = map[string]WorkspaceProperties_PublicNetworkAccess_STATUS{
	"disabled": WorkspaceProperties_PublicNetworkAccess_STATUS_Disabled,
	"enabled":  WorkspaceProperties_PublicNetworkAccess_STATUS_Enabled,
}

// Compute runtime config for feature store type workspace.
type ComputeRuntimeDto struct {
	SparkRuntimeVersion *string `json:"sparkRuntimeVersion,omitempty"`
}

var _ genruntime.ARMTransformer = &ComputeRuntimeDto{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (runtimeDto *ComputeRuntimeDto) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if runtimeDto == nil {
		return nil, nil
	}
	result := &arm.ComputeRuntimeDto{}

	// Set property "SparkRuntimeVersion":
	if runtimeDto.SparkRuntimeVersion != nil {
		sparkRuntimeVersion := *runtimeDto.SparkRuntimeVersion
		result.SparkRuntimeVersion = &sparkRuntimeVersion
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (runtimeDto *ComputeRuntimeDto) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComputeRuntimeDto{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (runtimeDto *ComputeRuntimeDto) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComputeRuntimeDto)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComputeRuntimeDto, got %T", armInput)
	}

	// Set property "SparkRuntimeVersion":
	if typedInput.SparkRuntimeVersion != nil {
		sparkRuntimeVersion := *typedInput.SparkRuntimeVersion
		runtimeDto.SparkRuntimeVersion = &sparkRuntimeVersion
	}

	// No error
	return nil
}

// AssignProperties_From_ComputeRuntimeDto populates our ComputeRuntimeDto from the provided source ComputeRuntimeDto
func (runtimeDto *ComputeRuntimeDto) AssignProperties_From_ComputeRuntimeDto(source *storage.ComputeRuntimeDto) error {

	// SparkRuntimeVersion
	runtimeDto.SparkRuntimeVersion = genruntime.ClonePointerToString(source.SparkRuntimeVersion)

	// No error
	return nil
}

// AssignProperties_To_ComputeRuntimeDto populates the provided destination ComputeRuntimeDto from our ComputeRuntimeDto
func (runtimeDto *ComputeRuntimeDto) AssignProperties_To_ComputeRuntimeDto(destination *storage.ComputeRuntimeDto) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SparkRuntimeVersion
	destination.SparkRuntimeVersion = genruntime.ClonePointerToString(runtimeDto.SparkRuntimeVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ComputeRuntimeDto_STATUS populates our ComputeRuntimeDto from the provided source ComputeRuntimeDto_STATUS
func (runtimeDto *ComputeRuntimeDto) Initialize_From_ComputeRuntimeDto_STATUS(source *ComputeRuntimeDto_STATUS) error {

	// SparkRuntimeVersion
	runtimeDto.SparkRuntimeVersion = genruntime.ClonePointerToString(source.SparkRuntimeVersion)

	// No error
	return nil
}

// Compute runtime config for feature store type workspace.
type ComputeRuntimeDto_STATUS struct {
	SparkRuntimeVersion *string `json:"sparkRuntimeVersion,omitempty"`
}

var _ genruntime.FromARMConverter = &ComputeRuntimeDto_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (runtimeDto *ComputeRuntimeDto_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComputeRuntimeDto_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (runtimeDto *ComputeRuntimeDto_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComputeRuntimeDto_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComputeRuntimeDto_STATUS, got %T", armInput)
	}

	// Set property "SparkRuntimeVersion":
	if typedInput.SparkRuntimeVersion != nil {
		sparkRuntimeVersion := *typedInput.SparkRuntimeVersion
		runtimeDto.SparkRuntimeVersion = &sparkRuntimeVersion
	}

	// No error
	return nil
}

// AssignProperties_From_ComputeRuntimeDto_STATUS populates our ComputeRuntimeDto_STATUS from the provided source ComputeRuntimeDto_STATUS
func (runtimeDto *ComputeRuntimeDto_STATUS) AssignProperties_From_ComputeRuntimeDto_STATUS(source *storage.ComputeRuntimeDto_STATUS) error {

	// SparkRuntimeVersion
	runtimeDto.SparkRuntimeVersion = genruntime.ClonePointerToString(source.SparkRuntimeVersion)

	// No error
	return nil
}

// AssignProperties_To_ComputeRuntimeDto_STATUS populates the provided destination ComputeRuntimeDto_STATUS from our ComputeRuntimeDto_STATUS
func (runtimeDto *ComputeRuntimeDto_STATUS) AssignProperties_To_ComputeRuntimeDto_STATUS(destination *storage.ComputeRuntimeDto_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SparkRuntimeVersion
	destination.SparkRuntimeVersion = genruntime.ClonePointerToString(runtimeDto.SparkRuntimeVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type CosmosDbSettings struct {
	// CollectionsThroughput: The throughput of the collections in cosmosdb database
	CollectionsThroughput *int `json:"collectionsThroughput,omitempty"`
}

var _ genruntime.ARMTransformer = &CosmosDbSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (settings *CosmosDbSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if settings == nil {
		return nil, nil
	}
	result := &arm.CosmosDbSettings{}

	// Set property "CollectionsThroughput":
	if settings.CollectionsThroughput != nil {
		collectionsThroughput := *settings.CollectionsThroughput
		result.CollectionsThroughput = &collectionsThroughput
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *CosmosDbSettings) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CosmosDbSettings{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *CosmosDbSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CosmosDbSettings)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CosmosDbSettings, got %T", armInput)
	}

	// Set property "CollectionsThroughput":
	if typedInput.CollectionsThroughput != nil {
		collectionsThroughput := *typedInput.CollectionsThroughput
		settings.CollectionsThroughput = &collectionsThroughput
	}

	// No error
	return nil
}

// AssignProperties_From_CosmosDbSettings populates our CosmosDbSettings from the provided source CosmosDbSettings
func (settings *CosmosDbSettings) AssignProperties_From_CosmosDbSettings(source *storage.CosmosDbSettings) error {

	// CollectionsThroughput
	settings.CollectionsThroughput = genruntime.ClonePointerToInt(source.CollectionsThroughput)

	// No error
	return nil
}

// AssignProperties_To_CosmosDbSettings populates the provided destination CosmosDbSettings from our CosmosDbSettings
func (settings *CosmosDbSettings) AssignProperties_To_CosmosDbSettings(destination *storage.CosmosDbSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CollectionsThroughput
	destination.CollectionsThroughput = genruntime.ClonePointerToInt(settings.CollectionsThroughput)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_CosmosDbSettings_STATUS populates our CosmosDbSettings from the provided source CosmosDbSettings_STATUS
func (settings *CosmosDbSettings) Initialize_From_CosmosDbSettings_STATUS(source *CosmosDbSettings_STATUS) error {

	// CollectionsThroughput
	settings.CollectionsThroughput = genruntime.ClonePointerToInt(source.CollectionsThroughput)

	// No error
	return nil
}

type CosmosDbSettings_STATUS struct {
	// CollectionsThroughput: The throughput of the collections in cosmosdb database
	CollectionsThroughput *int `json:"collectionsThroughput,omitempty"`
}

var _ genruntime.FromARMConverter = &CosmosDbSettings_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (settings *CosmosDbSettings_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CosmosDbSettings_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (settings *CosmosDbSettings_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CosmosDbSettings_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CosmosDbSettings_STATUS, got %T", armInput)
	}

	// Set property "CollectionsThroughput":
	if typedInput.CollectionsThroughput != nil {
		collectionsThroughput := *typedInput.CollectionsThroughput
		settings.CollectionsThroughput = &collectionsThroughput
	}

	// No error
	return nil
}

// AssignProperties_From_CosmosDbSettings_STATUS populates our CosmosDbSettings_STATUS from the provided source CosmosDbSettings_STATUS
func (settings *CosmosDbSettings_STATUS) AssignProperties_From_CosmosDbSettings_STATUS(source *storage.CosmosDbSettings_STATUS) error {

	// CollectionsThroughput
	settings.CollectionsThroughput = genruntime.ClonePointerToInt(source.CollectionsThroughput)

	// No error
	return nil
}

// AssignProperties_To_CosmosDbSettings_STATUS populates the provided destination CosmosDbSettings_STATUS from our CosmosDbSettings_STATUS
func (settings *CosmosDbSettings_STATUS) AssignProperties_To_CosmosDbSettings_STATUS(destination *storage.CosmosDbSettings_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CollectionsThroughput
	destination.CollectionsThroughput = genruntime.ClonePointerToInt(settings.CollectionsThroughput)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type EncryptionKeyVaultProperties struct {
	// IdentityClientId: For future use - The client id of the identity which will be used to access key vault.
	IdentityClientId *string `json:"identityClientId,omitempty" optionalConfigMapPair:"IdentityClientId"`

	// IdentityClientIdFromConfig: For future use - The client id of the identity which will be used to access key vault.
	IdentityClientIdFromConfig *genruntime.ConfigMapReference `json:"identityClientIdFromConfig,omitempty" optionalConfigMapPair:"IdentityClientId"`

	// +kubebuilder:validation:Required
	// KeyIdentifier: Key vault uri to access the encryption key.
	KeyIdentifier *string `json:"keyIdentifier,omitempty"`

	// +kubebuilder:validation:Required
	// KeyVaultArmReference: The ArmId of the keyVault where the customer owned encryption key is present.
	KeyVaultArmReference *genruntime.ResourceReference `armReference:"KeyVaultArmId" json:"keyVaultArmReference,omitempty"`
}

var _ genruntime.ARMTransformer = &EncryptionKeyVaultProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *EncryptionKeyVaultProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.EncryptionKeyVaultProperties{}

	// Set property "IdentityClientId":
	if properties.IdentityClientId != nil {
		identityClientId := *properties.IdentityClientId
		result.IdentityClientId = &identityClientId
	}
	if properties.IdentityClientIdFromConfig != nil {
		identityClientIdValue, err := resolved.ResolvedConfigMaps.Lookup(*properties.IdentityClientIdFromConfig)
		if err != nil {
			return nil, errors.Wrap(err, "looking up configmap for property IdentityClientId")
		}
		identityClientId := identityClientIdValue
		result.IdentityClientId = &identityClientId
	}

	// Set property "KeyIdentifier":
	if properties.KeyIdentifier != nil {
		keyIdentifier := *properties.KeyIdentifier
		result.KeyIdentifier = &keyIdentifier
	}

	// Set property "KeyVaultArmId":
	if properties.KeyVaultArmReference != nil {
		keyVaultArmReferenceARMID, err := resolved.ResolvedReferences.Lookup(*properties.KeyVaultArmReference)
		if err != nil {
			return nil, err
		}
		keyVaultArmReference := keyVaultArmReferenceARMID
		result.KeyVaultArmId = &keyVaultArmReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *EncryptionKeyVaultProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EncryptionKeyVaultProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *EncryptionKeyVaultProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EncryptionKeyVaultProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EncryptionKeyVaultProperties, got %T", armInput)
	}

	// Set property "IdentityClientId":
	if typedInput.IdentityClientId != nil {
		identityClientId := *typedInput.IdentityClientId
		properties.IdentityClientId = &identityClientId
	}

	// no assignment for property "IdentityClientIdFromConfig"

	// Set property "KeyIdentifier":
	if typedInput.KeyIdentifier != nil {
		keyIdentifier := *typedInput.KeyIdentifier
		properties.KeyIdentifier = &keyIdentifier
	}

	// no assignment for property "KeyVaultArmReference"

	// No error
	return nil
}

// AssignProperties_From_EncryptionKeyVaultProperties populates our EncryptionKeyVaultProperties from the provided source EncryptionKeyVaultProperties
func (properties *EncryptionKeyVaultProperties) AssignProperties_From_EncryptionKeyVaultProperties(source *storage.EncryptionKeyVaultProperties) error {

	// IdentityClientId
	properties.IdentityClientId = genruntime.ClonePointerToString(source.IdentityClientId)

	// IdentityClientIdFromConfig
	if source.IdentityClientIdFromConfig != nil {
		identityClientIdFromConfig := source.IdentityClientIdFromConfig.Copy()
		properties.IdentityClientIdFromConfig = &identityClientIdFromConfig
	} else {
		properties.IdentityClientIdFromConfig = nil
	}

	// KeyIdentifier
	properties.KeyIdentifier = genruntime.ClonePointerToString(source.KeyIdentifier)

	// KeyVaultArmReference
	if source.KeyVaultArmReference != nil {
		keyVaultArmReference := source.KeyVaultArmReference.Copy()
		properties.KeyVaultArmReference = &keyVaultArmReference
	} else {
		properties.KeyVaultArmReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_EncryptionKeyVaultProperties populates the provided destination EncryptionKeyVaultProperties from our EncryptionKeyVaultProperties
func (properties *EncryptionKeyVaultProperties) AssignProperties_To_EncryptionKeyVaultProperties(destination *storage.EncryptionKeyVaultProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IdentityClientId
	destination.IdentityClientId = genruntime.ClonePointerToString(properties.IdentityClientId)

	// IdentityClientIdFromConfig
	if properties.IdentityClientIdFromConfig != nil {
		identityClientIdFromConfig := properties.IdentityClientIdFromConfig.Copy()
		destination.IdentityClientIdFromConfig = &identityClientIdFromConfig
	} else {
		destination.IdentityClientIdFromConfig = nil
	}

	// KeyIdentifier
	destination.KeyIdentifier = genruntime.ClonePointerToString(properties.KeyIdentifier)

	// KeyVaultArmReference
	if properties.KeyVaultArmReference != nil {
		keyVaultArmReference := properties.KeyVaultArmReference.Copy()
		destination.KeyVaultArmReference = &keyVaultArmReference
	} else {
		destination.KeyVaultArmReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_EncryptionKeyVaultProperties_STATUS populates our EncryptionKeyVaultProperties from the provided source EncryptionKeyVaultProperties_STATUS
func (properties *EncryptionKeyVaultProperties) Initialize_From_EncryptionKeyVaultProperties_STATUS(source *EncryptionKeyVaultProperties_STATUS) error {

	// IdentityClientId
	properties.IdentityClientId = genruntime.ClonePointerToString(source.IdentityClientId)

	// KeyIdentifier
	properties.KeyIdentifier = genruntime.ClonePointerToString(source.KeyIdentifier)

	// KeyVaultArmReference
	if source.KeyVaultArmId != nil {
		keyVaultArmReference := genruntime.CreateResourceReferenceFromARMID(*source.KeyVaultArmId)
		properties.KeyVaultArmReference = &keyVaultArmReference
	} else {
		properties.KeyVaultArmReference = nil
	}

	// No error
	return nil
}

type EncryptionKeyVaultProperties_STATUS struct {
	// IdentityClientId: For future use - The client id of the identity which will be used to access key vault.
	IdentityClientId *string `json:"identityClientId,omitempty"`

	// KeyIdentifier: Key vault uri to access the encryption key.
	KeyIdentifier *string `json:"keyIdentifier,omitempty"`

	// KeyVaultArmId: The ArmId of the keyVault where the customer owned encryption key is present.
	KeyVaultArmId *string `json:"keyVaultArmId,omitempty"`
}

var _ genruntime.FromARMConverter = &EncryptionKeyVaultProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *EncryptionKeyVaultProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EncryptionKeyVaultProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *EncryptionKeyVaultProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EncryptionKeyVaultProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EncryptionKeyVaultProperties_STATUS, got %T", armInput)
	}

	// Set property "IdentityClientId":
	if typedInput.IdentityClientId != nil {
		identityClientId := *typedInput.IdentityClientId
		properties.IdentityClientId = &identityClientId
	}

	// Set property "KeyIdentifier":
	if typedInput.KeyIdentifier != nil {
		keyIdentifier := *typedInput.KeyIdentifier
		properties.KeyIdentifier = &keyIdentifier
	}

	// Set property "KeyVaultArmId":
	if typedInput.KeyVaultArmId != nil {
		keyVaultArmId := *typedInput.KeyVaultArmId
		properties.KeyVaultArmId = &keyVaultArmId
	}

	// No error
	return nil
}

// AssignProperties_From_EncryptionKeyVaultProperties_STATUS populates our EncryptionKeyVaultProperties_STATUS from the provided source EncryptionKeyVaultProperties_STATUS
func (properties *EncryptionKeyVaultProperties_STATUS) AssignProperties_From_EncryptionKeyVaultProperties_STATUS(source *storage.EncryptionKeyVaultProperties_STATUS) error {

	// IdentityClientId
	properties.IdentityClientId = genruntime.ClonePointerToString(source.IdentityClientId)

	// KeyIdentifier
	properties.KeyIdentifier = genruntime.ClonePointerToString(source.KeyIdentifier)

	// KeyVaultArmId
	properties.KeyVaultArmId = genruntime.ClonePointerToString(source.KeyVaultArmId)

	// No error
	return nil
}

// AssignProperties_To_EncryptionKeyVaultProperties_STATUS populates the provided destination EncryptionKeyVaultProperties_STATUS from our EncryptionKeyVaultProperties_STATUS
func (properties *EncryptionKeyVaultProperties_STATUS) AssignProperties_To_EncryptionKeyVaultProperties_STATUS(destination *storage.EncryptionKeyVaultProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IdentityClientId
	destination.IdentityClientId = genruntime.ClonePointerToString(properties.IdentityClientId)

	// KeyIdentifier
	destination.KeyIdentifier = genruntime.ClonePointerToString(properties.KeyIdentifier)

	// KeyVaultArmId
	destination.KeyVaultArmId = genruntime.ClonePointerToString(properties.KeyVaultArmId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type EncryptionProperty_Status_STATUS string

const (
	EncryptionProperty_Status_STATUS_Disabled = EncryptionProperty_Status_STATUS("Disabled")
	EncryptionProperty_Status_STATUS_Enabled  = EncryptionProperty_Status_STATUS("Enabled")
)

// Mapping from string to EncryptionProperty_Status_STATUS
var encryptionProperty_Status_STATUS_Values = map[string]EncryptionProperty_Status_STATUS{
	"disabled": EncryptionProperty_Status_STATUS_Disabled,
	"enabled":  EncryptionProperty_Status_STATUS_Enabled,
}

// Identity that will be used to access key vault for encryption at rest
type IdentityForCmk struct {
	// UserAssignedIdentityReference: The ArmId of the user assigned identity that will be used to access the customer managed
	// key vault
	UserAssignedIdentityReference *genruntime.ResourceReference `armReference:"UserAssignedIdentity" json:"userAssignedIdentityReference,omitempty"`
}

var _ genruntime.ARMTransformer = &IdentityForCmk{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (forCmk *IdentityForCmk) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if forCmk == nil {
		return nil, nil
	}
	result := &arm.IdentityForCmk{}

	// Set property "UserAssignedIdentity":
	if forCmk.UserAssignedIdentityReference != nil {
		userAssignedIdentityReferenceARMID, err := resolved.ResolvedReferences.Lookup(*forCmk.UserAssignedIdentityReference)
		if err != nil {
			return nil, err
		}
		userAssignedIdentityReference := userAssignedIdentityReferenceARMID
		result.UserAssignedIdentity = &userAssignedIdentityReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (forCmk *IdentityForCmk) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IdentityForCmk{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (forCmk *IdentityForCmk) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(arm.IdentityForCmk)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IdentityForCmk, got %T", armInput)
	}

	// no assignment for property "UserAssignedIdentityReference"

	// No error
	return nil
}

// AssignProperties_From_IdentityForCmk populates our IdentityForCmk from the provided source IdentityForCmk
func (forCmk *IdentityForCmk) AssignProperties_From_IdentityForCmk(source *storage.IdentityForCmk) error {

	// UserAssignedIdentityReference
	if source.UserAssignedIdentityReference != nil {
		userAssignedIdentityReference := source.UserAssignedIdentityReference.Copy()
		forCmk.UserAssignedIdentityReference = &userAssignedIdentityReference
	} else {
		forCmk.UserAssignedIdentityReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_IdentityForCmk populates the provided destination IdentityForCmk from our IdentityForCmk
func (forCmk *IdentityForCmk) AssignProperties_To_IdentityForCmk(destination *storage.IdentityForCmk) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// UserAssignedIdentityReference
	if forCmk.UserAssignedIdentityReference != nil {
		userAssignedIdentityReference := forCmk.UserAssignedIdentityReference.Copy()
		destination.UserAssignedIdentityReference = &userAssignedIdentityReference
	} else {
		destination.UserAssignedIdentityReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_IdentityForCmk_STATUS populates our IdentityForCmk from the provided source IdentityForCmk_STATUS
func (forCmk *IdentityForCmk) Initialize_From_IdentityForCmk_STATUS(source *IdentityForCmk_STATUS) error {

	// No error
	return nil
}

// Identity that will be used to access key vault for encryption at rest
type IdentityForCmk_STATUS struct {
	// UserAssignedIdentity: The ArmId of the user assigned identity that will be used to access the customer managed key vault
	UserAssignedIdentity *string `json:"userAssignedIdentity,omitempty"`
}

var _ genruntime.FromARMConverter = &IdentityForCmk_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (forCmk *IdentityForCmk_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.IdentityForCmk_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (forCmk *IdentityForCmk_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.IdentityForCmk_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.IdentityForCmk_STATUS, got %T", armInput)
	}

	// Set property "UserAssignedIdentity":
	if typedInput.UserAssignedIdentity != nil {
		userAssignedIdentity := *typedInput.UserAssignedIdentity
		forCmk.UserAssignedIdentity = &userAssignedIdentity
	}

	// No error
	return nil
}

// AssignProperties_From_IdentityForCmk_STATUS populates our IdentityForCmk_STATUS from the provided source IdentityForCmk_STATUS
func (forCmk *IdentityForCmk_STATUS) AssignProperties_From_IdentityForCmk_STATUS(source *storage.IdentityForCmk_STATUS) error {

	// UserAssignedIdentity
	forCmk.UserAssignedIdentity = genruntime.ClonePointerToString(source.UserAssignedIdentity)

	// No error
	return nil
}

// AssignProperties_To_IdentityForCmk_STATUS populates the provided destination IdentityForCmk_STATUS from our IdentityForCmk_STATUS
func (forCmk *IdentityForCmk_STATUS) AssignProperties_To_IdentityForCmk_STATUS(destination *storage.IdentityForCmk_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// UserAssignedIdentity
	destination.UserAssignedIdentity = genruntime.ClonePointerToString(forCmk.UserAssignedIdentity)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Isolation mode for the managed network of a machine learning workspace.
// +kubebuilder:validation:Enum={"AllowInternetOutbound","AllowOnlyApprovedOutbound","Disabled"}
type IsolationMode string

const (
	IsolationMode_AllowInternetOutbound     = IsolationMode("AllowInternetOutbound")
	IsolationMode_AllowOnlyApprovedOutbound = IsolationMode("AllowOnlyApprovedOutbound")
	IsolationMode_Disabled                  = IsolationMode("Disabled")
)

// Mapping from string to IsolationMode
var isolationMode_Values = map[string]IsolationMode{
	"allowinternetoutbound":     IsolationMode_AllowInternetOutbound,
	"allowonlyapprovedoutbound": IsolationMode_AllowOnlyApprovedOutbound,
	"disabled":                  IsolationMode_Disabled,
}

// Isolation mode for the managed network of a machine learning workspace.
type IsolationMode_STATUS string

const (
	IsolationMode_STATUS_AllowInternetOutbound     = IsolationMode_STATUS("AllowInternetOutbound")
	IsolationMode_STATUS_AllowOnlyApprovedOutbound = IsolationMode_STATUS("AllowOnlyApprovedOutbound")
	IsolationMode_STATUS_Disabled                  = IsolationMode_STATUS("Disabled")
)

// Mapping from string to IsolationMode_STATUS
var isolationMode_STATUS_Values = map[string]IsolationMode_STATUS{
	"allowinternetoutbound":     IsolationMode_STATUS_AllowInternetOutbound,
	"allowonlyapprovedoutbound": IsolationMode_STATUS_AllowOnlyApprovedOutbound,
	"disabled":                  IsolationMode_STATUS_Disabled,
}

// Status of the Provisioning for the managed network of a machine learning workspace.
type ManagedNetworkProvisionStatus struct {
	SparkReady *bool `json:"sparkReady,omitempty"`

	// Status: Status for the managed network of a machine learning workspace.
	Status *ManagedNetworkStatus `json:"status,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedNetworkProvisionStatus{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (status *ManagedNetworkProvisionStatus) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if status == nil {
		return nil, nil
	}
	result := &arm.ManagedNetworkProvisionStatus{}

	// Set property "SparkReady":
	if status.SparkReady != nil {
		sparkReady := *status.SparkReady
		result.SparkReady = &sparkReady
	}

	// Set property "Status":
	if status.Status != nil {
		var temp string
		temp = string(*status.Status)
		status1 := arm.ManagedNetworkStatus(temp)
		result.Status = &status1
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (status *ManagedNetworkProvisionStatus) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedNetworkProvisionStatus{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (status *ManagedNetworkProvisionStatus) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedNetworkProvisionStatus)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedNetworkProvisionStatus, got %T", armInput)
	}

	// Set property "SparkReady":
	if typedInput.SparkReady != nil {
		sparkReady := *typedInput.SparkReady
		status.SparkReady = &sparkReady
	}

	// Set property "Status":
	if typedInput.Status != nil {
		var temp string
		temp = string(*typedInput.Status)
		status1 := ManagedNetworkStatus(temp)
		status.Status = &status1
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedNetworkProvisionStatus populates our ManagedNetworkProvisionStatus from the provided source ManagedNetworkProvisionStatus
func (status *ManagedNetworkProvisionStatus) AssignProperties_From_ManagedNetworkProvisionStatus(source *storage.ManagedNetworkProvisionStatus) error {

	// SparkReady
	if source.SparkReady != nil {
		sparkReady := *source.SparkReady
		status.SparkReady = &sparkReady
	} else {
		status.SparkReady = nil
	}

	// Status
	if source.Status != nil {
		statusValue := *source.Status
		statusTemp := genruntime.ToEnum(statusValue, managedNetworkStatus_Values)
		status.Status = &statusTemp
	} else {
		status.Status = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedNetworkProvisionStatus populates the provided destination ManagedNetworkProvisionStatus from our ManagedNetworkProvisionStatus
func (status *ManagedNetworkProvisionStatus) AssignProperties_To_ManagedNetworkProvisionStatus(destination *storage.ManagedNetworkProvisionStatus) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SparkReady
	if status.SparkReady != nil {
		sparkReady := *status.SparkReady
		destination.SparkReady = &sparkReady
	} else {
		destination.SparkReady = nil
	}

	// Status
	if status.Status != nil {
		statusTemp := string(*status.Status)
		destination.Status = &statusTemp
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ManagedNetworkProvisionStatus_STATUS populates our ManagedNetworkProvisionStatus from the provided source ManagedNetworkProvisionStatus_STATUS
func (status *ManagedNetworkProvisionStatus) Initialize_From_ManagedNetworkProvisionStatus_STATUS(source *ManagedNetworkProvisionStatus_STATUS) error {

	// SparkReady
	if source.SparkReady != nil {
		sparkReady := *source.SparkReady
		status.SparkReady = &sparkReady
	} else {
		status.SparkReady = nil
	}

	// Status
	if source.Status != nil {
		statusAsManagedNetworkStatus := genruntime.ToEnum(string(*source.Status), managedNetworkStatus_Values)
		status.Status = &statusAsManagedNetworkStatus
	} else {
		status.Status = nil
	}

	// No error
	return nil
}

// Status of the Provisioning for the managed network of a machine learning workspace.
type ManagedNetworkProvisionStatus_STATUS struct {
	SparkReady *bool `json:"sparkReady,omitempty"`

	// Status: Status for the managed network of a machine learning workspace.
	Status *ManagedNetworkStatus_STATUS `json:"status,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedNetworkProvisionStatus_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (status *ManagedNetworkProvisionStatus_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedNetworkProvisionStatus_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (status *ManagedNetworkProvisionStatus_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedNetworkProvisionStatus_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedNetworkProvisionStatus_STATUS, got %T", armInput)
	}

	// Set property "SparkReady":
	if typedInput.SparkReady != nil {
		sparkReady := *typedInput.SparkReady
		status.SparkReady = &sparkReady
	}

	// Set property "Status":
	if typedInput.Status != nil {
		var temp string
		temp = string(*typedInput.Status)
		status1 := ManagedNetworkStatus_STATUS(temp)
		status.Status = &status1
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedNetworkProvisionStatus_STATUS populates our ManagedNetworkProvisionStatus_STATUS from the provided source ManagedNetworkProvisionStatus_STATUS
func (status *ManagedNetworkProvisionStatus_STATUS) AssignProperties_From_ManagedNetworkProvisionStatus_STATUS(source *storage.ManagedNetworkProvisionStatus_STATUS) error {

	// SparkReady
	if source.SparkReady != nil {
		sparkReady := *source.SparkReady
		status.SparkReady = &sparkReady
	} else {
		status.SparkReady = nil
	}

	// Status
	if source.Status != nil {
		statusValue := *source.Status
		statusTemp := genruntime.ToEnum(statusValue, managedNetworkStatus_STATUS_Values)
		status.Status = &statusTemp
	} else {
		status.Status = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedNetworkProvisionStatus_STATUS populates the provided destination ManagedNetworkProvisionStatus_STATUS from our ManagedNetworkProvisionStatus_STATUS
func (status *ManagedNetworkProvisionStatus_STATUS) AssignProperties_To_ManagedNetworkProvisionStatus_STATUS(destination *storage.ManagedNetworkProvisionStatus_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SparkReady
	if status.SparkReady != nil {
		sparkReady := *status.SparkReady
		destination.SparkReady = &sparkReady
	} else {
		destination.SparkReady = nil
	}

	// Status
	if status.Status != nil {
		statusTemp := string(*status.Status)
		destination.Status = &statusTemp
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type NotebookPreparationError_STATUS struct {
	ErrorMessage *string `json:"errorMessage,omitempty"`
	StatusCode   *int    `json:"statusCode,omitempty"`
}

var _ genruntime.FromARMConverter = &NotebookPreparationError_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (error *NotebookPreparationError_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NotebookPreparationError_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (error *NotebookPreparationError_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NotebookPreparationError_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NotebookPreparationError_STATUS, got %T", armInput)
	}

	// Set property "ErrorMessage":
	if typedInput.ErrorMessage != nil {
		errorMessage := *typedInput.ErrorMessage
		error.ErrorMessage = &errorMessage
	}

	// Set property "StatusCode":
	if typedInput.StatusCode != nil {
		statusCode := *typedInput.StatusCode
		error.StatusCode = &statusCode
	}

	// No error
	return nil
}

// AssignProperties_From_NotebookPreparationError_STATUS populates our NotebookPreparationError_STATUS from the provided source NotebookPreparationError_STATUS
func (error *NotebookPreparationError_STATUS) AssignProperties_From_NotebookPreparationError_STATUS(source *storage.NotebookPreparationError_STATUS) error {

	// ErrorMessage
	error.ErrorMessage = genruntime.ClonePointerToString(source.ErrorMessage)

	// StatusCode
	error.StatusCode = genruntime.ClonePointerToInt(source.StatusCode)

	// No error
	return nil
}

// AssignProperties_To_NotebookPreparationError_STATUS populates the provided destination NotebookPreparationError_STATUS from our NotebookPreparationError_STATUS
func (error *NotebookPreparationError_STATUS) AssignProperties_To_NotebookPreparationError_STATUS(destination *storage.NotebookPreparationError_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ErrorMessage
	destination.ErrorMessage = genruntime.ClonePointerToString(error.ErrorMessage)

	// StatusCode
	destination.StatusCode = genruntime.ClonePointerToInt(error.StatusCode)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type OutboundRule struct {
	// FQDN: Mutually exclusive with all other properties
	FQDN *FqdnOutboundRule `json:"fqdn,omitempty"`

	// PrivateEndpoint: Mutually exclusive with all other properties
	PrivateEndpoint *PrivateEndpointOutboundRule `json:"privateEndpoint,omitempty"`

	// ServiceTag: Mutually exclusive with all other properties
	ServiceTag *ServiceTagOutboundRule `json:"serviceTag,omitempty"`
}

var _ genruntime.ARMTransformer = &OutboundRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *OutboundRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.OutboundRule{}

	// Set property "FQDN":
	if rule.FQDN != nil {
		fqdn_ARM, err := (*rule.FQDN).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		fqdn := *fqdn_ARM.(*arm.FqdnOutboundRule)
		result.FQDN = &fqdn
	}

	// Set property "PrivateEndpoint":
	if rule.PrivateEndpoint != nil {
		privateEndpoint_ARM, err := (*rule.PrivateEndpoint).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		privateEndpoint := *privateEndpoint_ARM.(*arm.PrivateEndpointOutboundRule)
		result.PrivateEndpoint = &privateEndpoint
	}

	// Set property "ServiceTag":
	if rule.ServiceTag != nil {
		serviceTag_ARM, err := (*rule.ServiceTag).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		serviceTag := *serviceTag_ARM.(*arm.ServiceTagOutboundRule)
		result.ServiceTag = &serviceTag
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *OutboundRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.OutboundRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *OutboundRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.OutboundRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.OutboundRule, got %T", armInput)
	}

	// Set property "FQDN":
	if typedInput.FQDN != nil {
		var fqdn1 FqdnOutboundRule
		err := fqdn1.PopulateFromARM(owner, *typedInput.FQDN)
		if err != nil {
			return err
		}
		fqdn := fqdn1
		rule.FQDN = &fqdn
	}

	// Set property "PrivateEndpoint":
	if typedInput.PrivateEndpoint != nil {
		var privateEndpoint1 PrivateEndpointOutboundRule
		err := privateEndpoint1.PopulateFromARM(owner, *typedInput.PrivateEndpoint)
		if err != nil {
			return err
		}
		privateEndpoint := privateEndpoint1
		rule.PrivateEndpoint = &privateEndpoint
	}

	// Set property "ServiceTag":
	if typedInput.ServiceTag != nil {
		var serviceTag1 ServiceTagOutboundRule
		err := serviceTag1.PopulateFromARM(owner, *typedInput.ServiceTag)
		if err != nil {
			return err
		}
		serviceTag := serviceTag1
		rule.ServiceTag = &serviceTag
	}

	// No error
	return nil
}

// AssignProperties_From_OutboundRule populates our OutboundRule from the provided source OutboundRule
func (rule *OutboundRule) AssignProperties_From_OutboundRule(source *storage.OutboundRule) error {

	// FQDN
	if source.FQDN != nil {
		var fqdn FqdnOutboundRule
		err := fqdn.AssignProperties_From_FqdnOutboundRule(source.FQDN)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_FqdnOutboundRule() to populate field FQDN")
		}
		rule.FQDN = &fqdn
	} else {
		rule.FQDN = nil
	}

	// PrivateEndpoint
	if source.PrivateEndpoint != nil {
		var privateEndpoint PrivateEndpointOutboundRule
		err := privateEndpoint.AssignProperties_From_PrivateEndpointOutboundRule(source.PrivateEndpoint)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PrivateEndpointOutboundRule() to populate field PrivateEndpoint")
		}
		rule.PrivateEndpoint = &privateEndpoint
	} else {
		rule.PrivateEndpoint = nil
	}

	// ServiceTag
	if source.ServiceTag != nil {
		var serviceTag ServiceTagOutboundRule
		err := serviceTag.AssignProperties_From_ServiceTagOutboundRule(source.ServiceTag)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ServiceTagOutboundRule() to populate field ServiceTag")
		}
		rule.ServiceTag = &serviceTag
	} else {
		rule.ServiceTag = nil
	}

	// No error
	return nil
}

// AssignProperties_To_OutboundRule populates the provided destination OutboundRule from our OutboundRule
func (rule *OutboundRule) AssignProperties_To_OutboundRule(destination *storage.OutboundRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// FQDN
	if rule.FQDN != nil {
		var fqdn storage.FqdnOutboundRule
		err := rule.FQDN.AssignProperties_To_FqdnOutboundRule(&fqdn)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_FqdnOutboundRule() to populate field FQDN")
		}
		destination.FQDN = &fqdn
	} else {
		destination.FQDN = nil
	}

	// PrivateEndpoint
	if rule.PrivateEndpoint != nil {
		var privateEndpoint storage.PrivateEndpointOutboundRule
		err := rule.PrivateEndpoint.AssignProperties_To_PrivateEndpointOutboundRule(&privateEndpoint)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PrivateEndpointOutboundRule() to populate field PrivateEndpoint")
		}
		destination.PrivateEndpoint = &privateEndpoint
	} else {
		destination.PrivateEndpoint = nil
	}

	// ServiceTag
	if rule.ServiceTag != nil {
		var serviceTag storage.ServiceTagOutboundRule
		err := rule.ServiceTag.AssignProperties_To_ServiceTagOutboundRule(&serviceTag)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ServiceTagOutboundRule() to populate field ServiceTag")
		}
		destination.ServiceTag = &serviceTag
	} else {
		destination.ServiceTag = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_OutboundRule_STATUS populates our OutboundRule from the provided source OutboundRule_STATUS
func (rule *OutboundRule) Initialize_From_OutboundRule_STATUS(source *OutboundRule_STATUS) error {

	// FQDN
	if source.FQDN != nil {
		var fqdn FqdnOutboundRule
		err := fqdn.Initialize_From_FqdnOutboundRule_STATUS(source.FQDN)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_FqdnOutboundRule_STATUS() to populate field FQDN")
		}
		rule.FQDN = &fqdn
	} else {
		rule.FQDN = nil
	}

	// PrivateEndpoint
	if source.PrivateEndpoint != nil {
		var privateEndpoint PrivateEndpointOutboundRule
		err := privateEndpoint.Initialize_From_PrivateEndpointOutboundRule_STATUS(source.PrivateEndpoint)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_PrivateEndpointOutboundRule_STATUS() to populate field PrivateEndpoint")
		}
		rule.PrivateEndpoint = &privateEndpoint
	} else {
		rule.PrivateEndpoint = nil
	}

	// ServiceTag
	if source.ServiceTag != nil {
		var serviceTag ServiceTagOutboundRule
		err := serviceTag.Initialize_From_ServiceTagOutboundRule_STATUS(source.ServiceTag)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ServiceTagOutboundRule_STATUS() to populate field ServiceTag")
		}
		rule.ServiceTag = &serviceTag
	} else {
		rule.ServiceTag = nil
	}

	// No error
	return nil
}

type OutboundRule_STATUS struct {
	// FQDN: Mutually exclusive with all other properties
	FQDN *FqdnOutboundRule_STATUS `json:"fqdn,omitempty"`

	// PrivateEndpoint: Mutually exclusive with all other properties
	PrivateEndpoint *PrivateEndpointOutboundRule_STATUS `json:"privateEndpoint,omitempty"`

	// ServiceTag: Mutually exclusive with all other properties
	ServiceTag *ServiceTagOutboundRule_STATUS `json:"serviceTag,omitempty"`
}

var _ genruntime.FromARMConverter = &OutboundRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *OutboundRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.OutboundRule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *OutboundRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.OutboundRule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.OutboundRule_STATUS, got %T", armInput)
	}

	// Set property "FQDN":
	if typedInput.FQDN != nil {
		var fqdn1 FqdnOutboundRule_STATUS
		err := fqdn1.PopulateFromARM(owner, *typedInput.FQDN)
		if err != nil {
			return err
		}
		fqdn := fqdn1
		rule.FQDN = &fqdn
	}

	// Set property "PrivateEndpoint":
	if typedInput.PrivateEndpoint != nil {
		var privateEndpoint1 PrivateEndpointOutboundRule_STATUS
		err := privateEndpoint1.PopulateFromARM(owner, *typedInput.PrivateEndpoint)
		if err != nil {
			return err
		}
		privateEndpoint := privateEndpoint1
		rule.PrivateEndpoint = &privateEndpoint
	}

	// Set property "ServiceTag":
	if typedInput.ServiceTag != nil {
		var serviceTag1 ServiceTagOutboundRule_STATUS
		err := serviceTag1.PopulateFromARM(owner, *typedInput.ServiceTag)
		if err != nil {
			return err
		}
		serviceTag := serviceTag1
		rule.ServiceTag = &serviceTag
	}

	// No error
	return nil
}

// AssignProperties_From_OutboundRule_STATUS populates our OutboundRule_STATUS from the provided source OutboundRule_STATUS
func (rule *OutboundRule_STATUS) AssignProperties_From_OutboundRule_STATUS(source *storage.OutboundRule_STATUS) error {

	// FQDN
	if source.FQDN != nil {
		var fqdn FqdnOutboundRule_STATUS
		err := fqdn.AssignProperties_From_FqdnOutboundRule_STATUS(source.FQDN)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_FqdnOutboundRule_STATUS() to populate field FQDN")
		}
		rule.FQDN = &fqdn
	} else {
		rule.FQDN = nil
	}

	// PrivateEndpoint
	if source.PrivateEndpoint != nil {
		var privateEndpoint PrivateEndpointOutboundRule_STATUS
		err := privateEndpoint.AssignProperties_From_PrivateEndpointOutboundRule_STATUS(source.PrivateEndpoint)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PrivateEndpointOutboundRule_STATUS() to populate field PrivateEndpoint")
		}
		rule.PrivateEndpoint = &privateEndpoint
	} else {
		rule.PrivateEndpoint = nil
	}

	// ServiceTag
	if source.ServiceTag != nil {
		var serviceTag ServiceTagOutboundRule_STATUS
		err := serviceTag.AssignProperties_From_ServiceTagOutboundRule_STATUS(source.ServiceTag)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ServiceTagOutboundRule_STATUS() to populate field ServiceTag")
		}
		rule.ServiceTag = &serviceTag
	} else {
		rule.ServiceTag = nil
	}

	// No error
	return nil
}

// AssignProperties_To_OutboundRule_STATUS populates the provided destination OutboundRule_STATUS from our OutboundRule_STATUS
func (rule *OutboundRule_STATUS) AssignProperties_To_OutboundRule_STATUS(destination *storage.OutboundRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// FQDN
	if rule.FQDN != nil {
		var fqdn storage.FqdnOutboundRule_STATUS
		err := rule.FQDN.AssignProperties_To_FqdnOutboundRule_STATUS(&fqdn)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_FqdnOutboundRule_STATUS() to populate field FQDN")
		}
		destination.FQDN = &fqdn
	} else {
		destination.FQDN = nil
	}

	// PrivateEndpoint
	if rule.PrivateEndpoint != nil {
		var privateEndpoint storage.PrivateEndpointOutboundRule_STATUS
		err := rule.PrivateEndpoint.AssignProperties_To_PrivateEndpointOutboundRule_STATUS(&privateEndpoint)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PrivateEndpointOutboundRule_STATUS() to populate field PrivateEndpoint")
		}
		destination.PrivateEndpoint = &privateEndpoint
	} else {
		destination.PrivateEndpoint = nil
	}

	// ServiceTag
	if rule.ServiceTag != nil {
		var serviceTag storage.ServiceTagOutboundRule_STATUS
		err := rule.ServiceTag.AssignProperties_To_ServiceTagOutboundRule_STATUS(&serviceTag)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ServiceTagOutboundRule_STATUS() to populate field ServiceTag")
		}
		destination.ServiceTag = &serviceTag
	} else {
		destination.ServiceTag = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The private endpoint connection status.
// +kubebuilder:validation:Enum={"Approved","Disconnected","Pending","Rejected","Timeout"}
type PrivateEndpointServiceConnectionStatus string

const (
	PrivateEndpointServiceConnectionStatus_Approved     = PrivateEndpointServiceConnectionStatus("Approved")
	PrivateEndpointServiceConnectionStatus_Disconnected = PrivateEndpointServiceConnectionStatus("Disconnected")
	PrivateEndpointServiceConnectionStatus_Pending      = PrivateEndpointServiceConnectionStatus("Pending")
	PrivateEndpointServiceConnectionStatus_Rejected     = PrivateEndpointServiceConnectionStatus("Rejected")
	PrivateEndpointServiceConnectionStatus_Timeout      = PrivateEndpointServiceConnectionStatus("Timeout")
)

// Mapping from string to PrivateEndpointServiceConnectionStatus
var privateEndpointServiceConnectionStatus_Values = map[string]PrivateEndpointServiceConnectionStatus{
	"approved":     PrivateEndpointServiceConnectionStatus_Approved,
	"disconnected": PrivateEndpointServiceConnectionStatus_Disconnected,
	"pending":      PrivateEndpointServiceConnectionStatus_Pending,
	"rejected":     PrivateEndpointServiceConnectionStatus_Rejected,
	"timeout":      PrivateEndpointServiceConnectionStatus_Timeout,
}

// The private endpoint connection status.
type PrivateEndpointServiceConnectionStatus_STATUS string

const (
	PrivateEndpointServiceConnectionStatus_STATUS_Approved     = PrivateEndpointServiceConnectionStatus_STATUS("Approved")
	PrivateEndpointServiceConnectionStatus_STATUS_Disconnected = PrivateEndpointServiceConnectionStatus_STATUS("Disconnected")
	PrivateEndpointServiceConnectionStatus_STATUS_Pending      = PrivateEndpointServiceConnectionStatus_STATUS("Pending")
	PrivateEndpointServiceConnectionStatus_STATUS_Rejected     = PrivateEndpointServiceConnectionStatus_STATUS("Rejected")
	PrivateEndpointServiceConnectionStatus_STATUS_Timeout      = PrivateEndpointServiceConnectionStatus_STATUS("Timeout")
)

// Mapping from string to PrivateEndpointServiceConnectionStatus_STATUS
var privateEndpointServiceConnectionStatus_STATUS_Values = map[string]PrivateEndpointServiceConnectionStatus_STATUS{
	"approved":     PrivateEndpointServiceConnectionStatus_STATUS_Approved,
	"disconnected": PrivateEndpointServiceConnectionStatus_STATUS_Disconnected,
	"pending":      PrivateEndpointServiceConnectionStatus_STATUS_Pending,
	"rejected":     PrivateEndpointServiceConnectionStatus_STATUS_Rejected,
	"timeout":      PrivateEndpointServiceConnectionStatus_STATUS_Timeout,
}

type WorkspaceOperatorSecrets struct {
	// AppInsightsInstrumentationKey: indicates where the AppInsightsInstrumentationKey secret should be placed. If omitted,
	// the secret will not be retrieved from Azure.
	AppInsightsInstrumentationKey *genruntime.SecretDestination `json:"appInsightsInstrumentationKey,omitempty"`

	// ContainerRegistryPassword: indicates where the ContainerRegistryPassword secret should be placed. If omitted, the secret
	// will not be retrieved from Azure.
	ContainerRegistryPassword *genruntime.SecretDestination `json:"containerRegistryPassword,omitempty"`

	// ContainerRegistryPassword2: indicates where the ContainerRegistryPassword2 secret should be placed. If omitted, the
	// secret will not be retrieved from Azure.
	ContainerRegistryPassword2 *genruntime.SecretDestination `json:"containerRegistryPassword2,omitempty"`

	// ContainerRegistryUserName: indicates where the ContainerRegistryUserName secret should be placed. If omitted, the secret
	// will not be retrieved from Azure.
	ContainerRegistryUserName *genruntime.SecretDestination `json:"containerRegistryUserName,omitempty"`

	// PrimaryNotebookAccessKey: indicates where the PrimaryNotebookAccessKey secret should be placed. If omitted, the secret
	// will not be retrieved from Azure.
	PrimaryNotebookAccessKey *genruntime.SecretDestination `json:"primaryNotebookAccessKey,omitempty"`

	// SecondaryNotebookAccessKey: indicates where the SecondaryNotebookAccessKey secret should be placed. If omitted, the
	// secret will not be retrieved from Azure.
	SecondaryNotebookAccessKey *genruntime.SecretDestination `json:"secondaryNotebookAccessKey,omitempty"`

	// UserStorageKey: indicates where the UserStorageKey secret should be placed. If omitted, the secret will not be retrieved
	// from Azure.
	UserStorageKey *genruntime.SecretDestination `json:"userStorageKey,omitempty"`
}

// AssignProperties_From_WorkspaceOperatorSecrets populates our WorkspaceOperatorSecrets from the provided source WorkspaceOperatorSecrets
func (secrets *WorkspaceOperatorSecrets) AssignProperties_From_WorkspaceOperatorSecrets(source *storage.WorkspaceOperatorSecrets) error {

	// AppInsightsInstrumentationKey
	if source.AppInsightsInstrumentationKey != nil {
		appInsightsInstrumentationKey := source.AppInsightsInstrumentationKey.Copy()
		secrets.AppInsightsInstrumentationKey = &appInsightsInstrumentationKey
	} else {
		secrets.AppInsightsInstrumentationKey = nil
	}

	// ContainerRegistryPassword
	if source.ContainerRegistryPassword != nil {
		containerRegistryPassword := source.ContainerRegistryPassword.Copy()
		secrets.ContainerRegistryPassword = &containerRegistryPassword
	} else {
		secrets.ContainerRegistryPassword = nil
	}

	// ContainerRegistryPassword2
	if source.ContainerRegistryPassword2 != nil {
		containerRegistryPassword2 := source.ContainerRegistryPassword2.Copy()
		secrets.ContainerRegistryPassword2 = &containerRegistryPassword2
	} else {
		secrets.ContainerRegistryPassword2 = nil
	}

	// ContainerRegistryUserName
	if source.ContainerRegistryUserName != nil {
		containerRegistryUserName := source.ContainerRegistryUserName.Copy()
		secrets.ContainerRegistryUserName = &containerRegistryUserName
	} else {
		secrets.ContainerRegistryUserName = nil
	}

	// PrimaryNotebookAccessKey
	if source.PrimaryNotebookAccessKey != nil {
		primaryNotebookAccessKey := source.PrimaryNotebookAccessKey.Copy()
		secrets.PrimaryNotebookAccessKey = &primaryNotebookAccessKey
	} else {
		secrets.PrimaryNotebookAccessKey = nil
	}

	// SecondaryNotebookAccessKey
	if source.SecondaryNotebookAccessKey != nil {
		secondaryNotebookAccessKey := source.SecondaryNotebookAccessKey.Copy()
		secrets.SecondaryNotebookAccessKey = &secondaryNotebookAccessKey
	} else {
		secrets.SecondaryNotebookAccessKey = nil
	}

	// UserStorageKey
	if source.UserStorageKey != nil {
		userStorageKey := source.UserStorageKey.Copy()
		secrets.UserStorageKey = &userStorageKey
	} else {
		secrets.UserStorageKey = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WorkspaceOperatorSecrets populates the provided destination WorkspaceOperatorSecrets from our WorkspaceOperatorSecrets
func (secrets *WorkspaceOperatorSecrets) AssignProperties_To_WorkspaceOperatorSecrets(destination *storage.WorkspaceOperatorSecrets) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AppInsightsInstrumentationKey
	if secrets.AppInsightsInstrumentationKey != nil {
		appInsightsInstrumentationKey := secrets.AppInsightsInstrumentationKey.Copy()
		destination.AppInsightsInstrumentationKey = &appInsightsInstrumentationKey
	} else {
		destination.AppInsightsInstrumentationKey = nil
	}

	// ContainerRegistryPassword
	if secrets.ContainerRegistryPassword != nil {
		containerRegistryPassword := secrets.ContainerRegistryPassword.Copy()
		destination.ContainerRegistryPassword = &containerRegistryPassword
	} else {
		destination.ContainerRegistryPassword = nil
	}

	// ContainerRegistryPassword2
	if secrets.ContainerRegistryPassword2 != nil {
		containerRegistryPassword2 := secrets.ContainerRegistryPassword2.Copy()
		destination.ContainerRegistryPassword2 = &containerRegistryPassword2
	} else {
		destination.ContainerRegistryPassword2 = nil
	}

	// ContainerRegistryUserName
	if secrets.ContainerRegistryUserName != nil {
		containerRegistryUserName := secrets.ContainerRegistryUserName.Copy()
		destination.ContainerRegistryUserName = &containerRegistryUserName
	} else {
		destination.ContainerRegistryUserName = nil
	}

	// PrimaryNotebookAccessKey
	if secrets.PrimaryNotebookAccessKey != nil {
		primaryNotebookAccessKey := secrets.PrimaryNotebookAccessKey.Copy()
		destination.PrimaryNotebookAccessKey = &primaryNotebookAccessKey
	} else {
		destination.PrimaryNotebookAccessKey = nil
	}

	// SecondaryNotebookAccessKey
	if secrets.SecondaryNotebookAccessKey != nil {
		secondaryNotebookAccessKey := secrets.SecondaryNotebookAccessKey.Copy()
		destination.SecondaryNotebookAccessKey = &secondaryNotebookAccessKey
	} else {
		destination.SecondaryNotebookAccessKey = nil
	}

	// UserStorageKey
	if secrets.UserStorageKey != nil {
		userStorageKey := secrets.UserStorageKey.Copy()
		destination.UserStorageKey = &userStorageKey
	} else {
		destination.UserStorageKey = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type FqdnOutboundRule struct {
	// Category: Category of a managed network Outbound Rule of a machine learning workspace.
	Category    *RuleCategory `json:"category,omitempty"`
	Destination *string       `json:"destination,omitempty"`

	// Status: Type of a managed network Outbound Rule of a machine learning workspace.
	Status *RuleStatus `json:"status,omitempty"`

	// +kubebuilder:validation:Required
	Type *FqdnOutboundRule_Type `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &FqdnOutboundRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *FqdnOutboundRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.FqdnOutboundRule{}

	// Set property "Category":
	if rule.Category != nil {
		var temp string
		temp = string(*rule.Category)
		category := arm.RuleCategory(temp)
		result.Category = &category
	}

	// Set property "Destination":
	if rule.Destination != nil {
		destination := *rule.Destination
		result.Destination = &destination
	}

	// Set property "Status":
	if rule.Status != nil {
		var temp string
		temp = string(*rule.Status)
		status := arm.RuleStatus(temp)
		result.Status = &status
	}

	// Set property "Type":
	if rule.Type != nil {
		var temp arm.FqdnOutboundRule_Type
		var temp1 string
		temp1 = string(*rule.Type)
		temp = arm.FqdnOutboundRule_Type(temp1)
		result.Type = temp
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *FqdnOutboundRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FqdnOutboundRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *FqdnOutboundRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FqdnOutboundRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FqdnOutboundRule, got %T", armInput)
	}

	// Set property "Category":
	if typedInput.Category != nil {
		var temp string
		temp = string(*typedInput.Category)
		category := RuleCategory(temp)
		rule.Category = &category
	}

	// Set property "Destination":
	if typedInput.Destination != nil {
		destination := *typedInput.Destination
		rule.Destination = &destination
	}

	// Set property "Status":
	if typedInput.Status != nil {
		var temp string
		temp = string(*typedInput.Status)
		status := RuleStatus(temp)
		rule.Status = &status
	}

	// Set property "Type":
	var temp FqdnOutboundRule_Type
	var temp1 string
	temp1 = string(typedInput.Type)
	temp = FqdnOutboundRule_Type(temp1)
	rule.Type = &temp

	// No error
	return nil
}

// AssignProperties_From_FqdnOutboundRule populates our FqdnOutboundRule from the provided source FqdnOutboundRule
func (rule *FqdnOutboundRule) AssignProperties_From_FqdnOutboundRule(source *storage.FqdnOutboundRule) error {

	// Category
	if source.Category != nil {
		category := *source.Category
		categoryTemp := genruntime.ToEnum(category, ruleCategory_Values)
		rule.Category = &categoryTemp
	} else {
		rule.Category = nil
	}

	// Destination
	rule.Destination = genruntime.ClonePointerToString(source.Destination)

	// Status
	if source.Status != nil {
		status := *source.Status
		statusTemp := genruntime.ToEnum(status, ruleStatus_Values)
		rule.Status = &statusTemp
	} else {
		rule.Status = nil
	}

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, fqdnOutboundRule_Type_Values)
		rule.Type = &typeTemp
	} else {
		rule.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FqdnOutboundRule populates the provided destination FqdnOutboundRule from our FqdnOutboundRule
func (rule *FqdnOutboundRule) AssignProperties_To_FqdnOutboundRule(destination *storage.FqdnOutboundRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Category
	if rule.Category != nil {
		category := string(*rule.Category)
		destination.Category = &category
	} else {
		destination.Category = nil
	}

	// Destination
	destination.Destination = genruntime.ClonePointerToString(rule.Destination)

	// Status
	if rule.Status != nil {
		status := string(*rule.Status)
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Type
	if rule.Type != nil {
		typeVar := string(*rule.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_FqdnOutboundRule_STATUS populates our FqdnOutboundRule from the provided source FqdnOutboundRule_STATUS
func (rule *FqdnOutboundRule) Initialize_From_FqdnOutboundRule_STATUS(source *FqdnOutboundRule_STATUS) error {

	// Category
	if source.Category != nil {
		category := genruntime.ToEnum(string(*source.Category), ruleCategory_Values)
		rule.Category = &category
	} else {
		rule.Category = nil
	}

	// Destination
	rule.Destination = genruntime.ClonePointerToString(source.Destination)

	// Status
	if source.Status != nil {
		status := genruntime.ToEnum(string(*source.Status), ruleStatus_Values)
		rule.Status = &status
	} else {
		rule.Status = nil
	}

	// Type
	if source.Type != nil {
		typeVar := genruntime.ToEnum(string(*source.Type), fqdnOutboundRule_Type_Values)
		rule.Type = &typeVar
	} else {
		rule.Type = nil
	}

	// No error
	return nil
}

type FqdnOutboundRule_STATUS struct {
	// Category: Category of a managed network Outbound Rule of a machine learning workspace.
	Category    *RuleCategory_STATUS `json:"category,omitempty"`
	Destination *string              `json:"destination,omitempty"`

	// Status: Type of a managed network Outbound Rule of a machine learning workspace.
	Status *RuleStatus_STATUS            `json:"status,omitempty"`
	Type   *FqdnOutboundRule_Type_STATUS `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &FqdnOutboundRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *FqdnOutboundRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FqdnOutboundRule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *FqdnOutboundRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FqdnOutboundRule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FqdnOutboundRule_STATUS, got %T", armInput)
	}

	// Set property "Category":
	if typedInput.Category != nil {
		var temp string
		temp = string(*typedInput.Category)
		category := RuleCategory_STATUS(temp)
		rule.Category = &category
	}

	// Set property "Destination":
	if typedInput.Destination != nil {
		destination := *typedInput.Destination
		rule.Destination = &destination
	}

	// Set property "Status":
	if typedInput.Status != nil {
		var temp string
		temp = string(*typedInput.Status)
		status := RuleStatus_STATUS(temp)
		rule.Status = &status
	}

	// Set property "Type":
	var temp FqdnOutboundRule_Type_STATUS
	var temp1 string
	temp1 = string(typedInput.Type)
	temp = FqdnOutboundRule_Type_STATUS(temp1)
	rule.Type = &temp

	// No error
	return nil
}

// AssignProperties_From_FqdnOutboundRule_STATUS populates our FqdnOutboundRule_STATUS from the provided source FqdnOutboundRule_STATUS
func (rule *FqdnOutboundRule_STATUS) AssignProperties_From_FqdnOutboundRule_STATUS(source *storage.FqdnOutboundRule_STATUS) error {

	// Category
	if source.Category != nil {
		category := *source.Category
		categoryTemp := genruntime.ToEnum(category, ruleCategory_STATUS_Values)
		rule.Category = &categoryTemp
	} else {
		rule.Category = nil
	}

	// Destination
	rule.Destination = genruntime.ClonePointerToString(source.Destination)

	// Status
	if source.Status != nil {
		status := *source.Status
		statusTemp := genruntime.ToEnum(status, ruleStatus_STATUS_Values)
		rule.Status = &statusTemp
	} else {
		rule.Status = nil
	}

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, fqdnOutboundRule_Type_STATUS_Values)
		rule.Type = &typeTemp
	} else {
		rule.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_FqdnOutboundRule_STATUS populates the provided destination FqdnOutboundRule_STATUS from our FqdnOutboundRule_STATUS
func (rule *FqdnOutboundRule_STATUS) AssignProperties_To_FqdnOutboundRule_STATUS(destination *storage.FqdnOutboundRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Category
	if rule.Category != nil {
		category := string(*rule.Category)
		destination.Category = &category
	} else {
		destination.Category = nil
	}

	// Destination
	destination.Destination = genruntime.ClonePointerToString(rule.Destination)

	// Status
	if rule.Status != nil {
		status := string(*rule.Status)
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Type
	if rule.Type != nil {
		typeVar := string(*rule.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Status for the managed network of a machine learning workspace.
// +kubebuilder:validation:Enum={"Active","Inactive"}
type ManagedNetworkStatus string

const (
	ManagedNetworkStatus_Active   = ManagedNetworkStatus("Active")
	ManagedNetworkStatus_Inactive = ManagedNetworkStatus("Inactive")
)

// Mapping from string to ManagedNetworkStatus
var managedNetworkStatus_Values = map[string]ManagedNetworkStatus{
	"active":   ManagedNetworkStatus_Active,
	"inactive": ManagedNetworkStatus_Inactive,
}

// Status for the managed network of a machine learning workspace.
type ManagedNetworkStatus_STATUS string

const (
	ManagedNetworkStatus_STATUS_Active   = ManagedNetworkStatus_STATUS("Active")
	ManagedNetworkStatus_STATUS_Inactive = ManagedNetworkStatus_STATUS("Inactive")
)

// Mapping from string to ManagedNetworkStatus_STATUS
var managedNetworkStatus_STATUS_Values = map[string]ManagedNetworkStatus_STATUS{
	"active":   ManagedNetworkStatus_STATUS_Active,
	"inactive": ManagedNetworkStatus_STATUS_Inactive,
}

type PrivateEndpointOutboundRule struct {
	// Category: Category of a managed network Outbound Rule of a machine learning workspace.
	Category *RuleCategory `json:"category,omitempty"`

	// Destination: Private Endpoint destination for a Private Endpoint Outbound Rule for the managed network of a machine
	// learning  workspace.
	Destination *PrivateEndpointDestination `json:"destination,omitempty"`

	// Status: Type of a managed network Outbound Rule of a machine learning workspace.
	Status *RuleStatus `json:"status,omitempty"`

	// +kubebuilder:validation:Required
	Type *PrivateEndpointOutboundRule_Type `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &PrivateEndpointOutboundRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *PrivateEndpointOutboundRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.PrivateEndpointOutboundRule{}

	// Set property "Category":
	if rule.Category != nil {
		var temp string
		temp = string(*rule.Category)
		category := arm.RuleCategory(temp)
		result.Category = &category
	}

	// Set property "Destination":
	if rule.Destination != nil {
		destination_ARM, err := (*rule.Destination).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		destination := *destination_ARM.(*arm.PrivateEndpointDestination)
		result.Destination = &destination
	}

	// Set property "Status":
	if rule.Status != nil {
		var temp string
		temp = string(*rule.Status)
		status := arm.RuleStatus(temp)
		result.Status = &status
	}

	// Set property "Type":
	if rule.Type != nil {
		var temp arm.PrivateEndpointOutboundRule_Type
		var temp1 string
		temp1 = string(*rule.Type)
		temp = arm.PrivateEndpointOutboundRule_Type(temp1)
		result.Type = temp
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *PrivateEndpointOutboundRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PrivateEndpointOutboundRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *PrivateEndpointOutboundRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PrivateEndpointOutboundRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PrivateEndpointOutboundRule, got %T", armInput)
	}

	// Set property "Category":
	if typedInput.Category != nil {
		var temp string
		temp = string(*typedInput.Category)
		category := RuleCategory(temp)
		rule.Category = &category
	}

	// Set property "Destination":
	if typedInput.Destination != nil {
		var destination1 PrivateEndpointDestination
		err := destination1.PopulateFromARM(owner, *typedInput.Destination)
		if err != nil {
			return err
		}
		destination := destination1
		rule.Destination = &destination
	}

	// Set property "Status":
	if typedInput.Status != nil {
		var temp string
		temp = string(*typedInput.Status)
		status := RuleStatus(temp)
		rule.Status = &status
	}

	// Set property "Type":
	var temp PrivateEndpointOutboundRule_Type
	var temp1 string
	temp1 = string(typedInput.Type)
	temp = PrivateEndpointOutboundRule_Type(temp1)
	rule.Type = &temp

	// No error
	return nil
}

// AssignProperties_From_PrivateEndpointOutboundRule populates our PrivateEndpointOutboundRule from the provided source PrivateEndpointOutboundRule
func (rule *PrivateEndpointOutboundRule) AssignProperties_From_PrivateEndpointOutboundRule(source *storage.PrivateEndpointOutboundRule) error {

	// Category
	if source.Category != nil {
		category := *source.Category
		categoryTemp := genruntime.ToEnum(category, ruleCategory_Values)
		rule.Category = &categoryTemp
	} else {
		rule.Category = nil
	}

	// Destination
	if source.Destination != nil {
		var destination PrivateEndpointDestination
		err := destination.AssignProperties_From_PrivateEndpointDestination(source.Destination)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PrivateEndpointDestination() to populate field Destination")
		}
		rule.Destination = &destination
	} else {
		rule.Destination = nil
	}

	// Status
	if source.Status != nil {
		status := *source.Status
		statusTemp := genruntime.ToEnum(status, ruleStatus_Values)
		rule.Status = &statusTemp
	} else {
		rule.Status = nil
	}

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, privateEndpointOutboundRule_Type_Values)
		rule.Type = &typeTemp
	} else {
		rule.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PrivateEndpointOutboundRule populates the provided destination PrivateEndpointOutboundRule from our PrivateEndpointOutboundRule
func (rule *PrivateEndpointOutboundRule) AssignProperties_To_PrivateEndpointOutboundRule(destination *storage.PrivateEndpointOutboundRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Category
	if rule.Category != nil {
		category := string(*rule.Category)
		destination.Category = &category
	} else {
		destination.Category = nil
	}

	// Destination
	if rule.Destination != nil {
		var destinationLocal storage.PrivateEndpointDestination
		err := rule.Destination.AssignProperties_To_PrivateEndpointDestination(&destinationLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PrivateEndpointDestination() to populate field Destination")
		}
		destination.Destination = &destinationLocal
	} else {
		destination.Destination = nil
	}

	// Status
	if rule.Status != nil {
		status := string(*rule.Status)
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Type
	if rule.Type != nil {
		typeVar := string(*rule.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_PrivateEndpointOutboundRule_STATUS populates our PrivateEndpointOutboundRule from the provided source PrivateEndpointOutboundRule_STATUS
func (rule *PrivateEndpointOutboundRule) Initialize_From_PrivateEndpointOutboundRule_STATUS(source *PrivateEndpointOutboundRule_STATUS) error {

	// Category
	if source.Category != nil {
		category := genruntime.ToEnum(string(*source.Category), ruleCategory_Values)
		rule.Category = &category
	} else {
		rule.Category = nil
	}

	// Destination
	if source.Destination != nil {
		var destination PrivateEndpointDestination
		err := destination.Initialize_From_PrivateEndpointDestination_STATUS(source.Destination)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_PrivateEndpointDestination_STATUS() to populate field Destination")
		}
		rule.Destination = &destination
	} else {
		rule.Destination = nil
	}

	// Status
	if source.Status != nil {
		status := genruntime.ToEnum(string(*source.Status), ruleStatus_Values)
		rule.Status = &status
	} else {
		rule.Status = nil
	}

	// Type
	if source.Type != nil {
		typeVar := genruntime.ToEnum(string(*source.Type), privateEndpointOutboundRule_Type_Values)
		rule.Type = &typeVar
	} else {
		rule.Type = nil
	}

	// No error
	return nil
}

type PrivateEndpointOutboundRule_STATUS struct {
	// Category: Category of a managed network Outbound Rule of a machine learning workspace.
	Category *RuleCategory_STATUS `json:"category,omitempty"`

	// Destination: Private Endpoint destination for a Private Endpoint Outbound Rule for the managed network of a machine
	// learning  workspace.
	Destination *PrivateEndpointDestination_STATUS `json:"destination,omitempty"`

	// Status: Type of a managed network Outbound Rule of a machine learning workspace.
	Status *RuleStatus_STATUS                       `json:"status,omitempty"`
	Type   *PrivateEndpointOutboundRule_Type_STATUS `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &PrivateEndpointOutboundRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *PrivateEndpointOutboundRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PrivateEndpointOutboundRule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *PrivateEndpointOutboundRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PrivateEndpointOutboundRule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PrivateEndpointOutboundRule_STATUS, got %T", armInput)
	}

	// Set property "Category":
	if typedInput.Category != nil {
		var temp string
		temp = string(*typedInput.Category)
		category := RuleCategory_STATUS(temp)
		rule.Category = &category
	}

	// Set property "Destination":
	if typedInput.Destination != nil {
		var destination1 PrivateEndpointDestination_STATUS
		err := destination1.PopulateFromARM(owner, *typedInput.Destination)
		if err != nil {
			return err
		}
		destination := destination1
		rule.Destination = &destination
	}

	// Set property "Status":
	if typedInput.Status != nil {
		var temp string
		temp = string(*typedInput.Status)
		status := RuleStatus_STATUS(temp)
		rule.Status = &status
	}

	// Set property "Type":
	var temp PrivateEndpointOutboundRule_Type_STATUS
	var temp1 string
	temp1 = string(typedInput.Type)
	temp = PrivateEndpointOutboundRule_Type_STATUS(temp1)
	rule.Type = &temp

	// No error
	return nil
}

// AssignProperties_From_PrivateEndpointOutboundRule_STATUS populates our PrivateEndpointOutboundRule_STATUS from the provided source PrivateEndpointOutboundRule_STATUS
func (rule *PrivateEndpointOutboundRule_STATUS) AssignProperties_From_PrivateEndpointOutboundRule_STATUS(source *storage.PrivateEndpointOutboundRule_STATUS) error {

	// Category
	if source.Category != nil {
		category := *source.Category
		categoryTemp := genruntime.ToEnum(category, ruleCategory_STATUS_Values)
		rule.Category = &categoryTemp
	} else {
		rule.Category = nil
	}

	// Destination
	if source.Destination != nil {
		var destination PrivateEndpointDestination_STATUS
		err := destination.AssignProperties_From_PrivateEndpointDestination_STATUS(source.Destination)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PrivateEndpointDestination_STATUS() to populate field Destination")
		}
		rule.Destination = &destination
	} else {
		rule.Destination = nil
	}

	// Status
	if source.Status != nil {
		status := *source.Status
		statusTemp := genruntime.ToEnum(status, ruleStatus_STATUS_Values)
		rule.Status = &statusTemp
	} else {
		rule.Status = nil
	}

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, privateEndpointOutboundRule_Type_STATUS_Values)
		rule.Type = &typeTemp
	} else {
		rule.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PrivateEndpointOutboundRule_STATUS populates the provided destination PrivateEndpointOutboundRule_STATUS from our PrivateEndpointOutboundRule_STATUS
func (rule *PrivateEndpointOutboundRule_STATUS) AssignProperties_To_PrivateEndpointOutboundRule_STATUS(destination *storage.PrivateEndpointOutboundRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Category
	if rule.Category != nil {
		category := string(*rule.Category)
		destination.Category = &category
	} else {
		destination.Category = nil
	}

	// Destination
	if rule.Destination != nil {
		var destinationLocal storage.PrivateEndpointDestination_STATUS
		err := rule.Destination.AssignProperties_To_PrivateEndpointDestination_STATUS(&destinationLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PrivateEndpointDestination_STATUS() to populate field Destination")
		}
		destination.Destination = &destinationLocal
	} else {
		destination.Destination = nil
	}

	// Status
	if rule.Status != nil {
		status := string(*rule.Status)
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Type
	if rule.Type != nil {
		typeVar := string(*rule.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ServiceTagOutboundRule struct {
	// Category: Category of a managed network Outbound Rule of a machine learning workspace.
	Category *RuleCategory `json:"category,omitempty"`

	// Destination: Service Tag destination for a Service Tag Outbound Rule for the managed network of a machine learning
	// workspace.
	Destination *ServiceTagDestination `json:"destination,omitempty"`

	// Status: Type of a managed network Outbound Rule of a machine learning workspace.
	Status *RuleStatus `json:"status,omitempty"`

	// +kubebuilder:validation:Required
	Type *ServiceTagOutboundRule_Type `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &ServiceTagOutboundRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *ServiceTagOutboundRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.ServiceTagOutboundRule{}

	// Set property "Category":
	if rule.Category != nil {
		var temp string
		temp = string(*rule.Category)
		category := arm.RuleCategory(temp)
		result.Category = &category
	}

	// Set property "Destination":
	if rule.Destination != nil {
		destination_ARM, err := (*rule.Destination).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		destination := *destination_ARM.(*arm.ServiceTagDestination)
		result.Destination = &destination
	}

	// Set property "Status":
	if rule.Status != nil {
		var temp string
		temp = string(*rule.Status)
		status := arm.RuleStatus(temp)
		result.Status = &status
	}

	// Set property "Type":
	if rule.Type != nil {
		var temp arm.ServiceTagOutboundRule_Type
		var temp1 string
		temp1 = string(*rule.Type)
		temp = arm.ServiceTagOutboundRule_Type(temp1)
		result.Type = temp
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *ServiceTagOutboundRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ServiceTagOutboundRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *ServiceTagOutboundRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ServiceTagOutboundRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ServiceTagOutboundRule, got %T", armInput)
	}

	// Set property "Category":
	if typedInput.Category != nil {
		var temp string
		temp = string(*typedInput.Category)
		category := RuleCategory(temp)
		rule.Category = &category
	}

	// Set property "Destination":
	if typedInput.Destination != nil {
		var destination1 ServiceTagDestination
		err := destination1.PopulateFromARM(owner, *typedInput.Destination)
		if err != nil {
			return err
		}
		destination := destination1
		rule.Destination = &destination
	}

	// Set property "Status":
	if typedInput.Status != nil {
		var temp string
		temp = string(*typedInput.Status)
		status := RuleStatus(temp)
		rule.Status = &status
	}

	// Set property "Type":
	var temp ServiceTagOutboundRule_Type
	var temp1 string
	temp1 = string(typedInput.Type)
	temp = ServiceTagOutboundRule_Type(temp1)
	rule.Type = &temp

	// No error
	return nil
}

// AssignProperties_From_ServiceTagOutboundRule populates our ServiceTagOutboundRule from the provided source ServiceTagOutboundRule
func (rule *ServiceTagOutboundRule) AssignProperties_From_ServiceTagOutboundRule(source *storage.ServiceTagOutboundRule) error {

	// Category
	if source.Category != nil {
		category := *source.Category
		categoryTemp := genruntime.ToEnum(category, ruleCategory_Values)
		rule.Category = &categoryTemp
	} else {
		rule.Category = nil
	}

	// Destination
	if source.Destination != nil {
		var destination ServiceTagDestination
		err := destination.AssignProperties_From_ServiceTagDestination(source.Destination)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ServiceTagDestination() to populate field Destination")
		}
		rule.Destination = &destination
	} else {
		rule.Destination = nil
	}

	// Status
	if source.Status != nil {
		status := *source.Status
		statusTemp := genruntime.ToEnum(status, ruleStatus_Values)
		rule.Status = &statusTemp
	} else {
		rule.Status = nil
	}

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, serviceTagOutboundRule_Type_Values)
		rule.Type = &typeTemp
	} else {
		rule.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ServiceTagOutboundRule populates the provided destination ServiceTagOutboundRule from our ServiceTagOutboundRule
func (rule *ServiceTagOutboundRule) AssignProperties_To_ServiceTagOutboundRule(destination *storage.ServiceTagOutboundRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Category
	if rule.Category != nil {
		category := string(*rule.Category)
		destination.Category = &category
	} else {
		destination.Category = nil
	}

	// Destination
	if rule.Destination != nil {
		var destinationLocal storage.ServiceTagDestination
		err := rule.Destination.AssignProperties_To_ServiceTagDestination(&destinationLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ServiceTagDestination() to populate field Destination")
		}
		destination.Destination = &destinationLocal
	} else {
		destination.Destination = nil
	}

	// Status
	if rule.Status != nil {
		status := string(*rule.Status)
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Type
	if rule.Type != nil {
		typeVar := string(*rule.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ServiceTagOutboundRule_STATUS populates our ServiceTagOutboundRule from the provided source ServiceTagOutboundRule_STATUS
func (rule *ServiceTagOutboundRule) Initialize_From_ServiceTagOutboundRule_STATUS(source *ServiceTagOutboundRule_STATUS) error {

	// Category
	if source.Category != nil {
		category := genruntime.ToEnum(string(*source.Category), ruleCategory_Values)
		rule.Category = &category
	} else {
		rule.Category = nil
	}

	// Destination
	if source.Destination != nil {
		var destination ServiceTagDestination
		err := destination.Initialize_From_ServiceTagDestination_STATUS(source.Destination)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ServiceTagDestination_STATUS() to populate field Destination")
		}
		rule.Destination = &destination
	} else {
		rule.Destination = nil
	}

	// Status
	if source.Status != nil {
		status := genruntime.ToEnum(string(*source.Status), ruleStatus_Values)
		rule.Status = &status
	} else {
		rule.Status = nil
	}

	// Type
	if source.Type != nil {
		typeVar := genruntime.ToEnum(string(*source.Type), serviceTagOutboundRule_Type_Values)
		rule.Type = &typeVar
	} else {
		rule.Type = nil
	}

	// No error
	return nil
}

type ServiceTagOutboundRule_STATUS struct {
	// Category: Category of a managed network Outbound Rule of a machine learning workspace.
	Category *RuleCategory_STATUS `json:"category,omitempty"`

	// Destination: Service Tag destination for a Service Tag Outbound Rule for the managed network of a machine learning
	// workspace.
	Destination *ServiceTagDestination_STATUS `json:"destination,omitempty"`

	// Status: Type of a managed network Outbound Rule of a machine learning workspace.
	Status *RuleStatus_STATUS                  `json:"status,omitempty"`
	Type   *ServiceTagOutboundRule_Type_STATUS `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &ServiceTagOutboundRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *ServiceTagOutboundRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ServiceTagOutboundRule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *ServiceTagOutboundRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ServiceTagOutboundRule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ServiceTagOutboundRule_STATUS, got %T", armInput)
	}

	// Set property "Category":
	if typedInput.Category != nil {
		var temp string
		temp = string(*typedInput.Category)
		category := RuleCategory_STATUS(temp)
		rule.Category = &category
	}

	// Set property "Destination":
	if typedInput.Destination != nil {
		var destination1 ServiceTagDestination_STATUS
		err := destination1.PopulateFromARM(owner, *typedInput.Destination)
		if err != nil {
			return err
		}
		destination := destination1
		rule.Destination = &destination
	}

	// Set property "Status":
	if typedInput.Status != nil {
		var temp string
		temp = string(*typedInput.Status)
		status := RuleStatus_STATUS(temp)
		rule.Status = &status
	}

	// Set property "Type":
	var temp ServiceTagOutboundRule_Type_STATUS
	var temp1 string
	temp1 = string(typedInput.Type)
	temp = ServiceTagOutboundRule_Type_STATUS(temp1)
	rule.Type = &temp

	// No error
	return nil
}

// AssignProperties_From_ServiceTagOutboundRule_STATUS populates our ServiceTagOutboundRule_STATUS from the provided source ServiceTagOutboundRule_STATUS
func (rule *ServiceTagOutboundRule_STATUS) AssignProperties_From_ServiceTagOutboundRule_STATUS(source *storage.ServiceTagOutboundRule_STATUS) error {

	// Category
	if source.Category != nil {
		category := *source.Category
		categoryTemp := genruntime.ToEnum(category, ruleCategory_STATUS_Values)
		rule.Category = &categoryTemp
	} else {
		rule.Category = nil
	}

	// Destination
	if source.Destination != nil {
		var destination ServiceTagDestination_STATUS
		err := destination.AssignProperties_From_ServiceTagDestination_STATUS(source.Destination)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ServiceTagDestination_STATUS() to populate field Destination")
		}
		rule.Destination = &destination
	} else {
		rule.Destination = nil
	}

	// Status
	if source.Status != nil {
		status := *source.Status
		statusTemp := genruntime.ToEnum(status, ruleStatus_STATUS_Values)
		rule.Status = &statusTemp
	} else {
		rule.Status = nil
	}

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, serviceTagOutboundRule_Type_STATUS_Values)
		rule.Type = &typeTemp
	} else {
		rule.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ServiceTagOutboundRule_STATUS populates the provided destination ServiceTagOutboundRule_STATUS from our ServiceTagOutboundRule_STATUS
func (rule *ServiceTagOutboundRule_STATUS) AssignProperties_To_ServiceTagOutboundRule_STATUS(destination *storage.ServiceTagOutboundRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Category
	if rule.Category != nil {
		category := string(*rule.Category)
		destination.Category = &category
	} else {
		destination.Category = nil
	}

	// Destination
	if rule.Destination != nil {
		var destinationLocal storage.ServiceTagDestination_STATUS
		err := rule.Destination.AssignProperties_To_ServiceTagDestination_STATUS(&destinationLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ServiceTagDestination_STATUS() to populate field Destination")
		}
		destination.Destination = &destinationLocal
	} else {
		destination.Destination = nil
	}

	// Status
	if rule.Status != nil {
		status := string(*rule.Status)
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Type
	if rule.Type != nil {
		typeVar := string(*rule.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"FQDN"}
type FqdnOutboundRule_Type string

const FqdnOutboundRule_Type_FQDN = FqdnOutboundRule_Type("FQDN")

// Mapping from string to FqdnOutboundRule_Type
var fqdnOutboundRule_Type_Values = map[string]FqdnOutboundRule_Type{
	"fqdn": FqdnOutboundRule_Type_FQDN,
}

type FqdnOutboundRule_Type_STATUS string

const FqdnOutboundRule_Type_STATUS_FQDN = FqdnOutboundRule_Type_STATUS("FQDN")

// Mapping from string to FqdnOutboundRule_Type_STATUS
var fqdnOutboundRule_Type_STATUS_Values = map[string]FqdnOutboundRule_Type_STATUS{
	"fqdn": FqdnOutboundRule_Type_STATUS_FQDN,
}

// Private Endpoint destination for a Private Endpoint Outbound Rule for the managed network of a machine learning
// workspace.
type PrivateEndpointDestination struct {
	ServiceResourceReference *genruntime.ResourceReference `armReference:"ServiceResourceId" json:"serviceResourceReference,omitempty"`
	SparkEnabled             *bool                         `json:"sparkEnabled,omitempty"`

	// SparkStatus: Type of a managed network Outbound Rule of a machine learning workspace.
	SparkStatus                *RuleStatus                   `json:"sparkStatus,omitempty"`
	SubresourceTargetReference *genruntime.ResourceReference `armReference:"SubresourceTarget" json:"subresourceTargetReference,omitempty"`
}

var _ genruntime.ARMTransformer = &PrivateEndpointDestination{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (destination *PrivateEndpointDestination) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if destination == nil {
		return nil, nil
	}
	result := &arm.PrivateEndpointDestination{}

	// Set property "ServiceResourceId":
	if destination.ServiceResourceReference != nil {
		serviceResourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*destination.ServiceResourceReference)
		if err != nil {
			return nil, err
		}
		serviceResourceReference := serviceResourceReferenceARMID
		result.ServiceResourceId = &serviceResourceReference
	}

	// Set property "SparkEnabled":
	if destination.SparkEnabled != nil {
		sparkEnabled := *destination.SparkEnabled
		result.SparkEnabled = &sparkEnabled
	}

	// Set property "SparkStatus":
	if destination.SparkStatus != nil {
		var temp string
		temp = string(*destination.SparkStatus)
		sparkStatus := arm.RuleStatus(temp)
		result.SparkStatus = &sparkStatus
	}

	// Set property "SubresourceTarget":
	if destination.SubresourceTargetReference != nil {
		subresourceTargetReferenceARMID, err := resolved.ResolvedReferences.Lookup(*destination.SubresourceTargetReference)
		if err != nil {
			return nil, err
		}
		subresourceTargetReference := subresourceTargetReferenceARMID
		result.SubresourceTarget = &subresourceTargetReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (destination *PrivateEndpointDestination) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PrivateEndpointDestination{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (destination *PrivateEndpointDestination) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PrivateEndpointDestination)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PrivateEndpointDestination, got %T", armInput)
	}

	// no assignment for property "ServiceResourceReference"

	// Set property "SparkEnabled":
	if typedInput.SparkEnabled != nil {
		sparkEnabled := *typedInput.SparkEnabled
		destination.SparkEnabled = &sparkEnabled
	}

	// Set property "SparkStatus":
	if typedInput.SparkStatus != nil {
		var temp string
		temp = string(*typedInput.SparkStatus)
		sparkStatus := RuleStatus(temp)
		destination.SparkStatus = &sparkStatus
	}

	// no assignment for property "SubresourceTargetReference"

	// No error
	return nil
}

// AssignProperties_From_PrivateEndpointDestination populates our PrivateEndpointDestination from the provided source PrivateEndpointDestination
func (destination *PrivateEndpointDestination) AssignProperties_From_PrivateEndpointDestination(source *storage.PrivateEndpointDestination) error {

	// ServiceResourceReference
	if source.ServiceResourceReference != nil {
		serviceResourceReference := source.ServiceResourceReference.Copy()
		destination.ServiceResourceReference = &serviceResourceReference
	} else {
		destination.ServiceResourceReference = nil
	}

	// SparkEnabled
	if source.SparkEnabled != nil {
		sparkEnabled := *source.SparkEnabled
		destination.SparkEnabled = &sparkEnabled
	} else {
		destination.SparkEnabled = nil
	}

	// SparkStatus
	if source.SparkStatus != nil {
		sparkStatus := *source.SparkStatus
		sparkStatusTemp := genruntime.ToEnum(sparkStatus, ruleStatus_Values)
		destination.SparkStatus = &sparkStatusTemp
	} else {
		destination.SparkStatus = nil
	}

	// SubresourceTargetReference
	if source.SubresourceTargetReference != nil {
		subresourceTargetReference := source.SubresourceTargetReference.Copy()
		destination.SubresourceTargetReference = &subresourceTargetReference
	} else {
		destination.SubresourceTargetReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PrivateEndpointDestination populates the provided destination PrivateEndpointDestination from our PrivateEndpointDestination
func (destination *PrivateEndpointDestination) AssignProperties_To_PrivateEndpointDestination(target *storage.PrivateEndpointDestination) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ServiceResourceReference
	if destination.ServiceResourceReference != nil {
		serviceResourceReference := destination.ServiceResourceReference.Copy()
		target.ServiceResourceReference = &serviceResourceReference
	} else {
		target.ServiceResourceReference = nil
	}

	// SparkEnabled
	if destination.SparkEnabled != nil {
		sparkEnabled := *destination.SparkEnabled
		target.SparkEnabled = &sparkEnabled
	} else {
		target.SparkEnabled = nil
	}

	// SparkStatus
	if destination.SparkStatus != nil {
		sparkStatus := string(*destination.SparkStatus)
		target.SparkStatus = &sparkStatus
	} else {
		target.SparkStatus = nil
	}

	// SubresourceTargetReference
	if destination.SubresourceTargetReference != nil {
		subresourceTargetReference := destination.SubresourceTargetReference.Copy()
		target.SubresourceTargetReference = &subresourceTargetReference
	} else {
		target.SubresourceTargetReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_PrivateEndpointDestination_STATUS populates our PrivateEndpointDestination from the provided source PrivateEndpointDestination_STATUS
func (destination *PrivateEndpointDestination) Initialize_From_PrivateEndpointDestination_STATUS(source *PrivateEndpointDestination_STATUS) error {

	// ServiceResourceReference
	if source.ServiceResourceId != nil {
		serviceResourceReference := genruntime.CreateResourceReferenceFromARMID(*source.ServiceResourceId)
		destination.ServiceResourceReference = &serviceResourceReference
	} else {
		destination.ServiceResourceReference = nil
	}

	// SparkEnabled
	if source.SparkEnabled != nil {
		sparkEnabled := *source.SparkEnabled
		destination.SparkEnabled = &sparkEnabled
	} else {
		destination.SparkEnabled = nil
	}

	// SparkStatus
	if source.SparkStatus != nil {
		sparkStatus := genruntime.ToEnum(string(*source.SparkStatus), ruleStatus_Values)
		destination.SparkStatus = &sparkStatus
	} else {
		destination.SparkStatus = nil
	}

	// No error
	return nil
}

// Private Endpoint destination for a Private Endpoint Outbound Rule for the managed network of a machine learning
// workspace.
type PrivateEndpointDestination_STATUS struct {
	ServiceResourceId *string `json:"serviceResourceId,omitempty"`
	SparkEnabled      *bool   `json:"sparkEnabled,omitempty"`

	// SparkStatus: Type of a managed network Outbound Rule of a machine learning workspace.
	SparkStatus       *RuleStatus_STATUS `json:"sparkStatus,omitempty"`
	SubresourceTarget *string            `json:"subresourceTarget,omitempty"`
}

var _ genruntime.FromARMConverter = &PrivateEndpointDestination_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (destination *PrivateEndpointDestination_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PrivateEndpointDestination_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (destination *PrivateEndpointDestination_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PrivateEndpointDestination_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PrivateEndpointDestination_STATUS, got %T", armInput)
	}

	// Set property "ServiceResourceId":
	if typedInput.ServiceResourceId != nil {
		serviceResourceId := *typedInput.ServiceResourceId
		destination.ServiceResourceId = &serviceResourceId
	}

	// Set property "SparkEnabled":
	if typedInput.SparkEnabled != nil {
		sparkEnabled := *typedInput.SparkEnabled
		destination.SparkEnabled = &sparkEnabled
	}

	// Set property "SparkStatus":
	if typedInput.SparkStatus != nil {
		var temp string
		temp = string(*typedInput.SparkStatus)
		sparkStatus := RuleStatus_STATUS(temp)
		destination.SparkStatus = &sparkStatus
	}

	// Set property "SubresourceTarget":
	if typedInput.SubresourceTarget != nil {
		subresourceTarget := *typedInput.SubresourceTarget
		destination.SubresourceTarget = &subresourceTarget
	}

	// No error
	return nil
}

// AssignProperties_From_PrivateEndpointDestination_STATUS populates our PrivateEndpointDestination_STATUS from the provided source PrivateEndpointDestination_STATUS
func (destination *PrivateEndpointDestination_STATUS) AssignProperties_From_PrivateEndpointDestination_STATUS(source *storage.PrivateEndpointDestination_STATUS) error {

	// ServiceResourceId
	destination.ServiceResourceId = genruntime.ClonePointerToString(source.ServiceResourceId)

	// SparkEnabled
	if source.SparkEnabled != nil {
		sparkEnabled := *source.SparkEnabled
		destination.SparkEnabled = &sparkEnabled
	} else {
		destination.SparkEnabled = nil
	}

	// SparkStatus
	if source.SparkStatus != nil {
		sparkStatus := *source.SparkStatus
		sparkStatusTemp := genruntime.ToEnum(sparkStatus, ruleStatus_STATUS_Values)
		destination.SparkStatus = &sparkStatusTemp
	} else {
		destination.SparkStatus = nil
	}

	// SubresourceTarget
	destination.SubresourceTarget = genruntime.ClonePointerToString(source.SubresourceTarget)

	// No error
	return nil
}

// AssignProperties_To_PrivateEndpointDestination_STATUS populates the provided destination PrivateEndpointDestination_STATUS from our PrivateEndpointDestination_STATUS
func (destination *PrivateEndpointDestination_STATUS) AssignProperties_To_PrivateEndpointDestination_STATUS(target *storage.PrivateEndpointDestination_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ServiceResourceId
	target.ServiceResourceId = genruntime.ClonePointerToString(destination.ServiceResourceId)

	// SparkEnabled
	if destination.SparkEnabled != nil {
		sparkEnabled := *destination.SparkEnabled
		target.SparkEnabled = &sparkEnabled
	} else {
		target.SparkEnabled = nil
	}

	// SparkStatus
	if destination.SparkStatus != nil {
		sparkStatus := string(*destination.SparkStatus)
		target.SparkStatus = &sparkStatus
	} else {
		target.SparkStatus = nil
	}

	// SubresourceTarget
	target.SubresourceTarget = genruntime.ClonePointerToString(destination.SubresourceTarget)

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"PrivateEndpoint"}
type PrivateEndpointOutboundRule_Type string

const PrivateEndpointOutboundRule_Type_PrivateEndpoint = PrivateEndpointOutboundRule_Type("PrivateEndpoint")

// Mapping from string to PrivateEndpointOutboundRule_Type
var privateEndpointOutboundRule_Type_Values = map[string]PrivateEndpointOutboundRule_Type{
	"privateendpoint": PrivateEndpointOutboundRule_Type_PrivateEndpoint,
}

type PrivateEndpointOutboundRule_Type_STATUS string

const PrivateEndpointOutboundRule_Type_STATUS_PrivateEndpoint = PrivateEndpointOutboundRule_Type_STATUS("PrivateEndpoint")

// Mapping from string to PrivateEndpointOutboundRule_Type_STATUS
var privateEndpointOutboundRule_Type_STATUS_Values = map[string]PrivateEndpointOutboundRule_Type_STATUS{
	"privateendpoint": PrivateEndpointOutboundRule_Type_STATUS_PrivateEndpoint,
}

// Category of a managed network Outbound Rule of a machine learning workspace.
// +kubebuilder:validation:Enum={"Dependency","Recommended","Required","UserDefined"}
type RuleCategory string

const (
	RuleCategory_Dependency  = RuleCategory("Dependency")
	RuleCategory_Recommended = RuleCategory("Recommended")
	RuleCategory_Required    = RuleCategory("Required")
	RuleCategory_UserDefined = RuleCategory("UserDefined")
)

// Mapping from string to RuleCategory
var ruleCategory_Values = map[string]RuleCategory{
	"dependency":  RuleCategory_Dependency,
	"recommended": RuleCategory_Recommended,
	"required":    RuleCategory_Required,
	"userdefined": RuleCategory_UserDefined,
}

// Category of a managed network Outbound Rule of a machine learning workspace.
type RuleCategory_STATUS string

const (
	RuleCategory_STATUS_Dependency  = RuleCategory_STATUS("Dependency")
	RuleCategory_STATUS_Recommended = RuleCategory_STATUS("Recommended")
	RuleCategory_STATUS_Required    = RuleCategory_STATUS("Required")
	RuleCategory_STATUS_UserDefined = RuleCategory_STATUS("UserDefined")
)

// Mapping from string to RuleCategory_STATUS
var ruleCategory_STATUS_Values = map[string]RuleCategory_STATUS{
	"dependency":  RuleCategory_STATUS_Dependency,
	"recommended": RuleCategory_STATUS_Recommended,
	"required":    RuleCategory_STATUS_Required,
	"userdefined": RuleCategory_STATUS_UserDefined,
}

// Type of a managed network Outbound Rule of a machine learning workspace.
// +kubebuilder:validation:Enum={"Active","Inactive"}
type RuleStatus string

const (
	RuleStatus_Active   = RuleStatus("Active")
	RuleStatus_Inactive = RuleStatus("Inactive")
)

// Mapping from string to RuleStatus
var ruleStatus_Values = map[string]RuleStatus{
	"active":   RuleStatus_Active,
	"inactive": RuleStatus_Inactive,
}

// Type of a managed network Outbound Rule of a machine learning workspace.
type RuleStatus_STATUS string

const (
	RuleStatus_STATUS_Active   = RuleStatus_STATUS("Active")
	RuleStatus_STATUS_Inactive = RuleStatus_STATUS("Inactive")
)

// Mapping from string to RuleStatus_STATUS
var ruleStatus_STATUS_Values = map[string]RuleStatus_STATUS{
	"active":   RuleStatus_STATUS_Active,
	"inactive": RuleStatus_STATUS_Inactive,
}

// Service Tag destination for a Service Tag Outbound Rule for the managed network of a machine learning workspace.
type ServiceTagDestination struct {
	// Action: The action enum for networking rule.
	Action     *RuleAction `json:"action,omitempty"`
	PortRanges *string     `json:"portRanges,omitempty"`
	Protocol   *string     `json:"protocol,omitempty"`
	ServiceTag *string     `json:"serviceTag,omitempty"`
}

var _ genruntime.ARMTransformer = &ServiceTagDestination{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (destination *ServiceTagDestination) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if destination == nil {
		return nil, nil
	}
	result := &arm.ServiceTagDestination{}

	// Set property "Action":
	if destination.Action != nil {
		var temp string
		temp = string(*destination.Action)
		action := arm.RuleAction(temp)
		result.Action = &action
	}

	// Set property "PortRanges":
	if destination.PortRanges != nil {
		portRanges := *destination.PortRanges
		result.PortRanges = &portRanges
	}

	// Set property "Protocol":
	if destination.Protocol != nil {
		protocol := *destination.Protocol
		result.Protocol = &protocol
	}

	// Set property "ServiceTag":
	if destination.ServiceTag != nil {
		serviceTag := *destination.ServiceTag
		result.ServiceTag = &serviceTag
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (destination *ServiceTagDestination) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ServiceTagDestination{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (destination *ServiceTagDestination) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ServiceTagDestination)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ServiceTagDestination, got %T", armInput)
	}

	// Set property "Action":
	if typedInput.Action != nil {
		var temp string
		temp = string(*typedInput.Action)
		action := RuleAction(temp)
		destination.Action = &action
	}

	// Set property "PortRanges":
	if typedInput.PortRanges != nil {
		portRanges := *typedInput.PortRanges
		destination.PortRanges = &portRanges
	}

	// Set property "Protocol":
	if typedInput.Protocol != nil {
		protocol := *typedInput.Protocol
		destination.Protocol = &protocol
	}

	// Set property "ServiceTag":
	if typedInput.ServiceTag != nil {
		serviceTag := *typedInput.ServiceTag
		destination.ServiceTag = &serviceTag
	}

	// No error
	return nil
}

// AssignProperties_From_ServiceTagDestination populates our ServiceTagDestination from the provided source ServiceTagDestination
func (destination *ServiceTagDestination) AssignProperties_From_ServiceTagDestination(source *storage.ServiceTagDestination) error {

	// Action
	if source.Action != nil {
		action := *source.Action
		actionTemp := genruntime.ToEnum(action, ruleAction_Values)
		destination.Action = &actionTemp
	} else {
		destination.Action = nil
	}

	// PortRanges
	destination.PortRanges = genruntime.ClonePointerToString(source.PortRanges)

	// Protocol
	destination.Protocol = genruntime.ClonePointerToString(source.Protocol)

	// ServiceTag
	destination.ServiceTag = genruntime.ClonePointerToString(source.ServiceTag)

	// No error
	return nil
}

// AssignProperties_To_ServiceTagDestination populates the provided destination ServiceTagDestination from our ServiceTagDestination
func (destination *ServiceTagDestination) AssignProperties_To_ServiceTagDestination(target *storage.ServiceTagDestination) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	if destination.Action != nil {
		action := string(*destination.Action)
		target.Action = &action
	} else {
		target.Action = nil
	}

	// PortRanges
	target.PortRanges = genruntime.ClonePointerToString(destination.PortRanges)

	// Protocol
	target.Protocol = genruntime.ClonePointerToString(destination.Protocol)

	// ServiceTag
	target.ServiceTag = genruntime.ClonePointerToString(destination.ServiceTag)

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ServiceTagDestination_STATUS populates our ServiceTagDestination from the provided source ServiceTagDestination_STATUS
func (destination *ServiceTagDestination) Initialize_From_ServiceTagDestination_STATUS(source *ServiceTagDestination_STATUS) error {

	// Action
	if source.Action != nil {
		action := genruntime.ToEnum(string(*source.Action), ruleAction_Values)
		destination.Action = &action
	} else {
		destination.Action = nil
	}

	// PortRanges
	destination.PortRanges = genruntime.ClonePointerToString(source.PortRanges)

	// Protocol
	destination.Protocol = genruntime.ClonePointerToString(source.Protocol)

	// ServiceTag
	destination.ServiceTag = genruntime.ClonePointerToString(source.ServiceTag)

	// No error
	return nil
}

// Service Tag destination for a Service Tag Outbound Rule for the managed network of a machine learning workspace.
type ServiceTagDestination_STATUS struct {
	// Action: The action enum for networking rule.
	Action *RuleAction_STATUS `json:"action,omitempty"`

	// AddressPrefixes: Optional, if provided, the ServiceTag property will be ignored.
	AddressPrefixes []string `json:"addressPrefixes,omitempty"`
	PortRanges      *string  `json:"portRanges,omitempty"`
	Protocol        *string  `json:"protocol,omitempty"`
	ServiceTag      *string  `json:"serviceTag,omitempty"`
}

var _ genruntime.FromARMConverter = &ServiceTagDestination_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (destination *ServiceTagDestination_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ServiceTagDestination_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (destination *ServiceTagDestination_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ServiceTagDestination_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ServiceTagDestination_STATUS, got %T", armInput)
	}

	// Set property "Action":
	if typedInput.Action != nil {
		var temp string
		temp = string(*typedInput.Action)
		action := RuleAction_STATUS(temp)
		destination.Action = &action
	}

	// Set property "AddressPrefixes":
	for _, item := range typedInput.AddressPrefixes {
		destination.AddressPrefixes = append(destination.AddressPrefixes, item)
	}

	// Set property "PortRanges":
	if typedInput.PortRanges != nil {
		portRanges := *typedInput.PortRanges
		destination.PortRanges = &portRanges
	}

	// Set property "Protocol":
	if typedInput.Protocol != nil {
		protocol := *typedInput.Protocol
		destination.Protocol = &protocol
	}

	// Set property "ServiceTag":
	if typedInput.ServiceTag != nil {
		serviceTag := *typedInput.ServiceTag
		destination.ServiceTag = &serviceTag
	}

	// No error
	return nil
}

// AssignProperties_From_ServiceTagDestination_STATUS populates our ServiceTagDestination_STATUS from the provided source ServiceTagDestination_STATUS
func (destination *ServiceTagDestination_STATUS) AssignProperties_From_ServiceTagDestination_STATUS(source *storage.ServiceTagDestination_STATUS) error {

	// Action
	if source.Action != nil {
		action := *source.Action
		actionTemp := genruntime.ToEnum(action, ruleAction_STATUS_Values)
		destination.Action = &actionTemp
	} else {
		destination.Action = nil
	}

	// AddressPrefixes
	destination.AddressPrefixes = genruntime.CloneSliceOfString(source.AddressPrefixes)

	// PortRanges
	destination.PortRanges = genruntime.ClonePointerToString(source.PortRanges)

	// Protocol
	destination.Protocol = genruntime.ClonePointerToString(source.Protocol)

	// ServiceTag
	destination.ServiceTag = genruntime.ClonePointerToString(source.ServiceTag)

	// No error
	return nil
}

// AssignProperties_To_ServiceTagDestination_STATUS populates the provided destination ServiceTagDestination_STATUS from our ServiceTagDestination_STATUS
func (destination *ServiceTagDestination_STATUS) AssignProperties_To_ServiceTagDestination_STATUS(target *storage.ServiceTagDestination_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	if destination.Action != nil {
		action := string(*destination.Action)
		target.Action = &action
	} else {
		target.Action = nil
	}

	// AddressPrefixes
	target.AddressPrefixes = genruntime.CloneSliceOfString(destination.AddressPrefixes)

	// PortRanges
	target.PortRanges = genruntime.ClonePointerToString(destination.PortRanges)

	// Protocol
	target.Protocol = genruntime.ClonePointerToString(destination.Protocol)

	// ServiceTag
	target.ServiceTag = genruntime.ClonePointerToString(destination.ServiceTag)

	// Update the property bag
	if len(propertyBag) > 0 {
		target.PropertyBag = propertyBag
	} else {
		target.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"ServiceTag"}
type ServiceTagOutboundRule_Type string

const ServiceTagOutboundRule_Type_ServiceTag = ServiceTagOutboundRule_Type("ServiceTag")

// Mapping from string to ServiceTagOutboundRule_Type
var serviceTagOutboundRule_Type_Values = map[string]ServiceTagOutboundRule_Type{
	"servicetag": ServiceTagOutboundRule_Type_ServiceTag,
}

type ServiceTagOutboundRule_Type_STATUS string

const ServiceTagOutboundRule_Type_STATUS_ServiceTag = ServiceTagOutboundRule_Type_STATUS("ServiceTag")

// Mapping from string to ServiceTagOutboundRule_Type_STATUS
var serviceTagOutboundRule_Type_STATUS_Values = map[string]ServiceTagOutboundRule_Type_STATUS{
	"servicetag": ServiceTagOutboundRule_Type_STATUS_ServiceTag,
}

// The action enum for networking rule.
// +kubebuilder:validation:Enum={"Allow","Deny"}
type RuleAction string

const (
	RuleAction_Allow = RuleAction("Allow")
	RuleAction_Deny  = RuleAction("Deny")
)

// Mapping from string to RuleAction
var ruleAction_Values = map[string]RuleAction{
	"allow": RuleAction_Allow,
	"deny":  RuleAction_Deny,
}

// The action enum for networking rule.
type RuleAction_STATUS string

const (
	RuleAction_STATUS_Allow = RuleAction_STATUS("Allow")
	RuleAction_STATUS_Deny  = RuleAction_STATUS("Deny")
)

// Mapping from string to RuleAction_STATUS
var ruleAction_STATUS_Values = map[string]RuleAction_STATUS{
	"allow": RuleAction_STATUS_Allow,
	"deny":  RuleAction_STATUS_Deny,
}

func init() {
	SchemeBuilder.Register(&Workspace{}, &WorkspaceList{})
}
