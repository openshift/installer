// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20230501preview

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/apimanagement/v1api20230501preview/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/apimanagement/v1api20230501preview/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/rotisserie/eris"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /apimanagement/resource-manager/Microsoft.ApiManagement/preview/2023-05-01-preview/apimbackends.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/backends/{backendId}
type Backend struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              Backend_Spec   `json:"spec,omitempty"`
	Status            Backend_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &Backend{}

// GetConditions returns the conditions of the resource
func (backend *Backend) GetConditions() conditions.Conditions {
	return backend.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (backend *Backend) SetConditions(conditions conditions.Conditions) {
	backend.Status.Conditions = conditions
}

var _ conversion.Convertible = &Backend{}

// ConvertFrom populates our Backend from the provided hub Backend
func (backend *Backend) ConvertFrom(hub conversion.Hub) error {
	// intermediate variable for conversion
	var source storage.Backend

	err := source.ConvertFrom(hub)
	if err != nil {
		return eris.Wrap(err, "converting from hub to source")
	}

	err = backend.AssignProperties_From_Backend(&source)
	if err != nil {
		return eris.Wrap(err, "converting from source to backend")
	}

	return nil
}

// ConvertTo populates the provided hub Backend from our Backend
func (backend *Backend) ConvertTo(hub conversion.Hub) error {
	// intermediate variable for conversion
	var destination storage.Backend
	err := backend.AssignProperties_To_Backend(&destination)
	if err != nil {
		return eris.Wrap(err, "converting to destination from backend")
	}
	err = destination.ConvertTo(hub)
	if err != nil {
		return eris.Wrap(err, "converting from destination to hub")
	}

	return nil
}

var _ configmaps.Exporter = &Backend{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (backend *Backend) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if backend.Spec.OperatorSpec == nil {
		return nil
	}
	return backend.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &Backend{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (backend *Backend) SecretDestinationExpressions() []*core.DestinationExpression {
	if backend.Spec.OperatorSpec == nil {
		return nil
	}
	return backend.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.KubernetesResource = &Backend{}

// AzureName returns the Azure name of the resource
func (backend *Backend) AzureName() string {
	return backend.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2023-05-01-preview"
func (backend Backend) GetAPIVersion() string {
	return "2023-05-01-preview"
}

// GetResourceScope returns the scope of the resource
func (backend *Backend) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (backend *Backend) GetSpec() genruntime.ConvertibleSpec {
	return &backend.Spec
}

// GetStatus returns the status of this resource
func (backend *Backend) GetStatus() genruntime.ConvertibleStatus {
	return &backend.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (backend *Backend) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationHead,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.ApiManagement/service/backends"
func (backend *Backend) GetType() string {
	return "Microsoft.ApiManagement/service/backends"
}

// NewEmptyStatus returns a new empty (blank) status
func (backend *Backend) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &Backend_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (backend *Backend) Owner() *genruntime.ResourceReference {
	if backend.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(backend.Spec)
	return backend.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (backend *Backend) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*Backend_STATUS); ok {
		backend.Status = *st
		return nil
	}

	// Convert status to required version
	var st Backend_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	backend.Status = st
	return nil
}

// AssignProperties_From_Backend populates our Backend from the provided source Backend
func (backend *Backend) AssignProperties_From_Backend(source *storage.Backend) error {

	// ObjectMeta
	backend.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec Backend_Spec
	err := spec.AssignProperties_From_Backend_Spec(&source.Spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_Backend_Spec() to populate field Spec")
	}
	backend.Spec = spec

	// Status
	var status Backend_STATUS
	err = status.AssignProperties_From_Backend_STATUS(&source.Status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_Backend_STATUS() to populate field Status")
	}
	backend.Status = status

	// No error
	return nil
}

// AssignProperties_To_Backend populates the provided destination Backend from our Backend
func (backend *Backend) AssignProperties_To_Backend(destination *storage.Backend) error {

	// ObjectMeta
	destination.ObjectMeta = *backend.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.Backend_Spec
	err := backend.Spec.AssignProperties_To_Backend_Spec(&spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_Backend_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.Backend_STATUS
	err = backend.Status.AssignProperties_To_Backend_STATUS(&status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_Backend_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (backend *Backend) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: backend.Spec.OriginalVersion(),
		Kind:    "Backend",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /apimanagement/resource-manager/Microsoft.ApiManagement/preview/2023-05-01-preview/apimbackends.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ApiManagement/service/{serviceName}/backends/{backendId}
type BackendList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Backend `json:"items"`
}

type Backend_Spec struct {
	// +kubebuilder:validation:MaxLength=80
	// +kubebuilder:validation:MinLength=1
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// CircuitBreaker: Backend Circuit Breaker Configuration
	CircuitBreaker *BackendCircuitBreaker `json:"circuitBreaker,omitempty"`

	// Credentials: Backend Credentials Contract Properties
	Credentials *BackendCredentialsContract `json:"credentials,omitempty"`

	// +kubebuilder:validation:MaxLength=2000
	// +kubebuilder:validation:MinLength=1
	// Description: Backend Description.
	Description *string `json:"description,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *BackendOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a apimanagement.azure.com/Service resource
	Owner *genruntime.KnownResourceReference `group:"apimanagement.azure.com" json:"owner,omitempty" kind:"Service"`

	// Pool: Backend pool information
	Pool *BackendPool `json:"pool,omitempty"`

	// Properties: Backend Properties contract
	Properties *BackendProperties `json:"properties,omitempty"`

	// +kubebuilder:validation:Required
	// Protocol: Backend communication protocol.
	Protocol *BackendContractProperties_Protocol `json:"protocol,omitempty"`

	// Proxy: Backend gateway Contract Properties
	Proxy *BackendProxyContract `json:"proxy,omitempty"`

	// ResourceReference: Management Uri of the Resource in External System. This URL can be the Arm Resource Id of Logic Apps,
	// Function Apps or API Apps.
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`

	// +kubebuilder:validation:MaxLength=300
	// +kubebuilder:validation:MinLength=1
	// Title: Backend Title.
	Title *string `json:"title,omitempty"`

	// Tls: Backend TLS Properties
	Tls *BackendTlsProperties `json:"tls,omitempty"`

	// Type: Type of the backend. A backend can be either Single or Pool.
	Type *BackendContractProperties_Type `json:"type,omitempty"`

	// +kubebuilder:validation:Required
	// +kubebuilder:validation:MaxLength=2000
	// +kubebuilder:validation:MinLength=1
	// Url: Runtime Url of the Backend.
	Url *string `json:"url,omitempty"`
}

var _ genruntime.ARMTransformer = &Backend_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (backend *Backend_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if backend == nil {
		return nil, nil
	}
	result := &arm.Backend_Spec{}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if backend.CircuitBreaker != nil ||
		backend.Credentials != nil ||
		backend.Description != nil ||
		backend.Pool != nil ||
		backend.Properties != nil ||
		backend.Protocol != nil ||
		backend.Proxy != nil ||
		backend.ResourceReference != nil ||
		backend.Title != nil ||
		backend.Tls != nil ||
		backend.Type != nil ||
		backend.Url != nil {
		result.Properties = &arm.BackendContractProperties{}
	}
	if backend.CircuitBreaker != nil {
		circuitBreaker_ARM, err := (*backend.CircuitBreaker).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		circuitBreaker := *circuitBreaker_ARM.(*arm.BackendCircuitBreaker)
		result.Properties.CircuitBreaker = &circuitBreaker
	}
	if backend.Credentials != nil {
		credentials_ARM, err := (*backend.Credentials).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		credentials := *credentials_ARM.(*arm.BackendCredentialsContract)
		result.Properties.Credentials = &credentials
	}
	if backend.Description != nil {
		description := *backend.Description
		result.Properties.Description = &description
	}
	if backend.Pool != nil {
		pool_ARM, err := (*backend.Pool).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		pool := *pool_ARM.(*arm.BackendPool)
		result.Properties.Pool = &pool
	}
	if backend.Properties != nil {
		properties_ARM, err := (*backend.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*arm.BackendProperties)
		result.Properties.Properties = &properties
	}
	if backend.Protocol != nil {
		var temp string
		temp = string(*backend.Protocol)
		protocol := arm.BackendContractProperties_Protocol(temp)
		result.Properties.Protocol = &protocol
	}
	if backend.Proxy != nil {
		proxy_ARM, err := (*backend.Proxy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		proxy := *proxy_ARM.(*arm.BackendProxyContract)
		result.Properties.Proxy = &proxy
	}
	if backend.ResourceReference != nil {
		resourceIdARMID, err := resolved.ResolvedReferences.Lookup(*backend.ResourceReference)
		if err != nil {
			return nil, err
		}
		resourceId := resourceIdARMID
		result.Properties.ResourceId = &resourceId
	}
	if backend.Title != nil {
		title := *backend.Title
		result.Properties.Title = &title
	}
	if backend.Tls != nil {
		tls_ARM, err := (*backend.Tls).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		tls := *tls_ARM.(*arm.BackendTlsProperties)
		result.Properties.Tls = &tls
	}
	if backend.Type != nil {
		var temp string
		temp = string(*backend.Type)
		typeVar := arm.BackendContractProperties_Type(temp)
		result.Properties.Type = &typeVar
	}
	if backend.Url != nil {
		url := *backend.Url
		result.Properties.Url = &url
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (backend *Backend_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Backend_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (backend *Backend_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Backend_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Backend_Spec, got %T", armInput)
	}

	// Set property "AzureName":
	backend.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "CircuitBreaker":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CircuitBreaker != nil {
			var circuitBreaker1 BackendCircuitBreaker
			err := circuitBreaker1.PopulateFromARM(owner, *typedInput.Properties.CircuitBreaker)
			if err != nil {
				return err
			}
			circuitBreaker := circuitBreaker1
			backend.CircuitBreaker = &circuitBreaker
		}
	}

	// Set property "Credentials":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Credentials != nil {
			var credentials1 BackendCredentialsContract
			err := credentials1.PopulateFromARM(owner, *typedInput.Properties.Credentials)
			if err != nil {
				return err
			}
			credentials := credentials1
			backend.Credentials = &credentials
		}
	}

	// Set property "Description":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Description != nil {
			description := *typedInput.Properties.Description
			backend.Description = &description
		}
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	backend.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "Pool":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Pool != nil {
			var pool1 BackendPool
			err := pool1.PopulateFromARM(owner, *typedInput.Properties.Pool)
			if err != nil {
				return err
			}
			pool := pool1
			backend.Pool = &pool
		}
	}

	// Set property "Properties":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Properties != nil {
			var properties1 BackendProperties
			err := properties1.PopulateFromARM(owner, *typedInput.Properties.Properties)
			if err != nil {
				return err
			}
			properties := properties1
			backend.Properties = &properties
		}
	}

	// Set property "Protocol":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Protocol != nil {
			var temp string
			temp = string(*typedInput.Properties.Protocol)
			protocol := BackendContractProperties_Protocol(temp)
			backend.Protocol = &protocol
		}
	}

	// Set property "Proxy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Proxy != nil {
			var proxy1 BackendProxyContract
			err := proxy1.PopulateFromARM(owner, *typedInput.Properties.Proxy)
			if err != nil {
				return err
			}
			proxy := proxy1
			backend.Proxy = &proxy
		}
	}

	// no assignment for property "ResourceReference"

	// Set property "Title":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Title != nil {
			title := *typedInput.Properties.Title
			backend.Title = &title
		}
	}

	// Set property "Tls":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Tls != nil {
			var tls1 BackendTlsProperties
			err := tls1.PopulateFromARM(owner, *typedInput.Properties.Tls)
			if err != nil {
				return err
			}
			tls := tls1
			backend.Tls = &tls
		}
	}

	// Set property "Type":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Type != nil {
			var temp string
			temp = string(*typedInput.Properties.Type)
			typeVar := BackendContractProperties_Type(temp)
			backend.Type = &typeVar
		}
	}

	// Set property "Url":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Url != nil {
			url := *typedInput.Properties.Url
			backend.Url = &url
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &Backend_Spec{}

// ConvertSpecFrom populates our Backend_Spec from the provided source
func (backend *Backend_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.Backend_Spec)
	if ok {
		// Populate our instance from source
		return backend.AssignProperties_From_Backend_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.Backend_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = backend.AssignProperties_From_Backend_Spec(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our Backend_Spec
func (backend *Backend_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.Backend_Spec)
	if ok {
		// Populate destination from our instance
		return backend.AssignProperties_To_Backend_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.Backend_Spec{}
	err := backend.AssignProperties_To_Backend_Spec(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_Backend_Spec populates our Backend_Spec from the provided source Backend_Spec
func (backend *Backend_Spec) AssignProperties_From_Backend_Spec(source *storage.Backend_Spec) error {

	// AzureName
	backend.AzureName = source.AzureName

	// CircuitBreaker
	if source.CircuitBreaker != nil {
		var circuitBreaker BackendCircuitBreaker
		err := circuitBreaker.AssignProperties_From_BackendCircuitBreaker(source.CircuitBreaker)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BackendCircuitBreaker() to populate field CircuitBreaker")
		}
		backend.CircuitBreaker = &circuitBreaker
	} else {
		backend.CircuitBreaker = nil
	}

	// Credentials
	if source.Credentials != nil {
		var credential BackendCredentialsContract
		err := credential.AssignProperties_From_BackendCredentialsContract(source.Credentials)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BackendCredentialsContract() to populate field Credentials")
		}
		backend.Credentials = &credential
	} else {
		backend.Credentials = nil
	}

	// Description
	backend.Description = genruntime.ClonePointerToString(source.Description)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec BackendOperatorSpec
		err := operatorSpec.AssignProperties_From_BackendOperatorSpec(source.OperatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BackendOperatorSpec() to populate field OperatorSpec")
		}
		backend.OperatorSpec = &operatorSpec
	} else {
		backend.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		backend.Owner = &owner
	} else {
		backend.Owner = nil
	}

	// Pool
	if source.Pool != nil {
		var pool BackendPool
		err := pool.AssignProperties_From_BackendPool(source.Pool)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BackendPool() to populate field Pool")
		}
		backend.Pool = &pool
	} else {
		backend.Pool = nil
	}

	// Properties
	if source.Properties != nil {
		var property BackendProperties
		err := property.AssignProperties_From_BackendProperties(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BackendProperties() to populate field Properties")
		}
		backend.Properties = &property
	} else {
		backend.Properties = nil
	}

	// Protocol
	if source.Protocol != nil {
		protocol := *source.Protocol
		protocolTemp := genruntime.ToEnum(protocol, backendContractProperties_Protocol_Values)
		backend.Protocol = &protocolTemp
	} else {
		backend.Protocol = nil
	}

	// Proxy
	if source.Proxy != nil {
		var proxy BackendProxyContract
		err := proxy.AssignProperties_From_BackendProxyContract(source.Proxy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BackendProxyContract() to populate field Proxy")
		}
		backend.Proxy = &proxy
	} else {
		backend.Proxy = nil
	}

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		backend.ResourceReference = &resourceReference
	} else {
		backend.ResourceReference = nil
	}

	// Title
	backend.Title = genruntime.ClonePointerToString(source.Title)

	// Tls
	if source.Tls != nil {
		var tl BackendTlsProperties
		err := tl.AssignProperties_From_BackendTlsProperties(source.Tls)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BackendTlsProperties() to populate field Tls")
		}
		backend.Tls = &tl
	} else {
		backend.Tls = nil
	}

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, backendContractProperties_Type_Values)
		backend.Type = &typeTemp
	} else {
		backend.Type = nil
	}

	// Url
	backend.Url = genruntime.ClonePointerToString(source.Url)

	// No error
	return nil
}

// AssignProperties_To_Backend_Spec populates the provided destination Backend_Spec from our Backend_Spec
func (backend *Backend_Spec) AssignProperties_To_Backend_Spec(destination *storage.Backend_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = backend.AzureName

	// CircuitBreaker
	if backend.CircuitBreaker != nil {
		var circuitBreaker storage.BackendCircuitBreaker
		err := backend.CircuitBreaker.AssignProperties_To_BackendCircuitBreaker(&circuitBreaker)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BackendCircuitBreaker() to populate field CircuitBreaker")
		}
		destination.CircuitBreaker = &circuitBreaker
	} else {
		destination.CircuitBreaker = nil
	}

	// Credentials
	if backend.Credentials != nil {
		var credential storage.BackendCredentialsContract
		err := backend.Credentials.AssignProperties_To_BackendCredentialsContract(&credential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BackendCredentialsContract() to populate field Credentials")
		}
		destination.Credentials = &credential
	} else {
		destination.Credentials = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(backend.Description)

	// OperatorSpec
	if backend.OperatorSpec != nil {
		var operatorSpec storage.BackendOperatorSpec
		err := backend.OperatorSpec.AssignProperties_To_BackendOperatorSpec(&operatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BackendOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = backend.OriginalVersion()

	// Owner
	if backend.Owner != nil {
		owner := backend.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Pool
	if backend.Pool != nil {
		var pool storage.BackendPool
		err := backend.Pool.AssignProperties_To_BackendPool(&pool)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BackendPool() to populate field Pool")
		}
		destination.Pool = &pool
	} else {
		destination.Pool = nil
	}

	// Properties
	if backend.Properties != nil {
		var property storage.BackendProperties
		err := backend.Properties.AssignProperties_To_BackendProperties(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BackendProperties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// Protocol
	if backend.Protocol != nil {
		protocol := string(*backend.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Proxy
	if backend.Proxy != nil {
		var proxy storage.BackendProxyContract
		err := backend.Proxy.AssignProperties_To_BackendProxyContract(&proxy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BackendProxyContract() to populate field Proxy")
		}
		destination.Proxy = &proxy
	} else {
		destination.Proxy = nil
	}

	// ResourceReference
	if backend.ResourceReference != nil {
		resourceReference := backend.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Title
	destination.Title = genruntime.ClonePointerToString(backend.Title)

	// Tls
	if backend.Tls != nil {
		var tl storage.BackendTlsProperties
		err := backend.Tls.AssignProperties_To_BackendTlsProperties(&tl)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BackendTlsProperties() to populate field Tls")
		}
		destination.Tls = &tl
	} else {
		destination.Tls = nil
	}

	// Type
	if backend.Type != nil {
		typeVar := string(*backend.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Url
	destination.Url = genruntime.ClonePointerToString(backend.Url)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (backend *Backend_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (backend *Backend_Spec) SetAzureName(azureName string) { backend.AzureName = azureName }

type Backend_STATUS struct {
	// CircuitBreaker: Backend Circuit Breaker Configuration
	CircuitBreaker *BackendCircuitBreaker_STATUS `json:"circuitBreaker,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// Credentials: Backend Credentials Contract Properties
	Credentials *BackendCredentialsContract_STATUS `json:"credentials,omitempty"`

	// Description: Backend Description.
	Description *string `json:"description,omitempty"`

	// Id: Fully qualified resource ID for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// Pool: Backend pool information
	Pool *BackendPool_STATUS `json:"pool,omitempty"`

	// Properties: Backend Properties contract
	Properties *BackendProperties_STATUS `json:"properties,omitempty"`

	// PropertiesType: Type of the backend. A backend can be either Single or Pool.
	PropertiesType *BackendContractProperties_Type_STATUS `json:"properties_type,omitempty"`

	// Protocol: Backend communication protocol.
	Protocol *BackendContractProperties_Protocol_STATUS `json:"protocol,omitempty"`

	// Proxy: Backend gateway Contract Properties
	Proxy *BackendProxyContract_STATUS `json:"proxy,omitempty"`

	// ResourceId: Management Uri of the Resource in External System. This URL can be the Arm Resource Id of Logic Apps,
	// Function Apps or API Apps.
	ResourceId *string `json:"resourceId,omitempty"`

	// Title: Backend Title.
	Title *string `json:"title,omitempty"`

	// Tls: Backend TLS Properties
	Tls *BackendTlsProperties_STATUS `json:"tls,omitempty"`

	// Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`

	// Url: Runtime Url of the Backend.
	Url *string `json:"url,omitempty"`
}

var _ genruntime.ConvertibleStatus = &Backend_STATUS{}

// ConvertStatusFrom populates our Backend_STATUS from the provided source
func (backend *Backend_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.Backend_STATUS)
	if ok {
		// Populate our instance from source
		return backend.AssignProperties_From_Backend_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.Backend_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = backend.AssignProperties_From_Backend_STATUS(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our Backend_STATUS
func (backend *Backend_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.Backend_STATUS)
	if ok {
		// Populate destination from our instance
		return backend.AssignProperties_To_Backend_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.Backend_STATUS{}
	err := backend.AssignProperties_To_Backend_STATUS(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &Backend_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (backend *Backend_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Backend_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (backend *Backend_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Backend_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Backend_STATUS, got %T", armInput)
	}

	// Set property "CircuitBreaker":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CircuitBreaker != nil {
			var circuitBreaker1 BackendCircuitBreaker_STATUS
			err := circuitBreaker1.PopulateFromARM(owner, *typedInput.Properties.CircuitBreaker)
			if err != nil {
				return err
			}
			circuitBreaker := circuitBreaker1
			backend.CircuitBreaker = &circuitBreaker
		}
	}

	// no assignment for property "Conditions"

	// Set property "Credentials":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Credentials != nil {
			var credentials1 BackendCredentialsContract_STATUS
			err := credentials1.PopulateFromARM(owner, *typedInput.Properties.Credentials)
			if err != nil {
				return err
			}
			credentials := credentials1
			backend.Credentials = &credentials
		}
	}

	// Set property "Description":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Description != nil {
			description := *typedInput.Properties.Description
			backend.Description = &description
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		backend.Id = &id
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		backend.Name = &name
	}

	// Set property "Pool":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Pool != nil {
			var pool1 BackendPool_STATUS
			err := pool1.PopulateFromARM(owner, *typedInput.Properties.Pool)
			if err != nil {
				return err
			}
			pool := pool1
			backend.Pool = &pool
		}
	}

	// Set property "Properties":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Properties != nil {
			var properties1 BackendProperties_STATUS
			err := properties1.PopulateFromARM(owner, *typedInput.Properties.Properties)
			if err != nil {
				return err
			}
			properties := properties1
			backend.Properties = &properties
		}
	}

	// Set property "PropertiesType":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Type != nil {
			var temp string
			temp = string(*typedInput.Properties.Type)
			propertiesType := BackendContractProperties_Type_STATUS(temp)
			backend.PropertiesType = &propertiesType
		}
	}

	// Set property "Protocol":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Protocol != nil {
			var temp string
			temp = string(*typedInput.Properties.Protocol)
			protocol := BackendContractProperties_Protocol_STATUS(temp)
			backend.Protocol = &protocol
		}
	}

	// Set property "Proxy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Proxy != nil {
			var proxy1 BackendProxyContract_STATUS
			err := proxy1.PopulateFromARM(owner, *typedInput.Properties.Proxy)
			if err != nil {
				return err
			}
			proxy := proxy1
			backend.Proxy = &proxy
		}
	}

	// Set property "ResourceId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ResourceId != nil {
			resourceId := *typedInput.Properties.ResourceId
			backend.ResourceId = &resourceId
		}
	}

	// Set property "Title":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Title != nil {
			title := *typedInput.Properties.Title
			backend.Title = &title
		}
	}

	// Set property "Tls":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Tls != nil {
			var tls1 BackendTlsProperties_STATUS
			err := tls1.PopulateFromARM(owner, *typedInput.Properties.Tls)
			if err != nil {
				return err
			}
			tls := tls1
			backend.Tls = &tls
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		backend.Type = &typeVar
	}

	// Set property "Url":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Url != nil {
			url := *typedInput.Properties.Url
			backend.Url = &url
		}
	}

	// No error
	return nil
}

// AssignProperties_From_Backend_STATUS populates our Backend_STATUS from the provided source Backend_STATUS
func (backend *Backend_STATUS) AssignProperties_From_Backend_STATUS(source *storage.Backend_STATUS) error {

	// CircuitBreaker
	if source.CircuitBreaker != nil {
		var circuitBreaker BackendCircuitBreaker_STATUS
		err := circuitBreaker.AssignProperties_From_BackendCircuitBreaker_STATUS(source.CircuitBreaker)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BackendCircuitBreaker_STATUS() to populate field CircuitBreaker")
		}
		backend.CircuitBreaker = &circuitBreaker
	} else {
		backend.CircuitBreaker = nil
	}

	// Conditions
	backend.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// Credentials
	if source.Credentials != nil {
		var credential BackendCredentialsContract_STATUS
		err := credential.AssignProperties_From_BackendCredentialsContract_STATUS(source.Credentials)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BackendCredentialsContract_STATUS() to populate field Credentials")
		}
		backend.Credentials = &credential
	} else {
		backend.Credentials = nil
	}

	// Description
	backend.Description = genruntime.ClonePointerToString(source.Description)

	// Id
	backend.Id = genruntime.ClonePointerToString(source.Id)

	// Name
	backend.Name = genruntime.ClonePointerToString(source.Name)

	// Pool
	if source.Pool != nil {
		var pool BackendPool_STATUS
		err := pool.AssignProperties_From_BackendPool_STATUS(source.Pool)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BackendPool_STATUS() to populate field Pool")
		}
		backend.Pool = &pool
	} else {
		backend.Pool = nil
	}

	// Properties
	if source.Properties != nil {
		var property BackendProperties_STATUS
		err := property.AssignProperties_From_BackendProperties_STATUS(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BackendProperties_STATUS() to populate field Properties")
		}
		backend.Properties = &property
	} else {
		backend.Properties = nil
	}

	// PropertiesType
	if source.PropertiesType != nil {
		propertiesType := *source.PropertiesType
		propertiesTypeTemp := genruntime.ToEnum(propertiesType, backendContractProperties_Type_STATUS_Values)
		backend.PropertiesType = &propertiesTypeTemp
	} else {
		backend.PropertiesType = nil
	}

	// Protocol
	if source.Protocol != nil {
		protocol := *source.Protocol
		protocolTemp := genruntime.ToEnum(protocol, backendContractProperties_Protocol_STATUS_Values)
		backend.Protocol = &protocolTemp
	} else {
		backend.Protocol = nil
	}

	// Proxy
	if source.Proxy != nil {
		var proxy BackendProxyContract_STATUS
		err := proxy.AssignProperties_From_BackendProxyContract_STATUS(source.Proxy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BackendProxyContract_STATUS() to populate field Proxy")
		}
		backend.Proxy = &proxy
	} else {
		backend.Proxy = nil
	}

	// ResourceId
	backend.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// Title
	backend.Title = genruntime.ClonePointerToString(source.Title)

	// Tls
	if source.Tls != nil {
		var tl BackendTlsProperties_STATUS
		err := tl.AssignProperties_From_BackendTlsProperties_STATUS(source.Tls)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BackendTlsProperties_STATUS() to populate field Tls")
		}
		backend.Tls = &tl
	} else {
		backend.Tls = nil
	}

	// Type
	backend.Type = genruntime.ClonePointerToString(source.Type)

	// Url
	backend.Url = genruntime.ClonePointerToString(source.Url)

	// No error
	return nil
}

// AssignProperties_To_Backend_STATUS populates the provided destination Backend_STATUS from our Backend_STATUS
func (backend *Backend_STATUS) AssignProperties_To_Backend_STATUS(destination *storage.Backend_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CircuitBreaker
	if backend.CircuitBreaker != nil {
		var circuitBreaker storage.BackendCircuitBreaker_STATUS
		err := backend.CircuitBreaker.AssignProperties_To_BackendCircuitBreaker_STATUS(&circuitBreaker)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BackendCircuitBreaker_STATUS() to populate field CircuitBreaker")
		}
		destination.CircuitBreaker = &circuitBreaker
	} else {
		destination.CircuitBreaker = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(backend.Conditions)

	// Credentials
	if backend.Credentials != nil {
		var credential storage.BackendCredentialsContract_STATUS
		err := backend.Credentials.AssignProperties_To_BackendCredentialsContract_STATUS(&credential)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BackendCredentialsContract_STATUS() to populate field Credentials")
		}
		destination.Credentials = &credential
	} else {
		destination.Credentials = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(backend.Description)

	// Id
	destination.Id = genruntime.ClonePointerToString(backend.Id)

	// Name
	destination.Name = genruntime.ClonePointerToString(backend.Name)

	// Pool
	if backend.Pool != nil {
		var pool storage.BackendPool_STATUS
		err := backend.Pool.AssignProperties_To_BackendPool_STATUS(&pool)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BackendPool_STATUS() to populate field Pool")
		}
		destination.Pool = &pool
	} else {
		destination.Pool = nil
	}

	// Properties
	if backend.Properties != nil {
		var property storage.BackendProperties_STATUS
		err := backend.Properties.AssignProperties_To_BackendProperties_STATUS(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BackendProperties_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// PropertiesType
	if backend.PropertiesType != nil {
		propertiesType := string(*backend.PropertiesType)
		destination.PropertiesType = &propertiesType
	} else {
		destination.PropertiesType = nil
	}

	// Protocol
	if backend.Protocol != nil {
		protocol := string(*backend.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Proxy
	if backend.Proxy != nil {
		var proxy storage.BackendProxyContract_STATUS
		err := backend.Proxy.AssignProperties_To_BackendProxyContract_STATUS(&proxy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BackendProxyContract_STATUS() to populate field Proxy")
		}
		destination.Proxy = &proxy
	} else {
		destination.Proxy = nil
	}

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(backend.ResourceId)

	// Title
	destination.Title = genruntime.ClonePointerToString(backend.Title)

	// Tls
	if backend.Tls != nil {
		var tl storage.BackendTlsProperties_STATUS
		err := backend.Tls.AssignProperties_To_BackendTlsProperties_STATUS(&tl)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BackendTlsProperties_STATUS() to populate field Tls")
		}
		destination.Tls = &tl
	} else {
		destination.Tls = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(backend.Type)

	// Url
	destination.Url = genruntime.ClonePointerToString(backend.Url)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration of the backend circuit breaker
type BackendCircuitBreaker struct {
	// +kubebuilder:validation:MaxItems=15
	// Rules: The rules for tripping the backend.
	Rules []CircuitBreakerRule `json:"rules,omitempty"`
}

var _ genruntime.ARMTransformer = &BackendCircuitBreaker{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (breaker *BackendCircuitBreaker) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if breaker == nil {
		return nil, nil
	}
	result := &arm.BackendCircuitBreaker{}

	// Set property "Rules":
	for _, item := range breaker.Rules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Rules = append(result.Rules, *item_ARM.(*arm.CircuitBreakerRule))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (breaker *BackendCircuitBreaker) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackendCircuitBreaker{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (breaker *BackendCircuitBreaker) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackendCircuitBreaker)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackendCircuitBreaker, got %T", armInput)
	}

	// Set property "Rules":
	for _, item := range typedInput.Rules {
		var item1 CircuitBreakerRule
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		breaker.Rules = append(breaker.Rules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_BackendCircuitBreaker populates our BackendCircuitBreaker from the provided source BackendCircuitBreaker
func (breaker *BackendCircuitBreaker) AssignProperties_From_BackendCircuitBreaker(source *storage.BackendCircuitBreaker) error {

	// Rules
	if source.Rules != nil {
		ruleList := make([]CircuitBreakerRule, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule CircuitBreakerRule
			err := rule.AssignProperties_From_CircuitBreakerRule(&ruleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_CircuitBreakerRule() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		breaker.Rules = ruleList
	} else {
		breaker.Rules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackendCircuitBreaker populates the provided destination BackendCircuitBreaker from our BackendCircuitBreaker
func (breaker *BackendCircuitBreaker) AssignProperties_To_BackendCircuitBreaker(destination *storage.BackendCircuitBreaker) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Rules
	if breaker.Rules != nil {
		ruleList := make([]storage.CircuitBreakerRule, len(breaker.Rules))
		for ruleIndex, ruleItem := range breaker.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule storage.CircuitBreakerRule
			err := ruleItem.AssignProperties_To_CircuitBreakerRule(&rule)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_CircuitBreakerRule() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The configuration of the backend circuit breaker
type BackendCircuitBreaker_STATUS struct {
	// Rules: The rules for tripping the backend.
	Rules []CircuitBreakerRule_STATUS `json:"rules,omitempty"`
}

var _ genruntime.FromARMConverter = &BackendCircuitBreaker_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (breaker *BackendCircuitBreaker_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackendCircuitBreaker_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (breaker *BackendCircuitBreaker_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackendCircuitBreaker_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackendCircuitBreaker_STATUS, got %T", armInput)
	}

	// Set property "Rules":
	for _, item := range typedInput.Rules {
		var item1 CircuitBreakerRule_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		breaker.Rules = append(breaker.Rules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_BackendCircuitBreaker_STATUS populates our BackendCircuitBreaker_STATUS from the provided source BackendCircuitBreaker_STATUS
func (breaker *BackendCircuitBreaker_STATUS) AssignProperties_From_BackendCircuitBreaker_STATUS(source *storage.BackendCircuitBreaker_STATUS) error {

	// Rules
	if source.Rules != nil {
		ruleList := make([]CircuitBreakerRule_STATUS, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule CircuitBreakerRule_STATUS
			err := rule.AssignProperties_From_CircuitBreakerRule_STATUS(&ruleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_CircuitBreakerRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		breaker.Rules = ruleList
	} else {
		breaker.Rules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackendCircuitBreaker_STATUS populates the provided destination BackendCircuitBreaker_STATUS from our BackendCircuitBreaker_STATUS
func (breaker *BackendCircuitBreaker_STATUS) AssignProperties_To_BackendCircuitBreaker_STATUS(destination *storage.BackendCircuitBreaker_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Rules
	if breaker.Rules != nil {
		ruleList := make([]storage.CircuitBreakerRule_STATUS, len(breaker.Rules))
		for ruleIndex, ruleItem := range breaker.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule storage.CircuitBreakerRule_STATUS
			err := ruleItem.AssignProperties_To_CircuitBreakerRule_STATUS(&rule)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_CircuitBreakerRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"http","soap"}
type BackendContractProperties_Protocol string

const (
	BackendContractProperties_Protocol_Http = BackendContractProperties_Protocol("http")
	BackendContractProperties_Protocol_Soap = BackendContractProperties_Protocol("soap")
)

// Mapping from string to BackendContractProperties_Protocol
var backendContractProperties_Protocol_Values = map[string]BackendContractProperties_Protocol{
	"http": BackendContractProperties_Protocol_Http,
	"soap": BackendContractProperties_Protocol_Soap,
}

type BackendContractProperties_Protocol_STATUS string

const (
	BackendContractProperties_Protocol_STATUS_Http = BackendContractProperties_Protocol_STATUS("http")
	BackendContractProperties_Protocol_STATUS_Soap = BackendContractProperties_Protocol_STATUS("soap")
)

// Mapping from string to BackendContractProperties_Protocol_STATUS
var backendContractProperties_Protocol_STATUS_Values = map[string]BackendContractProperties_Protocol_STATUS{
	"http": BackendContractProperties_Protocol_STATUS_Http,
	"soap": BackendContractProperties_Protocol_STATUS_Soap,
}

// +kubebuilder:validation:Enum={"Pool","Single"}
type BackendContractProperties_Type string

const (
	BackendContractProperties_Type_Pool   = BackendContractProperties_Type("Pool")
	BackendContractProperties_Type_Single = BackendContractProperties_Type("Single")
)

// Mapping from string to BackendContractProperties_Type
var backendContractProperties_Type_Values = map[string]BackendContractProperties_Type{
	"pool":   BackendContractProperties_Type_Pool,
	"single": BackendContractProperties_Type_Single,
}

type BackendContractProperties_Type_STATUS string

const (
	BackendContractProperties_Type_STATUS_Pool   = BackendContractProperties_Type_STATUS("Pool")
	BackendContractProperties_Type_STATUS_Single = BackendContractProperties_Type_STATUS("Single")
)

// Mapping from string to BackendContractProperties_Type_STATUS
var backendContractProperties_Type_STATUS_Values = map[string]BackendContractProperties_Type_STATUS{
	"pool":   BackendContractProperties_Type_STATUS_Pool,
	"single": BackendContractProperties_Type_STATUS_Single,
}

// Details of the Credentials used to connect to Backend.
type BackendCredentialsContract struct {
	// Authorization: Authorization header authentication
	Authorization *BackendAuthorizationHeaderCredentials `json:"authorization,omitempty"`

	// +kubebuilder:validation:MaxItems=32
	// Certificate: List of Client Certificate Thumbprints. Will be ignored if certificatesIds are provided.
	Certificate []string `json:"certificate,omitempty"`

	// +kubebuilder:validation:MaxItems=32
	// CertificateIds: List of Client Certificate Ids.
	CertificateIds []string `json:"certificateIds,omitempty"`

	// Header: Header Parameter description.
	Header map[string][]string `json:"header,omitempty"`

	// Query: Query Parameter description.
	Query map[string][]string `json:"query,omitempty"`
}

var _ genruntime.ARMTransformer = &BackendCredentialsContract{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (contract *BackendCredentialsContract) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if contract == nil {
		return nil, nil
	}
	result := &arm.BackendCredentialsContract{}

	// Set property "Authorization":
	if contract.Authorization != nil {
		authorization_ARM, err := (*contract.Authorization).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		authorization := *authorization_ARM.(*arm.BackendAuthorizationHeaderCredentials)
		result.Authorization = &authorization
	}

	// Set property "Certificate":
	for _, item := range contract.Certificate {
		result.Certificate = append(result.Certificate, item)
	}

	// Set property "CertificateIds":
	for _, item := range contract.CertificateIds {
		result.CertificateIds = append(result.CertificateIds, item)
	}

	// Set property "Header":
	if contract.Header != nil {
		result.Header = make(map[string][]string, len(contract.Header))
		for key, value := range contract.Header {
			var valueTemp []string
			for _, item := range value {
				valueTemp = append(valueTemp, item)
			}
			result.Header[key] = valueTemp
		}
	}

	// Set property "Query":
	if contract.Query != nil {
		result.Query = make(map[string][]string, len(contract.Query))
		for key, value := range contract.Query {
			var valueTemp []string
			for _, item := range value {
				valueTemp = append(valueTemp, item)
			}
			result.Query[key] = valueTemp
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (contract *BackendCredentialsContract) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackendCredentialsContract{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (contract *BackendCredentialsContract) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackendCredentialsContract)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackendCredentialsContract, got %T", armInput)
	}

	// Set property "Authorization":
	if typedInput.Authorization != nil {
		var authorization1 BackendAuthorizationHeaderCredentials
		err := authorization1.PopulateFromARM(owner, *typedInput.Authorization)
		if err != nil {
			return err
		}
		authorization := authorization1
		contract.Authorization = &authorization
	}

	// Set property "Certificate":
	for _, item := range typedInput.Certificate {
		contract.Certificate = append(contract.Certificate, item)
	}

	// Set property "CertificateIds":
	for _, item := range typedInput.CertificateIds {
		contract.CertificateIds = append(contract.CertificateIds, item)
	}

	// Set property "Header":
	if typedInput.Header != nil {
		contract.Header = make(map[string][]string, len(typedInput.Header))
		for key, value := range typedInput.Header {
			var valueTemp []string
			for _, item := range value {
				valueTemp = append(valueTemp, item)
			}
			contract.Header[key] = valueTemp
		}
	}

	// Set property "Query":
	if typedInput.Query != nil {
		contract.Query = make(map[string][]string, len(typedInput.Query))
		for key, value := range typedInput.Query {
			var valueTemp []string
			for _, item := range value {
				valueTemp = append(valueTemp, item)
			}
			contract.Query[key] = valueTemp
		}
	}

	// No error
	return nil
}

// AssignProperties_From_BackendCredentialsContract populates our BackendCredentialsContract from the provided source BackendCredentialsContract
func (contract *BackendCredentialsContract) AssignProperties_From_BackendCredentialsContract(source *storage.BackendCredentialsContract) error {

	// Authorization
	if source.Authorization != nil {
		var authorization BackendAuthorizationHeaderCredentials
		err := authorization.AssignProperties_From_BackendAuthorizationHeaderCredentials(source.Authorization)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BackendAuthorizationHeaderCredentials() to populate field Authorization")
		}
		contract.Authorization = &authorization
	} else {
		contract.Authorization = nil
	}

	// Certificate
	contract.Certificate = genruntime.CloneSliceOfString(source.Certificate)

	// CertificateIds
	contract.CertificateIds = genruntime.CloneSliceOfString(source.CertificateIds)

	// Header
	if source.Header != nil {
		headerMap := make(map[string][]string, len(source.Header))
		for headerKey, headerValue := range source.Header {
			// Shadow the loop variable to avoid aliasing
			headerValue := headerValue
			headerMap[headerKey] = genruntime.CloneSliceOfString(headerValue)
		}
		contract.Header = headerMap
	} else {
		contract.Header = nil
	}

	// Query
	if source.Query != nil {
		queryMap := make(map[string][]string, len(source.Query))
		for queryKey, queryValue := range source.Query {
			// Shadow the loop variable to avoid aliasing
			queryValue := queryValue
			queryMap[queryKey] = genruntime.CloneSliceOfString(queryValue)
		}
		contract.Query = queryMap
	} else {
		contract.Query = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackendCredentialsContract populates the provided destination BackendCredentialsContract from our BackendCredentialsContract
func (contract *BackendCredentialsContract) AssignProperties_To_BackendCredentialsContract(destination *storage.BackendCredentialsContract) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Authorization
	if contract.Authorization != nil {
		var authorization storage.BackendAuthorizationHeaderCredentials
		err := contract.Authorization.AssignProperties_To_BackendAuthorizationHeaderCredentials(&authorization)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BackendAuthorizationHeaderCredentials() to populate field Authorization")
		}
		destination.Authorization = &authorization
	} else {
		destination.Authorization = nil
	}

	// Certificate
	destination.Certificate = genruntime.CloneSliceOfString(contract.Certificate)

	// CertificateIds
	destination.CertificateIds = genruntime.CloneSliceOfString(contract.CertificateIds)

	// Header
	if contract.Header != nil {
		headerMap := make(map[string][]string, len(contract.Header))
		for headerKey, headerValue := range contract.Header {
			// Shadow the loop variable to avoid aliasing
			headerValue := headerValue
			headerMap[headerKey] = genruntime.CloneSliceOfString(headerValue)
		}
		destination.Header = headerMap
	} else {
		destination.Header = nil
	}

	// Query
	if contract.Query != nil {
		queryMap := make(map[string][]string, len(contract.Query))
		for queryKey, queryValue := range contract.Query {
			// Shadow the loop variable to avoid aliasing
			queryValue := queryValue
			queryMap[queryKey] = genruntime.CloneSliceOfString(queryValue)
		}
		destination.Query = queryMap
	} else {
		destination.Query = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details of the Credentials used to connect to Backend.
type BackendCredentialsContract_STATUS struct {
	// Authorization: Authorization header authentication
	Authorization *BackendAuthorizationHeaderCredentials_STATUS `json:"authorization,omitempty"`

	// Certificate: List of Client Certificate Thumbprints. Will be ignored if certificatesIds are provided.
	Certificate []string `json:"certificate,omitempty"`

	// CertificateIds: List of Client Certificate Ids.
	CertificateIds []string `json:"certificateIds,omitempty"`

	// Header: Header Parameter description.
	Header map[string][]string `json:"header,omitempty"`

	// Query: Query Parameter description.
	Query map[string][]string `json:"query,omitempty"`
}

var _ genruntime.FromARMConverter = &BackendCredentialsContract_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (contract *BackendCredentialsContract_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackendCredentialsContract_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (contract *BackendCredentialsContract_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackendCredentialsContract_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackendCredentialsContract_STATUS, got %T", armInput)
	}

	// Set property "Authorization":
	if typedInput.Authorization != nil {
		var authorization1 BackendAuthorizationHeaderCredentials_STATUS
		err := authorization1.PopulateFromARM(owner, *typedInput.Authorization)
		if err != nil {
			return err
		}
		authorization := authorization1
		contract.Authorization = &authorization
	}

	// Set property "Certificate":
	for _, item := range typedInput.Certificate {
		contract.Certificate = append(contract.Certificate, item)
	}

	// Set property "CertificateIds":
	for _, item := range typedInput.CertificateIds {
		contract.CertificateIds = append(contract.CertificateIds, item)
	}

	// Set property "Header":
	if typedInput.Header != nil {
		contract.Header = make(map[string][]string, len(typedInput.Header))
		for key, value := range typedInput.Header {
			var valueTemp []string
			for _, item := range value {
				valueTemp = append(valueTemp, item)
			}
			contract.Header[key] = valueTemp
		}
	}

	// Set property "Query":
	if typedInput.Query != nil {
		contract.Query = make(map[string][]string, len(typedInput.Query))
		for key, value := range typedInput.Query {
			var valueTemp []string
			for _, item := range value {
				valueTemp = append(valueTemp, item)
			}
			contract.Query[key] = valueTemp
		}
	}

	// No error
	return nil
}

// AssignProperties_From_BackendCredentialsContract_STATUS populates our BackendCredentialsContract_STATUS from the provided source BackendCredentialsContract_STATUS
func (contract *BackendCredentialsContract_STATUS) AssignProperties_From_BackendCredentialsContract_STATUS(source *storage.BackendCredentialsContract_STATUS) error {

	// Authorization
	if source.Authorization != nil {
		var authorization BackendAuthorizationHeaderCredentials_STATUS
		err := authorization.AssignProperties_From_BackendAuthorizationHeaderCredentials_STATUS(source.Authorization)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BackendAuthorizationHeaderCredentials_STATUS() to populate field Authorization")
		}
		contract.Authorization = &authorization
	} else {
		contract.Authorization = nil
	}

	// Certificate
	contract.Certificate = genruntime.CloneSliceOfString(source.Certificate)

	// CertificateIds
	contract.CertificateIds = genruntime.CloneSliceOfString(source.CertificateIds)

	// Header
	if source.Header != nil {
		headerMap := make(map[string][]string, len(source.Header))
		for headerKey, headerValue := range source.Header {
			// Shadow the loop variable to avoid aliasing
			headerValue := headerValue
			headerMap[headerKey] = genruntime.CloneSliceOfString(headerValue)
		}
		contract.Header = headerMap
	} else {
		contract.Header = nil
	}

	// Query
	if source.Query != nil {
		queryMap := make(map[string][]string, len(source.Query))
		for queryKey, queryValue := range source.Query {
			// Shadow the loop variable to avoid aliasing
			queryValue := queryValue
			queryMap[queryKey] = genruntime.CloneSliceOfString(queryValue)
		}
		contract.Query = queryMap
	} else {
		contract.Query = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackendCredentialsContract_STATUS populates the provided destination BackendCredentialsContract_STATUS from our BackendCredentialsContract_STATUS
func (contract *BackendCredentialsContract_STATUS) AssignProperties_To_BackendCredentialsContract_STATUS(destination *storage.BackendCredentialsContract_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Authorization
	if contract.Authorization != nil {
		var authorization storage.BackendAuthorizationHeaderCredentials_STATUS
		err := contract.Authorization.AssignProperties_To_BackendAuthorizationHeaderCredentials_STATUS(&authorization)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BackendAuthorizationHeaderCredentials_STATUS() to populate field Authorization")
		}
		destination.Authorization = &authorization
	} else {
		destination.Authorization = nil
	}

	// Certificate
	destination.Certificate = genruntime.CloneSliceOfString(contract.Certificate)

	// CertificateIds
	destination.CertificateIds = genruntime.CloneSliceOfString(contract.CertificateIds)

	// Header
	if contract.Header != nil {
		headerMap := make(map[string][]string, len(contract.Header))
		for headerKey, headerValue := range contract.Header {
			// Shadow the loop variable to avoid aliasing
			headerValue := headerValue
			headerMap[headerKey] = genruntime.CloneSliceOfString(headerValue)
		}
		destination.Header = headerMap
	} else {
		destination.Header = nil
	}

	// Query
	if contract.Query != nil {
		queryMap := make(map[string][]string, len(contract.Query))
		for queryKey, queryValue := range contract.Query {
			// Shadow the loop variable to avoid aliasing
			queryValue := queryValue
			queryMap[queryKey] = genruntime.CloneSliceOfString(queryValue)
		}
		destination.Query = queryMap
	} else {
		destination.Query = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type BackendOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_BackendOperatorSpec populates our BackendOperatorSpec from the provided source BackendOperatorSpec
func (operator *BackendOperatorSpec) AssignProperties_From_BackendOperatorSpec(source *storage.BackendOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackendOperatorSpec populates the provided destination BackendOperatorSpec from our BackendOperatorSpec
func (operator *BackendOperatorSpec) AssignProperties_To_BackendOperatorSpec(destination *storage.BackendOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Backend pool information
type BackendPool struct {
	// +kubebuilder:validation:MinItems=1
	// Services: The list of backend entities belonging to a pool.
	Services []BackendPoolItem `json:"services,omitempty"`
}

var _ genruntime.ARMTransformer = &BackendPool{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (pool *BackendPool) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if pool == nil {
		return nil, nil
	}
	result := &arm.BackendPool{}

	// Set property "Services":
	for _, item := range pool.Services {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Services = append(result.Services, *item_ARM.(*arm.BackendPoolItem))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (pool *BackendPool) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackendPool{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (pool *BackendPool) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackendPool)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackendPool, got %T", armInput)
	}

	// Set property "Services":
	for _, item := range typedInput.Services {
		var item1 BackendPoolItem
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		pool.Services = append(pool.Services, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_BackendPool populates our BackendPool from the provided source BackendPool
func (pool *BackendPool) AssignProperties_From_BackendPool(source *storage.BackendPool) error {

	// Services
	if source.Services != nil {
		serviceList := make([]BackendPoolItem, len(source.Services))
		for serviceIndex, serviceItem := range source.Services {
			// Shadow the loop variable to avoid aliasing
			serviceItem := serviceItem
			var service BackendPoolItem
			err := service.AssignProperties_From_BackendPoolItem(&serviceItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_BackendPoolItem() to populate field Services")
			}
			serviceList[serviceIndex] = service
		}
		pool.Services = serviceList
	} else {
		pool.Services = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackendPool populates the provided destination BackendPool from our BackendPool
func (pool *BackendPool) AssignProperties_To_BackendPool(destination *storage.BackendPool) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Services
	if pool.Services != nil {
		serviceList := make([]storage.BackendPoolItem, len(pool.Services))
		for serviceIndex, serviceItem := range pool.Services {
			// Shadow the loop variable to avoid aliasing
			serviceItem := serviceItem
			var service storage.BackendPoolItem
			err := serviceItem.AssignProperties_To_BackendPoolItem(&service)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_BackendPoolItem() to populate field Services")
			}
			serviceList[serviceIndex] = service
		}
		destination.Services = serviceList
	} else {
		destination.Services = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Backend pool information
type BackendPool_STATUS struct {
	// Services: The list of backend entities belonging to a pool.
	Services []BackendPoolItem_STATUS `json:"services,omitempty"`
}

var _ genruntime.FromARMConverter = &BackendPool_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (pool *BackendPool_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackendPool_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (pool *BackendPool_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackendPool_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackendPool_STATUS, got %T", armInput)
	}

	// Set property "Services":
	for _, item := range typedInput.Services {
		var item1 BackendPoolItem_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		pool.Services = append(pool.Services, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_BackendPool_STATUS populates our BackendPool_STATUS from the provided source BackendPool_STATUS
func (pool *BackendPool_STATUS) AssignProperties_From_BackendPool_STATUS(source *storage.BackendPool_STATUS) error {

	// Services
	if source.Services != nil {
		serviceList := make([]BackendPoolItem_STATUS, len(source.Services))
		for serviceIndex, serviceItem := range source.Services {
			// Shadow the loop variable to avoid aliasing
			serviceItem := serviceItem
			var service BackendPoolItem_STATUS
			err := service.AssignProperties_From_BackendPoolItem_STATUS(&serviceItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_BackendPoolItem_STATUS() to populate field Services")
			}
			serviceList[serviceIndex] = service
		}
		pool.Services = serviceList
	} else {
		pool.Services = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackendPool_STATUS populates the provided destination BackendPool_STATUS from our BackendPool_STATUS
func (pool *BackendPool_STATUS) AssignProperties_To_BackendPool_STATUS(destination *storage.BackendPool_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Services
	if pool.Services != nil {
		serviceList := make([]storage.BackendPoolItem_STATUS, len(pool.Services))
		for serviceIndex, serviceItem := range pool.Services {
			// Shadow the loop variable to avoid aliasing
			serviceItem := serviceItem
			var service storage.BackendPoolItem_STATUS
			err := serviceItem.AssignProperties_To_BackendPoolItem_STATUS(&service)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_BackendPoolItem_STATUS() to populate field Services")
			}
			serviceList[serviceIndex] = service
		}
		destination.Services = serviceList
	} else {
		destination.Services = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Properties specific to the Backend Type.
type BackendProperties struct {
	// ServiceFabricCluster: Backend Service Fabric Cluster Properties
	ServiceFabricCluster *BackendServiceFabricClusterProperties `json:"serviceFabricCluster,omitempty"`
}

var _ genruntime.ARMTransformer = &BackendProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *BackendProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.BackendProperties{}

	// Set property "ServiceFabricCluster":
	if properties.ServiceFabricCluster != nil {
		serviceFabricCluster_ARM, err := (*properties.ServiceFabricCluster).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		serviceFabricCluster := *serviceFabricCluster_ARM.(*arm.BackendServiceFabricClusterProperties)
		result.ServiceFabricCluster = &serviceFabricCluster
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *BackendProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackendProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *BackendProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackendProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackendProperties, got %T", armInput)
	}

	// Set property "ServiceFabricCluster":
	if typedInput.ServiceFabricCluster != nil {
		var serviceFabricCluster1 BackendServiceFabricClusterProperties
		err := serviceFabricCluster1.PopulateFromARM(owner, *typedInput.ServiceFabricCluster)
		if err != nil {
			return err
		}
		serviceFabricCluster := serviceFabricCluster1
		properties.ServiceFabricCluster = &serviceFabricCluster
	}

	// No error
	return nil
}

// AssignProperties_From_BackendProperties populates our BackendProperties from the provided source BackendProperties
func (properties *BackendProperties) AssignProperties_From_BackendProperties(source *storage.BackendProperties) error {

	// ServiceFabricCluster
	if source.ServiceFabricCluster != nil {
		var serviceFabricCluster BackendServiceFabricClusterProperties
		err := serviceFabricCluster.AssignProperties_From_BackendServiceFabricClusterProperties(source.ServiceFabricCluster)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BackendServiceFabricClusterProperties() to populate field ServiceFabricCluster")
		}
		properties.ServiceFabricCluster = &serviceFabricCluster
	} else {
		properties.ServiceFabricCluster = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackendProperties populates the provided destination BackendProperties from our BackendProperties
func (properties *BackendProperties) AssignProperties_To_BackendProperties(destination *storage.BackendProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ServiceFabricCluster
	if properties.ServiceFabricCluster != nil {
		var serviceFabricCluster storage.BackendServiceFabricClusterProperties
		err := properties.ServiceFabricCluster.AssignProperties_To_BackendServiceFabricClusterProperties(&serviceFabricCluster)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BackendServiceFabricClusterProperties() to populate field ServiceFabricCluster")
		}
		destination.ServiceFabricCluster = &serviceFabricCluster
	} else {
		destination.ServiceFabricCluster = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Properties specific to the Backend Type.
type BackendProperties_STATUS struct {
	// ServiceFabricCluster: Backend Service Fabric Cluster Properties
	ServiceFabricCluster *BackendServiceFabricClusterProperties_STATUS `json:"serviceFabricCluster,omitempty"`
}

var _ genruntime.FromARMConverter = &BackendProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *BackendProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackendProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *BackendProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackendProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackendProperties_STATUS, got %T", armInput)
	}

	// Set property "ServiceFabricCluster":
	if typedInput.ServiceFabricCluster != nil {
		var serviceFabricCluster1 BackendServiceFabricClusterProperties_STATUS
		err := serviceFabricCluster1.PopulateFromARM(owner, *typedInput.ServiceFabricCluster)
		if err != nil {
			return err
		}
		serviceFabricCluster := serviceFabricCluster1
		properties.ServiceFabricCluster = &serviceFabricCluster
	}

	// No error
	return nil
}

// AssignProperties_From_BackendProperties_STATUS populates our BackendProperties_STATUS from the provided source BackendProperties_STATUS
func (properties *BackendProperties_STATUS) AssignProperties_From_BackendProperties_STATUS(source *storage.BackendProperties_STATUS) error {

	// ServiceFabricCluster
	if source.ServiceFabricCluster != nil {
		var serviceFabricCluster BackendServiceFabricClusterProperties_STATUS
		err := serviceFabricCluster.AssignProperties_From_BackendServiceFabricClusterProperties_STATUS(source.ServiceFabricCluster)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_BackendServiceFabricClusterProperties_STATUS() to populate field ServiceFabricCluster")
		}
		properties.ServiceFabricCluster = &serviceFabricCluster
	} else {
		properties.ServiceFabricCluster = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackendProperties_STATUS populates the provided destination BackendProperties_STATUS from our BackendProperties_STATUS
func (properties *BackendProperties_STATUS) AssignProperties_To_BackendProperties_STATUS(destination *storage.BackendProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ServiceFabricCluster
	if properties.ServiceFabricCluster != nil {
		var serviceFabricCluster storage.BackendServiceFabricClusterProperties_STATUS
		err := properties.ServiceFabricCluster.AssignProperties_To_BackendServiceFabricClusterProperties_STATUS(&serviceFabricCluster)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_BackendServiceFabricClusterProperties_STATUS() to populate field ServiceFabricCluster")
		}
		destination.ServiceFabricCluster = &serviceFabricCluster
	} else {
		destination.ServiceFabricCluster = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details of the Backend WebProxy Server to use in the Request to Backend.
type BackendProxyContract struct {
	// Password: Password to connect to the WebProxy Server
	Password *genruntime.SecretReference `json:"password,omitempty"`

	// +kubebuilder:validation:Required
	// +kubebuilder:validation:MaxLength=2000
	// +kubebuilder:validation:MinLength=1
	// Url: WebProxy Server AbsoluteUri property which includes the entire URI stored in the Uri instance, including all
	// fragments and query strings.
	Url *string `json:"url,omitempty"`

	// Username: Username to connect to the WebProxy server
	Username *string `json:"username,omitempty"`
}

var _ genruntime.ARMTransformer = &BackendProxyContract{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (contract *BackendProxyContract) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if contract == nil {
		return nil, nil
	}
	result := &arm.BackendProxyContract{}

	// Set property "Password":
	if contract.Password != nil {
		passwordSecret, err := resolved.ResolvedSecrets.Lookup(*contract.Password)
		if err != nil {
			return nil, eris.Wrap(err, "looking up secret for property Password")
		}
		password := passwordSecret
		result.Password = &password
	}

	// Set property "Url":
	if contract.Url != nil {
		url := *contract.Url
		result.Url = &url
	}

	// Set property "Username":
	if contract.Username != nil {
		username := *contract.Username
		result.Username = &username
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (contract *BackendProxyContract) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackendProxyContract{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (contract *BackendProxyContract) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackendProxyContract)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackendProxyContract, got %T", armInput)
	}

	// no assignment for property "Password"

	// Set property "Url":
	if typedInput.Url != nil {
		url := *typedInput.Url
		contract.Url = &url
	}

	// Set property "Username":
	if typedInput.Username != nil {
		username := *typedInput.Username
		contract.Username = &username
	}

	// No error
	return nil
}

// AssignProperties_From_BackendProxyContract populates our BackendProxyContract from the provided source BackendProxyContract
func (contract *BackendProxyContract) AssignProperties_From_BackendProxyContract(source *storage.BackendProxyContract) error {

	// Password
	if source.Password != nil {
		password := source.Password.Copy()
		contract.Password = &password
	} else {
		contract.Password = nil
	}

	// Url
	contract.Url = genruntime.ClonePointerToString(source.Url)

	// Username
	contract.Username = genruntime.ClonePointerToString(source.Username)

	// No error
	return nil
}

// AssignProperties_To_BackendProxyContract populates the provided destination BackendProxyContract from our BackendProxyContract
func (contract *BackendProxyContract) AssignProperties_To_BackendProxyContract(destination *storage.BackendProxyContract) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Password
	if contract.Password != nil {
		password := contract.Password.Copy()
		destination.Password = &password
	} else {
		destination.Password = nil
	}

	// Url
	destination.Url = genruntime.ClonePointerToString(contract.Url)

	// Username
	destination.Username = genruntime.ClonePointerToString(contract.Username)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details of the Backend WebProxy Server to use in the Request to Backend.
type BackendProxyContract_STATUS struct {
	// Url: WebProxy Server AbsoluteUri property which includes the entire URI stored in the Uri instance, including all
	// fragments and query strings.
	Url *string `json:"url,omitempty"`

	// Username: Username to connect to the WebProxy server
	Username *string `json:"username,omitempty"`
}

var _ genruntime.FromARMConverter = &BackendProxyContract_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (contract *BackendProxyContract_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackendProxyContract_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (contract *BackendProxyContract_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackendProxyContract_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackendProxyContract_STATUS, got %T", armInput)
	}

	// Set property "Url":
	if typedInput.Url != nil {
		url := *typedInput.Url
		contract.Url = &url
	}

	// Set property "Username":
	if typedInput.Username != nil {
		username := *typedInput.Username
		contract.Username = &username
	}

	// No error
	return nil
}

// AssignProperties_From_BackendProxyContract_STATUS populates our BackendProxyContract_STATUS from the provided source BackendProxyContract_STATUS
func (contract *BackendProxyContract_STATUS) AssignProperties_From_BackendProxyContract_STATUS(source *storage.BackendProxyContract_STATUS) error {

	// Url
	contract.Url = genruntime.ClonePointerToString(source.Url)

	// Username
	contract.Username = genruntime.ClonePointerToString(source.Username)

	// No error
	return nil
}

// AssignProperties_To_BackendProxyContract_STATUS populates the provided destination BackendProxyContract_STATUS from our BackendProxyContract_STATUS
func (contract *BackendProxyContract_STATUS) AssignProperties_To_BackendProxyContract_STATUS(destination *storage.BackendProxyContract_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Url
	destination.Url = genruntime.ClonePointerToString(contract.Url)

	// Username
	destination.Username = genruntime.ClonePointerToString(contract.Username)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Properties controlling TLS Certificate Validation.
type BackendTlsProperties struct {
	// ValidateCertificateChain: Flag indicating whether SSL certificate chain validation should be done when using self-signed
	// certificates for this backend host.
	ValidateCertificateChain *bool `json:"validateCertificateChain,omitempty"`

	// ValidateCertificateName: Flag indicating whether SSL certificate name validation should be done when using self-signed
	// certificates for this backend host.
	ValidateCertificateName *bool `json:"validateCertificateName,omitempty"`
}

var _ genruntime.ARMTransformer = &BackendTlsProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *BackendTlsProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.BackendTlsProperties{}

	// Set property "ValidateCertificateChain":
	if properties.ValidateCertificateChain != nil {
		validateCertificateChain := *properties.ValidateCertificateChain
		result.ValidateCertificateChain = &validateCertificateChain
	}

	// Set property "ValidateCertificateName":
	if properties.ValidateCertificateName != nil {
		validateCertificateName := *properties.ValidateCertificateName
		result.ValidateCertificateName = &validateCertificateName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *BackendTlsProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackendTlsProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *BackendTlsProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackendTlsProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackendTlsProperties, got %T", armInput)
	}

	// Set property "ValidateCertificateChain":
	if typedInput.ValidateCertificateChain != nil {
		validateCertificateChain := *typedInput.ValidateCertificateChain
		properties.ValidateCertificateChain = &validateCertificateChain
	}

	// Set property "ValidateCertificateName":
	if typedInput.ValidateCertificateName != nil {
		validateCertificateName := *typedInput.ValidateCertificateName
		properties.ValidateCertificateName = &validateCertificateName
	}

	// No error
	return nil
}

// AssignProperties_From_BackendTlsProperties populates our BackendTlsProperties from the provided source BackendTlsProperties
func (properties *BackendTlsProperties) AssignProperties_From_BackendTlsProperties(source *storage.BackendTlsProperties) error {

	// ValidateCertificateChain
	if source.ValidateCertificateChain != nil {
		validateCertificateChain := *source.ValidateCertificateChain
		properties.ValidateCertificateChain = &validateCertificateChain
	} else {
		properties.ValidateCertificateChain = nil
	}

	// ValidateCertificateName
	if source.ValidateCertificateName != nil {
		validateCertificateName := *source.ValidateCertificateName
		properties.ValidateCertificateName = &validateCertificateName
	} else {
		properties.ValidateCertificateName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackendTlsProperties populates the provided destination BackendTlsProperties from our BackendTlsProperties
func (properties *BackendTlsProperties) AssignProperties_To_BackendTlsProperties(destination *storage.BackendTlsProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ValidateCertificateChain
	if properties.ValidateCertificateChain != nil {
		validateCertificateChain := *properties.ValidateCertificateChain
		destination.ValidateCertificateChain = &validateCertificateChain
	} else {
		destination.ValidateCertificateChain = nil
	}

	// ValidateCertificateName
	if properties.ValidateCertificateName != nil {
		validateCertificateName := *properties.ValidateCertificateName
		destination.ValidateCertificateName = &validateCertificateName
	} else {
		destination.ValidateCertificateName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Properties controlling TLS Certificate Validation.
type BackendTlsProperties_STATUS struct {
	// ValidateCertificateChain: Flag indicating whether SSL certificate chain validation should be done when using self-signed
	// certificates for this backend host.
	ValidateCertificateChain *bool `json:"validateCertificateChain,omitempty"`

	// ValidateCertificateName: Flag indicating whether SSL certificate name validation should be done when using self-signed
	// certificates for this backend host.
	ValidateCertificateName *bool `json:"validateCertificateName,omitempty"`
}

var _ genruntime.FromARMConverter = &BackendTlsProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *BackendTlsProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackendTlsProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *BackendTlsProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackendTlsProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackendTlsProperties_STATUS, got %T", armInput)
	}

	// Set property "ValidateCertificateChain":
	if typedInput.ValidateCertificateChain != nil {
		validateCertificateChain := *typedInput.ValidateCertificateChain
		properties.ValidateCertificateChain = &validateCertificateChain
	}

	// Set property "ValidateCertificateName":
	if typedInput.ValidateCertificateName != nil {
		validateCertificateName := *typedInput.ValidateCertificateName
		properties.ValidateCertificateName = &validateCertificateName
	}

	// No error
	return nil
}

// AssignProperties_From_BackendTlsProperties_STATUS populates our BackendTlsProperties_STATUS from the provided source BackendTlsProperties_STATUS
func (properties *BackendTlsProperties_STATUS) AssignProperties_From_BackendTlsProperties_STATUS(source *storage.BackendTlsProperties_STATUS) error {

	// ValidateCertificateChain
	if source.ValidateCertificateChain != nil {
		validateCertificateChain := *source.ValidateCertificateChain
		properties.ValidateCertificateChain = &validateCertificateChain
	} else {
		properties.ValidateCertificateChain = nil
	}

	// ValidateCertificateName
	if source.ValidateCertificateName != nil {
		validateCertificateName := *source.ValidateCertificateName
		properties.ValidateCertificateName = &validateCertificateName
	} else {
		properties.ValidateCertificateName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackendTlsProperties_STATUS populates the provided destination BackendTlsProperties_STATUS from our BackendTlsProperties_STATUS
func (properties *BackendTlsProperties_STATUS) AssignProperties_To_BackendTlsProperties_STATUS(destination *storage.BackendTlsProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ValidateCertificateChain
	if properties.ValidateCertificateChain != nil {
		validateCertificateChain := *properties.ValidateCertificateChain
		destination.ValidateCertificateChain = &validateCertificateChain
	} else {
		destination.ValidateCertificateChain = nil
	}

	// ValidateCertificateName
	if properties.ValidateCertificateName != nil {
		validateCertificateName := *properties.ValidateCertificateName
		destination.ValidateCertificateName = &validateCertificateName
	} else {
		destination.ValidateCertificateName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Authorization header information.
type BackendAuthorizationHeaderCredentials struct {
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:MaxLength=300
	// +kubebuilder:validation:MinLength=1
	// Parameter: Authentication Parameter value.
	Parameter *string `json:"parameter,omitempty"`

	// +kubebuilder:validation:Required
	// +kubebuilder:validation:MaxLength=100
	// +kubebuilder:validation:MinLength=1
	// Scheme: Authentication Scheme name.
	Scheme *string `json:"scheme,omitempty"`
}

var _ genruntime.ARMTransformer = &BackendAuthorizationHeaderCredentials{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (credentials *BackendAuthorizationHeaderCredentials) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if credentials == nil {
		return nil, nil
	}
	result := &arm.BackendAuthorizationHeaderCredentials{}

	// Set property "Parameter":
	if credentials.Parameter != nil {
		parameter := *credentials.Parameter
		result.Parameter = &parameter
	}

	// Set property "Scheme":
	if credentials.Scheme != nil {
		scheme := *credentials.Scheme
		result.Scheme = &scheme
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (credentials *BackendAuthorizationHeaderCredentials) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackendAuthorizationHeaderCredentials{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (credentials *BackendAuthorizationHeaderCredentials) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackendAuthorizationHeaderCredentials)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackendAuthorizationHeaderCredentials, got %T", armInput)
	}

	// Set property "Parameter":
	if typedInput.Parameter != nil {
		parameter := *typedInput.Parameter
		credentials.Parameter = &parameter
	}

	// Set property "Scheme":
	if typedInput.Scheme != nil {
		scheme := *typedInput.Scheme
		credentials.Scheme = &scheme
	}

	// No error
	return nil
}

// AssignProperties_From_BackendAuthorizationHeaderCredentials populates our BackendAuthorizationHeaderCredentials from the provided source BackendAuthorizationHeaderCredentials
func (credentials *BackendAuthorizationHeaderCredentials) AssignProperties_From_BackendAuthorizationHeaderCredentials(source *storage.BackendAuthorizationHeaderCredentials) error {

	// Parameter
	credentials.Parameter = genruntime.ClonePointerToString(source.Parameter)

	// Scheme
	credentials.Scheme = genruntime.ClonePointerToString(source.Scheme)

	// No error
	return nil
}

// AssignProperties_To_BackendAuthorizationHeaderCredentials populates the provided destination BackendAuthorizationHeaderCredentials from our BackendAuthorizationHeaderCredentials
func (credentials *BackendAuthorizationHeaderCredentials) AssignProperties_To_BackendAuthorizationHeaderCredentials(destination *storage.BackendAuthorizationHeaderCredentials) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Parameter
	destination.Parameter = genruntime.ClonePointerToString(credentials.Parameter)

	// Scheme
	destination.Scheme = genruntime.ClonePointerToString(credentials.Scheme)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Authorization header information.
type BackendAuthorizationHeaderCredentials_STATUS struct {
	// Parameter: Authentication Parameter value.
	Parameter *string `json:"parameter,omitempty"`

	// Scheme: Authentication Scheme name.
	Scheme *string `json:"scheme,omitempty"`
}

var _ genruntime.FromARMConverter = &BackendAuthorizationHeaderCredentials_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (credentials *BackendAuthorizationHeaderCredentials_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackendAuthorizationHeaderCredentials_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (credentials *BackendAuthorizationHeaderCredentials_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackendAuthorizationHeaderCredentials_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackendAuthorizationHeaderCredentials_STATUS, got %T", armInput)
	}

	// Set property "Parameter":
	if typedInput.Parameter != nil {
		parameter := *typedInput.Parameter
		credentials.Parameter = &parameter
	}

	// Set property "Scheme":
	if typedInput.Scheme != nil {
		scheme := *typedInput.Scheme
		credentials.Scheme = &scheme
	}

	// No error
	return nil
}

// AssignProperties_From_BackendAuthorizationHeaderCredentials_STATUS populates our BackendAuthorizationHeaderCredentials_STATUS from the provided source BackendAuthorizationHeaderCredentials_STATUS
func (credentials *BackendAuthorizationHeaderCredentials_STATUS) AssignProperties_From_BackendAuthorizationHeaderCredentials_STATUS(source *storage.BackendAuthorizationHeaderCredentials_STATUS) error {

	// Parameter
	credentials.Parameter = genruntime.ClonePointerToString(source.Parameter)

	// Scheme
	credentials.Scheme = genruntime.ClonePointerToString(source.Scheme)

	// No error
	return nil
}

// AssignProperties_To_BackendAuthorizationHeaderCredentials_STATUS populates the provided destination BackendAuthorizationHeaderCredentials_STATUS from our BackendAuthorizationHeaderCredentials_STATUS
func (credentials *BackendAuthorizationHeaderCredentials_STATUS) AssignProperties_To_BackendAuthorizationHeaderCredentials_STATUS(destination *storage.BackendAuthorizationHeaderCredentials_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Parameter
	destination.Parameter = genruntime.ClonePointerToString(credentials.Parameter)

	// Scheme
	destination.Scheme = genruntime.ClonePointerToString(credentials.Scheme)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Backend pool service information
type BackendPoolItem struct {
	// +kubebuilder:validation:Required
	// Reference: The unique ARM id of the backend entity. The ARM id should refer to an already existing backend entity.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &BackendPoolItem{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (item *BackendPoolItem) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if item == nil {
		return nil, nil
	}
	result := &arm.BackendPoolItem{}

	// Set property "Id":
	if item.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*item.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (item *BackendPoolItem) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackendPoolItem{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (item *BackendPoolItem) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(arm.BackendPoolItem)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackendPoolItem, got %T", armInput)
	}

	// no assignment for property "Reference"

	// No error
	return nil
}

// AssignProperties_From_BackendPoolItem populates our BackendPoolItem from the provided source BackendPoolItem
func (item *BackendPoolItem) AssignProperties_From_BackendPoolItem(source *storage.BackendPoolItem) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		item.Reference = &reference
	} else {
		item.Reference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackendPoolItem populates the provided destination BackendPoolItem from our BackendPoolItem
func (item *BackendPoolItem) AssignProperties_To_BackendPoolItem(destination *storage.BackendPoolItem) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if item.Reference != nil {
		reference := item.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Backend pool service information
type BackendPoolItem_STATUS struct {
	// +kubebuilder:validation:Required
	// Id: The unique ARM id of the backend entity. The ARM id should refer to an already existing backend entity.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &BackendPoolItem_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (item *BackendPoolItem_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackendPoolItem_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (item *BackendPoolItem_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackendPoolItem_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackendPoolItem_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		item.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_BackendPoolItem_STATUS populates our BackendPoolItem_STATUS from the provided source BackendPoolItem_STATUS
func (item *BackendPoolItem_STATUS) AssignProperties_From_BackendPoolItem_STATUS(source *storage.BackendPoolItem_STATUS) error {

	// Id
	item.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_BackendPoolItem_STATUS populates the provided destination BackendPoolItem_STATUS from our BackendPoolItem_STATUS
func (item *BackendPoolItem_STATUS) AssignProperties_To_BackendPoolItem_STATUS(destination *storage.BackendPoolItem_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(item.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Properties of the Service Fabric Type Backend.
type BackendServiceFabricClusterProperties struct {
	// ClientCertificateId: The client certificate id for the management endpoint.
	ClientCertificateId *string `json:"clientCertificateId,omitempty"`

	// ClientCertificatethumbprint: The client certificate thumbprint for the management endpoint. Will be ignored if
	// certificatesIds are provided
	ClientCertificatethumbprint *string `json:"clientCertificatethumbprint,omitempty"`

	// +kubebuilder:validation:Required
	// ManagementEndpoints: The cluster management endpoint.
	ManagementEndpoints []string `json:"managementEndpoints,omitempty"`

	// MaxPartitionResolutionRetries: Maximum number of retries while attempting resolve the partition.
	MaxPartitionResolutionRetries *int `json:"maxPartitionResolutionRetries,omitempty"`

	// ServerCertificateThumbprints: Thumbprints of certificates cluster management service uses for tls communication
	ServerCertificateThumbprints []string `json:"serverCertificateThumbprints,omitempty"`

	// ServerX509Names: Server X509 Certificate Names Collection
	ServerX509Names []X509CertificateName `json:"serverX509Names,omitempty"`
}

var _ genruntime.ARMTransformer = &BackendServiceFabricClusterProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *BackendServiceFabricClusterProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.BackendServiceFabricClusterProperties{}

	// Set property "ClientCertificateId":
	if properties.ClientCertificateId != nil {
		clientCertificateId := *properties.ClientCertificateId
		result.ClientCertificateId = &clientCertificateId
	}

	// Set property "ClientCertificatethumbprint":
	if properties.ClientCertificatethumbprint != nil {
		clientCertificatethumbprint := *properties.ClientCertificatethumbprint
		result.ClientCertificatethumbprint = &clientCertificatethumbprint
	}

	// Set property "ManagementEndpoints":
	for _, item := range properties.ManagementEndpoints {
		result.ManagementEndpoints = append(result.ManagementEndpoints, item)
	}

	// Set property "MaxPartitionResolutionRetries":
	if properties.MaxPartitionResolutionRetries != nil {
		maxPartitionResolutionRetries := *properties.MaxPartitionResolutionRetries
		result.MaxPartitionResolutionRetries = &maxPartitionResolutionRetries
	}

	// Set property "ServerCertificateThumbprints":
	for _, item := range properties.ServerCertificateThumbprints {
		result.ServerCertificateThumbprints = append(result.ServerCertificateThumbprints, item)
	}

	// Set property "ServerX509Names":
	for _, item := range properties.ServerX509Names {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.ServerX509Names = append(result.ServerX509Names, *item_ARM.(*arm.X509CertificateName))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *BackendServiceFabricClusterProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackendServiceFabricClusterProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *BackendServiceFabricClusterProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackendServiceFabricClusterProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackendServiceFabricClusterProperties, got %T", armInput)
	}

	// Set property "ClientCertificateId":
	if typedInput.ClientCertificateId != nil {
		clientCertificateId := *typedInput.ClientCertificateId
		properties.ClientCertificateId = &clientCertificateId
	}

	// Set property "ClientCertificatethumbprint":
	if typedInput.ClientCertificatethumbprint != nil {
		clientCertificatethumbprint := *typedInput.ClientCertificatethumbprint
		properties.ClientCertificatethumbprint = &clientCertificatethumbprint
	}

	// Set property "ManagementEndpoints":
	for _, item := range typedInput.ManagementEndpoints {
		properties.ManagementEndpoints = append(properties.ManagementEndpoints, item)
	}

	// Set property "MaxPartitionResolutionRetries":
	if typedInput.MaxPartitionResolutionRetries != nil {
		maxPartitionResolutionRetries := *typedInput.MaxPartitionResolutionRetries
		properties.MaxPartitionResolutionRetries = &maxPartitionResolutionRetries
	}

	// Set property "ServerCertificateThumbprints":
	for _, item := range typedInput.ServerCertificateThumbprints {
		properties.ServerCertificateThumbprints = append(properties.ServerCertificateThumbprints, item)
	}

	// Set property "ServerX509Names":
	for _, item := range typedInput.ServerX509Names {
		var item1 X509CertificateName
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.ServerX509Names = append(properties.ServerX509Names, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_BackendServiceFabricClusterProperties populates our BackendServiceFabricClusterProperties from the provided source BackendServiceFabricClusterProperties
func (properties *BackendServiceFabricClusterProperties) AssignProperties_From_BackendServiceFabricClusterProperties(source *storage.BackendServiceFabricClusterProperties) error {

	// ClientCertificateId
	properties.ClientCertificateId = genruntime.ClonePointerToString(source.ClientCertificateId)

	// ClientCertificatethumbprint
	properties.ClientCertificatethumbprint = genruntime.ClonePointerToString(source.ClientCertificatethumbprint)

	// ManagementEndpoints
	properties.ManagementEndpoints = genruntime.CloneSliceOfString(source.ManagementEndpoints)

	// MaxPartitionResolutionRetries
	properties.MaxPartitionResolutionRetries = genruntime.ClonePointerToInt(source.MaxPartitionResolutionRetries)

	// ServerCertificateThumbprints
	properties.ServerCertificateThumbprints = genruntime.CloneSliceOfString(source.ServerCertificateThumbprints)

	// ServerX509Names
	if source.ServerX509Names != nil {
		serverX509NameList := make([]X509CertificateName, len(source.ServerX509Names))
		for serverX509NameIndex, serverX509NameItem := range source.ServerX509Names {
			// Shadow the loop variable to avoid aliasing
			serverX509NameItem := serverX509NameItem
			var serverX509Name X509CertificateName
			err := serverX509Name.AssignProperties_From_X509CertificateName(&serverX509NameItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_X509CertificateName() to populate field ServerX509Names")
			}
			serverX509NameList[serverX509NameIndex] = serverX509Name
		}
		properties.ServerX509Names = serverX509NameList
	} else {
		properties.ServerX509Names = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackendServiceFabricClusterProperties populates the provided destination BackendServiceFabricClusterProperties from our BackendServiceFabricClusterProperties
func (properties *BackendServiceFabricClusterProperties) AssignProperties_To_BackendServiceFabricClusterProperties(destination *storage.BackendServiceFabricClusterProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientCertificateId
	destination.ClientCertificateId = genruntime.ClonePointerToString(properties.ClientCertificateId)

	// ClientCertificatethumbprint
	destination.ClientCertificatethumbprint = genruntime.ClonePointerToString(properties.ClientCertificatethumbprint)

	// ManagementEndpoints
	destination.ManagementEndpoints = genruntime.CloneSliceOfString(properties.ManagementEndpoints)

	// MaxPartitionResolutionRetries
	destination.MaxPartitionResolutionRetries = genruntime.ClonePointerToInt(properties.MaxPartitionResolutionRetries)

	// ServerCertificateThumbprints
	destination.ServerCertificateThumbprints = genruntime.CloneSliceOfString(properties.ServerCertificateThumbprints)

	// ServerX509Names
	if properties.ServerX509Names != nil {
		serverX509NameList := make([]storage.X509CertificateName, len(properties.ServerX509Names))
		for serverX509NameIndex, serverX509NameItem := range properties.ServerX509Names {
			// Shadow the loop variable to avoid aliasing
			serverX509NameItem := serverX509NameItem
			var serverX509Name storage.X509CertificateName
			err := serverX509NameItem.AssignProperties_To_X509CertificateName(&serverX509Name)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_X509CertificateName() to populate field ServerX509Names")
			}
			serverX509NameList[serverX509NameIndex] = serverX509Name
		}
		destination.ServerX509Names = serverX509NameList
	} else {
		destination.ServerX509Names = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Properties of the Service Fabric Type Backend.
type BackendServiceFabricClusterProperties_STATUS struct {
	// ClientCertificateId: The client certificate id for the management endpoint.
	ClientCertificateId *string `json:"clientCertificateId,omitempty"`

	// ClientCertificatethumbprint: The client certificate thumbprint for the management endpoint. Will be ignored if
	// certificatesIds are provided
	ClientCertificatethumbprint *string `json:"clientCertificatethumbprint,omitempty"`

	// ManagementEndpoints: The cluster management endpoint.
	ManagementEndpoints []string `json:"managementEndpoints,omitempty"`

	// MaxPartitionResolutionRetries: Maximum number of retries while attempting resolve the partition.
	MaxPartitionResolutionRetries *int `json:"maxPartitionResolutionRetries,omitempty"`

	// ServerCertificateThumbprints: Thumbprints of certificates cluster management service uses for tls communication
	ServerCertificateThumbprints []string `json:"serverCertificateThumbprints,omitempty"`

	// ServerX509Names: Server X509 Certificate Names Collection
	ServerX509Names []X509CertificateName_STATUS `json:"serverX509Names,omitempty"`
}

var _ genruntime.FromARMConverter = &BackendServiceFabricClusterProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *BackendServiceFabricClusterProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.BackendServiceFabricClusterProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *BackendServiceFabricClusterProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.BackendServiceFabricClusterProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.BackendServiceFabricClusterProperties_STATUS, got %T", armInput)
	}

	// Set property "ClientCertificateId":
	if typedInput.ClientCertificateId != nil {
		clientCertificateId := *typedInput.ClientCertificateId
		properties.ClientCertificateId = &clientCertificateId
	}

	// Set property "ClientCertificatethumbprint":
	if typedInput.ClientCertificatethumbprint != nil {
		clientCertificatethumbprint := *typedInput.ClientCertificatethumbprint
		properties.ClientCertificatethumbprint = &clientCertificatethumbprint
	}

	// Set property "ManagementEndpoints":
	for _, item := range typedInput.ManagementEndpoints {
		properties.ManagementEndpoints = append(properties.ManagementEndpoints, item)
	}

	// Set property "MaxPartitionResolutionRetries":
	if typedInput.MaxPartitionResolutionRetries != nil {
		maxPartitionResolutionRetries := *typedInput.MaxPartitionResolutionRetries
		properties.MaxPartitionResolutionRetries = &maxPartitionResolutionRetries
	}

	// Set property "ServerCertificateThumbprints":
	for _, item := range typedInput.ServerCertificateThumbprints {
		properties.ServerCertificateThumbprints = append(properties.ServerCertificateThumbprints, item)
	}

	// Set property "ServerX509Names":
	for _, item := range typedInput.ServerX509Names {
		var item1 X509CertificateName_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.ServerX509Names = append(properties.ServerX509Names, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_BackendServiceFabricClusterProperties_STATUS populates our BackendServiceFabricClusterProperties_STATUS from the provided source BackendServiceFabricClusterProperties_STATUS
func (properties *BackendServiceFabricClusterProperties_STATUS) AssignProperties_From_BackendServiceFabricClusterProperties_STATUS(source *storage.BackendServiceFabricClusterProperties_STATUS) error {

	// ClientCertificateId
	properties.ClientCertificateId = genruntime.ClonePointerToString(source.ClientCertificateId)

	// ClientCertificatethumbprint
	properties.ClientCertificatethumbprint = genruntime.ClonePointerToString(source.ClientCertificatethumbprint)

	// ManagementEndpoints
	properties.ManagementEndpoints = genruntime.CloneSliceOfString(source.ManagementEndpoints)

	// MaxPartitionResolutionRetries
	properties.MaxPartitionResolutionRetries = genruntime.ClonePointerToInt(source.MaxPartitionResolutionRetries)

	// ServerCertificateThumbprints
	properties.ServerCertificateThumbprints = genruntime.CloneSliceOfString(source.ServerCertificateThumbprints)

	// ServerX509Names
	if source.ServerX509Names != nil {
		serverX509NameList := make([]X509CertificateName_STATUS, len(source.ServerX509Names))
		for serverX509NameIndex, serverX509NameItem := range source.ServerX509Names {
			// Shadow the loop variable to avoid aliasing
			serverX509NameItem := serverX509NameItem
			var serverX509Name X509CertificateName_STATUS
			err := serverX509Name.AssignProperties_From_X509CertificateName_STATUS(&serverX509NameItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_X509CertificateName_STATUS() to populate field ServerX509Names")
			}
			serverX509NameList[serverX509NameIndex] = serverX509Name
		}
		properties.ServerX509Names = serverX509NameList
	} else {
		properties.ServerX509Names = nil
	}

	// No error
	return nil
}

// AssignProperties_To_BackendServiceFabricClusterProperties_STATUS populates the provided destination BackendServiceFabricClusterProperties_STATUS from our BackendServiceFabricClusterProperties_STATUS
func (properties *BackendServiceFabricClusterProperties_STATUS) AssignProperties_To_BackendServiceFabricClusterProperties_STATUS(destination *storage.BackendServiceFabricClusterProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientCertificateId
	destination.ClientCertificateId = genruntime.ClonePointerToString(properties.ClientCertificateId)

	// ClientCertificatethumbprint
	destination.ClientCertificatethumbprint = genruntime.ClonePointerToString(properties.ClientCertificatethumbprint)

	// ManagementEndpoints
	destination.ManagementEndpoints = genruntime.CloneSliceOfString(properties.ManagementEndpoints)

	// MaxPartitionResolutionRetries
	destination.MaxPartitionResolutionRetries = genruntime.ClonePointerToInt(properties.MaxPartitionResolutionRetries)

	// ServerCertificateThumbprints
	destination.ServerCertificateThumbprints = genruntime.CloneSliceOfString(properties.ServerCertificateThumbprints)

	// ServerX509Names
	if properties.ServerX509Names != nil {
		serverX509NameList := make([]storage.X509CertificateName_STATUS, len(properties.ServerX509Names))
		for serverX509NameIndex, serverX509NameItem := range properties.ServerX509Names {
			// Shadow the loop variable to avoid aliasing
			serverX509NameItem := serverX509NameItem
			var serverX509Name storage.X509CertificateName_STATUS
			err := serverX509NameItem.AssignProperties_To_X509CertificateName_STATUS(&serverX509Name)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_X509CertificateName_STATUS() to populate field ServerX509Names")
			}
			serverX509NameList[serverX509NameIndex] = serverX509Name
		}
		destination.ServerX509Names = serverX509NameList
	} else {
		destination.ServerX509Names = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Rule configuration to trip the backend.
type CircuitBreakerRule struct {
	// FailureCondition: The conditions for tripping the circuit breaker.
	FailureCondition *CircuitBreakerFailureCondition `json:"failureCondition,omitempty"`

	// Name: The rule name.
	Name *string `json:"name,omitempty"`

	// TripDuration: The duration for which the circuit will be tripped.
	TripDuration *string `json:"tripDuration,omitempty"`
}

var _ genruntime.ARMTransformer = &CircuitBreakerRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *CircuitBreakerRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.CircuitBreakerRule{}

	// Set property "FailureCondition":
	if rule.FailureCondition != nil {
		failureCondition_ARM, err := (*rule.FailureCondition).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		failureCondition := *failureCondition_ARM.(*arm.CircuitBreakerFailureCondition)
		result.FailureCondition = &failureCondition
	}

	// Set property "Name":
	if rule.Name != nil {
		name := *rule.Name
		result.Name = &name
	}

	// Set property "TripDuration":
	if rule.TripDuration != nil {
		tripDuration := *rule.TripDuration
		result.TripDuration = &tripDuration
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *CircuitBreakerRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CircuitBreakerRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *CircuitBreakerRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CircuitBreakerRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CircuitBreakerRule, got %T", armInput)
	}

	// Set property "FailureCondition":
	if typedInput.FailureCondition != nil {
		var failureCondition1 CircuitBreakerFailureCondition
		err := failureCondition1.PopulateFromARM(owner, *typedInput.FailureCondition)
		if err != nil {
			return err
		}
		failureCondition := failureCondition1
		rule.FailureCondition = &failureCondition
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property "TripDuration":
	if typedInput.TripDuration != nil {
		tripDuration := *typedInput.TripDuration
		rule.TripDuration = &tripDuration
	}

	// No error
	return nil
}

// AssignProperties_From_CircuitBreakerRule populates our CircuitBreakerRule from the provided source CircuitBreakerRule
func (rule *CircuitBreakerRule) AssignProperties_From_CircuitBreakerRule(source *storage.CircuitBreakerRule) error {

	// FailureCondition
	if source.FailureCondition != nil {
		var failureCondition CircuitBreakerFailureCondition
		err := failureCondition.AssignProperties_From_CircuitBreakerFailureCondition(source.FailureCondition)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CircuitBreakerFailureCondition() to populate field FailureCondition")
		}
		rule.FailureCondition = &failureCondition
	} else {
		rule.FailureCondition = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// TripDuration
	rule.TripDuration = genruntime.ClonePointerToString(source.TripDuration)

	// No error
	return nil
}

// AssignProperties_To_CircuitBreakerRule populates the provided destination CircuitBreakerRule from our CircuitBreakerRule
func (rule *CircuitBreakerRule) AssignProperties_To_CircuitBreakerRule(destination *storage.CircuitBreakerRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// FailureCondition
	if rule.FailureCondition != nil {
		var failureCondition storage.CircuitBreakerFailureCondition
		err := rule.FailureCondition.AssignProperties_To_CircuitBreakerFailureCondition(&failureCondition)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CircuitBreakerFailureCondition() to populate field FailureCondition")
		}
		destination.FailureCondition = &failureCondition
	} else {
		destination.FailureCondition = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// TripDuration
	destination.TripDuration = genruntime.ClonePointerToString(rule.TripDuration)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Rule configuration to trip the backend.
type CircuitBreakerRule_STATUS struct {
	// FailureCondition: The conditions for tripping the circuit breaker.
	FailureCondition *CircuitBreakerFailureCondition_STATUS `json:"failureCondition,omitempty"`

	// Name: The rule name.
	Name *string `json:"name,omitempty"`

	// TripDuration: The duration for which the circuit will be tripped.
	TripDuration *string `json:"tripDuration,omitempty"`
}

var _ genruntime.FromARMConverter = &CircuitBreakerRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *CircuitBreakerRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CircuitBreakerRule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *CircuitBreakerRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CircuitBreakerRule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CircuitBreakerRule_STATUS, got %T", armInput)
	}

	// Set property "FailureCondition":
	if typedInput.FailureCondition != nil {
		var failureCondition1 CircuitBreakerFailureCondition_STATUS
		err := failureCondition1.PopulateFromARM(owner, *typedInput.FailureCondition)
		if err != nil {
			return err
		}
		failureCondition := failureCondition1
		rule.FailureCondition = &failureCondition
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property "TripDuration":
	if typedInput.TripDuration != nil {
		tripDuration := *typedInput.TripDuration
		rule.TripDuration = &tripDuration
	}

	// No error
	return nil
}

// AssignProperties_From_CircuitBreakerRule_STATUS populates our CircuitBreakerRule_STATUS from the provided source CircuitBreakerRule_STATUS
func (rule *CircuitBreakerRule_STATUS) AssignProperties_From_CircuitBreakerRule_STATUS(source *storage.CircuitBreakerRule_STATUS) error {

	// FailureCondition
	if source.FailureCondition != nil {
		var failureCondition CircuitBreakerFailureCondition_STATUS
		err := failureCondition.AssignProperties_From_CircuitBreakerFailureCondition_STATUS(source.FailureCondition)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CircuitBreakerFailureCondition_STATUS() to populate field FailureCondition")
		}
		rule.FailureCondition = &failureCondition
	} else {
		rule.FailureCondition = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// TripDuration
	rule.TripDuration = genruntime.ClonePointerToString(source.TripDuration)

	// No error
	return nil
}

// AssignProperties_To_CircuitBreakerRule_STATUS populates the provided destination CircuitBreakerRule_STATUS from our CircuitBreakerRule_STATUS
func (rule *CircuitBreakerRule_STATUS) AssignProperties_To_CircuitBreakerRule_STATUS(destination *storage.CircuitBreakerRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// FailureCondition
	if rule.FailureCondition != nil {
		var failureCondition storage.CircuitBreakerFailureCondition_STATUS
		err := rule.FailureCondition.AssignProperties_To_CircuitBreakerFailureCondition_STATUS(&failureCondition)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CircuitBreakerFailureCondition_STATUS() to populate field FailureCondition")
		}
		destination.FailureCondition = &failureCondition
	} else {
		destination.FailureCondition = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// TripDuration
	destination.TripDuration = genruntime.ClonePointerToString(rule.TripDuration)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The trip conditions of the circuit breaker
type CircuitBreakerFailureCondition struct {
	// Count: The threshold for opening the circuit.
	Count *int `json:"count,omitempty"`

	// +kubebuilder:validation:MaxItems=10
	// ErrorReasons: The error reasons which are considered as failure.
	ErrorReasons []CircuitBreakerFailureCondition_ErrorReasons `json:"errorReasons,omitempty"`

	// Interval: The interval during which the failures are counted.
	Interval *string `json:"interval,omitempty"`

	// Percentage: The threshold for opening the circuit.
	Percentage *int `json:"percentage,omitempty"`

	// +kubebuilder:validation:MaxItems=10
	// StatusCodeRanges: The status code ranges which are considered as failure.
	StatusCodeRanges []FailureStatusCodeRange `json:"statusCodeRanges,omitempty"`
}

var _ genruntime.ARMTransformer = &CircuitBreakerFailureCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *CircuitBreakerFailureCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &arm.CircuitBreakerFailureCondition{}

	// Set property "Count":
	if condition.Count != nil {
		count := *condition.Count
		result.Count = &count
	}

	// Set property "ErrorReasons":
	for _, item := range condition.ErrorReasons {
		result.ErrorReasons = append(result.ErrorReasons, string(item))
	}

	// Set property "Interval":
	if condition.Interval != nil {
		interval := *condition.Interval
		result.Interval = &interval
	}

	// Set property "Percentage":
	if condition.Percentage != nil {
		percentage := *condition.Percentage
		result.Percentage = &percentage
	}

	// Set property "StatusCodeRanges":
	for _, item := range condition.StatusCodeRanges {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.StatusCodeRanges = append(result.StatusCodeRanges, *item_ARM.(*arm.FailureStatusCodeRange))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *CircuitBreakerFailureCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CircuitBreakerFailureCondition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *CircuitBreakerFailureCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CircuitBreakerFailureCondition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CircuitBreakerFailureCondition, got %T", armInput)
	}

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		condition.Count = &count
	}

	// Set property "ErrorReasons":
	for _, item := range typedInput.ErrorReasons {
		condition.ErrorReasons = append(condition.ErrorReasons, CircuitBreakerFailureCondition_ErrorReasons(item))
	}

	// Set property "Interval":
	if typedInput.Interval != nil {
		interval := *typedInput.Interval
		condition.Interval = &interval
	}

	// Set property "Percentage":
	if typedInput.Percentage != nil {
		percentage := *typedInput.Percentage
		condition.Percentage = &percentage
	}

	// Set property "StatusCodeRanges":
	for _, item := range typedInput.StatusCodeRanges {
		var item1 FailureStatusCodeRange
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		condition.StatusCodeRanges = append(condition.StatusCodeRanges, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_CircuitBreakerFailureCondition populates our CircuitBreakerFailureCondition from the provided source CircuitBreakerFailureCondition
func (condition *CircuitBreakerFailureCondition) AssignProperties_From_CircuitBreakerFailureCondition(source *storage.CircuitBreakerFailureCondition) error {

	// Count
	condition.Count = genruntime.ClonePointerToInt(source.Count)

	// ErrorReasons
	if source.ErrorReasons != nil {
		errorReasonList := make([]CircuitBreakerFailureCondition_ErrorReasons, len(source.ErrorReasons))
		for errorReasonIndex, errorReasonItem := range source.ErrorReasons {
			// Shadow the loop variable to avoid aliasing
			errorReasonItem := errorReasonItem
			errorReasonList[errorReasonIndex] = CircuitBreakerFailureCondition_ErrorReasons(errorReasonItem)
		}
		condition.ErrorReasons = errorReasonList
	} else {
		condition.ErrorReasons = nil
	}

	// Interval
	condition.Interval = genruntime.ClonePointerToString(source.Interval)

	// Percentage
	condition.Percentage = genruntime.ClonePointerToInt(source.Percentage)

	// StatusCodeRanges
	if source.StatusCodeRanges != nil {
		statusCodeRangeList := make([]FailureStatusCodeRange, len(source.StatusCodeRanges))
		for statusCodeRangeIndex, statusCodeRangeItem := range source.StatusCodeRanges {
			// Shadow the loop variable to avoid aliasing
			statusCodeRangeItem := statusCodeRangeItem
			var statusCodeRange FailureStatusCodeRange
			err := statusCodeRange.AssignProperties_From_FailureStatusCodeRange(&statusCodeRangeItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_FailureStatusCodeRange() to populate field StatusCodeRanges")
			}
			statusCodeRangeList[statusCodeRangeIndex] = statusCodeRange
		}
		condition.StatusCodeRanges = statusCodeRangeList
	} else {
		condition.StatusCodeRanges = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CircuitBreakerFailureCondition populates the provided destination CircuitBreakerFailureCondition from our CircuitBreakerFailureCondition
func (condition *CircuitBreakerFailureCondition) AssignProperties_To_CircuitBreakerFailureCondition(destination *storage.CircuitBreakerFailureCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(condition.Count)

	// ErrorReasons
	if condition.ErrorReasons != nil {
		errorReasonList := make([]string, len(condition.ErrorReasons))
		for errorReasonIndex, errorReasonItem := range condition.ErrorReasons {
			// Shadow the loop variable to avoid aliasing
			errorReasonItem := errorReasonItem
			errorReasonList[errorReasonIndex] = string(errorReasonItem)
		}
		destination.ErrorReasons = errorReasonList
	} else {
		destination.ErrorReasons = nil
	}

	// Interval
	destination.Interval = genruntime.ClonePointerToString(condition.Interval)

	// Percentage
	destination.Percentage = genruntime.ClonePointerToInt(condition.Percentage)

	// StatusCodeRanges
	if condition.StatusCodeRanges != nil {
		statusCodeRangeList := make([]storage.FailureStatusCodeRange, len(condition.StatusCodeRanges))
		for statusCodeRangeIndex, statusCodeRangeItem := range condition.StatusCodeRanges {
			// Shadow the loop variable to avoid aliasing
			statusCodeRangeItem := statusCodeRangeItem
			var statusCodeRange storage.FailureStatusCodeRange
			err := statusCodeRangeItem.AssignProperties_To_FailureStatusCodeRange(&statusCodeRange)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_FailureStatusCodeRange() to populate field StatusCodeRanges")
			}
			statusCodeRangeList[statusCodeRangeIndex] = statusCodeRange
		}
		destination.StatusCodeRanges = statusCodeRangeList
	} else {
		destination.StatusCodeRanges = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The trip conditions of the circuit breaker
type CircuitBreakerFailureCondition_STATUS struct {
	// Count: The threshold for opening the circuit.
	Count *int `json:"count,omitempty"`

	// +kubebuilder:validation:MaxItems=10
	// ErrorReasons: The error reasons which are considered as failure.
	ErrorReasons []CircuitBreakerFailureCondition_ErrorReasons_STATUS `json:"errorReasons,omitempty"`

	// Interval: The interval during which the failures are counted.
	Interval *string `json:"interval,omitempty"`

	// Percentage: The threshold for opening the circuit.
	Percentage *int `json:"percentage,omitempty"`

	// +kubebuilder:validation:MaxItems=10
	// StatusCodeRanges: The status code ranges which are considered as failure.
	StatusCodeRanges []FailureStatusCodeRange_STATUS `json:"statusCodeRanges,omitempty"`
}

var _ genruntime.FromARMConverter = &CircuitBreakerFailureCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *CircuitBreakerFailureCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CircuitBreakerFailureCondition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *CircuitBreakerFailureCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CircuitBreakerFailureCondition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CircuitBreakerFailureCondition_STATUS, got %T", armInput)
	}

	// Set property "Count":
	if typedInput.Count != nil {
		count := *typedInput.Count
		condition.Count = &count
	}

	// Set property "ErrorReasons":
	for _, item := range typedInput.ErrorReasons {
		condition.ErrorReasons = append(condition.ErrorReasons, CircuitBreakerFailureCondition_ErrorReasons_STATUS(item))
	}

	// Set property "Interval":
	if typedInput.Interval != nil {
		interval := *typedInput.Interval
		condition.Interval = &interval
	}

	// Set property "Percentage":
	if typedInput.Percentage != nil {
		percentage := *typedInput.Percentage
		condition.Percentage = &percentage
	}

	// Set property "StatusCodeRanges":
	for _, item := range typedInput.StatusCodeRanges {
		var item1 FailureStatusCodeRange_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		condition.StatusCodeRanges = append(condition.StatusCodeRanges, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_CircuitBreakerFailureCondition_STATUS populates our CircuitBreakerFailureCondition_STATUS from the provided source CircuitBreakerFailureCondition_STATUS
func (condition *CircuitBreakerFailureCondition_STATUS) AssignProperties_From_CircuitBreakerFailureCondition_STATUS(source *storage.CircuitBreakerFailureCondition_STATUS) error {

	// Count
	condition.Count = genruntime.ClonePointerToInt(source.Count)

	// ErrorReasons
	if source.ErrorReasons != nil {
		errorReasonList := make([]CircuitBreakerFailureCondition_ErrorReasons_STATUS, len(source.ErrorReasons))
		for errorReasonIndex, errorReasonItem := range source.ErrorReasons {
			// Shadow the loop variable to avoid aliasing
			errorReasonItem := errorReasonItem
			errorReasonList[errorReasonIndex] = CircuitBreakerFailureCondition_ErrorReasons_STATUS(errorReasonItem)
		}
		condition.ErrorReasons = errorReasonList
	} else {
		condition.ErrorReasons = nil
	}

	// Interval
	condition.Interval = genruntime.ClonePointerToString(source.Interval)

	// Percentage
	condition.Percentage = genruntime.ClonePointerToInt(source.Percentage)

	// StatusCodeRanges
	if source.StatusCodeRanges != nil {
		statusCodeRangeList := make([]FailureStatusCodeRange_STATUS, len(source.StatusCodeRanges))
		for statusCodeRangeIndex, statusCodeRangeItem := range source.StatusCodeRanges {
			// Shadow the loop variable to avoid aliasing
			statusCodeRangeItem := statusCodeRangeItem
			var statusCodeRange FailureStatusCodeRange_STATUS
			err := statusCodeRange.AssignProperties_From_FailureStatusCodeRange_STATUS(&statusCodeRangeItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_FailureStatusCodeRange_STATUS() to populate field StatusCodeRanges")
			}
			statusCodeRangeList[statusCodeRangeIndex] = statusCodeRange
		}
		condition.StatusCodeRanges = statusCodeRangeList
	} else {
		condition.StatusCodeRanges = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CircuitBreakerFailureCondition_STATUS populates the provided destination CircuitBreakerFailureCondition_STATUS from our CircuitBreakerFailureCondition_STATUS
func (condition *CircuitBreakerFailureCondition_STATUS) AssignProperties_To_CircuitBreakerFailureCondition_STATUS(destination *storage.CircuitBreakerFailureCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Count
	destination.Count = genruntime.ClonePointerToInt(condition.Count)

	// ErrorReasons
	if condition.ErrorReasons != nil {
		errorReasonList := make([]string, len(condition.ErrorReasons))
		for errorReasonIndex, errorReasonItem := range condition.ErrorReasons {
			// Shadow the loop variable to avoid aliasing
			errorReasonItem := errorReasonItem
			errorReasonList[errorReasonIndex] = string(errorReasonItem)
		}
		destination.ErrorReasons = errorReasonList
	} else {
		destination.ErrorReasons = nil
	}

	// Interval
	destination.Interval = genruntime.ClonePointerToString(condition.Interval)

	// Percentage
	destination.Percentage = genruntime.ClonePointerToInt(condition.Percentage)

	// StatusCodeRanges
	if condition.StatusCodeRanges != nil {
		statusCodeRangeList := make([]storage.FailureStatusCodeRange_STATUS, len(condition.StatusCodeRanges))
		for statusCodeRangeIndex, statusCodeRangeItem := range condition.StatusCodeRanges {
			// Shadow the loop variable to avoid aliasing
			statusCodeRangeItem := statusCodeRangeItem
			var statusCodeRange storage.FailureStatusCodeRange_STATUS
			err := statusCodeRangeItem.AssignProperties_To_FailureStatusCodeRange_STATUS(&statusCodeRange)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_FailureStatusCodeRange_STATUS() to populate field StatusCodeRanges")
			}
			statusCodeRangeList[statusCodeRangeIndex] = statusCodeRange
		}
		destination.StatusCodeRanges = statusCodeRangeList
	} else {
		destination.StatusCodeRanges = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Properties of server X509Names.
type X509CertificateName struct {
	// IssuerCertificateThumbprint: Thumbprint for the Issuer of the Certificate.
	IssuerCertificateThumbprint *string `json:"issuerCertificateThumbprint,omitempty"`

	// Name: Common Name of the Certificate.
	Name *string `json:"name,omitempty"`
}

var _ genruntime.ARMTransformer = &X509CertificateName{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (name *X509CertificateName) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if name == nil {
		return nil, nil
	}
	result := &arm.X509CertificateName{}

	// Set property "IssuerCertificateThumbprint":
	if name.IssuerCertificateThumbprint != nil {
		issuerCertificateThumbprint := *name.IssuerCertificateThumbprint
		result.IssuerCertificateThumbprint = &issuerCertificateThumbprint
	}

	// Set property "Name":
	if name.Name != nil {
		name1 := *name.Name
		result.Name = &name1
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (name *X509CertificateName) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.X509CertificateName{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (name *X509CertificateName) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.X509CertificateName)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.X509CertificateName, got %T", armInput)
	}

	// Set property "IssuerCertificateThumbprint":
	if typedInput.IssuerCertificateThumbprint != nil {
		issuerCertificateThumbprint := *typedInput.IssuerCertificateThumbprint
		name.IssuerCertificateThumbprint = &issuerCertificateThumbprint
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name1 := *typedInput.Name
		name.Name = &name1
	}

	// No error
	return nil
}

// AssignProperties_From_X509CertificateName populates our X509CertificateName from the provided source X509CertificateName
func (name *X509CertificateName) AssignProperties_From_X509CertificateName(source *storage.X509CertificateName) error {

	// IssuerCertificateThumbprint
	name.IssuerCertificateThumbprint = genruntime.ClonePointerToString(source.IssuerCertificateThumbprint)

	// Name
	name.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// AssignProperties_To_X509CertificateName populates the provided destination X509CertificateName from our X509CertificateName
func (name *X509CertificateName) AssignProperties_To_X509CertificateName(destination *storage.X509CertificateName) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IssuerCertificateThumbprint
	destination.IssuerCertificateThumbprint = genruntime.ClonePointerToString(name.IssuerCertificateThumbprint)

	// Name
	destination.Name = genruntime.ClonePointerToString(name.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Properties of server X509Names.
type X509CertificateName_STATUS struct {
	// IssuerCertificateThumbprint: Thumbprint for the Issuer of the Certificate.
	IssuerCertificateThumbprint *string `json:"issuerCertificateThumbprint,omitempty"`

	// Name: Common Name of the Certificate.
	Name *string `json:"name,omitempty"`
}

var _ genruntime.FromARMConverter = &X509CertificateName_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (name *X509CertificateName_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.X509CertificateName_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (name *X509CertificateName_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.X509CertificateName_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.X509CertificateName_STATUS, got %T", armInput)
	}

	// Set property "IssuerCertificateThumbprint":
	if typedInput.IssuerCertificateThumbprint != nil {
		issuerCertificateThumbprint := *typedInput.IssuerCertificateThumbprint
		name.IssuerCertificateThumbprint = &issuerCertificateThumbprint
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name1 := *typedInput.Name
		name.Name = &name1
	}

	// No error
	return nil
}

// AssignProperties_From_X509CertificateName_STATUS populates our X509CertificateName_STATUS from the provided source X509CertificateName_STATUS
func (name *X509CertificateName_STATUS) AssignProperties_From_X509CertificateName_STATUS(source *storage.X509CertificateName_STATUS) error {

	// IssuerCertificateThumbprint
	name.IssuerCertificateThumbprint = genruntime.ClonePointerToString(source.IssuerCertificateThumbprint)

	// Name
	name.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// AssignProperties_To_X509CertificateName_STATUS populates the provided destination X509CertificateName_STATUS from our X509CertificateName_STATUS
func (name *X509CertificateName_STATUS) AssignProperties_To_X509CertificateName_STATUS(destination *storage.X509CertificateName_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IssuerCertificateThumbprint
	destination.IssuerCertificateThumbprint = genruntime.ClonePointerToString(name.IssuerCertificateThumbprint)

	// Name
	destination.Name = genruntime.ClonePointerToString(name.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:MaxLength=200
type CircuitBreakerFailureCondition_ErrorReasons string

// +kubebuilder:validation:MaxLength=200
type CircuitBreakerFailureCondition_ErrorReasons_STATUS string

// The failure http status code range
type FailureStatusCodeRange struct {
	// +kubebuilder:validation:Maximum=599
	// +kubebuilder:validation:Minimum=200
	// Max: The maximum http status code.
	Max *int `json:"max,omitempty"`

	// +kubebuilder:validation:Maximum=599
	// +kubebuilder:validation:Minimum=200
	// Min: The minimum http status code.
	Min *int `json:"min,omitempty"`
}

var _ genruntime.ARMTransformer = &FailureStatusCodeRange{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (codeRange *FailureStatusCodeRange) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if codeRange == nil {
		return nil, nil
	}
	result := &arm.FailureStatusCodeRange{}

	// Set property "Max":
	if codeRange.Max != nil {
		max := *codeRange.Max
		result.Max = &max
	}

	// Set property "Min":
	if codeRange.Min != nil {
		min := *codeRange.Min
		result.Min = &min
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (codeRange *FailureStatusCodeRange) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FailureStatusCodeRange{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (codeRange *FailureStatusCodeRange) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FailureStatusCodeRange)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FailureStatusCodeRange, got %T", armInput)
	}

	// Set property "Max":
	if typedInput.Max != nil {
		max := *typedInput.Max
		codeRange.Max = &max
	}

	// Set property "Min":
	if typedInput.Min != nil {
		min := *typedInput.Min
		codeRange.Min = &min
	}

	// No error
	return nil
}

// AssignProperties_From_FailureStatusCodeRange populates our FailureStatusCodeRange from the provided source FailureStatusCodeRange
func (codeRange *FailureStatusCodeRange) AssignProperties_From_FailureStatusCodeRange(source *storage.FailureStatusCodeRange) error {

	// Max
	codeRange.Max = genruntime.ClonePointerToInt(source.Max)

	// Min
	codeRange.Min = genruntime.ClonePointerToInt(source.Min)

	// No error
	return nil
}

// AssignProperties_To_FailureStatusCodeRange populates the provided destination FailureStatusCodeRange from our FailureStatusCodeRange
func (codeRange *FailureStatusCodeRange) AssignProperties_To_FailureStatusCodeRange(destination *storage.FailureStatusCodeRange) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Max
	destination.Max = genruntime.ClonePointerToInt(codeRange.Max)

	// Min
	destination.Min = genruntime.ClonePointerToInt(codeRange.Min)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The failure http status code range
type FailureStatusCodeRange_STATUS struct {
	// +kubebuilder:validation:Maximum=599
	// +kubebuilder:validation:Minimum=200
	// Max: The maximum http status code.
	Max *int `json:"max,omitempty"`

	// +kubebuilder:validation:Maximum=599
	// +kubebuilder:validation:Minimum=200
	// Min: The minimum http status code.
	Min *int `json:"min,omitempty"`
}

var _ genruntime.FromARMConverter = &FailureStatusCodeRange_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (codeRange *FailureStatusCodeRange_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.FailureStatusCodeRange_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (codeRange *FailureStatusCodeRange_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.FailureStatusCodeRange_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.FailureStatusCodeRange_STATUS, got %T", armInput)
	}

	// Set property "Max":
	if typedInput.Max != nil {
		max := *typedInput.Max
		codeRange.Max = &max
	}

	// Set property "Min":
	if typedInput.Min != nil {
		min := *typedInput.Min
		codeRange.Min = &min
	}

	// No error
	return nil
}

// AssignProperties_From_FailureStatusCodeRange_STATUS populates our FailureStatusCodeRange_STATUS from the provided source FailureStatusCodeRange_STATUS
func (codeRange *FailureStatusCodeRange_STATUS) AssignProperties_From_FailureStatusCodeRange_STATUS(source *storage.FailureStatusCodeRange_STATUS) error {

	// Max
	codeRange.Max = genruntime.ClonePointerToInt(source.Max)

	// Min
	codeRange.Min = genruntime.ClonePointerToInt(source.Min)

	// No error
	return nil
}

// AssignProperties_To_FailureStatusCodeRange_STATUS populates the provided destination FailureStatusCodeRange_STATUS from our FailureStatusCodeRange_STATUS
func (codeRange *FailureStatusCodeRange_STATUS) AssignProperties_To_FailureStatusCodeRange_STATUS(destination *storage.FailureStatusCodeRange_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Max
	destination.Max = genruntime.ClonePointerToInt(codeRange.Max)

	// Min
	destination.Min = genruntime.ClonePointerToInt(codeRange.Min)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&Backend{}, &BackendList{})
}
