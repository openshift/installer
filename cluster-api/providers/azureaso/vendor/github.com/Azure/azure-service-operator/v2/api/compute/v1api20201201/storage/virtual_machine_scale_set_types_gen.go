// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package storage

import (
	"fmt"
	v20210701s "github.com/Azure/azure-service-operator/v2/api/compute/v1api20210701/storage"
	v20220301s "github.com/Azure/azure-service-operator/v2/api/compute/v1api20220301/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/pkg/errors"
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Storage version of v1api20201201.VirtualMachineScaleSet
// Generator information:
// - Generated from: /compute/resource-manager/Microsoft.Compute/ComputeRP/stable/2020-12-01/compute.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}
type VirtualMachineScaleSet struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              VirtualMachineScaleSet_Spec   `json:"spec,omitempty"`
	Status            VirtualMachineScaleSet_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &VirtualMachineScaleSet{}

// GetConditions returns the conditions of the resource
func (scaleSet *VirtualMachineScaleSet) GetConditions() conditions.Conditions {
	return scaleSet.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (scaleSet *VirtualMachineScaleSet) SetConditions(conditions conditions.Conditions) {
	scaleSet.Status.Conditions = conditions
}

var _ conversion.Convertible = &VirtualMachineScaleSet{}

// ConvertFrom populates our VirtualMachineScaleSet from the provided hub VirtualMachineScaleSet
func (scaleSet *VirtualMachineScaleSet) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v20220301s.VirtualMachineScaleSet)
	if !ok {
		return fmt.Errorf("expected compute/v1api20220301/storage/VirtualMachineScaleSet but received %T instead", hub)
	}

	return scaleSet.AssignProperties_From_VirtualMachineScaleSet(source)
}

// ConvertTo populates the provided hub VirtualMachineScaleSet from our VirtualMachineScaleSet
func (scaleSet *VirtualMachineScaleSet) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v20220301s.VirtualMachineScaleSet)
	if !ok {
		return fmt.Errorf("expected compute/v1api20220301/storage/VirtualMachineScaleSet but received %T instead", hub)
	}

	return scaleSet.AssignProperties_To_VirtualMachineScaleSet(destination)
}

var _ configmaps.Exporter = &VirtualMachineScaleSet{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (scaleSet *VirtualMachineScaleSet) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if scaleSet.Spec.OperatorSpec == nil {
		return nil
	}
	return scaleSet.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &VirtualMachineScaleSet{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (scaleSet *VirtualMachineScaleSet) SecretDestinationExpressions() []*core.DestinationExpression {
	if scaleSet.Spec.OperatorSpec == nil {
		return nil
	}
	return scaleSet.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.KubernetesResource = &VirtualMachineScaleSet{}

// AzureName returns the Azure name of the resource
func (scaleSet *VirtualMachineScaleSet) AzureName() string {
	return scaleSet.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2020-12-01"
func (scaleSet VirtualMachineScaleSet) GetAPIVersion() string {
	return "2020-12-01"
}

// GetResourceScope returns the scope of the resource
func (scaleSet *VirtualMachineScaleSet) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (scaleSet *VirtualMachineScaleSet) GetSpec() genruntime.ConvertibleSpec {
	return &scaleSet.Spec
}

// GetStatus returns the status of this resource
func (scaleSet *VirtualMachineScaleSet) GetStatus() genruntime.ConvertibleStatus {
	return &scaleSet.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (scaleSet *VirtualMachineScaleSet) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Compute/virtualMachineScaleSets"
func (scaleSet *VirtualMachineScaleSet) GetType() string {
	return "Microsoft.Compute/virtualMachineScaleSets"
}

// NewEmptyStatus returns a new empty (blank) status
func (scaleSet *VirtualMachineScaleSet) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &VirtualMachineScaleSet_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (scaleSet *VirtualMachineScaleSet) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(scaleSet.Spec)
	return scaleSet.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (scaleSet *VirtualMachineScaleSet) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*VirtualMachineScaleSet_STATUS); ok {
		scaleSet.Status = *st
		return nil
	}

	// Convert status to required version
	var st VirtualMachineScaleSet_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	scaleSet.Status = st
	return nil
}

// AssignProperties_From_VirtualMachineScaleSet populates our VirtualMachineScaleSet from the provided source VirtualMachineScaleSet
func (scaleSet *VirtualMachineScaleSet) AssignProperties_From_VirtualMachineScaleSet(source *v20220301s.VirtualMachineScaleSet) error {

	// ObjectMeta
	scaleSet.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec VirtualMachineScaleSet_Spec
	err := spec.AssignProperties_From_VirtualMachineScaleSet_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSet_Spec() to populate field Spec")
	}
	scaleSet.Spec = spec

	// Status
	var status VirtualMachineScaleSet_STATUS
	err = status.AssignProperties_From_VirtualMachineScaleSet_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSet_STATUS() to populate field Status")
	}
	scaleSet.Status = status

	// Invoke the augmentConversionForVirtualMachineScaleSet interface (if implemented) to customize the conversion
	var scaleSetAsAny any = scaleSet
	if augmentedScaleSet, ok := scaleSetAsAny.(augmentConversionForVirtualMachineScaleSet); ok {
		err := augmentedScaleSet.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSet populates the provided destination VirtualMachineScaleSet from our VirtualMachineScaleSet
func (scaleSet *VirtualMachineScaleSet) AssignProperties_To_VirtualMachineScaleSet(destination *v20220301s.VirtualMachineScaleSet) error {

	// ObjectMeta
	destination.ObjectMeta = *scaleSet.ObjectMeta.DeepCopy()

	// Spec
	var spec v20220301s.VirtualMachineScaleSet_Spec
	err := scaleSet.Spec.AssignProperties_To_VirtualMachineScaleSet_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSet_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v20220301s.VirtualMachineScaleSet_STATUS
	err = scaleSet.Status.AssignProperties_To_VirtualMachineScaleSet_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSet_STATUS() to populate field Status")
	}
	destination.Status = status

	// Invoke the augmentConversionForVirtualMachineScaleSet interface (if implemented) to customize the conversion
	var scaleSetAsAny any = scaleSet
	if augmentedScaleSet, ok := scaleSetAsAny.(augmentConversionForVirtualMachineScaleSet); ok {
		err := augmentedScaleSet.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (scaleSet *VirtualMachineScaleSet) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: scaleSet.Spec.OriginalVersion,
		Kind:    "VirtualMachineScaleSet",
	}
}

// +kubebuilder:object:root=true
// Storage version of v1api20201201.VirtualMachineScaleSet
// Generator information:
// - Generated from: /compute/resource-manager/Microsoft.Compute/ComputeRP/stable/2020-12-01/compute.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}
type VirtualMachineScaleSetList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []VirtualMachineScaleSet `json:"items"`
}

type augmentConversionForVirtualMachineScaleSet interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSet) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSet) error
}

// Storage version of v1api20201201.VirtualMachineScaleSet_Spec
type VirtualMachineScaleSet_Spec struct {
	AdditionalCapabilities *AdditionalCapabilities `json:"additionalCapabilities,omitempty"`
	AutomaticRepairsPolicy *AutomaticRepairsPolicy `json:"automaticRepairsPolicy,omitempty"`

	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName                              string                              `json:"azureName,omitempty"`
	DoNotRunExtensionsOnOverprovisionedVMs *bool                               `json:"doNotRunExtensionsOnOverprovisionedVMs,omitempty"`
	ExtendedLocation                       *ExtendedLocation                   `json:"extendedLocation,omitempty"`
	HostGroup                              *SubResource                        `json:"hostGroup,omitempty"`
	Identity                               *VirtualMachineScaleSetIdentity     `json:"identity,omitempty"`
	Location                               *string                             `json:"location,omitempty"`
	OperatorSpec                           *VirtualMachineScaleSetOperatorSpec `json:"operatorSpec,omitempty"`
	OrchestrationMode                      *string                             `json:"orchestrationMode,omitempty"`
	OriginalVersion                        string                              `json:"originalVersion,omitempty"`
	Overprovision                          *bool                               `json:"overprovision,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner                    *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`
	Plan                     *Plan                              `json:"plan,omitempty"`
	PlatformFaultDomainCount *int                               `json:"platformFaultDomainCount,omitempty"`
	PropertyBag              genruntime.PropertyBag             `json:"$propertyBag,omitempty"`
	ProximityPlacementGroup  *SubResource                       `json:"proximityPlacementGroup,omitempty"`
	ScaleInPolicy            *ScaleInPolicy                     `json:"scaleInPolicy,omitempty"`
	SinglePlacementGroup     *bool                              `json:"singlePlacementGroup,omitempty"`
	Sku                      *Sku                               `json:"sku,omitempty"`
	Tags                     map[string]string                  `json:"tags,omitempty"`
	UpgradePolicy            *UpgradePolicy                     `json:"upgradePolicy,omitempty"`
	VirtualMachineProfile    *VirtualMachineScaleSetVMProfile   `json:"virtualMachineProfile,omitempty"`
	ZoneBalance              *bool                              `json:"zoneBalance,omitempty"`
	Zones                    []string                           `json:"zones,omitempty"`
}

var _ genruntime.ConvertibleSpec = &VirtualMachineScaleSet_Spec{}

// ConvertSpecFrom populates our VirtualMachineScaleSet_Spec from the provided source
func (scaleSet *VirtualMachineScaleSet_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v20220301s.VirtualMachineScaleSet_Spec)
	if ok {
		// Populate our instance from source
		return scaleSet.AssignProperties_From_VirtualMachineScaleSet_Spec(src)
	}

	// Convert to an intermediate form
	src = &v20220301s.VirtualMachineScaleSet_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = scaleSet.AssignProperties_From_VirtualMachineScaleSet_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our VirtualMachineScaleSet_Spec
func (scaleSet *VirtualMachineScaleSet_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v20220301s.VirtualMachineScaleSet_Spec)
	if ok {
		// Populate destination from our instance
		return scaleSet.AssignProperties_To_VirtualMachineScaleSet_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &v20220301s.VirtualMachineScaleSet_Spec{}
	err := scaleSet.AssignProperties_To_VirtualMachineScaleSet_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_VirtualMachineScaleSet_Spec populates our VirtualMachineScaleSet_Spec from the provided source VirtualMachineScaleSet_Spec
func (scaleSet *VirtualMachineScaleSet_Spec) AssignProperties_From_VirtualMachineScaleSet_Spec(source *v20220301s.VirtualMachineScaleSet_Spec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdditionalCapabilities
	if source.AdditionalCapabilities != nil {
		var additionalCapability AdditionalCapabilities
		err := additionalCapability.AssignProperties_From_AdditionalCapabilities(source.AdditionalCapabilities)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AdditionalCapabilities() to populate field AdditionalCapabilities")
		}
		scaleSet.AdditionalCapabilities = &additionalCapability
	} else {
		scaleSet.AdditionalCapabilities = nil
	}

	// AutomaticRepairsPolicy
	if source.AutomaticRepairsPolicy != nil {
		var automaticRepairsPolicy AutomaticRepairsPolicy
		err := automaticRepairsPolicy.AssignProperties_From_AutomaticRepairsPolicy(source.AutomaticRepairsPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AutomaticRepairsPolicy() to populate field AutomaticRepairsPolicy")
		}
		scaleSet.AutomaticRepairsPolicy = &automaticRepairsPolicy
	} else {
		scaleSet.AutomaticRepairsPolicy = nil
	}

	// AzureName
	scaleSet.AzureName = source.AzureName

	// DoNotRunExtensionsOnOverprovisionedVMs
	if source.DoNotRunExtensionsOnOverprovisionedVMs != nil {
		doNotRunExtensionsOnOverprovisionedVM := *source.DoNotRunExtensionsOnOverprovisionedVMs
		scaleSet.DoNotRunExtensionsOnOverprovisionedVMs = &doNotRunExtensionsOnOverprovisionedVM
	} else {
		scaleSet.DoNotRunExtensionsOnOverprovisionedVMs = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocationStash v20210701s.ExtendedLocation
		err := extendedLocationStash.AssignProperties_From_ExtendedLocation(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ExtendedLocation() to populate field ExtendedLocationStash from ExtendedLocation")
		}
		var extendedLocation ExtendedLocation
		err = extendedLocation.AssignProperties_From_ExtendedLocation(&extendedLocationStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ExtendedLocation() to populate field ExtendedLocation from ExtendedLocationStash")
		}
		scaleSet.ExtendedLocation = &extendedLocation
	} else {
		scaleSet.ExtendedLocation = nil
	}

	// HostGroup
	if source.HostGroup != nil {
		var subResourceStash v20210701s.SubResource
		err := subResourceStash.AssignProperties_From_SubResource(source.HostGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from HostGroup")
		}
		var hostGroup SubResource
		err = hostGroup.AssignProperties_From_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field HostGroup from SubResourceStash")
		}
		scaleSet.HostGroup = &hostGroup
	} else {
		scaleSet.HostGroup = nil
	}

	// Identity
	if source.Identity != nil {
		var identity VirtualMachineScaleSetIdentity
		err := identity.AssignProperties_From_VirtualMachineScaleSetIdentity(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetIdentity() to populate field Identity")
		}
		scaleSet.Identity = &identity
	} else {
		scaleSet.Identity = nil
	}

	// Location
	scaleSet.Location = genruntime.ClonePointerToString(source.Location)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec VirtualMachineScaleSetOperatorSpec
		err := operatorSpec.AssignProperties_From_VirtualMachineScaleSetOperatorSpec(source.OperatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetOperatorSpec() to populate field OperatorSpec")
		}
		scaleSet.OperatorSpec = &operatorSpec
	} else {
		scaleSet.OperatorSpec = nil
	}

	// OrchestrationMode
	scaleSet.OrchestrationMode = genruntime.ClonePointerToString(source.OrchestrationMode)

	// OriginalVersion
	scaleSet.OriginalVersion = source.OriginalVersion

	// Overprovision
	if source.Overprovision != nil {
		overprovision := *source.Overprovision
		scaleSet.Overprovision = &overprovision
	} else {
		scaleSet.Overprovision = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		scaleSet.Owner = &owner
	} else {
		scaleSet.Owner = nil
	}

	// Plan
	if source.Plan != nil {
		var plan Plan
		err := plan.AssignProperties_From_Plan(source.Plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Plan() to populate field Plan")
		}
		scaleSet.Plan = &plan
	} else {
		scaleSet.Plan = nil
	}

	// PlatformFaultDomainCount
	scaleSet.PlatformFaultDomainCount = genruntime.ClonePointerToInt(source.PlatformFaultDomainCount)

	// ProximityPlacementGroup
	if source.ProximityPlacementGroup != nil {
		var subResourceStash v20210701s.SubResource
		err := subResourceStash.AssignProperties_From_SubResource(source.ProximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from ProximityPlacementGroup")
		}
		var proximityPlacementGroup SubResource
		err = proximityPlacementGroup.AssignProperties_From_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field ProximityPlacementGroup from SubResourceStash")
		}
		scaleSet.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		scaleSet.ProximityPlacementGroup = nil
	}

	// ScaleInPolicy
	if source.ScaleInPolicy != nil {
		var scaleInPolicy ScaleInPolicy
		err := scaleInPolicy.AssignProperties_From_ScaleInPolicy(source.ScaleInPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ScaleInPolicy() to populate field ScaleInPolicy")
		}
		scaleSet.ScaleInPolicy = &scaleInPolicy
	} else {
		scaleSet.ScaleInPolicy = nil
	}

	// SinglePlacementGroup
	if source.SinglePlacementGroup != nil {
		singlePlacementGroup := *source.SinglePlacementGroup
		scaleSet.SinglePlacementGroup = &singlePlacementGroup
	} else {
		scaleSet.SinglePlacementGroup = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.AssignProperties_From_Sku(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Sku() to populate field Sku")
		}
		scaleSet.Sku = &sku
	} else {
		scaleSet.Sku = nil
	}

	// SpotRestorePolicy
	if source.SpotRestorePolicy != nil {
		propertyBag.Add("SpotRestorePolicy", *source.SpotRestorePolicy)
	} else {
		propertyBag.Remove("SpotRestorePolicy")
	}

	// Tags
	scaleSet.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// UpgradePolicy
	if source.UpgradePolicy != nil {
		var upgradePolicy UpgradePolicy
		err := upgradePolicy.AssignProperties_From_UpgradePolicy(source.UpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UpgradePolicy() to populate field UpgradePolicy")
		}
		scaleSet.UpgradePolicy = &upgradePolicy
	} else {
		scaleSet.UpgradePolicy = nil
	}

	// VirtualMachineProfile
	if source.VirtualMachineProfile != nil {
		var virtualMachineProfile VirtualMachineScaleSetVMProfile
		err := virtualMachineProfile.AssignProperties_From_VirtualMachineScaleSetVMProfile(source.VirtualMachineProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetVMProfile() to populate field VirtualMachineProfile")
		}
		scaleSet.VirtualMachineProfile = &virtualMachineProfile
	} else {
		scaleSet.VirtualMachineProfile = nil
	}

	// ZoneBalance
	if source.ZoneBalance != nil {
		zoneBalance := *source.ZoneBalance
		scaleSet.ZoneBalance = &zoneBalance
	} else {
		scaleSet.ZoneBalance = nil
	}

	// Zones
	scaleSet.Zones = genruntime.CloneSliceOfString(source.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		scaleSet.PropertyBag = propertyBag
	} else {
		scaleSet.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSet_Spec interface (if implemented) to customize the conversion
	var scaleSetAsAny any = scaleSet
	if augmentedScaleSet, ok := scaleSetAsAny.(augmentConversionForVirtualMachineScaleSet_Spec); ok {
		err := augmentedScaleSet.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSet_Spec populates the provided destination VirtualMachineScaleSet_Spec from our VirtualMachineScaleSet_Spec
func (scaleSet *VirtualMachineScaleSet_Spec) AssignProperties_To_VirtualMachineScaleSet_Spec(destination *v20220301s.VirtualMachineScaleSet_Spec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(scaleSet.PropertyBag)

	// AdditionalCapabilities
	if scaleSet.AdditionalCapabilities != nil {
		var additionalCapability v20220301s.AdditionalCapabilities
		err := scaleSet.AdditionalCapabilities.AssignProperties_To_AdditionalCapabilities(&additionalCapability)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AdditionalCapabilities() to populate field AdditionalCapabilities")
		}
		destination.AdditionalCapabilities = &additionalCapability
	} else {
		destination.AdditionalCapabilities = nil
	}

	// AutomaticRepairsPolicy
	if scaleSet.AutomaticRepairsPolicy != nil {
		var automaticRepairsPolicy v20220301s.AutomaticRepairsPolicy
		err := scaleSet.AutomaticRepairsPolicy.AssignProperties_To_AutomaticRepairsPolicy(&automaticRepairsPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AutomaticRepairsPolicy() to populate field AutomaticRepairsPolicy")
		}
		destination.AutomaticRepairsPolicy = &automaticRepairsPolicy
	} else {
		destination.AutomaticRepairsPolicy = nil
	}

	// AzureName
	destination.AzureName = scaleSet.AzureName

	// DoNotRunExtensionsOnOverprovisionedVMs
	if scaleSet.DoNotRunExtensionsOnOverprovisionedVMs != nil {
		doNotRunExtensionsOnOverprovisionedVM := *scaleSet.DoNotRunExtensionsOnOverprovisionedVMs
		destination.DoNotRunExtensionsOnOverprovisionedVMs = &doNotRunExtensionsOnOverprovisionedVM
	} else {
		destination.DoNotRunExtensionsOnOverprovisionedVMs = nil
	}

	// ExtendedLocation
	if scaleSet.ExtendedLocation != nil {
		var extendedLocationStash v20210701s.ExtendedLocation
		err := scaleSet.ExtendedLocation.AssignProperties_To_ExtendedLocation(&extendedLocationStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ExtendedLocation() to populate field ExtendedLocationStash from ExtendedLocation")
		}
		var extendedLocation v20220301s.ExtendedLocation
		err = extendedLocationStash.AssignProperties_To_ExtendedLocation(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ExtendedLocation() to populate field ExtendedLocation from ExtendedLocationStash")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// HostGroup
	if scaleSet.HostGroup != nil {
		var subResourceStash v20210701s.SubResource
		err := scaleSet.HostGroup.AssignProperties_To_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from HostGroup")
		}
		var hostGroup v20220301s.SubResource
		err = subResourceStash.AssignProperties_To_SubResource(&hostGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field HostGroup from SubResourceStash")
		}
		destination.HostGroup = &hostGroup
	} else {
		destination.HostGroup = nil
	}

	// Identity
	if scaleSet.Identity != nil {
		var identity v20220301s.VirtualMachineScaleSetIdentity
		err := scaleSet.Identity.AssignProperties_To_VirtualMachineScaleSetIdentity(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(scaleSet.Location)

	// OperatorSpec
	if scaleSet.OperatorSpec != nil {
		var operatorSpec v20220301s.VirtualMachineScaleSetOperatorSpec
		err := scaleSet.OperatorSpec.AssignProperties_To_VirtualMachineScaleSetOperatorSpec(&operatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OrchestrationMode
	destination.OrchestrationMode = genruntime.ClonePointerToString(scaleSet.OrchestrationMode)

	// OriginalVersion
	destination.OriginalVersion = scaleSet.OriginalVersion

	// Overprovision
	if scaleSet.Overprovision != nil {
		overprovision := *scaleSet.Overprovision
		destination.Overprovision = &overprovision
	} else {
		destination.Overprovision = nil
	}

	// Owner
	if scaleSet.Owner != nil {
		owner := scaleSet.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Plan
	if scaleSet.Plan != nil {
		var plan v20220301s.Plan
		err := scaleSet.Plan.AssignProperties_To_Plan(&plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Plan() to populate field Plan")
		}
		destination.Plan = &plan
	} else {
		destination.Plan = nil
	}

	// PlatformFaultDomainCount
	destination.PlatformFaultDomainCount = genruntime.ClonePointerToInt(scaleSet.PlatformFaultDomainCount)

	// ProximityPlacementGroup
	if scaleSet.ProximityPlacementGroup != nil {
		var subResourceStash v20210701s.SubResource
		err := scaleSet.ProximityPlacementGroup.AssignProperties_To_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from ProximityPlacementGroup")
		}
		var proximityPlacementGroup v20220301s.SubResource
		err = subResourceStash.AssignProperties_To_SubResource(&proximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field ProximityPlacementGroup from SubResourceStash")
		}
		destination.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		destination.ProximityPlacementGroup = nil
	}

	// ScaleInPolicy
	if scaleSet.ScaleInPolicy != nil {
		var scaleInPolicy v20220301s.ScaleInPolicy
		err := scaleSet.ScaleInPolicy.AssignProperties_To_ScaleInPolicy(&scaleInPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ScaleInPolicy() to populate field ScaleInPolicy")
		}
		destination.ScaleInPolicy = &scaleInPolicy
	} else {
		destination.ScaleInPolicy = nil
	}

	// SinglePlacementGroup
	if scaleSet.SinglePlacementGroup != nil {
		singlePlacementGroup := *scaleSet.SinglePlacementGroup
		destination.SinglePlacementGroup = &singlePlacementGroup
	} else {
		destination.SinglePlacementGroup = nil
	}

	// Sku
	if scaleSet.Sku != nil {
		var sku v20220301s.Sku
		err := scaleSet.Sku.AssignProperties_To_Sku(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Sku() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// SpotRestorePolicy
	if propertyBag.Contains("SpotRestorePolicy") {
		var spotRestorePolicy v20220301s.SpotRestorePolicy
		err := propertyBag.Pull("SpotRestorePolicy", &spotRestorePolicy)
		if err != nil {
			return errors.Wrap(err, "pulling 'SpotRestorePolicy' from propertyBag")
		}

		destination.SpotRestorePolicy = &spotRestorePolicy
	} else {
		destination.SpotRestorePolicy = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(scaleSet.Tags)

	// UpgradePolicy
	if scaleSet.UpgradePolicy != nil {
		var upgradePolicy v20220301s.UpgradePolicy
		err := scaleSet.UpgradePolicy.AssignProperties_To_UpgradePolicy(&upgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UpgradePolicy() to populate field UpgradePolicy")
		}
		destination.UpgradePolicy = &upgradePolicy
	} else {
		destination.UpgradePolicy = nil
	}

	// VirtualMachineProfile
	if scaleSet.VirtualMachineProfile != nil {
		var virtualMachineProfile v20220301s.VirtualMachineScaleSetVMProfile
		err := scaleSet.VirtualMachineProfile.AssignProperties_To_VirtualMachineScaleSetVMProfile(&virtualMachineProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetVMProfile() to populate field VirtualMachineProfile")
		}
		destination.VirtualMachineProfile = &virtualMachineProfile
	} else {
		destination.VirtualMachineProfile = nil
	}

	// ZoneBalance
	if scaleSet.ZoneBalance != nil {
		zoneBalance := *scaleSet.ZoneBalance
		destination.ZoneBalance = &zoneBalance
	} else {
		destination.ZoneBalance = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(scaleSet.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSet_Spec interface (if implemented) to customize the conversion
	var scaleSetAsAny any = scaleSet
	if augmentedScaleSet, ok := scaleSetAsAny.(augmentConversionForVirtualMachineScaleSet_Spec); ok {
		err := augmentedScaleSet.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineScaleSet_STATUS
// Describes a Virtual Machine Scale Set.
type VirtualMachineScaleSet_STATUS struct {
	AdditionalCapabilities                 *AdditionalCapabilities_STATUS          `json:"additionalCapabilities,omitempty"`
	AutomaticRepairsPolicy                 *AutomaticRepairsPolicy_STATUS          `json:"automaticRepairsPolicy,omitempty"`
	Conditions                             []conditions.Condition                  `json:"conditions,omitempty"`
	DoNotRunExtensionsOnOverprovisionedVMs *bool                                   `json:"doNotRunExtensionsOnOverprovisionedVMs,omitempty"`
	ExtendedLocation                       *ExtendedLocation_STATUS                `json:"extendedLocation,omitempty"`
	HostGroup                              *SubResource_STATUS                     `json:"hostGroup,omitempty"`
	Id                                     *string                                 `json:"id,omitempty"`
	Identity                               *VirtualMachineScaleSetIdentity_STATUS  `json:"identity,omitempty"`
	Location                               *string                                 `json:"location,omitempty"`
	Name                                   *string                                 `json:"name,omitempty"`
	OrchestrationMode                      *string                                 `json:"orchestrationMode,omitempty"`
	Overprovision                          *bool                                   `json:"overprovision,omitempty"`
	Plan                                   *Plan_STATUS                            `json:"plan,omitempty"`
	PlatformFaultDomainCount               *int                                    `json:"platformFaultDomainCount,omitempty"`
	PropertyBag                            genruntime.PropertyBag                  `json:"$propertyBag,omitempty"`
	ProvisioningState                      *string                                 `json:"provisioningState,omitempty"`
	ProximityPlacementGroup                *SubResource_STATUS                     `json:"proximityPlacementGroup,omitempty"`
	ScaleInPolicy                          *ScaleInPolicy_STATUS                   `json:"scaleInPolicy,omitempty"`
	SinglePlacementGroup                   *bool                                   `json:"singlePlacementGroup,omitempty"`
	Sku                                    *Sku_STATUS                             `json:"sku,omitempty"`
	Tags                                   map[string]string                       `json:"tags,omitempty"`
	Type                                   *string                                 `json:"type,omitempty"`
	UniqueId                               *string                                 `json:"uniqueId,omitempty"`
	UpgradePolicy                          *UpgradePolicy_STATUS                   `json:"upgradePolicy,omitempty"`
	VirtualMachineProfile                  *VirtualMachineScaleSetVMProfile_STATUS `json:"virtualMachineProfile,omitempty"`
	ZoneBalance                            *bool                                   `json:"zoneBalance,omitempty"`
	Zones                                  []string                                `json:"zones,omitempty"`
}

var _ genruntime.ConvertibleStatus = &VirtualMachineScaleSet_STATUS{}

// ConvertStatusFrom populates our VirtualMachineScaleSet_STATUS from the provided source
func (scaleSet *VirtualMachineScaleSet_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v20220301s.VirtualMachineScaleSet_STATUS)
	if ok {
		// Populate our instance from source
		return scaleSet.AssignProperties_From_VirtualMachineScaleSet_STATUS(src)
	}

	// Convert to an intermediate form
	src = &v20220301s.VirtualMachineScaleSet_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = scaleSet.AssignProperties_From_VirtualMachineScaleSet_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our VirtualMachineScaleSet_STATUS
func (scaleSet *VirtualMachineScaleSet_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v20220301s.VirtualMachineScaleSet_STATUS)
	if ok {
		// Populate destination from our instance
		return scaleSet.AssignProperties_To_VirtualMachineScaleSet_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &v20220301s.VirtualMachineScaleSet_STATUS{}
	err := scaleSet.AssignProperties_To_VirtualMachineScaleSet_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

// AssignProperties_From_VirtualMachineScaleSet_STATUS populates our VirtualMachineScaleSet_STATUS from the provided source VirtualMachineScaleSet_STATUS
func (scaleSet *VirtualMachineScaleSet_STATUS) AssignProperties_From_VirtualMachineScaleSet_STATUS(source *v20220301s.VirtualMachineScaleSet_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdditionalCapabilities
	if source.AdditionalCapabilities != nil {
		var additionalCapability AdditionalCapabilities_STATUS
		err := additionalCapability.AssignProperties_From_AdditionalCapabilities_STATUS(source.AdditionalCapabilities)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AdditionalCapabilities_STATUS() to populate field AdditionalCapabilities")
		}
		scaleSet.AdditionalCapabilities = &additionalCapability
	} else {
		scaleSet.AdditionalCapabilities = nil
	}

	// AutomaticRepairsPolicy
	if source.AutomaticRepairsPolicy != nil {
		var automaticRepairsPolicy AutomaticRepairsPolicy_STATUS
		err := automaticRepairsPolicy.AssignProperties_From_AutomaticRepairsPolicy_STATUS(source.AutomaticRepairsPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AutomaticRepairsPolicy_STATUS() to populate field AutomaticRepairsPolicy")
		}
		scaleSet.AutomaticRepairsPolicy = &automaticRepairsPolicy
	} else {
		scaleSet.AutomaticRepairsPolicy = nil
	}

	// Conditions
	scaleSet.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// DoNotRunExtensionsOnOverprovisionedVMs
	if source.DoNotRunExtensionsOnOverprovisionedVMs != nil {
		doNotRunExtensionsOnOverprovisionedVM := *source.DoNotRunExtensionsOnOverprovisionedVMs
		scaleSet.DoNotRunExtensionsOnOverprovisionedVMs = &doNotRunExtensionsOnOverprovisionedVM
	} else {
		scaleSet.DoNotRunExtensionsOnOverprovisionedVMs = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocationSTATUSStash v20210701s.ExtendedLocation_STATUS
		err := extendedLocationSTATUSStash.AssignProperties_From_ExtendedLocation_STATUS(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ExtendedLocation_STATUS() to populate field ExtendedLocation_STATUSStash from ExtendedLocation")
		}
		var extendedLocation ExtendedLocation_STATUS
		err = extendedLocation.AssignProperties_From_ExtendedLocation_STATUS(&extendedLocationSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ExtendedLocation_STATUS() to populate field ExtendedLocation from ExtendedLocation_STATUSStash")
		}
		scaleSet.ExtendedLocation = &extendedLocation
	} else {
		scaleSet.ExtendedLocation = nil
	}

	// HostGroup
	if source.HostGroup != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(source.HostGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from HostGroup")
		}
		var hostGroup SubResource_STATUS
		err = hostGroup.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field HostGroup from SubResource_STATUSStash")
		}
		scaleSet.HostGroup = &hostGroup
	} else {
		scaleSet.HostGroup = nil
	}

	// Id
	scaleSet.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity VirtualMachineScaleSetIdentity_STATUS
		err := identity.AssignProperties_From_VirtualMachineScaleSetIdentity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetIdentity_STATUS() to populate field Identity")
		}
		scaleSet.Identity = &identity
	} else {
		scaleSet.Identity = nil
	}

	// Location
	scaleSet.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	scaleSet.Name = genruntime.ClonePointerToString(source.Name)

	// OrchestrationMode
	scaleSet.OrchestrationMode = genruntime.ClonePointerToString(source.OrchestrationMode)

	// Overprovision
	if source.Overprovision != nil {
		overprovision := *source.Overprovision
		scaleSet.Overprovision = &overprovision
	} else {
		scaleSet.Overprovision = nil
	}

	// Plan
	if source.Plan != nil {
		var plan Plan_STATUS
		err := plan.AssignProperties_From_Plan_STATUS(source.Plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Plan_STATUS() to populate field Plan")
		}
		scaleSet.Plan = &plan
	} else {
		scaleSet.Plan = nil
	}

	// PlatformFaultDomainCount
	scaleSet.PlatformFaultDomainCount = genruntime.ClonePointerToInt(source.PlatformFaultDomainCount)

	// ProvisioningState
	scaleSet.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// ProximityPlacementGroup
	if source.ProximityPlacementGroup != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(source.ProximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from ProximityPlacementGroup")
		}
		var proximityPlacementGroup SubResource_STATUS
		err = proximityPlacementGroup.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field ProximityPlacementGroup from SubResource_STATUSStash")
		}
		scaleSet.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		scaleSet.ProximityPlacementGroup = nil
	}

	// ScaleInPolicy
	if source.ScaleInPolicy != nil {
		var scaleInPolicy ScaleInPolicy_STATUS
		err := scaleInPolicy.AssignProperties_From_ScaleInPolicy_STATUS(source.ScaleInPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ScaleInPolicy_STATUS() to populate field ScaleInPolicy")
		}
		scaleSet.ScaleInPolicy = &scaleInPolicy
	} else {
		scaleSet.ScaleInPolicy = nil
	}

	// SinglePlacementGroup
	if source.SinglePlacementGroup != nil {
		singlePlacementGroup := *source.SinglePlacementGroup
		scaleSet.SinglePlacementGroup = &singlePlacementGroup
	} else {
		scaleSet.SinglePlacementGroup = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku_STATUS
		err := sku.AssignProperties_From_Sku_STATUS(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Sku_STATUS() to populate field Sku")
		}
		scaleSet.Sku = &sku
	} else {
		scaleSet.Sku = nil
	}

	// SpotRestorePolicy
	if source.SpotRestorePolicy != nil {
		propertyBag.Add("SpotRestorePolicy", *source.SpotRestorePolicy)
	} else {
		propertyBag.Remove("SpotRestorePolicy")
	}

	// Tags
	scaleSet.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// TimeCreated
	if source.TimeCreated != nil {
		propertyBag.Add("TimeCreated", *source.TimeCreated)
	} else {
		propertyBag.Remove("TimeCreated")
	}

	// Type
	scaleSet.Type = genruntime.ClonePointerToString(source.Type)

	// UniqueId
	scaleSet.UniqueId = genruntime.ClonePointerToString(source.UniqueId)

	// UpgradePolicy
	if source.UpgradePolicy != nil {
		var upgradePolicy UpgradePolicy_STATUS
		err := upgradePolicy.AssignProperties_From_UpgradePolicy_STATUS(source.UpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UpgradePolicy_STATUS() to populate field UpgradePolicy")
		}
		scaleSet.UpgradePolicy = &upgradePolicy
	} else {
		scaleSet.UpgradePolicy = nil
	}

	// VirtualMachineProfile
	if source.VirtualMachineProfile != nil {
		var virtualMachineProfile VirtualMachineScaleSetVMProfile_STATUS
		err := virtualMachineProfile.AssignProperties_From_VirtualMachineScaleSetVMProfile_STATUS(source.VirtualMachineProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetVMProfile_STATUS() to populate field VirtualMachineProfile")
		}
		scaleSet.VirtualMachineProfile = &virtualMachineProfile
	} else {
		scaleSet.VirtualMachineProfile = nil
	}

	// ZoneBalance
	if source.ZoneBalance != nil {
		zoneBalance := *source.ZoneBalance
		scaleSet.ZoneBalance = &zoneBalance
	} else {
		scaleSet.ZoneBalance = nil
	}

	// Zones
	scaleSet.Zones = genruntime.CloneSliceOfString(source.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		scaleSet.PropertyBag = propertyBag
	} else {
		scaleSet.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSet_STATUS interface (if implemented) to customize the conversion
	var scaleSetAsAny any = scaleSet
	if augmentedScaleSet, ok := scaleSetAsAny.(augmentConversionForVirtualMachineScaleSet_STATUS); ok {
		err := augmentedScaleSet.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSet_STATUS populates the provided destination VirtualMachineScaleSet_STATUS from our VirtualMachineScaleSet_STATUS
func (scaleSet *VirtualMachineScaleSet_STATUS) AssignProperties_To_VirtualMachineScaleSet_STATUS(destination *v20220301s.VirtualMachineScaleSet_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(scaleSet.PropertyBag)

	// AdditionalCapabilities
	if scaleSet.AdditionalCapabilities != nil {
		var additionalCapability v20220301s.AdditionalCapabilities_STATUS
		err := scaleSet.AdditionalCapabilities.AssignProperties_To_AdditionalCapabilities_STATUS(&additionalCapability)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AdditionalCapabilities_STATUS() to populate field AdditionalCapabilities")
		}
		destination.AdditionalCapabilities = &additionalCapability
	} else {
		destination.AdditionalCapabilities = nil
	}

	// AutomaticRepairsPolicy
	if scaleSet.AutomaticRepairsPolicy != nil {
		var automaticRepairsPolicy v20220301s.AutomaticRepairsPolicy_STATUS
		err := scaleSet.AutomaticRepairsPolicy.AssignProperties_To_AutomaticRepairsPolicy_STATUS(&automaticRepairsPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AutomaticRepairsPolicy_STATUS() to populate field AutomaticRepairsPolicy")
		}
		destination.AutomaticRepairsPolicy = &automaticRepairsPolicy
	} else {
		destination.AutomaticRepairsPolicy = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(scaleSet.Conditions)

	// DoNotRunExtensionsOnOverprovisionedVMs
	if scaleSet.DoNotRunExtensionsOnOverprovisionedVMs != nil {
		doNotRunExtensionsOnOverprovisionedVM := *scaleSet.DoNotRunExtensionsOnOverprovisionedVMs
		destination.DoNotRunExtensionsOnOverprovisionedVMs = &doNotRunExtensionsOnOverprovisionedVM
	} else {
		destination.DoNotRunExtensionsOnOverprovisionedVMs = nil
	}

	// ExtendedLocation
	if scaleSet.ExtendedLocation != nil {
		var extendedLocationSTATUSStash v20210701s.ExtendedLocation_STATUS
		err := scaleSet.ExtendedLocation.AssignProperties_To_ExtendedLocation_STATUS(&extendedLocationSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ExtendedLocation_STATUS() to populate field ExtendedLocation_STATUSStash from ExtendedLocation")
		}
		var extendedLocation v20220301s.ExtendedLocation_STATUS
		err = extendedLocationSTATUSStash.AssignProperties_To_ExtendedLocation_STATUS(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ExtendedLocation_STATUS() to populate field ExtendedLocation from ExtendedLocation_STATUSStash")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// HostGroup
	if scaleSet.HostGroup != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := scaleSet.HostGroup.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from HostGroup")
		}
		var hostGroup v20220301s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&hostGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field HostGroup from SubResource_STATUSStash")
		}
		destination.HostGroup = &hostGroup
	} else {
		destination.HostGroup = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(scaleSet.Id)

	// Identity
	if scaleSet.Identity != nil {
		var identity v20220301s.VirtualMachineScaleSetIdentity_STATUS
		err := scaleSet.Identity.AssignProperties_To_VirtualMachineScaleSetIdentity_STATUS(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(scaleSet.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(scaleSet.Name)

	// OrchestrationMode
	destination.OrchestrationMode = genruntime.ClonePointerToString(scaleSet.OrchestrationMode)

	// Overprovision
	if scaleSet.Overprovision != nil {
		overprovision := *scaleSet.Overprovision
		destination.Overprovision = &overprovision
	} else {
		destination.Overprovision = nil
	}

	// Plan
	if scaleSet.Plan != nil {
		var plan v20220301s.Plan_STATUS
		err := scaleSet.Plan.AssignProperties_To_Plan_STATUS(&plan)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Plan_STATUS() to populate field Plan")
		}
		destination.Plan = &plan
	} else {
		destination.Plan = nil
	}

	// PlatformFaultDomainCount
	destination.PlatformFaultDomainCount = genruntime.ClonePointerToInt(scaleSet.PlatformFaultDomainCount)

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(scaleSet.ProvisioningState)

	// ProximityPlacementGroup
	if scaleSet.ProximityPlacementGroup != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := scaleSet.ProximityPlacementGroup.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from ProximityPlacementGroup")
		}
		var proximityPlacementGroup v20220301s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&proximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field ProximityPlacementGroup from SubResource_STATUSStash")
		}
		destination.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		destination.ProximityPlacementGroup = nil
	}

	// ScaleInPolicy
	if scaleSet.ScaleInPolicy != nil {
		var scaleInPolicy v20220301s.ScaleInPolicy_STATUS
		err := scaleSet.ScaleInPolicy.AssignProperties_To_ScaleInPolicy_STATUS(&scaleInPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ScaleInPolicy_STATUS() to populate field ScaleInPolicy")
		}
		destination.ScaleInPolicy = &scaleInPolicy
	} else {
		destination.ScaleInPolicy = nil
	}

	// SinglePlacementGroup
	if scaleSet.SinglePlacementGroup != nil {
		singlePlacementGroup := *scaleSet.SinglePlacementGroup
		destination.SinglePlacementGroup = &singlePlacementGroup
	} else {
		destination.SinglePlacementGroup = nil
	}

	// Sku
	if scaleSet.Sku != nil {
		var sku v20220301s.Sku_STATUS
		err := scaleSet.Sku.AssignProperties_To_Sku_STATUS(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Sku_STATUS() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// SpotRestorePolicy
	if propertyBag.Contains("SpotRestorePolicy") {
		var spotRestorePolicy v20220301s.SpotRestorePolicy_STATUS
		err := propertyBag.Pull("SpotRestorePolicy", &spotRestorePolicy)
		if err != nil {
			return errors.Wrap(err, "pulling 'SpotRestorePolicy' from propertyBag")
		}

		destination.SpotRestorePolicy = &spotRestorePolicy
	} else {
		destination.SpotRestorePolicy = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(scaleSet.Tags)

	// TimeCreated
	if propertyBag.Contains("TimeCreated") {
		var timeCreated string
		err := propertyBag.Pull("TimeCreated", &timeCreated)
		if err != nil {
			return errors.Wrap(err, "pulling 'TimeCreated' from propertyBag")
		}

		destination.TimeCreated = &timeCreated
	} else {
		destination.TimeCreated = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(scaleSet.Type)

	// UniqueId
	destination.UniqueId = genruntime.ClonePointerToString(scaleSet.UniqueId)

	// UpgradePolicy
	if scaleSet.UpgradePolicy != nil {
		var upgradePolicy v20220301s.UpgradePolicy_STATUS
		err := scaleSet.UpgradePolicy.AssignProperties_To_UpgradePolicy_STATUS(&upgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UpgradePolicy_STATUS() to populate field UpgradePolicy")
		}
		destination.UpgradePolicy = &upgradePolicy
	} else {
		destination.UpgradePolicy = nil
	}

	// VirtualMachineProfile
	if scaleSet.VirtualMachineProfile != nil {
		var virtualMachineProfile v20220301s.VirtualMachineScaleSetVMProfile_STATUS
		err := scaleSet.VirtualMachineProfile.AssignProperties_To_VirtualMachineScaleSetVMProfile_STATUS(&virtualMachineProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetVMProfile_STATUS() to populate field VirtualMachineProfile")
		}
		destination.VirtualMachineProfile = &virtualMachineProfile
	} else {
		destination.VirtualMachineProfile = nil
	}

	// ZoneBalance
	if scaleSet.ZoneBalance != nil {
		zoneBalance := *scaleSet.ZoneBalance
		destination.ZoneBalance = &zoneBalance
	} else {
		destination.ZoneBalance = nil
	}

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(scaleSet.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSet_STATUS interface (if implemented) to customize the conversion
	var scaleSetAsAny any = scaleSet
	if augmentedScaleSet, ok := scaleSetAsAny.(augmentConversionForVirtualMachineScaleSet_STATUS); ok {
		err := augmentedScaleSet.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForVirtualMachineScaleSet_Spec interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSet_Spec) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSet_Spec) error
}

type augmentConversionForVirtualMachineScaleSet_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSet_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSet_STATUS) error
}

// Storage version of v1api20201201.AutomaticRepairsPolicy
// Specifies the configuration parameters for automatic repairs on the virtual machine scale set.
type AutomaticRepairsPolicy struct {
	Enabled     *bool                  `json:"enabled,omitempty"`
	GracePeriod *string                `json:"gracePeriod,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_AutomaticRepairsPolicy populates our AutomaticRepairsPolicy from the provided source AutomaticRepairsPolicy
func (policy *AutomaticRepairsPolicy) AssignProperties_From_AutomaticRepairsPolicy(source *v20220301s.AutomaticRepairsPolicy) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		policy.Enabled = &enabled
	} else {
		policy.Enabled = nil
	}

	// GracePeriod
	policy.GracePeriod = genruntime.ClonePointerToString(source.GracePeriod)

	// RepairAction
	if source.RepairAction != nil {
		propertyBag.Add("RepairAction", *source.RepairAction)
	} else {
		propertyBag.Remove("RepairAction")
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		policy.PropertyBag = propertyBag
	} else {
		policy.PropertyBag = nil
	}

	// Invoke the augmentConversionForAutomaticRepairsPolicy interface (if implemented) to customize the conversion
	var policyAsAny any = policy
	if augmentedPolicy, ok := policyAsAny.(augmentConversionForAutomaticRepairsPolicy); ok {
		err := augmentedPolicy.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AutomaticRepairsPolicy populates the provided destination AutomaticRepairsPolicy from our AutomaticRepairsPolicy
func (policy *AutomaticRepairsPolicy) AssignProperties_To_AutomaticRepairsPolicy(destination *v20220301s.AutomaticRepairsPolicy) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(policy.PropertyBag)

	// Enabled
	if policy.Enabled != nil {
		enabled := *policy.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// GracePeriod
	destination.GracePeriod = genruntime.ClonePointerToString(policy.GracePeriod)

	// RepairAction
	if propertyBag.Contains("RepairAction") {
		var repairAction string
		err := propertyBag.Pull("RepairAction", &repairAction)
		if err != nil {
			return errors.Wrap(err, "pulling 'RepairAction' from propertyBag")
		}

		destination.RepairAction = &repairAction
	} else {
		destination.RepairAction = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAutomaticRepairsPolicy interface (if implemented) to customize the conversion
	var policyAsAny any = policy
	if augmentedPolicy, ok := policyAsAny.(augmentConversionForAutomaticRepairsPolicy); ok {
		err := augmentedPolicy.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.AutomaticRepairsPolicy_STATUS
// Specifies the configuration parameters for automatic repairs on the virtual machine scale set.
type AutomaticRepairsPolicy_STATUS struct {
	Enabled     *bool                  `json:"enabled,omitempty"`
	GracePeriod *string                `json:"gracePeriod,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_AutomaticRepairsPolicy_STATUS populates our AutomaticRepairsPolicy_STATUS from the provided source AutomaticRepairsPolicy_STATUS
func (policy *AutomaticRepairsPolicy_STATUS) AssignProperties_From_AutomaticRepairsPolicy_STATUS(source *v20220301s.AutomaticRepairsPolicy_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		policy.Enabled = &enabled
	} else {
		policy.Enabled = nil
	}

	// GracePeriod
	policy.GracePeriod = genruntime.ClonePointerToString(source.GracePeriod)

	// RepairAction
	if source.RepairAction != nil {
		propertyBag.Add("RepairAction", *source.RepairAction)
	} else {
		propertyBag.Remove("RepairAction")
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		policy.PropertyBag = propertyBag
	} else {
		policy.PropertyBag = nil
	}

	// Invoke the augmentConversionForAutomaticRepairsPolicy_STATUS interface (if implemented) to customize the conversion
	var policyAsAny any = policy
	if augmentedPolicy, ok := policyAsAny.(augmentConversionForAutomaticRepairsPolicy_STATUS); ok {
		err := augmentedPolicy.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AutomaticRepairsPolicy_STATUS populates the provided destination AutomaticRepairsPolicy_STATUS from our AutomaticRepairsPolicy_STATUS
func (policy *AutomaticRepairsPolicy_STATUS) AssignProperties_To_AutomaticRepairsPolicy_STATUS(destination *v20220301s.AutomaticRepairsPolicy_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(policy.PropertyBag)

	// Enabled
	if policy.Enabled != nil {
		enabled := *policy.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// GracePeriod
	destination.GracePeriod = genruntime.ClonePointerToString(policy.GracePeriod)

	// RepairAction
	if propertyBag.Contains("RepairAction") {
		var repairAction string
		err := propertyBag.Pull("RepairAction", &repairAction)
		if err != nil {
			return errors.Wrap(err, "pulling 'RepairAction' from propertyBag")
		}

		destination.RepairAction = &repairAction
	} else {
		destination.RepairAction = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAutomaticRepairsPolicy_STATUS interface (if implemented) to customize the conversion
	var policyAsAny any = policy
	if augmentedPolicy, ok := policyAsAny.(augmentConversionForAutomaticRepairsPolicy_STATUS); ok {
		err := augmentedPolicy.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.ScaleInPolicy
// Describes a scale-in policy for a virtual machine scale set.
type ScaleInPolicy struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Rules       []string               `json:"rules,omitempty"`
}

// AssignProperties_From_ScaleInPolicy populates our ScaleInPolicy from the provided source ScaleInPolicy
func (policy *ScaleInPolicy) AssignProperties_From_ScaleInPolicy(source *v20220301s.ScaleInPolicy) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ForceDeletion
	if source.ForceDeletion != nil {
		propertyBag.Add("ForceDeletion", *source.ForceDeletion)
	} else {
		propertyBag.Remove("ForceDeletion")
	}

	// Rules
	policy.Rules = genruntime.CloneSliceOfString(source.Rules)

	// Update the property bag
	if len(propertyBag) > 0 {
		policy.PropertyBag = propertyBag
	} else {
		policy.PropertyBag = nil
	}

	// Invoke the augmentConversionForScaleInPolicy interface (if implemented) to customize the conversion
	var policyAsAny any = policy
	if augmentedPolicy, ok := policyAsAny.(augmentConversionForScaleInPolicy); ok {
		err := augmentedPolicy.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ScaleInPolicy populates the provided destination ScaleInPolicy from our ScaleInPolicy
func (policy *ScaleInPolicy) AssignProperties_To_ScaleInPolicy(destination *v20220301s.ScaleInPolicy) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(policy.PropertyBag)

	// ForceDeletion
	if propertyBag.Contains("ForceDeletion") {
		var forceDeletion bool
		err := propertyBag.Pull("ForceDeletion", &forceDeletion)
		if err != nil {
			return errors.Wrap(err, "pulling 'ForceDeletion' from propertyBag")
		}

		destination.ForceDeletion = &forceDeletion
	} else {
		destination.ForceDeletion = nil
	}

	// Rules
	destination.Rules = genruntime.CloneSliceOfString(policy.Rules)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForScaleInPolicy interface (if implemented) to customize the conversion
	var policyAsAny any = policy
	if augmentedPolicy, ok := policyAsAny.(augmentConversionForScaleInPolicy); ok {
		err := augmentedPolicy.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.ScaleInPolicy_STATUS
// Describes a scale-in policy for a virtual machine scale set.
type ScaleInPolicy_STATUS struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Rules       []string               `json:"rules,omitempty"`
}

// AssignProperties_From_ScaleInPolicy_STATUS populates our ScaleInPolicy_STATUS from the provided source ScaleInPolicy_STATUS
func (policy *ScaleInPolicy_STATUS) AssignProperties_From_ScaleInPolicy_STATUS(source *v20220301s.ScaleInPolicy_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ForceDeletion
	if source.ForceDeletion != nil {
		propertyBag.Add("ForceDeletion", *source.ForceDeletion)
	} else {
		propertyBag.Remove("ForceDeletion")
	}

	// Rules
	policy.Rules = genruntime.CloneSliceOfString(source.Rules)

	// Update the property bag
	if len(propertyBag) > 0 {
		policy.PropertyBag = propertyBag
	} else {
		policy.PropertyBag = nil
	}

	// Invoke the augmentConversionForScaleInPolicy_STATUS interface (if implemented) to customize the conversion
	var policyAsAny any = policy
	if augmentedPolicy, ok := policyAsAny.(augmentConversionForScaleInPolicy_STATUS); ok {
		err := augmentedPolicy.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ScaleInPolicy_STATUS populates the provided destination ScaleInPolicy_STATUS from our ScaleInPolicy_STATUS
func (policy *ScaleInPolicy_STATUS) AssignProperties_To_ScaleInPolicy_STATUS(destination *v20220301s.ScaleInPolicy_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(policy.PropertyBag)

	// ForceDeletion
	if propertyBag.Contains("ForceDeletion") {
		var forceDeletion bool
		err := propertyBag.Pull("ForceDeletion", &forceDeletion)
		if err != nil {
			return errors.Wrap(err, "pulling 'ForceDeletion' from propertyBag")
		}

		destination.ForceDeletion = &forceDeletion
	} else {
		destination.ForceDeletion = nil
	}

	// Rules
	destination.Rules = genruntime.CloneSliceOfString(policy.Rules)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForScaleInPolicy_STATUS interface (if implemented) to customize the conversion
	var policyAsAny any = policy
	if augmentedPolicy, ok := policyAsAny.(augmentConversionForScaleInPolicy_STATUS); ok {
		err := augmentedPolicy.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.Sku
// Describes a virtual machine scale set sku. NOTE: If the new VM SKU is not supported on the hardware the scale set is
// currently on, you need to deallocate the VMs in the scale set before you modify the SKU name.
type Sku struct {
	Capacity    *int                   `json:"capacity,omitempty"`
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Tier        *string                `json:"tier,omitempty"`
}

// AssignProperties_From_Sku populates our Sku from the provided source Sku
func (sku *Sku) AssignProperties_From_Sku(source *v20220301s.Sku) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Capacity
	sku.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Name
	sku.Name = genruntime.ClonePointerToString(source.Name)

	// Tier
	sku.Tier = genruntime.ClonePointerToString(source.Tier)

	// Update the property bag
	if len(propertyBag) > 0 {
		sku.PropertyBag = propertyBag
	} else {
		sku.PropertyBag = nil
	}

	// Invoke the augmentConversionForSku interface (if implemented) to customize the conversion
	var skuAsAny any = sku
	if augmentedSku, ok := skuAsAny.(augmentConversionForSku); ok {
		err := augmentedSku.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Sku populates the provided destination Sku from our Sku
func (sku *Sku) AssignProperties_To_Sku(destination *v20220301s.Sku) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(sku.PropertyBag)

	// Capacity
	destination.Capacity = genruntime.ClonePointerToInt(sku.Capacity)

	// Name
	destination.Name = genruntime.ClonePointerToString(sku.Name)

	// Tier
	destination.Tier = genruntime.ClonePointerToString(sku.Tier)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSku interface (if implemented) to customize the conversion
	var skuAsAny any = sku
	if augmentedSku, ok := skuAsAny.(augmentConversionForSku); ok {
		err := augmentedSku.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.Sku_STATUS
// Describes a virtual machine scale set sku. NOTE: If the new VM SKU is not supported on the hardware the scale set is
// currently on, you need to deallocate the VMs in the scale set before you modify the SKU name.
type Sku_STATUS struct {
	Capacity    *int                   `json:"capacity,omitempty"`
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Tier        *string                `json:"tier,omitempty"`
}

// AssignProperties_From_Sku_STATUS populates our Sku_STATUS from the provided source Sku_STATUS
func (sku *Sku_STATUS) AssignProperties_From_Sku_STATUS(source *v20220301s.Sku_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Capacity
	sku.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Name
	sku.Name = genruntime.ClonePointerToString(source.Name)

	// Tier
	sku.Tier = genruntime.ClonePointerToString(source.Tier)

	// Update the property bag
	if len(propertyBag) > 0 {
		sku.PropertyBag = propertyBag
	} else {
		sku.PropertyBag = nil
	}

	// Invoke the augmentConversionForSku_STATUS interface (if implemented) to customize the conversion
	var skuAsAny any = sku
	if augmentedSku, ok := skuAsAny.(augmentConversionForSku_STATUS); ok {
		err := augmentedSku.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Sku_STATUS populates the provided destination Sku_STATUS from our Sku_STATUS
func (sku *Sku_STATUS) AssignProperties_To_Sku_STATUS(destination *v20220301s.Sku_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(sku.PropertyBag)

	// Capacity
	destination.Capacity = genruntime.ClonePointerToInt(sku.Capacity)

	// Name
	destination.Name = genruntime.ClonePointerToString(sku.Name)

	// Tier
	destination.Tier = genruntime.ClonePointerToString(sku.Tier)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSku_STATUS interface (if implemented) to customize the conversion
	var skuAsAny any = sku
	if augmentedSku, ok := skuAsAny.(augmentConversionForSku_STATUS); ok {
		err := augmentedSku.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.UpgradePolicy
// Describes an upgrade policy - automatic, manual, or rolling.
type UpgradePolicy struct {
	AutomaticOSUpgradePolicy *AutomaticOSUpgradePolicy `json:"automaticOSUpgradePolicy,omitempty"`
	Mode                     *string                   `json:"mode,omitempty"`
	PropertyBag              genruntime.PropertyBag    `json:"$propertyBag,omitempty"`
	RollingUpgradePolicy     *RollingUpgradePolicy     `json:"rollingUpgradePolicy,omitempty"`
}

// AssignProperties_From_UpgradePolicy populates our UpgradePolicy from the provided source UpgradePolicy
func (policy *UpgradePolicy) AssignProperties_From_UpgradePolicy(source *v20220301s.UpgradePolicy) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AutomaticOSUpgradePolicy
	if source.AutomaticOSUpgradePolicy != nil {
		var automaticOSUpgradePolicy AutomaticOSUpgradePolicy
		err := automaticOSUpgradePolicy.AssignProperties_From_AutomaticOSUpgradePolicy(source.AutomaticOSUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AutomaticOSUpgradePolicy() to populate field AutomaticOSUpgradePolicy")
		}
		policy.AutomaticOSUpgradePolicy = &automaticOSUpgradePolicy
	} else {
		policy.AutomaticOSUpgradePolicy = nil
	}

	// Mode
	policy.Mode = genruntime.ClonePointerToString(source.Mode)

	// RollingUpgradePolicy
	if source.RollingUpgradePolicy != nil {
		var rollingUpgradePolicy RollingUpgradePolicy
		err := rollingUpgradePolicy.AssignProperties_From_RollingUpgradePolicy(source.RollingUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RollingUpgradePolicy() to populate field RollingUpgradePolicy")
		}
		policy.RollingUpgradePolicy = &rollingUpgradePolicy
	} else {
		policy.RollingUpgradePolicy = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		policy.PropertyBag = propertyBag
	} else {
		policy.PropertyBag = nil
	}

	// Invoke the augmentConversionForUpgradePolicy interface (if implemented) to customize the conversion
	var policyAsAny any = policy
	if augmentedPolicy, ok := policyAsAny.(augmentConversionForUpgradePolicy); ok {
		err := augmentedPolicy.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UpgradePolicy populates the provided destination UpgradePolicy from our UpgradePolicy
func (policy *UpgradePolicy) AssignProperties_To_UpgradePolicy(destination *v20220301s.UpgradePolicy) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(policy.PropertyBag)

	// AutomaticOSUpgradePolicy
	if policy.AutomaticOSUpgradePolicy != nil {
		var automaticOSUpgradePolicy v20220301s.AutomaticOSUpgradePolicy
		err := policy.AutomaticOSUpgradePolicy.AssignProperties_To_AutomaticOSUpgradePolicy(&automaticOSUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AutomaticOSUpgradePolicy() to populate field AutomaticOSUpgradePolicy")
		}
		destination.AutomaticOSUpgradePolicy = &automaticOSUpgradePolicy
	} else {
		destination.AutomaticOSUpgradePolicy = nil
	}

	// Mode
	destination.Mode = genruntime.ClonePointerToString(policy.Mode)

	// RollingUpgradePolicy
	if policy.RollingUpgradePolicy != nil {
		var rollingUpgradePolicy v20220301s.RollingUpgradePolicy
		err := policy.RollingUpgradePolicy.AssignProperties_To_RollingUpgradePolicy(&rollingUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RollingUpgradePolicy() to populate field RollingUpgradePolicy")
		}
		destination.RollingUpgradePolicy = &rollingUpgradePolicy
	} else {
		destination.RollingUpgradePolicy = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUpgradePolicy interface (if implemented) to customize the conversion
	var policyAsAny any = policy
	if augmentedPolicy, ok := policyAsAny.(augmentConversionForUpgradePolicy); ok {
		err := augmentedPolicy.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.UpgradePolicy_STATUS
// Describes an upgrade policy - automatic, manual, or rolling.
type UpgradePolicy_STATUS struct {
	AutomaticOSUpgradePolicy *AutomaticOSUpgradePolicy_STATUS `json:"automaticOSUpgradePolicy,omitempty"`
	Mode                     *string                          `json:"mode,omitempty"`
	PropertyBag              genruntime.PropertyBag           `json:"$propertyBag,omitempty"`
	RollingUpgradePolicy     *RollingUpgradePolicy_STATUS     `json:"rollingUpgradePolicy,omitempty"`
}

// AssignProperties_From_UpgradePolicy_STATUS populates our UpgradePolicy_STATUS from the provided source UpgradePolicy_STATUS
func (policy *UpgradePolicy_STATUS) AssignProperties_From_UpgradePolicy_STATUS(source *v20220301s.UpgradePolicy_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AutomaticOSUpgradePolicy
	if source.AutomaticOSUpgradePolicy != nil {
		var automaticOSUpgradePolicy AutomaticOSUpgradePolicy_STATUS
		err := automaticOSUpgradePolicy.AssignProperties_From_AutomaticOSUpgradePolicy_STATUS(source.AutomaticOSUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AutomaticOSUpgradePolicy_STATUS() to populate field AutomaticOSUpgradePolicy")
		}
		policy.AutomaticOSUpgradePolicy = &automaticOSUpgradePolicy
	} else {
		policy.AutomaticOSUpgradePolicy = nil
	}

	// Mode
	policy.Mode = genruntime.ClonePointerToString(source.Mode)

	// RollingUpgradePolicy
	if source.RollingUpgradePolicy != nil {
		var rollingUpgradePolicy RollingUpgradePolicy_STATUS
		err := rollingUpgradePolicy.AssignProperties_From_RollingUpgradePolicy_STATUS(source.RollingUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RollingUpgradePolicy_STATUS() to populate field RollingUpgradePolicy")
		}
		policy.RollingUpgradePolicy = &rollingUpgradePolicy
	} else {
		policy.RollingUpgradePolicy = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		policy.PropertyBag = propertyBag
	} else {
		policy.PropertyBag = nil
	}

	// Invoke the augmentConversionForUpgradePolicy_STATUS interface (if implemented) to customize the conversion
	var policyAsAny any = policy
	if augmentedPolicy, ok := policyAsAny.(augmentConversionForUpgradePolicy_STATUS); ok {
		err := augmentedPolicy.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UpgradePolicy_STATUS populates the provided destination UpgradePolicy_STATUS from our UpgradePolicy_STATUS
func (policy *UpgradePolicy_STATUS) AssignProperties_To_UpgradePolicy_STATUS(destination *v20220301s.UpgradePolicy_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(policy.PropertyBag)

	// AutomaticOSUpgradePolicy
	if policy.AutomaticOSUpgradePolicy != nil {
		var automaticOSUpgradePolicy v20220301s.AutomaticOSUpgradePolicy_STATUS
		err := policy.AutomaticOSUpgradePolicy.AssignProperties_To_AutomaticOSUpgradePolicy_STATUS(&automaticOSUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AutomaticOSUpgradePolicy_STATUS() to populate field AutomaticOSUpgradePolicy")
		}
		destination.AutomaticOSUpgradePolicy = &automaticOSUpgradePolicy
	} else {
		destination.AutomaticOSUpgradePolicy = nil
	}

	// Mode
	destination.Mode = genruntime.ClonePointerToString(policy.Mode)

	// RollingUpgradePolicy
	if policy.RollingUpgradePolicy != nil {
		var rollingUpgradePolicy v20220301s.RollingUpgradePolicy_STATUS
		err := policy.RollingUpgradePolicy.AssignProperties_To_RollingUpgradePolicy_STATUS(&rollingUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RollingUpgradePolicy_STATUS() to populate field RollingUpgradePolicy")
		}
		destination.RollingUpgradePolicy = &rollingUpgradePolicy
	} else {
		destination.RollingUpgradePolicy = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUpgradePolicy_STATUS interface (if implemented) to customize the conversion
	var policyAsAny any = policy
	if augmentedPolicy, ok := policyAsAny.(augmentConversionForUpgradePolicy_STATUS); ok {
		err := augmentedPolicy.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineScaleSetIdentity
// Identity for the virtual machine scale set.
type VirtualMachineScaleSetIdentity struct {
	PropertyBag            genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	Type                   *string                       `json:"type,omitempty"`
	UserAssignedIdentities []UserAssignedIdentityDetails `json:"userAssignedIdentities,omitempty"`
}

// AssignProperties_From_VirtualMachineScaleSetIdentity populates our VirtualMachineScaleSetIdentity from the provided source VirtualMachineScaleSetIdentity
func (identity *VirtualMachineScaleSetIdentity) AssignProperties_From_VirtualMachineScaleSetIdentity(source *v20220301s.VirtualMachineScaleSetIdentity) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Type
	identity.Type = genruntime.ClonePointerToString(source.Type)

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, len(source.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity UserAssignedIdentityDetails
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentityDetails(&userAssignedIdentityItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		identity.PropertyBag = propertyBag
	} else {
		identity.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetIdentity interface (if implemented) to customize the conversion
	var identityAsAny any = identity
	if augmentedIdentity, ok := identityAsAny.(augmentConversionForVirtualMachineScaleSetIdentity); ok {
		err := augmentedIdentity.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetIdentity populates the provided destination VirtualMachineScaleSetIdentity from our VirtualMachineScaleSetIdentity
func (identity *VirtualMachineScaleSetIdentity) AssignProperties_To_VirtualMachineScaleSetIdentity(destination *v20220301s.VirtualMachineScaleSetIdentity) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(identity.PropertyBag)

	// Type
	destination.Type = genruntime.ClonePointerToString(identity.Type)

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]v20220301s.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity v20220301s.UserAssignedIdentityDetails
			err := userAssignedIdentityItem.AssignProperties_To_UserAssignedIdentityDetails(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityList
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetIdentity interface (if implemented) to customize the conversion
	var identityAsAny any = identity
	if augmentedIdentity, ok := identityAsAny.(augmentConversionForVirtualMachineScaleSetIdentity); ok {
		err := augmentedIdentity.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineScaleSetIdentity_STATUS
// Identity for the virtual machine scale set.
type VirtualMachineScaleSetIdentity_STATUS struct {
	PrincipalId            *string                                                                 `json:"principalId,omitempty"`
	PropertyBag            genruntime.PropertyBag                                                  `json:"$propertyBag,omitempty"`
	TenantId               *string                                                                 `json:"tenantId,omitempty"`
	Type                   *string                                                                 `json:"type,omitempty"`
	UserAssignedIdentities map[string]VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS `json:"userAssignedIdentities,omitempty"`
}

// AssignProperties_From_VirtualMachineScaleSetIdentity_STATUS populates our VirtualMachineScaleSetIdentity_STATUS from the provided source VirtualMachineScaleSetIdentity_STATUS
func (identity *VirtualMachineScaleSetIdentity_STATUS) AssignProperties_From_VirtualMachineScaleSetIdentity_STATUS(source *v20220301s.VirtualMachineScaleSetIdentity_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	identity.Type = genruntime.ClonePointerToString(source.Type)

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS
			err := userAssignedIdentity.AssignProperties_From_VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS(&userAssignedIdentityValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		identity.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		identity.PropertyBag = propertyBag
	} else {
		identity.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetIdentity_STATUS interface (if implemented) to customize the conversion
	var identityAsAny any = identity
	if augmentedIdentity, ok := identityAsAny.(augmentConversionForVirtualMachineScaleSetIdentity_STATUS); ok {
		err := augmentedIdentity.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetIdentity_STATUS populates the provided destination VirtualMachineScaleSetIdentity_STATUS from our VirtualMachineScaleSetIdentity_STATUS
func (identity *VirtualMachineScaleSetIdentity_STATUS) AssignProperties_To_VirtualMachineScaleSetIdentity_STATUS(destination *v20220301s.VirtualMachineScaleSetIdentity_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(identity.PropertyBag)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	destination.Type = genruntime.ClonePointerToString(identity.Type)

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]v20220301s.VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS, len(identity.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity v20220301s.VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS
			err := userAssignedIdentityValue.AssignProperties_To_VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetIdentity_STATUS interface (if implemented) to customize the conversion
	var identityAsAny any = identity
	if augmentedIdentity, ok := identityAsAny.(augmentConversionForVirtualMachineScaleSetIdentity_STATUS); ok {
		err := augmentedIdentity.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineScaleSetOperatorSpec
// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type VirtualMachineScaleSetOperatorSpec struct {
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`
	PropertyBag          genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	SecretExpressions    []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_VirtualMachineScaleSetOperatorSpec populates our VirtualMachineScaleSetOperatorSpec from the provided source VirtualMachineScaleSetOperatorSpec
func (operator *VirtualMachineScaleSetOperatorSpec) AssignProperties_From_VirtualMachineScaleSetOperatorSpec(source *v20220301s.VirtualMachineScaleSetOperatorSpec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		operator.PropertyBag = propertyBag
	} else {
		operator.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetOperatorSpec interface (if implemented) to customize the conversion
	var operatorAsAny any = operator
	if augmentedOperator, ok := operatorAsAny.(augmentConversionForVirtualMachineScaleSetOperatorSpec); ok {
		err := augmentedOperator.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetOperatorSpec populates the provided destination VirtualMachineScaleSetOperatorSpec from our VirtualMachineScaleSetOperatorSpec
func (operator *VirtualMachineScaleSetOperatorSpec) AssignProperties_To_VirtualMachineScaleSetOperatorSpec(destination *v20220301s.VirtualMachineScaleSetOperatorSpec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(operator.PropertyBag)

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetOperatorSpec interface (if implemented) to customize the conversion
	var operatorAsAny any = operator
	if augmentedOperator, ok := operatorAsAny.(augmentConversionForVirtualMachineScaleSetOperatorSpec); ok {
		err := augmentedOperator.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineScaleSetVMProfile
// Describes a virtual machine scale set virtual machine profile.
type VirtualMachineScaleSetVMProfile struct {
	BillingProfile         *BillingProfile                         `json:"billingProfile,omitempty"`
	DiagnosticsProfile     *DiagnosticsProfile                     `json:"diagnosticsProfile,omitempty"`
	EvictionPolicy         *string                                 `json:"evictionPolicy,omitempty"`
	ExtensionProfile       *VirtualMachineScaleSetExtensionProfile `json:"extensionProfile,omitempty"`
	LicenseType            *string                                 `json:"licenseType,omitempty"`
	NetworkProfile         *VirtualMachineScaleSetNetworkProfile   `json:"networkProfile,omitempty"`
	OsProfile              *VirtualMachineScaleSetOSProfile        `json:"osProfile,omitempty"`
	Priority               *string                                 `json:"priority,omitempty"`
	PropertyBag            genruntime.PropertyBag                  `json:"$propertyBag,omitempty"`
	ScheduledEventsProfile *ScheduledEventsProfile                 `json:"scheduledEventsProfile,omitempty"`
	SecurityProfile        *SecurityProfile                        `json:"securityProfile,omitempty"`
	StorageProfile         *VirtualMachineScaleSetStorageProfile   `json:"storageProfile,omitempty"`
}

// AssignProperties_From_VirtualMachineScaleSetVMProfile populates our VirtualMachineScaleSetVMProfile from the provided source VirtualMachineScaleSetVMProfile
func (profile *VirtualMachineScaleSetVMProfile) AssignProperties_From_VirtualMachineScaleSetVMProfile(source *v20220301s.VirtualMachineScaleSetVMProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ApplicationProfile
	if source.ApplicationProfile != nil {
		propertyBag.Add("ApplicationProfile", *source.ApplicationProfile)
	} else {
		propertyBag.Remove("ApplicationProfile")
	}

	// BillingProfile
	if source.BillingProfile != nil {
		var billingProfile BillingProfile
		err := billingProfile.AssignProperties_From_BillingProfile(source.BillingProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BillingProfile() to populate field BillingProfile")
		}
		profile.BillingProfile = &billingProfile
	} else {
		profile.BillingProfile = nil
	}

	// CapacityReservation
	if source.CapacityReservation != nil {
		propertyBag.Add("CapacityReservation", *source.CapacityReservation)
	} else {
		propertyBag.Remove("CapacityReservation")
	}

	// DiagnosticsProfile
	if source.DiagnosticsProfile != nil {
		var diagnosticsProfile DiagnosticsProfile
		err := diagnosticsProfile.AssignProperties_From_DiagnosticsProfile(source.DiagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DiagnosticsProfile() to populate field DiagnosticsProfile")
		}
		profile.DiagnosticsProfile = &diagnosticsProfile
	} else {
		profile.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	profile.EvictionPolicy = genruntime.ClonePointerToString(source.EvictionPolicy)

	// ExtensionProfile
	if source.ExtensionProfile != nil {
		var extensionProfile VirtualMachineScaleSetExtensionProfile
		err := extensionProfile.AssignProperties_From_VirtualMachineScaleSetExtensionProfile(source.ExtensionProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetExtensionProfile() to populate field ExtensionProfile")
		}
		profile.ExtensionProfile = &extensionProfile
	} else {
		profile.ExtensionProfile = nil
	}

	// HardwareProfile
	if source.HardwareProfile != nil {
		propertyBag.Add("HardwareProfile", *source.HardwareProfile)
	} else {
		propertyBag.Remove("HardwareProfile")
	}

	// LicenseType
	profile.LicenseType = genruntime.ClonePointerToString(source.LicenseType)

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile VirtualMachineScaleSetNetworkProfile
		err := networkProfile.AssignProperties_From_VirtualMachineScaleSetNetworkProfile(source.NetworkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetNetworkProfile() to populate field NetworkProfile")
		}
		profile.NetworkProfile = &networkProfile
	} else {
		profile.NetworkProfile = nil
	}

	// OsProfile
	if source.OsProfile != nil {
		var osProfile VirtualMachineScaleSetOSProfile
		err := osProfile.AssignProperties_From_VirtualMachineScaleSetOSProfile(source.OsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetOSProfile() to populate field OsProfile")
		}
		profile.OsProfile = &osProfile
	} else {
		profile.OsProfile = nil
	}

	// Priority
	profile.Priority = genruntime.ClonePointerToString(source.Priority)

	// ScheduledEventsProfile
	if source.ScheduledEventsProfile != nil {
		var scheduledEventsProfile ScheduledEventsProfile
		err := scheduledEventsProfile.AssignProperties_From_ScheduledEventsProfile(source.ScheduledEventsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ScheduledEventsProfile() to populate field ScheduledEventsProfile")
		}
		profile.ScheduledEventsProfile = &scheduledEventsProfile
	} else {
		profile.ScheduledEventsProfile = nil
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		var securityProfile SecurityProfile
		err := securityProfile.AssignProperties_From_SecurityProfile(source.SecurityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SecurityProfile() to populate field SecurityProfile")
		}
		profile.SecurityProfile = &securityProfile
	} else {
		profile.SecurityProfile = nil
	}

	// StorageProfile
	if source.StorageProfile != nil {
		var storageProfile VirtualMachineScaleSetStorageProfile
		err := storageProfile.AssignProperties_From_VirtualMachineScaleSetStorageProfile(source.StorageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetStorageProfile() to populate field StorageProfile")
		}
		profile.StorageProfile = &storageProfile
	} else {
		profile.StorageProfile = nil
	}

	// UserData
	if source.UserData != nil {
		propertyBag.Add("UserData", *source.UserData)
	} else {
		propertyBag.Remove("UserData")
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetVMProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForVirtualMachineScaleSetVMProfile); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetVMProfile populates the provided destination VirtualMachineScaleSetVMProfile from our VirtualMachineScaleSetVMProfile
func (profile *VirtualMachineScaleSetVMProfile) AssignProperties_To_VirtualMachineScaleSetVMProfile(destination *v20220301s.VirtualMachineScaleSetVMProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// ApplicationProfile
	if propertyBag.Contains("ApplicationProfile") {
		var applicationProfile v20220301s.ApplicationProfile
		err := propertyBag.Pull("ApplicationProfile", &applicationProfile)
		if err != nil {
			return errors.Wrap(err, "pulling 'ApplicationProfile' from propertyBag")
		}

		destination.ApplicationProfile = &applicationProfile
	} else {
		destination.ApplicationProfile = nil
	}

	// BillingProfile
	if profile.BillingProfile != nil {
		var billingProfile v20220301s.BillingProfile
		err := profile.BillingProfile.AssignProperties_To_BillingProfile(&billingProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BillingProfile() to populate field BillingProfile")
		}
		destination.BillingProfile = &billingProfile
	} else {
		destination.BillingProfile = nil
	}

	// CapacityReservation
	if propertyBag.Contains("CapacityReservation") {
		var capacityReservation v20220301s.CapacityReservationProfile
		err := propertyBag.Pull("CapacityReservation", &capacityReservation)
		if err != nil {
			return errors.Wrap(err, "pulling 'CapacityReservation' from propertyBag")
		}

		destination.CapacityReservation = &capacityReservation
	} else {
		destination.CapacityReservation = nil
	}

	// DiagnosticsProfile
	if profile.DiagnosticsProfile != nil {
		var diagnosticsProfile v20220301s.DiagnosticsProfile
		err := profile.DiagnosticsProfile.AssignProperties_To_DiagnosticsProfile(&diagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DiagnosticsProfile() to populate field DiagnosticsProfile")
		}
		destination.DiagnosticsProfile = &diagnosticsProfile
	} else {
		destination.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	destination.EvictionPolicy = genruntime.ClonePointerToString(profile.EvictionPolicy)

	// ExtensionProfile
	if profile.ExtensionProfile != nil {
		var extensionProfile v20220301s.VirtualMachineScaleSetExtensionProfile
		err := profile.ExtensionProfile.AssignProperties_To_VirtualMachineScaleSetExtensionProfile(&extensionProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetExtensionProfile() to populate field ExtensionProfile")
		}
		destination.ExtensionProfile = &extensionProfile
	} else {
		destination.ExtensionProfile = nil
	}

	// HardwareProfile
	if propertyBag.Contains("HardwareProfile") {
		var hardwareProfile v20220301s.VirtualMachineScaleSetHardwareProfile
		err := propertyBag.Pull("HardwareProfile", &hardwareProfile)
		if err != nil {
			return errors.Wrap(err, "pulling 'HardwareProfile' from propertyBag")
		}

		destination.HardwareProfile = &hardwareProfile
	} else {
		destination.HardwareProfile = nil
	}

	// LicenseType
	destination.LicenseType = genruntime.ClonePointerToString(profile.LicenseType)

	// NetworkProfile
	if profile.NetworkProfile != nil {
		var networkProfile v20220301s.VirtualMachineScaleSetNetworkProfile
		err := profile.NetworkProfile.AssignProperties_To_VirtualMachineScaleSetNetworkProfile(&networkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetNetworkProfile() to populate field NetworkProfile")
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// OsProfile
	if profile.OsProfile != nil {
		var osProfile v20220301s.VirtualMachineScaleSetOSProfile
		err := profile.OsProfile.AssignProperties_To_VirtualMachineScaleSetOSProfile(&osProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetOSProfile() to populate field OsProfile")
		}
		destination.OsProfile = &osProfile
	} else {
		destination.OsProfile = nil
	}

	// Priority
	destination.Priority = genruntime.ClonePointerToString(profile.Priority)

	// ScheduledEventsProfile
	if profile.ScheduledEventsProfile != nil {
		var scheduledEventsProfile v20220301s.ScheduledEventsProfile
		err := profile.ScheduledEventsProfile.AssignProperties_To_ScheduledEventsProfile(&scheduledEventsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ScheduledEventsProfile() to populate field ScheduledEventsProfile")
		}
		destination.ScheduledEventsProfile = &scheduledEventsProfile
	} else {
		destination.ScheduledEventsProfile = nil
	}

	// SecurityProfile
	if profile.SecurityProfile != nil {
		var securityProfile v20220301s.SecurityProfile
		err := profile.SecurityProfile.AssignProperties_To_SecurityProfile(&securityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SecurityProfile() to populate field SecurityProfile")
		}
		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// StorageProfile
	if profile.StorageProfile != nil {
		var storageProfile v20220301s.VirtualMachineScaleSetStorageProfile
		err := profile.StorageProfile.AssignProperties_To_VirtualMachineScaleSetStorageProfile(&storageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetStorageProfile() to populate field StorageProfile")
		}
		destination.StorageProfile = &storageProfile
	} else {
		destination.StorageProfile = nil
	}

	// UserData
	if propertyBag.Contains("UserData") {
		var userDatum string
		err := propertyBag.Pull("UserData", &userDatum)
		if err != nil {
			return errors.Wrap(err, "pulling 'UserData' from propertyBag")
		}

		destination.UserData = &userDatum
	} else {
		destination.UserData = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetVMProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForVirtualMachineScaleSetVMProfile); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineScaleSetVMProfile_STATUS
// Describes a virtual machine scale set virtual machine profile.
type VirtualMachineScaleSetVMProfile_STATUS struct {
	BillingProfile         *BillingProfile_STATUS                         `json:"billingProfile,omitempty"`
	DiagnosticsProfile     *DiagnosticsProfile_STATUS                     `json:"diagnosticsProfile,omitempty"`
	EvictionPolicy         *string                                        `json:"evictionPolicy,omitempty"`
	ExtensionProfile       *VirtualMachineScaleSetExtensionProfile_STATUS `json:"extensionProfile,omitempty"`
	LicenseType            *string                                        `json:"licenseType,omitempty"`
	NetworkProfile         *VirtualMachineScaleSetNetworkProfile_STATUS   `json:"networkProfile,omitempty"`
	OsProfile              *VirtualMachineScaleSetOSProfile_STATUS        `json:"osProfile,omitempty"`
	Priority               *string                                        `json:"priority,omitempty"`
	PropertyBag            genruntime.PropertyBag                         `json:"$propertyBag,omitempty"`
	ScheduledEventsProfile *ScheduledEventsProfile_STATUS                 `json:"scheduledEventsProfile,omitempty"`
	SecurityProfile        *SecurityProfile_STATUS                        `json:"securityProfile,omitempty"`
	StorageProfile         *VirtualMachineScaleSetStorageProfile_STATUS   `json:"storageProfile,omitempty"`
}

// AssignProperties_From_VirtualMachineScaleSetVMProfile_STATUS populates our VirtualMachineScaleSetVMProfile_STATUS from the provided source VirtualMachineScaleSetVMProfile_STATUS
func (profile *VirtualMachineScaleSetVMProfile_STATUS) AssignProperties_From_VirtualMachineScaleSetVMProfile_STATUS(source *v20220301s.VirtualMachineScaleSetVMProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ApplicationProfile
	if source.ApplicationProfile != nil {
		propertyBag.Add("ApplicationProfile", *source.ApplicationProfile)
	} else {
		propertyBag.Remove("ApplicationProfile")
	}

	// BillingProfile
	if source.BillingProfile != nil {
		var billingProfile BillingProfile_STATUS
		err := billingProfile.AssignProperties_From_BillingProfile_STATUS(source.BillingProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_BillingProfile_STATUS() to populate field BillingProfile")
		}
		profile.BillingProfile = &billingProfile
	} else {
		profile.BillingProfile = nil
	}

	// CapacityReservation
	if source.CapacityReservation != nil {
		propertyBag.Add("CapacityReservation", *source.CapacityReservation)
	} else {
		propertyBag.Remove("CapacityReservation")
	}

	// DiagnosticsProfile
	if source.DiagnosticsProfile != nil {
		var diagnosticsProfile DiagnosticsProfile_STATUS
		err := diagnosticsProfile.AssignProperties_From_DiagnosticsProfile_STATUS(source.DiagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DiagnosticsProfile_STATUS() to populate field DiagnosticsProfile")
		}
		profile.DiagnosticsProfile = &diagnosticsProfile
	} else {
		profile.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	profile.EvictionPolicy = genruntime.ClonePointerToString(source.EvictionPolicy)

	// ExtensionProfile
	if source.ExtensionProfile != nil {
		var extensionProfile VirtualMachineScaleSetExtensionProfile_STATUS
		err := extensionProfile.AssignProperties_From_VirtualMachineScaleSetExtensionProfile_STATUS(source.ExtensionProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetExtensionProfile_STATUS() to populate field ExtensionProfile")
		}
		profile.ExtensionProfile = &extensionProfile
	} else {
		profile.ExtensionProfile = nil
	}

	// HardwareProfile
	if source.HardwareProfile != nil {
		propertyBag.Add("HardwareProfile", *source.HardwareProfile)
	} else {
		propertyBag.Remove("HardwareProfile")
	}

	// LicenseType
	profile.LicenseType = genruntime.ClonePointerToString(source.LicenseType)

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile VirtualMachineScaleSetNetworkProfile_STATUS
		err := networkProfile.AssignProperties_From_VirtualMachineScaleSetNetworkProfile_STATUS(source.NetworkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetNetworkProfile_STATUS() to populate field NetworkProfile")
		}
		profile.NetworkProfile = &networkProfile
	} else {
		profile.NetworkProfile = nil
	}

	// OsProfile
	if source.OsProfile != nil {
		var osProfile VirtualMachineScaleSetOSProfile_STATUS
		err := osProfile.AssignProperties_From_VirtualMachineScaleSetOSProfile_STATUS(source.OsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetOSProfile_STATUS() to populate field OsProfile")
		}
		profile.OsProfile = &osProfile
	} else {
		profile.OsProfile = nil
	}

	// Priority
	profile.Priority = genruntime.ClonePointerToString(source.Priority)

	// ScheduledEventsProfile
	if source.ScheduledEventsProfile != nil {
		var scheduledEventsProfile ScheduledEventsProfile_STATUS
		err := scheduledEventsProfile.AssignProperties_From_ScheduledEventsProfile_STATUS(source.ScheduledEventsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ScheduledEventsProfile_STATUS() to populate field ScheduledEventsProfile")
		}
		profile.ScheduledEventsProfile = &scheduledEventsProfile
	} else {
		profile.ScheduledEventsProfile = nil
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		var securityProfile SecurityProfile_STATUS
		err := securityProfile.AssignProperties_From_SecurityProfile_STATUS(source.SecurityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SecurityProfile_STATUS() to populate field SecurityProfile")
		}
		profile.SecurityProfile = &securityProfile
	} else {
		profile.SecurityProfile = nil
	}

	// StorageProfile
	if source.StorageProfile != nil {
		var storageProfile VirtualMachineScaleSetStorageProfile_STATUS
		err := storageProfile.AssignProperties_From_VirtualMachineScaleSetStorageProfile_STATUS(source.StorageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetStorageProfile_STATUS() to populate field StorageProfile")
		}
		profile.StorageProfile = &storageProfile
	} else {
		profile.StorageProfile = nil
	}

	// UserData
	if source.UserData != nil {
		propertyBag.Add("UserData", *source.UserData)
	} else {
		propertyBag.Remove("UserData")
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetVMProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForVirtualMachineScaleSetVMProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetVMProfile_STATUS populates the provided destination VirtualMachineScaleSetVMProfile_STATUS from our VirtualMachineScaleSetVMProfile_STATUS
func (profile *VirtualMachineScaleSetVMProfile_STATUS) AssignProperties_To_VirtualMachineScaleSetVMProfile_STATUS(destination *v20220301s.VirtualMachineScaleSetVMProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// ApplicationProfile
	if propertyBag.Contains("ApplicationProfile") {
		var applicationProfile v20220301s.ApplicationProfile_STATUS
		err := propertyBag.Pull("ApplicationProfile", &applicationProfile)
		if err != nil {
			return errors.Wrap(err, "pulling 'ApplicationProfile' from propertyBag")
		}

		destination.ApplicationProfile = &applicationProfile
	} else {
		destination.ApplicationProfile = nil
	}

	// BillingProfile
	if profile.BillingProfile != nil {
		var billingProfile v20220301s.BillingProfile_STATUS
		err := profile.BillingProfile.AssignProperties_To_BillingProfile_STATUS(&billingProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_BillingProfile_STATUS() to populate field BillingProfile")
		}
		destination.BillingProfile = &billingProfile
	} else {
		destination.BillingProfile = nil
	}

	// CapacityReservation
	if propertyBag.Contains("CapacityReservation") {
		var capacityReservation v20220301s.CapacityReservationProfile_STATUS
		err := propertyBag.Pull("CapacityReservation", &capacityReservation)
		if err != nil {
			return errors.Wrap(err, "pulling 'CapacityReservation' from propertyBag")
		}

		destination.CapacityReservation = &capacityReservation
	} else {
		destination.CapacityReservation = nil
	}

	// DiagnosticsProfile
	if profile.DiagnosticsProfile != nil {
		var diagnosticsProfile v20220301s.DiagnosticsProfile_STATUS
		err := profile.DiagnosticsProfile.AssignProperties_To_DiagnosticsProfile_STATUS(&diagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DiagnosticsProfile_STATUS() to populate field DiagnosticsProfile")
		}
		destination.DiagnosticsProfile = &diagnosticsProfile
	} else {
		destination.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	destination.EvictionPolicy = genruntime.ClonePointerToString(profile.EvictionPolicy)

	// ExtensionProfile
	if profile.ExtensionProfile != nil {
		var extensionProfile v20220301s.VirtualMachineScaleSetExtensionProfile_STATUS
		err := profile.ExtensionProfile.AssignProperties_To_VirtualMachineScaleSetExtensionProfile_STATUS(&extensionProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetExtensionProfile_STATUS() to populate field ExtensionProfile")
		}
		destination.ExtensionProfile = &extensionProfile
	} else {
		destination.ExtensionProfile = nil
	}

	// HardwareProfile
	if propertyBag.Contains("HardwareProfile") {
		var hardwareProfile v20220301s.VirtualMachineScaleSetHardwareProfile_STATUS
		err := propertyBag.Pull("HardwareProfile", &hardwareProfile)
		if err != nil {
			return errors.Wrap(err, "pulling 'HardwareProfile' from propertyBag")
		}

		destination.HardwareProfile = &hardwareProfile
	} else {
		destination.HardwareProfile = nil
	}

	// LicenseType
	destination.LicenseType = genruntime.ClonePointerToString(profile.LicenseType)

	// NetworkProfile
	if profile.NetworkProfile != nil {
		var networkProfile v20220301s.VirtualMachineScaleSetNetworkProfile_STATUS
		err := profile.NetworkProfile.AssignProperties_To_VirtualMachineScaleSetNetworkProfile_STATUS(&networkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetNetworkProfile_STATUS() to populate field NetworkProfile")
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// OsProfile
	if profile.OsProfile != nil {
		var osProfile v20220301s.VirtualMachineScaleSetOSProfile_STATUS
		err := profile.OsProfile.AssignProperties_To_VirtualMachineScaleSetOSProfile_STATUS(&osProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetOSProfile_STATUS() to populate field OsProfile")
		}
		destination.OsProfile = &osProfile
	} else {
		destination.OsProfile = nil
	}

	// Priority
	destination.Priority = genruntime.ClonePointerToString(profile.Priority)

	// ScheduledEventsProfile
	if profile.ScheduledEventsProfile != nil {
		var scheduledEventsProfile v20220301s.ScheduledEventsProfile_STATUS
		err := profile.ScheduledEventsProfile.AssignProperties_To_ScheduledEventsProfile_STATUS(&scheduledEventsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ScheduledEventsProfile_STATUS() to populate field ScheduledEventsProfile")
		}
		destination.ScheduledEventsProfile = &scheduledEventsProfile
	} else {
		destination.ScheduledEventsProfile = nil
	}

	// SecurityProfile
	if profile.SecurityProfile != nil {
		var securityProfile v20220301s.SecurityProfile_STATUS
		err := profile.SecurityProfile.AssignProperties_To_SecurityProfile_STATUS(&securityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SecurityProfile_STATUS() to populate field SecurityProfile")
		}
		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// StorageProfile
	if profile.StorageProfile != nil {
		var storageProfile v20220301s.VirtualMachineScaleSetStorageProfile_STATUS
		err := profile.StorageProfile.AssignProperties_To_VirtualMachineScaleSetStorageProfile_STATUS(&storageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetStorageProfile_STATUS() to populate field StorageProfile")
		}
		destination.StorageProfile = &storageProfile
	} else {
		destination.StorageProfile = nil
	}

	// UserData
	if propertyBag.Contains("UserData") {
		var userDatum string
		err := propertyBag.Pull("UserData", &userDatum)
		if err != nil {
			return errors.Wrap(err, "pulling 'UserData' from propertyBag")
		}

		destination.UserData = &userDatum
	} else {
		destination.UserData = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetVMProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForVirtualMachineScaleSetVMProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForAutomaticRepairsPolicy interface {
	AssignPropertiesFrom(src *v20220301s.AutomaticRepairsPolicy) error
	AssignPropertiesTo(dst *v20220301s.AutomaticRepairsPolicy) error
}

type augmentConversionForAutomaticRepairsPolicy_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.AutomaticRepairsPolicy_STATUS) error
	AssignPropertiesTo(dst *v20220301s.AutomaticRepairsPolicy_STATUS) error
}

type augmentConversionForScaleInPolicy interface {
	AssignPropertiesFrom(src *v20220301s.ScaleInPolicy) error
	AssignPropertiesTo(dst *v20220301s.ScaleInPolicy) error
}

type augmentConversionForScaleInPolicy_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.ScaleInPolicy_STATUS) error
	AssignPropertiesTo(dst *v20220301s.ScaleInPolicy_STATUS) error
}

type augmentConversionForSku interface {
	AssignPropertiesFrom(src *v20220301s.Sku) error
	AssignPropertiesTo(dst *v20220301s.Sku) error
}

type augmentConversionForSku_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.Sku_STATUS) error
	AssignPropertiesTo(dst *v20220301s.Sku_STATUS) error
}

type augmentConversionForUpgradePolicy interface {
	AssignPropertiesFrom(src *v20220301s.UpgradePolicy) error
	AssignPropertiesTo(dst *v20220301s.UpgradePolicy) error
}

type augmentConversionForUpgradePolicy_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.UpgradePolicy_STATUS) error
	AssignPropertiesTo(dst *v20220301s.UpgradePolicy_STATUS) error
}

type augmentConversionForVirtualMachineScaleSetIdentity interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSetIdentity) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSetIdentity) error
}

type augmentConversionForVirtualMachineScaleSetIdentity_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSetIdentity_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSetIdentity_STATUS) error
}

type augmentConversionForVirtualMachineScaleSetOperatorSpec interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSetOperatorSpec) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSetOperatorSpec) error
}

type augmentConversionForVirtualMachineScaleSetVMProfile interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSetVMProfile) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSetVMProfile) error
}

type augmentConversionForVirtualMachineScaleSetVMProfile_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSetVMProfile_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSetVMProfile_STATUS) error
}

// Storage version of v1api20201201.AutomaticOSUpgradePolicy
// The configuration parameters used for performing automatic OS upgrade.
type AutomaticOSUpgradePolicy struct {
	DisableAutomaticRollback *bool                  `json:"disableAutomaticRollback,omitempty"`
	EnableAutomaticOSUpgrade *bool                  `json:"enableAutomaticOSUpgrade,omitempty"`
	PropertyBag              genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_AutomaticOSUpgradePolicy populates our AutomaticOSUpgradePolicy from the provided source AutomaticOSUpgradePolicy
func (policy *AutomaticOSUpgradePolicy) AssignProperties_From_AutomaticOSUpgradePolicy(source *v20220301s.AutomaticOSUpgradePolicy) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DisableAutomaticRollback
	if source.DisableAutomaticRollback != nil {
		disableAutomaticRollback := *source.DisableAutomaticRollback
		policy.DisableAutomaticRollback = &disableAutomaticRollback
	} else {
		policy.DisableAutomaticRollback = nil
	}

	// EnableAutomaticOSUpgrade
	if source.EnableAutomaticOSUpgrade != nil {
		enableAutomaticOSUpgrade := *source.EnableAutomaticOSUpgrade
		policy.EnableAutomaticOSUpgrade = &enableAutomaticOSUpgrade
	} else {
		policy.EnableAutomaticOSUpgrade = nil
	}

	// UseRollingUpgradePolicy
	if source.UseRollingUpgradePolicy != nil {
		propertyBag.Add("UseRollingUpgradePolicy", *source.UseRollingUpgradePolicy)
	} else {
		propertyBag.Remove("UseRollingUpgradePolicy")
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		policy.PropertyBag = propertyBag
	} else {
		policy.PropertyBag = nil
	}

	// Invoke the augmentConversionForAutomaticOSUpgradePolicy interface (if implemented) to customize the conversion
	var policyAsAny any = policy
	if augmentedPolicy, ok := policyAsAny.(augmentConversionForAutomaticOSUpgradePolicy); ok {
		err := augmentedPolicy.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AutomaticOSUpgradePolicy populates the provided destination AutomaticOSUpgradePolicy from our AutomaticOSUpgradePolicy
func (policy *AutomaticOSUpgradePolicy) AssignProperties_To_AutomaticOSUpgradePolicy(destination *v20220301s.AutomaticOSUpgradePolicy) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(policy.PropertyBag)

	// DisableAutomaticRollback
	if policy.DisableAutomaticRollback != nil {
		disableAutomaticRollback := *policy.DisableAutomaticRollback
		destination.DisableAutomaticRollback = &disableAutomaticRollback
	} else {
		destination.DisableAutomaticRollback = nil
	}

	// EnableAutomaticOSUpgrade
	if policy.EnableAutomaticOSUpgrade != nil {
		enableAutomaticOSUpgrade := *policy.EnableAutomaticOSUpgrade
		destination.EnableAutomaticOSUpgrade = &enableAutomaticOSUpgrade
	} else {
		destination.EnableAutomaticOSUpgrade = nil
	}

	// UseRollingUpgradePolicy
	if propertyBag.Contains("UseRollingUpgradePolicy") {
		var useRollingUpgradePolicy bool
		err := propertyBag.Pull("UseRollingUpgradePolicy", &useRollingUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "pulling 'UseRollingUpgradePolicy' from propertyBag")
		}

		destination.UseRollingUpgradePolicy = &useRollingUpgradePolicy
	} else {
		destination.UseRollingUpgradePolicy = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAutomaticOSUpgradePolicy interface (if implemented) to customize the conversion
	var policyAsAny any = policy
	if augmentedPolicy, ok := policyAsAny.(augmentConversionForAutomaticOSUpgradePolicy); ok {
		err := augmentedPolicy.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.AutomaticOSUpgradePolicy_STATUS
// The configuration parameters used for performing automatic OS upgrade.
type AutomaticOSUpgradePolicy_STATUS struct {
	DisableAutomaticRollback *bool                  `json:"disableAutomaticRollback,omitempty"`
	EnableAutomaticOSUpgrade *bool                  `json:"enableAutomaticOSUpgrade,omitempty"`
	PropertyBag              genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_AutomaticOSUpgradePolicy_STATUS populates our AutomaticOSUpgradePolicy_STATUS from the provided source AutomaticOSUpgradePolicy_STATUS
func (policy *AutomaticOSUpgradePolicy_STATUS) AssignProperties_From_AutomaticOSUpgradePolicy_STATUS(source *v20220301s.AutomaticOSUpgradePolicy_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DisableAutomaticRollback
	if source.DisableAutomaticRollback != nil {
		disableAutomaticRollback := *source.DisableAutomaticRollback
		policy.DisableAutomaticRollback = &disableAutomaticRollback
	} else {
		policy.DisableAutomaticRollback = nil
	}

	// EnableAutomaticOSUpgrade
	if source.EnableAutomaticOSUpgrade != nil {
		enableAutomaticOSUpgrade := *source.EnableAutomaticOSUpgrade
		policy.EnableAutomaticOSUpgrade = &enableAutomaticOSUpgrade
	} else {
		policy.EnableAutomaticOSUpgrade = nil
	}

	// UseRollingUpgradePolicy
	if source.UseRollingUpgradePolicy != nil {
		propertyBag.Add("UseRollingUpgradePolicy", *source.UseRollingUpgradePolicy)
	} else {
		propertyBag.Remove("UseRollingUpgradePolicy")
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		policy.PropertyBag = propertyBag
	} else {
		policy.PropertyBag = nil
	}

	// Invoke the augmentConversionForAutomaticOSUpgradePolicy_STATUS interface (if implemented) to customize the conversion
	var policyAsAny any = policy
	if augmentedPolicy, ok := policyAsAny.(augmentConversionForAutomaticOSUpgradePolicy_STATUS); ok {
		err := augmentedPolicy.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_AutomaticOSUpgradePolicy_STATUS populates the provided destination AutomaticOSUpgradePolicy_STATUS from our AutomaticOSUpgradePolicy_STATUS
func (policy *AutomaticOSUpgradePolicy_STATUS) AssignProperties_To_AutomaticOSUpgradePolicy_STATUS(destination *v20220301s.AutomaticOSUpgradePolicy_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(policy.PropertyBag)

	// DisableAutomaticRollback
	if policy.DisableAutomaticRollback != nil {
		disableAutomaticRollback := *policy.DisableAutomaticRollback
		destination.DisableAutomaticRollback = &disableAutomaticRollback
	} else {
		destination.DisableAutomaticRollback = nil
	}

	// EnableAutomaticOSUpgrade
	if policy.EnableAutomaticOSUpgrade != nil {
		enableAutomaticOSUpgrade := *policy.EnableAutomaticOSUpgrade
		destination.EnableAutomaticOSUpgrade = &enableAutomaticOSUpgrade
	} else {
		destination.EnableAutomaticOSUpgrade = nil
	}

	// UseRollingUpgradePolicy
	if propertyBag.Contains("UseRollingUpgradePolicy") {
		var useRollingUpgradePolicy bool
		err := propertyBag.Pull("UseRollingUpgradePolicy", &useRollingUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "pulling 'UseRollingUpgradePolicy' from propertyBag")
		}

		destination.UseRollingUpgradePolicy = &useRollingUpgradePolicy
	} else {
		destination.UseRollingUpgradePolicy = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForAutomaticOSUpgradePolicy_STATUS interface (if implemented) to customize the conversion
	var policyAsAny any = policy
	if augmentedPolicy, ok := policyAsAny.(augmentConversionForAutomaticOSUpgradePolicy_STATUS); ok {
		err := augmentedPolicy.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.RollingUpgradePolicy
// The configuration parameters used while performing a rolling upgrade.
type RollingUpgradePolicy struct {
	EnableCrossZoneUpgrade              *bool                  `json:"enableCrossZoneUpgrade,omitempty"`
	MaxBatchInstancePercent             *int                   `json:"maxBatchInstancePercent,omitempty"`
	MaxUnhealthyInstancePercent         *int                   `json:"maxUnhealthyInstancePercent,omitempty"`
	MaxUnhealthyUpgradedInstancePercent *int                   `json:"maxUnhealthyUpgradedInstancePercent,omitempty"`
	PauseTimeBetweenBatches             *string                `json:"pauseTimeBetweenBatches,omitempty"`
	PrioritizeUnhealthyInstances        *bool                  `json:"prioritizeUnhealthyInstances,omitempty"`
	PropertyBag                         genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_RollingUpgradePolicy populates our RollingUpgradePolicy from the provided source RollingUpgradePolicy
func (policy *RollingUpgradePolicy) AssignProperties_From_RollingUpgradePolicy(source *v20220301s.RollingUpgradePolicy) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// EnableCrossZoneUpgrade
	if source.EnableCrossZoneUpgrade != nil {
		enableCrossZoneUpgrade := *source.EnableCrossZoneUpgrade
		policy.EnableCrossZoneUpgrade = &enableCrossZoneUpgrade
	} else {
		policy.EnableCrossZoneUpgrade = nil
	}

	// MaxBatchInstancePercent
	policy.MaxBatchInstancePercent = genruntime.ClonePointerToInt(source.MaxBatchInstancePercent)

	// MaxUnhealthyInstancePercent
	policy.MaxUnhealthyInstancePercent = genruntime.ClonePointerToInt(source.MaxUnhealthyInstancePercent)

	// MaxUnhealthyUpgradedInstancePercent
	policy.MaxUnhealthyUpgradedInstancePercent = genruntime.ClonePointerToInt(source.MaxUnhealthyUpgradedInstancePercent)

	// PauseTimeBetweenBatches
	policy.PauseTimeBetweenBatches = genruntime.ClonePointerToString(source.PauseTimeBetweenBatches)

	// PrioritizeUnhealthyInstances
	if source.PrioritizeUnhealthyInstances != nil {
		prioritizeUnhealthyInstance := *source.PrioritizeUnhealthyInstances
		policy.PrioritizeUnhealthyInstances = &prioritizeUnhealthyInstance
	} else {
		policy.PrioritizeUnhealthyInstances = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		policy.PropertyBag = propertyBag
	} else {
		policy.PropertyBag = nil
	}

	// Invoke the augmentConversionForRollingUpgradePolicy interface (if implemented) to customize the conversion
	var policyAsAny any = policy
	if augmentedPolicy, ok := policyAsAny.(augmentConversionForRollingUpgradePolicy); ok {
		err := augmentedPolicy.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_RollingUpgradePolicy populates the provided destination RollingUpgradePolicy from our RollingUpgradePolicy
func (policy *RollingUpgradePolicy) AssignProperties_To_RollingUpgradePolicy(destination *v20220301s.RollingUpgradePolicy) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(policy.PropertyBag)

	// EnableCrossZoneUpgrade
	if policy.EnableCrossZoneUpgrade != nil {
		enableCrossZoneUpgrade := *policy.EnableCrossZoneUpgrade
		destination.EnableCrossZoneUpgrade = &enableCrossZoneUpgrade
	} else {
		destination.EnableCrossZoneUpgrade = nil
	}

	// MaxBatchInstancePercent
	destination.MaxBatchInstancePercent = genruntime.ClonePointerToInt(policy.MaxBatchInstancePercent)

	// MaxUnhealthyInstancePercent
	destination.MaxUnhealthyInstancePercent = genruntime.ClonePointerToInt(policy.MaxUnhealthyInstancePercent)

	// MaxUnhealthyUpgradedInstancePercent
	destination.MaxUnhealthyUpgradedInstancePercent = genruntime.ClonePointerToInt(policy.MaxUnhealthyUpgradedInstancePercent)

	// PauseTimeBetweenBatches
	destination.PauseTimeBetweenBatches = genruntime.ClonePointerToString(policy.PauseTimeBetweenBatches)

	// PrioritizeUnhealthyInstances
	if policy.PrioritizeUnhealthyInstances != nil {
		prioritizeUnhealthyInstance := *policy.PrioritizeUnhealthyInstances
		destination.PrioritizeUnhealthyInstances = &prioritizeUnhealthyInstance
	} else {
		destination.PrioritizeUnhealthyInstances = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForRollingUpgradePolicy interface (if implemented) to customize the conversion
	var policyAsAny any = policy
	if augmentedPolicy, ok := policyAsAny.(augmentConversionForRollingUpgradePolicy); ok {
		err := augmentedPolicy.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.RollingUpgradePolicy_STATUS
// The configuration parameters used while performing a rolling upgrade.
type RollingUpgradePolicy_STATUS struct {
	EnableCrossZoneUpgrade              *bool                  `json:"enableCrossZoneUpgrade,omitempty"`
	MaxBatchInstancePercent             *int                   `json:"maxBatchInstancePercent,omitempty"`
	MaxUnhealthyInstancePercent         *int                   `json:"maxUnhealthyInstancePercent,omitempty"`
	MaxUnhealthyUpgradedInstancePercent *int                   `json:"maxUnhealthyUpgradedInstancePercent,omitempty"`
	PauseTimeBetweenBatches             *string                `json:"pauseTimeBetweenBatches,omitempty"`
	PrioritizeUnhealthyInstances        *bool                  `json:"prioritizeUnhealthyInstances,omitempty"`
	PropertyBag                         genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_RollingUpgradePolicy_STATUS populates our RollingUpgradePolicy_STATUS from the provided source RollingUpgradePolicy_STATUS
func (policy *RollingUpgradePolicy_STATUS) AssignProperties_From_RollingUpgradePolicy_STATUS(source *v20220301s.RollingUpgradePolicy_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// EnableCrossZoneUpgrade
	if source.EnableCrossZoneUpgrade != nil {
		enableCrossZoneUpgrade := *source.EnableCrossZoneUpgrade
		policy.EnableCrossZoneUpgrade = &enableCrossZoneUpgrade
	} else {
		policy.EnableCrossZoneUpgrade = nil
	}

	// MaxBatchInstancePercent
	policy.MaxBatchInstancePercent = genruntime.ClonePointerToInt(source.MaxBatchInstancePercent)

	// MaxUnhealthyInstancePercent
	policy.MaxUnhealthyInstancePercent = genruntime.ClonePointerToInt(source.MaxUnhealthyInstancePercent)

	// MaxUnhealthyUpgradedInstancePercent
	policy.MaxUnhealthyUpgradedInstancePercent = genruntime.ClonePointerToInt(source.MaxUnhealthyUpgradedInstancePercent)

	// PauseTimeBetweenBatches
	policy.PauseTimeBetweenBatches = genruntime.ClonePointerToString(source.PauseTimeBetweenBatches)

	// PrioritizeUnhealthyInstances
	if source.PrioritizeUnhealthyInstances != nil {
		prioritizeUnhealthyInstance := *source.PrioritizeUnhealthyInstances
		policy.PrioritizeUnhealthyInstances = &prioritizeUnhealthyInstance
	} else {
		policy.PrioritizeUnhealthyInstances = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		policy.PropertyBag = propertyBag
	} else {
		policy.PropertyBag = nil
	}

	// Invoke the augmentConversionForRollingUpgradePolicy_STATUS interface (if implemented) to customize the conversion
	var policyAsAny any = policy
	if augmentedPolicy, ok := policyAsAny.(augmentConversionForRollingUpgradePolicy_STATUS); ok {
		err := augmentedPolicy.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_RollingUpgradePolicy_STATUS populates the provided destination RollingUpgradePolicy_STATUS from our RollingUpgradePolicy_STATUS
func (policy *RollingUpgradePolicy_STATUS) AssignProperties_To_RollingUpgradePolicy_STATUS(destination *v20220301s.RollingUpgradePolicy_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(policy.PropertyBag)

	// EnableCrossZoneUpgrade
	if policy.EnableCrossZoneUpgrade != nil {
		enableCrossZoneUpgrade := *policy.EnableCrossZoneUpgrade
		destination.EnableCrossZoneUpgrade = &enableCrossZoneUpgrade
	} else {
		destination.EnableCrossZoneUpgrade = nil
	}

	// MaxBatchInstancePercent
	destination.MaxBatchInstancePercent = genruntime.ClonePointerToInt(policy.MaxBatchInstancePercent)

	// MaxUnhealthyInstancePercent
	destination.MaxUnhealthyInstancePercent = genruntime.ClonePointerToInt(policy.MaxUnhealthyInstancePercent)

	// MaxUnhealthyUpgradedInstancePercent
	destination.MaxUnhealthyUpgradedInstancePercent = genruntime.ClonePointerToInt(policy.MaxUnhealthyUpgradedInstancePercent)

	// PauseTimeBetweenBatches
	destination.PauseTimeBetweenBatches = genruntime.ClonePointerToString(policy.PauseTimeBetweenBatches)

	// PrioritizeUnhealthyInstances
	if policy.PrioritizeUnhealthyInstances != nil {
		prioritizeUnhealthyInstance := *policy.PrioritizeUnhealthyInstances
		destination.PrioritizeUnhealthyInstances = &prioritizeUnhealthyInstance
	} else {
		destination.PrioritizeUnhealthyInstances = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForRollingUpgradePolicy_STATUS interface (if implemented) to customize the conversion
	var policyAsAny any = policy
	if augmentedPolicy, ok := policyAsAny.(augmentConversionForRollingUpgradePolicy_STATUS); ok {
		err := augmentedPolicy.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.ScheduledEventsProfile
type ScheduledEventsProfile struct {
	PropertyBag                  genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	TerminateNotificationProfile *TerminateNotificationProfile `json:"terminateNotificationProfile,omitempty"`
}

// AssignProperties_From_ScheduledEventsProfile populates our ScheduledEventsProfile from the provided source ScheduledEventsProfile
func (profile *ScheduledEventsProfile) AssignProperties_From_ScheduledEventsProfile(source *v20220301s.ScheduledEventsProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// TerminateNotificationProfile
	if source.TerminateNotificationProfile != nil {
		var terminateNotificationProfile TerminateNotificationProfile
		err := terminateNotificationProfile.AssignProperties_From_TerminateNotificationProfile(source.TerminateNotificationProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_TerminateNotificationProfile() to populate field TerminateNotificationProfile")
		}
		profile.TerminateNotificationProfile = &terminateNotificationProfile
	} else {
		profile.TerminateNotificationProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForScheduledEventsProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForScheduledEventsProfile); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ScheduledEventsProfile populates the provided destination ScheduledEventsProfile from our ScheduledEventsProfile
func (profile *ScheduledEventsProfile) AssignProperties_To_ScheduledEventsProfile(destination *v20220301s.ScheduledEventsProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// TerminateNotificationProfile
	if profile.TerminateNotificationProfile != nil {
		var terminateNotificationProfile v20220301s.TerminateNotificationProfile
		err := profile.TerminateNotificationProfile.AssignProperties_To_TerminateNotificationProfile(&terminateNotificationProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_TerminateNotificationProfile() to populate field TerminateNotificationProfile")
		}
		destination.TerminateNotificationProfile = &terminateNotificationProfile
	} else {
		destination.TerminateNotificationProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForScheduledEventsProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForScheduledEventsProfile); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.ScheduledEventsProfile_STATUS
type ScheduledEventsProfile_STATUS struct {
	PropertyBag                  genruntime.PropertyBag               `json:"$propertyBag,omitempty"`
	TerminateNotificationProfile *TerminateNotificationProfile_STATUS `json:"terminateNotificationProfile,omitempty"`
}

// AssignProperties_From_ScheduledEventsProfile_STATUS populates our ScheduledEventsProfile_STATUS from the provided source ScheduledEventsProfile_STATUS
func (profile *ScheduledEventsProfile_STATUS) AssignProperties_From_ScheduledEventsProfile_STATUS(source *v20220301s.ScheduledEventsProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// TerminateNotificationProfile
	if source.TerminateNotificationProfile != nil {
		var terminateNotificationProfile TerminateNotificationProfile_STATUS
		err := terminateNotificationProfile.AssignProperties_From_TerminateNotificationProfile_STATUS(source.TerminateNotificationProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_TerminateNotificationProfile_STATUS() to populate field TerminateNotificationProfile")
		}
		profile.TerminateNotificationProfile = &terminateNotificationProfile
	} else {
		profile.TerminateNotificationProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForScheduledEventsProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForScheduledEventsProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ScheduledEventsProfile_STATUS populates the provided destination ScheduledEventsProfile_STATUS from our ScheduledEventsProfile_STATUS
func (profile *ScheduledEventsProfile_STATUS) AssignProperties_To_ScheduledEventsProfile_STATUS(destination *v20220301s.ScheduledEventsProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// TerminateNotificationProfile
	if profile.TerminateNotificationProfile != nil {
		var terminateNotificationProfile v20220301s.TerminateNotificationProfile_STATUS
		err := profile.TerminateNotificationProfile.AssignProperties_To_TerminateNotificationProfile_STATUS(&terminateNotificationProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_TerminateNotificationProfile_STATUS() to populate field TerminateNotificationProfile")
		}
		destination.TerminateNotificationProfile = &terminateNotificationProfile
	} else {
		destination.TerminateNotificationProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForScheduledEventsProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForScheduledEventsProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineScaleSetExtensionProfile
// Describes a virtual machine scale set extension profile.
type VirtualMachineScaleSetExtensionProfile struct {
	Extensions           []VirtualMachineScaleSetExtension `json:"extensions,omitempty"`
	ExtensionsTimeBudget *string                           `json:"extensionsTimeBudget,omitempty"`
	PropertyBag          genruntime.PropertyBag            `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_VirtualMachineScaleSetExtensionProfile populates our VirtualMachineScaleSetExtensionProfile from the provided source VirtualMachineScaleSetExtensionProfile
func (profile *VirtualMachineScaleSetExtensionProfile) AssignProperties_From_VirtualMachineScaleSetExtensionProfile(source *v20220301s.VirtualMachineScaleSetExtensionProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Extensions
	if source.Extensions != nil {
		extensionList := make([]VirtualMachineScaleSetExtension, len(source.Extensions))
		for extensionIndex, extensionItem := range source.Extensions {
			// Shadow the loop variable to avoid aliasing
			extensionItem := extensionItem
			var extension VirtualMachineScaleSetExtension
			err := extension.AssignProperties_From_VirtualMachineScaleSetExtension(&extensionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetExtension() to populate field Extensions")
			}
			extensionList[extensionIndex] = extension
		}
		profile.Extensions = extensionList
	} else {
		profile.Extensions = nil
	}

	// ExtensionsTimeBudget
	profile.ExtensionsTimeBudget = genruntime.ClonePointerToString(source.ExtensionsTimeBudget)

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetExtensionProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForVirtualMachineScaleSetExtensionProfile); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetExtensionProfile populates the provided destination VirtualMachineScaleSetExtensionProfile from our VirtualMachineScaleSetExtensionProfile
func (profile *VirtualMachineScaleSetExtensionProfile) AssignProperties_To_VirtualMachineScaleSetExtensionProfile(destination *v20220301s.VirtualMachineScaleSetExtensionProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// Extensions
	if profile.Extensions != nil {
		extensionList := make([]v20220301s.VirtualMachineScaleSetExtension, len(profile.Extensions))
		for extensionIndex, extensionItem := range profile.Extensions {
			// Shadow the loop variable to avoid aliasing
			extensionItem := extensionItem
			var extension v20220301s.VirtualMachineScaleSetExtension
			err := extensionItem.AssignProperties_To_VirtualMachineScaleSetExtension(&extension)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetExtension() to populate field Extensions")
			}
			extensionList[extensionIndex] = extension
		}
		destination.Extensions = extensionList
	} else {
		destination.Extensions = nil
	}

	// ExtensionsTimeBudget
	destination.ExtensionsTimeBudget = genruntime.ClonePointerToString(profile.ExtensionsTimeBudget)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetExtensionProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForVirtualMachineScaleSetExtensionProfile); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineScaleSetExtensionProfile_STATUS
// Describes a virtual machine scale set extension profile.
type VirtualMachineScaleSetExtensionProfile_STATUS struct {
	Extensions           []VirtualMachineScaleSetExtension_STATUS `json:"extensions,omitempty"`
	ExtensionsTimeBudget *string                                  `json:"extensionsTimeBudget,omitempty"`
	PropertyBag          genruntime.PropertyBag                   `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_VirtualMachineScaleSetExtensionProfile_STATUS populates our VirtualMachineScaleSetExtensionProfile_STATUS from the provided source VirtualMachineScaleSetExtensionProfile_STATUS
func (profile *VirtualMachineScaleSetExtensionProfile_STATUS) AssignProperties_From_VirtualMachineScaleSetExtensionProfile_STATUS(source *v20220301s.VirtualMachineScaleSetExtensionProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Extensions
	if source.Extensions != nil {
		extensionList := make([]VirtualMachineScaleSetExtension_STATUS, len(source.Extensions))
		for extensionIndex, extensionItem := range source.Extensions {
			// Shadow the loop variable to avoid aliasing
			extensionItem := extensionItem
			var extension VirtualMachineScaleSetExtension_STATUS
			err := extension.AssignProperties_From_VirtualMachineScaleSetExtension_STATUS(&extensionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetExtension_STATUS() to populate field Extensions")
			}
			extensionList[extensionIndex] = extension
		}
		profile.Extensions = extensionList
	} else {
		profile.Extensions = nil
	}

	// ExtensionsTimeBudget
	profile.ExtensionsTimeBudget = genruntime.ClonePointerToString(source.ExtensionsTimeBudget)

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetExtensionProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForVirtualMachineScaleSetExtensionProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetExtensionProfile_STATUS populates the provided destination VirtualMachineScaleSetExtensionProfile_STATUS from our VirtualMachineScaleSetExtensionProfile_STATUS
func (profile *VirtualMachineScaleSetExtensionProfile_STATUS) AssignProperties_To_VirtualMachineScaleSetExtensionProfile_STATUS(destination *v20220301s.VirtualMachineScaleSetExtensionProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// Extensions
	if profile.Extensions != nil {
		extensionList := make([]v20220301s.VirtualMachineScaleSetExtension_STATUS, len(profile.Extensions))
		for extensionIndex, extensionItem := range profile.Extensions {
			// Shadow the loop variable to avoid aliasing
			extensionItem := extensionItem
			var extension v20220301s.VirtualMachineScaleSetExtension_STATUS
			err := extensionItem.AssignProperties_To_VirtualMachineScaleSetExtension_STATUS(&extension)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetExtension_STATUS() to populate field Extensions")
			}
			extensionList[extensionIndex] = extension
		}
		destination.Extensions = extensionList
	} else {
		destination.Extensions = nil
	}

	// ExtensionsTimeBudget
	destination.ExtensionsTimeBudget = genruntime.ClonePointerToString(profile.ExtensionsTimeBudget)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetExtensionProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForVirtualMachineScaleSetExtensionProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS
type VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS struct {
	ClientId    *string                `json:"clientId,omitempty"`
	PrincipalId *string                `json:"principalId,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS populates our VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS from the provided source VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS
func (identities *VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS) AssignProperties_From_VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS(source *v20220301s.VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ClientId
	identities.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// PrincipalId
	identities.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		identities.PropertyBag = propertyBag
	} else {
		identities.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS interface (if implemented) to customize the conversion
	var identitiesAsAny any = identities
	if augmentedIdentities, ok := identitiesAsAny.(augmentConversionForVirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS); ok {
		err := augmentedIdentities.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS populates the provided destination VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS from our VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS
func (identities *VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS) AssignProperties_To_VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS(destination *v20220301s.VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(identities.PropertyBag)

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identities.ClientId)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identities.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS interface (if implemented) to customize the conversion
	var identitiesAsAny any = identities
	if augmentedIdentities, ok := identitiesAsAny.(augmentConversionForVirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS); ok {
		err := augmentedIdentities.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineScaleSetNetworkProfile
// Describes a virtual machine scale set network profile.
type VirtualMachineScaleSetNetworkProfile struct {
	HealthProbe                    *ApiEntityReference                          `json:"healthProbe,omitempty"`
	NetworkInterfaceConfigurations []VirtualMachineScaleSetNetworkConfiguration `json:"networkInterfaceConfigurations,omitempty"`
	PropertyBag                    genruntime.PropertyBag                       `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_VirtualMachineScaleSetNetworkProfile populates our VirtualMachineScaleSetNetworkProfile from the provided source VirtualMachineScaleSetNetworkProfile
func (profile *VirtualMachineScaleSetNetworkProfile) AssignProperties_From_VirtualMachineScaleSetNetworkProfile(source *v20220301s.VirtualMachineScaleSetNetworkProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// HealthProbe
	if source.HealthProbe != nil {
		var healthProbe ApiEntityReference
		err := healthProbe.AssignProperties_From_ApiEntityReference(source.HealthProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApiEntityReference() to populate field HealthProbe")
		}
		profile.HealthProbe = &healthProbe
	} else {
		profile.HealthProbe = nil
	}

	// NetworkApiVersion
	if source.NetworkApiVersion != nil {
		propertyBag.Add("NetworkApiVersion", *source.NetworkApiVersion)
	} else {
		propertyBag.Remove("NetworkApiVersion")
	}

	// NetworkInterfaceConfigurations
	if source.NetworkInterfaceConfigurations != nil {
		networkInterfaceConfigurationList := make([]VirtualMachineScaleSetNetworkConfiguration, len(source.NetworkInterfaceConfigurations))
		for networkInterfaceConfigurationIndex, networkInterfaceConfigurationItem := range source.NetworkInterfaceConfigurations {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceConfigurationItem := networkInterfaceConfigurationItem
			var networkInterfaceConfiguration VirtualMachineScaleSetNetworkConfiguration
			err := networkInterfaceConfiguration.AssignProperties_From_VirtualMachineScaleSetNetworkConfiguration(&networkInterfaceConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetNetworkConfiguration() to populate field NetworkInterfaceConfigurations")
			}
			networkInterfaceConfigurationList[networkInterfaceConfigurationIndex] = networkInterfaceConfiguration
		}
		profile.NetworkInterfaceConfigurations = networkInterfaceConfigurationList
	} else {
		profile.NetworkInterfaceConfigurations = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetNetworkProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForVirtualMachineScaleSetNetworkProfile); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetNetworkProfile populates the provided destination VirtualMachineScaleSetNetworkProfile from our VirtualMachineScaleSetNetworkProfile
func (profile *VirtualMachineScaleSetNetworkProfile) AssignProperties_To_VirtualMachineScaleSetNetworkProfile(destination *v20220301s.VirtualMachineScaleSetNetworkProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// HealthProbe
	if profile.HealthProbe != nil {
		var healthProbe v20220301s.ApiEntityReference
		err := profile.HealthProbe.AssignProperties_To_ApiEntityReference(&healthProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApiEntityReference() to populate field HealthProbe")
		}
		destination.HealthProbe = &healthProbe
	} else {
		destination.HealthProbe = nil
	}

	// NetworkApiVersion
	if propertyBag.Contains("NetworkApiVersion") {
		var networkApiVersion string
		err := propertyBag.Pull("NetworkApiVersion", &networkApiVersion)
		if err != nil {
			return errors.Wrap(err, "pulling 'NetworkApiVersion' from propertyBag")
		}

		destination.NetworkApiVersion = &networkApiVersion
	} else {
		destination.NetworkApiVersion = nil
	}

	// NetworkInterfaceConfigurations
	if profile.NetworkInterfaceConfigurations != nil {
		networkInterfaceConfigurationList := make([]v20220301s.VirtualMachineScaleSetNetworkConfiguration, len(profile.NetworkInterfaceConfigurations))
		for networkInterfaceConfigurationIndex, networkInterfaceConfigurationItem := range profile.NetworkInterfaceConfigurations {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceConfigurationItem := networkInterfaceConfigurationItem
			var networkInterfaceConfiguration v20220301s.VirtualMachineScaleSetNetworkConfiguration
			err := networkInterfaceConfigurationItem.AssignProperties_To_VirtualMachineScaleSetNetworkConfiguration(&networkInterfaceConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetNetworkConfiguration() to populate field NetworkInterfaceConfigurations")
			}
			networkInterfaceConfigurationList[networkInterfaceConfigurationIndex] = networkInterfaceConfiguration
		}
		destination.NetworkInterfaceConfigurations = networkInterfaceConfigurationList
	} else {
		destination.NetworkInterfaceConfigurations = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetNetworkProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForVirtualMachineScaleSetNetworkProfile); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineScaleSetNetworkProfile_STATUS
// Describes a virtual machine scale set network profile.
type VirtualMachineScaleSetNetworkProfile_STATUS struct {
	HealthProbe                    *ApiEntityReference_STATUS                          `json:"healthProbe,omitempty"`
	NetworkInterfaceConfigurations []VirtualMachineScaleSetNetworkConfiguration_STATUS `json:"networkInterfaceConfigurations,omitempty"`
	PropertyBag                    genruntime.PropertyBag                              `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_VirtualMachineScaleSetNetworkProfile_STATUS populates our VirtualMachineScaleSetNetworkProfile_STATUS from the provided source VirtualMachineScaleSetNetworkProfile_STATUS
func (profile *VirtualMachineScaleSetNetworkProfile_STATUS) AssignProperties_From_VirtualMachineScaleSetNetworkProfile_STATUS(source *v20220301s.VirtualMachineScaleSetNetworkProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// HealthProbe
	if source.HealthProbe != nil {
		var healthProbe ApiEntityReference_STATUS
		err := healthProbe.AssignProperties_From_ApiEntityReference_STATUS(source.HealthProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApiEntityReference_STATUS() to populate field HealthProbe")
		}
		profile.HealthProbe = &healthProbe
	} else {
		profile.HealthProbe = nil
	}

	// NetworkApiVersion
	if source.NetworkApiVersion != nil {
		propertyBag.Add("NetworkApiVersion", *source.NetworkApiVersion)
	} else {
		propertyBag.Remove("NetworkApiVersion")
	}

	// NetworkInterfaceConfigurations
	if source.NetworkInterfaceConfigurations != nil {
		networkInterfaceConfigurationList := make([]VirtualMachineScaleSetNetworkConfiguration_STATUS, len(source.NetworkInterfaceConfigurations))
		for networkInterfaceConfigurationIndex, networkInterfaceConfigurationItem := range source.NetworkInterfaceConfigurations {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceConfigurationItem := networkInterfaceConfigurationItem
			var networkInterfaceConfiguration VirtualMachineScaleSetNetworkConfiguration_STATUS
			err := networkInterfaceConfiguration.AssignProperties_From_VirtualMachineScaleSetNetworkConfiguration_STATUS(&networkInterfaceConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetNetworkConfiguration_STATUS() to populate field NetworkInterfaceConfigurations")
			}
			networkInterfaceConfigurationList[networkInterfaceConfigurationIndex] = networkInterfaceConfiguration
		}
		profile.NetworkInterfaceConfigurations = networkInterfaceConfigurationList
	} else {
		profile.NetworkInterfaceConfigurations = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetNetworkProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForVirtualMachineScaleSetNetworkProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetNetworkProfile_STATUS populates the provided destination VirtualMachineScaleSetNetworkProfile_STATUS from our VirtualMachineScaleSetNetworkProfile_STATUS
func (profile *VirtualMachineScaleSetNetworkProfile_STATUS) AssignProperties_To_VirtualMachineScaleSetNetworkProfile_STATUS(destination *v20220301s.VirtualMachineScaleSetNetworkProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// HealthProbe
	if profile.HealthProbe != nil {
		var healthProbe v20220301s.ApiEntityReference_STATUS
		err := profile.HealthProbe.AssignProperties_To_ApiEntityReference_STATUS(&healthProbe)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApiEntityReference_STATUS() to populate field HealthProbe")
		}
		destination.HealthProbe = &healthProbe
	} else {
		destination.HealthProbe = nil
	}

	// NetworkApiVersion
	if propertyBag.Contains("NetworkApiVersion") {
		var networkApiVersion string
		err := propertyBag.Pull("NetworkApiVersion", &networkApiVersion)
		if err != nil {
			return errors.Wrap(err, "pulling 'NetworkApiVersion' from propertyBag")
		}

		destination.NetworkApiVersion = &networkApiVersion
	} else {
		destination.NetworkApiVersion = nil
	}

	// NetworkInterfaceConfigurations
	if profile.NetworkInterfaceConfigurations != nil {
		networkInterfaceConfigurationList := make([]v20220301s.VirtualMachineScaleSetNetworkConfiguration_STATUS, len(profile.NetworkInterfaceConfigurations))
		for networkInterfaceConfigurationIndex, networkInterfaceConfigurationItem := range profile.NetworkInterfaceConfigurations {
			// Shadow the loop variable to avoid aliasing
			networkInterfaceConfigurationItem := networkInterfaceConfigurationItem
			var networkInterfaceConfiguration v20220301s.VirtualMachineScaleSetNetworkConfiguration_STATUS
			err := networkInterfaceConfigurationItem.AssignProperties_To_VirtualMachineScaleSetNetworkConfiguration_STATUS(&networkInterfaceConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetNetworkConfiguration_STATUS() to populate field NetworkInterfaceConfigurations")
			}
			networkInterfaceConfigurationList[networkInterfaceConfigurationIndex] = networkInterfaceConfiguration
		}
		destination.NetworkInterfaceConfigurations = networkInterfaceConfigurationList
	} else {
		destination.NetworkInterfaceConfigurations = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetNetworkProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForVirtualMachineScaleSetNetworkProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineScaleSetOSProfile
// Describes a virtual machine scale set OS profile.
type VirtualMachineScaleSetOSProfile struct {
	AdminPassword        *genruntime.SecretReference `json:"adminPassword,omitempty"`
	AdminUsername        *string                     `json:"adminUsername,omitempty"`
	ComputerNamePrefix   *string                     `json:"computerNamePrefix,omitempty"`
	CustomData           *string                     `json:"customData,omitempty"`
	LinuxConfiguration   *LinuxConfiguration         `json:"linuxConfiguration,omitempty"`
	PropertyBag          genruntime.PropertyBag      `json:"$propertyBag,omitempty"`
	Secrets              []VaultSecretGroup          `json:"secrets,omitempty"`
	WindowsConfiguration *WindowsConfiguration       `json:"windowsConfiguration,omitempty"`
}

// AssignProperties_From_VirtualMachineScaleSetOSProfile populates our VirtualMachineScaleSetOSProfile from the provided source VirtualMachineScaleSetOSProfile
func (profile *VirtualMachineScaleSetOSProfile) AssignProperties_From_VirtualMachineScaleSetOSProfile(source *v20220301s.VirtualMachineScaleSetOSProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdminPassword
	if source.AdminPassword != nil {
		adminPassword := source.AdminPassword.Copy()
		profile.AdminPassword = &adminPassword
	} else {
		profile.AdminPassword = nil
	}

	// AdminUsername
	profile.AdminUsername = genruntime.ClonePointerToString(source.AdminUsername)

	// AllowExtensionOperations
	if source.AllowExtensionOperations != nil {
		propertyBag.Add("AllowExtensionOperations", *source.AllowExtensionOperations)
	} else {
		propertyBag.Remove("AllowExtensionOperations")
	}

	// ComputerNamePrefix
	profile.ComputerNamePrefix = genruntime.ClonePointerToString(source.ComputerNamePrefix)

	// CustomData
	profile.CustomData = genruntime.ClonePointerToString(source.CustomData)

	// LinuxConfiguration
	if source.LinuxConfiguration != nil {
		var linuxConfiguration LinuxConfiguration
		err := linuxConfiguration.AssignProperties_From_LinuxConfiguration(source.LinuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_LinuxConfiguration() to populate field LinuxConfiguration")
		}
		profile.LinuxConfiguration = &linuxConfiguration
	} else {
		profile.LinuxConfiguration = nil
	}

	// Secrets
	if source.Secrets != nil {
		secretList := make([]VaultSecretGroup, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret VaultSecretGroup
			err := secret.AssignProperties_From_VaultSecretGroup(&secretItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VaultSecretGroup() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		profile.Secrets = secretList
	} else {
		profile.Secrets = nil
	}

	// WindowsConfiguration
	if source.WindowsConfiguration != nil {
		var windowsConfiguration WindowsConfiguration
		err := windowsConfiguration.AssignProperties_From_WindowsConfiguration(source.WindowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WindowsConfiguration() to populate field WindowsConfiguration")
		}
		profile.WindowsConfiguration = &windowsConfiguration
	} else {
		profile.WindowsConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetOSProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForVirtualMachineScaleSetOSProfile); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetOSProfile populates the provided destination VirtualMachineScaleSetOSProfile from our VirtualMachineScaleSetOSProfile
func (profile *VirtualMachineScaleSetOSProfile) AssignProperties_To_VirtualMachineScaleSetOSProfile(destination *v20220301s.VirtualMachineScaleSetOSProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// AdminPassword
	if profile.AdminPassword != nil {
		adminPassword := profile.AdminPassword.Copy()
		destination.AdminPassword = &adminPassword
	} else {
		destination.AdminPassword = nil
	}

	// AdminUsername
	destination.AdminUsername = genruntime.ClonePointerToString(profile.AdminUsername)

	// AllowExtensionOperations
	if propertyBag.Contains("AllowExtensionOperations") {
		var allowExtensionOperation bool
		err := propertyBag.Pull("AllowExtensionOperations", &allowExtensionOperation)
		if err != nil {
			return errors.Wrap(err, "pulling 'AllowExtensionOperations' from propertyBag")
		}

		destination.AllowExtensionOperations = &allowExtensionOperation
	} else {
		destination.AllowExtensionOperations = nil
	}

	// ComputerNamePrefix
	destination.ComputerNamePrefix = genruntime.ClonePointerToString(profile.ComputerNamePrefix)

	// CustomData
	destination.CustomData = genruntime.ClonePointerToString(profile.CustomData)

	// LinuxConfiguration
	if profile.LinuxConfiguration != nil {
		var linuxConfiguration v20220301s.LinuxConfiguration
		err := profile.LinuxConfiguration.AssignProperties_To_LinuxConfiguration(&linuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_LinuxConfiguration() to populate field LinuxConfiguration")
		}
		destination.LinuxConfiguration = &linuxConfiguration
	} else {
		destination.LinuxConfiguration = nil
	}

	// Secrets
	if profile.Secrets != nil {
		secretList := make([]v20220301s.VaultSecretGroup, len(profile.Secrets))
		for secretIndex, secretItem := range profile.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret v20220301s.VaultSecretGroup
			err := secretItem.AssignProperties_To_VaultSecretGroup(&secret)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VaultSecretGroup() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		destination.Secrets = secretList
	} else {
		destination.Secrets = nil
	}

	// WindowsConfiguration
	if profile.WindowsConfiguration != nil {
		var windowsConfiguration v20220301s.WindowsConfiguration
		err := profile.WindowsConfiguration.AssignProperties_To_WindowsConfiguration(&windowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WindowsConfiguration() to populate field WindowsConfiguration")
		}
		destination.WindowsConfiguration = &windowsConfiguration
	} else {
		destination.WindowsConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetOSProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForVirtualMachineScaleSetOSProfile); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineScaleSetOSProfile_STATUS
// Describes a virtual machine scale set OS profile.
type VirtualMachineScaleSetOSProfile_STATUS struct {
	AdminUsername        *string                      `json:"adminUsername,omitempty"`
	ComputerNamePrefix   *string                      `json:"computerNamePrefix,omitempty"`
	CustomData           *string                      `json:"customData,omitempty"`
	LinuxConfiguration   *LinuxConfiguration_STATUS   `json:"linuxConfiguration,omitempty"`
	PropertyBag          genruntime.PropertyBag       `json:"$propertyBag,omitempty"`
	Secrets              []VaultSecretGroup_STATUS    `json:"secrets,omitempty"`
	WindowsConfiguration *WindowsConfiguration_STATUS `json:"windowsConfiguration,omitempty"`
}

// AssignProperties_From_VirtualMachineScaleSetOSProfile_STATUS populates our VirtualMachineScaleSetOSProfile_STATUS from the provided source VirtualMachineScaleSetOSProfile_STATUS
func (profile *VirtualMachineScaleSetOSProfile_STATUS) AssignProperties_From_VirtualMachineScaleSetOSProfile_STATUS(source *v20220301s.VirtualMachineScaleSetOSProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdminUsername
	profile.AdminUsername = genruntime.ClonePointerToString(source.AdminUsername)

	// AllowExtensionOperations
	if source.AllowExtensionOperations != nil {
		propertyBag.Add("AllowExtensionOperations", *source.AllowExtensionOperations)
	} else {
		propertyBag.Remove("AllowExtensionOperations")
	}

	// ComputerNamePrefix
	profile.ComputerNamePrefix = genruntime.ClonePointerToString(source.ComputerNamePrefix)

	// CustomData
	profile.CustomData = genruntime.ClonePointerToString(source.CustomData)

	// LinuxConfiguration
	if source.LinuxConfiguration != nil {
		var linuxConfiguration LinuxConfiguration_STATUS
		err := linuxConfiguration.AssignProperties_From_LinuxConfiguration_STATUS(source.LinuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_LinuxConfiguration_STATUS() to populate field LinuxConfiguration")
		}
		profile.LinuxConfiguration = &linuxConfiguration
	} else {
		profile.LinuxConfiguration = nil
	}

	// Secrets
	if source.Secrets != nil {
		secretList := make([]VaultSecretGroup_STATUS, len(source.Secrets))
		for secretIndex, secretItem := range source.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret VaultSecretGroup_STATUS
			err := secret.AssignProperties_From_VaultSecretGroup_STATUS(&secretItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VaultSecretGroup_STATUS() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		profile.Secrets = secretList
	} else {
		profile.Secrets = nil
	}

	// WindowsConfiguration
	if source.WindowsConfiguration != nil {
		var windowsConfiguration WindowsConfiguration_STATUS
		err := windowsConfiguration.AssignProperties_From_WindowsConfiguration_STATUS(source.WindowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_WindowsConfiguration_STATUS() to populate field WindowsConfiguration")
		}
		profile.WindowsConfiguration = &windowsConfiguration
	} else {
		profile.WindowsConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetOSProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForVirtualMachineScaleSetOSProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetOSProfile_STATUS populates the provided destination VirtualMachineScaleSetOSProfile_STATUS from our VirtualMachineScaleSetOSProfile_STATUS
func (profile *VirtualMachineScaleSetOSProfile_STATUS) AssignProperties_To_VirtualMachineScaleSetOSProfile_STATUS(destination *v20220301s.VirtualMachineScaleSetOSProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// AdminUsername
	destination.AdminUsername = genruntime.ClonePointerToString(profile.AdminUsername)

	// AllowExtensionOperations
	if propertyBag.Contains("AllowExtensionOperations") {
		var allowExtensionOperation bool
		err := propertyBag.Pull("AllowExtensionOperations", &allowExtensionOperation)
		if err != nil {
			return errors.Wrap(err, "pulling 'AllowExtensionOperations' from propertyBag")
		}

		destination.AllowExtensionOperations = &allowExtensionOperation
	} else {
		destination.AllowExtensionOperations = nil
	}

	// ComputerNamePrefix
	destination.ComputerNamePrefix = genruntime.ClonePointerToString(profile.ComputerNamePrefix)

	// CustomData
	destination.CustomData = genruntime.ClonePointerToString(profile.CustomData)

	// LinuxConfiguration
	if profile.LinuxConfiguration != nil {
		var linuxConfiguration v20220301s.LinuxConfiguration_STATUS
		err := profile.LinuxConfiguration.AssignProperties_To_LinuxConfiguration_STATUS(&linuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_LinuxConfiguration_STATUS() to populate field LinuxConfiguration")
		}
		destination.LinuxConfiguration = &linuxConfiguration
	} else {
		destination.LinuxConfiguration = nil
	}

	// Secrets
	if profile.Secrets != nil {
		secretList := make([]v20220301s.VaultSecretGroup_STATUS, len(profile.Secrets))
		for secretIndex, secretItem := range profile.Secrets {
			// Shadow the loop variable to avoid aliasing
			secretItem := secretItem
			var secret v20220301s.VaultSecretGroup_STATUS
			err := secretItem.AssignProperties_To_VaultSecretGroup_STATUS(&secret)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VaultSecretGroup_STATUS() to populate field Secrets")
			}
			secretList[secretIndex] = secret
		}
		destination.Secrets = secretList
	} else {
		destination.Secrets = nil
	}

	// WindowsConfiguration
	if profile.WindowsConfiguration != nil {
		var windowsConfiguration v20220301s.WindowsConfiguration_STATUS
		err := profile.WindowsConfiguration.AssignProperties_To_WindowsConfiguration_STATUS(&windowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_WindowsConfiguration_STATUS() to populate field WindowsConfiguration")
		}
		destination.WindowsConfiguration = &windowsConfiguration
	} else {
		destination.WindowsConfiguration = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetOSProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForVirtualMachineScaleSetOSProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineScaleSetStorageProfile
// Describes a virtual machine scale set storage profile.
type VirtualMachineScaleSetStorageProfile struct {
	DataDisks      []VirtualMachineScaleSetDataDisk `json:"dataDisks,omitempty"`
	ImageReference *ImageReference                  `json:"imageReference,omitempty"`
	OsDisk         *VirtualMachineScaleSetOSDisk    `json:"osDisk,omitempty"`
	PropertyBag    genruntime.PropertyBag           `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_VirtualMachineScaleSetStorageProfile populates our VirtualMachineScaleSetStorageProfile from the provided source VirtualMachineScaleSetStorageProfile
func (profile *VirtualMachineScaleSetStorageProfile) AssignProperties_From_VirtualMachineScaleSetStorageProfile(source *v20220301s.VirtualMachineScaleSetStorageProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DataDisks
	if source.DataDisks != nil {
		dataDiskList := make([]VirtualMachineScaleSetDataDisk, len(source.DataDisks))
		for dataDiskIndex, dataDiskItem := range source.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk VirtualMachineScaleSetDataDisk
			err := dataDisk.AssignProperties_From_VirtualMachineScaleSetDataDisk(&dataDiskItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetDataDisk() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		profile.DataDisks = dataDiskList
	} else {
		profile.DataDisks = nil
	}

	// ImageReference
	if source.ImageReference != nil {
		var imageReference ImageReference
		err := imageReference.AssignProperties_From_ImageReference(source.ImageReference)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ImageReference() to populate field ImageReference")
		}
		profile.ImageReference = &imageReference
	} else {
		profile.ImageReference = nil
	}

	// OsDisk
	if source.OsDisk != nil {
		var osDisk VirtualMachineScaleSetOSDisk
		err := osDisk.AssignProperties_From_VirtualMachineScaleSetOSDisk(source.OsDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetOSDisk() to populate field OsDisk")
		}
		profile.OsDisk = &osDisk
	} else {
		profile.OsDisk = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetStorageProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForVirtualMachineScaleSetStorageProfile); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetStorageProfile populates the provided destination VirtualMachineScaleSetStorageProfile from our VirtualMachineScaleSetStorageProfile
func (profile *VirtualMachineScaleSetStorageProfile) AssignProperties_To_VirtualMachineScaleSetStorageProfile(destination *v20220301s.VirtualMachineScaleSetStorageProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// DataDisks
	if profile.DataDisks != nil {
		dataDiskList := make([]v20220301s.VirtualMachineScaleSetDataDisk, len(profile.DataDisks))
		for dataDiskIndex, dataDiskItem := range profile.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk v20220301s.VirtualMachineScaleSetDataDisk
			err := dataDiskItem.AssignProperties_To_VirtualMachineScaleSetDataDisk(&dataDisk)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetDataDisk() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		destination.DataDisks = dataDiskList
	} else {
		destination.DataDisks = nil
	}

	// ImageReference
	if profile.ImageReference != nil {
		var imageReference v20220301s.ImageReference
		err := profile.ImageReference.AssignProperties_To_ImageReference(&imageReference)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ImageReference() to populate field ImageReference")
		}
		destination.ImageReference = &imageReference
	} else {
		destination.ImageReference = nil
	}

	// OsDisk
	if profile.OsDisk != nil {
		var osDisk v20220301s.VirtualMachineScaleSetOSDisk
		err := profile.OsDisk.AssignProperties_To_VirtualMachineScaleSetOSDisk(&osDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetOSDisk() to populate field OsDisk")
		}
		destination.OsDisk = &osDisk
	} else {
		destination.OsDisk = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetStorageProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForVirtualMachineScaleSetStorageProfile); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineScaleSetStorageProfile_STATUS
// Describes a virtual machine scale set storage profile.
type VirtualMachineScaleSetStorageProfile_STATUS struct {
	DataDisks      []VirtualMachineScaleSetDataDisk_STATUS `json:"dataDisks,omitempty"`
	ImageReference *ImageReference_STATUS                  `json:"imageReference,omitempty"`
	OsDisk         *VirtualMachineScaleSetOSDisk_STATUS    `json:"osDisk,omitempty"`
	PropertyBag    genruntime.PropertyBag                  `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_VirtualMachineScaleSetStorageProfile_STATUS populates our VirtualMachineScaleSetStorageProfile_STATUS from the provided source VirtualMachineScaleSetStorageProfile_STATUS
func (profile *VirtualMachineScaleSetStorageProfile_STATUS) AssignProperties_From_VirtualMachineScaleSetStorageProfile_STATUS(source *v20220301s.VirtualMachineScaleSetStorageProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DataDisks
	if source.DataDisks != nil {
		dataDiskList := make([]VirtualMachineScaleSetDataDisk_STATUS, len(source.DataDisks))
		for dataDiskIndex, dataDiskItem := range source.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk VirtualMachineScaleSetDataDisk_STATUS
			err := dataDisk.AssignProperties_From_VirtualMachineScaleSetDataDisk_STATUS(&dataDiskItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetDataDisk_STATUS() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		profile.DataDisks = dataDiskList
	} else {
		profile.DataDisks = nil
	}

	// ImageReference
	if source.ImageReference != nil {
		var imageReference ImageReference_STATUS
		err := imageReference.AssignProperties_From_ImageReference_STATUS(source.ImageReference)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ImageReference_STATUS() to populate field ImageReference")
		}
		profile.ImageReference = &imageReference
	} else {
		profile.ImageReference = nil
	}

	// OsDisk
	if source.OsDisk != nil {
		var osDisk VirtualMachineScaleSetOSDisk_STATUS
		err := osDisk.AssignProperties_From_VirtualMachineScaleSetOSDisk_STATUS(source.OsDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetOSDisk_STATUS() to populate field OsDisk")
		}
		profile.OsDisk = &osDisk
	} else {
		profile.OsDisk = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetStorageProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForVirtualMachineScaleSetStorageProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetStorageProfile_STATUS populates the provided destination VirtualMachineScaleSetStorageProfile_STATUS from our VirtualMachineScaleSetStorageProfile_STATUS
func (profile *VirtualMachineScaleSetStorageProfile_STATUS) AssignProperties_To_VirtualMachineScaleSetStorageProfile_STATUS(destination *v20220301s.VirtualMachineScaleSetStorageProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// DataDisks
	if profile.DataDisks != nil {
		dataDiskList := make([]v20220301s.VirtualMachineScaleSetDataDisk_STATUS, len(profile.DataDisks))
		for dataDiskIndex, dataDiskItem := range profile.DataDisks {
			// Shadow the loop variable to avoid aliasing
			dataDiskItem := dataDiskItem
			var dataDisk v20220301s.VirtualMachineScaleSetDataDisk_STATUS
			err := dataDiskItem.AssignProperties_To_VirtualMachineScaleSetDataDisk_STATUS(&dataDisk)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetDataDisk_STATUS() to populate field DataDisks")
			}
			dataDiskList[dataDiskIndex] = dataDisk
		}
		destination.DataDisks = dataDiskList
	} else {
		destination.DataDisks = nil
	}

	// ImageReference
	if profile.ImageReference != nil {
		var imageReference v20220301s.ImageReference_STATUS
		err := profile.ImageReference.AssignProperties_To_ImageReference_STATUS(&imageReference)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ImageReference_STATUS() to populate field ImageReference")
		}
		destination.ImageReference = &imageReference
	} else {
		destination.ImageReference = nil
	}

	// OsDisk
	if profile.OsDisk != nil {
		var osDisk v20220301s.VirtualMachineScaleSetOSDisk_STATUS
		err := profile.OsDisk.AssignProperties_To_VirtualMachineScaleSetOSDisk_STATUS(&osDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetOSDisk_STATUS() to populate field OsDisk")
		}
		destination.OsDisk = &osDisk
	} else {
		destination.OsDisk = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetStorageProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForVirtualMachineScaleSetStorageProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.ApiEntityReference
// The API entity reference.
type ApiEntityReference struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`

	// Reference: The ARM resource id in the form of /subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/...
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

// AssignProperties_From_ApiEntityReference populates our ApiEntityReference from the provided source ApiEntityReference
func (reference *ApiEntityReference) AssignProperties_From_ApiEntityReference(source *v20220301s.ApiEntityReference) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Reference
	if source.Reference != nil {
		referenceTemp := source.Reference.Copy()
		reference.Reference = &referenceTemp
	} else {
		reference.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		reference.PropertyBag = propertyBag
	} else {
		reference.PropertyBag = nil
	}

	// Invoke the augmentConversionForApiEntityReference interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForApiEntityReference); ok {
		err := augmentedReference.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ApiEntityReference populates the provided destination ApiEntityReference from our ApiEntityReference
func (reference *ApiEntityReference) AssignProperties_To_ApiEntityReference(destination *v20220301s.ApiEntityReference) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(reference.PropertyBag)

	// Reference
	if reference.Reference != nil {
		referenceTemp := reference.Reference.Copy()
		destination.Reference = &referenceTemp
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForApiEntityReference interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForApiEntityReference); ok {
		err := augmentedReference.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.ApiEntityReference_STATUS
// The API entity reference.
type ApiEntityReference_STATUS struct {
	Id          *string                `json:"id,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_ApiEntityReference_STATUS populates our ApiEntityReference_STATUS from the provided source ApiEntityReference_STATUS
func (reference *ApiEntityReference_STATUS) AssignProperties_From_ApiEntityReference_STATUS(source *v20220301s.ApiEntityReference_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Id
	reference.Id = genruntime.ClonePointerToString(source.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		reference.PropertyBag = propertyBag
	} else {
		reference.PropertyBag = nil
	}

	// Invoke the augmentConversionForApiEntityReference_STATUS interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForApiEntityReference_STATUS); ok {
		err := augmentedReference.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ApiEntityReference_STATUS populates the provided destination ApiEntityReference_STATUS from our ApiEntityReference_STATUS
func (reference *ApiEntityReference_STATUS) AssignProperties_To_ApiEntityReference_STATUS(destination *v20220301s.ApiEntityReference_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(reference.PropertyBag)

	// Id
	destination.Id = genruntime.ClonePointerToString(reference.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForApiEntityReference_STATUS interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForApiEntityReference_STATUS); ok {
		err := augmentedReference.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForAutomaticOSUpgradePolicy interface {
	AssignPropertiesFrom(src *v20220301s.AutomaticOSUpgradePolicy) error
	AssignPropertiesTo(dst *v20220301s.AutomaticOSUpgradePolicy) error
}

type augmentConversionForAutomaticOSUpgradePolicy_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.AutomaticOSUpgradePolicy_STATUS) error
	AssignPropertiesTo(dst *v20220301s.AutomaticOSUpgradePolicy_STATUS) error
}

type augmentConversionForRollingUpgradePolicy interface {
	AssignPropertiesFrom(src *v20220301s.RollingUpgradePolicy) error
	AssignPropertiesTo(dst *v20220301s.RollingUpgradePolicy) error
}

type augmentConversionForRollingUpgradePolicy_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.RollingUpgradePolicy_STATUS) error
	AssignPropertiesTo(dst *v20220301s.RollingUpgradePolicy_STATUS) error
}

type augmentConversionForScheduledEventsProfile interface {
	AssignPropertiesFrom(src *v20220301s.ScheduledEventsProfile) error
	AssignPropertiesTo(dst *v20220301s.ScheduledEventsProfile) error
}

type augmentConversionForScheduledEventsProfile_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.ScheduledEventsProfile_STATUS) error
	AssignPropertiesTo(dst *v20220301s.ScheduledEventsProfile_STATUS) error
}

type augmentConversionForVirtualMachineScaleSetExtensionProfile interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSetExtensionProfile) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSetExtensionProfile) error
}

type augmentConversionForVirtualMachineScaleSetExtensionProfile_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSetExtensionProfile_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSetExtensionProfile_STATUS) error
}

type augmentConversionForVirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSetIdentity_UserAssignedIdentities_STATUS) error
}

type augmentConversionForVirtualMachineScaleSetNetworkProfile interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSetNetworkProfile) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSetNetworkProfile) error
}

type augmentConversionForVirtualMachineScaleSetNetworkProfile_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSetNetworkProfile_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSetNetworkProfile_STATUS) error
}

type augmentConversionForVirtualMachineScaleSetOSProfile interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSetOSProfile) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSetOSProfile) error
}

type augmentConversionForVirtualMachineScaleSetOSProfile_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSetOSProfile_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSetOSProfile_STATUS) error
}

type augmentConversionForVirtualMachineScaleSetStorageProfile interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSetStorageProfile) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSetStorageProfile) error
}

type augmentConversionForVirtualMachineScaleSetStorageProfile_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSetStorageProfile_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSetStorageProfile_STATUS) error
}

// Storage version of v1api20201201.TerminateNotificationProfile
type TerminateNotificationProfile struct {
	Enable           *bool                  `json:"enable,omitempty"`
	NotBeforeTimeout *string                `json:"notBeforeTimeout,omitempty"`
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_TerminateNotificationProfile populates our TerminateNotificationProfile from the provided source TerminateNotificationProfile
func (profile *TerminateNotificationProfile) AssignProperties_From_TerminateNotificationProfile(source *v20220301s.TerminateNotificationProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Enable
	if source.Enable != nil {
		enable := *source.Enable
		profile.Enable = &enable
	} else {
		profile.Enable = nil
	}

	// NotBeforeTimeout
	profile.NotBeforeTimeout = genruntime.ClonePointerToString(source.NotBeforeTimeout)

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForTerminateNotificationProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForTerminateNotificationProfile); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_TerminateNotificationProfile populates the provided destination TerminateNotificationProfile from our TerminateNotificationProfile
func (profile *TerminateNotificationProfile) AssignProperties_To_TerminateNotificationProfile(destination *v20220301s.TerminateNotificationProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// Enable
	if profile.Enable != nil {
		enable := *profile.Enable
		destination.Enable = &enable
	} else {
		destination.Enable = nil
	}

	// NotBeforeTimeout
	destination.NotBeforeTimeout = genruntime.ClonePointerToString(profile.NotBeforeTimeout)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForTerminateNotificationProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForTerminateNotificationProfile); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.TerminateNotificationProfile_STATUS
type TerminateNotificationProfile_STATUS struct {
	Enable           *bool                  `json:"enable,omitempty"`
	NotBeforeTimeout *string                `json:"notBeforeTimeout,omitempty"`
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_TerminateNotificationProfile_STATUS populates our TerminateNotificationProfile_STATUS from the provided source TerminateNotificationProfile_STATUS
func (profile *TerminateNotificationProfile_STATUS) AssignProperties_From_TerminateNotificationProfile_STATUS(source *v20220301s.TerminateNotificationProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Enable
	if source.Enable != nil {
		enable := *source.Enable
		profile.Enable = &enable
	} else {
		profile.Enable = nil
	}

	// NotBeforeTimeout
	profile.NotBeforeTimeout = genruntime.ClonePointerToString(source.NotBeforeTimeout)

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForTerminateNotificationProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForTerminateNotificationProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_TerminateNotificationProfile_STATUS populates the provided destination TerminateNotificationProfile_STATUS from our TerminateNotificationProfile_STATUS
func (profile *TerminateNotificationProfile_STATUS) AssignProperties_To_TerminateNotificationProfile_STATUS(destination *v20220301s.TerminateNotificationProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// Enable
	if profile.Enable != nil {
		enable := *profile.Enable
		destination.Enable = &enable
	} else {
		destination.Enable = nil
	}

	// NotBeforeTimeout
	destination.NotBeforeTimeout = genruntime.ClonePointerToString(profile.NotBeforeTimeout)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForTerminateNotificationProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForTerminateNotificationProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineScaleSetDataDisk
// Describes a virtual machine scale set data disk.
type VirtualMachineScaleSetDataDisk struct {
	Caching                 *string                                      `json:"caching,omitempty"`
	CreateOption            *string                                      `json:"createOption,omitempty"`
	DiskIOPSReadWrite       *int                                         `json:"diskIOPSReadWrite,omitempty"`
	DiskMBpsReadWrite       *int                                         `json:"diskMBpsReadWrite,omitempty"`
	DiskSizeGB              *int                                         `json:"diskSizeGB,omitempty"`
	Lun                     *int                                         `json:"lun,omitempty"`
	ManagedDisk             *VirtualMachineScaleSetManagedDiskParameters `json:"managedDisk,omitempty"`
	Name                    *string                                      `json:"name,omitempty"`
	PropertyBag             genruntime.PropertyBag                       `json:"$propertyBag,omitempty"`
	WriteAcceleratorEnabled *bool                                        `json:"writeAcceleratorEnabled,omitempty"`
}

// AssignProperties_From_VirtualMachineScaleSetDataDisk populates our VirtualMachineScaleSetDataDisk from the provided source VirtualMachineScaleSetDataDisk
func (disk *VirtualMachineScaleSetDataDisk) AssignProperties_From_VirtualMachineScaleSetDataDisk(source *v20220301s.VirtualMachineScaleSetDataDisk) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Caching
	disk.Caching = genruntime.ClonePointerToString(source.Caching)

	// CreateOption
	disk.CreateOption = genruntime.ClonePointerToString(source.CreateOption)

	// DeleteOption
	if source.DeleteOption != nil {
		propertyBag.Add("DeleteOption", *source.DeleteOption)
	} else {
		propertyBag.Remove("DeleteOption")
	}

	// DiskIOPSReadWrite
	disk.DiskIOPSReadWrite = genruntime.ClonePointerToInt(source.DiskIOPSReadWrite)

	// DiskMBpsReadWrite
	disk.DiskMBpsReadWrite = genruntime.ClonePointerToInt(source.DiskMBpsReadWrite)

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// Lun
	disk.Lun = genruntime.ClonePointerToInt(source.Lun)

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk VirtualMachineScaleSetManagedDiskParameters
		err := managedDisk.AssignProperties_From_VirtualMachineScaleSetManagedDiskParameters(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetManagedDiskParameters() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		disk.PropertyBag = propertyBag
	} else {
		disk.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetDataDisk interface (if implemented) to customize the conversion
	var diskAsAny any = disk
	if augmentedDisk, ok := diskAsAny.(augmentConversionForVirtualMachineScaleSetDataDisk); ok {
		err := augmentedDisk.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetDataDisk populates the provided destination VirtualMachineScaleSetDataDisk from our VirtualMachineScaleSetDataDisk
func (disk *VirtualMachineScaleSetDataDisk) AssignProperties_To_VirtualMachineScaleSetDataDisk(destination *v20220301s.VirtualMachineScaleSetDataDisk) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(disk.PropertyBag)

	// Caching
	destination.Caching = genruntime.ClonePointerToString(disk.Caching)

	// CreateOption
	destination.CreateOption = genruntime.ClonePointerToString(disk.CreateOption)

	// DeleteOption
	if propertyBag.Contains("DeleteOption") {
		var deleteOption string
		err := propertyBag.Pull("DeleteOption", &deleteOption)
		if err != nil {
			return errors.Wrap(err, "pulling 'DeleteOption' from propertyBag")
		}

		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// DiskIOPSReadWrite
	destination.DiskIOPSReadWrite = genruntime.ClonePointerToInt(disk.DiskIOPSReadWrite)

	// DiskMBpsReadWrite
	destination.DiskMBpsReadWrite = genruntime.ClonePointerToInt(disk.DiskMBpsReadWrite)

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// Lun
	destination.Lun = genruntime.ClonePointerToInt(disk.Lun)

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk v20220301s.VirtualMachineScaleSetManagedDiskParameters
		err := disk.ManagedDisk.AssignProperties_To_VirtualMachineScaleSetManagedDiskParameters(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetManagedDiskParameters() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetDataDisk interface (if implemented) to customize the conversion
	var diskAsAny any = disk
	if augmentedDisk, ok := diskAsAny.(augmentConversionForVirtualMachineScaleSetDataDisk); ok {
		err := augmentedDisk.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineScaleSetDataDisk_STATUS
// Describes a virtual machine scale set data disk.
type VirtualMachineScaleSetDataDisk_STATUS struct {
	Caching                 *string                                             `json:"caching,omitempty"`
	CreateOption            *string                                             `json:"createOption,omitempty"`
	DiskIOPSReadWrite       *int                                                `json:"diskIOPSReadWrite,omitempty"`
	DiskMBpsReadWrite       *int                                                `json:"diskMBpsReadWrite,omitempty"`
	DiskSizeGB              *int                                                `json:"diskSizeGB,omitempty"`
	Lun                     *int                                                `json:"lun,omitempty"`
	ManagedDisk             *VirtualMachineScaleSetManagedDiskParameters_STATUS `json:"managedDisk,omitempty"`
	Name                    *string                                             `json:"name,omitempty"`
	PropertyBag             genruntime.PropertyBag                              `json:"$propertyBag,omitempty"`
	WriteAcceleratorEnabled *bool                                               `json:"writeAcceleratorEnabled,omitempty"`
}

// AssignProperties_From_VirtualMachineScaleSetDataDisk_STATUS populates our VirtualMachineScaleSetDataDisk_STATUS from the provided source VirtualMachineScaleSetDataDisk_STATUS
func (disk *VirtualMachineScaleSetDataDisk_STATUS) AssignProperties_From_VirtualMachineScaleSetDataDisk_STATUS(source *v20220301s.VirtualMachineScaleSetDataDisk_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Caching
	disk.Caching = genruntime.ClonePointerToString(source.Caching)

	// CreateOption
	disk.CreateOption = genruntime.ClonePointerToString(source.CreateOption)

	// DeleteOption
	if source.DeleteOption != nil {
		propertyBag.Add("DeleteOption", *source.DeleteOption)
	} else {
		propertyBag.Remove("DeleteOption")
	}

	// DiskIOPSReadWrite
	disk.DiskIOPSReadWrite = genruntime.ClonePointerToInt(source.DiskIOPSReadWrite)

	// DiskMBpsReadWrite
	disk.DiskMBpsReadWrite = genruntime.ClonePointerToInt(source.DiskMBpsReadWrite)

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// Lun
	disk.Lun = genruntime.ClonePointerToInt(source.Lun)

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk VirtualMachineScaleSetManagedDiskParameters_STATUS
		err := managedDisk.AssignProperties_From_VirtualMachineScaleSetManagedDiskParameters_STATUS(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetManagedDiskParameters_STATUS() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		disk.PropertyBag = propertyBag
	} else {
		disk.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetDataDisk_STATUS interface (if implemented) to customize the conversion
	var diskAsAny any = disk
	if augmentedDisk, ok := diskAsAny.(augmentConversionForVirtualMachineScaleSetDataDisk_STATUS); ok {
		err := augmentedDisk.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetDataDisk_STATUS populates the provided destination VirtualMachineScaleSetDataDisk_STATUS from our VirtualMachineScaleSetDataDisk_STATUS
func (disk *VirtualMachineScaleSetDataDisk_STATUS) AssignProperties_To_VirtualMachineScaleSetDataDisk_STATUS(destination *v20220301s.VirtualMachineScaleSetDataDisk_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(disk.PropertyBag)

	// Caching
	destination.Caching = genruntime.ClonePointerToString(disk.Caching)

	// CreateOption
	destination.CreateOption = genruntime.ClonePointerToString(disk.CreateOption)

	// DeleteOption
	if propertyBag.Contains("DeleteOption") {
		var deleteOption string
		err := propertyBag.Pull("DeleteOption", &deleteOption)
		if err != nil {
			return errors.Wrap(err, "pulling 'DeleteOption' from propertyBag")
		}

		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// DiskIOPSReadWrite
	destination.DiskIOPSReadWrite = genruntime.ClonePointerToInt(disk.DiskIOPSReadWrite)

	// DiskMBpsReadWrite
	destination.DiskMBpsReadWrite = genruntime.ClonePointerToInt(disk.DiskMBpsReadWrite)

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// Lun
	destination.Lun = genruntime.ClonePointerToInt(disk.Lun)

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk v20220301s.VirtualMachineScaleSetManagedDiskParameters_STATUS
		err := disk.ManagedDisk.AssignProperties_To_VirtualMachineScaleSetManagedDiskParameters_STATUS(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetManagedDiskParameters_STATUS() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetDataDisk_STATUS interface (if implemented) to customize the conversion
	var diskAsAny any = disk
	if augmentedDisk, ok := diskAsAny.(augmentConversionForVirtualMachineScaleSetDataDisk_STATUS); ok {
		err := augmentedDisk.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineScaleSetExtension
// Describes a Virtual Machine Scale Set Extension.
type VirtualMachineScaleSetExtension struct {
	AutoUpgradeMinorVersion  *bool                          `json:"autoUpgradeMinorVersion,omitempty"`
	EnableAutomaticUpgrade   *bool                          `json:"enableAutomaticUpgrade,omitempty"`
	ForceUpdateTag           *string                        `json:"forceUpdateTag,omitempty"`
	Name                     *string                        `json:"name,omitempty"`
	PropertyBag              genruntime.PropertyBag         `json:"$propertyBag,omitempty"`
	ProtectedSettings        *genruntime.SecretMapReference `json:"protectedSettings,omitempty"`
	ProvisionAfterExtensions []string                       `json:"provisionAfterExtensions,omitempty"`
	Publisher                *string                        `json:"publisher,omitempty"`
	Settings                 map[string]v1.JSON             `json:"settings,omitempty"`
	Type                     *string                        `json:"type,omitempty"`
	TypeHandlerVersion       *string                        `json:"typeHandlerVersion,omitempty"`
}

// AssignProperties_From_VirtualMachineScaleSetExtension populates our VirtualMachineScaleSetExtension from the provided source VirtualMachineScaleSetExtension
func (extension *VirtualMachineScaleSetExtension) AssignProperties_From_VirtualMachineScaleSetExtension(source *v20220301s.VirtualMachineScaleSetExtension) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AutoUpgradeMinorVersion
	if source.AutoUpgradeMinorVersion != nil {
		autoUpgradeMinorVersion := *source.AutoUpgradeMinorVersion
		extension.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
	} else {
		extension.AutoUpgradeMinorVersion = nil
	}

	// EnableAutomaticUpgrade
	if source.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *source.EnableAutomaticUpgrade
		extension.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	} else {
		extension.EnableAutomaticUpgrade = nil
	}

	// ForceUpdateTag
	extension.ForceUpdateTag = genruntime.ClonePointerToString(source.ForceUpdateTag)

	// Name
	extension.Name = genruntime.ClonePointerToString(source.Name)

	// ProtectedSettings
	if source.ProtectedSettings != nil {
		protectedSetting := source.ProtectedSettings.Copy()
		extension.ProtectedSettings = &protectedSetting
	} else {
		extension.ProtectedSettings = nil
	}

	// ProtectedSettingsFromKeyVault
	if source.ProtectedSettingsFromKeyVault != nil {
		propertyBag.Add("ProtectedSettingsFromKeyVault", *source.ProtectedSettingsFromKeyVault)
	} else {
		propertyBag.Remove("ProtectedSettingsFromKeyVault")
	}

	// ProvisionAfterExtensions
	extension.ProvisionAfterExtensions = genruntime.CloneSliceOfString(source.ProvisionAfterExtensions)

	// Publisher
	extension.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// Settings
	if source.Settings != nil {
		settingMap := make(map[string]v1.JSON, len(source.Settings))
		for settingKey, settingValue := range source.Settings {
			// Shadow the loop variable to avoid aliasing
			settingValue := settingValue
			settingMap[settingKey] = *settingValue.DeepCopy()
		}
		extension.Settings = settingMap
	} else {
		extension.Settings = nil
	}

	// SuppressFailures
	if source.SuppressFailures != nil {
		propertyBag.Add("SuppressFailures", *source.SuppressFailures)
	} else {
		propertyBag.Remove("SuppressFailures")
	}

	// Type
	extension.Type = genruntime.ClonePointerToString(source.Type)

	// TypeHandlerVersion
	extension.TypeHandlerVersion = genruntime.ClonePointerToString(source.TypeHandlerVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		extension.PropertyBag = propertyBag
	} else {
		extension.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetExtension interface (if implemented) to customize the conversion
	var extensionAsAny any = extension
	if augmentedExtension, ok := extensionAsAny.(augmentConversionForVirtualMachineScaleSetExtension); ok {
		err := augmentedExtension.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetExtension populates the provided destination VirtualMachineScaleSetExtension from our VirtualMachineScaleSetExtension
func (extension *VirtualMachineScaleSetExtension) AssignProperties_To_VirtualMachineScaleSetExtension(destination *v20220301s.VirtualMachineScaleSetExtension) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(extension.PropertyBag)

	// AutoUpgradeMinorVersion
	if extension.AutoUpgradeMinorVersion != nil {
		autoUpgradeMinorVersion := *extension.AutoUpgradeMinorVersion
		destination.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
	} else {
		destination.AutoUpgradeMinorVersion = nil
	}

	// EnableAutomaticUpgrade
	if extension.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *extension.EnableAutomaticUpgrade
		destination.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	} else {
		destination.EnableAutomaticUpgrade = nil
	}

	// ForceUpdateTag
	destination.ForceUpdateTag = genruntime.ClonePointerToString(extension.ForceUpdateTag)

	// Name
	destination.Name = genruntime.ClonePointerToString(extension.Name)

	// ProtectedSettings
	if extension.ProtectedSettings != nil {
		protectedSetting := extension.ProtectedSettings.Copy()
		destination.ProtectedSettings = &protectedSetting
	} else {
		destination.ProtectedSettings = nil
	}

	// ProtectedSettingsFromKeyVault
	if propertyBag.Contains("ProtectedSettingsFromKeyVault") {
		var protectedSettingsFromKeyVault v20220301s.KeyVaultSecretReference
		err := propertyBag.Pull("ProtectedSettingsFromKeyVault", &protectedSettingsFromKeyVault)
		if err != nil {
			return errors.Wrap(err, "pulling 'ProtectedSettingsFromKeyVault' from propertyBag")
		}

		destination.ProtectedSettingsFromKeyVault = &protectedSettingsFromKeyVault
	} else {
		destination.ProtectedSettingsFromKeyVault = nil
	}

	// ProvisionAfterExtensions
	destination.ProvisionAfterExtensions = genruntime.CloneSliceOfString(extension.ProvisionAfterExtensions)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(extension.Publisher)

	// Settings
	if extension.Settings != nil {
		settingMap := make(map[string]v1.JSON, len(extension.Settings))
		for settingKey, settingValue := range extension.Settings {
			// Shadow the loop variable to avoid aliasing
			settingValue := settingValue
			settingMap[settingKey] = *settingValue.DeepCopy()
		}
		destination.Settings = settingMap
	} else {
		destination.Settings = nil
	}

	// SuppressFailures
	if propertyBag.Contains("SuppressFailures") {
		var suppressFailure bool
		err := propertyBag.Pull("SuppressFailures", &suppressFailure)
		if err != nil {
			return errors.Wrap(err, "pulling 'SuppressFailures' from propertyBag")
		}

		destination.SuppressFailures = &suppressFailure
	} else {
		destination.SuppressFailures = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(extension.Type)

	// TypeHandlerVersion
	destination.TypeHandlerVersion = genruntime.ClonePointerToString(extension.TypeHandlerVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetExtension interface (if implemented) to customize the conversion
	var extensionAsAny any = extension
	if augmentedExtension, ok := extensionAsAny.(augmentConversionForVirtualMachineScaleSetExtension); ok {
		err := augmentedExtension.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineScaleSetExtension_STATUS
// Describes a Virtual Machine Scale Set Extension.
type VirtualMachineScaleSetExtension_STATUS struct {
	AutoUpgradeMinorVersion  *bool                  `json:"autoUpgradeMinorVersion,omitempty"`
	EnableAutomaticUpgrade   *bool                  `json:"enableAutomaticUpgrade,omitempty"`
	ForceUpdateTag           *string                `json:"forceUpdateTag,omitempty"`
	Id                       *string                `json:"id,omitempty"`
	Name                     *string                `json:"name,omitempty"`
	PropertiesType           *string                `json:"properties_type,omitempty"`
	PropertyBag              genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ProvisionAfterExtensions []string               `json:"provisionAfterExtensions,omitempty"`
	ProvisioningState        *string                `json:"provisioningState,omitempty"`
	Publisher                *string                `json:"publisher,omitempty"`
	Settings                 map[string]v1.JSON     `json:"settings,omitempty"`
	Type                     *string                `json:"type,omitempty"`
	TypeHandlerVersion       *string                `json:"typeHandlerVersion,omitempty"`
}

// AssignProperties_From_VirtualMachineScaleSetExtension_STATUS populates our VirtualMachineScaleSetExtension_STATUS from the provided source VirtualMachineScaleSetExtension_STATUS
func (extension *VirtualMachineScaleSetExtension_STATUS) AssignProperties_From_VirtualMachineScaleSetExtension_STATUS(source *v20220301s.VirtualMachineScaleSetExtension_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AutoUpgradeMinorVersion
	if source.AutoUpgradeMinorVersion != nil {
		autoUpgradeMinorVersion := *source.AutoUpgradeMinorVersion
		extension.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
	} else {
		extension.AutoUpgradeMinorVersion = nil
	}

	// EnableAutomaticUpgrade
	if source.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *source.EnableAutomaticUpgrade
		extension.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	} else {
		extension.EnableAutomaticUpgrade = nil
	}

	// ForceUpdateTag
	extension.ForceUpdateTag = genruntime.ClonePointerToString(source.ForceUpdateTag)

	// Id
	extension.Id = genruntime.ClonePointerToString(source.Id)

	// Name
	extension.Name = genruntime.ClonePointerToString(source.Name)

	// PropertiesType
	extension.PropertiesType = genruntime.ClonePointerToString(source.PropertiesType)

	// ProtectedSettingsFromKeyVault
	if source.ProtectedSettingsFromKeyVault != nil {
		propertyBag.Add("ProtectedSettingsFromKeyVault", *source.ProtectedSettingsFromKeyVault)
	} else {
		propertyBag.Remove("ProtectedSettingsFromKeyVault")
	}

	// ProvisionAfterExtensions
	extension.ProvisionAfterExtensions = genruntime.CloneSliceOfString(source.ProvisionAfterExtensions)

	// ProvisioningState
	extension.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// Publisher
	extension.Publisher = genruntime.ClonePointerToString(source.Publisher)

	// Settings
	if source.Settings != nil {
		settingMap := make(map[string]v1.JSON, len(source.Settings))
		for settingKey, settingValue := range source.Settings {
			// Shadow the loop variable to avoid aliasing
			settingValue := settingValue
			settingMap[settingKey] = *settingValue.DeepCopy()
		}
		extension.Settings = settingMap
	} else {
		extension.Settings = nil
	}

	// SuppressFailures
	if source.SuppressFailures != nil {
		propertyBag.Add("SuppressFailures", *source.SuppressFailures)
	} else {
		propertyBag.Remove("SuppressFailures")
	}

	// Type
	extension.Type = genruntime.ClonePointerToString(source.Type)

	// TypeHandlerVersion
	extension.TypeHandlerVersion = genruntime.ClonePointerToString(source.TypeHandlerVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		extension.PropertyBag = propertyBag
	} else {
		extension.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetExtension_STATUS interface (if implemented) to customize the conversion
	var extensionAsAny any = extension
	if augmentedExtension, ok := extensionAsAny.(augmentConversionForVirtualMachineScaleSetExtension_STATUS); ok {
		err := augmentedExtension.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetExtension_STATUS populates the provided destination VirtualMachineScaleSetExtension_STATUS from our VirtualMachineScaleSetExtension_STATUS
func (extension *VirtualMachineScaleSetExtension_STATUS) AssignProperties_To_VirtualMachineScaleSetExtension_STATUS(destination *v20220301s.VirtualMachineScaleSetExtension_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(extension.PropertyBag)

	// AutoUpgradeMinorVersion
	if extension.AutoUpgradeMinorVersion != nil {
		autoUpgradeMinorVersion := *extension.AutoUpgradeMinorVersion
		destination.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
	} else {
		destination.AutoUpgradeMinorVersion = nil
	}

	// EnableAutomaticUpgrade
	if extension.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *extension.EnableAutomaticUpgrade
		destination.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	} else {
		destination.EnableAutomaticUpgrade = nil
	}

	// ForceUpdateTag
	destination.ForceUpdateTag = genruntime.ClonePointerToString(extension.ForceUpdateTag)

	// Id
	destination.Id = genruntime.ClonePointerToString(extension.Id)

	// Name
	destination.Name = genruntime.ClonePointerToString(extension.Name)

	// PropertiesType
	destination.PropertiesType = genruntime.ClonePointerToString(extension.PropertiesType)

	// ProtectedSettingsFromKeyVault
	if propertyBag.Contains("ProtectedSettingsFromKeyVault") {
		var protectedSettingsFromKeyVault v20220301s.KeyVaultSecretReference_STATUS
		err := propertyBag.Pull("ProtectedSettingsFromKeyVault", &protectedSettingsFromKeyVault)
		if err != nil {
			return errors.Wrap(err, "pulling 'ProtectedSettingsFromKeyVault' from propertyBag")
		}

		destination.ProtectedSettingsFromKeyVault = &protectedSettingsFromKeyVault
	} else {
		destination.ProtectedSettingsFromKeyVault = nil
	}

	// ProvisionAfterExtensions
	destination.ProvisionAfterExtensions = genruntime.CloneSliceOfString(extension.ProvisionAfterExtensions)

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(extension.ProvisioningState)

	// Publisher
	destination.Publisher = genruntime.ClonePointerToString(extension.Publisher)

	// Settings
	if extension.Settings != nil {
		settingMap := make(map[string]v1.JSON, len(extension.Settings))
		for settingKey, settingValue := range extension.Settings {
			// Shadow the loop variable to avoid aliasing
			settingValue := settingValue
			settingMap[settingKey] = *settingValue.DeepCopy()
		}
		destination.Settings = settingMap
	} else {
		destination.Settings = nil
	}

	// SuppressFailures
	if propertyBag.Contains("SuppressFailures") {
		var suppressFailure bool
		err := propertyBag.Pull("SuppressFailures", &suppressFailure)
		if err != nil {
			return errors.Wrap(err, "pulling 'SuppressFailures' from propertyBag")
		}

		destination.SuppressFailures = &suppressFailure
	} else {
		destination.SuppressFailures = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(extension.Type)

	// TypeHandlerVersion
	destination.TypeHandlerVersion = genruntime.ClonePointerToString(extension.TypeHandlerVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetExtension_STATUS interface (if implemented) to customize the conversion
	var extensionAsAny any = extension
	if augmentedExtension, ok := extensionAsAny.(augmentConversionForVirtualMachineScaleSetExtension_STATUS); ok {
		err := augmentedExtension.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineScaleSetNetworkConfiguration
// Describes a virtual machine scale set network profile's network configurations.
type VirtualMachineScaleSetNetworkConfiguration struct {
	DnsSettings                 *VirtualMachineScaleSetNetworkConfigurationDnsSettings `json:"dnsSettings,omitempty"`
	EnableAcceleratedNetworking *bool                                                  `json:"enableAcceleratedNetworking,omitempty"`
	EnableFpga                  *bool                                                  `json:"enableFpga,omitempty"`
	EnableIPForwarding          *bool                                                  `json:"enableIPForwarding,omitempty"`
	IpConfigurations            []VirtualMachineScaleSetIPConfiguration                `json:"ipConfigurations,omitempty"`
	Name                        *string                                                `json:"name,omitempty"`
	NetworkSecurityGroup        *SubResource                                           `json:"networkSecurityGroup,omitempty"`
	Primary                     *bool                                                  `json:"primary,omitempty"`
	PropertyBag                 genruntime.PropertyBag                                 `json:"$propertyBag,omitempty"`

	// Reference: Resource Id
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

// AssignProperties_From_VirtualMachineScaleSetNetworkConfiguration populates our VirtualMachineScaleSetNetworkConfiguration from the provided source VirtualMachineScaleSetNetworkConfiguration
func (configuration *VirtualMachineScaleSetNetworkConfiguration) AssignProperties_From_VirtualMachineScaleSetNetworkConfiguration(source *v20220301s.VirtualMachineScaleSetNetworkConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DeleteOption
	if source.DeleteOption != nil {
		propertyBag.Add("DeleteOption", *source.DeleteOption)
	} else {
		propertyBag.Remove("DeleteOption")
	}

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting VirtualMachineScaleSetNetworkConfigurationDnsSettings
		err := dnsSetting.AssignProperties_From_VirtualMachineScaleSetNetworkConfigurationDnsSettings(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetNetworkConfigurationDnsSettings() to populate field DnsSettings")
		}
		configuration.DnsSettings = &dnsSetting
	} else {
		configuration.DnsSettings = nil
	}

	// EnableAcceleratedNetworking
	if source.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *source.EnableAcceleratedNetworking
		configuration.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		configuration.EnableAcceleratedNetworking = nil
	}

	// EnableFpga
	if source.EnableFpga != nil {
		enableFpga := *source.EnableFpga
		configuration.EnableFpga = &enableFpga
	} else {
		configuration.EnableFpga = nil
	}

	// EnableIPForwarding
	if source.EnableIPForwarding != nil {
		enableIPForwarding := *source.EnableIPForwarding
		configuration.EnableIPForwarding = &enableIPForwarding
	} else {
		configuration.EnableIPForwarding = nil
	}

	// IpConfigurations
	if source.IpConfigurations != nil {
		ipConfigurationList := make([]VirtualMachineScaleSetIPConfiguration, len(source.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range source.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration VirtualMachineScaleSetIPConfiguration
			err := ipConfiguration.AssignProperties_From_VirtualMachineScaleSetIPConfiguration(&ipConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetIPConfiguration() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		configuration.IpConfigurations = ipConfigurationList
	} else {
		configuration.IpConfigurations = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// NetworkSecurityGroup
	if source.NetworkSecurityGroup != nil {
		var subResourceStash v20210701s.SubResource
		err := subResourceStash.AssignProperties_From_SubResource(source.NetworkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from NetworkSecurityGroup")
		}
		var networkSecurityGroup SubResource
		err = networkSecurityGroup.AssignProperties_From_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field NetworkSecurityGroup from SubResourceStash")
		}
		configuration.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		configuration.NetworkSecurityGroup = nil
	}

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		configuration.Primary = &primary
	} else {
		configuration.Primary = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		configuration.Reference = &reference
	} else {
		configuration.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetNetworkConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForVirtualMachineScaleSetNetworkConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetNetworkConfiguration populates the provided destination VirtualMachineScaleSetNetworkConfiguration from our VirtualMachineScaleSetNetworkConfiguration
func (configuration *VirtualMachineScaleSetNetworkConfiguration) AssignProperties_To_VirtualMachineScaleSetNetworkConfiguration(destination *v20220301s.VirtualMachineScaleSetNetworkConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// DeleteOption
	if propertyBag.Contains("DeleteOption") {
		var deleteOption string
		err := propertyBag.Pull("DeleteOption", &deleteOption)
		if err != nil {
			return errors.Wrap(err, "pulling 'DeleteOption' from propertyBag")
		}

		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// DnsSettings
	if configuration.DnsSettings != nil {
		var dnsSetting v20220301s.VirtualMachineScaleSetNetworkConfigurationDnsSettings
		err := configuration.DnsSettings.AssignProperties_To_VirtualMachineScaleSetNetworkConfigurationDnsSettings(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetNetworkConfigurationDnsSettings() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// EnableAcceleratedNetworking
	if configuration.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *configuration.EnableAcceleratedNetworking
		destination.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		destination.EnableAcceleratedNetworking = nil
	}

	// EnableFpga
	if configuration.EnableFpga != nil {
		enableFpga := *configuration.EnableFpga
		destination.EnableFpga = &enableFpga
	} else {
		destination.EnableFpga = nil
	}

	// EnableIPForwarding
	if configuration.EnableIPForwarding != nil {
		enableIPForwarding := *configuration.EnableIPForwarding
		destination.EnableIPForwarding = &enableIPForwarding
	} else {
		destination.EnableIPForwarding = nil
	}

	// IpConfigurations
	if configuration.IpConfigurations != nil {
		ipConfigurationList := make([]v20220301s.VirtualMachineScaleSetIPConfiguration, len(configuration.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range configuration.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration v20220301s.VirtualMachineScaleSetIPConfiguration
			err := ipConfigurationItem.AssignProperties_To_VirtualMachineScaleSetIPConfiguration(&ipConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetIPConfiguration() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		destination.IpConfigurations = ipConfigurationList
	} else {
		destination.IpConfigurations = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// NetworkSecurityGroup
	if configuration.NetworkSecurityGroup != nil {
		var subResourceStash v20210701s.SubResource
		err := configuration.NetworkSecurityGroup.AssignProperties_To_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from NetworkSecurityGroup")
		}
		var networkSecurityGroup v20220301s.SubResource
		err = subResourceStash.AssignProperties_To_SubResource(&networkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field NetworkSecurityGroup from SubResourceStash")
		}
		destination.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		destination.NetworkSecurityGroup = nil
	}

	// Primary
	if configuration.Primary != nil {
		primary := *configuration.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// Reference
	if configuration.Reference != nil {
		reference := configuration.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetNetworkConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForVirtualMachineScaleSetNetworkConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineScaleSetNetworkConfiguration_STATUS
// Describes a virtual machine scale set network profile's network configurations.
type VirtualMachineScaleSetNetworkConfiguration_STATUS struct {
	DnsSettings                 *VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS `json:"dnsSettings,omitempty"`
	EnableAcceleratedNetworking *bool                                                         `json:"enableAcceleratedNetworking,omitempty"`
	EnableFpga                  *bool                                                         `json:"enableFpga,omitempty"`
	EnableIPForwarding          *bool                                                         `json:"enableIPForwarding,omitempty"`
	Id                          *string                                                       `json:"id,omitempty"`
	IpConfigurations            []VirtualMachineScaleSetIPConfiguration_STATUS                `json:"ipConfigurations,omitempty"`
	Name                        *string                                                       `json:"name,omitempty"`
	NetworkSecurityGroup        *SubResource_STATUS                                           `json:"networkSecurityGroup,omitempty"`
	Primary                     *bool                                                         `json:"primary,omitempty"`
	PropertyBag                 genruntime.PropertyBag                                        `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_VirtualMachineScaleSetNetworkConfiguration_STATUS populates our VirtualMachineScaleSetNetworkConfiguration_STATUS from the provided source VirtualMachineScaleSetNetworkConfiguration_STATUS
func (configuration *VirtualMachineScaleSetNetworkConfiguration_STATUS) AssignProperties_From_VirtualMachineScaleSetNetworkConfiguration_STATUS(source *v20220301s.VirtualMachineScaleSetNetworkConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DeleteOption
	if source.DeleteOption != nil {
		propertyBag.Add("DeleteOption", *source.DeleteOption)
	} else {
		propertyBag.Remove("DeleteOption")
	}

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS
		err := dnsSetting.AssignProperties_From_VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS() to populate field DnsSettings")
		}
		configuration.DnsSettings = &dnsSetting
	} else {
		configuration.DnsSettings = nil
	}

	// EnableAcceleratedNetworking
	if source.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *source.EnableAcceleratedNetworking
		configuration.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		configuration.EnableAcceleratedNetworking = nil
	}

	// EnableFpga
	if source.EnableFpga != nil {
		enableFpga := *source.EnableFpga
		configuration.EnableFpga = &enableFpga
	} else {
		configuration.EnableFpga = nil
	}

	// EnableIPForwarding
	if source.EnableIPForwarding != nil {
		enableIPForwarding := *source.EnableIPForwarding
		configuration.EnableIPForwarding = &enableIPForwarding
	} else {
		configuration.EnableIPForwarding = nil
	}

	// Id
	configuration.Id = genruntime.ClonePointerToString(source.Id)

	// IpConfigurations
	if source.IpConfigurations != nil {
		ipConfigurationList := make([]VirtualMachineScaleSetIPConfiguration_STATUS, len(source.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range source.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration VirtualMachineScaleSetIPConfiguration_STATUS
			err := ipConfiguration.AssignProperties_From_VirtualMachineScaleSetIPConfiguration_STATUS(&ipConfigurationItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetIPConfiguration_STATUS() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		configuration.IpConfigurations = ipConfigurationList
	} else {
		configuration.IpConfigurations = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// NetworkSecurityGroup
	if source.NetworkSecurityGroup != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(source.NetworkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from NetworkSecurityGroup")
		}
		var networkSecurityGroup SubResource_STATUS
		err = networkSecurityGroup.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field NetworkSecurityGroup from SubResource_STATUSStash")
		}
		configuration.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		configuration.NetworkSecurityGroup = nil
	}

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		configuration.Primary = &primary
	} else {
		configuration.Primary = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetNetworkConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForVirtualMachineScaleSetNetworkConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetNetworkConfiguration_STATUS populates the provided destination VirtualMachineScaleSetNetworkConfiguration_STATUS from our VirtualMachineScaleSetNetworkConfiguration_STATUS
func (configuration *VirtualMachineScaleSetNetworkConfiguration_STATUS) AssignProperties_To_VirtualMachineScaleSetNetworkConfiguration_STATUS(destination *v20220301s.VirtualMachineScaleSetNetworkConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// DeleteOption
	if propertyBag.Contains("DeleteOption") {
		var deleteOption string
		err := propertyBag.Pull("DeleteOption", &deleteOption)
		if err != nil {
			return errors.Wrap(err, "pulling 'DeleteOption' from propertyBag")
		}

		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// DnsSettings
	if configuration.DnsSettings != nil {
		var dnsSetting v20220301s.VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS
		err := configuration.DnsSettings.AssignProperties_To_VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// EnableAcceleratedNetworking
	if configuration.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *configuration.EnableAcceleratedNetworking
		destination.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		destination.EnableAcceleratedNetworking = nil
	}

	// EnableFpga
	if configuration.EnableFpga != nil {
		enableFpga := *configuration.EnableFpga
		destination.EnableFpga = &enableFpga
	} else {
		destination.EnableFpga = nil
	}

	// EnableIPForwarding
	if configuration.EnableIPForwarding != nil {
		enableIPForwarding := *configuration.EnableIPForwarding
		destination.EnableIPForwarding = &enableIPForwarding
	} else {
		destination.EnableIPForwarding = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(configuration.Id)

	// IpConfigurations
	if configuration.IpConfigurations != nil {
		ipConfigurationList := make([]v20220301s.VirtualMachineScaleSetIPConfiguration_STATUS, len(configuration.IpConfigurations))
		for ipConfigurationIndex, ipConfigurationItem := range configuration.IpConfigurations {
			// Shadow the loop variable to avoid aliasing
			ipConfigurationItem := ipConfigurationItem
			var ipConfiguration v20220301s.VirtualMachineScaleSetIPConfiguration_STATUS
			err := ipConfigurationItem.AssignProperties_To_VirtualMachineScaleSetIPConfiguration_STATUS(&ipConfiguration)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetIPConfiguration_STATUS() to populate field IpConfigurations")
			}
			ipConfigurationList[ipConfigurationIndex] = ipConfiguration
		}
		destination.IpConfigurations = ipConfigurationList
	} else {
		destination.IpConfigurations = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// NetworkSecurityGroup
	if configuration.NetworkSecurityGroup != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := configuration.NetworkSecurityGroup.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from NetworkSecurityGroup")
		}
		var networkSecurityGroup v20220301s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&networkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field NetworkSecurityGroup from SubResource_STATUSStash")
		}
		destination.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		destination.NetworkSecurityGroup = nil
	}

	// Primary
	if configuration.Primary != nil {
		primary := *configuration.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetNetworkConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForVirtualMachineScaleSetNetworkConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineScaleSetOSDisk
// Describes a virtual machine scale set operating system disk.
type VirtualMachineScaleSetOSDisk struct {
	Caching                 *string                                      `json:"caching,omitempty"`
	CreateOption            *string                                      `json:"createOption,omitempty"`
	DiffDiskSettings        *DiffDiskSettings                            `json:"diffDiskSettings,omitempty"`
	DiskSizeGB              *int                                         `json:"diskSizeGB,omitempty"`
	Image                   *VirtualHardDisk                             `json:"image,omitempty"`
	ManagedDisk             *VirtualMachineScaleSetManagedDiskParameters `json:"managedDisk,omitempty"`
	Name                    *string                                      `json:"name,omitempty"`
	OsType                  *string                                      `json:"osType,omitempty"`
	PropertyBag             genruntime.PropertyBag                       `json:"$propertyBag,omitempty"`
	VhdContainers           []string                                     `json:"vhdContainers,omitempty"`
	WriteAcceleratorEnabled *bool                                        `json:"writeAcceleratorEnabled,omitempty"`
}

// AssignProperties_From_VirtualMachineScaleSetOSDisk populates our VirtualMachineScaleSetOSDisk from the provided source VirtualMachineScaleSetOSDisk
func (disk *VirtualMachineScaleSetOSDisk) AssignProperties_From_VirtualMachineScaleSetOSDisk(source *v20220301s.VirtualMachineScaleSetOSDisk) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Caching
	disk.Caching = genruntime.ClonePointerToString(source.Caching)

	// CreateOption
	disk.CreateOption = genruntime.ClonePointerToString(source.CreateOption)

	// DeleteOption
	if source.DeleteOption != nil {
		propertyBag.Add("DeleteOption", *source.DeleteOption)
	} else {
		propertyBag.Remove("DeleteOption")
	}

	// DiffDiskSettings
	if source.DiffDiskSettings != nil {
		var diffDiskSetting DiffDiskSettings
		err := diffDiskSetting.AssignProperties_From_DiffDiskSettings(source.DiffDiskSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DiffDiskSettings() to populate field DiffDiskSettings")
		}
		disk.DiffDiskSettings = &diffDiskSetting
	} else {
		disk.DiffDiskSettings = nil
	}

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// Image
	if source.Image != nil {
		var image VirtualHardDisk
		err := image.AssignProperties_From_VirtualHardDisk(source.Image)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualHardDisk() to populate field Image")
		}
		disk.Image = &image
	} else {
		disk.Image = nil
	}

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk VirtualMachineScaleSetManagedDiskParameters
		err := managedDisk.AssignProperties_From_VirtualMachineScaleSetManagedDiskParameters(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetManagedDiskParameters() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// OsType
	disk.OsType = genruntime.ClonePointerToString(source.OsType)

	// VhdContainers
	disk.VhdContainers = genruntime.CloneSliceOfString(source.VhdContainers)

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		disk.PropertyBag = propertyBag
	} else {
		disk.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetOSDisk interface (if implemented) to customize the conversion
	var diskAsAny any = disk
	if augmentedDisk, ok := diskAsAny.(augmentConversionForVirtualMachineScaleSetOSDisk); ok {
		err := augmentedDisk.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetOSDisk populates the provided destination VirtualMachineScaleSetOSDisk from our VirtualMachineScaleSetOSDisk
func (disk *VirtualMachineScaleSetOSDisk) AssignProperties_To_VirtualMachineScaleSetOSDisk(destination *v20220301s.VirtualMachineScaleSetOSDisk) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(disk.PropertyBag)

	// Caching
	destination.Caching = genruntime.ClonePointerToString(disk.Caching)

	// CreateOption
	destination.CreateOption = genruntime.ClonePointerToString(disk.CreateOption)

	// DeleteOption
	if propertyBag.Contains("DeleteOption") {
		var deleteOption string
		err := propertyBag.Pull("DeleteOption", &deleteOption)
		if err != nil {
			return errors.Wrap(err, "pulling 'DeleteOption' from propertyBag")
		}

		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// DiffDiskSettings
	if disk.DiffDiskSettings != nil {
		var diffDiskSetting v20220301s.DiffDiskSettings
		err := disk.DiffDiskSettings.AssignProperties_To_DiffDiskSettings(&diffDiskSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DiffDiskSettings() to populate field DiffDiskSettings")
		}
		destination.DiffDiskSettings = &diffDiskSetting
	} else {
		destination.DiffDiskSettings = nil
	}

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// Image
	if disk.Image != nil {
		var image v20220301s.VirtualHardDisk
		err := disk.Image.AssignProperties_To_VirtualHardDisk(&image)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualHardDisk() to populate field Image")
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk v20220301s.VirtualMachineScaleSetManagedDiskParameters
		err := disk.ManagedDisk.AssignProperties_To_VirtualMachineScaleSetManagedDiskParameters(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetManagedDiskParameters() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// OsType
	destination.OsType = genruntime.ClonePointerToString(disk.OsType)

	// VhdContainers
	destination.VhdContainers = genruntime.CloneSliceOfString(disk.VhdContainers)

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetOSDisk interface (if implemented) to customize the conversion
	var diskAsAny any = disk
	if augmentedDisk, ok := diskAsAny.(augmentConversionForVirtualMachineScaleSetOSDisk); ok {
		err := augmentedDisk.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineScaleSetOSDisk_STATUS
// Describes a virtual machine scale set operating system disk.
type VirtualMachineScaleSetOSDisk_STATUS struct {
	Caching                 *string                                             `json:"caching,omitempty"`
	CreateOption            *string                                             `json:"createOption,omitempty"`
	DiffDiskSettings        *DiffDiskSettings_STATUS                            `json:"diffDiskSettings,omitempty"`
	DiskSizeGB              *int                                                `json:"diskSizeGB,omitempty"`
	Image                   *VirtualHardDisk_STATUS                             `json:"image,omitempty"`
	ManagedDisk             *VirtualMachineScaleSetManagedDiskParameters_STATUS `json:"managedDisk,omitempty"`
	Name                    *string                                             `json:"name,omitempty"`
	OsType                  *string                                             `json:"osType,omitempty"`
	PropertyBag             genruntime.PropertyBag                              `json:"$propertyBag,omitempty"`
	VhdContainers           []string                                            `json:"vhdContainers,omitempty"`
	WriteAcceleratorEnabled *bool                                               `json:"writeAcceleratorEnabled,omitempty"`
}

// AssignProperties_From_VirtualMachineScaleSetOSDisk_STATUS populates our VirtualMachineScaleSetOSDisk_STATUS from the provided source VirtualMachineScaleSetOSDisk_STATUS
func (disk *VirtualMachineScaleSetOSDisk_STATUS) AssignProperties_From_VirtualMachineScaleSetOSDisk_STATUS(source *v20220301s.VirtualMachineScaleSetOSDisk_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Caching
	disk.Caching = genruntime.ClonePointerToString(source.Caching)

	// CreateOption
	disk.CreateOption = genruntime.ClonePointerToString(source.CreateOption)

	// DeleteOption
	if source.DeleteOption != nil {
		propertyBag.Add("DeleteOption", *source.DeleteOption)
	} else {
		propertyBag.Remove("DeleteOption")
	}

	// DiffDiskSettings
	if source.DiffDiskSettings != nil {
		var diffDiskSetting DiffDiskSettings_STATUS
		err := diffDiskSetting.AssignProperties_From_DiffDiskSettings_STATUS(source.DiffDiskSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DiffDiskSettings_STATUS() to populate field DiffDiskSettings")
		}
		disk.DiffDiskSettings = &diffDiskSetting
	} else {
		disk.DiffDiskSettings = nil
	}

	// DiskSizeGB
	disk.DiskSizeGB = genruntime.ClonePointerToInt(source.DiskSizeGB)

	// Image
	if source.Image != nil {
		var image VirtualHardDisk_STATUS
		err := image.AssignProperties_From_VirtualHardDisk_STATUS(source.Image)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualHardDisk_STATUS() to populate field Image")
		}
		disk.Image = &image
	} else {
		disk.Image = nil
	}

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk VirtualMachineScaleSetManagedDiskParameters_STATUS
		err := managedDisk.AssignProperties_From_VirtualMachineScaleSetManagedDiskParameters_STATUS(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetManagedDiskParameters_STATUS() to populate field ManagedDisk")
		}
		disk.ManagedDisk = &managedDisk
	} else {
		disk.ManagedDisk = nil
	}

	// Name
	disk.Name = genruntime.ClonePointerToString(source.Name)

	// OsType
	disk.OsType = genruntime.ClonePointerToString(source.OsType)

	// VhdContainers
	disk.VhdContainers = genruntime.CloneSliceOfString(source.VhdContainers)

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		disk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		disk.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		disk.PropertyBag = propertyBag
	} else {
		disk.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetOSDisk_STATUS interface (if implemented) to customize the conversion
	var diskAsAny any = disk
	if augmentedDisk, ok := diskAsAny.(augmentConversionForVirtualMachineScaleSetOSDisk_STATUS); ok {
		err := augmentedDisk.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetOSDisk_STATUS populates the provided destination VirtualMachineScaleSetOSDisk_STATUS from our VirtualMachineScaleSetOSDisk_STATUS
func (disk *VirtualMachineScaleSetOSDisk_STATUS) AssignProperties_To_VirtualMachineScaleSetOSDisk_STATUS(destination *v20220301s.VirtualMachineScaleSetOSDisk_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(disk.PropertyBag)

	// Caching
	destination.Caching = genruntime.ClonePointerToString(disk.Caching)

	// CreateOption
	destination.CreateOption = genruntime.ClonePointerToString(disk.CreateOption)

	// DeleteOption
	if propertyBag.Contains("DeleteOption") {
		var deleteOption string
		err := propertyBag.Pull("DeleteOption", &deleteOption)
		if err != nil {
			return errors.Wrap(err, "pulling 'DeleteOption' from propertyBag")
		}

		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// DiffDiskSettings
	if disk.DiffDiskSettings != nil {
		var diffDiskSetting v20220301s.DiffDiskSettings_STATUS
		err := disk.DiffDiskSettings.AssignProperties_To_DiffDiskSettings_STATUS(&diffDiskSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DiffDiskSettings_STATUS() to populate field DiffDiskSettings")
		}
		destination.DiffDiskSettings = &diffDiskSetting
	} else {
		destination.DiffDiskSettings = nil
	}

	// DiskSizeGB
	destination.DiskSizeGB = genruntime.ClonePointerToInt(disk.DiskSizeGB)

	// Image
	if disk.Image != nil {
		var image v20220301s.VirtualHardDisk_STATUS
		err := disk.Image.AssignProperties_To_VirtualHardDisk_STATUS(&image)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualHardDisk_STATUS() to populate field Image")
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// ManagedDisk
	if disk.ManagedDisk != nil {
		var managedDisk v20220301s.VirtualMachineScaleSetManagedDiskParameters_STATUS
		err := disk.ManagedDisk.AssignProperties_To_VirtualMachineScaleSetManagedDiskParameters_STATUS(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetManagedDiskParameters_STATUS() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(disk.Name)

	// OsType
	destination.OsType = genruntime.ClonePointerToString(disk.OsType)

	// VhdContainers
	destination.VhdContainers = genruntime.CloneSliceOfString(disk.VhdContainers)

	// WriteAcceleratorEnabled
	if disk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *disk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetOSDisk_STATUS interface (if implemented) to customize the conversion
	var diskAsAny any = disk
	if augmentedDisk, ok := diskAsAny.(augmentConversionForVirtualMachineScaleSetOSDisk_STATUS); ok {
		err := augmentedDisk.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForApiEntityReference interface {
	AssignPropertiesFrom(src *v20220301s.ApiEntityReference) error
	AssignPropertiesTo(dst *v20220301s.ApiEntityReference) error
}

type augmentConversionForApiEntityReference_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.ApiEntityReference_STATUS) error
	AssignPropertiesTo(dst *v20220301s.ApiEntityReference_STATUS) error
}

type augmentConversionForTerminateNotificationProfile interface {
	AssignPropertiesFrom(src *v20220301s.TerminateNotificationProfile) error
	AssignPropertiesTo(dst *v20220301s.TerminateNotificationProfile) error
}

type augmentConversionForTerminateNotificationProfile_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.TerminateNotificationProfile_STATUS) error
	AssignPropertiesTo(dst *v20220301s.TerminateNotificationProfile_STATUS) error
}

type augmentConversionForVirtualMachineScaleSetDataDisk interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSetDataDisk) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSetDataDisk) error
}

type augmentConversionForVirtualMachineScaleSetDataDisk_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSetDataDisk_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSetDataDisk_STATUS) error
}

type augmentConversionForVirtualMachineScaleSetExtension interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSetExtension) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSetExtension) error
}

type augmentConversionForVirtualMachineScaleSetExtension_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSetExtension_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSetExtension_STATUS) error
}

type augmentConversionForVirtualMachineScaleSetNetworkConfiguration interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSetNetworkConfiguration) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSetNetworkConfiguration) error
}

type augmentConversionForVirtualMachineScaleSetNetworkConfiguration_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSetNetworkConfiguration_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSetNetworkConfiguration_STATUS) error
}

type augmentConversionForVirtualMachineScaleSetOSDisk interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSetOSDisk) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSetOSDisk) error
}

type augmentConversionForVirtualMachineScaleSetOSDisk_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSetOSDisk_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSetOSDisk_STATUS) error
}

// Storage version of v1api20201201.VirtualMachineScaleSetIPConfiguration
// Describes a virtual machine scale set network profile's IP configuration.
type VirtualMachineScaleSetIPConfiguration struct {
	ApplicationGatewayBackendAddressPools []SubResource                                       `json:"applicationGatewayBackendAddressPools,omitempty"`
	ApplicationSecurityGroups             []SubResource                                       `json:"applicationSecurityGroups,omitempty"`
	LoadBalancerBackendAddressPools       []SubResource                                       `json:"loadBalancerBackendAddressPools,omitempty"`
	LoadBalancerInboundNatPools           []SubResource                                       `json:"loadBalancerInboundNatPools,omitempty"`
	Name                                  *string                                             `json:"name,omitempty"`
	Primary                               *bool                                               `json:"primary,omitempty"`
	PrivateIPAddressVersion               *string                                             `json:"privateIPAddressVersion,omitempty"`
	PropertyBag                           genruntime.PropertyBag                              `json:"$propertyBag,omitempty"`
	PublicIPAddressConfiguration          *VirtualMachineScaleSetPublicIPAddressConfiguration `json:"publicIPAddressConfiguration,omitempty"`

	// Reference: Resource Id
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
	Subnet    *ApiEntityReference           `json:"subnet,omitempty"`
}

// AssignProperties_From_VirtualMachineScaleSetIPConfiguration populates our VirtualMachineScaleSetIPConfiguration from the provided source VirtualMachineScaleSetIPConfiguration
func (configuration *VirtualMachineScaleSetIPConfiguration) AssignProperties_From_VirtualMachineScaleSetIPConfiguration(source *v20220301s.VirtualMachineScaleSetIPConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ApplicationGatewayBackendAddressPools
	if source.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]SubResource, len(source.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range source.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var subResourceStash v20210701s.SubResource
			err := subResourceStash.AssignProperties_From_SubResource(&applicationGatewayBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from ApplicationGatewayBackendAddressPools")
			}
			var applicationGatewayBackendAddressPool SubResource
			err = applicationGatewayBackendAddressPool.AssignProperties_From_SubResource(&subResourceStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field ApplicationGatewayBackendAddressPools from SubResourceStash")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		configuration.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		configuration.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if source.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]SubResource, len(source.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range source.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var subResourceStash v20210701s.SubResource
			err := subResourceStash.AssignProperties_From_SubResource(&applicationSecurityGroupItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from ApplicationSecurityGroups")
			}
			var applicationSecurityGroup SubResource
			err = applicationSecurityGroup.AssignProperties_From_SubResource(&subResourceStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field ApplicationSecurityGroups from SubResourceStash")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		configuration.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		configuration.ApplicationSecurityGroups = nil
	}

	// LoadBalancerBackendAddressPools
	if source.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]SubResource, len(source.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range source.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var subResourceStash v20210701s.SubResource
			err := subResourceStash.AssignProperties_From_SubResource(&loadBalancerBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from LoadBalancerBackendAddressPools")
			}
			var loadBalancerBackendAddressPool SubResource
			err = loadBalancerBackendAddressPool.AssignProperties_From_SubResource(&subResourceStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field LoadBalancerBackendAddressPools from SubResourceStash")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		configuration.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		configuration.LoadBalancerBackendAddressPools = nil
	}

	// LoadBalancerInboundNatPools
	if source.LoadBalancerInboundNatPools != nil {
		loadBalancerInboundNatPoolList := make([]SubResource, len(source.LoadBalancerInboundNatPools))
		for loadBalancerInboundNatPoolIndex, loadBalancerInboundNatPoolItem := range source.LoadBalancerInboundNatPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerInboundNatPoolItem := loadBalancerInboundNatPoolItem
			var subResourceStash v20210701s.SubResource
			err := subResourceStash.AssignProperties_From_SubResource(&loadBalancerInboundNatPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from LoadBalancerInboundNatPools")
			}
			var loadBalancerInboundNatPool SubResource
			err = loadBalancerInboundNatPool.AssignProperties_From_SubResource(&subResourceStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field LoadBalancerInboundNatPools from SubResourceStash")
			}
			loadBalancerInboundNatPoolList[loadBalancerInboundNatPoolIndex] = loadBalancerInboundNatPool
		}
		configuration.LoadBalancerInboundNatPools = loadBalancerInboundNatPoolList
	} else {
		configuration.LoadBalancerInboundNatPools = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		configuration.Primary = &primary
	} else {
		configuration.Primary = nil
	}

	// PrivateIPAddressVersion
	configuration.PrivateIPAddressVersion = genruntime.ClonePointerToString(source.PrivateIPAddressVersion)

	// PublicIPAddressConfiguration
	if source.PublicIPAddressConfiguration != nil {
		var publicIPAddressConfiguration VirtualMachineScaleSetPublicIPAddressConfiguration
		err := publicIPAddressConfiguration.AssignProperties_From_VirtualMachineScaleSetPublicIPAddressConfiguration(source.PublicIPAddressConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetPublicIPAddressConfiguration() to populate field PublicIPAddressConfiguration")
		}
		configuration.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	} else {
		configuration.PublicIPAddressConfiguration = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		configuration.Reference = &reference
	} else {
		configuration.Reference = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet ApiEntityReference
		err := subnet.AssignProperties_From_ApiEntityReference(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApiEntityReference() to populate field Subnet")
		}
		configuration.Subnet = &subnet
	} else {
		configuration.Subnet = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetIPConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForVirtualMachineScaleSetIPConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetIPConfiguration populates the provided destination VirtualMachineScaleSetIPConfiguration from our VirtualMachineScaleSetIPConfiguration
func (configuration *VirtualMachineScaleSetIPConfiguration) AssignProperties_To_VirtualMachineScaleSetIPConfiguration(destination *v20220301s.VirtualMachineScaleSetIPConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// ApplicationGatewayBackendAddressPools
	if configuration.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]v20220301s.SubResource, len(configuration.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range configuration.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var subResourceStash v20210701s.SubResource
			err := applicationGatewayBackendAddressPoolItem.AssignProperties_To_SubResource(&subResourceStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from ApplicationGatewayBackendAddressPools")
			}
			var applicationGatewayBackendAddressPool v20220301s.SubResource
			err = subResourceStash.AssignProperties_To_SubResource(&applicationGatewayBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field ApplicationGatewayBackendAddressPools from SubResourceStash")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		destination.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		destination.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if configuration.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]v20220301s.SubResource, len(configuration.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range configuration.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var subResourceStash v20210701s.SubResource
			err := applicationSecurityGroupItem.AssignProperties_To_SubResource(&subResourceStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from ApplicationSecurityGroups")
			}
			var applicationSecurityGroup v20220301s.SubResource
			err = subResourceStash.AssignProperties_To_SubResource(&applicationSecurityGroup)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field ApplicationSecurityGroups from SubResourceStash")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		destination.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		destination.ApplicationSecurityGroups = nil
	}

	// LoadBalancerBackendAddressPools
	if configuration.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]v20220301s.SubResource, len(configuration.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range configuration.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var subResourceStash v20210701s.SubResource
			err := loadBalancerBackendAddressPoolItem.AssignProperties_To_SubResource(&subResourceStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from LoadBalancerBackendAddressPools")
			}
			var loadBalancerBackendAddressPool v20220301s.SubResource
			err = subResourceStash.AssignProperties_To_SubResource(&loadBalancerBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field LoadBalancerBackendAddressPools from SubResourceStash")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		destination.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		destination.LoadBalancerBackendAddressPools = nil
	}

	// LoadBalancerInboundNatPools
	if configuration.LoadBalancerInboundNatPools != nil {
		loadBalancerInboundNatPoolList := make([]v20220301s.SubResource, len(configuration.LoadBalancerInboundNatPools))
		for loadBalancerInboundNatPoolIndex, loadBalancerInboundNatPoolItem := range configuration.LoadBalancerInboundNatPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerInboundNatPoolItem := loadBalancerInboundNatPoolItem
			var subResourceStash v20210701s.SubResource
			err := loadBalancerInboundNatPoolItem.AssignProperties_To_SubResource(&subResourceStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from LoadBalancerInboundNatPools")
			}
			var loadBalancerInboundNatPool v20220301s.SubResource
			err = subResourceStash.AssignProperties_To_SubResource(&loadBalancerInboundNatPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field LoadBalancerInboundNatPools from SubResourceStash")
			}
			loadBalancerInboundNatPoolList[loadBalancerInboundNatPoolIndex] = loadBalancerInboundNatPool
		}
		destination.LoadBalancerInboundNatPools = loadBalancerInboundNatPoolList
	} else {
		destination.LoadBalancerInboundNatPools = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// Primary
	if configuration.Primary != nil {
		primary := *configuration.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// PrivateIPAddressVersion
	destination.PrivateIPAddressVersion = genruntime.ClonePointerToString(configuration.PrivateIPAddressVersion)

	// PublicIPAddressConfiguration
	if configuration.PublicIPAddressConfiguration != nil {
		var publicIPAddressConfiguration v20220301s.VirtualMachineScaleSetPublicIPAddressConfiguration
		err := configuration.PublicIPAddressConfiguration.AssignProperties_To_VirtualMachineScaleSetPublicIPAddressConfiguration(&publicIPAddressConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetPublicIPAddressConfiguration() to populate field PublicIPAddressConfiguration")
		}
		destination.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	} else {
		destination.PublicIPAddressConfiguration = nil
	}

	// Reference
	if configuration.Reference != nil {
		reference := configuration.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Subnet
	if configuration.Subnet != nil {
		var subnet v20220301s.ApiEntityReference
		err := configuration.Subnet.AssignProperties_To_ApiEntityReference(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApiEntityReference() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetIPConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForVirtualMachineScaleSetIPConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineScaleSetIPConfiguration_STATUS
// Describes a virtual machine scale set network profile's IP configuration.
type VirtualMachineScaleSetIPConfiguration_STATUS struct {
	ApplicationGatewayBackendAddressPools []SubResource_STATUS                                       `json:"applicationGatewayBackendAddressPools,omitempty"`
	ApplicationSecurityGroups             []SubResource_STATUS                                       `json:"applicationSecurityGroups,omitempty"`
	Id                                    *string                                                    `json:"id,omitempty"`
	LoadBalancerBackendAddressPools       []SubResource_STATUS                                       `json:"loadBalancerBackendAddressPools,omitempty"`
	LoadBalancerInboundNatPools           []SubResource_STATUS                                       `json:"loadBalancerInboundNatPools,omitempty"`
	Name                                  *string                                                    `json:"name,omitempty"`
	Primary                               *bool                                                      `json:"primary,omitempty"`
	PrivateIPAddressVersion               *string                                                    `json:"privateIPAddressVersion,omitempty"`
	PropertyBag                           genruntime.PropertyBag                                     `json:"$propertyBag,omitempty"`
	PublicIPAddressConfiguration          *VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS `json:"publicIPAddressConfiguration,omitempty"`
	Subnet                                *ApiEntityReference_STATUS                                 `json:"subnet,omitempty"`
}

// AssignProperties_From_VirtualMachineScaleSetIPConfiguration_STATUS populates our VirtualMachineScaleSetIPConfiguration_STATUS from the provided source VirtualMachineScaleSetIPConfiguration_STATUS
func (configuration *VirtualMachineScaleSetIPConfiguration_STATUS) AssignProperties_From_VirtualMachineScaleSetIPConfiguration_STATUS(source *v20220301s.VirtualMachineScaleSetIPConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ApplicationGatewayBackendAddressPools
	if source.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]SubResource_STATUS, len(source.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range source.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var subResourceSTATUSStash v20210701s.SubResource_STATUS
			err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(&applicationGatewayBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from ApplicationGatewayBackendAddressPools")
			}
			var applicationGatewayBackendAddressPool SubResource_STATUS
			err = applicationGatewayBackendAddressPool.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field ApplicationGatewayBackendAddressPools from SubResource_STATUSStash")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		configuration.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		configuration.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if source.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]SubResource_STATUS, len(source.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range source.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var subResourceSTATUSStash v20210701s.SubResource_STATUS
			err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(&applicationSecurityGroupItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from ApplicationSecurityGroups")
			}
			var applicationSecurityGroup SubResource_STATUS
			err = applicationSecurityGroup.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field ApplicationSecurityGroups from SubResource_STATUSStash")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		configuration.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		configuration.ApplicationSecurityGroups = nil
	}

	// Id
	configuration.Id = genruntime.ClonePointerToString(source.Id)

	// LoadBalancerBackendAddressPools
	if source.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]SubResource_STATUS, len(source.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range source.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var subResourceSTATUSStash v20210701s.SubResource_STATUS
			err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(&loadBalancerBackendAddressPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from LoadBalancerBackendAddressPools")
			}
			var loadBalancerBackendAddressPool SubResource_STATUS
			err = loadBalancerBackendAddressPool.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field LoadBalancerBackendAddressPools from SubResource_STATUSStash")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		configuration.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		configuration.LoadBalancerBackendAddressPools = nil
	}

	// LoadBalancerInboundNatPools
	if source.LoadBalancerInboundNatPools != nil {
		loadBalancerInboundNatPoolList := make([]SubResource_STATUS, len(source.LoadBalancerInboundNatPools))
		for loadBalancerInboundNatPoolIndex, loadBalancerInboundNatPoolItem := range source.LoadBalancerInboundNatPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerInboundNatPoolItem := loadBalancerInboundNatPoolItem
			var subResourceSTATUSStash v20210701s.SubResource_STATUS
			err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(&loadBalancerInboundNatPoolItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from LoadBalancerInboundNatPools")
			}
			var loadBalancerInboundNatPool SubResource_STATUS
			err = loadBalancerInboundNatPool.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field LoadBalancerInboundNatPools from SubResource_STATUSStash")
			}
			loadBalancerInboundNatPoolList[loadBalancerInboundNatPoolIndex] = loadBalancerInboundNatPool
		}
		configuration.LoadBalancerInboundNatPools = loadBalancerInboundNatPoolList
	} else {
		configuration.LoadBalancerInboundNatPools = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		configuration.Primary = &primary
	} else {
		configuration.Primary = nil
	}

	// PrivateIPAddressVersion
	configuration.PrivateIPAddressVersion = genruntime.ClonePointerToString(source.PrivateIPAddressVersion)

	// PublicIPAddressConfiguration
	if source.PublicIPAddressConfiguration != nil {
		var publicIPAddressConfiguration VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS
		err := publicIPAddressConfiguration.AssignProperties_From_VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS(source.PublicIPAddressConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS() to populate field PublicIPAddressConfiguration")
		}
		configuration.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	} else {
		configuration.PublicIPAddressConfiguration = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet ApiEntityReference_STATUS
		err := subnet.AssignProperties_From_ApiEntityReference_STATUS(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ApiEntityReference_STATUS() to populate field Subnet")
		}
		configuration.Subnet = &subnet
	} else {
		configuration.Subnet = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetIPConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForVirtualMachineScaleSetIPConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetIPConfiguration_STATUS populates the provided destination VirtualMachineScaleSetIPConfiguration_STATUS from our VirtualMachineScaleSetIPConfiguration_STATUS
func (configuration *VirtualMachineScaleSetIPConfiguration_STATUS) AssignProperties_To_VirtualMachineScaleSetIPConfiguration_STATUS(destination *v20220301s.VirtualMachineScaleSetIPConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// ApplicationGatewayBackendAddressPools
	if configuration.ApplicationGatewayBackendAddressPools != nil {
		applicationGatewayBackendAddressPoolList := make([]v20220301s.SubResource_STATUS, len(configuration.ApplicationGatewayBackendAddressPools))
		for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range configuration.ApplicationGatewayBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
			var subResourceSTATUSStash v20210701s.SubResource_STATUS
			err := applicationGatewayBackendAddressPoolItem.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from ApplicationGatewayBackendAddressPools")
			}
			var applicationGatewayBackendAddressPool v20220301s.SubResource_STATUS
			err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&applicationGatewayBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field ApplicationGatewayBackendAddressPools from SubResource_STATUSStash")
			}
			applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
		}
		destination.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList
	} else {
		destination.ApplicationGatewayBackendAddressPools = nil
	}

	// ApplicationSecurityGroups
	if configuration.ApplicationSecurityGroups != nil {
		applicationSecurityGroupList := make([]v20220301s.SubResource_STATUS, len(configuration.ApplicationSecurityGroups))
		for applicationSecurityGroupIndex, applicationSecurityGroupItem := range configuration.ApplicationSecurityGroups {
			// Shadow the loop variable to avoid aliasing
			applicationSecurityGroupItem := applicationSecurityGroupItem
			var subResourceSTATUSStash v20210701s.SubResource_STATUS
			err := applicationSecurityGroupItem.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from ApplicationSecurityGroups")
			}
			var applicationSecurityGroup v20220301s.SubResource_STATUS
			err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&applicationSecurityGroup)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field ApplicationSecurityGroups from SubResource_STATUSStash")
			}
			applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
		}
		destination.ApplicationSecurityGroups = applicationSecurityGroupList
	} else {
		destination.ApplicationSecurityGroups = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(configuration.Id)

	// LoadBalancerBackendAddressPools
	if configuration.LoadBalancerBackendAddressPools != nil {
		loadBalancerBackendAddressPoolList := make([]v20220301s.SubResource_STATUS, len(configuration.LoadBalancerBackendAddressPools))
		for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range configuration.LoadBalancerBackendAddressPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
			var subResourceSTATUSStash v20210701s.SubResource_STATUS
			err := loadBalancerBackendAddressPoolItem.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from LoadBalancerBackendAddressPools")
			}
			var loadBalancerBackendAddressPool v20220301s.SubResource_STATUS
			err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&loadBalancerBackendAddressPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field LoadBalancerBackendAddressPools from SubResource_STATUSStash")
			}
			loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
		}
		destination.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList
	} else {
		destination.LoadBalancerBackendAddressPools = nil
	}

	// LoadBalancerInboundNatPools
	if configuration.LoadBalancerInboundNatPools != nil {
		loadBalancerInboundNatPoolList := make([]v20220301s.SubResource_STATUS, len(configuration.LoadBalancerInboundNatPools))
		for loadBalancerInboundNatPoolIndex, loadBalancerInboundNatPoolItem := range configuration.LoadBalancerInboundNatPools {
			// Shadow the loop variable to avoid aliasing
			loadBalancerInboundNatPoolItem := loadBalancerInboundNatPoolItem
			var subResourceSTATUSStash v20210701s.SubResource_STATUS
			err := loadBalancerInboundNatPoolItem.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from LoadBalancerInboundNatPools")
			}
			var loadBalancerInboundNatPool v20220301s.SubResource_STATUS
			err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&loadBalancerInboundNatPool)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field LoadBalancerInboundNatPools from SubResource_STATUSStash")
			}
			loadBalancerInboundNatPoolList[loadBalancerInboundNatPoolIndex] = loadBalancerInboundNatPool
		}
		destination.LoadBalancerInboundNatPools = loadBalancerInboundNatPoolList
	} else {
		destination.LoadBalancerInboundNatPools = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// Primary
	if configuration.Primary != nil {
		primary := *configuration.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// PrivateIPAddressVersion
	destination.PrivateIPAddressVersion = genruntime.ClonePointerToString(configuration.PrivateIPAddressVersion)

	// PublicIPAddressConfiguration
	if configuration.PublicIPAddressConfiguration != nil {
		var publicIPAddressConfiguration v20220301s.VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS
		err := configuration.PublicIPAddressConfiguration.AssignProperties_To_VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS(&publicIPAddressConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS() to populate field PublicIPAddressConfiguration")
		}
		destination.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	} else {
		destination.PublicIPAddressConfiguration = nil
	}

	// Subnet
	if configuration.Subnet != nil {
		var subnet v20220301s.ApiEntityReference_STATUS
		err := configuration.Subnet.AssignProperties_To_ApiEntityReference_STATUS(&subnet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ApiEntityReference_STATUS() to populate field Subnet")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetIPConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForVirtualMachineScaleSetIPConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineScaleSetManagedDiskParameters
// Describes the parameters of a ScaleSet managed disk.
type VirtualMachineScaleSetManagedDiskParameters struct {
	DiskEncryptionSet  *SubResource           `json:"diskEncryptionSet,omitempty"`
	PropertyBag        genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	StorageAccountType *string                `json:"storageAccountType,omitempty"`
}

// AssignProperties_From_VirtualMachineScaleSetManagedDiskParameters populates our VirtualMachineScaleSetManagedDiskParameters from the provided source VirtualMachineScaleSetManagedDiskParameters
func (parameters *VirtualMachineScaleSetManagedDiskParameters) AssignProperties_From_VirtualMachineScaleSetManagedDiskParameters(source *v20220301s.VirtualMachineScaleSetManagedDiskParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DiskEncryptionSet
	if source.DiskEncryptionSet != nil {
		var subResourceStash v20210701s.SubResource
		err := subResourceStash.AssignProperties_From_SubResource(source.DiskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from DiskEncryptionSet")
		}
		var diskEncryptionSet SubResource
		err = diskEncryptionSet.AssignProperties_From_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field DiskEncryptionSet from SubResourceStash")
		}
		parameters.DiskEncryptionSet = &diskEncryptionSet
	} else {
		parameters.DiskEncryptionSet = nil
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		propertyBag.Add("SecurityProfile", *source.SecurityProfile)
	} else {
		propertyBag.Remove("SecurityProfile")
	}

	// StorageAccountType
	parameters.StorageAccountType = genruntime.ClonePointerToString(source.StorageAccountType)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetManagedDiskParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForVirtualMachineScaleSetManagedDiskParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetManagedDiskParameters populates the provided destination VirtualMachineScaleSetManagedDiskParameters from our VirtualMachineScaleSetManagedDiskParameters
func (parameters *VirtualMachineScaleSetManagedDiskParameters) AssignProperties_To_VirtualMachineScaleSetManagedDiskParameters(destination *v20220301s.VirtualMachineScaleSetManagedDiskParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// DiskEncryptionSet
	if parameters.DiskEncryptionSet != nil {
		var subResourceStash v20210701s.SubResource
		err := parameters.DiskEncryptionSet.AssignProperties_To_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from DiskEncryptionSet")
		}
		var diskEncryptionSet v20220301s.SubResource
		err = subResourceStash.AssignProperties_To_SubResource(&diskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field DiskEncryptionSet from SubResourceStash")
		}
		destination.DiskEncryptionSet = &diskEncryptionSet
	} else {
		destination.DiskEncryptionSet = nil
	}

	// SecurityProfile
	if propertyBag.Contains("SecurityProfile") {
		var securityProfile v20220301s.VMDiskSecurityProfile
		err := propertyBag.Pull("SecurityProfile", &securityProfile)
		if err != nil {
			return errors.Wrap(err, "pulling 'SecurityProfile' from propertyBag")
		}

		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// StorageAccountType
	destination.StorageAccountType = genruntime.ClonePointerToString(parameters.StorageAccountType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetManagedDiskParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForVirtualMachineScaleSetManagedDiskParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineScaleSetManagedDiskParameters_STATUS
// Describes the parameters of a ScaleSet managed disk.
type VirtualMachineScaleSetManagedDiskParameters_STATUS struct {
	DiskEncryptionSet  *SubResource_STATUS    `json:"diskEncryptionSet,omitempty"`
	PropertyBag        genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	StorageAccountType *string                `json:"storageAccountType,omitempty"`
}

// AssignProperties_From_VirtualMachineScaleSetManagedDiskParameters_STATUS populates our VirtualMachineScaleSetManagedDiskParameters_STATUS from the provided source VirtualMachineScaleSetManagedDiskParameters_STATUS
func (parameters *VirtualMachineScaleSetManagedDiskParameters_STATUS) AssignProperties_From_VirtualMachineScaleSetManagedDiskParameters_STATUS(source *v20220301s.VirtualMachineScaleSetManagedDiskParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DiskEncryptionSet
	if source.DiskEncryptionSet != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(source.DiskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from DiskEncryptionSet")
		}
		var diskEncryptionSet SubResource_STATUS
		err = diskEncryptionSet.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field DiskEncryptionSet from SubResource_STATUSStash")
		}
		parameters.DiskEncryptionSet = &diskEncryptionSet
	} else {
		parameters.DiskEncryptionSet = nil
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		propertyBag.Add("SecurityProfile", *source.SecurityProfile)
	} else {
		propertyBag.Remove("SecurityProfile")
	}

	// StorageAccountType
	parameters.StorageAccountType = genruntime.ClonePointerToString(source.StorageAccountType)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetManagedDiskParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForVirtualMachineScaleSetManagedDiskParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetManagedDiskParameters_STATUS populates the provided destination VirtualMachineScaleSetManagedDiskParameters_STATUS from our VirtualMachineScaleSetManagedDiskParameters_STATUS
func (parameters *VirtualMachineScaleSetManagedDiskParameters_STATUS) AssignProperties_To_VirtualMachineScaleSetManagedDiskParameters_STATUS(destination *v20220301s.VirtualMachineScaleSetManagedDiskParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// DiskEncryptionSet
	if parameters.DiskEncryptionSet != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := parameters.DiskEncryptionSet.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from DiskEncryptionSet")
		}
		var diskEncryptionSet v20220301s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&diskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field DiskEncryptionSet from SubResource_STATUSStash")
		}
		destination.DiskEncryptionSet = &diskEncryptionSet
	} else {
		destination.DiskEncryptionSet = nil
	}

	// SecurityProfile
	if propertyBag.Contains("SecurityProfile") {
		var securityProfile v20220301s.VMDiskSecurityProfile_STATUS
		err := propertyBag.Pull("SecurityProfile", &securityProfile)
		if err != nil {
			return errors.Wrap(err, "pulling 'SecurityProfile' from propertyBag")
		}

		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// StorageAccountType
	destination.StorageAccountType = genruntime.ClonePointerToString(parameters.StorageAccountType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetManagedDiskParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForVirtualMachineScaleSetManagedDiskParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineScaleSetNetworkConfigurationDnsSettings
// Describes a virtual machines scale sets network configuration's DNS settings.
type VirtualMachineScaleSetNetworkConfigurationDnsSettings struct {
	DnsServers  []string               `json:"dnsServers,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_VirtualMachineScaleSetNetworkConfigurationDnsSettings populates our VirtualMachineScaleSetNetworkConfigurationDnsSettings from the provided source VirtualMachineScaleSetNetworkConfigurationDnsSettings
func (settings *VirtualMachineScaleSetNetworkConfigurationDnsSettings) AssignProperties_From_VirtualMachineScaleSetNetworkConfigurationDnsSettings(source *v20220301s.VirtualMachineScaleSetNetworkConfigurationDnsSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DnsServers
	settings.DnsServers = genruntime.CloneSliceOfString(source.DnsServers)

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetNetworkConfigurationDnsSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForVirtualMachineScaleSetNetworkConfigurationDnsSettings); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetNetworkConfigurationDnsSettings populates the provided destination VirtualMachineScaleSetNetworkConfigurationDnsSettings from our VirtualMachineScaleSetNetworkConfigurationDnsSettings
func (settings *VirtualMachineScaleSetNetworkConfigurationDnsSettings) AssignProperties_To_VirtualMachineScaleSetNetworkConfigurationDnsSettings(destination *v20220301s.VirtualMachineScaleSetNetworkConfigurationDnsSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// DnsServers
	destination.DnsServers = genruntime.CloneSliceOfString(settings.DnsServers)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetNetworkConfigurationDnsSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForVirtualMachineScaleSetNetworkConfigurationDnsSettings); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS
// Describes a virtual machines scale sets network configuration's DNS settings.
type VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS struct {
	DnsServers  []string               `json:"dnsServers,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS populates our VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS from the provided source VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS
func (settings *VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS) AssignProperties_From_VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS(source *v20220301s.VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DnsServers
	settings.DnsServers = genruntime.CloneSliceOfString(source.DnsServers)

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForVirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS populates the provided destination VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS from our VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS
func (settings *VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS) AssignProperties_To_VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS(destination *v20220301s.VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// DnsServers
	destination.DnsServers = genruntime.CloneSliceOfString(settings.DnsServers)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForVirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForVirtualMachineScaleSetIPConfiguration interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSetIPConfiguration) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSetIPConfiguration) error
}

type augmentConversionForVirtualMachineScaleSetIPConfiguration_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSetIPConfiguration_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSetIPConfiguration_STATUS) error
}

type augmentConversionForVirtualMachineScaleSetManagedDiskParameters interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSetManagedDiskParameters) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSetManagedDiskParameters) error
}

type augmentConversionForVirtualMachineScaleSetManagedDiskParameters_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSetManagedDiskParameters_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSetManagedDiskParameters_STATUS) error
}

type augmentConversionForVirtualMachineScaleSetNetworkConfigurationDnsSettings interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSetNetworkConfigurationDnsSettings) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSetNetworkConfigurationDnsSettings) error
}

type augmentConversionForVirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSetNetworkConfigurationDnsSettings_STATUS) error
}

// Storage version of v1api20201201.VirtualMachineScaleSetPublicIPAddressConfiguration
// Describes a virtual machines scale set IP Configuration's PublicIPAddress configuration
type VirtualMachineScaleSetPublicIPAddressConfiguration struct {
	DnsSettings            *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings `json:"dnsSettings,omitempty"`
	IdleTimeoutInMinutes   *int                                                           `json:"idleTimeoutInMinutes,omitempty"`
	IpTags                 []VirtualMachineScaleSetIpTag                                  `json:"ipTags,omitempty"`
	Name                   *string                                                        `json:"name,omitempty"`
	PropertyBag            genruntime.PropertyBag                                         `json:"$propertyBag,omitempty"`
	PublicIPAddressVersion *string                                                        `json:"publicIPAddressVersion,omitempty"`
	PublicIPPrefix         *SubResource                                                   `json:"publicIPPrefix,omitempty"`
}

// AssignProperties_From_VirtualMachineScaleSetPublicIPAddressConfiguration populates our VirtualMachineScaleSetPublicIPAddressConfiguration from the provided source VirtualMachineScaleSetPublicIPAddressConfiguration
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration) AssignProperties_From_VirtualMachineScaleSetPublicIPAddressConfiguration(source *v20220301s.VirtualMachineScaleSetPublicIPAddressConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DeleteOption
	if source.DeleteOption != nil {
		propertyBag.Add("DeleteOption", *source.DeleteOption)
	} else {
		propertyBag.Remove("DeleteOption")
	}

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings
		err := dnsSetting.AssignProperties_From_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings() to populate field DnsSettings")
		}
		configuration.DnsSettings = &dnsSetting
	} else {
		configuration.DnsSettings = nil
	}

	// IdleTimeoutInMinutes
	configuration.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// IpTags
	if source.IpTags != nil {
		ipTagList := make([]VirtualMachineScaleSetIpTag, len(source.IpTags))
		for ipTagIndex, ipTagItem := range source.IpTags {
			// Shadow the loop variable to avoid aliasing
			ipTagItem := ipTagItem
			var ipTag VirtualMachineScaleSetIpTag
			err := ipTag.AssignProperties_From_VirtualMachineScaleSetIpTag(&ipTagItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetIpTag() to populate field IpTags")
			}
			ipTagList[ipTagIndex] = ipTag
		}
		configuration.IpTags = ipTagList
	} else {
		configuration.IpTags = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// PublicIPAddressVersion
	configuration.PublicIPAddressVersion = genruntime.ClonePointerToString(source.PublicIPAddressVersion)

	// PublicIPPrefix
	if source.PublicIPPrefix != nil {
		var subResourceStash v20210701s.SubResource
		err := subResourceStash.AssignProperties_From_SubResource(source.PublicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field SubResourceStash from PublicIPPrefix")
		}
		var publicIPPrefix SubResource
		err = publicIPPrefix.AssignProperties_From_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource() to populate field PublicIPPrefix from SubResourceStash")
		}
		configuration.PublicIPPrefix = &publicIPPrefix
	} else {
		configuration.PublicIPPrefix = nil
	}

	// Sku
	if source.Sku != nil {
		propertyBag.Add("Sku", *source.Sku)
	} else {
		propertyBag.Remove("Sku")
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetPublicIPAddressConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForVirtualMachineScaleSetPublicIPAddressConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetPublicIPAddressConfiguration populates the provided destination VirtualMachineScaleSetPublicIPAddressConfiguration from our VirtualMachineScaleSetPublicIPAddressConfiguration
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration) AssignProperties_To_VirtualMachineScaleSetPublicIPAddressConfiguration(destination *v20220301s.VirtualMachineScaleSetPublicIPAddressConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// DeleteOption
	if propertyBag.Contains("DeleteOption") {
		var deleteOption string
		err := propertyBag.Pull("DeleteOption", &deleteOption)
		if err != nil {
			return errors.Wrap(err, "pulling 'DeleteOption' from propertyBag")
		}

		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// DnsSettings
	if configuration.DnsSettings != nil {
		var dnsSetting v20220301s.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings
		err := configuration.DnsSettings.AssignProperties_To_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(configuration.IdleTimeoutInMinutes)

	// IpTags
	if configuration.IpTags != nil {
		ipTagList := make([]v20220301s.VirtualMachineScaleSetIpTag, len(configuration.IpTags))
		for ipTagIndex, ipTagItem := range configuration.IpTags {
			// Shadow the loop variable to avoid aliasing
			ipTagItem := ipTagItem
			var ipTag v20220301s.VirtualMachineScaleSetIpTag
			err := ipTagItem.AssignProperties_To_VirtualMachineScaleSetIpTag(&ipTag)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetIpTag() to populate field IpTags")
			}
			ipTagList[ipTagIndex] = ipTag
		}
		destination.IpTags = ipTagList
	} else {
		destination.IpTags = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// PublicIPAddressVersion
	destination.PublicIPAddressVersion = genruntime.ClonePointerToString(configuration.PublicIPAddressVersion)

	// PublicIPPrefix
	if configuration.PublicIPPrefix != nil {
		var subResourceStash v20210701s.SubResource
		err := configuration.PublicIPPrefix.AssignProperties_To_SubResource(&subResourceStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field SubResourceStash from PublicIPPrefix")
		}
		var publicIPPrefix v20220301s.SubResource
		err = subResourceStash.AssignProperties_To_SubResource(&publicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource() to populate field PublicIPPrefix from SubResourceStash")
		}
		destination.PublicIPPrefix = &publicIPPrefix
	} else {
		destination.PublicIPPrefix = nil
	}

	// Sku
	if propertyBag.Contains("Sku") {
		var sku v20220301s.PublicIPAddressSku
		err := propertyBag.Pull("Sku", &sku)
		if err != nil {
			return errors.Wrap(err, "pulling 'Sku' from propertyBag")
		}

		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetPublicIPAddressConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForVirtualMachineScaleSetPublicIPAddressConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS
// Describes a virtual machines scale set IP Configuration's PublicIPAddress configuration
type VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS struct {
	DnsSettings            *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS `json:"dnsSettings,omitempty"`
	IdleTimeoutInMinutes   *int                                                                  `json:"idleTimeoutInMinutes,omitempty"`
	IpTags                 []VirtualMachineScaleSetIpTag_STATUS                                  `json:"ipTags,omitempty"`
	Name                   *string                                                               `json:"name,omitempty"`
	PropertyBag            genruntime.PropertyBag                                                `json:"$propertyBag,omitempty"`
	PublicIPAddressVersion *string                                                               `json:"publicIPAddressVersion,omitempty"`
	PublicIPPrefix         *SubResource_STATUS                                                   `json:"publicIPPrefix,omitempty"`
}

// AssignProperties_From_VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS populates our VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS from the provided source VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS) AssignProperties_From_VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS(source *v20220301s.VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DeleteOption
	if source.DeleteOption != nil {
		propertyBag.Add("DeleteOption", *source.DeleteOption)
	} else {
		propertyBag.Remove("DeleteOption")
	}

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS
		err := dnsSetting.AssignProperties_From_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS() to populate field DnsSettings")
		}
		configuration.DnsSettings = &dnsSetting
	} else {
		configuration.DnsSettings = nil
	}

	// IdleTimeoutInMinutes
	configuration.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// IpTags
	if source.IpTags != nil {
		ipTagList := make([]VirtualMachineScaleSetIpTag_STATUS, len(source.IpTags))
		for ipTagIndex, ipTagItem := range source.IpTags {
			// Shadow the loop variable to avoid aliasing
			ipTagItem := ipTagItem
			var ipTag VirtualMachineScaleSetIpTag_STATUS
			err := ipTag.AssignProperties_From_VirtualMachineScaleSetIpTag_STATUS(&ipTagItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_VirtualMachineScaleSetIpTag_STATUS() to populate field IpTags")
			}
			ipTagList[ipTagIndex] = ipTag
		}
		configuration.IpTags = ipTagList
	} else {
		configuration.IpTags = nil
	}

	// Name
	configuration.Name = genruntime.ClonePointerToString(source.Name)

	// PublicIPAddressVersion
	configuration.PublicIPAddressVersion = genruntime.ClonePointerToString(source.PublicIPAddressVersion)

	// PublicIPPrefix
	if source.PublicIPPrefix != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := subResourceSTATUSStash.AssignProperties_From_SubResource_STATUS(source.PublicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field SubResource_STATUSStash from PublicIPPrefix")
		}
		var publicIPPrefix SubResource_STATUS
		err = publicIPPrefix.AssignProperties_From_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SubResource_STATUS() to populate field PublicIPPrefix from SubResource_STATUSStash")
		}
		configuration.PublicIPPrefix = &publicIPPrefix
	} else {
		configuration.PublicIPPrefix = nil
	}

	// Sku
	if source.Sku != nil {
		propertyBag.Add("Sku", *source.Sku)
	} else {
		propertyBag.Remove("Sku")
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetPublicIPAddressConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForVirtualMachineScaleSetPublicIPAddressConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS populates the provided destination VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS from our VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS
func (configuration *VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS) AssignProperties_To_VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS(destination *v20220301s.VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// DeleteOption
	if propertyBag.Contains("DeleteOption") {
		var deleteOption string
		err := propertyBag.Pull("DeleteOption", &deleteOption)
		if err != nil {
			return errors.Wrap(err, "pulling 'DeleteOption' from propertyBag")
		}

		destination.DeleteOption = &deleteOption
	} else {
		destination.DeleteOption = nil
	}

	// DnsSettings
	if configuration.DnsSettings != nil {
		var dnsSetting v20220301s.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS
		err := configuration.DnsSettings.AssignProperties_To_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS() to populate field DnsSettings")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(configuration.IdleTimeoutInMinutes)

	// IpTags
	if configuration.IpTags != nil {
		ipTagList := make([]v20220301s.VirtualMachineScaleSetIpTag_STATUS, len(configuration.IpTags))
		for ipTagIndex, ipTagItem := range configuration.IpTags {
			// Shadow the loop variable to avoid aliasing
			ipTagItem := ipTagItem
			var ipTag v20220301s.VirtualMachineScaleSetIpTag_STATUS
			err := ipTagItem.AssignProperties_To_VirtualMachineScaleSetIpTag_STATUS(&ipTag)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_VirtualMachineScaleSetIpTag_STATUS() to populate field IpTags")
			}
			ipTagList[ipTagIndex] = ipTag
		}
		destination.IpTags = ipTagList
	} else {
		destination.IpTags = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(configuration.Name)

	// PublicIPAddressVersion
	destination.PublicIPAddressVersion = genruntime.ClonePointerToString(configuration.PublicIPAddressVersion)

	// PublicIPPrefix
	if configuration.PublicIPPrefix != nil {
		var subResourceSTATUSStash v20210701s.SubResource_STATUS
		err := configuration.PublicIPPrefix.AssignProperties_To_SubResource_STATUS(&subResourceSTATUSStash)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field SubResource_STATUSStash from PublicIPPrefix")
		}
		var publicIPPrefix v20220301s.SubResource_STATUS
		err = subResourceSTATUSStash.AssignProperties_To_SubResource_STATUS(&publicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SubResource_STATUS() to populate field PublicIPPrefix from SubResource_STATUSStash")
		}
		destination.PublicIPPrefix = &publicIPPrefix
	} else {
		destination.PublicIPPrefix = nil
	}

	// Sku
	if propertyBag.Contains("Sku") {
		var sku v20220301s.PublicIPAddressSku_STATUS
		err := propertyBag.Pull("Sku", &sku)
		if err != nil {
			return errors.Wrap(err, "pulling 'Sku' from propertyBag")
		}

		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetPublicIPAddressConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForVirtualMachineScaleSetPublicIPAddressConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForVirtualMachineScaleSetPublicIPAddressConfiguration interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSetPublicIPAddressConfiguration) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSetPublicIPAddressConfiguration) error
}

type augmentConversionForVirtualMachineScaleSetPublicIPAddressConfiguration_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSetPublicIPAddressConfiguration_STATUS) error
}

// Storage version of v1api20201201.VirtualMachineScaleSetIpTag
// Contains the IP tag associated with the public IP address.
type VirtualMachineScaleSetIpTag struct {
	IpTagType   *string                `json:"ipTagType,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Tag         *string                `json:"tag,omitempty"`
}

// AssignProperties_From_VirtualMachineScaleSetIpTag populates our VirtualMachineScaleSetIpTag from the provided source VirtualMachineScaleSetIpTag
func (ipTag *VirtualMachineScaleSetIpTag) AssignProperties_From_VirtualMachineScaleSetIpTag(source *v20220301s.VirtualMachineScaleSetIpTag) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// IpTagType
	ipTag.IpTagType = genruntime.ClonePointerToString(source.IpTagType)

	// Tag
	ipTag.Tag = genruntime.ClonePointerToString(source.Tag)

	// Update the property bag
	if len(propertyBag) > 0 {
		ipTag.PropertyBag = propertyBag
	} else {
		ipTag.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetIpTag interface (if implemented) to customize the conversion
	var ipTagAsAny any = ipTag
	if augmentedIpTag, ok := ipTagAsAny.(augmentConversionForVirtualMachineScaleSetIpTag); ok {
		err := augmentedIpTag.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetIpTag populates the provided destination VirtualMachineScaleSetIpTag from our VirtualMachineScaleSetIpTag
func (ipTag *VirtualMachineScaleSetIpTag) AssignProperties_To_VirtualMachineScaleSetIpTag(destination *v20220301s.VirtualMachineScaleSetIpTag) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(ipTag.PropertyBag)

	// IpTagType
	destination.IpTagType = genruntime.ClonePointerToString(ipTag.IpTagType)

	// Tag
	destination.Tag = genruntime.ClonePointerToString(ipTag.Tag)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetIpTag interface (if implemented) to customize the conversion
	var ipTagAsAny any = ipTag
	if augmentedIpTag, ok := ipTagAsAny.(augmentConversionForVirtualMachineScaleSetIpTag); ok {
		err := augmentedIpTag.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineScaleSetIpTag_STATUS
// Contains the IP tag associated with the public IP address.
type VirtualMachineScaleSetIpTag_STATUS struct {
	IpTagType   *string                `json:"ipTagType,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Tag         *string                `json:"tag,omitempty"`
}

// AssignProperties_From_VirtualMachineScaleSetIpTag_STATUS populates our VirtualMachineScaleSetIpTag_STATUS from the provided source VirtualMachineScaleSetIpTag_STATUS
func (ipTag *VirtualMachineScaleSetIpTag_STATUS) AssignProperties_From_VirtualMachineScaleSetIpTag_STATUS(source *v20220301s.VirtualMachineScaleSetIpTag_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// IpTagType
	ipTag.IpTagType = genruntime.ClonePointerToString(source.IpTagType)

	// Tag
	ipTag.Tag = genruntime.ClonePointerToString(source.Tag)

	// Update the property bag
	if len(propertyBag) > 0 {
		ipTag.PropertyBag = propertyBag
	} else {
		ipTag.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetIpTag_STATUS interface (if implemented) to customize the conversion
	var ipTagAsAny any = ipTag
	if augmentedIpTag, ok := ipTagAsAny.(augmentConversionForVirtualMachineScaleSetIpTag_STATUS); ok {
		err := augmentedIpTag.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetIpTag_STATUS populates the provided destination VirtualMachineScaleSetIpTag_STATUS from our VirtualMachineScaleSetIpTag_STATUS
func (ipTag *VirtualMachineScaleSetIpTag_STATUS) AssignProperties_To_VirtualMachineScaleSetIpTag_STATUS(destination *v20220301s.VirtualMachineScaleSetIpTag_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(ipTag.PropertyBag)

	// IpTagType
	destination.IpTagType = genruntime.ClonePointerToString(ipTag.IpTagType)

	// Tag
	destination.Tag = genruntime.ClonePointerToString(ipTag.Tag)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetIpTag_STATUS interface (if implemented) to customize the conversion
	var ipTagAsAny any = ipTag
	if augmentedIpTag, ok := ipTagAsAny.(augmentConversionForVirtualMachineScaleSetIpTag_STATUS); ok {
		err := augmentedIpTag.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings
// Describes a virtual machines scale sets network configuration's DNS settings.
type VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings struct {
	DomainNameLabel *string                `json:"domainNameLabel,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings populates our VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings from the provided source VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings
func (settings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings) AssignProperties_From_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings(source *v20220301s.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DomainNameLabel
	settings.DomainNameLabel = genruntime.ClonePointerToString(source.DomainNameLabel)

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings populates the provided destination VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings from our VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings
func (settings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings) AssignProperties_To_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings(destination *v20220301s.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// DomainNameLabel
	destination.DomainNameLabel = genruntime.ClonePointerToString(settings.DomainNameLabel)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20201201.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS
// Describes a virtual machines scale sets network configuration's DNS settings.
type VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS struct {
	DomainNameLabel *string                `json:"domainNameLabel,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS populates our VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS from the provided source VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS
func (settings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS) AssignProperties_From_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS(source *v20220301s.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DomainNameLabel
	settings.DomainNameLabel = genruntime.ClonePointerToString(source.DomainNameLabel)

	// Update the property bag
	if len(propertyBag) > 0 {
		settings.PropertyBag = propertyBag
	} else {
		settings.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS populates the provided destination VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS from our VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS
func (settings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS) AssignProperties_To_VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS(destination *v20220301s.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(settings.PropertyBag)

	// DomainNameLabel
	destination.DomainNameLabel = genruntime.ClonePointerToString(settings.DomainNameLabel)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS interface (if implemented) to customize the conversion
	var settingsAsAny any = settings
	if augmentedSettings, ok := settingsAsAny.(augmentConversionForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS); ok {
		err := augmentedSettings.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForVirtualMachineScaleSetIpTag interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSetIpTag) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSetIpTag) error
}

type augmentConversionForVirtualMachineScaleSetIpTag_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSetIpTag_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSetIpTag_STATUS) error
}

type augmentConversionForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings) error
}

type augmentConversionForVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS interface {
	AssignPropertiesFrom(src *v20220301s.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS) error
	AssignPropertiesTo(dst *v20220301s.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_STATUS) error
}

func init() {
	SchemeBuilder.Register(&VirtualMachineScaleSet{}, &VirtualMachineScaleSetList{})
}
